<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e54a409f873bd1d41112a935b730a1a1e593c53eb2f4d3b1e8e5a6b30134f852a3e7ed0300a9487d4cf35e8132ea76d3cea0f0e86815c816c590a34aaec190da0957a156db0c42a98886f3970644a496324872939220c1f41cab45158973a541c2f9257d242c8fa5a74b8cba4df6f131017c4004b170ed03f361a94fb0300eca3e33694c4a9f40598acac6d2cb18ca2de1a2483a06d0b4c119bbf7ec387520846187cce5104c92f6ca5f502a0daa63955329dcb7dd48dde6f98d7fb5782da4b7b1aab57c48a2f9e404512a4316650b27ec96170adc7b9c5fb51f748d6b32372291531c8623236ba09573c5de61c72c1ed4d9a8aeb91ae57b5f2d315a4e8d41144468dacb8e48ce916ba5e3f45645281dd7e6e9153a3cca7d79caf93c6544a6a72cad9fe9979ac4fec22a6ba4209e5ebc8c8e957f384c47c5269f5079b4f6f3afe0de16973d5523d5435727efd5d5224db59d85bc3160b4892e83c28707bc7112c5c32fde06d30c0efd3db831626d4a1992f1394c6c1ee69e020a3373a186d151d7d09d40b50f206f2ccdcd5173256bd00acfbd91ca48fcb0f15346bb82d232d69c76ad57b6eb06dde6dee84f51ef410c42b96a2456d323a55cf33549524ea52df68fc200f19cab62f70f6f72b9b888039c53ade30c0cb86b371f8172eea05ccc3603c366f148e9b4139943efa43733852ae31ac52d95c0bcb3b2850bbda7f8cf32cb091d55ae738d7b9d104980cb8792bfe9355d7d076c446b7ba19c71fae8f06fbb245a173c22a460bdc63d7f981a11654b526bc7255ccc4d4cec8fde55503434ca86574fc63bdfcdfd6c2c3fc964854dcc87af87eba4f870cc875980a05d6bc2af6bc5c93ee3f56f79bac88f340224d3bd62912e770274d143c8997b574811a81978a5816c5fa06aaa5209f0e404de35a241e2e9ae81da096a4b6761c3846ec1293adfdf3df7bd875726a1b4d817fa98c1336493afc974f67a7f1b9307c3b3e7ad1ed1e2e9302698cebc51bde07a340e50cfd06d90c4f60c1582a46fed8f18a497553d363db62367c930cf85e058906cb891335c410c61e2b05df239b2e5e252d1b15065ae154be31bc01c195bf28dca8a672210350a163b55c9bb9ea0c54a3eb60140c5dfcb1b5d9c9dd2aac0594b630603c8e457e3a8dbc0aa1107ebf4b823acad831acac0976ba2e48652a73a36f6027b3ed466cd8891ef00afd357b06f86c0ef01f6de7e5a9c13379b1d576fd87b954323b9e89239bb634cd9d9fce00a1a342a47d301e480dd68b3b267a3fedd7c3ccbfc3f2aaafe33be2fdf70b1f35e78bfae68ff078cf4955c41f0515d63b5306a6f561d236a57a36b58630868fa634b75e148fe0c4871a086f69ec5bdb48cacb4d672cdb4e3853e7246878580030f87b3de47b527b181366f91712d855ef1ac70d1e2a0fb8a0b0df1daf1e64c46fe94dd076c3835f1e7a67cf0735f019b94a5940ae1a28ba335c319757bb0e31f3017b76eea0df021077d7e02531a0fe2ec7ea6c197665a82b5f8226e0fa5acf2016fc79da34f69a26c080fbc40bfa3b771334c4eb906e1aec5ecffa1debe01c1eaf36aa28592949d5e04f4848062a0f1868cfe234c3155899d453189ab0c5a6cf3ffd1f0883f0debd9121ab17c805d9ae398071488ed4fb8d36bc1a030d4aa957c6b7ba45d3ba4e39cc1a82eb458706c07317d71c367823163ab5e722e85e6d6f9d0f9705bd2216e0865938e246d8dea4ee48f4f3b3d9442c8c2fd0d774f54cf1371f892ef4bd439d7b616c1190426a6d56c85bc694a241ee8a831e44ceca59c914e206f21af61898a92fe9e36a2bb21f295aa2c31e108997b740b1b984b09322c4de26fd621085e24c6484b0e039d2c70471146d6b49edb7ca580fe261e657e4b86a68bb532a04f570107e8f74852956f975cc4ef79251e451723f46df67ac402d3f1c4d802e886e495820ffced63c54838d29bdcfc2eb9a9a081339472dd8bf7e28b5d171b99f10061ef0d6569d039270094fa97e39c0f8c6c82a5883ca2ab91d937c36f17cebbaae99107b5436766d7c5ec998fa99cd2341fdf16a849d627385a234078815f27dc810d75755d9562c62ae992ebf125505e54c11c379da5d1fe49685c0b46479e883fd40b824e519ee49c487a4f17513c07b033eb3e6bb6500b02b79a5d4399440a83f432461d8dd0bc8fec857ab9bd054a408d67fa70e7faa7f4aaba385dfe8927806ee9a4600a8b1f3a97a9a697869b469c53228527bcf4b484ee100bc8028b5fa16f42d838af59d494c5cd47e0a0da680aadc3dafcd95f32675d108ad1af28aaa317bd2272a4b7fcff4861acb0e3d40e5c8b35131c5c9f56655bab8a370f2f1ec2141b369519aa56e31a3708554d346f91c7a9ea71f771efe35a4577b7227c7d8afa47bfc3337de3ad8de3b721c43afd381ef6828384865d9953b1d723434d1fb51cb7b94599feb80924d499b859a79ef7147006643c42bcb2381a3ba5ed186d6b0d5c0e4a0117db39aafadaba0f0c3feabd09c08e0a015c80232631e451fd7def2f03d8413e97d1015792076908f6744facf6ad4644c952a3237c596d5bbf25d6bc39c8e3997b8e475f0fe2b2d3e7a0b30fa56e9d44e3bdbbf70f32d4eea07861a77a1835a9042b87ce0f6593b534703a6114084508fcdb59070a9144c3fa6b58debf3fc5db16705947c30d4674795f481ce05b7b7bc0b0e69b09ecdd33a85c1478f0cec0b9e3829a7e662b601346718936f6f78a740531673142956b5b09c89a684cab9eea1130febffdb023292dc9f3782013bfcd951e52ee13ca4a21e1ade6130ad8dfc4564ac7cfd5772a52f725996c438685ca8e8ead975705ab962e5fd98d94b1c26dd430539beaf7091a1d4b34de1988d613f4aab338f982ee17e834549a401b90a354b84c9c4a3a57a12b66e6f1f22592268eeab2e3973cd671edad0d011ba5cf4692542307ff1732d923dfd641670bb2eb0660d0dcf5ecfbfb4b6354459f7a5be1509a8e38f9f10f22cb5005f5c9eb840004e023c7e24925641b509d0f2aa3e9de4ff76a236aaa65713b21be059b12f5a35d3370052fcc53ad406d06d86e6e2a722827ade307786886df681ecfaf48506731a5b6c2415e23d3dac801a3c8eb5b5a7b8c5807caf9f40ac1b7cc3dbfb1f06030224e61427efcff75432a84d1094e43f086b8baf39d03c24be81dfadeb48698c213d8e980884a4483fa23c273c09ba96b52dab03742c1695175a912b7a548860975a6ebf3b79919f8c2e3fb55c5d1949a328d4960b6627653563d5ecff27b580dc84db3dd865d42ef57e3eca397ea464051c40be65a336438cdfde813189bd4c7c8ec7c655fc987b04c9ad4d5867a395f408c22608bbf8a6da62cbe211f97dd6b56f025ebeba0ddd1bde1285ba5883861e3534f98ccded6b0f843707c472817736c65d9a6999fd9852a73337f2483581437864a687844da84ecd858ed87ddc55975088fdd616bef95abb55e45ab9702aeb76fdb5d7d53372bff9d5cd3f4bc333e8f9634375e770ffc4a987e53ea1be10f68a706f2383ff60cb6caaba4e201416c2a16890ccf8746f2d470811a1a3954f5be7c6c36007ecfea73b4f53098e86bf60b4cc03b1e7fea8dc4ae68730ed42cb9d4e1a8beb5d25ff29d69c01341ab1fe4b00b834ac23a839bb181902388c9477ed3b16e58aed084813e4751c6132e998d7261519368b6a8963219b7aaaf1801504bcaeca9c951f702f3664ae3f1585faf88624fcc34a955d39339d18ca61aec992556030842053fed3b941e8980132be477d18fc59b1de5fd99c9f3f008ea3d792016b4a23534ebdf33b9811409d2c245a25c93910fe7ba6d902fc71e1988ba378b5de5f833f856f78fea44f2ea323135fa0de9bafede0f993442b4fe89efdfa42f8099c301dacf76c0aef70806d5fbfe4a68dca8a5924fda1eb35a3dab2a96aa307ae735b5e9b79da978637a66fe481126c337ba0ef2cab32239c47c78599d3ba15590bcc15d9b1d6466f3e7e6e585b38a125a424f6c59e5df339a7e03b23e66332195268f8469d6ec2165c2317cb253faea2e6ea36c7ef234acc368a2ee73dac11a82ec621f922d836a98f7d1d68f074dfafb4581e1aab0c6d098cbadcc67889859dac4966c19665fb026c7398fffa52569bb53f67ac23bf0e5cb234684511227615aca0a757e9a0bc3ef3b2ba33e4d051609b01164da19ed40b3729253e05279dfd1ac60795fa3a11108901883fac4802d792466e1efb395702108a2ee2999454c3210059c8fcb949c20674bb5716d261d7fd55df44c7b00893b733df39fb4a6f806246ce05cdc2b1a0e1127fd2b2e449dbcd673a20e9fcc43a527c1fb9182bab2b11ccbfe7ddfb7868bb7b050927e1cfefde7538b786a57749f830cf6c46e94a39824fe6bb4c2120ba0f7cc5daaa85120af22bf92a18bd063ae3393293c3b58be282f0c4d78d6d00b060429796fb1c63a52de7a2d887added5a542d9706296be59823f996100c3701a4c337be6c3686814bff8b1ff4a4217dfd32959c7a7510f3afa87c827d625eee0955f88243727dbf147787b6a73a8fc4e1917a243a8104a6884f65236540cc0c583b702430847659a07ab4a9b1b6cac9095db32f99cce9d3e3851f6612654b09dfceff5b96d91d03bb0327cc29b0e63e7eb675aff1f400d27e5c3b5cd8d04ef929de21a142217eaab5823329e1be3ed97763eff439adc5f4a1a2b64cc012165db4e48fb4ceb36b93e379cfb331641dde10b8c214fd13e3e57fcd341773a4a679c945798b0fc467936e73523e1a6ea0a23369892bf4a17b1ba50f32112d9f13b998172c86fd6cd1c09a63a35647c98edcc2d42a36103f91392377cb3544bbb3a96ff78180a016044160b99be61c7b01498469701a30c0b79ae91862792fb5d1e8d32ca83fd4be5065022cfda63bacda2cdcd12a6ba779e2aece8b330f50b10209f62252775b196e60a0b93ea177f353077b2fcbbd5f90b2d1bd94a595b2216d31358876b2c623ebcf46f5228f867b7e57cb187fe315975b13ee4b86174c4d8f3d8cdb7ec273aa5624b8de593af32d2081db3b5fce274c7d0d62d60f4c96b99988b88bc176ef0cad048d34bf9404241365f2b2ac65c4a22960eb59aba53a57ba354fa5ac302c375b48fd0bb801ba53b0b6c0547f777fa82b270001f6294dbb1f96ebcad3237f1f083876dba6b7e294d0169daa6e74be031475de09db60d48acf66ef645fba227dcb8df99670aff2005e8e6359ea829c4c4d39b0a9faadfabd11d03a3d7f755b173bc08e64ad576e59a124ca57a44a32533be33e9e43f0fb238ce98ba321a8532a4029015183dfc6e5b2bc81cd2e1e6e15e12405ee76ee569acb1fa5affe34446d184f1d150d5d4cb23dd3a7c6d96bd71091d8f4f60314f2df6300b3abe11846ab26676b10499aa0ec20c9aed8490c7eaccd322d5bae6a243ecdc7b6aa1bf3ba9361dc9709a909bceb5e2b7b08b9571cd8260bab66fc0c9d4afa95f7511c5e4a0a3b6c34ede445fa96841d0ce476dd3638938f66d60aa550ed8afcd7bda4b13ae24e1956d658357441295ffccb90c0a963f60b4134de52b6c202fb94be382a2e01bd68fd51d0b57462ccc9b6f1c94a9f68b4496e890979c7c65310feae1fd52e26a3c303001b62cd25cea1777603379b6e889eede722880830c684eb0749becf31114e570b9106c0c930a799a2d7a8ddd70d3a1272b1dea9ccdc6caeba2159fa133a942df86131ff94ac57e3857162d8ed4ef8ffc316b0778650ecfb317081f7e945d604beedecbb8183b18c333fec75421f2a2374b71b79ff7a930e83245d90b17e2c20cc3aff0b79383e85bd2d09c582428df0721a887a5730ee9673978a39edc07f3157120834bce10149588df1f0deb145ba76e561f6094ad5e73025ffdae2ae5c0d8b7fa40469ed0d77866f523f4138c9976633e4a3243d6a3a591b856de5198f483d84c66b48be3f561476f68b11a39c5cc812bd57b70fb18adc725554feee4f5b6b313c26c0674e8cef357b276d99669c37976a9f72765e54b302b69856b3b091941baf86600af3a183b87245a2be997f2e813a35822ba561949c00c42ed3d0eb270d8b82d5964796fe53f5520be159ef9779a9aa55634a9f5152e0429a94d6cf4c9a9622537b99a9adb454325ede8ab9676a39dd6f163583c957d64dec56f88b1c5e1754e29ad3d8d0ab710cb123b239faffeee578764fcf80ded64159d9c6d3cf1b46b7016637013f66a131c218bbd44fb710d02bab0c4be240eba608d1cfae6b6d4071bfc5ddb5892e3be91b03be3ea0d50a03e6fc93877e09a27ddb61eeb3414bad4da9e8d97dd2915ac873897785bd1e20b536d9c8994a716db7c2c10ae0f44fa263c29ec7f5ff21cf01a39be53c703cf10189d7da300553b8cf31acaabf3f69e2f70c878ceb6621b9f64f0543187a97681b54d7ff04a73f948e031d9501516af8cd179aeaf2042b714b4a09efdedeceb2fa0b21ded47bcb19bce0e7e82cde30bc399977b8514b03a6e661cf8adf267f7390ae6ddd0700cb1f3055224f94debac344f14a78ab3a9c3db6e2c5b167d30742aee5c1de77b0319c76c9688089c9efef7f32b3fe9be72e1660f739f8cff9d3273ba19835d844c575f4b16084b01ddb893806bc55d361363028e04928d9e4f287713753b672dcc0942ed2ec08871445604dfbf00668734dd50ea97bb743a36a52d4f0504355d45200eacd5e768b612dc9d56517f5a0c17f59c7109a0585837601165796b68bf53556cfcd959913fb66ea3dd833929065ac058542edaa43ad497b476d1cc8579ccbdaf6645f844f7e1c4c407a2faf968f3a15e485e1474cd3398ed02c1dda7a3a07eccba91d345fdfdde7b2d1c407031d659ea18199b6ecc41dba05c16c050801177a1cd997aa0d65908a5b1bdabbe21d67f8ea0bad6d76331992650869d12358722b5dfe45dde0c0a731457f391e72572b083aff3db0cfc57d2827431fc66bcbd245e73d6fd33b391054196546494be99fbc181eb56473315d0c413799f6e874ef1785ce7384a2ac18f029d895d3608c6ceb391a12a992138e9738292c290d7b0f7cf4d82b980be404e469ce8c30e916043a5b17973d27881c8e3443ae2215ebefc16473394ce97f81b994147bc90397860c8f473a5042511e97cdcd7e4ca0182533b329fbfcc0428559567a5033dd43ed143b4dca86aea2dc90dc4926bb8a7c82fa230253531d4adceb4c4c8cfe147a12a8dfa18c92629ca5a1b9663bfad7156561edbdfb59bd3377777530cedd0dd3a060aa053f55086560860e471fcb68959107081ac41e847abd3c00ff563e9a63fd36c54273983f3d39e1105becf959f2caabc35ef9e9ec2ea0bb56c38df4e17a4abbc0f1a382b1d76b501072bd367e54ee461cd2956b64bc6ca4564fc5d33f8a178d99db8ff3d19ca40b76926ccf18c30674257ba0ac04145d7b4d53e1596bd7a9d65985f49cc2a5689efdc34e4f08376e15669dbf1050322fba38b9f3bc8a66f770fcfa303f46b8bcdbef74033d68d554648ccd05b62ea7f18157c3df20f271af85dd1125d04f29d2b7a128540d5381673c8db7cda416a2f197b5655c68a10df62711fd98e4eeb826a3b52f91433488a208795b9babb3b3c96bac8e31bb594e615c7fde740090018779441a79530e14c9f6e2aee1257576882e67ef73ecd37ee7016975a8e47f92e8b3926c576546b0de53dece16909d5969e9e1a873ef1e4ccc52b64b839344e46898783f6bd4c1f4354a7f446e726cd6dea816fd7bac874b3a70884737712918ba6ca9953032e08ecca099ee5a3b8d30c90b12de80e864fc2b00fcee63c7820fb7c9cff0c832d2fbee490dc669b78b768a452ae615c8d5b577df0389ccdd10ed4848fbe232942c8ece0197ef7c8c887e603626b7e3a91f07bbaa05134bf9d2164aa651d3b4cdb425cf6c88b0ee39d9082767f27df15e3ee22b77c6a07d9338bad163f13a4ad90aa9479a814f7b67962a79b1f17d7c0dee53cab0b411969f1a3e1c2e12e67b66976d082aca80502ebcab88a09e2d70c731d8e6fb05d7c61d1ecc21c242fcf1e028a880b4dc8e13489c555eac699b4eb5efae96e6c8c3671cf19457aec11c153c579a18d9aad926a3309e2ad219127018a9937c9a4e14b6ba29761332276f618c8f89a63ce3e78d58a22da77b005ae2ff96f2c226fa2fa101556060594b1e24ecddf385617e6b79b9944ef9d5a1e768e7f1d18678ac69eb6afd22631cf862eee4d7649e900579156bc0738ca05328a044f50a88e388a624c527082da90c6c7307fc330c98e40b98d2db3f262a9a1ac09002ddf523b7d537a4523cf8665b5bb36f6cfe174e542877ff3e1536510dcf0585e61d057a80499a7b402ae8ea33b1bf19bebdefb3dd2baa5491b4509fc713b88d61f1469deabbaf9835aecb63d702bc84cd631219ed2b62c978fc0bdf23402aa8665f8a203140710f088cacc5f4444848e92e00904c8542b15a46d40b28bb1c39626e115937d1729023f6d1c71303ac028dd159a08e207e9bfad4ca9d3ddcfc035948901ba675f6d7470d94a44c61456bb1ce1de266946474a50fd731bfae4543f033c1f6a8abecf45bea0fc20d266604d21fff7a33afa7e0e1ae2126d89915febf8a76949b3c337f9cfbbdda623030c5b594cf3d9c7cd6b2e7a56798abaced1653c22829d445884afe7019123b58a0afb213b2bb1384fe0e05b601db924ae2f48adefe8d6a21adcd02396aa3c6e8bb0a169bc16fe7fa1c0fd080064af5cde408b7059bc0acd1193aef81c3a651e15d216a81e04da807910ff2d5a4ab2b215d21587ebe593f62107d3baf957bb7440f362766d828b76fa09e54477a1944efcb84c45d315be58076af44b2b773537545251a0de09cbfe2e7e93ce92c8332232c3e5152effa4e606e954635d39fe0a9d26b500ee661ea23f36894b62c762cb715d4bd918ba44f6900484755679fb6f13058dbc1e6a6fbd4d1a0bee7260f1c13f099a4459c3b99e26f370d9556c05eec4eef2338de8893f851dd1a06541cafde6fb74f3db89b4acf181eb1d05fa2ebb1b6ce6dc06331d811b1894210c8101b1bcf7f1b8f92d8d24cc387d76d1d9f49e414062a7e6f07551271632267e368cd7aa3611304b225d951d11c07adbf5803e38724b5672e795a11ea34fcd1b6fddccd0f403cd6b983a4ad4337a5be0f7ed3ab8e05c29bddcfd83268ed237465259e2aae0188682bcca2b3cf59bda386329af359f919d577f98401465de5c4e8c4a13fd17b63af0cda0cb80e01e78298721bc4772aa8cab0790b9194638d5ba006e3b3899d0448bc3dcb38522ea680648fa70190c3ccbcae23d6d1b30b78a9d62fd1dafbee2962b95e9c16bcfe9e59c854687660c0d6858728386ec962a03468222e82501a14e7d7f26a98a02c99fdf90a281de8a932d7922a1fa05260778de95c70bb0190da9217abafe61c6841c0bf047b3014aaa55d4a5be0bf847fa9c307c2d61aa8bf5ac42411a6485045e2eafff076b1aea413c6576c2db23362509496414663fc61ea8aa96035f80ba1b8acf718bb970f0011283c2986276429af571b56c0d6b30d84882a6937806d8eda561ddd543e6473d7ee1ea093b42d456e259a9b7701abd1ec99fc340d2d732895c6609e63858cfd900489cb804ac49d9e5020903d9b52725a35e93e7ccb05ef30efa0c1af0951cc2f05aa927fe0d2cade1d9bbdfa79709e0c2822642e126c16de1d1bb0ea76cd678575a54107d5f2e6ad7c5dc0ba82b9f03dbca1931edad5054459777e2a1e139cc933dccf508a6b1d9dbbfc2d89e6284e0ee9a13417190cdf5ed4033aa638ee0f9fb474d44b037f2324c3127af70d8da08c4816e2bf635ac2ec11ddefe78f949535571727c928ba9db54c9c03c48869382bcdd31e9be0b47534789777394e63251640c674396435e73e4ecff7d12975854013613e1c0227e325c51fc6a5844aae48fb4ac3556efa7184124381cdc1d1f26af0e419453720c04885f9fcf5effa4a6eb71da2d80e0d3af24da6eeba0f02d6783cb9d569326b4e113c87169b94dc1c2eb4ba30cd31c4546c6be4ce9f4cad9dc9196bed2d87f8b5a5f6a4199ebba5c747de1ae87ccb56b10233a5f04290018cbb2a0d7a14c456b12d25dac538620ab35c6a8163a30913eb62d9fc9a97847834f53c15ff759f2fbaae2d4bf3e463b0d77aa15194e72e7b5a2cbd0745d45db2944db8507bf1c26d026af6aaca20f59b72022213ce83de4daa67db9b7cafed3269ec222268b5b9e05d588b1c932d00f4daddbe3671dae62151af4d8727c6bbe7d9ebac4eae9cbcb203a10d573e5b03462af1e6d01f3ea326f331b298914a8086f365130da0a4bcdf2e048b1bbcab93a58529296cd14a2763f815fa53515810270d7d8a0e6507956942019ca2a28af5d4013bc2f04d7aac024734dd79801d4a7fc176919fcffdab6e01b666455912e8e7549f2db439581097ac54d30067fec2d12e90f015839a5cdc36e70a7ac857a023591ca4d441c51bdc9e3244cc80feae9075c93aa8516b3cd0fc7e27036faf230d4cdf390006c39df956f3ef1d3b06254e266a725a89a7c374f74f371cddd1a9a26f365febed79555df8573204e039a990bbaa3a6aa6d75d078de29090b7dfde9e9d0456f094b0329efe3e0113c28e8f0c679f1c41c8f41eaa40ea77915331f7c9bab7b155b0ee2463692b4ac089a9e0b477ea82e1875b941764d0933cea5c0f9cee3a0c4ad993ab6e31911d545ef5fed2b2dbd589c5712fb5b195676509dca543c79c21ad37f6e054a330e8a7b01d32e9ac9569b86bb79d19296424266115e8ae71b06c6346fe2f9ec62fb86880d8b67c7e296da4d21f7698b4868f0e8ca8a9337c4ad17679f4b8fb9a5bb444b2770c1d8b8642e500864b5e173d782c59d4bd9a203d4ac4aa3d70e62915b3a5ef538d54fd2b60ef235c1a3770adcc3ac02ddbdb464a776bd6cbe3254f94329f28fcb1c40e2ae5da81c9b832eb0fdca5b870dd98dfc68ddb342b86f136fb0b2558f9618365512568e1cd6621649ac49faefd2b362afea407ea0a59a987173db7b3f6b6768a96118e172bb22ed0fc55113bdeeff1c8f25fac0ab56f8d33990c4ddb89b7a86e289efa8ad629bd48e56f08f3e3f0dd92e6e0ae8a66255b787797de45e515088d62705886e25c1cbacbe47d5ca209b7bd5974abf1cd691302ff4a01038454e51d6f48413410bc07ee2d8b84fef6e5a08fd9bc8e7a4ac0ba92a0da3fe11c88b2da28fa07bcf227d9a9f5693958fa749499ff99a21f9c62a5673635b518b5fcc964ad5bf37f9f8fa85f3d54590ee9edbd7f3fb9aef4d6823cc81f8370b24543957d832ef9a5dbff75582271f8436629c5616a0132235530b006a7a1045a110fd92257ddb0b78ae51c3946de5f1d60dd383cfa38660e33652fd0af769b0710b3820d9281e3ace3308b20e851a4eab9bffc179f6e59f08dca40db05528de3bd4df69d06fe3e2e36eb4efbd2d7ecd626df638bcc96a4e381e278bbf93635bd3437264a37a1dd8327039acf4bd7f5a05911dcbf3e6d840932971b6d7982f98d4d9fb3ac30b469885110cdc049e0ef7de49430ed372a5215e221f70079d50c0f78b8b3dac208ddf2785518b1696244b3b3b452b5c7463eed0fef0cb0a64ddb22e22162eca62b28c5f088f502356bfb138c179a2ac5cf7d4424ffe3d313b272fe9f6d4ba35322b500532be4de96577c43fe5e120cb5b574dda26149111c91e2a5163244684c9d2f19a54238121ca0f904d3943943c0fc9b43d856ca20ee4a2b6328ec11124b244789b773bb344ec4196efa019d8a7d8564589b2ffe9dd5a399f1061a898bfd4b8102ea526d27cf4f0d9d1cfd05fcfb270972428c95633b0369424470328fd9c28cc43976f9f1f11d912924ae25f0b0795542d44bc18c61f7271401be193448bde7fe472a8d310c5a2a12047e6ddd5c2a8817c412c863c83f5134a2676385797959bc3018a3e86f3f84ae16a75ffd281b1577f3616383d55e2290c492dcf02da6d6ef0600b6e74a0293fc74693d9d1dd2fdcc508074547d6cf912563c69e765b1cfca5c868fed50e04e7effd318a42bc7e86ece55e2c9f3b5755b3de51a795aab070046dcc4d6c937b79f600758844c2e5b9f30b9c786af61a7e3a9e295e294ddf19a5493b780c1d90f28a52a7eda32bf00370b03c27c44f2e86972843405889d64e8311c611ebaa72ba09857660091892322d9c5a4ebc1367202945d6bff2b7fdcb1718050e4c60da417856c414a62638ddaa59cff7125ada4521ea3b808f1001084904b414824e6d2b51aa165dfec6f1d1c9e7d06c15f9c3bbfa485a412418ffd15ad75080c5cbfe25d0ec4ec13a9d918441c492e8d60854da9eca66ca3288fc6e2cf293795e3fa4554915b4afaa557d912af4ef713ba5e347cb093d869cc1636ca5be3ade3cc62de2496d01c68fe2aae9490ab327dfd252101a03ddf74193eb15daea18bb50e464aea99d24a82c7dd66c108c98a77d32d11f52fbf7eac175b0cab2628c7e4fbd07ad7ad9fccc54f9e2cf5e47fa3d521075698a01971456fa4436e3d1514e4b72f570a2d97a64c15e5228a6e8be34953d008f752b63b20f5855b9fb9f53391d6453dcd9455266db43cb275a70c3351697eaf2ebb110387f1313e907f46d277f21adc9d0ae1f00ad67a2b14450f758ef3f7bd0bb2fbfffbf467e4738b1c09f6ad3d5c262deae46e34b4a221a266c95c6578ed3e9fd89294e52a1fa9f89f573d3658d2048eddb19eba1e3458ae9e32fdb48f88f0bd17566150e02f971dda43bbcf2b00ea05cf9ac04a09b10ca32d654faba4ebbf7d49e077a2f2f8dd7b637a220e7d1e18dbbbfcec7b9d87f9a96074b8a370ad7171c23b778dcd4e79794f095874005cef29f0919a892b1e6725502f05a69d5d055ac5a489f3fd5c4b84fb05e894161bc596df4873aa9f119c92ffc229e491f4c414d4cdfc8aa9e723030d13046c70f847679ea48a6a0bb5bbe407f70b76f45ec1fde7cb3225381bb14514717816b0676f46281933efd82ce7df3843f6d441da7c4b9725e3a225fff8396d45d76049cd058fe5059e0e9422faa00779499d808103e0924434ea06b9e60c05b97ef14baf65d81cc342c0a8f882f4d2bde330adc39814401369f03b5d5561b4c6baabd805de089f43e8a0190c27e264e6a021d26f2a432e4d79dc6bf2ef95c67a4ef1c8d70fc8d58533785d671a2c0078af2ca42af0d05669a00b19b493fe15007854e96785e7e4fa6e5328f582fd328057c122aec3dfa022ed69cfdea5a2118b029541ed96c3c42352cec2405383618482e3d1097bddef72e0757a5c59d160846eebebd664c3c175ef88ee020818247712a4a073bcbb737b74a2d6d684b9c64dbe9f7e0263bbbfec43198917bd45dce0d8923bdc5f54659be5ed363de1db8812fc7d41ec680a8744cc0a0bfa2bb8412211f10e1a515330f52e654204ffaebc96a66410fd91e07f7dc901b1bdfa9ca01ea013b8db64eef86ce00f2cd669655f4a9c05434cc4f77042bd423ed57971d8e372d67722d23c209fc638209527c258d79088cdb46a24506e58263298a02581decba53fbeabed77eb84d5bfe6794a6d2567710036828b0ccf047b86da5b55def309fc253b8e1484819a73180c77e02cb55e53a9acbcf8d1cb445a3c0bc961025646c781808defd0c08a39640b3beb2fe69229233166bd3b2b3c7ebe886ad660de6450123eecb74296c83c68b547ef657753d9f53290e2da54ddb6efbd824f7c62b7e27c80cf1b23c551d85170247dc20bcebd84c2dd4eb824dc0c7065efadbd04169267be0c3626ac3ac187acb0b16d1371f312517e978793074744e8ba2bb10646f801083a1df82e7c74adcf6c4a5d469b057e665e9369de80d3593c6dabc095992db0f01098c2243fb2c09f1b95da20cf28f057192a782f6a68c909f494d495c61de156450ead841dadcdd7b14cd7a876a497d9f708a65c396af512657ee3f283814ddb5bba91a0545a0af55dc32a6b9d45ec16ab37ce8caa02d4846066e93f4e4e5596d7db18a52ca4b30a73aaa2a93bf95bce3a4ff348adfc35ca4ef306ea86fc1f39e421f7178fba02806a934785188ab305d06cb2c9d38555a174f91a662628247a6db30aecfe68ff4da6774a22cba5794e603c799f210d4dd52c95aca12da85db27792fa303b19bd67607beb4cfa4c84162abbfa5f28fbadc2d4c1b9b0bde15e73ad7bd6ae8f330ea21abe555135dbf4faa1f27e47d846847c0ead693c983eee3cf73ad0a2cf936209093928ba845fb2764ab027d52f5acb9f9fe5cd46f300aa7eb921a8273bd1da0f26cab03b329ccfdc282b26602f00559798bdc8e099f205ba837598f58593b1cfa3ea02ca1211b016ab2ac98c4b2f14254aed43139355db51bbb495ec9792e71512477c881e82e1c77975a5763551aa2b1db8f445b4c5deb1b993fed1c473578657f1a6d461d335154003bf6ecf318fb8e5cb2542bfc30f292a26dec7de0fee3495708d66d1b94f03616907120caa28731d95e2ae01f1d42fc60ce12c04cfc5d777910fc79c6c79bfa4fe3b0a69d2970da55a939258dd5a387ff864dfe44451d953ff3541b14ed919e2efa8e91114067c927a8d9b4920dc8c295940f160905cd701e0bda5fbe2bb6d8b1983d068f99a156917a4f67050501263ac91767273c24e8d1dd09a71570fdf40219b1c2e06a6e4529e4989596bb67a9cff0312d6b1816cde52e245d0bdbdd99827bda9f0155af1fbe97f37a011bafb68dfcd41bee22173ad40ac0f0640cca6c997dd85b3c6f3c8797e3b4e0c32de0bf0f250cac07964d0347400097caf2bd520d573cc6e8269fb34cb8a8a33823dacbd9e213d32106fba09aed0893c0cb475c599613aa288dee9e8ac629cc7aa98e93fcea18a978a170aff491629b37e4339d0fb638488b8d40d52a2afba39e29dc3d50b1d0b7e72bd1e444eff0ea86cfbcd830ade05c8d7d61bee5d5b28a77f1e321366770f459353c63e85465fa0a97b2482901babc46489334d8215620b2801de6557b3f8f1417bf20a7f7fb44f9d8f3e67d2a03d311f2fdc73fcb105e7148deea6bf4d71df687a9e367f1245a6b8e8fca33a82e5eb394941c80180f500042b58c9cf5c9aec68ef4b0cb71db2fa6052e66b70844bacda0aeae07c3667cffd0b4d33d2848859230e15b725b6c09b50955a537de18a85aaea9df5166772e78633ac6ad49e4593192f95cee06b96c26abcf21cf0aa8450bb7f0084adf18f07855082a76e41717589a937b81ff20de2fd4d49eedb9d035666c6d5f61050c7123bdd400139f8a4c6f0fd4b40e47dc73b5ef5d44bc3c28a32ced8789dc24b363d168920884bff2dc141055e8b58506d80a65cd67c92c10096e6c594e2d7ae3e8a5e18228c19681df1ed13e9ca5c4d7917e14fa2a4f4caf773c8a00d303bd125004ebed4af9fcbab20f3286ad3f8b665d717c2084b982cde7353543e7aaeacf8b3fde9cf8bbfb822386145cb2d2032d7b614b662b880e7e2f88a87e0c46beb4c20ec50ad08546ca2accb7becd30c03eb7022d6510de171e20ebad418fb9d6fbf219f1ca47cf34f6c5bd08a2f253eceb6fb9b39059ed0e3929c62a0162fa07ab31a887dc277a8355a7069bae291ccafd299e291b123e25cc5f2b22a4dc30d5a8e63c7825d98d156fdef96dff7fce54d8cffc332e08b50c3ebf81ff4282d6b8ef22e70b98d032bdd73b5aa8749d0be039d826e395e5bfbc8365a6425fd9368985420bb1606473674789d3039b66dee0756c239a6e2e800437f81cf0ccfd94ce483026a420f093124f20f9e292979ef95ece98813141559f45e98c44c8e85ad5c894cb0eb2942857b8d0cc08617b69384fd1db8e542f4cf5c897f7d26c8d72cc985","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
