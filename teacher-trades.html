<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0b37930810aa3bed8a7117e46885c5339f0097c9b8accdc4ba0a520990466c48ff3ab98a88ad250bd3701ef9934cdb9eb41429cc755d85f756f5209f232a5fc8cb24f7494ed08fe041f64afeb0a9b98270e62374b838b5c19655a481ac6771c8cf2d1a8f1dee32cfbe6f4b166de1559a6059b5b6fe5df51a5f0f43bfdd03f96e3f739cd3fb793cbe0f7c062bc0e8f9382c7e7fb4ca9a302dfb82c6e0af7723253a7995936d6343959aacac31cb813928e00c5b668a807463ad410f9b4738e7aedfca458bdb14723ec44a207240d72435fe387dc8a98c1c0f90ad6b830eeccc786d86ec22ca0c19da8525e67335951fa8d9d390706e3f36013a421258e06ae87048e1fb4f3aaeee76116a852cf13e3fe2262de26fc2ef5a44b5d177e7f139b6c2d2bcb5522fd91ef78f2b5a7640f38d66c1e97c6637de3f498ee99401e01966ee0a673d0de63f91dd93d04e16f94c04a994c105c008aa40d88d4632c9c6938c9c06ea948f509ce228eb76501d25defead77ae6ca67f0ec4ab99b45588ee2c917cb8e00f96fdae38a0f3cc1735d42096c1826408cf9be3fbb79991f319f4b98c109df45f653fd6f72640af1d902800557b3707efc169a8e05494085d407bb89aed90e7dc918a5d75e2a12335ccac32e59dd22c47c574907ed10ccd53cc07c1f5e4578e34960575947d223f62a3ef67a349e4551935a4ffea383bb25814e085a24d0782d24afd8265e038cac76dbf2b91a40eca0bbb0318e2858da6487eaedc3b7b61a9d5ff8a5d01de57e901c41fed6ac9a8c86e9e81bf67f739b490172a363a66a923d47b553873c1f50c7c6f7a7ad1e7e9343147e012336cc0469c80e4b94bd207662b5285a79740d6a4e21076ce28406475b173d40a7304450743d07c10f0a9dca8fec74b74e450e6ff75ab4dc60631b3faea97c2f3866e6de0e9e306dff852bfd4d247977f2dec9e6211ff1c1f2a6881e90672a7a7c155f7146d732aa7b0cbc934f003ba6aaed0729d836a096723b9262c71c8b349dce877349d8a1eceeac7b303c156d3de7d5ef94cf8db0de23a236c46102a2cd760c3bdab1d529bf6fb563cdc833aa175d12ba5b9a5bd555f42b94521d6a25044b9bda1e253469d9357024d66baddb63185c755b934ec5862178f61c7605df7375e327507967b2e5a1c47988bd146e0ab6c0d889920fe304d851d1b545f5f11b4e8be720a5d2e931d25d42d21d86c9cf0d54236b8baf279be3f78f535791207bb55b7fc23e45bef4b915bfe2a1864fc1d50abbbd20e1e3451a99d381334d5f12774bc079db0982a070374f3867bf1f8564c96dc89679fbd214319fb379f85c543f34e78c7c54ae41cc1b6720a5a560a593c1908c70fde9541e86b8e2ecd0fa955b0a7bb576ff274512cb80d8bea0dc0bc4d500792729c6daef85078ff50dde396095fb51e8c242710bd4573ca6bf9eae9becc5a34f559331c75aa72213e6555d484ede324e24d01cdc409dd2361a1ccda1afde86c862a1cedd087f063edd05f606f09f4d8aa11319cf7080e2339eec75719158b75c83f67e0bd49e24234b20b822b61a214a710627525abf23ca2456bb1093b61ea91810fda58c29eb71bc098efb693238b84d2c5d4e52bba09df081796a30354c71a8558e2b8d7c14fd5f1db459f807f155345b878279177a74a7939cd8d0a41232d721b7960f5e74e1b45b7d51efc9dd129083483dbb62a09b086605c7132fac349af926997123155c5728a30633ba0cd4b30031169172b5ddac67da2b9955001236bce8396d440a93920b72403323aa97c09f38ae4c9d12165bdd4865c351619b9a027f773345d9a02c7424358acb2534f2d78dff75904b551d23e88a0304d397af3303c1328d0bd9c31e6e3ac1ca05a0b05315eddf370e35d77c7beb2c5ead4b770ea9bf27f0719927ca454ba3d2424a87b18dcc1c4cbc74890c363f212ccb98fb524112fdc5d8d12bc9b68dd40b1f0ab96475a1be0e14bf89bc755dd4f06427cdef09be73a53d89446ecbfaf4485f7dfbc19e6bfca81df6fe685f881f2531871dad40e3325d395218e7d2cf01b8dc09809e5221311103fd134b084a8732c5f04bd8d58ea9404d08cf620fef34508a9b22ae1cb59bd1cb684b556b8f6664760f7879fc74baf451c177bab87bbccd52845b84202d90c22a9214efcde37c50363bbb5c88203f7aff9d72d8f9427279832b04f55a7fcbdf8af9b34d0c5b6474ed2fe5c967806a13fe16ee4d3ae5a7bd97065ccf78d37a788eb40c391bc23ab9d49230de9a5e5d3dde865d3ec3e82c6aedcf37dd8a3ad3c923549c775f4f86d7720134d7bb0ca7eba9a15fbf8a70b039bfdfa18925663efb73e94062ea8200a59ddc56c94d5010db7db6ce653d04adf4d463d7f9f7f991ec5b1702b31f45777913fa38541953de0ba44aaa4bd85d4f9dd17c86595cd09ed22dd0b196bb195ddb472fa0fe8e561f03ee7fdebc450ea691a3612c92511558dbf0ed951b84eed9579afafde04abf580322aaa426ac905b5514c406b539927b20ef9609b88b24fba5d5762d438610623e979c6ff403197ef5463aa266c113370cbda291bb2441c1a7d2496973491a879b1b6b886ab4762fd3641a91be5e64307e8a74d6d2207c3089d1136dd301a52cdf317aa92e2087d9c038debe402a151e9ac1abfe81862ab2ef6f69482fa5b909c8d452a084aab758b037d8d2ff40aebf72225ae9850e62159c9a84ad4bd7561c72274a703df49a340841c90deac0daafcbbba2701cd4d35ea834728943889639d8b7c2f66e9ba3dc94a0826abe24c7053f70fa659f1fd21096bc51b812755117cb318aa7b402cc76b97259c2d8c70486a4ac6b458c019bc17c6bdcb33b2533f158284f677b711a30680ce12a301e3bb9c7a400927c0f7f2c6298137ca3ec4073b4d413e98e9d0212b002f5075134821abfc2ccd9bb457d067806fb18b154769a27d88a9e3f0282ae9b58afa44b1d4e930d904dd0abda3cace91b66b7877e0fc96ae7721417ca9eb457ccc6da7224320045d91ef65e6a849af128e60d56e8a0842f1f11a2d0395c671fa69e3cd9d9236cbc96570053f7a3bce838d78997f5ee395c93ccbf9db82a03b5288fa10f6a63b2135c15d38dc4dd77783df379989031098c468a55d83128800cb30a3621aecbd96db9253478799baa604a034569af743f651d1d086ff0eaffd2aafe0e5f67b707075cc7d286fa7a25636ca87c4ec6b1f7112f03df21014fe326f458150cd1a73db343d7060973330f615a6c06ee2368acbd7a80194b6db820a38e9b84aa5c4bd3c21f07aa7648f6793e435a37711b6a4c56e1a6aa2f811d78697c330fbabf9bdf59380ea0af4c9fb4268e21257d0c23b26f284a07b05e960e83be557ae0d474d02795079a6e2c2a1db3c9a7308d0c18d5195b8b215bed02b059c57f477544d2e3a6421b8e745b8ada4cc317cbf8bc9af8699facd98311ee4ded545c543f4ac0c368baa76bb92fcf705a4509ab6701c9c5b9c5525d7d7b6fcfdce27b8a36fa728161a2782b80f68ca4975a3b99368b26cd7cbc4b1e07385edba70e767b72d9a5f637480d21ecc301cb56ca3c9ceb6f276a6a0f4b4bd0fcde25ca2645aa10afe1dbc6833d3765b00e0c6c8377e4747fbb46b96caf5e885c1506dbe6ce477a3cd57c9fa7b159f08631ca0630a143b78f851fdfc46b15e39998b97013eecdc03cd04b802849355bcce5bfa772e5a0b0973d352d018775834c667427e7471c2b5d90ad51eb60208f1e958cbddfec41112f37531a238bdabfc9b0070d6dad1d7c7deba295b79480235250563798029cc96f7dd572ad6fa5f6e30834756da9ab1f7df65bdfae536a36f5a9feda8cd39df7fb9f63df88b791e125ec430a030f289dc9deb731a649befd1d90048bfecf82994eb72bd38bc934176b10328575f842d7c22010351cf4087652008d152e6fa216a1abb3c5b94552c57a87d691c98aad3f9381762edca4a76765e1dba114cedbe0af3ca95deb5b048fe6b81619a4439861b51e560c2fee6aeba5c84b56aa9148d6594e00887e0f3d4593ce8d1c8e74d48ffb0b0dfe6fa69540d8f5b80c67a25e322aee287e5ee3a1afe905723fb1350333c81dc58d862f6ad3f26507ca873d09c653bf910d9caf9d501095b968ca47b147664d94915f0735547bcd4a6cc6b58aad15420644f3fefb537a2f61d51502db175c6f50db26baada98094bb4114a28a7e90b9213c2ae3aa7c4c8687de523f5783e7c8e4a689c3648d16c9ecbd38cea4ad0343c28810a2d2f8e81c4f831789afd00cc2638f6305cd2b9ea370c24d475f897716447385eaeb23c8c988f3b68585316a962bf034a37beb0e289fdf551b8ba95f6a50cd30c63d6b249bb644dfa9e978f5c49340d52dfb29619ef902e4a9b80d2b449cf498ee974e46728c02744dcc25563649d4371e0e8421e5c1fb106d1753f7933d5244ad07268888fc599f504f5b242bf35fa5fd64cdc89835dec4a322a7b27c692f6eacb09cc167d555a21e6ca9697a880eba11a218c107de9c58c9b668096feb9c8668897a4d593ec92651bfef43f177c5da43f291b11fa85e263bf69af62a1a95435f961798011dcbf84ae20e494a1d9291f5ad99a90534c4f7c2ebbf81ae1a8acd3cde239d4b21e7af482239306cc621d575e0182e2c9e10d06176a8c81166d0be0899b72d1b8cbee455eadbdd6b36cc490ecf759859cf6163f7ffa0b02f2d9e235cea03f498dd6a007d743604640b2d71ff514494cf4743325405da9aa3c03d7b73f1e41dfec34a65146a80e469a10cf90de33a66f64f2f261e1632a363da16b0733a5e25024616eb6c1ecd2c6c9d9cd1c177feccbe5f7075ff8b897f1de4f5af31c22ac4241bba92d3b94c5ef98d5cd02f619e38b3633e7d6c1f1a289a08b6fba406f45e0ede1c8cf6a4a3929a36665353c5242443b46f39f3a4a845bb5ed933fb2cd8331dd3e3f188af6ccb5c81784be8b1f3fe4267a0efe17b8c3e72ce3081c67035e95e91e5910a6399e35d863582c06a5149c7154fcc64c4e903608962e43a15441a7196881263c6749c15dadc8008653bb77de38cedcb55b8d88e630469d1f5cfe213083fd7e8c9dd87d35e729c3b7034f146de87ecc796a104db7421f274af700c59c3a9b3d51e87b3abb122bf2dc4b528d75b98d7e0f7ffad0c5697212c1cb6fabd3066c1ead1dd5d6c0746c11c6377ced33c1381f82486325281cd82b6fcd1dc41067d7f5a7f57ffee6eb6d16228ece820702c61d62206a1050b9221e88974975332b637c439378a142b4f589e9798f62d85508df6370cb0b7a5cf498e001fc95ef4ef06e83d90b4ae5bc5b55aecb5cca9d3ec7e1ce1a477714861986e44c2b27720cff309d39722c4ba6fafe2157274a357f36e339d6987c1093078e5072a2cc6851d92d298a11ca608de06ea86784ca2dd9aa125a2e20c910cc845f6e0fe98987f5e4bb21d9d500cb1aeebb3ba8cc921eff2ac243fc6f89c37c634a6cd43703845feb7516c38615f7f829cfb25034188deab30b245e8d8cee4e094e25884702fa9a7b60a6012083f1a9ed2919608b4a400e9ee5381bf08b74772e68854c6bd9eb59758c7b0ad6badc9b340a21a1e9d3a4ed40037d5609387632f57b4c6a61bbe2d76821315895c1fbf373be6e64b57f7f5eb6c0a59f85fe25193d63a1706238f264e5448f3048b0b94c9dae008c834bfdc6925286af3a5033f6e71eb5bdfbe1cc624954c952ad95a86adc6810582fc914e768c3e68ea6f27956b848ff3f1cc67ea94042c14dc387b0bbe5ae5ec6f6b9d49d49a1a33084207d9709e5833d6825f58051a83ec817775db87bc55ecc184f8b537e1deeaec2bf32795360e1afb3ca499b95f63899710c756cfff71fab5d414e4fcd3cfe5b8eeca2acfd0de3ff0df7ee894785369db7680fa438ccbfb5784304bec726677f2d957ec3bef036a4249a8477e4d89041f3ec6dc355741e8f0c25d708c85c5830dc44eb71c6fb9e7d310f1a2c5573924f8a55ab75087b7bec4029915eee24130f37750b326e06591382a5ec4719f5e4ba3f30a546ed4b72020efe62c5b035b487307111e4559ba0da20680108230afb0cb37cbfa5758e1f5c268e61dbe6d2e65b268d6996135a4763b14cbd433724bfe8e4d06d92a581ce961dd6b54ccab583b94117fce3f30ed6f7a15755dce68347a7be4c6d886ab00f9428780fb47e7a308896101b8eb9df65331974d88221747496c06fe8a546a3d99cb130dac156824d6459e1e55ead5a13d2aa23bd1a1d6b41ee576ee49765603365cbb83a5b622ae9fa3c2edfa8cf74f95c3704e4fc9e80a303342feac9ab4018bd5aabba952b997063204f1a5e0b4c6d270f4e61496eb4654568f024ef87a4b931ef83df791d17bbec17b1b40bde09214a4a591c523b34749a458c1604aa79558ee5571c9ba0889963ddf4b897742ce7c86d27c0f1332d71f79ce2b0dd351ad9810f40dba15396172855593e54bd40bdb27f1429aade409761d81e817eda70d23379d82c65d6d9ed70c8fc7e33225811e60ae34a1c9f7ff830d0822eb619eb4db410aacc954778d12e7b430759b816738736dae9f06a81ad664e0f0d32b18bd17c6626598589c69fb85e3aeb695daef5b1ee004e599be0b6d43ad51007c6ec378ff799a5cd8e89b1aeec6d3727f71c34fba39505b92f69fc5cbb369aa32853e85bc351989bc783e31c03d323c0b3725532d2313dd88bc916d22ec2fe17ae703be870ed4bbc82db306dff41d5a486de70f3e14627d652ac395ff7466b51d0a9ef9a9993bd8ece512b27d2200386fe6b7c6bae15d0acdce7ec1e81b4e1acf7591558ddcb4e0170f9ba17be4ea08f1d55aff7e773a65ec5b17f041f2be36f2d0944e11625967a953690c92bab4dc61e50ade97be106cdf03665cbefb3f538b14ef67efcd795a12a65fa6317099de72875d7325a525731afd2bfa3368444c353fc4d18b5ee4858ce8d1f4b729f1758be5e7f14b49ffcc43de5ec61d2135a152434bfa4c17f348797a779cedb313a83c77ece697faf876b94bd96359e1078b252cd09d4638750e6f459e65c29c82048675d4879c21f81b9f36a0a37a01414e49479aead17f06a9da94bf59db7d0f869f36e1139a147bea0b60dd923a40f03551f53325cff76df4eab3726e94f3bd92fb3f0d636649a095eed96cac224cc4ea93756f6e9812abdb43110f3d65cd1f67f1d5d2d122d1c5c989e8f93fadbf435cea91b017a80ed81d082edd8aec0766e9a288deffb5b308507b96d49b0d60f89cdd87e0a11ce65e31c23c4d5945fa91673878668d02d8dc78f19de358e8112ca7d8721831b08f3134bb59a3c4df61133314fc980c5c4aa31af136a4694f8aed92ac5630c156644447066e6fec5f5c62a32e9d37c77e3e208e3a6235ab97e89cc067a5ffd6c405ba9d20d6b5e8d2e882a130a00d33bdc37cd71578c52f8fcab5e638cb8d5f7fa547c6bb901f0dc6b452b52c660959390e5c92398a547039cf7e4c5b5fa9144176e77488e15df0cc53efe0375bca2a6b2899069c4b14ad4aa624b7fa2b415425f815d47cc7cb454d0c43c762f08b368c0e914a4017df42f539a09c6851e5e6306746b88854f928c5bfc75317c35743447ff5f8b12d573260727f49ad26f61ba360cf7263a2114a53cbb847dfd5ba1993767c096d460eaaf73a79f806ece30a52eb35827fcbcd5193829f0a191478d622910f478f6ec515504c18d1650ceac6e4a12075f1d4041c1f4da8e7eff50c112c052b98fe7ec5b0612530b920be4c385d4e09ba80ef30432b64f5343fb7576ee1f0546cd405fdae482754b62f104eb34240d5d19f75195a44060a137c6a9b86abda84db1f497d622222a2fdb46503efa6b727d2a2b5903a3be919afce7b8a49923272d8e6ae14ca31c9705f7e4286f40f3fa8e660fd53e048f526b35dbba31cd1787076c234dd9dd81f6a9d55377680f2de7465731025390443c714e0f83f62642fc42346b1195e219765e336236885ce0c9811b4cf603170084d4e3512536b7ce6a1f18356e5eac71e1c12c651fba56f612ec6db04da3d530a6f41d4561cae77fe21799d9859d30768e776963c2c5acb2f86b98617229103cee1acd229646800169a67423a322a1bc81158ddb7c826765495d1d7e475f2142da5404e84be6ebbd637108627d46bddeb708417f511e9da42754bb9bb5bba60bbbe19c33aef3e2e7a15edc7cb8bc3e81372e5f9ef131085842e56f812f53615f1b7b44f857f469a9484c89819265f839ecb32fea6b3917c88543e64bb595d15ac30fd00be6861453ae8e34ee13e7b9c1f5eebc1a9abf7183214ccc7162e968561eaa0f3d38b079c899c2d60813c2a4437ac1db3e4c3d9fcec792dc1e4fa9edb9f34a566a06a3c8adfbcee7cbcebcce49e49b8f0d157a7ccfd1ca15f12bebc18801c1a30f7276a2c55ee84880eea34e8c658ff8a90ce475854d0f00ef70c80d46ee77c40c7438bfa3cc367680065616698cb3131c5e5d128ff60f9b89d997443b615ff310e5884589144e039edb6dc9050beb961b8e64737e9946b8a48167c08a85af997fd02dc199961cbe31f7aa18f0b34b80b5f4bdbe02c304005e6b1699af2f4250721d668a459686c199b54e297b857ed39acffaadfc21430e414aa1b2c9d36bce4836997d3ec91283bb75bd869a043f5d01db405f400db1b2bb4c692cee33efbc21bde5c7bc2e9e370b4d131a02ce655de2e654e2274e22fb87d3f0780fae8a90cab5b89735890fcdc27d9d948c4d211e847314859534f156b0f2d8bee670b3e4007cbf9667189d8b438b1b40852b409420715078459d591e760fb66345289b6cbdb04bc288f1858bc332199522d5c9d6fb50b8772497e3f0b148c8f063f552e75a6d742688c0188980954319e25b2db76b0f0813f504b9a743c074d250db3793b0db0f72bcde6ba298a86dc9d741f112ff96f3582283672e1b438055a385fb542e8b4e10f8fcba5f6ada27a792f55d3007f8191a496c3f7ac4396d21cbcc6921a05e90dd5739ba757aec1f6bfbf6f31cf8b954fc302b2fe9ba5f2660a7440cc512177184c2f81e7b17b5e9b463dfc307935509663581d97d9ef59de2584900ccc757cf130e3c9d866310b922defbe44f08215cfacba637740cf84417ca63475295b3113a2cc3a6174c325f29c3903fcfd791625c70e4938bbea4c81cf2d988e10464baba604527d922852dd61b6faba4e67114ae9d574d166f1d2f05a837dc93c12471baed6a859781b32bae751beb9148a07ef8e96127ea18422c7ad9378389d1ffd8d62ad191862360d9a6d9e1e13b5021699bdbae223eab97c7b103c1821f19ae8b4c9ccbde008915a875e038065d95b97abf81754e71bd4aa76500163cc13e8bf85a5c58a76ddd7fe4db6b8f68654cf3d39d1288659bdaeb64730d83cc668fca27d4b65e59336d867c44c5ee97419a825158afe32b9160003f4e2d7b3d9d4ca710e63206cf71f466d1dae45905847219a6a7dfbd4e38a99b599278935b72ab036d0e7eeffc1bbf7f901f4239b02dfcf5ecdc11cb8856b0daa2ddbe0ef7cf4af4fa86d2986289e371f4bf8a846e630e1bc349d52c5b03855c36a4afd3dcc9e4ac3fd9f9e15a3c45fc7624496278d26c75fa47d79820a25458402fbe01a62776219258f846602a4fb0bdb0050201f93d16f5a00a4cba62daa260230bbc8cbe13804c25d299792eac3a172427f513c4022d922dccd068fa33f3dc2234d5b52cb3613933580899eb7039d92130c8eeb3d5645bd7643ac9cede43c7058c9fd1a237ebedf8fbe5df416c24fd8cc9f28dd2c58b3b4411b787eb0fa05b630126801c46477b756d85c73e3b9b29756b7a99172ee10757120f927d5c19a096a9671fe54ac5445771a8f5d9623d60398960b498be651f8224eb29bb2d61d1ae350dc5e0ddafa395df5be7bf56e6397681d8cdded9dacd1433263dc512bbf483ab5d6db00519be5edcc5afd1821a7e3abba462cd96818f915656a4c3939eb34c913042ef5f39ce08616982906f4901cc03062569cef5c020f629c615c044d3405bdfc439e7e388e8ab53a700d4c2688f3a07b3d4ea52ac49894ed6c3b56db01f15cfac0020be5f3a05bf73e73a0c899332d055ecdb6c9859c971f94eb98bd3a39d0a2617cd337ee2b71e46a890199f3ba138eeb286299d3b3e259f3179d721b57d5db8c4e1cb9658352b4ff871033d9cfe132d37540f5c95c286dbac304af308439b76ba695544b58420808d31a3912dbe797bcfa0809cd0b4c4b2adef7f218f25d1a23e91445a2ca32cbeea0a394e1b04d486076611c12cf5608c5e200d0ed773d40170d6f5829d240333830f0c41d75c8d637a2b9ee5207538aa4cd6ecce7eba17771767b3cc4f8d16c71651b2fd266e3fcb4b53f68e738e3544d0bad8eec5ed515ff8b43af38fc46b9dd7428567dee192990dff927a499bd438113b046d5e76dfca71b347a86b8ca07413f7d0e4665a6e33d006351e1c18b965c865271c92289139f1bc22bb9cc200c362929db62a79bdfd5ce10cf43038b313d8b50fcae1d4af02070356e7df4c9930ff8c3017295c6567b54bcae059b2beafff3841f8e73390ec90b505d847c3a6b1cbdefeebc9004cbcccef70762c809455ee02607dd441d7d624f1011d6df7080529279997c48ad63abf7d8a044d33fa8da19f9a1d1e653bf57206cf738abbb779e58ad5fb2bb97139b4b022b257792e3b66c9cad2f451c102b75735e28e641657035c4ab55ce5fcc8a17b8930fc5a28cfd6fdd0025514ad260abec8aaf6f2ebf7acfadf34afca7707e46e8a418d3fc01cb1da65b31c06d93aed8bf97a137bcb88d8365f6b58246b031ab171272e4162548d3e66f928b6ad3f373a789746db65dcd17b4cd98a52b9bb1ee11e446cf938f91bea64999b78fac8a4fcb08b22436633224b95021bb741552fa820c745a542479090004695c2f9416e94faf23aeaeb8206fab84b07792b157b3021013efe5cf495d86de35d0b7e42906a1924b349f1832cc2fec0bb926ffe801e0db3627aaa8e3eac178f2536a21fedcc7f792cdbfb406e3e5191bec3fdc656c36d4c5bb2b15df21b5ae8551a0f91bfdcea9d9d4cc3e0439152adb5091971afd582edc1b0af6f1a27b9acb57cafc30b0f9583750ca258011a10d2c226e74252685b0fc6fa3050ae6a3fd783ab2b8faeca9c708497c1fd146afc581cd91814d6bd17e4ff6f4712c29c66e480860c91e736314f986b9d3b5dc7a331d3c121b0f14b102289502ec4431826dd709a4460d497fd8f09d18251647bbd82c44144ee87558229cb735ae5f307533930789a4c98ba8575360e92228ed71b8dfcda84e1337b3554247937524443bf7624efcfc25e0c1d956177a54b6232bc1e805cbe884e7b8f9bd26345df9b6fadded52d13e1271850ba7ad5c2979dec374041b7829588d8eeb7a8e66133b63af15145e229eff180dbe86a86b7e79ef2bf71939153df2d33a114e5d8deb0556dba239fa0cba44e480f40764c9df969d913cea32fd271c10536727dc8b188eae4b25122e8ab2c2a9d3e152d95ba041b6b91e68dcaa904c0572eb527543ff60d1d77182f6cc8cbf336bde6d492b31a57b4e3de12c4bb891b9f09d696384fd9ddd056dcd99e55a21ce6ff6bdd2419f16adea1dadb50dc0e21718db618e36e3b8bb4395228783a5499ae52e8266c6c20fdbd4459f631bfcd0c2f8be646be1bb518388b6da26e9296bbca98c8d90f2ee8dfcf62597dd101d3b5ed32ecfa32655056125a0d1f66e7c7765e9e61e0efe2a3475fad56df065c152332a87cb0c2719e9fd7e58df463080391a8922b4967fa977a9aa6318386f61987a5e2fae4d58bbfb33e238b630158f053c4397e3a7c48b7281820796bcc1536b159b0c18d8a206d4f6794b48d75f279acf9cb08ca94591feaf7d0fdc21bcaab98ae5bcc404a960562d39bad1bf69af35abead89183e53d58471d2a2b8b57094daf7017d38ba21c30dcca4ab6132d40e32f44fb074bd32332452c000c2a81a386b43d220d6ca2784db6c85c39d326e300a025c67e6134bf9e3c8e558d6dc66dce43c88b4ec14dbf9a0a652fa8258dd24b0cdd812a7f4cf7664489d9286237b23c2e879d45458154cbc30d612ecd192b93d4b5efd72dfb3e25335620a779234447af37f86c1cd525bb7321983413c8d2ae51cbb3c541ce34c1e278c65fcd907dd666689279db257bbda708d068b63596d81dc6a0af3f73ea75236ddf61caf2e9063ebe2fb369d25600b000b296bd6bb88ad54cbe2e20b1e061e15e03cfe5bd6b9558d89d0b87c71c5b5afcb7cd6aa1321ef74ae6a35debd4171240452984657bc431a08dc951982418a64dbc2b5d13e8471d7dbdfcff78789789e81c380c54b4f6533d2b86151cc26370a51352c7618ae1e4d5ea8fd62cacf79aead843f33406f08c80fe50df05039180dbee21ff33be5fd4c0e65a1148f1cd5d398ba1c7aca6a847330ba7bb1d4206863652460e3661f0d74b77f9ecfa6a42cd6b8e63c9c6089f49dfa941df9d355777e9e82e39ab653bcb0d29ed9d563af924c89ddaeb5296a1ca390e65784075b712e9150d7718c0b2a2dfbad9867f98fc0321e9640dcc255c6d4b81b6edd74fbde59fa2a3981f8f657701426985a6b5cfc24ba31ca03b3f39f2464efa31d6ca701897d2c9f130d96b9d107c0c0bb1757f389c47db31943729b05d03e38287c239789c074a9270003b4d8b7191d6ec2cf5567acee4da13ffefac31f52b53cb984b8f4566e0d96acabc852a26c2077d9f62387370b18594838f24160d813a148848cb5d8b17676860609162017cbfebb3a8eb6b99f1f24baa3aae0683837460ca54c2486b55c8091e2ccb7da3aaed0aadd738522606fea78029839e2efed7ba1816afdd9c277ab6b6f343582fb0d0c385f81036413b2eef8ee06091152ac9fb5199fd69aa72fb5ce6f860597a5665da60c316483f2b15d5b6880d30051943c63c67f608fb487c63b7d56cac02d96f989cb1cc96c03d59b107396e130bb6f9cd16aa98758f409f61bca8032a5a36f6a8d558293208a8aee931588d2e15f13dfe731e8aa41b94fce5e78300edf8f8ed1b5a3b537dcf8bc190d042c7abeaee7e949d37a87dc47f5aa174b41c25f4d534fdffb2f38829cfe7849c746adbe0039b958d5be668900c114d04aa4847157e68da1e5ab20de3dd9c2a8eee123ae0170d3160af3a0b25cd2eb892b48eff2e9b0074012c29f6b7f5925ed89443c5420aa58d1407cc5bbb98a25277171ddd493d5896604cb360b45f2a09b9ebda2687fcb98fa462d6a1b5c6714935df7882236f945610e77062e9145352ceaf2c17962928449e508f8eb8a02c17c3515c283c4472356de0b6646e05c72bf5be2b28800cd544b0cfc3216ebaf57a328228f197ae06ddb1ea9bd41d48db2533b897987b26f2d7facdc95719c24788d09ccd752f51bea197c439c75a490be5d2771eeb06d244b226281877dee92bd49156872b7df63f225185b1442b798b7691543cc49f499fcbebe7f6a4f51529f6165015e08dbd6c6f9aff0c06ba7aa29e6a5db669ff36eacd38aedf4aa21252c3b6260dbf438edc1812b2d855d71584cd70f096d71084f8329c3f52c9e5db27aa3603f14d42c003ee667b0414d7aad375c32354786a1fdaae3af6d0494a985d213d630af3dd095493510a4eb6d272f142b1c31298b5c8a58618d289958f480bddf09ddc51eb2f55d9ab241194f751c198ff3bf2c0764c394c9d811e1aa97fc66307a382e6651985ac16edcb255833e99727e02731cec512effd3b48d434c962309a18bef2d661cddf288466934f906cdf927ae398ac70b19592519519c9e031b73d5e6572a3d7b62869dae3b90dac8322c231ff0d9e3326591e9aa750bcdbf2f0de3848aaa8d6dabca2e2eb46e079e6ae4b7fdd3cb5a6124fb69c56b69ff0fbbd20d82c96fcc3e23365b4c495aa46ac4fadc9d4c6fdc3ce64f2633673ac9a45f76e710cdc41481f0ca40df378d348a835bc9d5a9a07104bdb414cbe0f9de59d2f30f84a56aa29be1b35990bc986dd249daea653135caaf22381853e4c6dde1305cd9053ecaa201841aef4279bfc250417f9ada","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
