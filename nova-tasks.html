<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"28cf7452c9f82d4160d56b2f0ed600c423becce80808db367b77059822171d6a0bde0d13dfef4e451750cf4d88456d647a8d7b9c5c34dbd83e4f93ee81021a0c33c3120f4072c644d26d55767dd8d872371457f2676a430a35f3f3e23941dd2d9582f888c7c1e74c48519d9355657f30dc491e7c9ddf301a373cef786f43017755a0502572ddc274d44bfb40b70a70d7297be529c7a3b1e93e9680540d169daa46f7e4780cd9c0c802148808f0b61cb09403340f96d88b531506f20ef65e6a16cb1033a04b8e59117f0890d5950e30931a3a65c1fe760962c8fb670d5a09801fbbc043aa6feada19a4eff50898523c374f61ce76b6a2bd968d711e5d0eead26cd9e240ebe377a09da2002a0a529d9b75d0e1cb5ba2d0dfb4c63f324923117714c5778083768922d9f804cb464aadbed663b73d4204b1b8b8c96d4deda777f58f749b9ad8749a5ed92283bd462b4784aa6c83bfed9b30c685458e4e54349e156b9de5caf87d7cd29715d9b6adf4efe2e5c4eedf1232db683f48046df9f39d46c11f7cc182ac1e85897c08a882ce7837fd7ab34a744c827fe7ec8793c3dc912339af5f2be6a85a319b7f77514a2bc55e5e2f1b93bff9532e2c8f0a6670d2f262adf13893e1ddcba60fbf81dcaa271fe04ac1ceff7f3833a81abdd39bda43c8f786819aa441b5e581a15bea43215c55f55bcf9e7664cb7b721e54123e0ad757c2c87fec7d2d784f6251d4ba586bb9e7c6587f8c57ce6c97fbbecb44ca9afa3cffe90e78691aae2e635f5189c61e0a8087f8bfeced4cc0a32c67e8dd98d2fd9bf6a911260a76c81363754fd2e11d4dd59cec0df851aa78d3c07189d470d5b86132792e234aab1a2ea959bd69b50bfd7473f5406accb094f907a3d5d0ab75dbd91adb28b3dc7e693cfb0dd2cb3d065afe681f0173166ed56c492b6330b17c4b7389575bd5edd433054ed4334f8e7c6d6f972ed26fb9377426afd50d3ceaaa6d04a6044ef57d5570d4bf2420791833e970aee051ee9fda2d0666ef80310a8d682679ec242f1177ec26179211c938a7426f9ef9a60ad586ee18d941423b5c582910222a643ad7a855154cca413a7987c0ca62a56cae7373ee66ba8af13e7ef72b55b0e5d3049bcf8720d61ae3b14ff5ef26e9d6fc37e595d013287309e2daf57906f51a9371ea1cd6a40ecdeae9626583cf6767e78d31d5006484c3512734ee464615ba387e45cf2bd2c9f86d596b5f1e15c4bfd22bac4f82b571c62473c9e3b2d5f195efac1ecb67a9813f9e032bbb0db3dff5318601dbec925c7984b1756e44226fa47e5bb0746ba0f89ce00030ab543253a9a948d245a0f205509e392c76a69a6989a120066f8859d5e463a90ee7d6406afc3fe105c98ce19adc67e8a92eac3cfa7d5903872a19fbf8ed6fdd15b4fb6eb91557a63efc752f6fe86e65034dd45511e06a6231528e5da6d22f7ee33f7beed266b8681a0611915fa720c2f6be5a6061ca6b4f28d677c017c8cd9a3af9f53b592e52d82e717bdd33a5f6ab5809acb2358bda7836508ad321d8021ed6de2a634b82d985fda661dee430e8cac6e3d916052e8ae49d7a013c628acae6349865a2680b8d8aa798d25f8d4e9421f470779bef9cd9c25c582604d17c27ca08d1b15fd2fe6f14f89a5e6b9e943ada87b1a126199d226ce2afb3439c90f20de91e4eb2b2ea6203cc3bc4f24a78ab227d30382c7ee2f33f48fe42d81d544c888e987c63cb049c6947a0196efa63fa923c6c107e90cd1420c8c21de3ec82ed8dd5a336fedf0ec3974604398e69997b7e8dc1cb2bdc67ebf59af6644552e6b5d91f6d8167eb119682ac24617e9b0ef6faa92218c41e94f6301e27ef0edd3e3035f7473f74d18c14f901f16f1dd47c3fd939a77273a2bf999a6065d32c6f16e8e98026bfb64af9b346d0d26896020af48ebcee9589f0aa4ca888b456ac6e124f22edd4efbe51286361b20db6c11c8c91a51532ef98148d7f213a2a00411d271cb6600ee44793adad4bdc62c9efb678ce2bb2c0efa575fff102e212acec761ce644f131220a58c62233a2c09ffe9cbf9c996e0e49052db7762abdb7c2046a20b120c9d3f3aa16fdcfdf29a281002dcba03172a66dbd96bff6ceb8cbbfbb83e498e7932bbbe16f02e3f2daf004be96ba2df994b1f4ad9db96c241618d5488ea3faf06d5ee92fadb81dbbd1a8c590c15434652390dfff9aa4b230c16ceb22d25d2078ac57ccda6c7195ea50a4df20aebd3c768c97fdeee5e930b50c72c608ab8dac96fea690d75b2cad750c7512f57e314668f77bee34b63c89032062189558a22d51b6fc9c321b9341e4f819f6509abc9ad44b8fd07658916cc1159990fdb8905ae8a04502c6b66267e9c225d01bb4a358e4a529ce7ff451bb0d4fe5899c06eab58167bb56e02982c8abc64b7798951b4d8f5614d66f5e9af530147ee434b04726ea193b33f107b0ec316a7e30ff0a2d3d8900b92833367e284c78ca2bbd818e72864f21a0566a263067f91cc1576b135a6f3a2dbf9554cf757a2e3ec7c7d05f537655be0d856add35b8947722e5aa0097d35f6bd271724c559a9760aa06251e92ed84704a9a208773367a752047c46d1f46706f12ff0de8dce848998d89552e9ed80031d950cd036ab5095ae3f61caf9f93ae814b09efb12ecb377e1c8822c6316990b2ca960d98770fd8b1865f3f630733bfe4e6a57ad30602f18274840ce22975346e93cf944b200b91a6e0d748ab8bfddbfbc39fb9088bdf2af9dc7e7ac0cbc2fa1bcb3d8a936d36e7f90c5e7f1f0ac8d4836098d0910ca2a2bc1257c57b2ef80d44b7beac865090cde0aad2aa94cfd501b024459dfe59582c6d398e07ac974ca42bd8831be362e185e9edafd1825f9bce653608f736e838e7a458f2fb1c5c431a14777fb519ba20ef9ad96d77b27ec49767f65cd5929f159f16ec1990dea04db6b598dd63fc1bf975a735eaff1768f1dc6bd2b512b92ba885209f4c2d039584fa11df1773863eeb7348d48c85d1ba1f2d8fcb907cca137d0ed33f46e4230b78f3b80db756cba76eda705ad1b0284aa6f0bb9a69de6a9e991e911ff7439b6c48b2a2d54ced5eca8cfcee74c8ae021e9e6700ee669b1ade3b8e89bafdbf4afac457cc18e93903d6b91f7ff465a6617902d3c017aa83a96eed316ab5d016c1917f13ed322244534d76ed472eda10b69b3b4e0a2498e12a8ebc2d826185ab7938008f2080714f7fde5cfb631564885e91bc571770d85411f3d3b0e1ece163d3951d5b14659e460eda51988e21a0a3bb192b1ba8ab6dee2b6c1381765ed33e36d3e99c7b9c70b129c32e5a256c7066189974f6b636872cc4a63154a17d72e6028d49bb2608a39f5fad9eca931dd3b2fbbce35dfae3a71fca092fda8b1e17aa3ff06a704bad9253b72f104dcd8ef750622a7e356a99409ea7bc519e2b91a53eef883b2abd51f6da502ce7ab42e3e71d906a1dca5d6cff9b4ce6f2f3438034c2044a8d7cbe01ce1ecf7e1f797f449e1ddbe14530dd324343b1ea9171c0e44f7badc1f7d41746f99b89e95ce2b26875c6b0fbd306b1cf429eaadd6bada987c36bc45fc5f9f9f8c454669013472796215af9e23d47cbec6a3c2b8102c01bd629dcf8cc0627fa15ce56ec344291ea3601e25f75a17278bd0386dd749f9afc887b151150cdba4b789a913ace82482a8f5cbce97369190a029ac7cbb1c0bed9ddfee80f472588ddf699eebff80515ccaf8ce2980b3ef8f643919b1b45c88acee4e2f8887dd612f3eff757584ca54effd4a42964b5e1add58eee409fb6a20605d0f334d83a6b2cac38d0dffb71c6757568efd982670283ecf78ca2cd4c590679ff329fc50d40f0146ffc0d16b429858bcfec159957ecb99dfbc6dadf97b5986e2132774331976355e532069ee5bbe36e7644c2f3bb73317decb8da79beb247f5286d6cfba2b2972cff6a05ca595def4817594d043a9d5cc4b66fde44cb87fe0b51063220ccf44f3659c75df02a2d770714635f0af08f7c6ecfb51b039eda1c1a4471bdcfc95ff31add43047f59749863e5317ca950e3bef7ca9fc1af568562d8525ef90cf0b349d0a9b2b1e08e2435d0d884643a395c15bc675d3c3416c41ad2dd3fd55e6768e5d12c5644a7ac30325863e6751ffcc474d56f9365c51d2ee9b82bcbd5c305f386c3765daa884ebd9b3f2bea337128a562b67c7d452b9515c4f1b7d9f03d4b46c67f59d0c7e6062d8c56228911418fed021d4a82ffd510abb460b3b8360e2a4708c398ccbe707288a86cd7369b4a651467ce8c784ef0a7cef3c2aaf02e07422e85c2893089ba849f7343cd4a9802b319dd4ed016dd4fcd1ad17407520283ab7011122574cbf1df7384ef389644f0e3cd22bdf64ea990fde95a06b903ccccfbb72bbe988dbaf656cc9ca193d4a44d1b603981249d01514926b7f05fe91afbfc49b49b5f7b2e7b92d2cffe153a83b0e6dcfc6aea137fdd7012792102b75bf767b9bc4639867bb8453c5a3dbe972d1ae61f511f321533d0819644b4a1c03c872b06dbc76161a0c6f06faa0ae758406cc262e13b132034bed57300c3c23bc2b6dc8b4d8df83416940efb8d9fcf024727d84b494aca1c6600f15b8294a7602bb854b2f38e43b3f9515b904838fa24d89b2ebe020357cf7fdb5fd742bbac9039ea2b48973364188bd168f81734805497d035088ddda043e15fc27a10d576f19f6a39395737380ead1b0d23522cb959ebef991e035399fcc17e6ab711eb1cf29e09081f64984380316bccab6789720528a4e3538451ca0bef4259672a93b8fed06f1c49a1a9c8ba6df313cfca82496e6579d14a8434924681147c282557e866bd0446ca7295c83dadcfa20dc0849e359dfe90d3006935244ba0570839fcd1af54e47d87209c22d032e5c7994f1d0143bcd2ae17c42255a92eb82f0f5159cb76345a645a65ddd1d5b9dd3a1b99a56d793b54b328ac1ed16dddbd5a217e0126b57a897c9eb31594b1f284d04df5aeea7aacbcbd43a757fee3e1f0bc79b3b56b06043288a7b32a29193a9c5ba76d178fb3fece625c766d665d20d58c794d45cf40c8c72f35effc37ec8bbf56ae7b68ef5379040df9f3b28bc44d60cc7420c5a3d0fb330269f14409a10ab89a0f6c0ba16f5b65be51db605cd48b8a64a2b0d165793e8f71c8a4a18e498717828dc2a9b1cb2cfa4778bc584d83ce5c23f4c3a7ca928ac3810f19becedc96b6e837e00e4f7252cff8000611c15d08be893135f95992231fe4bbaec8e95095d90e883f67372fbea9c19f44c478359da7e8f00ae148830f861783bd91764a2245880c20d477e7f3185457ec22f844651d53a6f2727185c2378ec7e8a36e775be0d73ef4cff0424c38ea2f504b875f913bae499a78eee1c25eea528504e7ecdf6cf3970515c1382826b71e5d6aad9c4a181f221671b2282a0b12caa88fa17d3578ba3cc8331a2d2c886b0b10c4da9a6b7e94a7fa5965826df11c1a069a56b1bea41c5c6a874a38477a959f9e537ef30844caa8dd4da199678e21c41ff1741c1765efdffa7da41da9771ace079086633ab85f8c76527b4681ec8851dafe312eba226d13fd4d67229b1024e6afbfbcf542b326be448ad7dbf8e7ba91fc1fb364c15f9ecb6d04c9676b725613f035970d9e69e37a3d738ffa5bcc4d9715d939a6494c09db2454283a4c16d13bb88dbde555696c3db278998dfc99736a9aec1431fb2a1ff796de6fcda2443b5b73ce570c610c29d5e02f504cba957d3644862cd1cfb35d3979302210b7b12a2548fb93669364f163c8cc2d67821452c7e266fef9865ac380e26b9f4a13e3ade65776fe2ec7d996a3427c67fd0ec8c3244d37b628bd929851e47eea18a24765a1aeb13add78039a4b579e570952ba0c934a380d3cbe344485c46270905aa39c886771c0348227de28ab5614dadd93b06d6cc70475f34a75b03d6e6908dc5d529c40c89d6bb8b288f13cc9ba7fdd46a2eb167570a4ae3101cd7701ea2f03a8c7ed5f3748ba05b5369fd0882da7f2246d2144095ce81f233b4d1901a226c9428b8fd2ba6ed4e480c46e0f15b724893376b077f692f1f14849aff199d51b4d34cd45f3206be71e9e02bfc09d5852e96769326153017ed9b20749c8b91c4e4e6fc7ee6394fe86b3fb9f00c7291eee3772f6a6a64cda2386429bef1b56d1dc70ff2e722952ed51db0bd3d951a8be5cfd080353ca0a18bb3432f701bec0c38bd35b75cd8764dd25b38ab6946df8bc36dd8c6a96f73010e45cf958339fd80e4cefe0f79be25af073ab014fe0e47c18f342148ff2be1943df11f8cb2a3e98702e1aafa27887b180b051eafdd7e52fba352bd3f9a8fab9060938fb7f076e2c183bc0f8008a8c181b6d03f212a7e152f7c4841f3ae56ae8e558605bed87468bb71c706ca3fa2bf3bf96d1922d256ef090ed73e958fe20bad5d1621b44310371c5d32a4e2b358d79098a687d5fe79df263023d43f0a8c58132098ee6f8467be1f92ebcea487b7221cb514c3d09b4f5701c21b991cd57a1b4ae28502d5a7e3d3ef4ccb3b52ebd6232d13e636fb0b95a26d77c60c37dab404e4710f8eabf76218fe992604ef4a3b9cf18e70e86ffe35187f951c7bf5f3ea7ef6448f3952a882f48df27cf1d32163d1bc777461e0a4fc9a4c0b4cb66eda736a702f6ed1c3cc087441755a466cf1f96df654627a912cb87bab47d88b4d2436051e7f308a377f3e8b23e252c77e2c1777ded89703055f57966508554cddec10fadaf4adde55159ed19e838a6b51c62cd3b8bdd4bcccf5e2a4d88d1995c2776477c2685c087474a96e7c25fa4385c251ad26519d147a71fa6ddf909f2e3986bedf795c4d9f2641534c1e36835e50a83a180b8de1f14c85e0cf8446fe2a3e1017a3b2092ac40c0120344323ec95c2e588e5fe9e2409cd52efce0884e66e36a71579c739fc3780e694e81469ad0dcc3743b866ca8964569a6d29ddddbfea74068bb761a16b747d8b16f26c313b0d5d05101e256a6c410c5c8b59acd389e90450fddca94f2c3f6ba20ca21f8ee98a0c8f4a4e4d13af94b108c2835ee1bc833ccce67372c5df3dbc07307bc077d04232cb1557d29037da43c2ade1db001d30d51f18a0ca84aa4c973ee0589a7a9764e101b576bab377bd097775cfec0d42ac429ce34c62b159fa370efe857a04ac32905ee0703c995e941acd8d19012a2e066b9d893cc96f84c10632a7f11c3bc4763cd36d6275b4a7eacae60b8e7f478808ccb0096e2a820f4448a1985adae6f568f1f8d23e134ad3891132f67acce22abf487888efa57ca58794ba22779608e0041f79a091f2e79175b4f32382413e6ac82f1dc10ebea21a2e36010f083a8364945bf4b2d7ec0f3bf2ecf6b5c76d5f97c2630ab7fba3d5509d536ccd0f0b0d81099e9441444e388d8dbff2f4d72cf8cd500cf26a6c02e62f1c44b04bb0e02abc0638b113c01f0788669bdf3d77dae64308032c408150d163c21651893df90b0cac2897ec89230ea2ee205e63acde6010e158051b49cd3180624d69dd603315da4f284f1ceb54ef771add47ef13f70e22bb8e7e30b8c5fea5383fe2b4d18a846db467c4cd253885534a34a18de3212228bbdb7368e180125495e103a39006176f217a1dd1f6e66fc1af0a54e4771d88809aeda9680dfab4cf134b6b83bae631f8a93401c6f29912e144f2a12e4718c23878304e26cad6f8e606ff15f3d5aec0fac43ee18f92200e5e149661439be46261ce88952561c3fadf192344db83e5f36e306f8319c0d6a062de2e6de404166a722e2ff0355009464ae42717adbe430e12bbf6476d8f82930e1d1fa29ff80c8557b7529d8cc907f3ec7762ed60eb752da1af4f9b05aeda244d6101ce9380588742120523eb91b4f99cd96686675b6a036d961753fe2ed54d546e9921c2ca5d3689cfe60f92b51dd3dce4ad642f14fb2b5c91c565428add3c5cd6b6de5edeb844b0d06e815f3bea11cb86ed6a4a24dcc2b7fd235fb4197b7163563c0fb003c17f93b1dbdfd97c3791c24927919aa831dc8e0cbf20084828b5dc17f759e1773a6ba25274ea9cd41434efe2b701fc41b67d45f7e6785a681357c826895e66d08c8e356636bb6d476894c4bc94a01ded5ded16b1258faa16b65f93cf0de4e6bc25d88964b8fc5deaa0661c5f614fb621280a63dc3c392c93d231a3e21d48aabf5bcc7a4086f307d159052d5c1954a2b33452e56d5db6becfca133b3632603463a6317a76b1bc3f8fdc1ac78d1eb3efa62d8552deeb426be48ddac914b1bb4ec7ab31331680ecdb07193a346800bbe1c61cbf6ae15e65404eb60e5fc8d4a12b0c190348152a20964a19506779687153084ab11db618c16f4b4035570287bc1d7021258a09974d44574eeb702cf51cc112b2fdf27f220ecb1fcb077b68703389c80bccd4f454711db1275ae840984dbb434faf8f5fb9f2a75778c03d838a54d85b5603b78b9a3ef259a3ffb53f9e412c159269dffdf7c686c51a0dd047e8c8cbaa600d82175299e83aa9fd6c1cf9378665fabc0c0d0921a3941c7dea360f641e6e1554afcdea1af1bf87fd930a83f31e1643beca292ec7251543d33021ee1fac165fde3a5295dd3dda1f5707b9111f14706b2836f78086112bba0e0799245402f80eb24d3842f651c8629e67ca128e7ffbebbfc0f251e1324286490f4de48eacc744030e4ff64a0ecf080c50805f8693d78e8f82f8bf0ad2da07f684935581cd1e68addd293f260969dbb84e5f273901617fba38acafd7afbdca0bdf6172e6c929bac276b1f4b27512322aa581f8b881f3104d7832952984a122e3cbf734d2e4adb862a0a901a6f426b2d4197ea7b8ff86bce4b66db3eed7fd15b1a3077d85b76ba2707b2d70e69f6bb249506e01851e17a65026483d2fa8fa78fc9ca809627a2b5f004732d5b9788606064f102a70f2e3e6144cb2e73cf9f2151d6b45ce19ad05a563889aaa2b8e7358c1b58ff45124e87c8c6688498c1983c8fdf8a005f1010caf4e445a1e0d9ffd5121e4b073bc94d9760b69dfe763644396dd85431cc52fa7eedb949e324b0f4bf61f75555b6cdc9195ff3e67cce581d56c77b367ed48514e9fcd3ac0e21b2b93410d744c9a091def2a9c671f95ea2d4d0c99cc258cd4991cfa762a3d986f27491f87923f8b0edba3366ed33bf98c2d9adc5fd2b7059db862dac93f4eda052cf1c0600cfed278d4f2da98755289277d1c82997448be7e22f00047d5f4e0c058092b157a510f1b62159d7b47b889be5fbf26765d3543b4d84e6a1b2b74824984ecc2e3c2f2a46f6cb91a4d4afa58bd9c1c7db98b08dc62e78cd1a44e52e2e30259b1aab5999c25a1760f5de690a9ef66e9afa9c7c578499bfc1466880e16c1dc3d82f0cd57f37a0d13033f81553dc16c0550310229791bdd66fb3bb4af8382bec0290d5ab4a2d2f065459b106df6cb4767a9cab1c04921b148c729251a28021065e473da9ae70935553e9b39cd3273b70f144b7cf48e198ec28836c2327b7b3c5e88427b13b92904b5971da316da746f431383dd7ac2a0774c380e81bf5164d74a4ac497182fc1f3afa5230115c53fcfa58d942cd58d269dd2e54b033a5ce62c7c0bb2e3741fbbd9e38c3759d9f747a00834f18765e4c10e4f2bae31667ffb9c91257e00980495d1117ef04f77467b1e4afb0630244b8cfb696fc9bc8e866c2393c38f976ad4cfe5afe943d7dfc249ce62a71a1f28349d9bb2506cb8498bcbc666bf19d52d7fc358204db269a52409ba908832ce76846f94e61b6d32c448509b9d028d34a069ae28d864bd57f4060a07394ce7c4ba7534e7680f4c83c11e5cfcdc2cd2c0b64c4a90e0ffaf92bd98fb3a745baf951200a9f9ed4aa7b3f93af2ab8192036f3905f5b1508bbdbffde2ace266f9edca9a6adb89951625e8edd4e34bfe0d4eb5fa3376e030471816e0c775866d5562b50befac0f53e14b20396a22d2c61da9e2c99a10fcf3de6d7d4b563f053131e320af7a4c5b8273fd578b7c834a83c42a05476c4cfde4ebb23c5427c648f175f319cd190e8c6333b8867a54f479c563fc63404805671d1c7353222824ecae9db81b5763e87e37c5b987c19cb7c412ceea0766198525e8280a5f12c01518e1407793e58f91cbe49d9e187ac4b15dd106c2d1e19fefbec282847b29a564217defe507194e8d3f3d42c3ee3c59944127b5c951d648ede7e22a6e40cac6c2509d8c9e0603a35a8ce7794e38892a6d0df42d8e8a5d80fefe1274de65a38d2401d1b6ce5c59d4c1b56db11bad3e8a486be2ceec4e8edd6d2ddc1a17765d92e7ec354f4fff7b185f52432d7a1ea437ebdaa14c05e7055384eb164bbbbf5dd150f928aad49f1a3d9c8f6d16da4972b83daf5bf74b8b2a034422d1e1e9b405876567e5b8e08e93f95ecbd6ce43f1fe86b989a67091a7f2a6426c05688158c0bef7169f9cdd9cb47a912af4e4c28a243c8039fad6f8c4959f821a91ffc7b39ddd5777c6def4d887e9261fc1cc10383ddc1d4ddc62f72e5793fb57184dbdf692a106a529577a6588a697ea06b8373a087fc3cf71893a1498da185908b7079ccc977e510577cf511b046d3cffc50bb2e75a0cd78927b43eac73362dee0c1e40c18b3708eb2b0c5f5c22a3706b2f04c714fe8d7012a2fa8f8288a68e2200189ee80b1826a7d9f9765015d3e226dca54ffb8e86347507bceafe334689fe6f6b9eca01e9f2c1cb54bb81bd0dd01379da126f010f4a2943f19553beb3a56d8bf9cc8800d42b3d869dc2f6ee9b7f2d1cd2c06c1b82770ab501fdd2a892ea27c701f8853b189e1c7760821a5b9377429f2df8496eeda4b8c62faa6ca21abe4ac4cc9e552e2eee8b3244735d2e3f166c519bf54c3d4236c24b0a6b13fbf2b4fb5f9106ed2232bfe92d5d8b2ce5ede1d301a60c55083080ccbeafe7bd7bd605fb35bc7f282b6532eedb56c661726de21ec76ea0e42f7b490c9f5e47214fbb91b53e41c04943530741ef9ec3b54c32e1a492c1eea803f4a4b2647541be4d764e9794ff1424d7c5ee8adfcea28117b28462da582617744eef4eb3a1c719434422d157f499c0580eafdfafeefde6c2e4a4d2e3d16e2f1a91ac2a133168e625bcd5c05bcb4c77bf3f36f73f39dfed13dd22ceff874be741d8c78d452ec34657c16b20a9ff02cd67cf955e8dc922144a78689c2dec5f688ea72a63d4fb8a2110f86b264f1a2de83c3258b3b1009d1c4f199a5976b1f41fe9364898e1f3de5f44f10f94a19a9e31feaecd5ee42bf6a5849eb9fb3ea06b863be402fccaa587ebef2b15ffaec29421c19dc8f33889aa9616a1e42fbd227540093426753e05e79ea6f884103d90aaf0ba76eeea60f9c560fec083b81e4922d410129c13939616fdb80e09c8857e1472b67318d1c3a70ad3a1c491ef53edfbb8760d5197cbee5a74f2d8b9b33054cf257e090ac7d13238b29d142b4dd99771ba7a6e433ee4c85f0451569dec9bede1ff0b33624fb7c3d1d7d8ab8b75030071b1b530fad15a0f2e2238a2e445af0f65d8821d1c82312eece673d4d3ab1c00213963dfdfe9c5e4e63f2ed54f9e4e432a5e951f2d5c6221d579f0434c78928f1a45749cb107d12b6b14212a4d98cdf99216d6018fa8b1fce34983fff66fedd98ac839f64e22ddeeec84cca1ac485f5800aef628d4ed0ced6c952ad9b83e6f8c09e508627da934114fb644d83feec4f5ae2235394f6f0ba8b7aede5acf997f6cb926d21a497f2a0f0b328042ae2751ecfb509ef6678a2ce26f1a15621a97e9274ed989e04c788dbe1975f68da345129697b5056002454fcecf1d6ae3b2949051f44162c6b1853558ba038641271b7c68d2fcfb87865dfec1ba1c92456119108b128fd935462bc11d97c2376f347fb4b61ac9bfbf591a112573a77c42cb12ecf2cc38e33d4bd15179bfc35871c0ef90a5423b936526d8145b664f8297e04bf146c0210ad5c5fdf4b79dcd97929dfaff06822755b3c01c0e28ee33b886f446f09bbbad4b65af08f1fe4e24f8e582a89ff7b99e1b26e016f184869e3646c08a59ce8b549eff575be107340593498aff88b3f177a126c71a7671bc96922d9b0787aa27ff69fa4514f346dcc7112be713cef48753c965a7e80a0e71833d2e6146301983faed986d9d64ab0be13a4e7d907411b70aaba65e78d10b2f3cffff2f497efcffb1e3f18e8ffc728da9addd6ec9392973c3936c94dcbeb44c6109f4c181238e25b2689907fc9aa5a9032fc241f57a2887a6dffdb3694c7f2e72ead053d9083dde7089e69389729f7fb25cf556e56a70ad773f4e80f812fc6ceda5ce70a7fae5d1742e6b247349d626b0f5cdda47e67ec0369d0c4ec883c4ea89514b0d0d00362407375e794fa55105f6527d3740493dcdba0c3bdfc5c46617a3417925b4b8c3cddb54f628c076151d66e6237d62240a825b799702c2cbd123e27802149bf1c366ebf60fd485f90b0bd924f176c7afc9bebb642b37cf8fcb3d22bf9050739f4df9d3aae18d26d41e19b780fa03f9a4db80320b40330984a864247fffaacdf31a6e0658658691e8b7e282dd9800a8e547ab819c7365ab4c37a2995ed2b96d94040338c7afdd4506e6fa567dcd231ea7c67ca33014f6f80f0e41fb0be4643a2884b425e50154283143e98b1be89accee024090ee0d62576b8c41ab3ad73deec596951371e18a1371819fb9963a2690db882e89cea8e4a86f4e1ac0dea2df2e6b0049b37fd346dc15d9be27ed42eb14d26eb1b790a356fbc47b511efd892d2f5bd9cc3eb4cd4391bf2b6851018a343bf39ee65ccc4471ae9b6dccec6476bb1deb9af24df832fb0f628842ce1a17ec05861ed304ffab82b5c2e300a4060c5a56c22c8cbd83c2535700f0d01ec5aa51551f41497abd521c3c8629de01cdb4a817326ce77a98d0696ae9b87097008b2e14013b6e0b84e695102705e07aff0f682a84633e44514caeb370e6d9f0497b9b32066ee8a9eaecc4db5043f5781d372281699d096c4859c0f113de9640cb9d5b3d208d68dbaf45782da7a8b685f4d5a2da109661ff207d92de0a204f9fda78fc4e1b81c3deb0d80821da46cf961fcd1d24743149a9362fe7a1b697cc8f6345cfc0dc30d0d2f2920675331adbe4a7b8f05b857c833454873e393aa0918ce5a43927ce044dfd626cd08f2469e193f481d59fb12a71245382cf5f8b92b217fdce6b9c85aa889426f145f75c512f4228e83d5417ab1c791f3cb6adcc10a51ca76ce8a71b97a56719206528ccd7a27bebb04abd2729a0a9d615d5054462d12859957d0d2b62fff75359ef01427427677dcc1e5df518bd7606f24c6fe7886252718f2a81f889d66bd5c9dcefd776cfb6bd2d7f08c4eed189c0bbddf49154904924d21e27a8350941b83a82e65002c9da5f9085250817710d4118c6ff874b118d65d443b18aed3f106651d8fc26990f7581689f96adcf9115405e3c72e7d71efb852e5d3559118601f70e33a6d1bd9f9d1b88435810b37d267a33bf5682a07c7e1f6f8c8406b5b90c0b2bada881e9b86bbe244753d5e1d82eee9debb4a8a79ad57a55a802d2774f3274dbdcb5ff59bf1d54beed19f63ecb799f2851beff634eeab2d950c6df3637e42f17816296b03c47141d4716da93cd59acc3b467b0d3e66eff60a8db25aaf7ab56369b55ee6b2f0b7f8331cdd5a493ca118d21069fa810754a7f15238f8dd760721c5ff2e28d21dcb845611ad878268935dc7c8d7952171859ffb08cccf6f5dc5fc8692f51e5e4e24457cf8e894bc9fe0b715cba9e501a6471ed15856986b6c9344d405acc1c8638d5e2a7714609931c8b38feb0f0422b8c95f2e46066b87b7628b895da0b76be6f7805204b29c323817d296b2ece04dca7f2f7c62c74c14e0a58751ba92372616df2ebfa97fcdaf3d947f431e69302c8c73b1d80123e7b340fbe8bfd920ba3393cb429fdeacf78cfc719ec927c8a3695def9270916f6dc3efc9963fbd28c7e083f29517c89c9fcd0744843848469bd28f22d714f215cbd106253c2ff9865cf575a23e912a3f67dd47690839049be2915e918c9e3640aaa6fd0dbf5117f169be088d188a5c88e5b50f76388c18ae394ce881379de4c4fc88f3b88ca16b3fe6a027ea37324a7780ed827db003d2748b9276a5","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
