<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"74b256bd9fe2d0da35c7f72086eada8c5b83b85289bef81b1baddf748b54feea7395b3909af805eab83918d664e939e21a17e89106d6005ee7f04180b84c96f2b98cf48bcce4b37cdd1df0d2784862c22e7bce23a0e815a8099ba138c9cf543d990fc8d947cc90827a3f9e98872f078331d9aab8c271ad068c94df429a580441a8f915e3311740ce190ba63dcc0d1fc65ac509c7622b51404f06b31da068c185eb989196fc7b0130d11df2a6cb5beb5a8ef72738077618cbfc3a985116ee025e1db3c1bb0d09ba9ca4788e5410a6c8d17c8edfe7a3d42a535cc1feff0d250f71b519530cdaffc75ac2f054aba98707aa7fb27713e5658b38af0e575136a90109f98e69f45d9ea933d548e3c0307ca970cf9eb4c40217b6a81138aabcf226c5781b908997b2032e63935cfe8878ba8e6e6ab87ea2259579e6dc4986d805bec36ed3e0263ba8a7b14e88025bb1603a06ee1050c6fcc3074b86584dfbc29a0ac1399691489c9a2f3109f0e4910b89a969d93531fd6ad3a42325acccd726675867402aced48c03efeb14d5ff08592e1c558e0549559c0cdcdb22da595e8f268ed4468e402b0eb73ebc0021a7f21997ef54ceb186696bbd2efca267ee3f87f12228118640b70148d0ab28dd94987e6e00e99558f3d7ad3d4cbb6bf2fcb57aa868c99bf0557cc5bfde9b5e089b32e41ba0696bec9d227b5682b85c2b07d1f74020b2881f5e8a2ee1b8956d17b40a2442bbc12c83aed95788947660111a38539adcadf89547272faf855af109826693dedf5bdf84ade9c02db587ce2e879422ad9724afdb5e60d83447c0794c52c4e19051f8caf82547ba06305cb0cdd955bad2e1a47a406633942a4de657f8256b7aaa7ace096df8b9bd477e821a574c3a2663032daec3596a7195f44ed2cee4c78ae1e8a8c9743773e7d249085e4af0cb573b044d6652246a649c34e4d9ace80d4596b1639aa23ca54196d3aed76296f4d290a60f29780d040882b43e8c964e11402fe66e85f65ed76796f4ad2c17b1af64e77831b883d0340601c15d582c910fa16ea2708e0a458bbc685a16c170a220bde9f41a0932f75e424056e8a84625d0fc1d95eef5ecbba07a868ac4451e1b91833df0deac3de8c3b496c5539a56d383b4d797c2286ee66ba061d5c045ee1c76dd724237d099b4db22658b9063644985b1b4539730e0188836135eab3f5ba183a40a352be91cf50d928f22f4e307dd153135e738f04bd5a4fe59b0e337a5638c82a5dd66b18dbcbfd92ead05bbdc512defd639760499a49e42aceea44cb6f0f4f3de20f9af91e80191d9a23a127182e306cb1d44e26b1393fd10bae2cd31e59c80d4abf1ea665b651cdd042e25c203d99f3e96d6084b2733bd8c683a01fd69de9b8b83958eb8283ddfd1d71a1c47b5943846968d36939e755c53b6581f79890d7f17d2b5eb698cd8f468a8a96e76318ee6979cb9e7f19e010e53b748e52d2cee2f24f2e9a943ad6a0f471db95566509152a5a0b4db44862645f69825aecdcfc89c5a69c5b82b56208e214895ae200ffe37319c7cd5dd8d9ccaf2af2ba33b4d60d072a13d612c20941f0f71df711d3243a3d54ab9d1494e8b5be0924fef8466e254ff46e59ab3635a81b15a199798f77fbe748705ba57df8ec533543db9def3a2edf3cedd40daf12bd187296b05783f86bbab53c8f6a8b9f13e5215ce5fc048c6744c6b9daf8aa47f44f8aab281132aec7dadb7b1df6a12d28e46c659030b591f5fcf066fb83eb87451862c573d9919e82d35537d501fb6da4e78e11d183c5a9b70c2545a747dbb08f2bb157b7100dbc147bb6d6870093baaf57bfda014bbde9b6e3c879d56d411b53b3ecd43fce0718ea3c2bed6d2ef60540d08016a43dbf492d3d35bae9eb491436d77028781188de3a31061960d8bdd6165b251a457b216c68eb6e34f8027cfbbc5374c5ad0974237ffae85130da2dd54bbfeff17ae7cbf9df01e9bec99056e6238dc2ea9141f245fde73fef7378635bcd25bc193ad95a281cbf2fba1d042ebfbe288aaa4747e196abe47c9578a550467c366d406255f34f240678eb57cab28f70a5213cb5fca687252b9fa217a16154278a45a1f1c615bed21d4a559ee02997f30ac0fd4bd811a3241bf1cd1664251ea093e62b346b9b8e24505655975356b70297f315d035c74b67d6f180c1baac7dc37fd5811fbbaefc31d1f096b34f50787582d77a0885ea2e642c65c62991beaba4ebe16b45a6889563a020fc164bc47cacbc1398a9e6bdaf591e65d61a9a1b9de9fd38de142fee5d1a97230ca01c89d372d34e74f373ade012fc190eb9507eb5517ff1142ac70a8b7ece5ee49e7a57253fe57a5910c0248136e131deb4993ee2be4930cdb555f5cf39adfeb5895c91b75ab38d9119ef7745ca4fb6dc30617b9a7fb1d3ee1d0bf9f94e85ff00f9cfd8435a763cb50ff157e0f3eeb926f7790f7bbbae1be44d5467b1495af31253d402002405a8044dd02c3d6cc7da69e798736dd87448ff9e1c5eb8454edaeec544734e6d0745fee83b425a8546ee92277c47ee0594ff7047c11dcefce8836f871e4d261205140185c66ee9fd4b7f939b3039ea93544ded15714fb770d9f38669a7bf504d22689de2fa26a92cf9ec504309f598a236d7a5a08a2c4addfe38712e3d86cf70d559e6badc41ba87accc2971ecdefc9fe5869b333e5f9e887ecd0879cd76025d78589a5e84d24e9e511ff4f03ea694d9614bbb408b3f363d9776cf41bf74ad457b151aa373513483a0e7e496aca06b401ecdaa0a144cbe46ed7d4844f2ce35d3e087a5213e273fd11554b9f8b57c473eea5b5f787adf98b99df13960c3f74b3d3c5ba32b85a668ad777c6c09cf7a789de6c95375e73624cc5d658a4da9e339cb6d5c26e0c38c59c2f9cb1a71a8db739e1cc4aaf52b8918d7e07f2c7c7a6532ac26b985ec6e8dc41c666e6b72aa16c4f86994959b2399a27909685c4aa990c930ed46ba84bf3c2ab346bfd7c075fa58e2923ed8311bf707b90b7aced60f7a923e053e292c1bc4c46c1cc229a90bd6783bf57e2e6f32cec65361b0cf015f209562dc45d59e80006fb280d06c985ad474cf48b89dfb76c4b5c59f1a28f483c4e8c6b2e8973ea7f862c7bff5cfa0cab667869ec13c0324d6271e63cb9a58853dc1eb20f34fa2f6f54a4cac799e494961ade67e639b1e8645e2e33c37fe1fc784cbeb8c8b39da460a59ab1c87136c8c1eb7abb6df89ecbff2c37914543e6ce38e9416f0d6fb419c28891ff48a24f5fa8d4d630c4541aeefa70da8bb2580ab9273e37089937431fa3178861613e29afb3c27ede801e30d1d4f2e2aa0107eb5edfec674fa1233fdc32c248f0d031ca02a9e1327f6d69760d045be663267648abe76ab8226e6964c2449fd0eba3b5161826873f7eab938aad8eb4778056f44a2ee722836ebbe383b950c3fd8a6effa8453cab1b0f5d8b70551a49e402bd2628c4979ff98fb8995c9f3472dc19c41c3e6b830430454ca883fb5d49c7afe0ada9cf4d1116113d9e2a94236e3b406ef7f2737db711c1608fbc60c98cb22c1c48254437a80ca4b7e66fc39e7f78b09d2e55518a9d9ddf4d15a45b00b4521ab44b97a4682f6af7f67ea51e2ad310c095948c1ef3672791a122a531711b0cf849d6aafba27554819c7b0ef871e8eee80e6ddc0cee94585c617f0cdad7e3abb595427a7650d74b39ba0621e500204a6c357b0d9e094b1e17f06ac367aadc853149894a0258d1639d19a069fa89edaf33a3d0bfdca225e725d5ae8de4deb32d6857ff95bb233dc3d7e20a60a8548cd8d1ea89de3bc988d051644ba70c1ea51eca264138569af52f9201ff1bd958dc59c61ff9dc3f2fb3287c53268b914b3c58256a64eb30bcde28e51cf95e0d82acfb3286ab29f9af432000045b30e7c68313b4a20754ca835dd392e50776a8f4bf64f86346c4850b29ebbd1c0a2c44afd829a07a756d827ae2e788eec5eae0ace7c7e763178abc073112623fe8667c4f0ae4df847030e0243eff8c48ec3dfd21ac8b1447793ddbe6af16407c9dde42971a2f2905f5e776db082b90709d6e6bf1ac7091f5bc15a740c6ed7a472d4686f1232db521d939afcc227794a8e3d27756127c5a8b9f4b4707e800c6d09c8b7d9fd84665d2645ce0753ad3c59e392b4e70c08fe9e57f5a5ec72fadb2cf4ad54de56d49cdad0870480cc814c4d4cff410d0d27b5d2e76b1a7d2f8ced3203089d51a434a163658198c3c972aaeb643d6821648caa38f506ff0eaad498f1f60c7507d9ad1f52bc8101c2d08dc5d4caa7b91edfaf32bf9a1b9c5a416cbca33fce227d22293a3ebee5a62974f41e5ab2bae2d94f33796cba0f782bcde324685f53ed440ef8c1ad9abac32bc7a84ae00b4fb14ca18f13f29e8736684501187846ddf4f23350e32113c4c700a13e353ba173e9a9c362341caef1422c3df4263b94316061c26bacc114e3ae7ff751596a977792f01f2d4f487e9ae6193f7d4c1bc8d5cea97764ad13baff6a7b2cc481dc73499b2d731665fa92ac0efb9f4406e2c399418238b957eff3a19d84f88ab58b77d0635190f77cf1214cdb2caac37ad970aa6c5cf96568dcbede23509c4d7009adcd0b7debf1572afd5b646be6d7b388cbb40858c28c95745a66183c4706c0de67a4c7d94a04015d78605572d060cdf7eb1447862e4abf05c563ea0a09b3a8a11694ed33a6795f12da1d443262a07245331b2030f43b2c23ea8a84f86d9395c2142d174baf17d4569f90fd0e09385b37f885511907dc7198a36a72ee8fcb8918804389ad95dd94f06654c1b360351d8cab5313f62c03c2adf5e8407ae021fd8cc212a9de6ff31a2b005fb13b24711f0d6d4712ad3ceded0ac8a3cb64e7ac42b67daa018714eff2185ed3b280c00406ecc108ea1626637c6752dc25f62fd9fc0606bd9550f72a9334321d181ad972263b328f8a6dc6abaad0fd22268117a513a07be95fa370772129b12ddf97bd0bab5fbeda73c98ba62efab2cbb8974189b0f6d3d15eec71d659e302ec9ae69ba477f800582cab2285257d46373bbfea7457baf5699c5574e0a4a8f51e53110e52fa948025b5d9d2339919ef3a265897b55f3952faf539329cec793121bf07b5191ffb3d76952b96df9a31906f200750b5b4fe19beec5f308af51286fa795c5ca317bea486d407c8eb7ccb84bdd3f7be63bb2329e8935adb487b8d7c773dfb192cd8eb5e64846416d422f92ae19f5aa1f22ba75d984c694fca4538eb708ef9c3c4fbdf1d7cadf4334bb719663c37261a134c122ca4059502a83d426edaf70d917451af09465d10fbcd095968b9171af6199b811e64e9fc7212fe2d59cb9d6371fa4fe463d0e29a45efaa50ca454055bf85b645691c022d65794ab6b583a51ec8413adf1dcc2d1fd3c1e9f32dc774f8bfd4540c28a01ccafd407b9bc7f0a3fec182c399f7d55000a94ddb3722ea14616b16db434652f460df9209522569ffd94e65ee8febd7fa0b6390851808d8e84bfbe1c5c9fbb3bf8b20492d7c0219363d38a1ff446328ed19aaaba4a5055aeb7bf5433d434f6f51c9a34c6b9418b98841abb1eb743c6ed0b89dab13e6947a7eeaf791e05d1f2db2dab9fd2c91a3e7263d2d8c7d2f1823600a9f0553bfaaf2d749705777a2073bd17b2bb72a7c72071da81bbf16b46452d7aba2973b892f4666607a9b8a268f3fde9ee1018107275632803dcf1dba11dc5cac2454891e7217c89c15ee50b2dafce5c948b02b6521dd2318f80cde3b8d7ef53017fde93e464b0d7be9ab1688c9fb8c04114c3d2ab5bfa17949a725e2255ffbdd0422ee7058b23cc1bce487bfb56cd7e8011754f92931bc9b42a27ed997b0e5a9a210420284cbebab67214ecb70b7b2363db32faca60622dcafb13817d07a890c101a18653333aebb86ca0bfcd19944d4c36386e2df46083262b4d00d7d0ebe8d7342cd932620980f977a589690077040f73a6e3ef6b7407851c3467bc0adff4d9702f464678ac07d0e16e3c923d2c8b7b2d080b5b3346d5147ced3f2c1425ac00be390999a7765e7b9c4a8dc904f732befc59715acd676735df32092598eece19b94285d711f23649659dc7e4ad337e0ee5b7fc6340a6ed101d59566cf22335c24935cb0d69293c58a6599c62ad3ee4deace5952aee1c3e92cbb2f149c4c3e39dbb7cde7fe2fe3d495517d636b69feb2032aa84cb524c46d10e728ccf99c8753c79210d57b959d663c219d0b552e83c6db7872ccb12fcd3c89f7f0cc53e671daa4e305b7336b02536713d94c16e114c332780bba0fbea9f47b8cf33d2ec3c147169e38e23dc972fb8dbf3a98348608a3e0221dc7eba0266e703252fc784ad9111490dec1ae316c7264d5196461b61e7a683b12ab7530f533fd88cd6cc20969588731bd07165b2af11f217e1146b9435c1687f14dfd13bc0b02331d610f91bffa714878c68330951fc80f30e16bf31f46e0d42363406c491308c10c3fae28b38bae12d31d3ad9020d7c96622b11e9e2505a07ba05cde81834fe27236af18ec56440614e7125df724a12965f3f792daccbb50e875a9a843477375d8460656baff86ded258e6c1c4eb99fb9fd7c346b50bb8d2c51e257026552e4265711e262919b154705abd991779e79568a8112ce8c832980b7e54bb9e3bf564e4f9dc7f38c0768b4514450bc2d13778f6ecea8f612d8d16b61d9bf088a75134aad6cbb46e5e3b40122281fa79647e1263ccfad68cbc04259d2684144e186dda45d6801093d53b517a37bde9d726a148520f403c35a96be3332dcefbe324800aea2fb51de438601662ac922b470ed76fa5beea7244dee7808b3d3f97d241dfc111af07b01694f664fddaf205037f2048082baf91ed3a04a989a08f2e141ac87b0e00ec32367151339d63bba2fa6f70864a70a620a198fd277fa6fff4cf6fa1cb19e582d6cbb526f25b5885ee9c3754120a5b8f005bfdbb295f75f899ab86f0daab5ec29165fad90e6fcb93105f3fb01848a0a3e5ac2e7a7f0e09fd0424d2e540a6bea77c4708c720a89ab0e587b8aadb4f4a1c62db3d525a092b1f59f3cf73dfe20f070e847cf10e3b05c9e55374d737241a88e84dc7116a46ef1845795f1501c1cd973b150f313364c973c105428450ba44b9b47c137db9c37926cea4953f7be1cebe6d72ca6de3fee351273f69f3b03c0d02277eef978f077b3f71dfaa83822685f721b5cb55a9d8c08ad9d637a8cecc98e1ee46428f71bb1a437873f0120b17b37c880e8ceb2d525f85ad110c26c796d41de1ad4735332d02dd7160257733514776fe95f2913c35a7428e9ca6ebafe3f9b72377e3c7fd03520398b0acce1e76a53f046e12914f9ae51faeaec6bc6b61c632e41b3ad6165fdcdc749dceac6100212997a7d93a83ca15784ae108eacd5e2cd6268a6a97c8d752d4833d9e7548662f4ffba07fd8e402a5b97655b8e4580fdc90c8c977e39e4ab14381c958da761848c61e6dc58514308df9dfb61c043b6ad0ae611a1d731bf6ed9a73f13a8eb4066aab79d0ba22b189cce4f992b0c583168d5e956a5debcc2e236dc302935b5aa7aee988d0270645d63bd517dd6e362373d4a77b79a69b4ccb5a1f265742ac2d97e3bfa2d8a9fce24ff070edf000d047c04b1bbc5d852157c367e2d157008e8dc47c1f78ecbc3dc341558f46726d2caf692984db114986f125de2284b414fd4122dd182c09905f1d38f9568e258b86d5257585cc401a134cfcf2a99ff8822a3778b11747f5a14babe01a22397bc2cba44975f12624fb3334fb7ded2d40f9b10a091aa83806b47a04a236ca6b45d7271cdfd7a4cea8c2be02425cda220d8b914875ea8dd06743397f32a5eb6ecc4b1a20db8dca6d48a4460545d8a5c501fd3404f3b5903353d45743c2f158231b040bb36ae52a64efcfe017a3a55ab6482d17a317bd3ef05a699c14126baed08f0eea0d031ccb81464b2ca90a3e0987e045a6bb1baa4dda9ccbf3222cecf0e2f3491ddb579a853d703e0515477aa7836bd298ada7387b2d7f3d66c0049637da2ab8c9965d5e410a0064c19241157bb14f158133ac4d9c271f7adbbbabf249e0b9e741187a0b473e879c22c478148738137986c97f05bc7077e8b0b60ab7d4480f4208a002987edac381095e5c95b316b71a42938f2014efa7ae72444fa2181193a17491fe7a0e51ce976bb98c0f3ee6babe24de504ba638fe5140bdefa38036b5892080d28891d4277cd15fe62124ae8195ca3d3186a3c5d3a47f44582d5afa08f2db963ff0d27174175ac7358b49075d79c4cbcd5b4fb6e35a8e3b90d9b5485fb67694c757c7e81ad3e3869255bd2ec4bedaf243ece4999258076031708cd5d8db8068b19bd0ceebb4674ccb0a0c5647fc7bdd2f9cb0f26d52d87fccc00fce26f34b8bc1f4e01838cfeca16e50812bf6799ebda11a0ac9ab4172e789e614f0265b414c41619d109ee91f8ab5c069e6f9d3b19d8982c9feedae473536b538040e619e314894486b462514ed596ff4824c619324259a59892687359f25cd760c816a21ee84c308a3900d4fffe942451048f5891546abf1870bde5fa84293dc585fe6efa521c796807e022e4dd3026e393c9a64a21145743c7504a1994c1bf19bb9213bdddf047a899ea9e055a72b81298bff043133a90e6b0bb4b44ddcee40d8b2358b4e7216109be5381fb791ca143c82f7c1c15a518e55c8fdd3821e5af22f5f1fd6b29f811b3407e22b2825d7c38da868eb8482298ea1197808b7bee15cad93329632820f0dace99fc81e2aa8b50989754f7481bd9f60163786a52d5f2a29e6d665a1db483bb4172bcd0b2c7a0de1c284a10f5641e193ee927022b78f1cb3e26fc404852307df492ef19a6f7b9556faea9f36c953e2c5b16f65c0b1218ac822f493504f12ae3e3037e8336b4251341ce8e8896933bb039004192ea6c02ac715ae7fb5f598cddc669db31ad3e298379b5e941a2f24e11569d9a7109b4361be8ef9fa49cb4fe5dacd7d56c7646fca868954e0027d6c4ddd85d3a90960c6de87d5713eda4d2f654367b1cadd3c3ce7481eee263b6730369a3b21d31e85fc45b0230bb10cc5993e0e84c2f796542481d122f24c537d83c0671151e2d03ce4a47699122e9ac4ed8e88e498e57acd2713e8b83ea5d2cb8f17c0d6f5f891846a9dd916b1dadaeb119ac9cabaeaf7dc67c4168220bf6ea46e209fd5ca0344a96b7660160cf573efe361ee84161d6396f73ebab4c1020f2d4ab912b50528011f4298018a27e08caafc25a7791d18fa39c184b3600655d490357f286f6376e038f528734fa8b24779f9c47f845706a7a25c80c35a413f2b0ad0310a54fec46366542d664ea2e27c79d97c336b8e7d97c016dea13f1bfc9342a0eb292f409fb42860f776927a5dbf41f743ff5899cb800a9d4a7f73721ccc707bd23a812dcc9b6403dbaccb802a4d7828ec7e54ff17ce65b4986861b450cfd0c6a68396eddec6c9606e0560e4f1c8f33a7c05a85cd6332f47949a5d42796be4ab8e6bb22ed839c87b777a476b30233b0243c208df86bb9ee0c70deb3934b564da6cda48635eb0cd53fa82c0a579b4a880e0271ad0a6003e593fc96d9b6cc81b750c2871b7d7a30cb6a3a69d3dae1869e94fab9be561ad3eca9628a6e5c9d671929c870449e637c76b139a6e9044528ecc0bbb781163b2fdbc1e5d222e3570a77132fe6f84800ecfdc0a6f36e627e98323cd5a3370dd8a233bc4d5679736e5cc5e7d44d24a205a58dfe3932f2ce4da1cb8100db141c51a21e650ea2dda4322a33201b5e615f0c088146d0e6bc4f159b911a7f46c4ed827a3e83ea44255e9d0909dd08c645392fb69e0dd31196196803c0c326994eb25aebd61d6cd2ca30c8b846ffa0678e123e0f562875d9e9c0c5305e51a1a071da48f2f90033836b46cab22a02b934f7d064850896656d59c2602537c877bb32767344bd46df3e4272239dd00dfe10d5b56cff42c14478e0919fde3bd91d833a41d344b50e32b3c66e4b10886c420e8ae4a93ad3ed295acacc4439622ca9db8e691472b7a13162ca53bce97bfefaee8a214a52682708162143dfba08f50258989dcaae8b47e6bc0b41cfffff7f72512f00115408c8b8fb8a890671681b5aeff9d7cf020c23af09dfd32cac8d4ab2e14347c259271f3dfbad66a3698a8a2dedecbe3804f2648585cabd2c0d894a591360454a8b5f103c4fd68a941d331898838afbde9239c43b94747d6f7d8d8b4be91b8d6c1d0c3b8ed3fe42e8ba74a0fd9c796466222d62c356205183d70501e5657d92d3bd68056c02ac51387aea4426aa2dc361b9f722acc0626ba5d18c872cf7f5a2a2b3ecfc551639d8f24f3e2bcfb4c3d067b55f24b7ce295f6fe87e3b9226fb1cc25ee9f71f846cf4855b0b5bbd9f5c74fb3896936ae6f2c1f7622151d478f8782715a25d9b03a3df71def53b4505da7210306ab14901b3aa00c898e5b2d63180646db5a9fa94351eba645cfbd2174c2e936405a09276186bfe212260491cdd218dfed2e93f0269cc9456d176d19f80c8aeb8922fa2723fec5a1b8411bedfd2d6f5fb67de97d5f84b16dde31fa58e44010619aecf4606ee67001af5ef78d7d1e94d05b31c8a4193c92bb6db1d29245206e583e6e49bdb4e0cfd3925bee75660396467625446bcdcff4f73f2fcf36e1f9886970e0d0ad19b7a1b99ea3e4ea9d59533583a9ea4e24c6473cc774f8132b42755069c3bf5837b35b0be4085715c5fe76684c0f54076bf50a2b9c954e46692b46daaa82ef0f8933f578b84917d478c9d2aabdb14eec66d4eba05eb7afd94effefcb6e04db429fce3cb3160e57a24495ed5271a3a87e78367b392609d24316385ff36c3a67421e7db8f50e927b29ac7a44b5d84dd61d76deb54af8dd2bb2b2c2e3c489d66dcf016685443ba888773e9a1389b054f1988f74ef712d7a107fc4f06343d41dfc73a523f828ad54a8bee9330387eaa0caae8e99099a3a6e48bd12a222f932b15322f622029de820db51b4d119fa4ff9cb9c6e6e5ae602e79e66404244e72d7b55f2fe296d5672df21fcfa48aebcf5ba56acd65195f847d50d965968e7d88f6e451d414a0988cbe821c6d3d6c059f0f6398f83bad04c73ba514f0d32c27af4a87ea651a8fb3820bee0835fe484ba301372c78268f78c8bba7696f5f572ab6fec12d8347134e084a54ca2be2389e85edb8398b19572c4a935ff596f26f43fedc0f280aef22aa3614103ec7b177aaf044d024f7bcdc3528c391d36a5855d7947b6f5eaffc3d007c79d83a43e287d5dc89fc13bef5650fb523123bc0715ac9c64c0d1d6fd157ff48d11de43c1596a89610ed7851ae946e7107fc8ce2f166be363bf7d72ca2af8b49f4c08903bf8755e50179c74d7ab8a0f2db6d2fff0104a4f3569042884e77bdd95fd040d28c08ad82580da1ad6aad8411f3a199f08c7818142aeba617413a8e4926dcc2b7552160fa2e49124368f7d38d5332eada42ee35c2660073cf79b4b791a469820c6358d5d4ec91709da649b73104fa151ad0a8b8bcbbfe303191d8fca51e6475c4a9595e52cd078ce3fe8952a1e418b7059171543e55166f48eb565e2545c4dad15b27cd43e649e5307d8edfbfe768d14ff6b4e732cdda0fc65ae689783e93afc479ad0177502f6f7f38e6413dacb277e609652f800d1e3969b9f938c053802a172e4fb9680942a9a604a41f09b0d81c4b1571780f82a4b4451d936bc60edd6b56ec8abd031bce2d0d1a6a88b6c570956a6fd87dcc51aaa6415e63564af8c22c6a103b56b9f61b6c33b2e6136ea6096890b260b7397e3bbe925fbfad806abb0bdc1c4d11eaf259c013c9c2ec97a15341e13e34f9178a87ecb281a64521bc72e8725dce98e05385cd9bf4f2291d30c33e0be4ba6bb9a0c4154ffc80e92d00054991f65062dded2362d94653302a002a720eff97ada93d47b587c23df8df5a2c040dda8379d59ed04580ce83fd7753ace38a031c0bc12b5b0c19d13c039d073e4446fcf35d33d4d0587e2c67308a84a48ed4e141583d0eb3428343263a15dba435bc2a6619830be677fb4ba7f8b41e2bab6ea08857555bb531f8cca3fb533ad9e1b00d0bce9842a9a8a1db0e7f8f9f8f915b3df9d3ff899b2a65876bbd44a5c55e232b5d48876be1d9b512a9c60e3a19cc812d47bf2b1c0df775ca5a8fd93c28c8c969c295be58b2425f023c0ec691ee3e3192d02088fe4b4951c3990cba451be80827b1093b076c5de0b05958f6cae23a52a59e9b67f50902615d3ca56e4694d6dbabc918293461e14690aa9a81c1a25ce5d0cb4349799b5c97d9deaff09c88739635b7fa5aa809c1ad78d71a28a21c691bbf8a288af878f7362a3fd16181d08a9cf155caa496b45d27d1478605a85b48edd5565c1484b523d49db9e5a983bee9e8b11f91cd9aff5516175bb243cc8c31e8a9addbc007c69f83947821f697cd497f1663be1c5be7afa6c760ff1df9bd3cd2938203bb202d2d7cdaa86712391ff41f9d15fadf6fefa93bb15e552367f20c9ef51abf278a38bf07babb35979f8b49cc7dcd1df91af0a3d673843c7c4267bd968c65a310d48edf7c7e2ccf1d3cbce641f470c6e836100a7cd8dc6d66ee7352c4a36a15defebb8c0f3a567a348884cde073ff188817fc3e838e8cff98e64cedb778f3f983d7934eb686b25ffabbdc050cd1dcdc694c1006e2e5ddf6e9ef5b59fb80f009c25ab7223ed7f95d884dbd738ae121958039b92343aaffecfe3d99500f9a297543adacc950dc09bd2fe1c474627115f92ea3729edbf8c484b53367bf42a6a7c7392dcc3574c47032aeb94929f02b68da0e54fca2249e9552107e403af2dd28311656ebde68d8d3939e619e2c662d2b95b677b004e3575bfe7953d85d30ba9db0e95561fa9ac3a5f9e97c0db7c296d9f4bcb833fe09575cb9b34ca3a1c14c119d2532f8dea3260a126263223517fd98109b5551be5e0911d966940eb7f3c1f51dd47db5d77781beb91cba1503ba6ba25903a8291e23f9cb2d81046bfea63ee6c96ffad624cb641bd25760a275fd5f6ce46e72432920654d7a893c3db6a3603f41186fcff1a568c33fc4512883f8ae2353db14de91e7bd9b34051643f1a028ce6fb765f6fad7132762e7fd5374788c84483c324d84f1d8c0c16bcf1fe7138ebf1899345ec9451dc52cae4d437f00773f82fe20049c81d024d7b761e5c9638c8373d6d4cace40a0209c65d68b20ac259d2ce1b4cdf24ba1006c71a62286b339bd9935b8053f34795ec7210eb59d88acb76b338aa3aa7571c6499526020f6dbfdd3af93bb2f8d18ed1118b722d8b4ac60e4f18a42c0423a543d453ad471add08addb80a253216be174c6e6743afeec903451a81cae86dd7090683b1427f15cd26cb77754478169e85ca49c8a2c24bc97f58b74157d25c9744026b8ca81ad591262b6d01f35bf2de1d50d3aaad3d15bced1e291167200e62ff14940243a7ebd17847ca7a9b72a6bcaa8ab584e356101d5ba696107d1c1b64c3342ff432073ed888c4e775fa742b5596d799f1719517323b2d9f0c00cb054b945b1aac4019da2196ae5e5556de9d1782aa08588af990e9729ca5576aeed4dccaf9bee2b4b358daa32a0f3c3bbc9c5230870533b4f563ccc7e81289b5ea84790926fae350b405735062721c2ba6df690ac89b4e9ff17d7cd81dc8ba00f6a0794695107d397c456588333431199e74f5a8f8e326e84d8fabfd6e9b493904a77e8a82482e0d26a42f658d34c049adb10b87d0369fe6fb749bd53387951ee2d2754b475c42d08cdd976035a82759eb060c2c43044867011f4bfbb8d61208c6024938ed3353494bbf29eeabaff72e905699895067d21095cab6caa848228aa18123e188c831bd07f45dde8676e8f0dbb797614ca31f5df7be33f7748d2aa46ef26cb2280de9a0c6d51fab6584d25ce561c258592f2686e1447b3ad4f15156e14dcf927affd4f1744b71d1c9a894ff2cbd9f6ad548c4b86522485157f7b9fbecb079d54c9b80d172f4a526f366b0b91c67b1f55cbb2323aa7a20341c47c1ea78eaf51cf16cc9ca8a8ef0d23b3d65c2b7291c656155dce5f0448a0a7bccd3beae6b297900a4888ca8417ae1e00644845db0fe423d9d925d45985c758c19ca5b3c0158bd2a435d555c4e571943eab08256b7c4a9e0cb4df063c74ebeeb768f61d79d021ba0ad946ec72c19d8a71628d54832244bc2c9d41e3bc0cf296fa69e2c6001ce2c624c43c8b3d297a29746cec9cd282babde789b058d3a5ae67627f0ac0127a8060c21991e609d9ab034142c44429d0fef60b4adc4646211b30b3ad3db058dc6ccbb3a5ea312d4672772999afd4ddcdd3495041282c278ec50c217cfd4c78a2362f76b6fb62c1d922a9a2e09838673d75763bf7fdc24ea72f2a63ab2ae568da6e7","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
