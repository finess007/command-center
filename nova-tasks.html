<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a2aab46a3835bada59fc46a5fb08539772b01a681dc402153963e7e8bc2f53dcbeb31b4221122df2d2f8674c78b0b99427ab703c3829f90254311a59faa59ed7194586df0deb024e8d96a03d7197236f9628366a94290553bb502e1984f1eecd2275a75c5ca503b2a6f4b9437b6a42731a07f94e85ed6694ec1eac99c116f09f8a23644cb6c89e68f9bb33f0c273ab1e0e70710748ec35eeb2de684847a9bf3ad05d0eccfd05ac1d9ece03d4e3585033b5f8b4cf9b835a68c59245f28d4b327a26175599335cb6cdfea05db5960238eb39445d25dd4c8657366ff2f85747d172708175556e19d24a0797126abdc2a28b68226e6ab95f0f3138605dc2da6030e5897fa2aa8a4e515c1a525698a16f809b968724e89493c24455de8c3d1a7a48a5427a7c0033532ccd4b79de09d24b9c0637a613ff7a017820cd6eb80fe76fca9222fdec01feb553eae725e32cf4f00d56fce88ac7b8afdd18885067a113492d80d81c605d354b2e3ff64a7d3e1149f776fd3f20a755c88b6d5aabdaccfbe83498ed8fa26096fcab9cae96732522db0a03a4880caed20c4738a198b13d6f4c7a94269a323db1d527d52a3a78b4da1d99984d49be05c592b0a58392abbc6bc7df441eceb968dfb9060029693d7070910ecdb7c35e9b14315a00b733a35585d280723ffcad6b2ecdc8fcb282cf7f4e34645a1be02b0b33b59fc0dee26006add644887705e3d32877764ccde45656e02a0861f4d8f291b9baa89cfe66bdcecd3ba703258a754e5b07f99aa19005be2ef576ddb6e59fc520632bdaaa78e299e65e675375efab6c87f2427bab55788afb4995995dc8392b6c32e367c0e61669026afa20416c5056114333fbc5386de68983729e3d010a5b21f93bf681bafa773e4a6c2f5175aba04602814526d323eecc5f764ba75f1984bfde34ca2cf85ee4874e4fcbbe2fc5000bfe5391294c70482c7f400a4d57930801c69548b3d004752c55010779da261299651cd0517188ba5926678ca6353ba5dc11e51f48767f6b7374a29a21e73b1428ae817ee7e7e07503209d4cfe517d6d8162a768aecfb2c3b27683322a01f2d3d65f05367d310313960e62d5904e5bc1771e8f591836cf5d27857e90bfa4458729d6c9d554713807f3009789b5e8b2f5bdd8b6fb9a8f6996550f2cce9d8e44e7119dfa0758d54143e781ce45c0ea01d1d159c3059bbcbbfc12186428a1f4862183224f78db1dc3e1ce8bef9ab5e03bd7a95802b7c0cf2fa06d163a5d2629bcca23f5d1fdabeda3d4ae34b66261ea3311623a9b631bb2611bdd04d31b8f4017965a2dde60ade9a44169be51471a9d3b95e3f24e0c6d9eb8c8ca408fff45e20aa0b9bb87f5c02e7eb652d06866ae68b7a5fff158411cef7ab42442f16a00747026b3b501e381f9defa6ad3c2d84f5634ff4f7647b68b272d773383606c3cd7ca416cb0be9db558a8493186e788a2f56628efdfd226499674a177718a964b3acb9a97d7b72800de012cf0e884bc770aea67f93427648baebebe3acd395ca7211c402f39462f70adcba57b6497dc999c8e489a1d65e5fd092e79cdac60c491a41fd3de1b44f8d94cb403d105aae6992b6b6053ad73165fa58be6b45f3b6ac05928dee9fa2d10c05699dae933b3fed57eb0895606a7f6b79466c0d12205b9c63797d786d636dca5ead5a656a49ab5b7c84b162ac79ce858d7d60359c7780d4b612bc02e8c319656d082175eaf1d23567b81a02ff72599799b6da1360c9f239b8081d80ecf2792e2525fdae210d093c68b6db937681aef60859eea57802f33efc859e4dfba3d69ef590ca1f73a82c073643e2ece08cf808388933823517f19711ac3578b2b11e09f85156eb2b28bed730160268127d4a6636f434b7611d5dc63f5d32314513e020d5d604c24306aa7d8a8a67d465abcd1db1aa9ea73e49495b03464b45f31925857783e0c97b847fa1d7797bc3bef4b7096fc4f702aa67d8df7e5434b5d1bb0b5b3554f379e9d68f541f2a6a4e03cc52489d65eb51b41645ee4a1598dbb616a4e7f06a0a5e7523998927569376dd3854a4639eeb33682d5061bc3b99601af4d9b056812d1fdbafbddd0bdc8926945e6b492a3b62b891837e8c93ccf80d4e7e42b98d86e745c7b6d9b3cf47464ae18e485c72e0636f3a34ddb3248f40e7dfb16dd6208232edaadccce9e8a68dd8b58ca1f1fd07c7cb85eb80d6dba161fcbf1f8548d0736433a4ed2f81a2644782e82f25af97a2dad47dd82131b747718e2f925e39e9bed73d3b12415bf96106394deb45ed585a080c6be254f4341805185af003475804c9035f1c4358df2bf81d5899e6ea5f01b89a1082ae4020558350eea311ba04694fb8ac3a0fff88d9592e79be55861766bf12c758c35a3043bb090e44b0137f2b44834ba3a18aab1a3480178d5ab0235a5fcc049575a6f6bf3622191669cfa77f89f20af257fd86a2e35703c7efdf8a8dfbecab629d37d02b58455d4b484000e97790bac1c0f5b45502894b09b526d338a75c3ed26aac53d9eb595c08c512c154bbf18bb92c80654ca94b918b9a5c73ea7fa94aefa68cd4200c662c053113e379a6d6a378cb4add4387b0fe74a08e82cfc09756fc98060fd774896cae457687285528beb5e4057580a2a5846da6ac8de773f8dc2fdc31cf85ce85c018af3791e89c2625943d19c002ae6f1215bd487f4450a48d4dcd8873d4a2bcc45778f4b6a5bdf1dd34f04055b4bf0bbfc707c8111ae2e4e356af1098f73ccb164d85d8c34a7dfdf48e0624f291cd904ad9d109bbff0687d041a1aacdc306713a5094c0e9ec04357e9d5c5aa20ab7b95e1be279c344b92c2903d8956301672c4da365b01577d8afad2b4dad91494990aca4123df09a5b787c80dd4b6b62c1f6ac13e0d1b32ed6ae266f5463678da0ec6db975018254e0cfbf824e38041c8ceb13dc882f855c8a6fb18691a73b4aac9a324a1fe4d18c16fd7513bb93d563149983228beaeebe7c8ad08d3a08fbccbfdba8b41696a121e7d8bc1ef0c9bc742e928482efb1ffad74bcc4685ff681a65c76f279448e3a961055b339e01d6a1d3e63747aee8943a6dd5dfc4ed80380112a2a312086f3a4fb96b1f494445a19b4311faddb784879982a2603b34445904708f4e1970c4e04e4c6a62529cf3c7d57c481604dd49cd110298330034cae4fa58af00a43e9a55a450b91a377df90ef4b051ed0c0162a0958eaac1c8e3d414022545f4b5cf15db31f6499031e2e5b1351b102259e2bae566e1672ee054beb906351efd195cd9019dd9e9795589c36b797c70936bf4713355e0c03fca4763880756468487557236e06e04e6909ba6e9f391089de04a2d1e5a33e25484584de3297bb47a26b6d09c21ded044422d6a066bd67f66b7337b813bcf06af9ce095b589fc69a111e41e98a2394950fefc5cd2d5c1faebeb0921bd30b3c7932129d7aa91191235e287ce30bc41aa7e8e197a571fdd76906bacab9da8e1f0872ae4d65007cc00ac5c1cfbc99358ef139b02a853509321a180ea4715687bf624a6e2b7b1e71b16daa30e833dc29ff37bb77395bfd6e72d899e470bc6659b585412ca141c025597203e343d78cb307d0971bfe7ba4b0af4b51313b7e65f1733c9e1bd67bf250e6fdb40ab7f39c5b0ae3fd1867fc54a9a8640515d2db6ef29973b3c06245a27ce1e134f178e9fac085945d51476e72b9f18f7b2d07bb4c87e1a149ee246848ad822f18ad7d2f64dd9687f02ed85556403873abd790d158e8c20a4e06af6243b3a0282e12576f2a60f87830e02992c3f5d0a9919cfa9fa2ba0f65f4b21d1d45155406c873bb4f3a3ac49abf083cd9131f960076bf68efd7b9687af6888831994bf43f040c95d349ac4fc1886a4802f2845a6f4b92ccd119439e54eaa95be01c739ae3221a776184d74493149b6db66650f29b4ffbb6c81836420cb7feac09232667055967b83304fa3e459beeef8de4fa453472d4267445a473d73724e82121b42cc027585be30ad198203975e0f50974a00e892b60d8a5e1880cab279b30bf3b80e33d03fa11df955ebf2635a1f58b818aa6104f07af6d4141c77ddb2e43c7c144c3b67bd875df97cc5f8b74f3fcf3c48dcfe886ee7605a7c901187e65addd7bd61dff0644c9e2c28b7ae181c7a8e8febf0f1926a253453116020cf6d4950eb4520efd64f2b7e94488e079621df55d8d2bca474bfe0e4b3ab15cdb10d6ca85416f51bfa7f5b63c4dcb424f8f6ea5cfb15c176e38fb3d044295d3f707f9dfac7ad8b0925e71ea7d074312762a9848013931675c1e25204bb2f5df453220a6d963eec0791a33e2b5c6d7cb1d1f8874de674eac2cdd050f33e28b49f75fc39931f440e4fb6ef7da1dcf0e8e3bc0c9954e17738c371e58f3a33ac00ac5910d0bc735d9bf314dc42c9fd12864d37c8453ff81f0ad1c327fcd4f801c448db85c66be205fabc1f6a3fdf69fe3e557139271db1497e6d7001fbe930e7400067d33a42964977fd6bb84fee8104bf008ac31385a0674d0c9d519c6c4fe558ed2b05548ab4165e202e6c479785c2ab9386fa25d21305c8213d22a95f9f3627c3448781f3e54703a18f9bef806972610bbea9bace0d927706c1c809aff3a4ae6b797d8bb3b1fc608d82eb642a73f75d9bfd57ca913903c3dcec8b17a90527ad149614a0b8c8189f98ce4fe5c6b9fda232cd137b8738d22a8652ab4494e757af020dca0605e39047a79dbb4063ad63ac1940b170347df7ffd9b4bf4841f28d17d4d4c090054ff06d8bb073a3e78ec64eefae6ee377ef9af6b642d8ff332933252d09b391a63349817b04347eed58f7f0bdaafb5d358b48e60f8d8af9034f327cf32f6608c2f265d0494aed92619b2ffa36821a528b6383478e4e30ca6864e9c6d93cc54c6017b159a36615d6123ba211c74ea3a7117d21f7fae725d42a25d7e2e31110a7edfcfdf1d02bcd3d23442a3bd7ee6a0c6cd34f7327972073531156bcfb9d8d1a14b23ef5c6a1734d18b8cc0c1e27ea6cc9f34569eb9e5b1eb4921262791dd5a60f8be79863d8327fdace6a4b00b285aafeaf29d91b4e72c344cc397d5bf547a3c3115cf02ddec9da638551fca22f62ace23970468e0320d2e69302dbd4c09cff3205e2a5061c9bb7ab1f6567cdc22bdecf98ae802e67668327e8f7840d0621a084f675cbd7ee9bdc53b7b810dd07d04e38f144e59e9dcbeb5cb336080ab4f7192bb8ddea03dc2d50fd59d021dd6cb8c36f4b03971eaaa2dd2fce3ad7aec8fd566eb3d67bf617f76b1f59abdcc5a0a9ffb939fea611142e939459e25f11999667a3acbacca6ca06c52043bce48939cf5069e24398ebbcd498c9cd7aed5cbcc2f78bb0128a677412224253c88a7b8edd38ef5ea90e836cacdb9a9e63458f832e24f4d75be9ef3181e213cd6b71c084e58d21f6014b08088132605115844b69fe91a36ae6fb60c130f7bde62268f871a13bf5f329119bd297e2f9887aafc0c69b1f842d8db4e708e8c7831a8e5ea945c468e04ab07e097d4fd54eb9016589d84a37e0b4f3fcc5d877c7610384611f7273a65c2b3e93fe90bd74ebb0a48632bb34abd33e5c9db22151ea4c80ad5f2eea0253fd35b05926678d58265239da0aaf05f13adae1c59b76463a91f1b6b1d1b0f71720d1842f06047750298d1c9457490d197dadb34b17e2b60dd205e42a0ec7d2d7df34fd87c57603b64cedb6288dc9fe95aefa014f96e748d4941d7ef1bcf48d5d3ae4d763ad8984d8174dd5ce8fd619d6be86b3ee838a105c8c2dd0aaf40d6e644d515a2797d4e1e43bedebf4acb18b77e6206868865d3d51976599911549934ecd3c4d8744eb2d5645a01ecbea7503015b360dc61a7945ce7abfaa59770844087bfd49d9dcd5b1d798342eb047f8a23f217f58225936f4bd356532b81bf237ee42bd58fab6140cb2ead6d64d1e8d4dbb4c03260544d360a141301013ca4cff2b322f0c611d23115cf79b1cf4a778043a7ef97e3735cddec01eb711ed9cb3f50db3e9d749f2f34f8f9f2a6da88634af40b46b2bb3c4f98c58bc21cefe4c172259a63d3ef6b22931111dfcb19c11467af893e9ee420e9d6bef5d084050ca5a4996465cf64cfd166d80f579332a3c892568ce09039f9ac209dbe304cdc08eb9a0800d758301ce1f4f40885259b86fd8d6ffc935ec6a63f2f31b4e4979f9c1ca1ba424dc6191fe730aab47ddb6b07992d067a2ac3f6142458bac0b72fdf91923586fc0f9308bb6756714982d64f74b0e0121501adc71e57eca710ca42285e1a128864951f8fb9b44802409a9a8c6c2299474b3684506d2c744ca829b8e69a4d9c9e2c4ac9fd8f41c341fe400b06daee7b806b3584355ceb832b59a8b1de9a26a54ed589df35ad89244c34bca9b8013f4bdd3d5d7a8daa63baeeeb44e494a5bc5fff5f36b77fab2cc4d44c0cd42769c544acc4511b7d125354e939f4331071fa953cf54b510dfc6fc292bd3600f11868fad879bf4f6db9e1784b48a58f28ed769a4d087a13f981fc21eeb5ed964fea22557efdbe1c0420e8a3c290a77d55da5266abaeb7787b8e5841e900c2d58aa7c1a77cf9079dc195625a81147dc04cd94d7cbfa1d148b2dcec377da2b8f4b910517b143c666ec1522584e4e7ed58b445b14c3a24c0dd19846bcdc36ec95cc16165394b76b58c62c908498f5a79dd7ba0d4657c469044a9e24729d8ea9755b4daa2b49984d2025e4b964770bf8cbbf57d70fef8837588f1b3abcc28f29d4e7a90efbb355f7e89d2b642f0bda105f0125e89d9f5055e68c1f66c9e92c0d8a4ca16ca3ef679eb0b05668d3f88a3fa2d7f0bec9904f6a181daa34b6ec03e738fea1079e68701aff9915d3e26c4409eee2e0cc9fd30feba8d679bdb841b84bf8d3dc22aa79084d53ebcd88a2f35c538adaf712fe1d9b344fee033a8bc9349f7205f5cfeeb81612a072c32127250ca79f723b5f8111359867930c84cf60374d83752bbe045a69f048498afe51e5c3680fa4906927b38e6b88ad32f2203a2a9e8504369b6b303f86eb65c002cb19ec6dfc4031380ea274e8c609314cdc31698a2bddae1aeb1d2d29562502971b8bdd4edaca25c905230cfa059e95e06ece6f5efb9778a58bb4772ff51c26dc63857ae91f9ed20b1c8b1e8a040c8b62576c86d90a329a95a6edf8e97f8e29d213409645e99cef01dbd051510dbbec0ca7327de4b5184fbe9006e3b135aa7dc266ea241a02a42554aa993eaf8ba959b220b11b5ac2f7d1ccc583909ea422a7237d73e4bd99766fc2ffd5c21647c085c9d6fdb2b195e679374b942c143dab292131b973391a2dbc1bf35edf48b89bb00fd6a1927552a948d45b61a014e81116c17481dd5daa0bb9176243d35a925a2fb7820348071860aa5d4cf2d0b99307e1e9267cc6bf64accad3b9eb619a4b03cf37bab994e6739ab93db1a303394f788909884526940c1eb7364c56e5cbd8433af2cfe63a328bbfb8c6f7ce98568cd72d20d0e02d243ea4d0d7e249c0aa7ada3172c1c8ca65d7b1d1e4374304f535d82bb5d1a76ac9bbdc989d978271298696dc9242953129ebd78f02a3359034efff474f2dbae378c60e0c366137e5da035818e2e9598ebe2643eee4ac0ecf4613b5692154efe5870219198bb6b93434aebce03f98282895dd1d8c826c71282d125e38e8b1a9abe8a35cbdfab5a3975969db1477503a9c3db8b879f928188e8970f0f8a12fc7b33b1bd6ac278b229476b52f467434d6f866a21c82d50332c3b17e45802f429a502a7a2c9e0a011dea09cadb0394b54a41930fc0c2ddba466ce670173669b1c6bb744c136d167d29dc1f5e85302ad4cdf1ac6d1bd0c65d8c4d39af2d352601440765053e2ef7b06c7f03aa80cb3b8720d3174f07d27d915ef76df7dae989f307c750141c18a7a21c952d548ff9be24398c48aed19ccf7308f3bf398dc2be13104863473f1e47bdb36b5c7922a4be9f6686d853b048e7bb549aea95df87e80afa92407c6f938bc066958fd6d5e82f7b5dccb72e8df911584b72082f891944b03e74f39ec87d2595632fab783ed6dd3f895b3a9d870f6ed1cfb3df5d023d5f88c8fe0c59f87079035e71ac7441dcbd1a0f4f670c9f3e546040a9c8b096cdf42628df7720133860177a548a8ec1e105df27e2e985521554f08251ad18bf5be5be3fbf2aefa3a2dacd1cef75a8a7133ae047baef0cae2c20b21be71dfb9fa70abd0144b9c22624d518be30ef816ea5d53f1ccedaf986b92e10799d3f94a4db79770e3ad5700e3014a1aa0ffedd4e22bd8a4c2815baeeb5611ec23097c2d3684321417db014ab4bf3b4c50226875f222248e6e2ce7404f8107dcdca0ba4ef52ed17929603fa3b790cd6d56b402a44afa36a0275e4d8c8fdd0e5a6c87c519717edf50c7a64da3143acd93037d74fbabdc739e6f82bf0c30b2c4b4be40d5e3ebe02279d6850b29d77529b82146b6c76675112f09a99fb601cc9b6d643bf4a9c6af3835ead6f167c149074bfb9dacfa2fcd1c12944edcf16cda3d379ce9c75fd4395874d7a284473883aa23d8bd4ee4d3cd78ccaf9b2a0d668e6660f09e943dcf109c0c6c92f472fbdfcdc5604020ab0fe744617e157f771ed0a9fad98325937e2b3f4af9217d9fb8dbe85f9ac85047eb55c6bfde543f8e03a2add24914ee9c925b96f813b947b7009bd300f5edb310c81f8d38ffb322b285e1b30401f0e47c7e8c2738775defdbf7e542b696ba9c06d0e335184a1eaeb8d8e70bfd04bee1fe326cf9a979f2f652bac6716a86dc2cc2519e763b2414c8a3f210d76c6fa79d312861048e952aa30b85656982ddad6097dc6b23329fd0bc1e98dbf492caa7a25e65076c90b0cdac64e4a31c4ed8ab3d7d5f560e202666952bf698e5fc788adc299016bb9e20ddf019c7fbb6cac410ddf279250428a0229e8ab5528363df7b39b7a8a39a81f6b7f546f89a332e83847e57ffb6ca02fb9d4a6177d5874d9d384861c2f7213c14da24404a6857b3e16e5862029192d9540bb72cc0c2c53567f6b4f131c8c3ed76c5b34187403d295ddb4b71c6a69f888270239f4ef04fea4b9f819c4872170c265f48b1bfd6fbdd70e96836e538c8812b84a0533472e2a36852c37b777f83f349a6c14d86c0f15b8d20b94677cd766fd132ae5184a0c0598498d052cda47a3d2a835d9b43a637aa39a81cd8f1d032e90e109de9896f9a893e42d52953a780d872e0dbefa46f48f4fba27f21fa1cfd534ba0827fdbc6348ec70ffe674dfe7b2a9d068c193c218a28a7f9d49dbb5ab14c1a0f5970cb9d850ef6e22ec4cc63b578374195fd3d3be9d1cfed20bd61a7cd34b05faad840f04165f050e773ebf5c68a3fce5d6339845cf5a70e6d0c7a5a564209d7083d4c6d97dc4db52cd7eeb610f398f2b84f388470517a7450a070be8c160099f7ba2942067546a6fddd768a8b518298af668b0f77b9e3e480f47d99cfe492e051bce22373d899e2fc51e6e652d9a62cfa2cb89dff702ae4582f45faabcc7f798c25bb1072e09f4ea34b74934ffae3fba8bc769f2886fbab8a86213cad812c4551057f78e574adf3c5cb8eb0ac531e9195514ddc228499a2725955775451e6b1433ee8835d36b5ca119021fc76eb56eed4ccd51a4de99f6a3d903beae486ffac486d7fc62197668a2edf0b825d051e0835811ef60af6099f14cdd16b45f4b2b3273bdee2878d6449cc7e171f6d9a49715928b1a57c017138a1ff9fc0b0f373bc7f05cd493a9f7174f940ea742243a73797f5bdf38d3da90193244accf9b18c2c1df961223bad5a4d8fd37c92ede1d58d18d351a4575885c60aecf37921a435f90a524ac9b8d9b3cb3e276a80b1302789ee63888e536e2421614f0ab0b160af0ebd5d04b29e552e2c1e150e0be2c7b16bc5d1f7102d2c3e959a67f3cb60efcc5ca77f43fafd7d7da6a6206942b06e086a88cbf8967461ee5fe9c158846bb07816daf91b7813cbea1e3fc61f9929abec4a499b0ebe2ecf80ecc1314b35d74008a61b8b1f7bad3e64cbd58b93699607937d51e552876b42608df7e769ce5ab0611d012abfa005e2d56865f61be2ffe6eb3f35a301ec968bbc927a6c0b0243f91ea5779a32f4059763a1441630cb012c85d8385e083aa5c7e5ce58d2ed0d24e5a705f4cb263a8d0d42df014040908d8adb164f2d7bb38f9f6e66d283132ca210d7fa3aac8174e06c4cf9de7bd5dcaaf7fdb66ab35a53c5e1c10815eb778a8278b7eed3e40ea200e1c899b6955e94ba19dedcf0ebae6d22550d3cc62373f74c8aa7c789e61796bd54a844e289af7002767baf9b4c7bcf30da1547faa1b80d8721fc53e82269a34438ea7694a09d9ad3cd39d469a57cf9699405ad60e8b7e0280d19024983eed63980d944f65bf03ba990979caa89dd7bcb58e82c5a3310fb21437bd478f8b4aa85059e0a70a8a480101b87492ddec1696ef100f40e22ab9c435ebb468ba6977c9f2755532844cf480bcfe0babd230b9a8f4ba754640f240ec6c228139f259bf72c279c687a436a7306e964e2ddb4b83c4224d153f245935b649d471a6314d7118674f3a92cdf845da6c39b75723d08aec39966864b49c03ae120f4ff1131d2951c68525b3a54410cf757e6a6fa74287095a19dcda862c8feae31684fc34c2e35906c9fb024499511284561b8ae5f7b02876a7ef83723ed2b50f0ac8c79ec508b3357fdb1b8fa25b1e86ba7f160050722dd2d8cd040ecdd609db4690278f7dee4c539d94f85236916395f16f2c14abd653d798e9915cd6590085a4871a021056bd8fcd17b6ed33e7cedc2c75108b54b2c0414ddbce907f20bd53515939c17424f297ecf53623e8239d9dee2c4f5681e29b767794566c8a83a54f2492e297a3245bda8d219f57f1a36539cc3cd137b27a3e990d25aa2593045167f15263b0fa192a1c17e6850f318b542403f81bb01315b2cc09b3cb2695cfc635e940abcf1516e439fefc8bac1f1c43a7909355f280e912e3ae9fa6957374aa5fa34fe3732a9cb99d105e2a8bfbea53f4533882d1c36d23f96b8c31b4ed4d9c455339291895fb32c4f875bf8549d9555c7861a97181ee60ad766750e197d37cf371bc3e71a75826e19770072a1e0c6e2fc6066f583103508c18518ee4106dd24270e3319464f7ad8ff8ef3ff3dbb2dc89ee24ff6a2ba2a440639461a5f4d29dd50fd0b1d8b9a7a2d39f3c925035b02f884a50d2dd1c52b8db81826dcd566d79ebbbf4e0a13d318ce731b36820acfce2de8810ed91ce29dad17f2a7c6c781881b5b4be541ffa8268dd186a1f79d26d68f4e21dc21aa0d89e1d9cabf0c02081fa98769cb34f20856c5e0fb1efeb8ca2249b53ac88a287934c9040998ab4b0dc0dd47e8be29e654eb7ae44660144a3716d88b466006b5ba6ff198ab5b7cfe31ee6ef7cf4059d3ab11832b9b69550a83e02de5ab08fa231afdbbdd2b70c26b0256baa533294c294e49780b073aa3c4978de5f6e07bd86a7ccf15ea4861aadf2d152968f2f4d91b1bb0567c9058afd3712ed8f919fcaed9df0f22a0dc776173171bc6f3f97ec533b29498a45e09c2c91309c73a3d28f10aec2b1233c74c7da4a361dbef425a94b137ec435448606b628c1acd34e55200547d09d65af373f141d09b463e561ee89097464cd67be3c009f1ae15e4ea60d855f451ffe0687cc22d9e7491f22a52782d59414dfdce299a2702f6e96b50b6d51e2b26e121e74ef01c823c2aa1fac5f9a7ed2eb114523401fca98eadb9019b588230a564c64e88919fb353f39100173bcd4e42cb4f5b5581d86b7366c9bcb6aa9ce0c284e2b332c276641d13b7add6bd8ab9b3dbe63368297dcb18c18f9b6e4ed51c46ce52c191fcd0fb07769219ab50e03b0e720c96f6fc10f4ad02d9cd396bc7ab41e87722f20f0e241870f6bbd78cf660a1fe16f7babd5953b3381f6b2118904fa1c2d0a5004b72a338c3dff4cbdbb3555e7d39aa85535a6c1a6287e2bfb3fecdc55fcb9a87c7798bf0bca3855191a044bde1ea7e877a803bc6951d05e52d8cb94978ee746e30c5511051dedbcd63f57c34f5703850660206ac6d2c56bf6e160bb75d7b69d77e9bcf3696e67894b7a632db2a9325b825e47d4565817e8b878e9cb4f3356561579b9eea9d89f016d6d716a574664707b7a972596fb0e841df507b14dd1cbc96f69e852559c4473a40d35ecdb5442a189adba667b5475dff2e5ce7914a0de9189defde420053b811f2dd39f5fd1bc3bbb3fe0555dbc79689cf4f815d6cfdee0101c5088119e2ef8fe597d8cae7390b6eba58d1c93985f95b52f4ffc451127d8c9ae9885672f93f17a7c50966a57110064383bef8c552aaf1eea5200aff0932bbe2a0a17e492980b91ffe983a4555373899152c90c5203bcc223b2d7d7b06ffd487e18005a4e3b96f30645a909e61b76ce22987fca54e8e526c3ee74d99259502a60c1961b9670de4c98dca8cf6431aa493a496fc2ba5b9d35fcb796d479d653a2c5fccce4fea451918a1aeb3fa8e6fecb09a680370a1af90d58ca7e8b6b397b4d3029152ce92371ab9a8a449e991027da4e799714a49b044bf1c1a58b73922023826c6f26764e857830ec04fdbc75f11a591d96ca6e6b899880f2bf4b7a330a8fea59c4e6cae5d885c0afa3e6a8ee346b054be10659f09d086b9bc0b21130f9e80e0fa282aeaf997c3217b9f48f089def4f7ecdddbedf644f0f4d7bc8b3403e4e1e0479bd46b82bca73d82570b67a1b103b27d85d80b3ee2568cad975437116208bd264fbf1e8235825de22bbc32d4441e36f33270c5a514d44b0fe4d38effd05e041319a3a70cf1d23d6719aee75d2a4f730ebf57ddc66a1845a0cb1104a91a6ad3bc6f133496fe3d0683242746ef583fb9e267c1d015c632ff767a34da83c9948961832bf1520c87685a08f3453b23ec6fbba450d9547be4bb3b71428735fb04867bf90140a8851e35a18032d8e1510bce952e0de5cd44e8cbab8d5738ad1b8b4dcda312c4bb4270488595adb3c3a715018260f18b396bc47f12c587d18211224e524a4c1c644f8be407a249e7956695f7c92f6eb834835336aaa2bb0b8dfb2f464ca3e0915c36004f1004478e915ac2549ba024cae1f914b0b447a22b903063c9191f673ccfc9511a13649be0a93a40038ff8db72e88d8b115b53652fd7af4856297e4dcc781b9570a4d8aa46ec59abe93ae8b388d7d06f75b62ed1787b0902217756641539808c6c36dd80d915e6a68d43f85207c4cdf5f60c5de6bc2c180516cd5dea5f32459992ff462d2a6a7e49871436cc33d91aac9aedfddf501b8def13c7b461d48b9fe80356d323b7b5212edf28dbb0e971128599ab969bbb5405fe41cd0078f8de84ef8976cf8ea1154b828be55844dfbaf89b58c88e494a226d6bc1bdd388e032426b840d4288742d4e1e24b627e04792966309d2c2f02e4ac3d1212edf6767a28bcff360de10fcc272367c5b55b180080c710940b224e8007da54a5906b6f859f520ce0c39d48663458d2f499afb8f25c4659b2dcebb56842d929b46bf5b67d45415ccf91559b61fbf2e62d1e340c5b29b40ec8005bb453b442e4d3a7ac055f37eda13d9d133a7b2f7b8799fd177790f68e32c1e0e3bb1be0b75301ca2d57a6d62df82d5930e6f0c1f5799deb797512758e09851f79979eab967cd5935cb17305b2c6d01b736cab7c26c6d850a588cd5fbe32c2be388ddef3869629cd5f8ee93d5ca4ae914290a841ac19714e06b525730960ad19ada1573404e82d26ca219bd190f47c2aeaf1e3c41bfe76c9affbf6a5bc9a69c44a58092447e0a52765a10b68d96d2baf97fe7fa9d684eec6daa531fbfc52f1b20d2ee3b9f1b9314b3f81a328472b633d2792548e55b8655c47afe3184eb9295f4261fb143ca57bf5d373f9be45e842b3b30f4511a71343d42e9dafc868205d4a8cfa3d360ca988ebe17452bea851f6d9b6a9445a21479466828917de67d140aae13c1f1f5d22f8846d49f127f49c498c48b5a9d235c31b920e8ec4ddfc02d3e990eeb11bb7263f69c04ef6caaaec2c04c4e2d9eeead1d01e43ceda38a5cf2c02b0c2aea91d16b1b7413f2c281e69c99e957eae429d43734f0695e54f2ed3eaa772c284564b5dde8e000a5333595e00dcf5f22b39","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
