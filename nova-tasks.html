<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d5891d03ee5e230eb63b4afc15470a13fed4fbf5ff1dcbcdbfc12c1e697543e0499b2cb93368fac67e3d4412451f11f8a145ac01cb2cfcb651825ba72120b243d3bf952804fad097f703a3dd4b5d7ed935509f76b10c845a31dbe0ea3e049aedcdfd23c20722b53ab566a1659925725257132925e4d2ea6a79a7d94934ecb74353f3b4c1e5ce5a21a6078a1bb4e908c6ffd284418e2f45458f86f18eaabc413767de898f23b089a77728a6d2ebd73c9810831dffb1d6a46b6116d5476bfabada2f3ab162613b0a960dac21788a9c961315000915763c18f8442b70a01860ebded22d0cb75298375268a0da17a3d85e8bbabe8f1ad4548da4e7dbeb4496eebda14f2e9bcae68b61254f3eec9195a8c17de2360c84497b6d25c1f3f816e164e6de52629ac474bb1bbdd8473beabc5ad5131d9a12a9a94b0b87268ab1867d7d973f2c4cca0e47867cf53fe5fb308b29e36453930b9a0143adac6a91e1ac685a625e83cc95b6ca998082056cfe40a18221981ff5b556022c8b4cd7123e4c7265e7ef0005627a7399a13fc8aef791614fa5a01b1e92042e6766e2cb612b0160cc6d95ffe7e49a7f5ab92642b28f88b575e021056c1b1cf4f7e3d4b83ed780c07d8e1ccef822a234ea4325fa2af42bf2c53d85fd85d6eada5584339b52ea306ec692aa72d004d8add06199816094c154525f7af946f5cd8599c1afd82d30b0dabd69453411523fb4814b546bcda98f5cd33beebe8f303348d8292350b27954552706eebe5846ba1415a7cd304441bfca4260d14fba07964039001ba6d0ca8d932bade1095fd3b56e75e88e9835ab2d7a6480fe4cb67dd55c4139e2946824d8b46a045e8a4ca7567e4ab3d1a2d8e0470e45473bb17da64dd11a8e785ca43e94272a4eff76ef7ce90c35db83690d0441d287fa118dc9d8daa300016aae4f99bcfcad4e4fac65a9bbedab80e24b2ac42b070baf99d431edf4bad2832228fa6f78f77e9cad8ff67e06cf155c6207c5edc2ddbb011a6a01fe92a79a59cd3788288b9f339e1a42539199a1329fe6165f71b92dfd3824384a7184ce0f437639ec1b941efa8db072cded77bec518c40d662ed4cecfd0d7d7b72c3458dc60ad954881759815b5f795a572b5094b4c52bb0634fb8ede81ce8588800049ab4b778dd23e6f9878fe2a4e5caedda4acfef639cc84485aadbb0afe2c5a09427b73fc2cfc2617ba126fc8f2ac875b6ba9b170aa20407deeb3da58c7c4d72176727ff5c0c351bad54ef6f1c79343775cfccc6eb400e97737d1e2e3d1bb19bb8ef655ebe2d3a8401b9e9d23029a86ac769ff4508f671d78350342c6ae31cd6699c553f1e79e280d1832feaddf6b9d8fdc1543091bb0ff8d23b6bfe9f0901608a2ef1784347231fbef4adb3b4d750e0fb6a7b7add8402d54c131bdd3c9d7e3c1a93ed73abce04124c618011463ff5947e5d5513c804b30e7f35cbf5635e64a42cd1ecb33e934874ecde2ac7d2e7b380ea8ff32117c0721acc84c3ff68e357df0e88363959f45b7e5e6f7ef59a7a6d4b2e595a0afa451c0f5c7551fa07263a9d34603164d16a56aa8225cd3eb8fed19ce44bbcec5852494198f40271c2afbc539faad501b8da18acaec7d3e76201aafa223be856b7383a4c010c30306ae6d89ae86b01236c7cfed029e09fb178e80ea7e915a278fd01f8e95f212a1770fd57fa23e1da8f676fdde4014801538504b63b518dd0a93434c15f51aa2169c4f7d14c647be2c0c358d290c151f7f241f4030af9acf9f7b0fa26934a3fe6e33d4710d34480408a7e00d28d26b43ca1f177f12181cc13cb3fa354cca324fd1a3c19365b054781b41c2ce9a4bad572a2e8bef3b77701dcfe748f21628ea6e7652c5da1eb3c5e9df619d36bb6083ed00c44280f17248b4ba77a351449463b4f53d446a4cb8d9cf44fe2e9c0782f11cc295b7d598d8dedb764e258429b0cafa1634a3142dfa6ff62c05ee5a32b6ece25efab6d5f0efd80829b4c3ef158a174ba56c97e740d32813ef925d8821faefa4740651a66344acacc3e7efdc0056d05994438458b92a7f40e1610e1656ce5a9e20e48cb4095540fb56f28e04f643f83ef362a03d2f12bb99d2ce586f1d8ca10b8a490fad2bedaf2dc608e9e05ddf83b42e100d84e71d3c4f013cc14d5948fd35031090d62e417a184756f62ccf0771612522f9e14fa90cf57a212cd14d2888a51f03c1d0fe1391377ee5e21edf4aaac3ef831c5fc44f3604e8054b0f8e79dbef43de6c0f03faa76cedcf64e53b10f38bcac5c6dde85bab3ebfce2ec68ace6ad1fbd33202662adfee11514d41383c57e3288149e2f2ee4455f1993af3831593a40ae4d030b5b1c71f7211244121016a090a50114932a59c831fa6e1de122a7c2453a8775e7770e1ac569fd2544c124061a1c60687810fe15464f0ebf2650072b67f2903a11f3fdae7c6f2058d41b9c8e2180a63771832eb5b1353c8123dc291382993dd19eef7cc48f9f2bb6572587405464ae286c18f2da5f2b8582d4c4c456344c17804285174a0b932109ae445c622c68b7078edb478d785ab0c4d8100e5642aed017aca4dedf9c4c7de46e7141dcfeab78f67a59ec546e13369944a3a9d512a65db803aa5bf6a92308542ab1526d2aacb0eb20995fe60128b4c39a2ccb710b66ac84889818aaa6a1d9948751f9a943da653a7d4606158107ec5032d751400b4b2e1795247a89f8941e687eca354e1f704020eb55efc57e44015f986d4811e45332b415319733d0785c7a4e4a63782dc69338d02e1b7615d6633cce2ef0ca8434557cf7661dd2ee922d8b2b5cd8dd2a0806216acb3fd85f80e11f9c4e14c4e7b01357a2b95e6218d096a26f5870fb0cb06ca023b6171cc31ef6769c931bbcdfe94c5878bdf38b64974bc23c9ee80c7801ed78152ae56b679536a54812d5c8cb0b1c1d38ea008877c41233220aa165c9297354f19fabd4df0665c29485d7eb84ade6d66dc99ba4ee47c075265fcbfecbc8f097868e17c956421bae63b9212bf38ff13ec6bd3c232feef7dc98651c634db10c45c200d55338e544dc226af2e6c2de031091eb452916ee952fec10e0f5448417b34ccd8712a2d9b2bdafde9239c4741e813a4c6503e55d713c647f9e91511233eb37cae97c46f0b53df984fd7b028c8d17597e28c94d1a8e6813673af711cbfdbd88c119f170c197d15c9b38545aa23429c186ec79fdea996dc0f0dfd8a686ddff4872dd6ec97e1dba50ce06e78e402fea0884fb34de1b13d69a9ffe42bd396b7f9ab0e0b96c3dfe036b8e77f771979441d43bb0d93f30ce83c92c29d362c04da971ff23f6bc254408c5b5a89182c86e8e12dae61a517154e142d1c82794b47356c40e3d1f0db3ab175b6089c22aebe5dae65182efc4965bd9200eeb05b8fca4e3329feee68c2a0a0252d5a1d8aca81b0746aaa3e6706141ac1952fca11965bdf9e0826083d8db91a30ea1cf06c58cfc76b3dc4e142f499380980676217f4b067bc9e2d760ec592f257de6c010ccb7d205ed23acea26dfea1753a17cdd22825c3b902cf53458dfec0cbc94c4f6139af3872e889f6244dd3ae15c97f3d83c5fef27556590d4135898fcfe3c28fe95c4642fe5d1e49cfd053a875534e0d0acd586c804b9c507ab2b6aa74ff2fbe5eb7ba2830c379c4da50655ac23d7147aa516169118ab71dad2ae0abb2253569876e56bcc636e379f5c9a941c9c4e7405bece37187e747918e9a9b9409d0173319471341ae399bf0f6852b9a77992918ab90a94b66a90f5a107a47d731c6624e094611f63e0bf02ff42c75d464014bddc4e8c28e90ff5ff6163e058fe110252cc2753f10e9b32178c126b130634d0efc71c96516dd0bfe0aaeac4438c2e50c919b00ffdd25bb56dee562639685f1b8b4982a72df3b96d331123d6a8eb0b82678e2587e3e4f8bc17eb6fcf661e7190ebb44a0eda9be95c8fc22203e910b9b65f90c16ebc6ed8f9a893304b6f2c0aa527c9292268d0bcc410bbae21ded7e6dac93008c9b64d12c070b8299da271d37a40760ea68f4368f9890c9d0418e8bec7be0a63249dc2a9701cf67e160cd7955dfcd2c4942fe161ba7dfa4c1122889802f7fb2d9560944380d4ca781d1c3aa3d8a2924a671cd6a301d1bc13718b9493fbda96e2d8dc3683c01ad62c7e8651edda35b128b31e77b26322b4268149de48b71dbab3701a05494c48c1e69c1e8ee652e02c565a59959856a673195e471851dfaf1aa3355ca806edbca740b982d35b8c7f3675b35a7860f1da5424729738d86fe42c4037a06f942e2a63a6c1d4b4196b1bcff5d442d101c11c7719030f34f3e2afd6c4daa1901716e000b5d04361adc1f1daa4268c9e85913116fb5a7f8f2c22f6a1b452b4531c8e26ae3c6b8b257ab35d748928433e43f1a7ac3a48fa53372088e0dce1bed71086962fffce5a7336e53b642da81c97d8eca2a18e924c78946c22a7d3cb9118898647062fd37da2b10bb77dcc79f67970c3beb590ccbdec1f33bdf3a4a7a7d85218fbff5a50777a05203145e74cd5aa2b2a9af53a42a580b122e4b2833818e44f08bb0546edcf65d11726710408418896fe55dc597ac65f0eb6e9707868cdacbe85ea4f689d169ec971aab82a39516517f3d4c4a1f0eb418d0dbad93b3fcc5c1cbb03ef302c65757bd6cb440947b518a40df7cc14cab4e58c3e13497e07fb6cd405c849ccb0ce8da4520e76745c107f5e53f0d4605cfcd7c9349d5ef2fce38b680d76afdcdad4f933fbaf1c0ec46837b31082dd52e2eba7862e896ec8b119839262ca4223b040f03c55d3332c6731c249fddd8ccc1306bdf5fd06c51c9c4567ac4e96c23963f45d407a7ba38b88b9657eb3fdb00eb235b31047bbf784e0c424b5a03c947fc195435d222a140eef24464ea91e78d1c2c9fd964618c348c7807dacbecce7b9166470648f663671a8f8912c550b3d072fc3c5db00d261ffec5aba4bf31fb159b07ac73ac80b72bd8b10060952c073a1f902b838c75e2d431d7b8173b65ec62a77296074277c4a857324fa57d994abdf41fd77c3cc608954cb3d224d2677423f5022a1d8b6ea0631d20374ec5e12f9664faee5dfe6b2acbc913e178b275f8a993984a7f7b534daf5375e7694622cb9cd9b4358466323f07b326cb8106bcd6bcac309663311dd23e567f0a07caf293adf0cd20dfb04937f0c936a4f912b0a4c7d898031bd0d5bc97ee12997ea090eec485c995a98fcea9fc4998cc63de2052e330a202329460c2d84fcf5e4244daa15f206b921e03f04d030252dfb0aefae72eb044748e97d58b311dee53fbf3e0dd8ad5b2014c53d422ccf8574a8f257db6379412f6fe1c511c58f74ba256cdba6eb6ef6f50e8b80997ad230bd907602aceea8da7a8134db86d78ad90c57626aca3a29762bca41c7d900aeeaa3807c62f851d4c882cb8e2161389a9d0887513df145f309b2ca7d93153fac5b243bd99175b6d78c07f7a1165f44855ac4939573881c2552f8e993d1d172de9f0ec79ee4caa377da1b65c32955eeb33b31925942f3ef70e83a2c8ae743aab4922b5f80f10287c0462580f107d866279ff4c3890880d784c42b4187f44798b2a780d271a71376820fd03199643e08a5a299c40386010328dc5f3496c78fe507fc0ca4bc039fb63bc196f387f57593e574deba817186a18c0bad0c6b90bdd5f32aaa6ce4d6d8fa1e1df7ca168bf9b6de81297f276ec56d1dbe81df2208d6e0cf0b48c308470bffc867876c857726a509cecc78ba0bcc48afac2e5ee183ce06b145d35df0e6529577d902336118899888f4a560a58268dbed35e41e9d1b092650a59f0c4f240ef72bd98901aa2b8c331c1186aa10c20b77eac944437930af9c8939baed014cf8de64eba38cc926eea7712f0adde1dbe2ec0255e6a8e990b1f48bd4a51a79e00f35b423134f0a5cacf01bf2cbe010ca734e85fe4215d4a69eb89b623cea80d94f0614a8931c9d7544540f996d7e5e0b68f5eb1595229ef2cf783483a6562510930b7c15637edf071796767b362a67f1e597d15fdded0ce0e4c8703596b0c5b94e89f082c5948a57fda0b0470885ecba55dd2cb2a82e088a1ce341faa0880edf0cdc15eb5b7ff4ecb539ac34325256e760f84ee12ad5882c8b160c540e1d51f0ae3a8e1d079a993b88453ea9712fe1d39b2f614f72277864edbb51ff87db0c0b4bcb6d53f31c1670d6b717957a59cba19eb9efe683759cb2bf6dfbd5d3be53c0a6663d0ca0c0942dc10688aff870d07708674ab9a433789dd03b83e5e556398bbaa2034d846847bea55605d632a113eabe1adda17c6d6b35cb42bddf987e884ebe98560741cfdb61b652cebfae37c2c271c72a5a4ec84bd6532edb626c2af0f100adcc139da6fc6d15690c5248f1fa7c6455d8654ff5ef649ce3336c968d5ca97869afe878c9cbf9616db7e64bd351714dbe267b95cbe105c651adcedfc6b897b761b4f2dc20ff210724e9c5be156111d4ee2b1e246342234483953df6a44cb191a364baa20cbff68ac013cb86530ce3c0161840ea79a9676273ee178355bc361481f6b4177a84d8c7d35c336544317accec2312a28e49cdb492c1e43fea857880027a2d6885a317561e3e3001b4c66892ecee77e018ea5c1576d58f46facc1cc273be0d2f6eb02bd4e43e1c87e62fa3d118f5c069d16acae46693a5e1a0be55899a67af772facad75209c41c42e3b842991cb2fa98a3d6b01dd171ebcb70f9dc667b8b5c0e04ae1e2d7492e85236d75117bce0508207c05fc7361dc76074149933a708a27a776baf0ba4c1ff1271fdb69af9f749eadf29289a9328576f26de65fe5c718b09c2083272c23aaa1ad37604ec3042e90dc387ac3000a034b68f5b3238919cdce03eafcaabf24134711f1d99064f64097f0df65da2c64ac4b59d5fb9fe128600c791d80196e4334100be40be5a6f448e2f0be9f9cfa9ab0c1fbf3eaa6b7cd3498301507006fdd9eec7f2feb95da0759d01ffb7b33db597f581cde074708c593bb7f5e892decbf86e8a9c4a29992fe55a3c3a6dbe8119bafbedcab6593bb9bd631cb175bcdd6fed42611074cc5276f38560376eac56126bf7196d8569b34f1a0ef627417b7a1a922d2b3d251dda358a26a48559bc1cf788b77e96781ad3f05f6101f285e9f7bce0b2755269f805fe8030b9a5dd2f2f85fc183f94a553588abbf7c517d31479066609a9333f0af915008854d12860fdd4f860dfc118ab4dcb71139e83c8e19385e65ecfe14d098cbb98bd6eb6521e4e6c6bf1ea8f0fbb5b7d7c7a976f2b187cf02808d13a3e7baef1b1c90f2ba5de503b4f0c211b4dc34ca1c30071e9af8ee3cccec270abe5124a264fb848cd26618ce62f410368c7fa2e53fdc8497bbe26b1e647c47d77b7ed4a275b731085411f10e918805a0bf17e72993987baffa278421657c303c612992a3e583e5c07530230b2e36d34c7caad5e8b138bc7f1d6f56d6454ce78d941681b8ca77a1275709be1fbeef7970039f990c15743ced124bba97cfa53e367b417e1875d03b2c7ae85fb76b76eadcb36b5a3d0e6154c6dc0113121ec2477a85cacf31231427fa84de338fd914c2dfea667cdb20549766181ab4bbdd34a34fd6d28933ae3e2006b4945e401bdf99d8f6397a84655a61d217034ed50b1915cf6434f48d9fe215667646f508587581d7ce87ce7a1c421db2ea35dd1b8c0ccdef394e037700a4339fd1d80905b739dcff9e1d5abf469462f0290dd123915bb9ee9a3a61ef0e8cd2d1220addf1d822aed18a09fb4bfc083dc3812afcf15edbf0a65a26d007c9a2d524bc56b7e5b6bdd6b09890877effe1b37a27f6361367d4376d514eebe09ffef750f26ffe61f525d4aa93dad019abb329a8fcbd9a2861f8cbc711354d0f66dac691ba1abdc83a8735074a9f4f977b1dc4b7250454a3f51f2b1fe2ef710dc05c17ae5f16bdd90c38ad7dce39ab05a6ca05cdf3373e2dad8098bbe644b215ff4ead9367da5522ccb141c4c4f9141f77d63d426f702315c2763744769d3d0caf38b867509ddbe7fb85a05949860efa5550c656e599642d74e7b92cce7c350915776b4d672651fe5d8ef0d465071f15dfa390423b8dc4d4d9aa08c01bc6d0bd7272d0cac86e9200c91c4c513f05422019854d519a08b15f38874681813e3bca97fae07e62b6d69553eb24f7f01944a2e20f27b5f6b728cbf66965d52bcea818e44d18e102e77ea37fdb87af855a970fe34df4229463b4d6e7aab7f82ad4e580c5ab6374e027ec3972e0d577603a13543ea83dbcb69523455ee6b454a834125f34e4fef8848679401e422d01292325e0b39444a64eb95e99c29e41e68cd1daed2b7800b69a78a43e5a7a28204d42754d639d8acdddbb98ce482e48d7e98fec267c33226e8b018ae4f754fbf269d62311ac87b9eb69fb26630748fe1c1a964489fff7bf5cf99ef4d6a121df810fa97febe0fa9f6de84b20a25c0b7ecc3469b57ca65a51f8144af8dc3035f5d22048ebf779bf11e9e0b248332a69b4ee94d642ecc86a63f6785f2df537776ba9b12bf3170b8afecdeab1ab6f88ebfe57a437b2f2b29cfe85825b0cfa3aa1423ee34d761087ed221f389f957c67ba8992000581021c48eed6b0a2ec4a67a5809a287b040872d72e37e789961d27e8232345bf020024cacc69ccf230b6497207a01322e8eaf7d6e01037e903b091e0df47930c1d61cf967e87f3ab10cfb7222bb773a13cd73c2797eff2c84256edd2a94a8d8e3f6cd7c2db7db47160549f80d7087d0e2214ce59c8a60732b3cfffdc86d8afb5b4492e387bccb96c71c7b53f30c44526f2b83159bd087341fd759c9470446842b48e831ae8e989cf05020f6ba4f1e251a0802257f83f818128c3659236cf780f85cd30eca7cc0b3772c32ce084e9f218e707e98512fbeecdc4b0ba9272b744d5fde4bbb86c1977155dcf2d0a93c3813986ca393cdeff04965c336aa39bf1cd116a5b4ffa7926658e4669afdf845d525d1db03559c42fe17fdcd9beca40327d9bcf0394f8ca446d57db21104c04605afbe1eb2a19aae2d146db420963fd1ad03c0a6b9bf949738f55710c8481d0b4db2b87f4dae54ebdccf63231eee9e92bbdfdacae327b7fe8da5898538d41be4658f5bd62553ec69100289f22601d0de7f42bc9b0bc7d38fa8f6e78199aac53d1f8a521515684a4b6748abb4a3d9a3a3304edb18da1d579456df3162f56f9343c94006120b3f4c1fb9f6d58667e23e48bd30d93dea4b4d7fa5e18e20ab74949dc61e55b5bef6a40929e79794b74d209bfa519c628e9c19a10ec0a4021f0e1dbb3548899ab41af6c12a97f5a038f6d6dde36b0c480c2a554f6c7e064033b1248a1197d11a36f2616bf41deab19d6c72ce6de241b49fab597a1e00c145557b3c9e2ba3be9d91c27bef4366438b777146ecc80779ab666bb23b838eadc59af6556e7b3800a9280cdf960d65222b131fb77a3cb9c0f35c17158c8084bbcd16bc399bd19642d1e65436a31f3e666aa85480446d80282b388e7a0203d95c603ebd7a6a585502d3423ea995b818cb504037b3b01d6e5d2dc51e55bdc8360a5d6a00cd11b3fa67f96190f0c3c0a1d643e6e7f8cc52040725e5cc66d2a5590a84089f607fbfb8e3fd46f5d08e2ae4360a002055c5cd7158f3e8148bc98c8ab6e1180c25562343e8688ee84d811a41742edf7321cecfe2f56fa2fd1dce71e2bbbb602b9e0ff2da3b15db3db84ad5e8e19b92b160f55cb256ff275c0cf99eca7962a1619cf86b55948025b2bc96c32fa852bfc5cb0e465a1c743d1528495aae1d0a4f2706b3f52de435c4e55d0504288718fb7d5fe3097759902c18288191e0e815a0265ccbdcbf61d9dbe64a4142b3a80fa570acd5afb3ad547208329f36f82cbc44e3f28c20ed5c6f04d12ae5d9240eb5cca378b6683928b37105902d79b25ea17e92caec3afc46d53ac38369104c9658b32886a961ec8f08b526fe73c23ea963cf6aa5839f4ecc82c1b37bec1a3b3e5daafd73f41e514f32a747de62caaa5ec30497edb2c3b4717efa185903f0364a69d32c7471875f08d525738f83eba661bb93eb4a69ba9aed89124ed5e7952bf3dd35e11a76ed70ef71df4ec3fcfce3c99c3cc4907fd9e8c41b4085a4762fb57e706c20048843ca25f238d99b66952d41874c3db609707622249e32d9be9bfd716e4d07aab3af0c40ac50834a3deb65ef6f39adfa0167f87f4f146f9e4a654f108a1a5426f811ea19896193c9f349e837dfb30d9fcbb402996922728b8bf58b7328608dc0b9e9bac5d87cca166f41626ed4dfddb5391b5387042a4463c09c49ac31146d0d1bb7c85cb9a0868f01ee084a8d122988d692b096a644ee54411dd3489f7bdb1e627653371ee85da9d67edc4787d8d3a35cf4b374816e61d0e33a4e3185b2c2586b2784dd875e18721d326ce63ec2c1799a937ff9daf0b666c3cbc95e29f68707306d034cbe8f3be28b03ae5dffcecbe1339ba470d2c171d482d6cedb175010d6318f6cdedcfa0de8d983d8debf88f626aae086a11bb81e8037265c717092fd0bbbf97209ee74c0fc3135eb53dd5131dd7ee31e6ab9b5e3cd6c70e266756acb9e7750f5627f5422d1566479c91c6518e092cfb20a7d01668f9d6c58ab7223f80ca4b67f1e696f3a84e895b7bd30750654b555ca36209cd26738b47d33402b88db41417674679d5b1bd5a774be4c8f07af9c6e05a8537566854f3ea36c18bb703292a26f500f3e72546fd84e2ea04242005d8f57f1ce1f848868708f7ad8123da35c4b84f8e8f1568d8e55520783c94c4088fc75b3ae9ff77aeea119a5e8c99bd250c99af3f30690e33b8749e8c2ad6f3fda46b31172d5628a6da5f0ff1b1c6d24f1a155dbec0fe43577e0b4db4831587e3bd8c96bddc01cb51aa41ddbfa5f35cbb5d43f3320c1b69eee43d88befa431e234b129c4ca8793134676b75a4bbb158bc0661f45820193853a9982e828766441e1ca9330dd6602e178c9c07e1c2dd365aca94ec0e35a4f229c695c2ef7833d9080310b2616bbc173f8f1828335288a378c07714284564f589ef3290eb5668c56b6999ba1f58531682c2e695ca93b6ef467679976a6db4a216b48ac1f056e7c0affea28263d54834f7a7c2a634f6b1a7dd212bf273162eeb1c56b4f22809becc90c1aa6afdd294bdd88292850bb703d646a78f4eca8205c20f4b9a291e1f6944c7778c8c198cd7568a99c797350be0a4d41877dab26e8a3a49ec672a1862783e57dc5ea786761bd0969e7df5aa34422437309bcc500bbbc99a6da11ce9421639044a7a8c0053279dfec7d4abd244870e1640cd20937035672538806c44235f206e3dbfa81a1a225a9a0d4452ef09689a82096b83133aa0281f2f936b6139574de7c32c23ea432a367390c12a19d89231e2343e8caf45e8a1a9085ab85db9f5b428f4e66ae08ae502e479cce9ac670f5114c9a619f15999723ef22e1d3dd6b1815263fc9571a2b37130c377b29c66f44f8c718135f35e42f444b7e99e4bf7fffbbffa8b5845c0595b0dcf2363a80cadfdf01bb41b0052885fb9d477cd35f9e62e8dea7bf5141eb104105740a97f7accc26517eb526f9fea9733d8e792b78e34ca4ec0c547759df7df13d41ba76992770e62a6e38b17e329dd4c50d27e57592b01dbcb1bc9e7730d7fa255bdeae92ad063c37acacf9ccd245d0241c892f239ae883b90e535fcbc7d5eabb3e180d0e49fde2e4b727141e077de14b928f8bf4976f2ebe08473e9236200918e3b2ca4e3b955a9aa45a5da997ba3f0a49fb66223a76a5eb41a8b0be5bc3a3c18a91d2d884b880d3676c2a13cb5598bf06201f0b05ebb0ab0e1d72b60170b6b5f5644b7a27fefa9206e2f5617aac0d2624ec353c387d4e274e0f83715e97b1d193c47b84d14a9fa2b6df7aa975fa1eea0f7985f6f76a61758ae7826bfcc6f50f8eb37b8c8d5c88163d406080e8a4d6a13c36550a2c3db61c8645459f885ccb5885fdd3c17173edc90d82c7abc518c4f2a15cc234885431a6da445c6ff2c9b129bfad83f7e5b89fe235eaaa13d972bfa630e2205f57273cdaf70893ea564bd061b7fc9b3495571d8d856ddfeaed4af143268223ad7c397e6d21a7777fa7136459a23363f48b407d06c1925ebbe1aa7146164dcf8253db231cf5a8de0854adbd250128b204e8bdf79f76d01e2e2134947a883124617191b03c07b4114ff66989ddb829ac5a47ef3815aca7bbf6573bb533ae95c7df767ad6e6abd9f94264a5cafd9b0cd73b7c1aaf0cf1dae9c17f4691c4f1b407f1c60d5fd2ebffa4935357f13b5d10b0eba97e3b30164a92e799574eebda1ebdb1a49e97a774d03f1bc1bb4ebd4ee8fa906698139f4643d6a9d6736ee2951407452a37f1e11c9a8715722e62737944960d03fa0cff32e9ea57ce7aa6e2bc3a04354f0e7faf1c8d1bdb24401e8d7b4a5eff895fae7814af783f4a60be6b2270f9b3e4b58ee53eeb354362e1b80274b3662ab8ae0ec43fe825ae7742caaf80368a5bc22bce637a7191232f684ca71fe4630572d39e58575747cc57c3cfbedcccc1cec3c6336a6bbd3123fdb6eee515928f9f38bb01c6b59b382d4c93fb7d856059c8d8d0accfcd12be9c1025f32153f3c0bccac2b3acadc0d3bb3d619866f476806bd38bc2fae6ab1f4dd73abcf5e2b0554e782b849f7d6f2315893a03e582d905f969ee3207ac20cbb4acb8867015bb13213ae821179b6d5909c81eda185a8ade148d80689594428337b5e7648671f0f36dad60578a82a74533a4acf0d0662c319bcd1d4631751854211c5331ac03c5757c5c77288b0501a67a8ff06ffe9fcb6ae5b9361696a08d0b196c1bc87328e8e69a6fe787b79e87dfda488935090f28ac466a6658154aafb83da24717af9d872ae9ce302959c2fe85547177c0e7a825de980b9cf62c33b7a8e1f0b87b13ec1464bf2a558021fcc4011303f99a2e5cb72b767a984d12e1bf6d94925bcae53356bd647631fce2883bf72de3538e761e413971cf3eb72816b2587698e9177ff67789e2c58c1ee7377a49bf1f45fd7387ec2ff2f460aa984dada6c0e910bf000c9177406b5fc6273510e78da4f43be43dec60dfeefed0b5d4f06ec387bbd4117c84cd7bcba933de2c68345a95a5a5a3f8cd5f97919902fc223976eb7951e65e2387265e57c58c00375b706274a25fa31653837dc4e9a082807b4cf5cfdacfb617de1e7e450eeaac7dc33624f00c5a7b026a7444cd37b7219d191faad6446d4aa891f8cc5027da45df3394ec5662208f05b14304dcbf3610d8d81b27164e6bb14676ffe06783c5cf0f9dfb7431c2fb877093ba64f4e83ddc886b2c76035972266d80998f38e1c8ce77a4b15c418d5b855b1d398067478fd3e16f7440c4e148f243bae7b400413b1994755bd05833f388bc68d015c2ebb23d0605b047268b4b21fad043ec049ee95b9988f0c0841251fd9bc94c5d20775b57f4ad0680ff74f86e66306561ab163626ad7dfcfbd7c7c82c93ded14bdd9657cad986ffba4a37102c808c08e14d987720d0f6f4d2998d6664ab2b6ecf29c42b44f2d817811085d9294acfcdbe3eb4a6160151ed71fee29618273c38b4dd049706e317d1f70cb0b51b049c9bf0bc27899da358e53db87edc778d60f46cfa073c9d0f62dc21b346d761b652d42aad2817e8959d2aa24bc952ad1c0148046334b39720c71ab7cd7576838bf1b80c6c17a844922aa3c51ae4700ed616554928d26d1a29ee552fb4e2f07e6fa45a3d6cd759d7db57c044b4fe5a3943e7b7493680a8cbee5d282def896c3c62160844df6d17c24efddbd15ccf4e7ea459615cb54385022f991247578ddacb60f0c9d9e9b4cadc6fcde57ea6d95db230108a41c91e4779192a011845121d1552df4632e34dbfd18ccbd0857d1ede7118e94763c64395dbcf294efd0f28f3743cf7f26d02124ca08892f2c2d864afd46bbb00a36f606de513a79e459aa0386105103a2dc219e08412a5bbbc0f8098572c7409f5223933c691b7dbb624d13416b2caca786969ac6b0c905a2a6592b2741bdc4e98ecc956f439db1cb77067ca186073ef32e6759216959d25915bfcf41c77d78de6cac3084408a19cce96a19f98397cd93497ac05842cf70786cf8e58431ae56097e3bf0c63a38c5e401156a1679a33e813342cc1aaf9b9c078c2ac67360ce94b38a90de089e068aebbfc3c386218c76ea5d994134bd459ee38580f34d7626a9d13dec2a98fb34fa5daba83ae7a7061a49f82576d2342dcbdc4891d59eb43e989ee680c351ad13963c969d89a2a4414aa430005c45535fa56f39f3d866627a8ea845656809c0cc1fc901de3055255b2d22338b798f2c9ef5541eec3e26c60f43eff3c20c025fe0ac96f3a0b2069cd39c0b2e574359276c9095220ce5b5433e4f6e023e70c","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
