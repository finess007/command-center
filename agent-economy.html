<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f3b640cb39343abfa7c7a4ef96741bd63272ab217b42fea003cdc8e6dfd337b1541b77733f534339356458102fc6b1c36e90500566745eddb2a80a89f37aa10ca46521eb4ce701256af8034222e019e8ea2cdded7d431e9dff79eba9710f11b0538ef382586abfe6b577a48f28dcba9e5c2eb8402077b1247ba2d42bb5c56b4a26f37d08ba9fc3187a0bc2edefe7d44cc4199a2273f735d042e4ef5f2f37342d0931a62f73d15ca856cc58996e5a369700b824ee67c88fa134aefbd730a42c6c8c379e2e249496a7078acb266fbdf6424a7c9231fd10ac3e2bb73249f901bb1b06b9829ecee984e353e7b6636232e369e2ae09bd72a17597d97b6ffa029910d23725514c6e92b0e5275e37dd1e18245e6c24a853f5112cb951f79082a657a0af9c41b2a819221b4cda9e448adfda965577ff5405321e3e90d49c04ff99252516497f441eaf7f44bf212447cb798af50329cfb55b6281952ec7f2279757671150cacf4fd0e6531803f62f5c667f9adedef5314e8f6f03b8d60b180006e91ee3390009003faf7d72981eceb41982d99ff8fa5b0409e5018b93fb7cf5861fad772a03b95d41124fa32797bb4e2efe2b28c28bdc48d8048fe50afeaad20619bd65ef6ba97fe95d97f248a2286444c079d09527a8bb92c8f0b82079b38612d9b96e8319fcfa8f519e14ad1f1db740de5eae49b44358977e42a8b4304221165c7da76ff4fc21073e1baf599e794cb9b4306a377e5de69fd7920191e83a6db00cd8d840160c25de960036095d1ab8e17e36ff119b826ee7fcd327ddf1a6dd29d0e76ce4faf0ce378b32c0ac5aa857ea95f80d2a6756bed4b288ca5662e159d7e2ba2c7b8b57c08bcc97a7fa8451540af0fb32937110c08484792943a4049fe5b42dedda01e8adc657ee22a95e345b0823909ba6f345dff9f6efbe84c497c125819a181546553fbc55d031c84aa23ed7b12b6a873b809aa94ed2672fbd2401f87fbc7a5e3ca0e003c9663a02565adceb9390917b51887f6f865da92294f65ef0b52956be3882240c61a2cbd1df137492037faadaf2a5c0e6e4f89d02bdef292421841f98fb3d1b6b3f871f3ce8b4ed43292b1284a18b40e479c92c319c81328860b43f75770040e71c425004d2cb7590d45a1c934ac54ef33567ea17e2e4b67e4273b4e42b8cdaea7c33746fba149ab7ec2daaf0ff5bfd1aaffce943e465c685e3d735d193593b1120e656da2bca97fcaf4b7ac4535665d8d59930f8087688f1c9c2a31903c8a15fbc9b2e318a2beee996214790503df77c174fd8f04358a74f2c7070c82f211dc6f601ba4904ee0534d9b3a95f6c006e515d20d9e61a785ddd9ef67828db754a915ea8538ea53a4230003b019438a13c43f9e0ee1b701e295522fc8e1c0652f4e0e73a34716402deca1d1994ea3811d0b407c83dcae31ce8dee7923552330764182d5538c382ea9a0a6e3f3174bd229a0654085969953f46ead7d1486684d644d4951110a9721a16e9fd6f840fb75cbcda6fdab26636e01312fc6b62436911a5638e7036602ef94558894bc3c8b43c1886c8e3550688a9bbecb96b31db5cb12dc78669c56028ecdd5eeac05742cb2afa5676a0f24b47c9bbfe5a91ceac1c9e66f66b279d9050b226910c62a446a393f40030e6b9284e365636d98c072919fe21057dafe16b7417810e84ad30af2eab2dc749c03f12112d8f6192a99d4ac8d2dcefa90d42b4cf94b1b97e7dacbe40d076430ac5b4db82c7510b93262e886f0e175793d5ef6341b4a08e84a7bc5dcb354847ab430a713dcda8c363eef83472fa77d4767885ad2bd0bf143909c8a63d6af4e095df7eb1a1e810fa6a3eb338e82f8ed7bbc0944626ff18228ac97909407982c80f3954eb8a419da783585dfd6987fbe779de9719b2b7fae442206d06b00fdfd0dfb9a4effb478ee50d795828165d9c8bcf2a777390653db5e925f4a9416643131d891841e9ea5b9b9afd31d92f6d775a0a3c270a2b2dc6200f1b31bdec5f68b8cbde717317e3cd2cc8d5859eeaf5897bc35ee24187311eea14378c4d246a0d4d759890f67e6d83d51db8660cae8bacf14f9fbbc431650b949ac6016bea6ae6e065dd25b4c317f779f0d46fd77a183003d2e8aaf47db0f59c401acffadefe90604f86dbd3481bdd9ce00c1ad4cd9165f20e85e181a48ae47f6fc4158330897c2c2f0871ecb6e7340b52ff14e1d7d9230c786d555063e766309c5d18e40dc4f406a00aec5c46c7ffba3f9482bc7587d4b9fc8ace298c51577aacfda4da882635d25b243397c8a38de76e99a4225c4426651f73f6388d38484c6e0ab4856ddfdcafac85b8fea03f2688745647e0006ac9df1339c2d1f2d020d964ba37eeb080d16c64f66073f1584f6c9250bf54983233d5ac13797764d1d145fe4607e0fc06fb3caa471d0ce87ebcea1bde4446103094db3051ed060965b1fa783f4f7301e8a68770b959f241f9a1d0adb1507cf5eb140cd6b7a0400aebdf2dcd098d704169e73b57179b6914ee8366e879eac9493fc61beae3908b2864fd8afcb50dd47074062abe508cead8f2e4cbc261baa34b3d1a9fccb35c7506c54fc759fc808f6e5d6de7430ff2d19ba2e401613a102de86bdd5716361eac7977ef014a536f53804a50227d01600f72a555e2228dc264de012982a8423dda367fa7ee25d5bc83455462b61d8d7c36a49f728f2528092b09682c8857b3b2331eecb636b4bb328b7abb68c00edb02d26360b3620d3e114aa8696eba99b2f41f90ac6fbbdbd7f82090c9f10fe6d5148c6826b5dab1bda14af8328f0949929c1d2804f745fdac9761cec25987be0c3736f32ddbcf15472ea464a528a573e93e788e1248eeffd5dbfc2f9123aef4ad9419c0ba2eeae1f2df8a591f177c2abf1c9e6d30c620b0b053a827cca8d227363571bf28ad86c030ae067e5436217c22789d06d6bc851203dcd608faea5206c0fa48ceeb1e098f6a1d7645b2131945df45f2c35650a9fbaf7970f06cd8a2508883bb884f6c9a7e0046b503a98d304bcf094e3cc34e37d3e140b79ef1a61a6546f624bced6cf5f734a71941cee312caa6b647e88d1c76ae604153d785b86385916f4133450fb26dd3be9b6826c92b4d9a49154d440f89ae34296da3157c858cbf29ffbb115142063e0b424d5d351e6dccb373e80cb11edc7156b4ab544c9435e4ee94b206606d7c8f5e17e0103f7cc7ebfd8c4ef3918da4c1fd44d79fe69f2eef7fb09e10002b98dca92f052d59629b6fd4a68e7c1de841368226af6184e3d226fa773ff6086248b94e5318beef380315186670ca21b8069c78d2ac9f1a1750c810eecce69029cbe8e8056c93562c496d644f42738c672838c38ea9cdc1ff6257992b8b4a953ee456806adc43154744c54128d61f05e22ff653aa65e7b0ba6f890c623168f488ef5da263ece1cb11693952bb3061e616e30ac3ed5594c7e84fbd49d9107355f9d6f08178c9497730480b80746f9443635f341fbb076f31ab17ca3efb75d51a0446421a2cb3bf08b414f0dd2a3e8d909936cba0eaaf2f4a0d1d195f949ccf3620c001ec8ea42d589535fefef4c82c32b8acb039ffd824e18c307c8f0f088ea3ab81309e01ff2c0b5384476ec909bd766f47870dcc7fa613cca3238f4ac8ed85be9ca16e187c3fdbcaa13031efc0a6d07819dec86bc195f47938e9e42efb669b2dad5840564a0c749d07548b95a7cf6e0c1020328610074ed682fee846b8011ff33ad6d513ebbd2ef2a7a1075ed09ab3e3c294938c609603fe6aad925ed42375c504717f9b1e4ebcee481911b8014b435a69cea1df9eb31479d47c00e16253b492d5010f57749b0be6cd9aac08f1e9c964155ad45610f5585beb98d3944e658b0eb74681f47829504e5892ea1b4c959f0b2f8961199ea85294001556efce2adb5fe4e3409c5cfed053ebf285c4e8b49d6137b4d11308bf4c234c614c536348e31778fc0348ba403014541f73a64565ddc38953c82fb5f903149b3b71d0891cb4108f5deee020fe19a1fc24ef913e8c01bfe6f17aae03e8f9e39854c78fedbb44fd371c92d43c1f36f7f3bb1ac0ca0a37140f007429a7848fc3161dad377175b0b0757e26856fba3701f38697e7b9ff19adce1dc74ebbc0cd1189099fe28061290ffe749a85dec59194ccfb8fcb764af894b32fe8cb3b04909377fef0223d7440116bc808f65b07d955726d6d598e6120ac47fcff25398375e3da6ae0ada3ecdee9b7890589a23a5d2be813efc6c9231a10e6743b02296faa8928d357a250c6865e57bc5b96bc75e1535933487fefb587c567d92c156781c4857e49f1689a28da24f5bcd5c186afa6270850c8b8964d666df8d66900af5346c22685d30149ac681b63ef92a42b03f418104ecf6ec7d8793fea15d9edf04a9ae16e30b1108fe376257d2976b0166ced3ad0fe303f804272a8c6e9fe02778693ea3bb26dfba492e9ac9e8f382e168a7aa78d886add7e7e2026c0cd835cc8a8f8735ecb66c5fa9a0b2b0662306b8a0ccb3cb814ea3872c763ff8e94b5224d33cc7be60d28522ebcdbf76af3e80c42412c8bc1fb519384c1b8e92695875a5ab34122b3bbc01ea23182f6718276c3872c6bc8b9ae80131d6144fae0a8581ce5e6d62ee33a35eba87fc0a9bf8144f03cad93df6a425d58fbde37b4dc3b8b3c77495a26dec520166dbb502eb2733c9c7a545852365c6491ca362bc312170202ba8de07714e0aaa9863e0d23e6557c2d85409195912649a9731a5357575a8b5d21c005c0a5229dac8a43e638451557a3439d51560ec3853cf3af7ab764af72ccee2cac7b1dd760077f5d510064ea730818ac94de19cc6a939d75913479b06a576da4c5c411c09709993357cbc3dff143e13556d1c0b423fd4fecce92187d66c5fc574f6e9287bb333e1049f3737c5c846c69fd5582fef5502164cc963c3936a707a26fd5bfda38be3da1fae2f6fb4bd84c23ffb51656af02a95ca178cb7825a44e2f70f58e990967afbfedf7aa7d6df65bcabc80eb0442a7040ace0ed3ae7d4041544f3905c8fb244f4ba77226c7b0bb2c57c5aed1312f9c7fe582bb30ab5d2cb6abbde8464daa4c0c13932402506b669b769d2fc4d7831bbd0c3f1781884e7c147173db2408f5493c4b80263af4e83126641706283e8cd6797e7604e64359d59c75f13b5e625a7666d798c0a4ed9c118520b938c89214a28a849b8b54d7be22e361912b0d034c81d002ac9eedb6edf78e62fc410b0b75f77a995685f5c0c664c128cc3da00f390e63586e0d55bbb686e51bd7bd45ec314ec01657d16996a7de1dd7d04fd3c103ebdb2c7ab77994ae4e887304d20d3425a188b100b63401dae307dd892afeab517cce2f9353798dbf97b29b108e0f3bf1f5005767c70c8ad7411afe7ed469bb57bba1f9ff80f815e390efaea3a22b49cde170526bb71f11b0560c247a994f9de7c76e0fb5d321faf8f5e2c9e07f9a086e6454dc397ebf22618a88076a664050f4038963bf2bcd09aa8afaaf7e887e31253ae51a661ed16e564293f4b1ba824a0fe0e13bbcd244e99840fd02b2ef5ba1b4bb6e44a198f1522b6dea643aedb1cef93d663916ddc71de93d73260eac1665d30d30c371d8f34a7e77f160cff686ac86d185d47f07357f955d440f643d0e75de5cc9a49a131b8424ee95725d6ee3224b8d22f4d5325b2c640211eefb00a57a635bf1e5f779c44c5ab719c691bbf477b6a5667ccd93e201adda9977a2a3f656e1431783294e10d756527e81dabb6debe23f54f63d3950d5385eea8be818d9614b582a11f3fc24255d7b4e220d0d7a3e248284bb21cf0677979aa0b9314dba2d3ef81bad9cc43c1f751cd42fd68bdaaf596222681f64eda75691a886770bce9a497868862959c19357e886c15ad0bd3c6d7801a9bbeb5767d1a71da4259b18e3b1522afcbdf42c4c215fb0a895c223b3d5622912013a06f53f21f30ce5e3d10cc473633f5941faa58c137e07ac1452fe35ecb2e686e75cbb4a3978baa63ec91c2753ef7190141404568dab22726ff5c345cb5c627e0e8ae200f57a76a82eb746291fdd1fa9dbbf761f5fcc0670bc6558f8a74e8c90b1ec6f0ee07fe7c57cd9f6f49ffd07fefb3539ea84153af9865abd6e8989c258318cea24e3accc17c9439951ff6145ffe4459b8116cbce98115616591fdafb86fd1c0a3ec5bf5ca49058ec4920e3d7c31c212c03d1aa80d9792a545c0243d862dd1ecda276924322d8ea363aa09e94e7e518bb62d3ba0d60b5f370f8528ee5dd7cca3d725444ab17b2e70bc2481daa306290fedf1e09488235fdfa8fcb7d9035ae470f8e3c107bb5275626201290245389ac108190305ce4453b1817b0c3f2c16bcbebb9c8768723a72072e7f0a8f58d351a958b8ab6a1373de2dc7b959afc489014a4ca8627d008766c7c229b506918d13bdb4339a32835aec014a604f0e2416fc6a83b0f80b0fc8e2285bf93c08ac0eb7cb1a95bca0da72479f3edb3961d6ab4085dafff0620a707f9ac1901f95ff8e1f0e6b5bc8c4e7aa0d60f13ad51e0d650f90f7af90be3ffd1948a5f931afac3fddbbc0b14e5ce2f16c5c3b8b6ed33d180da4944232b4e3bed0e8f70d6b011cac57c9ddd2fcfb6f7c6e8bbf9bc1c5ba4f64abf651ae9920df44c64d43ce536d43b53b8239f9a2db6756ac3b4ade51f24e4ec3e4e17fbae77ef3042c9e14d55f511ac15bbfe15ecd1babfb6d8f1c42a1caf40aef7bfe6e590236e82c77edfd9561bf4b0048bbef23afeace0290d7be48c62356f24e7a385e88ee8f9b46c21f50576c57668f47863f5ec5241e6df8a45ffab5cf908c9b3459b8602831785bb976df21d2fc07de7064dfd72e04da05607c6e2bfd9789f7873330ac40ae01872a3687e264b21a7b9a4d1700b1f4e517bb358340b577ed843c41370ca0a168382fc030f0118746b748851805bff77bffbe364e289252226c7fb425d356e67a06369db49973f88730d03ff5d2c68a9f2a19938136fd63f273c39f8fa3ce2d62f0ccec24f1ff881bbe804fae75fbc4cabd683cbc43e8c729d1991055b78cc88eb2cecb3134cf56952cf9da486d0ce97f557138593eb33873a6d92710a2f95a09b2f7e4ffeb955c3cd356dbd717a27089565550a52f790b36017d2b9989bb8b90d37c1619e6aab045a85d762ea28fa5e77bda9ce05ef0347bdbedad947989a29835aed447544a25316e2d7570b0fd821d0ecde9962ec92ab4eeaa93d37e9959731b494f522e698b7e176630bf67332570bfcdf4e2102c939dc32ddc0d6bbbc54f79f478845a24ae27b8042611b61521c7d7bde50632b302bdd3fad6369bd9e884f9e5fbe828254dd44131e1176bb4e90cc411fad17f484452b3abe3c4e52171c4df18e65223097832635efacf1ae6dc076951f0cbb40b3b85bb9a231b4d8c4c7d4e9006fbcb5661efed6f74aefc2e49ae156100888ef94e4abbfee35cff5d96e24f1c7ff1188a1cb76356bca2e15df377d9c13aace203c9e70d1d7e1af94dd75399b2954ac704815f2521843e0e75dd2a23be3d3c1d8a5e3d35a02e823b4b6c033d18b7a17114969c76113ab58d03e7ca442a36d4ee834004bbc6566ffc1a97559dc2ccd56afa3ee614f399e73ce25688431a9691c8f744cad48ade600958b0d2ac76ef0f55a85399512e87bf2845a48bdf0b7c1d1c8024ebebeb4a7e3506317854473d061865f385d30d5265de07bbfd9f0905fa145b72eef9178beeb9962893388782d5e3d9828127b7e6f0dae5c35b77a98da5e1b2e25393766c6188c87e1590e30f3005a37c9447ba765b8cdf795a31ea94710b56af1aac818974d7d86eb4874e924770f985a6f1f10b39dfb87e7e4dcf34d8f988707b9c00cabc897a591cbea618377f2cc4f1860e5aa378f7058ec6b5ffb56f719647b0ba5de7ab7bb2bdddc21562bc59105c57142aa89e2004249acff1e5b5cf7d341c89db5395548d7a6b53e5ca6401ffa59efc2e14a498a04f49aae6b8938ad593c31432078ed57c38c987d931db490b6790928afc765a6d6f86f70ba3c6251d5ae8fe8eda0fabd24d44decfe518f01f6dbdda7e4b540b292f228fa2f098ac6a17a73c48757366f60662e411b04c6ad007ed074e6c1431d8aa60002154050bde61bf891c48977f225943a03e9ed38d2c42d6c976199264364a629b9fd17d31941fe9c370de6a843b94efa84d037cdfa268cdb3cf6e5e58b896ef434aafa6c46e5cda2f4fb4f8c05c0fd209c6924cbe2ae18cd22775d8f244404adff27ee0cfa1e91394df8b3d322f4e5177d8126efb2f644f361418628ec328d1a7dd9eb4ed343ad1b01c43b1744befd8a990d968311d4cdbcfe25a62ebfcb33e3799514f23cfeb13c09c81717dfa7d8daaeac93d08c76653453a5d2efa657a516935af2bea6cf45699176faa0ddc3d246434ed39b433e0bc68aae3a6d8e96ec5ab8438fb375b44f3bb48e9ec2cda16c56895bca3be27b0464f9789e26a86a880530e8f18f52289fd2b38ed7e64c260eccd815dad7d60df67c37fae2bcf028ba415bf5fc8b0becedc8c88c892eafba991b60c91c777ae54ba551244e64e27b7e6b34a16448b6839c2c324e1a7852e7b1aab282ff0b2522df9d10ca857b9e4dd246bba4aef5a1cdac086e0a7af3e6b3f7c82d797849fe8e08a0213aee37871b663c84cf87bb5f95b6add236a9f3664803b774d4682d2bfd3a340a5c0441b15797225416000706f00837c08369c5bac9044d0514217104f62299e176b52bfd7a7e171667b099bcc5e08844aecbbc8019d3de66f587ba4337c7591ffdcb756bf68e00f00f9de36acddd902b3161f9f476c94efb2993ad731fb62899b3f39502e7c113e4208a1ecd177ab10cb43ae8e340e6571d81b04e2a83fa3509841dfbbcce27a937377b979ec8b8cc7822220984ef70e04682d8e59b2fda721e6343f5ca23a358d5bb4e43e0d1cd8fce7eaaae56fd4d40659aa565982a07bea92c51338fa246be8cb9ecc3605e97f73b484e9a4bb65125faedfad83a6eb92406e76341bf753520bbdec33752073b4cff7b4dd236de171369b1ca1bbb4355116baab85cf86e6aa5b335b7108a085e61c413c915507b0eff636f2b33dbe89cf22fd4188c6fd202b57df5753732b515e0098f926ea17ca06efc44c5df993f3d8ac120a5bd7fb69fb57d846cb3c2359e0dfdbc9932436901d47abe012757d092eb7e4a420decd3d988a66a0b95efb69c0f41481421505ee5e643541cd83950dd8d28d5a0a8d9f30a51d28ec20a306acf09af60cf033d0ce0109f94908301a86e9cb6eb6eb8313ad82c682a2c41e723fb4d1e7c50832c7db4906e8c5789a855d47ef77acfc6721848b8aa38b29c10f6bdc8443392a115de720653e047eceaccfc4b309e73a35625cc4f1226d7d85cd11a4b9057771b19ab338a7781f64daac2c038324ef1d3dbad5161724d714b1748044f2ee3466eb819faa454b9473be4f8ae3680c3cbaa7a346ade98db85d73ee2d946aa02082ef3e1dcca016fb17634ddb36ab205bad966a03f8e75c798e338a575065a4a31fdb7916154ea2f644ab80b481f4b7474c2c74dd38823d37fa85d4b59f1ce41a362abc7fd1c8c3d3a1150a4e333eba0c2bdcbaf0d1ed184b08ed1bc245e30c98a9f769310a633693528fbd18cf59de779cac2bd7baf3c119ff5f4145141392ceddb03c034aa064e016ba6697c0e78f8c84c5850dede5af4244574609ac6af109314a8244d01b8933b599e219dd968c0fb1eaa7308a22ed25b1dd1eb23c1d8f407fd7e724470a4cd5d22cf7913c60d673a851e404c46e7dc5b9ab20e7bf348a8ee04a81dfed920a404ad4aca5ad0b1825c2e611a4abc784a0de8ad515d5ffd2b3aa818c328278bb534e5266454d009edc4420cae08af4ee2d6569bf71d2491dee4b7649f3a1f751940145f7a3ec159055c28fd6aeb9364bfddfe2b484d3df619f3d64508eab39d5d27328128cf8a003460e980aacd3c53a41e79bdbd17c8dc3f8eeff9b08b31bf510c6e120850c3475782a06579812680b776ce35ea2a1f7a31345fa3ffbf3a506445fb59f8f3c78e00980adeddac5f9681a57c887c14a5c5327da66942a49e73484de0f6b3dc08b68dcd9a8bfbdccf0cfe034ee252e71778fe179f6e1aac3bd51f0ab7ae4aca599b9d39680a511bfa23238b8cbfe50e8115968429c060e9f6f74ab782b318bfd1ea7c125dba73d5a616c4c5087a7250a46fa6f2c242f57673b4f69d6d05af7b6ba7a8178d35b7402073e7b11315926adf61a1e533dc1b41bc54de655c00be1122ffd96222c0706374cae354198c3b5931abb6d0ca85228cd4e1675ce8955480cc68ec746d813bac6e3a4faad70317ec56f6c09f3c7dad191f7e2b577a657a18cb69aae86c4b03e15c26ef1131bef4d37a98a79db7e5d6c9c351c41971bc530b4678f20a672d43799e69abb7e26d0a13e8aa86b28363abf1b5211c952acc44080c4d8cd88ec0f6817d8ef3415cb50ee06751db156e554cff0eff2492c8dd89f985ae210a493e272e721835d37dcb92f029797f94edf8d44cc40591f0dc5fc558919325bcd5154088207183f279152d53130145a580d0e04c416390dda96cda8329cd624e4d153df3fa9a607ca4df32c6e04ba1036a1f812fb638c02e7931b221c1ab26f858cc586c1b2f32020ef554affbbb880fc36ff5ff5b2c3a4d8522a994a45d0b665aa4cb7e4d4314e85728c834a7c2468ab365c165604fc010f25dcb92cbbc8427b8d78a5cde2a7f0a6a899b5afebfe152f48731ad7141c308817e41b55321bac8e1e55403762797775fbbf2d54fd6062030190d66811269657744c01ce7f5986a04e46d964ef4b133e63cfb943c6ec521092d228144e80abb43b28e417e5fe85e2d4841164f3769b8d3dd87612889ecda29a5daba5276df8b4e6c19ea2cf7398e08d80df0461779783694c3d412397d89e033e82d54592711bde8bedd9d419d6e146f8d9741d45a2bc6942511008f3c9e69373908d894b7da9d3887ce249286fd524c019239b83666ab86ff35bdbad36c463d6e956d43e1e1a591ab4ccb46ac597ca54e583df62e5bd2a9cb6c531419b185d857533ace9715f6c42bfad7af98b54fc7974d833c90355a66308bf90b4219416b53f5ffc3ecf55e971454f6d73f71786cafd98e31eb2ef7439d41b6f634e7d671dea4c6f2c2b94c4ae6261c2a67ccff74b5d66bb5ead3ab2ea46d641dd14603636e80ebdd17d719c5b525c5acd3376b600092a4a58836ff5783bbcfe0d1c13fd62e43b0b3b3877642d2f20bd1fc93179c026ef2111b80826b928fb52218945191aa45883866a8613956903c2b2a1bb03ef61c2d69f52b9876f632bc28511e1b6fd8ac7442d7a12ef685823bd1e41bc635aeb1a0745b387e8ea04b68a99993466aaad66241f17df9679c4592c5ffeef3540a5e7b75ec4ad493378838428dfd131314c81823a0f79afbf5dbd5186c69b7bb2fa822ce9d73a80478670bf4128be619c8df8e6d1aa62034ed55acb6b90457f72ec53668ea98e4948d658c001eefc25a810cccbd0355c4ef1ffdb0099689be1bdefdb45d05220da0f1b6559736dee8e10505440455b1d395c91bd9af539a2e0f410d012f70f39a1ca8b4ca339ffe8d2e547a295e4953491700557fd388cd00c5e8ac0f1dafa51cd5d7aef38569da0ecce7cc218c19a773c8c1820ebe3defed0b2ca0fd0cbd5ee30beff6f373bc165bf2972dc3d080d059acc9e5e9ea5edb99b819fcc7f3265b6f43cc917a33c03820533a4560096eaa274f832e7579b629928d3a311996ce25689d751671824451801567f7afde2c5a62d26b20afe1311cae1b46d0b79cc597d0bc4cf991d24411fdb9587a6d21969af128adf700b240a6f26df1dc2067137e97d57d6211ebd03b742d0634a46349d2dbed480f1136792a1fd52de5b99161994bb79185370b094b8ede9791e1cbc621770bcc467222d94eb9b3af129cd9f4b3602b5fa1aed8e5d88cda5870ddd6d61eb6fb2a7d9a18f128ec3bcb705b91abc1ec403019f2b6dc7188a2ee12cf322123df59303418ecb9e7bf8328c70fb51e9f79f7b6ced66df79e5b5ba88cdc42cc0a3ae6115906b61b14de240f1fc30c6c2641f49a195243436275df4610d8a2328f32372d2bbacf23f154d9d849b57cd7e1895be6d55e6d9fa74985680096a8546320ca08386b054b5853531d3356793756a171d7fd4c72a2531210738879122537bef50c9ce70ecbc245c77ed97b23483ffae266d450fb48b9bc59bba23a3307f2e6d96769e3e953317140b92d0851ded1d1f8f8b59df892cdfccd2efcb18bc9e5cd788f697b859dfb208684544926962bc5c4a6bd6aaec4d3a98dceeb6d291278e51f5dc2bbbf6ec4752c362be670515011c034d705ee868b430767f11e33adb4b22a8f74b3711a7581d56afb4d139a35b871ab8b51fb5d7df7fe5a9c7ee827a828cc6ef6d6c9662f2852a75002228054bb8a6303f12fa9c5f6108d06279991abce9adce63836b0e9037318c99bac91ead688feada1d8056c1a2687bf83cace1e27ebe8c321ab6cd0d310d7658741b3db793030ccfe92adf5d6b7635923d15626479f3b32ad7d5402de72870439e62ecd93ac2bca0a9966ee6c3a612585af27f3f83f4a03105883a06eaebdd88d78978927cbcd4de9ae4724f936169a406f94b6370c1825fa8711cb3552d85e3b1e89dd2e5f416bc05907f5e8dca1c672680aee08126ed4ee8a25b5b3928265d4333c11caecb3adf5868f4ebef1ebaf4db9ce7d969e7033d4a17c3726f8d38a7762cc489ecdf6c51390be44c77705d4ac80a868fe2dc100f21f3891d4c7e42b45f889a6ebf3ad679c3b403033fd07bfa17f9412ad32498933d1000fd70abe5add01df8c59e5a9485c5a453947df06a220b135c83f0db3aaac2808e8995a647449b78f974aa363dd5f093dab9f3e8e879153f9b397a17465120b3730b375b5eddc663efeb7c7b35a68c5e5b5305c272bd0cc6383cc508547a99530c6bd86876692a1bf3380e689f47c4683679f5a068023f003e93d0af1a6b1c4799c1f3c8b016b9309fd932063224f99bdfc14073d35651bfa246effafa15caa1687c7596a1f1fbe6f1eccc97cb11d15b7be04c2bc921e70096809412f05ee7121a0d9060e1f0cfb259c4ff8bda8f36e30b84f28c625b0ec9280f3e476a08952318b9045fddb6a07e3eba5f6dd742106ebf8e82416d1df8ff9e67a5e34dccfcb24575e3cc7086ce8bda002aa860dc6108c7bba22ba8e86621800410b256775a41526f9d26aec3df7b18102fb514f1413eb9cb2d8536dac43726207a26037feab036a6846fdac704a78361bc4afd8ad25a165bf7dd6197ee85d84491ceb936bf2e4fa26ea7448b77f17d8f2ce765586ebf23dabe1ae8e1699e34bee9f4e1ad3d4146286901f4592b3bfcf937bc646679e5f2b9aae62e22401ad259e8a6f4fc2d7f93067aa82539bf53cc7fdd0b8c7cf96ac64dfb37a829d5c3cc78096a5fe1536c5bfa0720c7016b50475c016ae86b4eabe0b0db93713347341d3c2d26f9c2b38e08bda00eb621e084ea01e3f58725edb0c54f7920b5027e52f695001485f1d8cd8ba1bea42a7416669350ea0175b47a5ca764866e690f8ddb393802b0cec8acae8b13c6706dac5fb5b07237d4f7fdbcd9bff0794498c838be00418a49b17dec6f3699bfb0b98ae586031bc85067a8e9e5a7bc0a918d8ed9a3ffd02bbca5ac5fb728c6a1b0344ef0f851d4bace59ba13d1d5483fa6ef4afd597e51e05b3a1c89ea8abf6fbed200fa136e38bb4fea7e6c9ac2e060c185be519d0ca22eb25c1e66436a2b46f9019eea6ef14af2382a3cc675be751adf2bd0f430fa6fa790809ba89f74c3a56823de7ead86fe60c0eaaf3d3910aa6c2928125eda9ad1cda966715563ba433041b9e248c1cb3f4b10d2ec1d276e0a25398289816c5a6b43f2fbf3986443a4986b13ac49acdeb26d0ef84bd5782afe10ec23bd4d6a38ad32f4fef2be2aa7e6c7e67ed002d054543db4925d7965d1de1b63ac2a4339827b5ff6815d54b10cd86a2b87db5f869ee7f765ec56e11f97e04b4b85622ad68455c0a72cbf998cbb408792fbfe7e889cd032e4832a8eaf7ccc84a0b3db5d32f60766ee402c4d3c2c264db54f0c37db0b14e48e04496516c5c74d0771b72b5ac9a8b29c8b9919224ac9d650fba074a367f481b53991588674f7507cd89136c2e0f7f179b03a75f9a968dc9cc0544bd9119086384a1c88b7af38c60eeb747b0ce4e8839c5b861bc5ddcb0a4d41342f50013a1a8e6b94205fc3c146bff5a65823b0cbc45f31c8d200a243db22a7cb0a4f035004dde0d25e6ba3eaae62a495e8886b819dccb8b9326754525e4cdb6216d4a6483421440fde8dc97fe0607409663023f964bce2db263b1978653942d0e383671a2211cab876c59da73e974042e67485e3236c32d97949dd2e887779e2dd924ea2d2b36c24282c9b595e9aba041f89a2764127d1bd5fe1ec2df730b07c107d85e7d5fa5ae8667622c8681d0786d5eb612b78bdc54119d21edc7af8c33d8bb2670ca7ac21f9f6e95d9987d7336521aab8ab7d9f43730de5c70980069466b3f6cd7129249076286d59c400262968e1ecc1a2fac82d69fcc9e62f455ff5435dfb4de6e6214024c1237bde32ca0d7ac674405d6daa348887bd67e4ee9db30bb140bf3fb473a941338c5dd51f62624bf4323299e7ff2b7c4235b8b27d8d1539bad3fe48ad3edc6bcabe6295e0edf1ae8a52c508c7e9ca48a7bc1d02e51b4aaf8e1c34e0363943ddc34f9fb04281d19535f8fa5f9a0980d3338532582dd962626a842502b1c191323237d54a8329c8ae21f9ea3b465e423386df924c1245ed21af47bc2873b7aa1f27a5f58b02095b371f6d149cfaff8b410f769a3a09d95ae40fc177755a0ca06425c39563dab923fb0c3220724f178cfbc6911688e6a3dc6e65892ec1263b5ae5c3081e9e8ba6e40bc5277d35eb7caf9a516fc92995c1842f9ae5770427825e88bb8e1d69605bc52141c0001642281cb073a4050cf1489875105df8617f0a48c205b13606e3a37542966903f1ac064492f9e5e2ffb42cd1199b891d587d3a85559dc8e72434ddaef0aee405c480e7c6151f35db34faae4600c285eac9b1862a5a8d3a9463241eea48dca5d0cd0e06864a9b6c16f7cc633ca3ca3942c86c52c4704c25a83c12e59543502821c96af1804eb90d2a7a2a6e5b9eb71bbb997af4f95ca5e1c69027e1f1e9aeea7c30a36112ce44888df2666c6d16deb6b8114211c046f79e6d91c18d9521fb5e6f1fdca404e9dc4f73d13c453625f750273568303dc3f47eb256b96794e4ceb4f657f404cba5ce2adfaccd623ceea32443652c037e85d031903cc2640a4c42a84acfa46ada9d503ce3b773c2abf510cb4cfb7cf4a76adec4475f0155c307cc26021183d36dad91963b9136894fff1132c5d1a483c26991dd9eeb47a3d7aca727bf233e17feb612145e496eb07fa9944a1bed5090ffc32fec7e893919d39bc19fee31f10177fbe3f4baa774a94b639d2517c9b84dbb39701e71e332d69048e4b604c55d388c4a396b9db072266c7160eb7aae23762e124b5ab5d074a518fe4200c799fa09298a776f90b5506bb6941ffc6745365fc7aef60fd151e865c93eb7499ac8e9d9d4223f9365b1f94a299935f6406719171b0d27c570545c7c9e9168cc85050306532deb041d9e57dbbdf7c859a3f26f352b3358dcb4ac9c4f6c137acc94a9daf47e0d422edf3db52b40003134eb6acb3999415b2860b699db42fd6b50db845961c509c39c899ebfd233d0a6a7ac8a6733c0baa6b24e5a4b6622ab3047357c1c948e5a3987ed798b8898d728e9e9405207578050a610c29fb9121452f4c8d9911da9e843a8fdb5f58c728d3b3f9cf02546c19","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
