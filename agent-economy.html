<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7d24c8480178db37b7a5b06490fbc6610ea98d25fe7ecf811a8dd9752da0a16712af8a28377999d21a490c12c6dbae24ebc3d16a3bcc555b6eb00334d1d525442795a9a7b6e1476e1139401ce9dfaa588602fb8a7a3a38bdfcaeebfbecab4fb8f752b89bdc5b52f68a1a030972f6d182da6050ac24aed60cf424b352faef760bfbfae9a1de64c95a50244870d4964e1b008b02ab9b3a38783f6b9e38a4e798f023d91cbbeabfcdb85e38e1bc02185abfa6541a292f08f442dc750371ef5976a8069139a0073b61b5c4b9015803727f228c8ed7152eca0c88a733f1dec6ca6f31a2742c4ace2b2e6fbaef0695e9cf8cfdc07e2be72763d3b5610c927a247e21bfa4dcfd7755318e3ba52df1d9ede01f824f8c4410ed42652ac184b951503fd6ede9819003b9c145271fde117a080789f01281a2419434cbff580819a8f4b39a141bd20227576132e53c6870d2fc8cce445758069b030cf00c94a3e1b10fbbe6a5ab0724e1cda9036271effc7e67a23542bfc31e79e1e57ed3729b593eacbfb19301d2af71bf5dadb8b66c44009077741e4510436968c5df93592a8f7eea33533b206e7c17039d8881c443f0508300e143f1e60a3cf4e31e715ee12a5aa2bb886ec6d7056c21598ebb7c0fda7ba0a20266742075c050c589a8b4438b9a02dc03c76cdb3ef939894cbdd136978bf15f2eeaf3e0241a8fae7461b52351238f3752c275bad314bfad362c43bdbdf7bff672b6ec5c12eddaa99596033cd4b773731ac5c36bab8fe4abef42863abafe9403ae75360ccd59cb5d4041f4a297c0b1f1a11d9cc99b130f4263926f0d6a9c54bfd5dee82c6cbf77127e30e4cbfde4ee13c029247ebccace45e1de358ba59c3a6f2352febeda25778655c4bcb945a29739065f9b76ee764b763058e77f05f1f00b9fbd4a6c65bcaf20ccd283439cff002f7c761c4a04896b3db0ce613eb12d5fedd5d30f83b60102e6d3352ca16e5d2e6155c8ca6018f54badd9480fde6b13527d6de296b656f49d8e0bd3c4833c86299f2abd703d8acd520098e459f5b997b9d241ddf81525072669cf9a91e73c2dcb9e850ee3a9362c3539045054743e3d7789557a7c1754ed90fbcd70fe03f45c6dab2b28d19eccbc1ccab33a61aba3fb761e5dd68952eb1f8e3606850aa00e241e9c71834903320a7c96b1dea7967d339273a82b80009f48df5ecf849d5b0f18d0667a7eed08410c0b1ac70bf1e2faa16a239ca7891473a50924e727d9fed8d29d16f5dbfa4f904654dab215832e6765a321b0a13829c9eaa9681886221c67cb0306bd954d3a5f0a5fb71cf6e489f6e544b95c27cd86cf33577a497f6043ee1b3415af0de50294af2f089819d6704d5456aa66d6352d5ee32337cf1c254b2a55e1f5bc6d4692c5113b5ace1fd0c4fb6d0d50bd02ed27aacfc39a317a624ad432e6f41e306cf0987381f8506ce874b13dcf3f60885d59b5452ed0c04284766e02893af57ea09c6c415fa99e0b3ae2bf7bd103144e5117d3183fc60f11e90702a6345a973fd801ec28f5e1368e67c674c57bdd387d94edc642627fec8adc1439eb1dde2dd1baac84f643939602e8829b3a5337927b957b734ad2a0fc978dc25fbfbb857fc6d80ebf0fe9b847306b65d810b45bfabc4d01f0e7cf529e5af8c7a82317ac02bf77767ce4b899dbac7912ad0d8209ebcc7acff2bfcf0d62ae40a909fd8f4cfd8b2f8a6de46b4012e4b1eab2a22447341030769fff68d9f8d1124d0717030c93c63dd8248ec3ef108bbeb819ee2f47ae96f819b79e4024195535397dbd03cdeca31db2ce9a3ea10dcaabe6fe6c2d132f0a465c42b04e05b5cac2f9ba54deb929f7c281bba6b3e785b6631b6f48b615291647416b52109cfb27143320bffb904ec2ebb0b4dd2fc130ad0330cac0ccff22f0e1e0afb58a425c1a440090c87f39a1f62b6c5216833321ca61bbc1154cc0ffedb6f77add90f980e05f59e9062ddf5d6bd8354a01ccd714a992459b55fca6000fc4631a811884a5d223583b02b7d7f5793da5565e5712b0bfb6fcfffd061cc3c55fe3432e5b80596c9f09d95ea0e8461e16b2e8a4d8926f4e4bfe5008b89250d0e75e6c6949e3a8d54d76c4f2bc438607f5a7f2364a3a75723497457a9c2a2233afe60b6777108a3677dd2ea54b1c8ff4d02af0e0f9c2f67c072bf52ae86319aee4da2bd35f65cd1727e67e092547bc337d92175f2a3bb6a16da1de724efa6c03b61b6d650e361b0492a6cb8b66ec06b7400457624c49ad355916074810a6be5dff0269c36bab3d669896fc90f7f229dada885e30eae5dcb55ed5163a2b8f89fab97b5e47e6d2a6215868c5407d1a2b5a2dab8305fb13e3c6a033645a118c562a9f5ba4d4aa7476c933cc71041adeed20050363cd11bf8c2793390b5b184e14062f71c1e61e208fab2f93a7bef441d06a81f864e637386514a26c9a409a69d91a07d809939a23d7ba3f7af151539c3b2295dda4da1f176f7560b3ff3fcab2d3e13240e10f6fd4e291223881c660ad928240f5cd796f4dbe90e1ee2f2e3c3e1541b0040efa7ffafefea2c8ffcb05d6904736050de87e013f6f871cdf69c2e0923ee448eb31c2f8d121e1d931b230703dfb568708f44e021ce788bf23b797eb7cf9c821883a3c99ed2a0204af93bf79e2020dfc716943619659a691a8838c847bc24c3c759464e45164070f868a014432f027359a3336bfacae7eedf6548193deb7e86ca5337417dc1571fede6cf88177f05531751c993f5c95e2f4e78028ea60a6f9f77a6a320147e82a1e6852316761e25e52cfb8e22aa1295f85151c69508fbee740cbce760216c5e8e87b6b70338b5cb2bf079dbda500f217b7178c6900db2f1bc8806f3a501286a9ff65f958d5c7b8ed462e21dcf41cce0261059b87c180d2d4155e3544417d29d55312b18363f3e036e65989b4aa2c29e7d9681939a9d71a2557a264c6a4b5c688f5c60e17119a85139ff8e5d8766e9de76e3cb9ef491ba787c057db3cd400c7f09f4d8460bef8165250461c7cf63a53d8ed72493dd6daeb606d83073e88dbf0c51452154d77172d7c5a61040c2e5acb9529bd49e1be56a3fa10f5ce9808bb8d6d5526a74130d371163ec53ae4d3902e0bf73f47109ebc9df44fa8567929d9dbc8b9a465350c1b5187517bdeb5b4ac007317579d457a6b035c20d67c2f9b7fb7523fc71670fd6c6bf133d3f76d017d22ba883f58641d99baaa0b0fd3d98b1ef37305dc873e19b4f3d51cec1652af72d50fa352e654eb121b118da8fda82df63500a3b43588113836a27ec71f1bd4f510e16e35771caf48be6a8c36ff1598dc878faa66917c90a1ac06922abc1485b650bafbef3ea6e8e35b3c5649f390783e4e5d3393cf41fc94f9d1c6ce6b9085839c524f364ebee9ba39f14f4f1af0bf8b6037cd9657e428fcb4cbec4f9142f9e9df6fd5f714c66d1909e85ad931656048a92cda6fd73d8e94a08b2a5771536d5a36ea9d21cd683169c4dc835a8cb9d16ca3a351fd9fd2ac87d5a8f702c47b03eef1a019c95f5df637c38721da5a2405f7d2e6e89a2ffaed7bf406103196fe1f35d3367ff2c2dd36ad82134445da167ea451c18d9057c701971fd1c73b8cc65a1f1a76769a4c9f00b54a016962ee4832de36b100d0330b3aee5d6d000297b6e2e73368c48412437866c3d40a75da9e25530a1d641034acca8db4ab79543a5dc3e6c494a7083ce8c46c91097760831a24810f4f9fef3634483937723240632defeee56b328e260c6c9e802afa519dd572422ecea82b351b71e6f5ab25ac7bd074a66df96472b2fd6eba2b8c39e637a7e60ef47ab645021d351dcab61b334ddf92b98f595a480cf6f5ccb1fae9c68c6d9f490b155a37644ec778e846db22af02806459c0cf6d8e353f124df6a16190eb95d3f3e8909579d40a3525cb6318772abc7e4f02334c496f45ca315f2772130339f2c0594c1e72ebfccd49f099954561c5b84e14f7174fd447d7562e0a48af5100b8662b7593ccc12424d98961a0589b86372e3bdba54667789d8657412f495d074c0e220d8b49eed54d8bb0fa7580841860950b37ed70453d7d49199736c9c972bedf1e184d4f45386eb2bb9823f184af26a3e5966d20de1e1855635f64f67c7c6e1f49e603c8da2fceb06b71ce255210fc17b945ef77937d028536719dc1bec514e2aca290ea6f3846a37045bc830b2cebcd2820897bb47cece611a03e101483d04340a3f89b0e5134787667b78ecbcc08366390c38c391c6be72a1d6caa637466f91588c8fd8768fa8998267fc933d71ef4937c24be7d8f08d56d0cecfd82eaeef3fdf624ef7e7e68bd6761dd7389bfd45bbce7f643f8e26a99dfe62724869b2082f691da837d482d6d30c0460e6503d28f97774d7c038e2e1068dc44fedcaf7e0e29a6eb9f6ad5dd24f2d60cc2ee2b87884c3da82dbe8f8518d5d69ca64d836524b12a692e3436a2b2f2ead2a5e12212c1829e0d7c68dbecc1d2f22517317ad675fecbb41bcac776f8948e41992ef2439cc29a6eee95f8027472affe73b3fa281c70a3519305ee36bf9c3b9f10652381d52563dc3ef554b65f343edebb3f8e166524933708383c9ea76c679277fbc0efba9e3e85667c72594d872ff6f5faf1845f0cbc0fd40dd8415f09e1eb547aae73ce710579ec7ffa38a78376d2c79c58c437155481a3114f1b8936d208900bdad0a24f7707829dd568e53577a1d952a0815226a2ebfa0ffc49181fd3ff929f395a9a2a9ad6a6c1866fc1fbece5c697e295858c0a55e33672e1a207e8447fc835e1f80da054744c25b16a4fbc18be57348d5a60446f61a4d111504dad0c7eafa4fd6a9ece2ec14a877df6fbcc9201cac7669d84a22f34b8fab0b231e2cca5efa1ff4200e9ce010afd796a45af8d1c8be7f008398ffae95a178820d09133fecb2b782b99120308131024c88812c3a1efc40fe0de9082d919ac42574a95e6b26e06e1d9f6bf420ff761fdb0906f082354edbbf9f143710db01e306f5f11d7dc18cf9fb25660d71f8bd8579aedfc3d2a79aad0ec1a865c90f6fb1f11237cc4b450e20553d9a77db30e666a752c7eefe8339a42bc520b2a74ee66777a61eded6b887095ce8202dee02c7aaeec40355501e420e33c1065fe3cb8e750d145fd446787e92ded08fa36a667127699e8d712eb84039673eec085bdcc406ee0d0015896c24a7e03167af45e89f98ae381b3219cb47dd9fce8ee5c6f293db1b64bf44ce292d9c14efeb738ab1dc4fe6da9238c1825d2b1b4c423bfed0ad93c3a15f669769e2774499da08fa04a0bc7bfa484b0b88066b805f88646fde0c16075681f1ec8eebfd960db03b41d757ddda0442c37ef6d19b1ac5b0912d649b3910b753b4ea4796c5f5456293f85ce86f0528f41dd48b9b7a9fe7f7d27644cb69dea25841d5e88da93e2e7431000ba7e08f5f6d24abb9a1897cebffa1a814e6a131253fddb167c2d30fe534764a80b3a1f0a6328553ac69e26744f974a13fcfe159490813de8e354d7f997fda4d11d95b5851e394a1f6264069f313e36626b9ec2902f01f00232a2a1f88ed10e891a1f552c6cdab996aef29353e317a7f7bd5408dd05e25e4108555551127f51d0ba5ad0920c8717671c57d87b75aaf275d475fd33a59c6b289af12bb3d011435649b83774b0c20fbecfe9a181e8ae904ddfcbc3f06ea171178b183ebd646b1d2a976025de1e53251f89512631575fa26ad6b1198c6cffe175c2b9ba3dcd041b2b9be38f00b36673b487ac33da763d047d7af7bd0e4cc7c35a1e2a1161a72491cff8c87792470a2ff1c965e63c8bcd28ac3b4990ce3e9189fc021db6f1db61301dbfbf471f67761cf1cce480a5ece9579912a3be5770265670fa4ac8eb7b1206cfd1fe25d4bb64364bc81836bc271dc1f50572c535fd6423e2eadbad8043f4a76c6c41b9eb5af953e31db0f01ec47f81223396b71347ec4c27cb939163dcf59a6be4893d7e44846326650026f9870544d643f018fff7cab4e9dba1435d943d92df5feadfbddd6326bcd434830dcdb48ccba629ac1ff29984e595aae7e1dab58a109fa8260ea0dc336244b19032ec8750721ab21482767feec38a0625ae6f9c1f81ffd2c35aa07ee1da20690b0f480e6393242c3b1ea2c1f29b904dbf367c6c6d1a2ba4f12153f8fee34a1bc8fdf28bbe3fb7984f672e72395a0d5b9c03c6ed46a039f7381ceb38884ebd0cbcded38957338313de3bc40b33f35b943b29a79e839f7ac0b73b41b509af341c9bad55434e8f14f65d1a1fafa6da0d7da97b78a091344cdb53730d5333e177810e9d20553e17a064df20ff8a9dd3cc81815bb7f75391ee258ad856d12aa54e0058256540d3b3b6a247d5e69103cfbee6e7c34ad2230611e07b9440630fc8373173637b0f8687e8badfc5e71a94f9a3e7220b8aa37bb46a83169f160737674ca4b1884e32737c0517a240bf096fc14266b0730e7b70fe44ebd45bc01189fd477381dbb53f239a5317379aa10f112fc4fed9ed3fab0d09ad0e08475c13b2501b6a2f2683b5e7208206070ed58251676573c1b8c45437ba96baf2d25434587745841150ccd789ba7918ce013b39fb7f1c9bbc48f0a02aa81b115f399703f391617a28ea871f358c1df38d1b504058dd873bcdc59178609120e338ce8e19131bc0dcf7b2bee0448cbb390e39240aa9fb75448888b31ad104b07aba3fc3482912143c1475af20e490423312c933c1c424e14d53a51ec984fa618b61350e863b340f038ea49f151a7ec2d8122f47f3145c4dd4297d4fb68c90a7b9ca3d90c70a2310b9d3a570358306803115eb85c33c6720f337ce04778703952ee52ea368598be0a7db68dff215c6895aff6b7a4f7e631ae28521a9ff6e4bbaa29a61ab8f8cbc8e6a7f26cf65015517f1565a593d1dd8329079892dee802e80b18a3a87987543924e8f1d01547e62a848f0cb6c4d94b8340f81ace29e81361e6ddb18f35bfb8b923a8a8199dd2fca9c43085bfc18907b4e4c40a685893aed1f4722d5bd4cd879cbd2d33d23c1e721a6a0c30c29b720311a0c6aa8cadba96604971eeae11ae4a39ce89226a20d8056e83c9037aa53b3ed273e25757727dc727b67a209ada7aaf2bdb7a302405593a4781baf43091813b9d9db7e34b6d51f5c7c388f0e86afbdb734994d286f855e00bc8d1c7f2b8c2d227e7387caccaab2429cca9e8595d8b907574783475085887687d0a7fc9a825bc3fa9ab694d806279270dc5d48b3f737cc05070f33293a4ddb31e90840b0aa1e0d3819829416531954f90cc77c20b57ce70e00d6db07ae2ca52386cfc5d2f685711379f39e4cc56f273d833ebe5ed821dff5b3f54e81eabba256ed293013932d715d8737503b5452d532d09930604558820207c8cb2517391b49e3a1f0611050df0391183287ea3fb06f3f07b932aef5259da2843ba99ad9eb0726120a93079da4f431121126cf5a8e7a575ad4ced612e9f0af355ca296987ff412ec3c8bd6a7d25c40b28752bb04e278dd7cbedb0c487e5f41c854f3bfae1dca621193788557085f2b56291980ab094653102bbf26379e8a641ae16587a68d763e651b0e94c8019c44c506d07fb460f0665e4e746b1852ce7ded8c52bc3f44d8657a796203334c430a29bdbe1f52c81872b3d493a66f4a2f7558157ae27331564eb802120109827c4fab0c6f56728865d9d0b3ddaca092215ecf6f058f4b9f6683f29ed0f2a69296bb5ceadb6b1ab3ae2a3a1aa42f4cec6d092233cd227454f6f120900d7e951f868206d09487b02080141d18342c5d7ea004974b037aa86eac1650fd8cbc57a66dc4f512adf8b98d32d34fbd59027904efdc0665afdd5d1a21588646c69c84e972b7b03d1350653830bdb8c0cb40160081a44febefd2913a39309245aaa62f56ed95cc6c6aca9b46208e09f56c5a3a9cde8e677fb3cf749fc85f1da12746c96b62cba136636cca4ef4b83fa3f8d529973dbcd4c275f279f79db54c0b48dfc5ba29e66061bfd5b8e2bb9ab00d4ec048e398855e65dec6b6d480d0a952bf91f6c096f8ba151ff25b56c91e1ba8690d52842972f9e202998c95449ea5aa2d776032819b3e549c75e4e88a82797bd85f3514fcc6b8d0bbd3f82c00a798f2ee63ff65a71486013232ac07518477d3d2b74b927d3486f983f9d51096747853efcfe6d1929148b0233f01fffc357d24a3cf76bab6e16793b4a25e6b0ae9f744ea4eefde2d413c6e84228f15903b909270d0f7a431135596fad16ac901e454e789a48dced98a30cbef77e19e44024a2f852ecacad177ff951ed49f5b0e987143b823d455104809571c9c1e1da9cdb74cb3b8c2a82437fad653cda5c06cc13b7fd8d30bdaa6716bc6181790931087f18743151b09829ae56c5617031d600a600a030e79a53ef7e3b54ba97896b6d930423126f4be55b5169460920c7c494cb79dfbe6512053ca7d0607fff2c1e93f334b2300aae216647a95c340da61769381c876244bb209cac000fd59779047c5efd8b102db201304e5d942c43a42c2517343ae537eec81cd46693e0028f7f7d438e741fee5c0266f79a8dd4bf0879b7e5d3dc4c46646a557febb98b0fbf591508c03221c7522889b52f28a09b3a3184f4478211b1a7e092db79ff4df34050169784e992201a18bd2b82d96f382d6c7f79d2c76f66a6a35a93d57f95ce9c867512bab4bb3d39d97963caa3f38ce82c772ecc68ed868915068bf2f6ef560a62b57c708f7ef394a89f65052caa4470c78bb82102130227af0774b158641b9a4f4639ecf2c5d83327b32843204fedbadf7ab683cfb08a9a935a21d7912916c84844136e6c0c6ee18224c572f4786fdaa03d0b6ca73ce7da8bed42756aac3c3d1c239d25690b59807db7a5aab232fc895e5658a3df8d02ffeaeb131bb9e521aed827751b5cba9924e99da5b5f835b172aac13073130d5229d0e5a7fad38b9c3e9f5114a8398c335e9db7538d165e072f3e87f73e2a328fe64e53bd95b44e71bb3adbfc3f2ee4aa763519319b7e45bc8d8932148b2ccc8a849291b7a2e3447e2329b8aa4b397eb7eead8e0409fd0113a2f795a599e01eb19a2554a9a83ae9c43c94f9ee9e2955f60f224fdcf81d0d761d89ddd29d80645048768812b168b4ef6afff6786dd3ecb28575d6de2368a938a0f6c39e42ead0789f6f5a995dd9eedb6bb4dc1fe28ffe4d7b28458387bfc9a499cf572cf18fdd7dae06643b76f518d28b1ec1478e88b4a670cf4d1bce4f28d45385edcb809c38160e3334549298b549fee4fe7d5956e82837303ea019451fd036e05ee94f296de005bb0e9195a756fcd2d192d0c0f7cd712071ec88e83e3c619ab8f65aa61829eefa24bbd7508fcf0a01b434b50c2a61f81fae0dc42db71ba603a2a83aa4bbbb52578deb0046d15d08b43da64e50a74e0aeb8e0dff2d689c89b51a644ec5fd107a8b15b952dccdec87d569fcb6e9f2199060b9e9570a8c2e59b7c51cee29dbf2937278ab3ef983579d8f895b6c98393523c4b3300631afa3ec41ff45ca2ea6102ded933d39ce9baf523454ccc205b6c20ba1110da550260836bf476ce1dea037e0bc1cee57fb57946d2ec084d02e85caf0fb920b826b80b76f173d0d439596bd73256e669dc6ffa0ef4fa2a1eed9940fc13d064019d954fcc450169662160966a7deec34c0663f1bf564643327077ab2bd0813a5a6ffb3fd560b82a2fa03c678be23668e740328f661a9176c5b2f261dcaa33fbe52979b4cae8fe298199bd7e0765f54f4ae34801120a68b3c10bbba74daf03057023da62215d83825218ed791803eec4a5db315b61216c7f0de035f004f2a817077640ffa38829afc383212d2925b7c8c9265ca5464bf2ddb78b66ddf77ed27e66593dc8745c849260dc9e139de03539ec8ee80f1e401e477a67934f0aba572025348b62f27d57e413312f89998d0e6c10ccb3cb64ed00a62f1d2858ef4842aca8004b6ad1a6f6aa632b331f692d763a959132f98a544f57eca148bbcaf109f63d98b9feea2d2238128c2b308931ac1926d97b180531abfebc6ecf4ac7a7c067b4fbd9d398a63bb4f1f1b9273bfbe283ec2d7ec9968fcbc2cf86a2555ab043bb4a8833692a3b90feea66bc25ce8404e30d361f4465c56f8c68b463709ea9da24e83bd2b84adea4147c20a6fd6ea31cefa3ff92935016c015c34551567064fa32fc9f04beed5b01a3d9f1c4deb58a5372572fbd606651ef1330ebc7a31ed3e35eec551cab12944dc8c128e27f847bc2afc5f700c77688abd2cad222a45035266d438bd7492460aaf0bc7aa910c989024f72329747564a8e4c91947c1e5cb710a88004d906336ae135b2cc3871bdb664fcde3416916cef056adcbc1743daa3e87330695b427c4295ae4543ee2093e1d81e240ebebcb1a4d1847ee7a6cbaa998fff91cd3413151067063cd821a6d30fbd4f14ddf612b1e7acb22c30c30426e0f7787562ccb2fdc4248bc752d17531979f49482aaee04afc6b7628fe81207ccec81592be75353f6a9c15fff92a9a3032a2021d1b493419cbac2354172dd5af6a15fc22e7ec021dac7ef51aec1b8063ed2283ef05fdc16cb3a4ce1f1553c90009232cbe34d4bd5c332fad12d4c30e35a5482bb01a85767bc676fc02a3c075d9a79773be208a4d2e5abc3041ea7cd78284dcb5e3ee6e0545702f035a98d6bdb45cc80da8817824c179c1a84d0385a36231a21972762d83601627fe412e7244774da1e87c8abb1692e082acc23da8a3be9c4b7c2fa52dc3888a8cb49103b78cefdf07f326836c3dee30f88dc2f7f30961e89a3d32c2174a9897f610368f7ae6fe4f2af4f516b65d1351297f7d5065569676ff5f54fef2d091111691dcb97c2ec63d30023681e1ba389ef5c25ca5787c50845458cbdefda4ea58c46d0ae9824165facd12a541cea14c4d0956acb8016f7fd299dfcd0488d37b1b627832630bdaaf49a0688e185e103e189b153006870b8f344a12491c848c6260d7555dcaa6d84a5c0b06815ec4b61f1979bc78ea37d991ef29063fd45ef25fad5900148c0605d330b0928e8124315b8c97e8932cfb8d59b63234fac986cf1a100a018099aba26ade434ea6295d47b0b5fa7a4ab80f5c8824736ba5cbc21547a81bae80c594a3725b2dc90e433e93456fc417ab3660c93bde46f9373c0c6f22bf76fab035e586db000c468e57d84d766a160f00ed3deff4dd8eef4501953758562da8451cd8da36e5bcd86bcdec1816a1e3bdc097a9cbab4b9b08503c5fa7a7915059eec972d85e7cdb0532956707ed63f607579b80177c3e482313e3c80cde2c07433ee710082ca93ae62ca83f7a52d47099c281314e410f77e4ed73eb63f92952dd07a2de9009ccd375c28c57583f824dea3315d79e060b02bcf52d53af626c7a8445f4752b7414598ea28d95d175fa0a8e1ac5724152d73d112ff0ae4e9912e2b44bfebc03d73346c8ead3931dc6f51c9a06cbf6ec1abeed1fc259be219df0633881633c6fccaaada532614ba95ab4517a5c8bd9b0064c3255547d74a06526faa90af0edde9c239f05d8535a6c0109a7506385b152ac4d0e12e6c0e88a2992cad31bef6fa1058fb62a92cb0a3c2762e806d7ab89445cede65456f015e1c99696cf446f7e0e6c7c1b0f8575dbdbea591ac2f6c0ab7e9b5f9945d44696cc5ab7c81386d865b6350fa7711c6e03d23dfb29017eb9a0b78fc7a39eabcf60fd1aa145c287a5e796cc4a85f97ce715858fb5b55c558a0f91cf386246312b524b54715ef0457c1e6a11e54663a338bc99ed960679c29e20cf15dbe1eae0a92643a273e48b3137335f0d5a90a007c13586bdf9a2759266674d93fad8590f2a1c78d055154d429ecd9b343eb74d296a9686cf5abd01c162571a9274fd5e231986d2efba00e7a9f694a651ffa595956ae3b5191403997368eb4c63a4351f6d581b4bce5bf32c80819cb324713b65b490ac06d244b61d37e6ea8d57bcf0881ecbd015e207845a6d8466f07b4f28a6492b456c777a025b696d5f8d20e8ffe1255195ecdbeb45a5e20e806b5e4f1a6461ede89c5baf1a68149995730cd0e76d76af78c3eda302ae96cd6d769b5f5def58290cf7c0bcc7a744520869b2a5810e5f51b4a304fc346286373f99b24a040076eb9b0627fa8044cdf7fe90566f85072a4f1695449e51176eab85dea64e8099070b2c2f03e16ee9f3853c7bac0622afa2bf6a2c814d977c42ed719ba6ef33f26a687308df21447a8f7fb06c84f984cc26da4cc10b5cae541c84161d06e40ca0cb2e75efe80ae39604743d1575d9965ffe3a7d72718ceeb6a34e3ad1f2f118d97e20dc5fbf175526d64a809203dc39df8fa2ac74090615c48a63563280ceef3bfe665fe0e5452ecea65bd7b5d3a75f608edee0b80fc89f52b8b38ea57c3fcb4d9570cf130b01350ba70d44eee4f927571d244701690c06a460d70f150ee969bdfef94de445c9f07e7a1a1e2d071f9cfc9057e3eacaa7b867ecd51d074156e026de9577268ca47d6b9488f4692c04d35fbd8a19cbeaf25d9bff10f4989cef634a6895d060d2d12e6f9d8050cfc2daf4acb5ade1094823883c36ef4d29ed32534087ac66ff40ea3362d9fec34824ae83bef757c50fa3414b150de11b0522135da4a04e25b28061f7f6e9c969a15299779af461e178a32c7cdfcd7e121d7aeb7ccef22751acaed33819f8d4e21dd8ca0ca200ce9e5af8d20c6d35cca0ab1adb99b3af9703e64e7c7bb1f70c592d71ee1eb27b7274f8c218e268a40068139bc71a2b8e8a5e9bc26e56e23b603aa58f90106a0e7f97e118802f54e8c3425f89a30de77c87aad1b6afc234f65e7caa5ba6717ac83d45dd6492174494faeda0280a998904d75e0ee80f7b69a521f99b13be3821db16da6245bdf2fb03746cd5cf235348246e0c3dd8f2c43f055e2e80cd710ca3214dcd07becf25397ac49092d22c86fa510bd1acd5f18917b98b2cead50e3deb4f582a0bef35a8556e21a7e6cc9081dfd38eff8119b4842e137fc1e65a58e97f9d92b106b968beca83ddf7c28c1e55d447b686e536811505baa6951f3e9eb048e897217e0e91e6ca91dd9b3df472895515ec74cca92e3c1c35648b971d3504c514515f3746d7784bc1db912cf3eac9b5f6e85eb1d57299a1278c10548ad1d1dd751f2afd7422ad7fd12e52657e421307a768a8f26c4b76244a8c1fcd5125c85334dca59c7655276146a9124a261070f6e067e0ca42de075fd2030399975b1f94e4cf18ab76eb03597f0c734f126f1061ea312287c1ee3387166791554ea9be4adc9a3d1f3ef2625e563b8f7facd4c61ee983626927b445e83f098acd42f897ef9a3ac34d5c44870c4cf079820988323334df289cba570b0e1070f3302f61bc5f2a7c983f74dca95d9d06df67639648f0f6de6dde6b2d7ce41e39c373a4595c5629e0ee5720876a811d57a1b91b06b3442c772f9eb416f15f8c2c01233c81b71344c0715d033ee7e20d3706a4a93584136fe135eba7be85be86cb0166ad20cc398b12eccc85321770f1ec4db96f40cdebdc1eed61d1aedc8279864d4f787b3e37e94e610b14818ad23ddb461efc9dd43d32ee59f701b3643dba9c6fb68a441cea0259d3431e7e755e72bafd28a6ed987ef6399890bebfd0c82f541f626b22a47180ae5e3c551802b39959238dbfec3c44893f992d61dd148a0249505a49dc1d6280414f801135aa985fe5525690fd1e941d43a98edcff111b3f860ab9bdd979a0d1971a3be8bb289eb72ad6a37f40ba05e292baf00b7c1026f2f7436ce76e915bb2028c59c597d758ceeff5a0d8f408cd056acf8f23b01e041509024f599bfddaae6c493288dc49983d8aa1ee97671f2362662a9f6a1d10dc577f5e34f44c36ec85d45e50a6dafc0294e8c2fd785da895dca29683e1e103a355e27f6ae6436182ae0544c7a2116772292913d633fd152955f305748450d346729c62a4863958ba54f99c228510f1254759c185448ca9cd119d8346920a3bab7aef5d86ebc845daa210af3caeb44d43a7524e061c5bf300189c78f81581a1399c9f58ddf178ec0053c0fabc648d82b59d77e136a6e469d93951e98bdbdf4855ec110f50c26e1127fdcb7d182e8016caecc3624b116c4f1f1140517eaee86d17b1e42c0bb14a4b746b8c40038e5562597825f83cc1555f6d76462969c88f7c4c268f325d9a5e807d87208119847ac3b28162441a445e807f21853ddb4de5a057e98227099bb7164aec7319d8522f096a47c257a6481ff9a11be5e5891e9971c40b52757ab349433a7edcfafeb9f96b6c79be846b6cb62206781095518535fb5f2c6d092e6e677ae74cf29cb608c80275e2d32133ba05ebce3eab00aa73a5f4d48b28b71856ef1f7b6035acabf3b76e06ce6a873df5eaaa8cad2d28a77fd64354b2530fb426888265c0b4c98de51dd4781b4bccb675e5c6efadca871ba25bb45267c2fc306847fb97223823bca2a22c22da7e7a05e4e40dcc14fe08d7bcdb2402109e466a4f60d053f96b236733f1c70f44f96ac4d04bf685419cc8ec8deee51c91aec63cdcabf816329ec276b059e56e309c257db601d73c847f1445db449f38448b95253cabe4f6154774cd2684eeee17ef1dffb9fd7310cb48c2e615b9f4a1ae70518225fb59964e635cbd7bb2819bf313d669032f0ec4feaf2a4e328385dd3eeebba949ac91215fe68128432aeb4c460b1bb26431e4056b2c7547ed7d0db0df7de6138220b6575951ab426b512e71df672032f4265e3165c209640225d70abebd3692715bf561c8130559d083191988db825bac03bfaff4a1bc47d3e5da04771826d8b4745145db230e59a12cc814dda357494f4db9a2c590c37680c0cc2dbec2ced78a64eb352e9e661b6ba6140bb0fb5b6fa4fe6a33115f54acb27c693178515065b60d85b8509fc84d0531415ca5af3fe3bf05479082a73d3d136b6b9e37f12d702159f12b54f35a524dd1a8f74c3ccd564bf39dd913897624f066a585ed53a1130a82b1530288381fe83aca7212b5d7ebfce14c671087b9772d7380b773063303a8d938ed7500523d5545ac7ee35b84936b93fa3466bc0942b6df8267a9efdd3687548f6df215e718a2248ccac6052d6c6c92f367cde388c8fcdd4153397381c5a8479dc57f9edc7c9ff53eeb83cee0af95c652a7f4b7ffed7413147ed965c3017d032135b4e44ab0c6c04b5bd7810074f1a07eb9ad4ad638ab2b4f30edc51089bc8eb3996c27fc5831674d1835512ef94d53b49e06017209b8bc0da1aa15df920aa1e6e963b224db800133b5b5fe42e8fc2c9018c03cc9808f3a3765385265c8dfd89f2a91995796b90434485ff8b012f3bda105ad6e243bb6ae19f032ad21374ff2583d21b6db8edbfe295a7cfdd61499223fe923772218bc14d13fb835e300262fe4f187667c3d82eb932556935c9f329d0e0b019d5f9a38811395076258192e98113c51605737b1c55246715a52f0a4a9b0aafdb80c8ba434bba8eadda489db0206fbf4b1b92bfeea6115cb3cae4527ac0fa58e786e3a451bdb2751f40751a9a27b1ed92ab131847055c0fb553d0415bfbd3b87da44ea7e46426c68b6b162ea251ce7622d2e971b12c8210eefab1ded3ad4469bcd49e18846a42065a3ba8c1f4e11d3066f25cd28083d347c6d0f221868979867ff14d2a7e14065587659e5659756cc14d9e74c9dab0711bef102fba72862c41a09e58eddb830908884770827ecde59ad30256248170e6968d8bf9bb82d2583ce1fd628131585b58b2623a67e49e942d90aa87c90aa0e8867d322423b4a4fa36d504c32b627dd0ef5b0770ff6c2eaad766849b018e3e7c135641a59541062fbd2ad1fd97ee8438dae7b8ee9c8542cd803ce2e2e6dd979afe03f74d7e5e5d6674237bce015705762ba3df0","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
