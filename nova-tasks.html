<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8babbe540b77635fc8ebecc4ac6206d7479e511c0d1c3a618cd0b3a06f07960139b2885bc0bf5532f208ca97e0503bff146614179b18f7b8012e54679f5a4aaae52ce6f559950b782ded61b380b12ca3e9b885e28c794bf74e152ec22f22e013ffe8a6c3b11a76ec27a4f89701c02e09542ef88f6640add868d6c3745b3795282c623515d1434a2060253297d6f0bfaf720a48bbd7595867eb728efa0c569bb5732c4b578195838ab2bad3a7608dd223bf84aa025fff28828d939bb399fa611bf6d234a75bf123107e8b4bd1787def2c826c86ab5e952b34b22c16bd348062e42372fb68dae66e2227843b038cf069ae379b93c70730607eb206d61e77ef3948c4c3eab1dfb5250412faa0f26a478d78a2d0085e5895562830baabc71d16605faa7b521944e920b3792b112bd0a49bcbd52f6b749087a0f01dd4203ca07010876551b5d47f4553168e6693c540f38bb2e1ae1bfcc41ce6f66ada297149bb3b1f99b17e8487da75e49cdecaa1668de749cabed3560857267219e8383c2f805074d05315ea3f96a99ca9f10baf0b09ac7075e304cda839677f2f624dfcfd6ff1238a592d070b9ff005cc202db30e5c225c3116457cc27b32f155e5a080d0ef356d66a456c90db16dccf73c09b706360a34c89ca1fd36d81a52f155e018fab975a4de6a24c8e0afc35e7d91c98af952185a630ece1cc42a93b814271c48e7710fd677695c8b179dc0f7ef514726e677ce0da8e02ff13aa5deaabe1ad5e54840381604d8d25cafd4cee6706fe1a531a7b00e9fa62a4e890ba888abec9ecafed9d2ef75be17eb4f73d0283d010eea76b26a9561027af076121d566a8ecd5c18c8e76fae0ea5c6ce7dd5db2a6e3e455d1a8b20de5dbafe7b54c1690e86fafd7401704cc55fc951b84c58429ea95dfe828fd1189098ad29cd7f70480d6c2b2e93fa01bb2b90886416d0caf8d35dac2215e76bf385637b5f14a37a0509f315d1cff6ab720d5211bf1801749469260323c481d3c14a35421cc3772f57ba1e096682c323cedb6243788ca825659942df037e7019bc11f5c63d23c85ffe585aa2ca4db1886c1d803744b042dc3625aca27c8befaa09255df33bcc98c5bb21e2d1a5316b78e93625398bef13c4c0e80c6def07a6699ebd3a44ffd79221957656dbd7da85fab4a2a49f4318c6a2d7d96e05d2556403be5ac9e45b4ebfeafa73a15e21a4f4a08e27b57ea9fa1ee60a35354a2b09874becd58f04e0d92392828fc0aa72f0e44c67a8cd9211b9a124b998dc68ed7bf3410e1c6c7fe909019999abd09d07ce3f7d9e97fe6189292111bbbf73f439f21198c1516e4703e29e5063798d0ab3538d9d0e9fba0a76f732e31d106e38c3d65a379260063ba061d4eb1bfb415364f462ec0c1be68b2c6cbb2f4137130c7d9d3dc18f58257d415373ce4151785069ff3dbebaae6ec45fe6e0e140984c472ca853a21796154afea25dc2ddd2c39470112d8c509c29a0c1f758978f8641e2a5f538f650949671822808fd43580a637b58983afd42c9ff806b0b739ec5ccb65b12f926b4a075be29a5b6a650af25418c93df4c782b9cafb3fd4310080baa8bce61b82cbef82513dfaa2a12b6cc48948cc32185899bd800ec5a638784e9adf56051120d04e36c8970e656719a76e3c855247bd275a86937d20d2459d1b4e6f11b4184138288fdd08f9291791e6ada0f5b86112ab425ea4844aabed9b6e6485ae9d68ca15b46265bd26b66c4924deca5a77f5fef04018961ab149178929868fabab280306177f29aad7066ff21111f3e2cb066c69f03e5058e17fbe67d82faa5a46c557000f5e08199c8e5e0f63853bd23bccdbf0a8f89512ddf467993e6b28afd863234c6fc4e394ea338d4329a4fae5c453e6123b519dcc594ec3987963dfe005518286fd9496fcfaa22d2de626646284420588f03beb82d78a32d89007595072c26760176d01432550219feec34031d949bf0bac540680cc7a8d70cb9c75be75d6e7af7f980862a3fde7115043fc5107701ab54d635c25440511d1dbb8c0bc33a461242544b6268456f00c4121b1f55bf5447efc7888b07be84ab5fdb1ecc3b205afcd62c8b9ae223e3e62ab395cbbc1c044be963436f6eb74fc599b5a40a80e5f725c0d4bc01290ff97e7cfc016ad6b9de4362fb5ab61632c99d4fce4caccfd2eddfbc0f3486db1c2ea04fec7210d114b593bfbadb2486eaeea0b9c408e7e3743600b0e2db20323bedb61b9dac1e9d0711886fdd993018de03f8935c3ca41c574d93fc0b4d14997e1ad1ca41e9ee962827ecd06886be372fccd8f4ce7c8b7ed37a8382baf09c27e4f4b2db5157846e2447abfb89f4041ffc589de6f7b4704e151867fb92f5ef79a65e980af4732850ca482e8abc1edc4ecfe65579f098ea4db1f990a45f665c78f2a27d53e21c1b3785842c87a753b45bbc894288b8109fdf55711addfdd7755803d4b0567598ecf234885ac67424063eba386d849e1a4fc149e95324c4025755a7075d485421b8531227a848c2747693bcc932ab1cdbacc232503408c493c75b9764ddccb945dbfae5c6552688173cb1c1f0d3a2ce5d748458f69a91645ff95cf422ff95149b3a88689c71789f2cf21c5148ce2437374e519326c5f1b25087382f47f5b7d5f87bc3a10fd31f43045e9d48c593a7c27bfeb98511ae207dea5f7a9e6a0491844b8df6ab2b4b6f55d88fc57e7b91f90e163904105145f0233a92b1c82983ae4e62f724c17b179618e6894ab48c486bbba4b3e71fe449294a8884caad1cb5830febf17f9d0024506776a61a4904476aee3053f0c483a06bf3c8aec4e6f3685d97bdcf33b656009a41652f15885e9fafa1184630e37281eaeb2c87a44e4633909eb995895c5eadfc47a87454598eb0ffeea46b135365311ce522d33abe2e476ba1ae9c4c5baf9991736f39551657745aa164bdd28701e182410f09992f290b4ee5168b379586e5be34abc9c0899bb45ae72516853936d24f9907e5befb0f04f6e22375dcf0fac2d37c4b544679dd47db5f38bf997cfec0e49d28218f1a8dfe79a653ae6eb50a0c93137819e5485ce189a07f38562738a48c1b25c54c022dc36cc35633b9d7ce874c78be57b983893035aafd6201a53c45a1cc31da455850f742adb5eeebd8b78937c15ba2eb2224170abad21f2e0029b6be36bf918e402228d6e880ed8f8a0c1b3fe74e1da8162ae048f2f3d1e19b5f96a796ee205fbda84ca256cc21225d5b18376857284e266f810cf71e0d6c0053b2585052c5953198d112c67376f4877fa69554644a4103cb02da4576cbb1ce28925dc1446060122863ef4205d9b550b4d67033538e20ad7a43aa73095ca602b2b5eb571c69dcb6bb8daca4770aa37f1fbf4abc2b9d896620714c59eacfe94666e133eef0053438903eb244be367c961451cbfe3d271ae024d68669e160f86fb77d10fe6b3bd5e9e69b1e2acb4d0765d31dc08ffe453f9ed0e9aa2dcb9295e255f69f4842c2165366ac9dfd294acdbf3889e90641b032a59d8bf53c202990803e81e520a5d5afc37757d35931a6b4a63b9174c232b1a64f1ad9415f6415f071051d46c524d165d8f0841f77a932d3a03e884f01577cde842ea9c8e78cbe61758a23592eab94bf135b8aff752ce49390bcdd0e3df0458025217b4098c1a2dde9ef72f0be26621576a5ba890a14a21cf1bb66e6b4aa047ea92f8fee2c0997431c9912c238bbc48a0c5282fd76ef02756938e33140dc8d0db3f1f7df9cf2b63711b296e96be1fb87c49857079d720dd82cfdf6a43cee7a8335e994b369b1624cebe733e086329afe4f3e2e2aa10c0e0cc31bd4373ee711ba8d887fa9d8f1a0cc9e126d8f2b4fedc31b24fddab64e1c9ef6c8d0fa89a63e81e0e164c9c41e84334942592660b425a4d5b5c763f86ba3c06109a050a735978ed5343a9931dbc61db8087bb704b82ce3f0485c135aee38fe885c17ef107ce11a4d09a616ca2a71783f892238858522bb64214e80b0209d9cdb09d6a2e596e729961b14b05fc0d581584b946b847a5f78da2cee771a7237e39115e4b62ee34a819c9318289bb505b27b7dd2a2104d3d292ad31f8275dfc6fe89433eff65c98c80b36b1c4f1f5cc0e75a66bd93cad8211d4ac7eadda166ff65ae679f53200941c320973fe1847c1ca352dee3cc50436a64871ef1c00f8ab9d8c8848715f1323ebca2266574b22d0a20ff72d60756dbfa6b0d0b3c135c2e3c3667f8b6ef65ea04de69bf9f22235adf086676c419e99bf30af962f591eaabc41c7e583c5908cf22aab4df810fe2bd83b1f5103c86ef2c588081f30fa8eb2de4943758a49cdea0676f507cb396c4351d563079af37e8f5e33083984ad6a8083f0ee06d671345f58c8ad5247f481db6533ef385288dbe75f531530e8d45b9c36ca4b617d0fc0dadf2715d6fcdb7bdff1bf42537e82a78e080e7a0037293b7b3f7a645fa9eed29d9b77fad68798cb1b16e939f32c99d9cc4c6e9010d750b65a0b8c55135b09f48dde45bd8a4eafb352bde40919debe9d4f06b3107963ce47e3a0ad73850d9b72c269ddc37b040230b9423b70bfd6aff01cb96798fdd5041d899828990da6d1be16bc39e3e4a6e20033118c515d03d30ea170ad9fddf467dfa55c1119fefdcef6f878cd3a9906a3f177bdecea4d41abfea7988593d23dd335e01f22c604543eb64f00ab7359cd0cbf1dfb4418decef7da5b80d025371ad80f5536a811f0ae6289480f041ab140405af6ec31b7f06f9a0193119be2d731a68091b01ad2686501443dda0872e52c558593aace1310edf8a2dcdd8081e15c655b3b3e06080742fe40aeb45068161f646a0034ae380f9966904ab9b7eb78d5d99b6c6c4dd21bc92f61282e1ab0e694d383709649ac2bdd1ef8a1a47ec310f598307f774068cf673cc2e892189c444026d1d96d099a97d5066e407064bc8204134970f2c53ecd6de9d1e80dc484e5b32c82ef3e82c48e8c6594c7bd4a6831d7c05692b08780a4933bcfb43d3603cd815ea4f7992e62ec6c0924102548335f1a77812f0514bc8ea4ee45d2838b7156e270cdd885350c54f5e184a0181c2da25acc50413e9cfb91f9dd8516346f912c5e9c37893da144b75e25a97baf1300071c776a132d885fa8bb826f7a84e54bc3d8ebe7b3139d1d50842fa8ccb95219bcc605060dda5d1c167dab1152e8d61e84b41707bdafd17f976d15455778995ec57002b9b1252fca0d130c100466cb07cb9968b6afe7384c28aabeaf161d03244e5f166429ba30445d70c31b33cbdfc890dc05628905031dc8b1bddfe94195713ec63aa7056a405dcc221e44ac416575be9a747e0fbe48ae66249675bd57fc9511473d41a742c2e5c52a795244da6d6da1d245caa80bd254111070db6ce2144035b84878d574328c13f86308ea297fd094534b78fe612d54e80bc61ed35eac6cfb95f5d06a2c328b71265fec99b7340c41225bc4df34f74f84051e88ad3e08b9d3466415360277297a297f602ba100e85651dbd53d6fdb84c021c6a2ed89211d840998f905bd13739d907a0ec82f0a4be6e335808b1ed7226799f51ce0b46dffa38b3024929286d34c4d3ff4f74c64679bd166c9d4d440978913de2d6a361eec9cba4201b1e6aaac06284eb47342e750bd044f43d596c960b81b3444cc533f5ed853d2487c0b741c8151dabfaf32b3c8670cb339b5e8a29a83899562066dec9b76be32353882be14a8293a10f720913565edbdbe9cb4ea2af20cea2ed4b996a39560932c94880ea013f11b0dc0f8a29c87d051b067f5720ea3b94e52e7705c8c5af8d13d42f88fa0dcde298a9afe3067c28a7f62523028f4027037f70d8c79b3f735f3cffc29831985002be9440d202180c3d095cd276730b42caef44a65435de16d9ac9fc55ebe342e6ab2289603d5b58a1d25f927459b86f255c0206345b62dde95c043a3a5e50ce560cbdf7e693080948e0cf6090108cc56dadb8b45bc43b4998f29b6bb6face02426592e4c70ec7585a5fcdca83e6a0bc4a06dd3d243c41fb6d947cd30c47bf7e3131b82d2e90103084996558947312a07e5cc76625a6905db1cb4574db826f85e0a5ec4db8e31cd6d7b0fdff46fdf349916df7fddcdbb5a9d0f68c22eece9b11ed3e087ef225e27a0ddd2670efac8f5f52dcc7906b54499a32ffec0c36e46378973772ba82f9ea538a80db5b7e927d79b08a301859d1fc09588fbc292bd6183074b3e0fc2620fd7a852998237c986c54601b29de482cf2b5ee92a30a22c2ca513e0c22d43370184615df104738f5c720ebcff16b64bc621b501d3a6f63d0637f0361983e95948af456eb0ed5c1c7b84d229e372871a9dcd3bd9c6f52fd5934f91296d75e368aa14bf3be5b427f79adaaca5fcf7b8b2df8f7eeb2823a15519ab5171f1bf6c655f121cf291d7fd243fd5087b4ac68fb0b2bc88d4f3f829952533b614bae1aac0e2f43ce17a4c2df5e9dbc10c051975b301b13e1fccb71d87df6e96d9037bfab4368f8583b4ab105b664f647ed4e32ef3d0827e436329e9320ee8c72bc0c5c9452e0eefd86f1d61cc1083610a7eafff851caf9f12eff177d7faf0b07b524e905435f497bd3a4b68825f6485eba03dda24e589ed9ac50a38b4d56a78b730b64a045d6e42e29fdb4e79fea2d4662abb41781417499933db26d6468d85e03fcde5f6ca9cf78d10cc70f890bbdecfc35f16a13c85c9274de437ba84aa956478e8e83efc9e87c886918bfc6aceec14695bf1185158ea75cdeb82ee02f820a49c4d4d5e7a9a9499fd04e6b0fbf66e40b58d165be882d3ea126fac2b4e1dd7bac514b4127c72f2f8c31fcb95e48ab33cc35326db910236d2784f6c7dd3351d96f3d40bdca8a270bf9e019bd626ee64e221920cdc24178cb0d7a7ddae72fe30b5b20da0ebd0207c59ad7983b23e101309b3d58db94c49f25b66cc839e1f2c535df8d913d8f804e92a86dfe34a1beaaf39a5b67b3729e8c3c17fe8068b673e75e6ab360de623255be94463a9118749bb2abfb26f0cbf13058c52928551bafe81744dbe959b3835585da4ee95e249c872c04dc94eeb0af63f4b4adfa685d3f95023f19f6b14eba7687f81a697cecc9c63b9f75b2b6c1f0f98f19d52245ef02d5023a5bdad7b7c66585730474e81a023fa720fb8d9d4fa1c62c76fc43b02bba986682583a02dff74daffa27e9eae0fb9774b7c0efdbc4d448b62540c508e0c80648cb51bfe3c64bad00a9d210d8038cc77b5892873dbfbcbca36944f4a094c68241c7ef81e10df1e72da8c893a045c76c227e3bd5a223e40300de423612ce0aa53a778b22870b0da256026a0b3718bb97dfde40bbfb35a5ba4106852ef22ac500608ec3ab760cb18eb3c4cba5201332445cca5adcfa0d9a7f44c6f27121a2f6c9ed32ad61e7e41d698f63e84c7bd20aec1f9e44f88579b571e184cceb1600522103fafad378bbc1a5502f20e173f7449c721a734ab57095bbf0c881a7c2a7186e67717f62066551d66b53dd5ebb125cf8f322a4a9b77e97d51654177a60a21730a3c84510c43efa6c0703d2a40b152cf12be4664297f7d1092d58a7f5a2bc9927269ee65f7b025ff7bc81353e9bc4522460230a78b24fbb76776b5079751b16e7c00191624c7fe5ccc4bca4581d73219b530a8e129aff3a98b03ba5322f30aec75ad2ae77f18186aae41ee02f021d2d21c1239e22dc80c436c12e2b1db0273bc650cef111774c5d2d90992775de7e8c9621d85a8017e2419d5ca9a9f6da8058f4f17dd785b5fc3300a432849d4b8b9e328dbcb23380cc51f5b0b59b030510a1f4099d78902f49ba97e5af921482e48948f4ee820df89f8480f0048becbb818cb920862eb710d89387db52cbf98d2eb86a21af46fc803eddb1af00cef5cc3783cfbc2167f8dcb30a390ea41afb90bc05233f88e59a0c192908c8953a939f56a7477fccb040998eaf5215f4951c96561b6972d9e2681986a4e1dbc3970ab49f61fec384ab05d07ee5a7615a0bfb7503ec19e1a290dbe8597eea117147912e67cfe54e58bb1f8f7d359135ad89595aafb84dbfaa7640a3e468a5bb1484a2c2c4eaafd43c018142d3eeed287874fb81ff0f5a322ab07bdaa9025c5f658837bb00dff7248571871c4ab7600c49d21d801387187ea06866f991685ffa52acbeda7e0fd2db8134015467ae5c3c36cc25069c2f57d965e0edc52ee0f604a97480d0a33e4348647f684160bceff155c32aaa732e95e94a4333f2fc84ec6fb5f77d25b46af1b3de2f1b764fad01d680ce8f8382f1b23e30100e3a9850639dc60eb36d4b06ae12907c7c8837b5455e6973368cb5116904ed43ec50ba2737765f7c6b3ae9e7774b9af9fd16b4262635664a2afc30d46ef1f7c479dac9bcff2bed5c332ff0d9853554fca127cdc4abb3102f53b8165719c75cfecf81ca439c5bad91df24c88986b21b5b16573d6c7f12284cba1807f1528ccfa1e496f86c99dc2fade1da010d5d2aee40773a93ace032a019fd6501ddb1fa1023582524d05a1978c2471cbe19f477a14a2dda9ee39100b9fabca54e9c84962305a6eae0ded50a3e57ffef323d2bd47a98c2552bff3f3578b6e7671229776a3439407d44f6f921cff0ae87343494b9f9b915351950ba8b3a94fa7376cd1d6a9b29d4c9548a7a49184a40f17083f912b1d0de2edbb2f4cad4ee39a3f835e8d2523577367bf40758f220eeab5a2fb5802725389675fb927f5db9ab0c5d6a87281b52a39a89f6de87bf6a567f87aa6de5c40f2376ab22dcb8e5115cc6a4e9e64226c3a6b9bc4022cb6354793d05281c0add51e942a38aeb7a1bee0d2eabda9882de39c44396017318cd25d26962e14b8569077179c1bd79b758633341c2173a13c7bc74f3989988c80b64b56154841fca27a728d5ad830d7ff0f61032ad89d0087dfe8e74d3bae8b1ba9b05d0b378a5294989ebeb6686630f5efe4129c00e819c0a727ac6bd406efeb2b3e1691566ce468809fe4ed2884708e7b0421686909ff21ac19761724d5ecd844a922eed53c745180e8b315496d33c68b39b9317055c4231bc6d0199588da5a02b3759bdc480237582ded8430ee41add9c49ed16455bfe93cee5985f708598b5c83c41f8ce4bc3337f70b7bd0b72f8839880c2818d291b9b76dbee7c30a0fba39304f2141962db86527e91092ba60c2c8fae0774fd1ff3f838c933a920a5d1d47c71b48b8ded58b9bc3274d9d5d1d327dcd6c8d371de82f41708cc8992ef9d549d4bd945efffaf3fd7bee0f71c3b2d734a81da2a6a45b649262567bdaf3a7d3a1c4ab52b472198beae2f072c15e96e0a6a55a9ef4d9030c531f93d7d13e03037af55c532691e65f11afb9f8b2ca01a34cdcdb43acba90890270d7ad7a05b03f4150edcc10e549ce8749b544d42b50edc576b9a78f9590267d7a1b63a8bbeedf2785278540c36cf7a72df29bdb240afaf7d077cd1c5ce1762c0f2e3be1f611965ebef86f4445564f4c15b9d59f173408ed1e9753d8ef02be981c4597b263ca32d2e1b2b3252b82f6e548889a5e17f51c29792f7cdc42f672e5cbe2b2eb15bc8f0f41e31ba95239bd1fd36c0307ec63b5d29566e5d10bee25367368c00510e2cee18400c16a7e0c2153cdb8bc5279d8b11c7431cd4a03a80a89d8a998595ee39c856b94355ae6adfb8472fd925ae1f74747f748f36d18fd7652ec0821b3bff59362a0cd28a343d06ca4d9a07e4f112b310d7db6cf756b0e08c56aaf75bbdca70c0dde89c74381475f16676296e6d1b9595ab4b16fdcb65a93dd917831dcb9bf8707f8762d4f00408754d1262b7d10a4280ad42857f14c3618b6bee7e93002779f1dd357f5a075b555554fd450f9f9abdb6c8228274460d6206edd8ba62beb7af73e49d2a5e7a1498a86d6db291e374f0eaa06b014923ed0cb1544731958b5308ad239549fc8b20f3575d739f711737729f7df15b4eada9bc61a23acba4aace0a532a14ccd2f233480cb306f8fd3825eeca84e4f84685f6d17ba988b5bc8d1a8ba842074b4440a9d26f6dbfbdfdcb8e9d33b1651be7fc1b354844cfef4bb9dacf5ca3ce3db44bdd1cf1de1206d53e4c27c7f61409a16d0b7b41a709013165f71b62062154a7545c62080c7a281037817c562f963e33e2c8c60b4f18cb1e5d6060be5d7d55625433f89acc95af70aafb812948e08234832578354daea665d459b17fef95010777208f6e3cb82850f5165a459702e60cdcc9287f86f442aaa6b4f88b9fc0b58dfa8b4a88797a4e97e827f35ad01cecab34e841ebcda19b297909ea809cf3630d73a7388d3034882079d546d76667316052de3bbb95f33bcd91652d048631198929c9027d99dcb3ecc2df51978692395e4974494ab778f0169c7fd7a54a8706f0b82526726cb98e71fc233fee3462da7065fd3a0a8ce04be054d1fcc828f44539032525e32d822d98920c970ce32eef387bf7abeb93d375cd54f6b7946b9c00cab5185b5a9e0dc1d51a199ec1274c63f7a639e02ac88f48c4de6729d8d8e3e1006dc37a7b5aca8ea3ca81ea17662f9bf33bd326a35926880383011fe19b40a570499d4d41deacb5f399919f6de19c5113070cfb1be0f2231da2e88fff741b33c507ab21be8fae49d67dd1f0ef185118c169241504c6c5259298dce3f228cf80f3e24db8060cbc4d29a905e1f7ac8e664bfd370c2faff5e9dd6292ff3763de33b1e6339a4e8dfb244e610dd3fefc6fc0763c5daf51bd06c339cbc940807a6b006eb1a0fabb8b9edda751d6ec68cd955b77353cea9c19d80f1a68a6f32f95ea574aa97f1630b7a779181c8e5110d798fb56500d3e77220c8378b96df01a7f3df548ff0535b425a41d0ef56d5917b1bcc2ebb6288aa7f02878998613f66c63863cadec36f6d9710ef6a25c646c03971628e185217e68a2f4023e7a79349dbff12770b5f16d2bc6458459629e2565494ad0cc419150734727168ffbaf6ba7cc99257acc2fbc185c87d4d8c65fabf5effce30b3c972585c8d2c128fa1721f05db8bc695581f0d45e44cedc96a36130def940e3aa04c37275c9b35d4372e896b115fd14d998b7af8f0b3a95115f2a3321056649f54597b08570180358da11fcf0d6a4f0821c2f1adefdab866d878bb84de4937e1d8e855f39d4bda877b75f89379fca44f9208ba2841563add931858b97285749f98094f2cacf0f278924085ba7d01d2f0306c711103f0f305f94e02c3c057930580081998b2b1ee5678f8a20ed1c7b880d6854fa40d8ab4a8b5e996c9ecd4e21cfbfa339c3ad37c3beb0353edb72d91a6eb40611cfaf9a71436cd53c508a34b0574dfb0575e58ac53a26e8ffc951ff73994c25291f78470490069c6881c7a0d98fb7549a526381dc81c1d98487a64780c1326483e772010080818d36fc3aac685434e80c0e743519f49c7768887b0cbb3f9a5c2d9ae0a60895dddc5244a7286451a8239a05488644ab8db3e11ebdf25d2ca934f6931ff024ec28c89b2f8ef2a27a464e9e8975eaeb88de224fa22f4a81c1cfba0117ba758526cd11450a54a3ec2deaebbb684f414b10625a94035c6bb632e1b50a7f03311b133f7cedaf338b6f97237a65d6a36a3c3f1187dffb608e8b2e4750d8ed25249a316c3218cee70e1c487ee5eefbc49f5323bd9a079da9c1da2aa54d247d8839ffee7491f2b2656328a555edc49cf7f5e72387b9385a5022ffae9d48715b174c3f5d0e96e2de8c1e52a14c1125c022f4f8b1baec929ce05b130d6de6d6b7c091c26ac1a71b3f76d407e72adacfc3d3845a90771113c88150a715e62298360a10c4c9704d5f35751ddb1bbbe8d23571e3450f9d00e05316dc8c918e09498dea6d4aec95dcf57ae17d7ce361d5ff9568c4a332a6a230c644a12a2230ea37e14dc78a00feab94aef3219237ca68db98c58f93d6612b37c5ea44fa06f706497e9913a9c88867b4dbb1b9f8eff17a1ee344cb40e8c9bb1571c8b9cf6e727ee173098c6638dd08f980d27201f10a5cdc56de4c35812d9154aeed594f7945bfde886c4051acf2f1db64c30667cc2e12ce6521a8d4ff6327048caac67520c0657be465497789c1e0413b422499a4e2dd5f7f71f95bb458a1cce3fcd71c3d3fc0e86e8ff071ff6162e88113941611c16148bacfb856ad924d051a68c7ec5fbab6f57cf11e4d1527f298db7d12972493b5b3b851126a5dd092b79b79888cec335b208f331676d6c2d4da6e827e36e2f14ead53fa1dff3aa235db7c5df085fd3cc21738c45b8d92cf0065e4ef19fc4989037500ddb49a0818dd1c9944e52c68081b4745c75c385811c9a7fae0058307868e121216e966761cae41072409edc4a6ef93c6ae1372f25f23c6d4e0295b616e8b0d33b9b9749b79d4d9c38b80cbe290e6cff06ccf5d00b796a7561b442d3be6c4ce4cd6603c704ea14027bae7617321cddd0f749f4b89fd7e2ef0563b211770cb8bde54cca5482eb49021fde6707c90d9040aa96835d01b9c25dd505f3bbabe8e35b5312b89ebf441e425298160ef2d640cba6d33024f7db1ca077d8ed17ddd328bd690b360d2315b57e8b028c531377476c1b05a0a9b0d7855b78f4c7d539511a63423f1deaa09d2c608b6911153f3bc8121dcacd5575719eb0119cd0a4ca072101fe1dda0aa6fe11dc9cb775cc0501b15c81a0e6caaaf7645de15e97969e5712fc3d3f2bedef444d5dba98730411b0c3be12c61b2ade6695f7835fcf2fd890c6cfb7dd3d922e1979595d96976976afd1a5d47e15a84fe97dee41276aad8c4bd34f6b9e3c70acbdc8676518eb1dcd993e7e3689a54bd728926f248d926f5bec04295a1af1a1bb45afc23e82d819f998a046bb4bef4d88ce625d85913793c0c569d1e9aa6062cda71e243ece331b208f1f2248b401609a56ca247d377e1e2f582fbc77600a0aa29e30440c5738b4b588f20af12683cbb79806b1af8fb85cb40a7ff863d8d835222a5c0660b8fef392096d0048b480ad38d2fbdf3eef131e205ac512757d91dc702832e0eec3813f9a3cc1f59d79924e1fcdb9f83eee04969263fde87cc1446603df60d1614ed15bc9cacd97847c15f72974f8849e83aa986afb0f9da53c12f11b88fd5118537f60cfc21b9e0c82784e0782998e05a9549a88c430000f0542b37218309d275b89f560eb9356197d99290460ff0a3b7a3e57dd1e331f1e166d00fc72b89d4e60aa3ee7a8e7d704d7c0e297328c3ff24b06819ed754a0199ea04ca052164fac8950792e6c9ef8a113a3da716dcc2b3144796f9508d3b4955c934af191ccc4c00bbaeee5b26409a2cb270746fb14bdb766880a5b98f984e409e7de9d7dc20e27b9f86bcb401eb95e9472a5bfb2e2fd4b3c2296df56568f6ad4d5dbf4b4ac3143f6aa2103007cdf676b7a6d9c8ba4fac6367578af34256a3d6e04d2f041ca95de52a929f213d71829a0ded8355072b9c9cee4beab12c7265f4d855f2434dc8cdc3f47c22df81cb13f2e8f1b660c7e6a550b15edfbb5f29dc77df560442ce98664980be2a503a2a41b431c2a2cac820ce90a1f81165c32ad27e06c92a25188d2690abd56b3f3ec129d48116955f7f8195b2c220f3548549656f074cf40a40d85bd1b3a3baf5ada73dfb436fe9e8ad8ccc3c265554960b0a678f37429eee9893a5b7c8b383f20446dce1aac18326ea281e4de556278a18d6b40b0500cee8de769e38f6c40f08ea93a211bfbbb2cb9f27059c5eb4afbb76d3b107ed695a2fddb24948aceb84df04853793986156f2e3a2814ef3dc7b341ee55a6847bc2b181f0b237c20b5a643f1cf2741cc93935ffa6a692b5f69adc09a57e6f3d92653f4ab0c52fb46744d85d204749bdae769ab3719460afe86091792db3c114f99bb1d4d178d93b4acb0e665d1799689d0098f1b87ff400ef520d6c833140987f1cc290e205f5e1270e7837a2709bd97591e889041789c6e8cf2b7f50555c8a75d78dc72c603d7464964157915f3d739e4639ece4b0d701c1ca1b9024505d4210449c6df20064edfeb124b1122044ca2bd3780ae898f077cbd49eb5a5ae810ca6b8e525a309af870935c8f7074e87b1aec5ff0d027a9a62add7bf4a2c7aafd213344dcd681e13379599460fcf9e630ce9c7319dbaed5605126b27fe7f0fb4376831ef05dcf12ee04516996aad86e719a2f78c4fc87319b0b451433f04cc6982bb00e5534ceccf80deb455686ace3ecff52569e54f507bd7a0bebeb8c8ac66556059ecec1899a1d9c895383f0934d8ec234c0996109cc52ed081caf8d8f909bb6cdd4628b9997e577563db35b36ec10b1b45f2cf3078a400ec6c649d49d3627dce1c4caac0cba1369f3fc347e41babb49884577140a568dd0ec0c92da040b734a994bafbadf7bcbcbaffd477189a5106f9560b7f8759ab18ea807849a568611cf5a8bed21e98879a70f5ae6f4c9e","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
