<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6a67a30dc3eb7f748113b960c3ab40e3f00af09718e3358f4b32d3787c2e0ca07473498a21bdba2d02a318b85d29603e34ca694dc12d5e2543bb2b3bb305022d0a869a52caea7be79fabb7f166ee5a5123fe21bd5f4ec126163c7a508f98b01bead2022ca09679a63f8637b6abdad5440e9dca5d2b5d7601eec3c4df8e7765849b74cb22133a2c585c08e83b0c0d04c3d3b7cfbcb0ebffe04e2cb8b25a1e4a867645ff6aed9021cbe85eefec1bdd0ef646ec8b3d616b9351806ded0a98000875d34f9853153a878c09e45cf6a8aa7ea54dfaafcc215900923f09c46c3f52e268d041a380e78d9fe4feb3dfd9ad846ad1b8a76ec148000f31d80fdf90767b3e182967fbe4c2966954e32f71c68e2d35e081aa8098e4f1dd193b3c6121164faf09fc062fa9c29b6f0cd8a92e800fd1b810a73856fdd7de3b7f6677be10e5e09995a35c3e97cdfd561198e5b1f4948757c9558ffb5eec83c7e7fb73c803b31b1297d456f97afb84ba20326601fdbe721d8ad99141d10602dc890c717a2b40b870f0b8e69512c18fc25d64e4e853b479684f528dcfd0f69738d67510d54e581e1b19fea9b70f3cfad0f888e1c5f0c81f80e7d3dbb5485aa7b57d58ebaafc1b512fa7b248ca475391408203f899f66d891859347d4606abcd33f3a27fb5dc2a85357c4e70e674beadfe8c7b5ead23714145c81c464f2da6037a8226b6e687cf18b989b7a7a21ad26406c4b4a9acffbecd91c28bd5602986260e9d558aae58a8a6f1ed897ce86443d6506f09bc59b7402ca595dd30766fb05728e721a0ad13f37d752003e88beb328fee86bd06f5b8fabefeafb93ca2cbf9e6f0080128a08812c97313996b34b939f4b2d94e9901afa610e13b8d3aa010207df9c78ccf8bdb273d3b1616e0ae598c727f4ac0b22e419a6329d2e2e2c7ab02f06f336a75f209b9875044738877780c221a50bf77afa5f2250a700977095faf80a13f2b32cbf2aba89c5c105292e6f1e949327b63fdfb8718af6aa39980b8fdd4ec6fbbbd663ed1fe3dd98ad093ec517cd095a57b19f5677c95f3a36677d567c26e71bbd5c821be8bb347684577bf1d154ce8d13304c7da6f1936bc039dba8dd4e0a16d68ad28b3362c8a2d306b45df62256c57aad7518fdf370644496f0094a121710e8fdda0ef0e6b792f7db395e30b72975abd66f25e94b7aef5e4d911bc22a7eccbb9fba830ae7c1332279c4c2246b532ff11e2b921425891f0a218805ec52c41c6cc8d5a088726a3c35f273900d3eb0fe849be1140e659869200b1c2961f3de80dc3d00e0c5e69feec7766235d7d35354f113e50f2f08335d3f3e70ee36c4543d134405d0d9ba031fc1e8890ad08a0e2985fee5c63f0a88828293c4ccb29b79580ec59dcbfefabfa035f623a8f1e9877aee5c4d3343daaeafcc80d3bdeb091283141637947f8531b936edbdd8f9af9fcd4dbb3b174d4c6462a96b8bdf7b79a329d1a3a388f6ab32bddef12d5c0d95568d2a154fa00e8e35460816166d03bcb45090101e966d28b1c335ce167ddc8c99d912f206fb04fda961a10ddbbb94c76a398f39f59c1202ea8910eb56664d4bb6168084c34999d207d6309c791ea671b9b8685f98af75aebe231c44d6e3f3a009648956b3c06048845836a8fce201f8bea5db619567beae778497a96d092d925b1b0c8f9a5ea1d5c69467b2ffdfb04a93fd13032b8fdfd7e05496b2495a86105fd593e8da6ff484846102b8dbc158f44036a51596206616e05db13b03545eac65d1f7d12485709f3cad0eef52c62906122a0d9a186b58f2af16144c009b83463ab1cc07f2adf7eadc68d5e2af105bc08c22522d6eb748f0948c072d0d850294b3f946dbbad45a5b6259fd7362c8f69ea6d0e07fc7ad87cf75c0d49fb022cb5b1822c5e71f0781cfedd3693027953149d862b3dad0cb6fc9d6c439d3523d5c30fb8308a719d90e0b33c9970cabfeb0138546408e646d06fe93c00efa95af471322eac6595359f8c67a7bcdcf2e18131e3d687e4bdfea005219b8161ddde525f3d5eade338109085560bcbd838d9950a8b365fea2828c915238212881cd91389cc19aba05e50d42f0b5d0554906e02d8441fa11d62ed2aea45e180688dfec708caffaa6fffc6830c77c0ccd7f186cc82af05c50c1b0d5ee7599e7ceb83583940b541c5f2b9fb19902f6e17271767ef8e11634e052818bc14136f30c2e646b92d884571e9a9a8f797e416a055cc00661c2a2ca068d711504eeaf9f38417d0cdb18bda3ebd46b2cc9f52a737c76bd08ef0b788587457be95bd3a4d13b685ad0b1141921b836ff6ce3a8d7def1379d76d3c1c50ad9f0b81ec9cd5eb1cb73e62aec19a5407afdc0026317cdfd3b619ef67fd082b5515de52824cbd943738738bc641a1b18cc5b768530089091c09a4a0b0296f7852f3c7ec8190c49442fc1b2d4ed86808c050828f5a59e161b448a8e383b53763758ac01c7f8ec5e247938625932a02ee9b5eba31c6e552cd6740f027c29a7b1b3a50b5bba64f7fbc4b2b25027cc8c980827bd03ee719bc1d7b4b136a42490870446033b677ed3b764dd82ab20d5ad14b048b66a84d23ea18f3ea78f69ad812eadae689abc917d609396c03fec48dc7327ffed0447a88e9dade2d5782ec4608f008f8aa21475710ba0a7b10a06c36ba41ec82edeebaaf29bb63b6397c96d28ace429b349889609e05d0ba33dbc7c79e63a50f18f771ae9a3c35c459adcdac7f0f6cd35d89e54abec538da9bf9f3e2b1ac834aec3385290439404d31c487c5b2a1a2d2a5541cca3f8bd19a8ae100067888c686642e6fb251972e27e3892278af2450bc664f13f69bad9f5e20be754821ab8ad566083d156984b70a0cf9c11186178517702babfd21caf7389ee4df091e79742e45b836e3e23b1e582d9a9e91acee3ac8d5b82be70a03c368f8d891da83caf1dedd718c257766f3ee1a9caa9af0020a04600837608701dc1942141868b24df2f533bd87ca0051899d1b2050d48e0cf9262e9b902f79a6961b50354e410b0fbaca9d91c875a8241b28134142ea9ed14b7426bba5446313dc6f4aeabc73e925e582e2ea62eb37c0a2b663a241d2938371b000cb08c63c9ac6863d7cb5f79d74579840ac66f7bcfdcc77244c26cdc8bfa0bce9688b6184f5ed60cae8a6a6928a68d75405ff7bd765353ab1e1424a6abb88425dd8c22ed777a7a060894dd573653e8aafff1f9d10542ed97a5ea20d843f0a91e5256a3c404da8099d93b42de4a23aec0a8dfd946d889b46a2fa5c185bfbd190ffecb6ac716e6245b548d5ac2d4965e2140b822a5eb0190622f93ec94b9374f1e487b98f403645f5ea54102906276cfc235095cbe9fa7a0f4ca37e5a74f0da39680fd89da1c9de3b015b8c80fd01f77b0c7eda0fa5e0b890475cc7c9971e21adbb41f931b6ad9558aa84b4c9737b990131c8d0ec5420131bd2a0e5a999810ddd1548f5ca3febb01a4f4ad06dc107562fa166562dae2766efa712749bed60fe446d6ed07cd2be1e25452d0b85d931f9ba452fadf04b91112961646da00b7d7fe20f2cc4fc4787487749b72ad9898f64f4e15cbef7713fe1ae98ddd956e628daa242e0880f404a4fc121584c0bae62f39b7c69c4eb4b9863c23d259f25bf4b93e3a9d71de9165b3ecad8e1f9e843c9b3bfb02d92c6e3fb7684d078743a53ceeb1c869fb7cb6f2f4cd951ef7cd79088406a2bd668162f6f524a11253ed80b8313b9a70ae6be4b7000e007d412f4e19316fa4a23f564b2c736f3ee7ca81dc32cc2be08d345a8c71f5d78554e931b1a5284729cbc6c44f6064a084a427452d3e19c93067168f498e5cef3c90fb6d4613cb86da30087eb12a216bf8a29db10e28a8e2537e8ccb4372b7c2fefd47d57736401c9657623132bc8a859ee24c722a67ebb3d94cef3d88bd18df546ea5320c0194881fe0b8c90c38aaba8c3c15be06734b452381bae98ad185e7a097745bf4b93ef4d234dfeb8144e367e2f76b41f5db95b33586c6f9ea2736335d52dea7699e91b3dcb189d8c4381b17e8c399232d076411671e08499c840db4f8ab6a5cfff9f891da8b1d59d95f3977f7273ceb0f4ae225d62110f2d2b0fc3d1a16e53fb0d10dbb15a724216b46173864f6450126bcf3dc10ce0c21d9ee0de351995a6f69ea02aca53b114554308a77f977d41184e21417cf98b246c1b84a80aa73005d8a2fe00eb94b7810f8cbeb8c44fc17c8ea92cecbe72712007170c8b84ce72d8c163f64c2806afb703166eebf38d0b05806c1f5cd2e4ced23975265fb4aed1d93df4203a9e075313e61043b6332aa4454d305db4eef7c39256109ba9f1dd39fc26b5327c987611755573a495eeab0bddec223c616e8dbe7c2d2eb58c282948b31b8bc3822552f8bd7cd03ff38344a33a2efa8da107d669c9577982ee513845762b3193929e86e76f2154c0e7a4996f1dc5e588c3f8e002706aa3622e6ac3b5265edff794093cfb0ab6f234d0a42eb6fffe2b07ba4121f6bda7d255ba6b72842f1bb7f69edae556390977781c53b856ebac64136c946499f9f29ece27fa9a36faa9fcaab57b4272d4c61ac7fa8469e53a3f3492ed3377a2188a3ac63ca15b9f58296b83efd95c1ea261ba05b3bb9b9049335876cf1daf65742a4cc70ed64528bb43320c30c9b72f51033d6bcd5d2fb8f8639de8bb7c0e86c4e7cf64c229d0c44ab4a0766d9cec75e5ecbfb088b23b1a4c34881a0f9abaed83fa7bdf2a9488fa449d2a109c1e0f90584805ea2fdd4184e05311e5a6b9a3dde92baeb69284827c2748018d10ad5430fd2ce1082ce845e68499b2f02f40292c0df92a275f07f3c067a216e14bdfa2db3b5debce311b0dac2945f6387d515d99889590bc6128c3ca995151095a684917d7d7f38c733b14d1fa55e8afb7cc46e2da677bff34d30de1fef9a9316d675062099f79084ae920854e30c79bbfb0220d068efe7d6a9be9e3806c3b5832ab23e99d12c26406751aef14d2d33f7a51a3df106043ad9a303e6f3d988c3a149970d01dc9d749e0cd0af9c8cd50e5b67e679cc7739e30e9589d023ee3ead3f5574560f05aa1cfd8d427e3053277a546ea46115ef8935a273760f10bca203d20e47925cbf590b86c4c742cfe2177f666cad50a76b900214ab7a0711e778baf1e3d74f1f0781deac3d49409fecf0f2fc18c9ba4a0310f7f5cad5d5c767c0d0831635778c045c45aa690d7848dfdeb6bd7023eefbe27a14bcd97b6d13e81175c7d450126b47b3a658864054cfbc45a5ac74e631e88f09af3b43eb82ff8fa8ddad89ae68c40d93505fb4484e17030b080b55e9dc0e74a411e5a332376526b2ce446ae00ee87920ff798f14b33cc87dd07769eb6a934c1bb33b9e76a9c249aa4f15583f24759ede606eab2fa3d6c523ca088b44b7b7a17b4aa331156d54b0690715ec3a83773501211eb55dec2f7d7b7510aeca8c1f292e81868d676b9afd4f53b58ff150836cab9eec8e2bb2574e7b5469bce0a30dc9784ae4fb2f5c17c30d26d4061ecee4498406e2950250c91bbc0b3c76397e4cc3a7f270c2e37b36461099b36a55a0a4e233ad539183127d5353713db7e36f1fa7a01e3b4cc526730db8435df113fcc4e69d9c0a5e95a35a980b08663b5338793a93cd4aff40760b987dd628d988aaff657dbc85e5914dac1c9db15a218c8c589066c0198adf4b262e3e1be736271cc1984735783493509ed4292cdf53e384a7786b0643bdb29ffe8db949b78705f60d192e9098bd6898dcbf369a3c5ed518742dbea26d9f98d769a8b8cc2ac999f3c1aaaae8cb8665fa7351744d9e710dc0abd9ca52940293d348dc1a787cd46dcb2088be88fff32c5c4a993d80c2857b379a3e4d0d401e605e4060789f2ecf636b29934b2d076e5af023cff49d56d3e5593b55c129ecb32011e9963ed7a24f0e4751990052b56c9c12907134c26059d591c0c11feebe6d973c44fb3d570c45d097858ad9c7181518c40a8b69f71528b4a1cbbff5fd47126f3247d608f509963e817012ab34672fc8a6cb23e0c6f21e1a3d88d920b39e0be6c098994421127707e5d6a2dbf89de07bde0e0484aafc47df6d3eeab7d720bb0247549e2bc0e6aa09749e60f56be794907518c1bcea838b94f2784dba5cd52f409d9188d88d2447b9d3d097232fcbe45989e77c142cb2045038878e95ee5af7d570eccf2a9a44c722b849dfda1a373e3c1b9daf4bd7aa36b232293703d6e7a39d0239341d2d65bec1a1a26df9d464693e4887aaf54f7845c87a3f336a36782e76b7996eccbf26e03c27d9869883cf3f5faaccc25ef4b4ade3288db8608b50326245e95d80401ce909c53e74707481786e824df8bfdff991617d4b6eb9c58cff53115fcfedb4a7833f1f34c6dcfdf09280ab559fd9826a5a66f83feff246da4fcd8b082aa2eb55d1b155bef4172e4b91f036e0f389adffc5c0f41653d336c1255e6c8b8f6e054923ee5f1ca643730238da158177e7832e3476d4dd692ada4b9a908f7573cfea1a287c3c8caf9bade22ab13b4266abb57cb2414c0e54b40b94cbd3e56bab029018ce90f2fbf1ade20a7f1af7aad6166b6621673517e614c406d3d59a1d1d0a83c9132ba8aa1d93795cc4172a75416eff7efb3cd6a96b295d10179524e7bd969428448bef4ee60c97d9983bf4541455f85d65a3442d039dd965765f7ddf53a34b3cd7da2ee5171a27963f46d113d195b9e7a3ad1d06146e1a0dfcb3a1d39a5f3a4e7ce6aa6e9d8d0482f56f7e2c5791af87c1d6030748a9c185803ddf0c2ff7f5a0ecc830ad2a8928aa4c7b7e7037351edf33ea3f0b212fb56f694487528b731755cd80db6b66929e44013461ff95120e0f6c1793fcf6bd554ffdb40d4d7486325c264ede928622fcf189b1a1bf596db53d429272665f30409793bbf31fa003c7cddd339aecbe8dfe94270615ac2ede678761ddb98c5274fd99d53b55c41875a8f5e8e6c1443a3c6891fb5f378e3f7a7b337fe1a8d0429c6e5b9bfe5d28ab5882cc6c9db2ed3ff300683524ad6edda9e8640a480626c121902b983461439561ee3bdfdeac6f924e7fd9c4fe6f940002db989dff16dc5a850ad73d6793f43ad7ed042d1f253028cc7f81e6441b751b1c1fb36067c0f0a85ceeb15581174ef6179c04a2d580408682304beadc8ab982e13ffca4ee9bbc876c7169ab6a6bb792089f376ca3d344d357cdc9297f99619ac9345bd32bcfb33a0fda82a97e5e21a2d2e4a7d87a126b8cf7effbaf4b13645f09a5f87e8a60372ea842021f121826e6e92cabe26f8e19992533e5068195db2043b27a879d160968f8bda8c7e3bc57f34abaa31c761efcb703238f4dbb86e85c4a6c6818ccfe8a9b9bb80aeeee2a9603b6c69d3de066313c87c1822d2f3bf4c9a03ad7b88efdacde52f21e22d03ec33c5685331585ec8be053c135806822c0c93e7832c602e0dce0f6aa1be544697bcbf4168f720392ff77daf44665213e61991334a155e728312831de6d112e7751422c7953454df4f794176323d746703d9da5780b4232188b5fc08c4f15f0d00a8dbf926d49c875f5ef2081104f2c130f1241e0b99bd5b98e7bdd904097c4e237ad5d0036dd62fb4661d365e423b917bbcaed2bb057c2f15e1a8490abbfb3871987ed92884f76b7e168d69021d32decd57f13a71c499be2201da637e94d06a0aa6132dbfee0407018520d12e4076cf71fb18d0ce522c319d257143a7ac5f57a9c5fecc6e6c5aaf29a71e86d21f02ead899d458007b4ffeb16ec14d957a9b6a41e8b38c52295ab227b0f3e6b843d2d350cb5416a1a4b76a4754f6cfa567ebabc287308cd26fbdc46bb3de0f817f712ffacba7cc43be32d68d4b2da6fbbbd8538ccc5450f3d5f70628da96d5f01454a1684f1f549b91ef9a2e8fa4c47eda704ae579105b26b7c1b779359f7c9f4613a633ccba9d0a2c76374bb02546aabb32e2b5a76164d68599cedd357a3cd23c47fd621286e5bd2d3e349dbbc839912067b9c01b1aedd6a779b6125810653eaa38302cdf9938628b9994d8479598e0e50fd79d8cdd468584d8872deff0d6667cf0bec99beb04bb30fadf1197ace21740bd45fd4e23811707475adeae5b7efa2ebe7a5d51b1250beb8ffb4525064a6a1f8c32e68452cb6797dd1e628875b66d393e88623f9a6eeaed225fd04d725b65ae4889b2be0da7cd44214040991b69243f349807bc61785d31f1601d5163433714bb44cac14859e276d907b6f5c3b76113922e5daf159c98e15fe2e564dd83acbbf81c944bc9486628ffbce37051170f6137abb0f6771cc55bf76958047fb3684263c3714c6bd46701e4eca20c825a7c7457e8a52e2f7ae2a64b43b76e39304167a25c1ee5b4590917bb0d7364688a0d8153b48b637739c808293b2b934f59600624b074dd349b2861a7c74706cf82c7cdd9bdc969140d689a4f0299a0267d731ce95a559cfca1282806c5d1051c33321c316897fb56276f498a22ee5f8e93511f571cd3c48d83991805fbe0e15a2ffdb8d13e57886af35429da6c61022d8909bd3f61c091f11a9a1ebd0309ab3d9707a97af9250fd551e305a6c3256dc976333d9adf041e8e03e2921ec6679bdffa9ea72149e7522a7218acd75b74ca9dafd2722b2c20e6e0780dd3862d0760895d6cac44df7ce060f1705f9ce2a26a7bcd2783411db48d5009a14f9d2a379114c685222011b82831476ab863ad95d5feb37a4abdf6cb52b4ae0a183887c9e3d00504dc7772f2268ae158be2ea5d324b3e895eee9642f3e41d73582f25e51683ddd0cfdac46a6e96a0082eef2dcdcba95ab8fc83c5f9aa9ef5e189dd76f4ea5b43bf4e428de2726e9b14067583aecc830f39f59a9b8495dc6e24b3e74d205f6906d1b4b3a4c87fe5b3e188cca5d9951ccf73ea99d5fa0311b8c717822d1260193d482349a135997cfd4e261d11944ab4f87ff1c6f53a4278dbfa2fdc4f56445930d91c5ce74bbe88e0e319a4bb9379f299afb3f172def499313a42414fd42cb22dbba63498be507bda0ee998a2c0f89e33d72a8d42b0df5d664e39eb3662fd1f00119723f53c5d3c3ef894bbb240a93d6bf78d913735351a41df8d69bf732f0ae1fe5174ac1d4454255e182f8fcd5d9d4cfdf82228d31c2d0d4237a917853fe8b6c47eaa45628fed53a3a959d98cc3e8cdf8e29e444aeb1a8936e75b22c7d5f3eb3029a34a3c1078f9367cd093cb93474091ba5766c82e9219423baeecaa11199b75da8cee661e80edf8d470b791f5507251c3445cedf5a978ba4c60d06e4c8028a8d8795625491d6d32e4f488f4fe9e89edd2e3552e8c46746d93af41f374b10c6e75d8f5a071fac63a6e22e25fb16f01f04d65e9955bb033db92aa4d9754912bf5776c331d908fa2376468d74282a5e3f9bc1bd31e71316c18c261eb886eb47c90020b3d5c633046bafdbff7d751d081d90416592d095f3d69bdf5994661144f176a081bafe09b1b547c529a7775c7336ca586fce483a476677c4ac0c0f0971d7f6963456f146929d4f5a8fa8ce22e7ee69a1ce5667ef54c0fbea20af2fd0872275fc0d86a24f11b0c29ef16e1fad1f81bbbba288d1277ae4471309407da68bf6496cde5391f1adc4a2d4fba341d3db8fa1fbd42ffa7aedbb721a65bc252e2299c4be78cbe8303b0c3fb2f2aa5c5bc1ed28d76ad57a47ee61024f7ed4b5370f8350487938a1aa9eedbfaa349f7e03e77866dbfb13fb09960e179e976de41b7e1269829411a93b28ba8e7e65c06ed534640e780a362da568da8feb48f11ee3c654f0e40900f2ad771a4007a19704f6527a44bccd773c927ad3ea09e13ea28c6b8f138d28e09533f4385e09283c00b1802fcc30dd76c9c57cccc2923e52889ccef84d0f3e98d3fd0aa959462d72ed5a0321adf28f9edd568d7ec8a9d17bac788f24c716b32442327881ca63fbc678eefd59e15bc79b79e012d4b89080075c909ff27038bcc5faebed56310fa33b6c002b0bc79d7b94338fcd565643ec5ccc71410bbe90ea2a3791842fed9a422b289312f549c4c7a461fac61ff5b71fd30f7ba0275f6d9f8bf37d42e31635d5635af38f3404a8de256b6299af8adef58d1ae06d71e1e968113fb295ef7e833d0fe3c47ec476e91d5c70d5c9cefec69504048c28a52eb67402bdc1ecd72b8a4b8e77f974430acaf0970eeb7330c9c4a964bfba6c6883ec695f74bcf49fcbd6dcfb276983c2023c4a78bbc16f83f45d566807d269e64f0f90020a0c7d9eeaf502277bcd7cc62a437aa2f264cbb67a2265615d7b0972413958473353eb8a9642821bd4dac3b710e9d0d6f36d7b1f425be473150e2af0d6aa204c2dce2537b1c5f2d6b12e087881fe2b53a8e71704e3213c923ecafd72bf57c8c0cfde14f1e7be8083e02e9a76a9d03c6c2473776c507bb2efe4b12d691dc536a24ec4dab00dbb25761cea9e0a146ae3a63a5e09d8e8d67ee53c4dc96ce5704adab87676d67b73d4de28e73c317f864bf28e71e3655fbf052185692a74d514db70cbff9763a0dffdad9204aabea621893539d4a70aa046181be80712454a4fadf9ee681e186cfa4475820338037e5c6e2b52bb6d86f2ad26fb120c6edc1dc594926fad354e5c0124faaecfd9e4ae6fe85c47f414361eaa1315e9c05af80ce2e018fc0d20f64a6df35f38771873313ed940edc3467bb1ba98a0bc3ea528f2344bd450d73ae42562894ea1570b62c2033a73b01ec9c15f9bdfd0bec1d572ceaf21ad06f58e964161572a1fbddf2b35ffbdc36ab6e67b7a6e9d0c66c77593e8f0e2165f4f49743fad87bfcade6478c6bf6afd75a428ec1df2b7d0b05da451afa79b82a0054c85e6f629ec4f2bd358e9052ced8c4f180e268ff3a3f45dbe4bb305e919cea99f8035881c5294112932c8811fbbe9052d9c61d8448e36f7ec30a6ac6dd1a37aea0e440869d4b7fe77c9909a66cfd1bc7653abb5fef9dcfb2352838c80d56ae3b018756f3a65ac94c61a53f780f514637ab4b0a804ae91c726c8fa7371dceec95af06edbf23f1f54bf263995e1f68426456d3a8ab7893334da51cc6bc97b66203a992856447d882ba44c4a2b1cf8362b383371d61f7158acd35175950b3d0c8ec068b8cfbf92015a57910655b42b8c31e00d3616f26e4279c7da3af6181f10163af9c77d8e0fece2cad5d0f88bf619f6588a13628a5af1b5d3970817d23ab9c97f064984e8e927af705825a9dee3cf55be00fb3bddb031dda932c78cb1c8b69750e2c165f9bd77983725cf8a015fc3258c63a1f418e25582a4d30a3c45bb2be21ce3d9033055fed9de71d24d1d34dff1a0ffacc26adef8b93ed54c26cd072c5550fb61eb1f8cbbf4bb6ea6ab6a4f09f28fa0214d88baeeeafa8c72a04988f41784b4f65ee6827ca4d17b9da1dc55526a7dd53bc5a891766731ac2d58819be58e57acba3571612986e4a7a63398a56a0b14bc6ffb9ee6e47b46ff6e7d1396e460c24948e3bed0e39962752bca1fdd71107ce7d90b4da75bab8b0b14728633957fb6160161fbb9ac8899724e6a133eb00da5e4e7cd0316890ae8d2ab6c2f29389c3c695a6df6ce2f02b0af6a05575df1d8c766702db186220b029ebfe60d360f5405420582fe3afeb30e83125854b83f0100c74d257956262f120dde12ffd0e7427eba51376d93afdea639cf2803105ec6c34a1acd08e87b24993143cc2088042bff5c4aa0e7a3ca653aea85ff94a06e2b583e36a22d55c4a9cfe88cacadd6e518fed6d0a331ff07bf44b2e9a1d4c1be7b8cd3ef60cae2bf795d6b56fefe8123e1f68e6e8b0383ee4206b48eb8d0850f007cbf7139068ad45950cb6b9d7da7a6344bc6d8315d15ac68c6956b3a3342880fbf0246a4a57b47d1d26403154274220520c2ef178200880aa3c25213698ce7f2d24a59412c215f5ab36457761370a2251b813d765d54ee2a80851e4f85df6b9c88f0bcf374966774c15e421df45de6e32fa3ac20b992654fe611f08b12fcf5578e6a672026df423b48c124c66e226f487eb0fdd02fd6a838b887c683990b9dc661c8b94a0e2210911f22b6080544607ed62b0673c86e3358bae2ace9dd3312862c1c57a8023d59f924a174cf47d101cc95513d3f5d578aa90529e78033125039998f1fb750e5d3b99399922c0d3ef81416acf24600c4d8b0f448a53ce4869e840878b002ac416389697f75d559b7773541d4d0b55aca06d9d7e4bd5db3425fae2e78fcc68fe858841065d4ad8b984d6f56df77f2e165b7c5618082a9c4eff30696bc04ee10bdeecbf1ed8dd98c7c53dc756f35369a59f719f51707cecce6fa431b299b45df483adeee13ecd61d390a5d68cb497784487efd8e8eaf38f20732e627d6d4f39a4e148535982a3ffacf4c2ff5be3cd60643a48d3375d0a0835dfef8ab83f61ae4f07cb5b4aac6b0a6653d5f45f3bcf918b0a848a634fb6a28f8059da6841a62b7a72866dc60d3ad250440d23caf228e1ccda6bff94177c5644af3158d3ef80a12f334c62a6040af740195b7757ec3879168793b74332e7f1efdbbf0f0d21c07528b202e7aee1e322d0465ffeda27d31eb1354d65d11c19dcf3d07028897a60fe277059aaf692d6e4b9297d7c735238a962f8a365c94ed318b476b6fa664860554b270211d554b7deae3be18c22fc7896cf9d28671c9b650712cd9a1ba0e9f211c351446d875ef1e7cbf83b05dac3706aeb36675da6cc259fd629a963838fb7f40b3bb9381d6ad7ef235c0061e822fc707886e0800330ebb33a35ae39287bfd3307da26259d0c26c4c3b0c5315a601a52e64c45f679afb41a3e88f03892af2e3d2ea3fb4e8a79ab39906077dc7154cc6533652f501023a3ed846ff398df2c0a961349abe267fdad65f23af8a8f9cb367cf4c4e643a0b6adea811737ccce9de9e0b6150a3f68abe3af74395e6aa15afb1b822c322ca6bb939d127627a83861fc27bfd5fa639f5e8b8e2f21f88aab66169c692f16c84bd85d81765c680e44da6462e0f1235c92daf730ad4a391d2f443463d2191259c2473512d1701fde581cffbde75722b223766036a018b7984ef40a2213189d479943b0a4a6d4944a643370c54ec390946d5ce1161e791d77bc6a9f2ff1c7063dc32bc0875b6295e7cc7272ae3c03f6ccc17ed7cf977af80212685eeddfe4dad032a880a8730f21f1f9bad72cb3281b170bd9443d2e0bd1dc6bff398f67e970fa1e74fbc5a2399a7f080116b56410f95fec2560216a1ce26742db0a1f092a442721ebd2945279936b1e9cea4ae7c0e4e74d4dac8b640a0464eb987d266c4b41bccaf6d2719b5fe62ebb83cd84b715ba3027c654aae1b025b62b9c5a8cd0c269127e09dc2fa4d59c795e576fbfc83d6f174767f1489d22164a52cac6794826cc9d80aa1f8d94cd7821eb2a924930fe005f7d4a782c63ff10b9e654e737d894fbd49990eee76b5e678db5b7ba6315b0082ea357d5aa5dd1fd7f877595c5a412fea9d09fe31022cff79650a26ec9099f4346cb2e077425baef0674a5ed34b9c966f3da4fbf59231e681313f61a5aaf4b95a489f62cef920da7dfc1ecd3694feeccf72147c4b59b955e87b29f619fcbd2af672654e9d113b70c3bfd7fb362be0950aa3c06fcaaf381fb6ca73caa5c13fe11a614bc54e2b45f55780e46fd056c3faa4f95e535dffe11610919194fa3daf764b8408f98d4c64e7b8a7795767176249e6d78799750e550c729b54ccb7ece5fe66cf77630a6f0f7b9dbe548b1cb21bf129f84a26403684514b1ea35c0cddb9b8b6a6a8e6124bde681359b2d5261cc949de48b598d72bd4d08105b597d77917d3d845bc8e3f3e4d8de10d803d08f4ab42ba9ff3c5bc02c89ee7a529fad3cc46508d54a55dd7eb213c5d10293cdc14b7423cc71acdbd7461ee000eb576643dc929a98c5c8af8f949f580376759b81f24819a4b8ec7d685364a7a8bf6dfd4f7ed7c969881684b1cf142f485c238d3c004d5e47c786c0a72283f7f0a158d569d5b69b5564d28dbb9a27730e40ffea10ab44fdaea1c3aa1bef757e8323db46ac899cca2d368ca1bf5a34829f5a84b6af2ef4842a23a74d217dbeb0f45cdf68c66814ece731de7a4c63fb576a953aa02bd93a70af21dd046786771205c785fb3bfef24497851cbf9e5f498fcd2e29fc591623a5ae510bd1b689da49a5b4ccf3e83c5b98429d4a8964100eeaae1daa7dade68653615b6e122f8edc8e11197536d8e90fb9b8585b3ea7511727d4636d189068fae5f9d3d251ba679f9c1cba8c2288426ee564e900be17b5df908c7066f0e1214fc78470c0ab97c0ad2824f8544c1f7a645db17e59ccea84cb83205d010140f28b196210f48b5cfe62d422072ef3781fdd29b73676282c5ac70c6c12e3ea69b314f0dbf2281db54f8896ab1b4d3785b844ba67846e1f097c0f97fdbdba6544ea40bf08390c92ea0716612893345d7df7b96b203ccea845fbe44f1aa7e41b56bcd51cc58edd253d3b33e234111ab612f154438987494f8e3c3079ae09204ac72e7e3533db71a89affa6efc1b44cd18ca07b1fac5021fcb23f0c056a281e34988e39cee64bb6321c945e2411bceb41b7ac965911cf2905b23a87cdb050496dbc4d222d4c5d32b7a835ff8f89132f67f8a807cfc9e6af569dafade84a076195177788abebc53ae5ad8c93082c51bab9d2ad45ea65b6d51644e1459bd8e5ac36ac026380a4043a25a3fe56bcdb3f0170bb3c1fb4d9ca8f762843fd3e42b33462aa8dbb169b438326aa9d14316f8ab0ccfc2c8fceb0dda4fdd34d84fde15e5dec19ab899376329caf0e67b46f36a767c9edf2d364f72f0f4c66df6d52ef83bcbff44a0ad026658c46cfcea149b7985c91611f881a1d3ff41d871b9d404c147ccfb00c09644508c65f8bf228030a3baacde97c0f89c5355fa578a7526d6e15478a78c8dbc2282eefbfdc327219e9007f3fb8fb0ee41ca69b7014460b97d473a1e19126565b015b23944277a9c081d124bd43f73c7b255736d43c950105b67013435a1da6909f2433ce40b97759d71fd66c782db1a9afbf52f113609ae9d4a0a0b06806be2745dc37166740bfaef1bbb62111c0d18c001d2f904b535239bdc531b49b910eba0b22c82896ab64b95241c2e6a27e8e1073604829708a0eae71c885ff46f7c0f1ac60d6d2c0095cc8bb398f8953cb51d2f2e1bff73126bfbc5b2e6355ccf759f8e09086219f6b0d8cdb4b66ba27fce739a5d87d4b60f83eb0015023aee28d5237397e1d3e39be418547d3b640a168771c17789b120b586e6368d422e4d5ec8113bdefc51ce05ee364807e33a7ef673f63c181514feae8bdb5ae5d5f101fff7cf3359e0ae3a1afae56a4fc187d74d591ee4a9cb55637a89faa21bfb2227c72bd93a664bef504879184feae219c982e546900611fa7832e220a977d6c7850e22f76751be3faf2989d56bd54def9b9caa9de0992824e324093e2d3f2390670fbe34fea6a5b02ef780b886e20141d907c74f6b52ff67392d327b804a549ab9ab476ec74fefacfe0d0145a44293dfcde0d587fec4f4345912f33d81be6afa364d7167411c7a8eb0910300bde907b54343128aa0ed7f490d0e9e662ae602444b48fd0531305f666cb7f490a9ed9f72509cd043fb199e7ebea1bc576a7d240ac9624f717a74012fb99de669b563490a4c947f38393020896844aab96e480e26d1f2044c80c7d9f6b3b209a936273072d9a59c7245a0ec3305d0c4133f10aa31f28c266513386dc7f84d79a85707810f01b7d107592d34a93a684ded88fc58f9268298793b17a7bbd83b3adcefd586ed7b74c4c2e942c32089f249572fb9a6659a2f11e6a6aee64823355d46e09e9fb44b4b414cf3ccef6803e60968bd2c952215366f92d494579b38558db21a2e9f3d5f4ce24557f5d0e721b8b721d0b0a3d29e75795527127f5c","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
