<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"71c562421d3872dea6e0fc029a557aeac4786a585eb5e5fa7c32c893ec40590e81bda3b2cfe5fd97c7db4b614e1861f1ea1cdd15c018278ed5f302ed9bd0360ac161ecc52d633c1d23d4ae289087ab3c4e1843b954bd0e632cdcf961d6f95ca9521c7b8fec2cbea3e205684f667779111c0630ac6b46a3717ba56a6c23ae8395328551a44a358de51da656bd07f75167df30d85706beb1e81673400975487e1c57ce94904a2589de3c96167a514f938c3c94423ba0413e4171fe20841ef151e2f1d4e7a0ae25938b923d91653658c25fa033652f6de7d3b78872939cb14b47388a26de4bbee420853b1b304aeec0b13be861c2e7ccf1b3d78512c06694e8081dd9186b07154f8798bbe8fd621af6f4353df82a645a6040871c3a8ce9ddb58d6f41712683a197489e63282c91f1b5ce04b7a727e755b4c6f777b778c9c7bae2cb7fc85c02ea35c3ab39167729e9981dd2df08716d6ed4f923d39bb2dbbeeff88a06d1faf92fcb0447068a7d2d03b565649e41f06e6108e0e04eb8c852de598b958d28df1cf329ad1eb9718410488be850923169b9ef3dfa98578e805bccf333cc458591f1bb7440b5bc2cd705f89171cd1f4e80f6203ebcae4aa4ccb0d25fa12f3536107e4c3a4306799837b8e9ddf973b868e4f7702d7f43b87361b9079b0bfc145b8512ca28714653e64056e1096ee4a86387886feae977c6e127b64bead5a37bea1378f77d4e25722a01672f2770cfb9a99fac79f697dbd9061b4c23a5b6aeb675f28ee7fa3eb74bd693a6e15befa4166beae9aa644894a6ffd3f75161f1805553012ddd371682018afbcd90f26474d9666e832c352f1906f79b73ff2061fd6a64a7d1129cf299745e48186315c01b7f2f4e94266aca9aa60f2308802f4feea2752bf64e3bf0d77c0de587ec6cf0a10bb4e826c6cea36844360683cecfa0c966028ecb72e965211352022f350ac4a38e918604f3fd49d31f12284df4d95dfd910b2008a4099c88191f4cfc312e3ecad7b896b8568124edd68ed2f2135181d93213e679ee9018658134c9bb2a73c66368b4f82caafd13258fee3d839c6e874201568ab5b7dafc59cd1e9b27ca7025b4398bce65b20ede2707fead5d9169091066796c7ce9961fb08bd0de469df6a191298da5edd0b5ed2407c406d13c3f1df57edaae0df10efb83f19bbdfedd4f8199193041ec2407e040a42793489cdca2eca5820b8a92b4949ac9fc4ffafdbd0972dc63a8458b26a0ac7c5e4e5bb95c0117752ab4bc9255c2118bedf35943c7068d2169a611f52223fb883e7f06c82eb09c57b25f8d25855caaa1ce041516975d4448831b80c58da23e8b80ea696e2ecc6d2c24d4468a6c44a7b5e1cefed75a893c5999fc34f62214ed6930a54058ed9cb2ae6879bcb7ff15b9ce8cf27aa44013031915c293d5da5eb03f2926778892a5590b293d1bbe850ad32f941dbaa106b683bb27ff7178c2c147510819d50435ce43d01f543c7507cb922fd5b291c23dc4d22279d8c13a7eb0acaa8e39330b10e8870d78de40b03e1ce9cb0cc27750dfe9c9688d163e4e39acf2165089d3ce3bf720928cfe073113b56234be4a435d737f3d2c8f8d342d306dfaf40510eee12a440116ebac7ef20a393161ad7e18807a8eafb2bc4a44231b3570639921a759f615907c3a0b1c9a34c55124d5364cfb0e047d88e1c572d1b0a6b5f16a2fc081c50b246dffd7527ed85e9fbbe8a55d2024d5a6bc68bd95bacf4da8e1e03c0500e05e707c31240c9eca5b7bdf8c0fc1559adae221e0543b7ea009b8016c3d1466339c7b366f065b2fc6835a8deb5d8773b0a11247b15da9fa6715419bf16340b8b55f49e3a59d51b6c502669f4d9aae2c5ad983d9ea94be99b9f2fe6645312203e0b585dbde2deba05d6127545b5ebbb16e31b49da751677dadd7ec1e6bce24bfd9d8882aaa51f90aa0a629d90f5962dca1ec07ee459dac200724f8c73ebbc12e058eaee9cce82aef19b671e0f9e43dcb9ed1d38548db039dce4ce67b7ada0c5e5fd1196b2a7b2cde111da65e76b80d7880dabd2a41c02d8eecfd5e2fd187f81f96e7b09a642387fed8b99b1786ed0cc3297f74f7dbe929c50ffb473360a564d2e15bf6ef788a3d33071378793d27d6b1c8514f00db7619eedd4ec04b67b10ef5a807d8c5b63132387cc0ee29ce2be595c1a8521037d22d117cb16b0e46e8fd9df0f984b5d503f4ba209240991754a8415b5c40a2ad40a86421ae87c96c42cdbf8a785add7d1bc78cfb33760402c7991e1a8c5fef98839bfa68d0f930a7d5180e46ca3b4082d7b02f0d74fad70c6566bb7ddeabbbe66e106c1f0e9d9be1134fce5cad6fc2ed18700593f53ef8148ff18686ac02420c302d63f1c3735a1b6996cef59f98234d2befc06b4acd7b58549a7714e59e586c0cbe393240b4589de0b1a76316b15e94348bb52a87ea23afffe9e776f2eae61628208107816f64240dd30485286faf6e9123f7cd06fdfbdb1aa62352a25c51d35aea36bc69eee74152341cbd6e85d9d2c3696bbecf32e1e2a8b549bcb10935888dec23384d78ace784fbc50f21581ed30ed6431648ea36b6d6defa5d767d4c534e2a8e1e7f364243b932499d53a754acd5684c804cb2f421dc882a5e4cf1dd5db191f3b9b9e9cc033b5f965c4c0905b17fa825b3d290e262e5150357b28781325e781cb6cd4757d3a6a53e3c87cbdd0109ce5c05b4eab70428ce9d3040dec0f853cc985bba45d6cf4dad53759687d47dad2baa7fa3075217491792d0f60a69f1a926984b2a9a19c92b61913bd24736f38f3ac123ba91eaf2982c6c388e13b0725f42d1bd90f55aecf3ee2832c4694d3fbb8fb7687bff3563816ab9ac3e10ade6d6b4f281b94f6b24ca10ab6a8aaf2cdcffe6109133406b442df6bf38b9d151497214544d3fa1148e5b875ea085a09fd1bc8bdabef876f27ac9981411dbf9b91448d1a9ce3569879464e13768f30a7f0ab342c94bb5089c1e8c9bb1cf410c41a83bcf9d9996a4ed1f60b72477a65179706a52c0c6b512f6e46592b970d13fdabca6cf1db23c2d6d7ae62dcb67a85243db6d222d40d9aea580a44a961b5bfe9cfcc906f2cd99994c3c935d440fc8c9183a69af9bf7689e9562dc3afa0ff521963d65e256c2aea74886a949dc2926e5bb70f347af0bc82ba672cff5f1bbc921b341910e0ce76cf5c9e1a37643d4a545b7da711b4b8b6876049de9978c3390d89fa2587f1a05b4c856b7dd130969c9d6b0e95d4b3e223d3e1dbf392a0f6b257065c752952f5a493f792e8cd26c5933e2ca7712387d5b0b0141c211f6e63196a05c106e555fe9331976bbf4d9a8e3aac2ab5bb77c0045e89ffccd158f241f08f89d676ffb0425914ceb7e339869fec12fc9ba06a10fd2933d5acf832bec062add0764336881941bb0a2342fc82738eeaf399b782bd59b0c3d462ad73bbd018c01fee458402febb599d7cd268a4efbdd42c67a82dc85cb61e3e8a3eea0017f1e8cb3c91bee2b26e22853246d9f1d1f1465c816a7e4a3cf2f4e1276bf73a4213c5b800780d646e26d32efd3cf9176fcded15bee6403f0319aebf11e6a3c6a01152e355c44125f58e3c1fb48037c568b833ba9707c40c3c2c2d314285817acd7669977d311a4fa35f78396ac0c688e153da1993addaa15e0c0dee49747b2aefaf88e74af17183b247400277bc95dca2c10a1cb2f102fb1db1bd4b481e525efda3e474e121fa336b697c7f20840f20109b844d47baf098f6498a25b2f3509a580af4f4a7284903a819abb6c01ace7e3fa2c99248eef94c1e6e66d07bfd4a7cf89dee46bc0194186fc05558b22f5318147027b4493296125644347feadefc2326122a4aa33820b4821e7619fbbcbddce5efbd3eea34246646698f1716788c5b7ca1e65478101d9deb6b234c3e6f65dfc9488a579c73c4f4deb412ee03e74a674b18ba409c5e596aa0870cfd581d84b103b4f61f5875f46357df0a578cdf9898628f14321fa4ac46cf93a9801567e8d0589f5a53bfc5ca6844ac1abce57a7b45fbeaa23005efa11a907940f09972810ca4e6996d6a6598a139774862f25d1a2ab8cfe1b9195e342e26b32d0693a4f62947a2617b05ade2c5d3834df6edfd72eefe55821578a932c4389150a0e34a8f60f169a5c99ac99ce1c65663e36b58eda6470a56f56577f9acbf8363082a113dc08fdae321639d6578482ec099659529993d47a7639185a085fa2f89f98ea32e624f439263115e5eaf322a4c3748637a877c500659f4b68eed7b21d0c35acadd6ed8cb417ace46cf305020fe2641ca8eac75d9cbdb672e3310c3da890bc9888617ef66617d484a7b812621e9da552e63fde3c57e975179e213eeedf57fd5930e105b15ce03c862f09279985bceeafc7e21e0974306d4f86bc22e2528eedb75aa50ab5455ebfe618ed141f105d4a61923491e9a2a4cbd13785edd7c715e106778765642e0026234d6e0c48874212f36e08dd4eecb47d0c5b5273bb6667bcd81284a5b6434e97851c555826e24e4db04839e0bee2cfa17b623477b34bec9bc34dfb9a9def8727e31a462433f2c3dbe86fc7f4297e025ad25153f0710d2eaaee22237f9da930f499a9f53cd2939a766f6f94ba305fae72918f79138b04c57d3e41a2154285324f94cc025887e2f65460eca6f73fcc93ca06a3eded8d1dda53433efd636eafb3a14bfa7f778e1691b3d08151d4dacceb17429d68b22618c3170fb46cbe6f3527f991f480573a404fbc858cfb52f154da1b011465f22faf6e043df59cb14e59c9df30b6674fad8df1e958979e97545b715cc62950331cc8fd97a4414db43d869f0443dcc2443088476b7c0e5863138a74058aa71e14f476a977874a978dbc699e84853887c8fe2edd6fce80ff32d0a803d3ef72aedbbe583a608574f68005f9cb70d0496aef258d29184ded1b90677a1ff2a924c80da73054907513ab9fb9f696f2dc40a4adf0065626f07cda102b40585b08a32369606296e743bec9073d994b5d167e9736502b9fd827ebf76be3a296ac6eb3fcd2145fea230f5d861c7f7559d2072ed2136fcc7d233bb9f1f393a4a58b5f0296b5861de0613111f5d213659c7ed56254917ed9c3387e3d1147897682f034a953426e618ee9927d5da162640d6a44a3c22ba4b1e96219114205bbfa17e96791fb2a3e539ab41bce87bbb70c11716973a1b01a6a5f625c5c61f4928d688ebd5fcf645ab1198e75f64106a2a24154c8f27b605b446a43d23319bb7eff1bf4e8df6faa41361f4637d301779f0b410a3f7d28e20970bb776844626277a2099b92b908001476513ed7ebc583409243c76db6386fe805aa4efb60b11f22015de5d400ed3eeff717a984d807810c37e02cae8d0a3292675759a89abfe48dc30a6597d800c93323a7d0d12417a9df69daf839b21c7d81557abbf4058a2ce4af1c68841ad73c2b2b44cccacbf6d13c4c17eeccf4befeefe9d23c93c0a0529d1d7973818f85c77cd946d5d3461ae7ef514ce6138841fe7b03973dbad2d2e6c5c86d33903aea17386459eeb302cca2811ca4d8c15840a05904ece829596b36c16d8346a45a5c71846c3b24d4bea74e65ed4c2e6b7bee466ef803d4e03e467032c055ee12d508848b0c655b5f6e813c5022236e25d03128c9ea4fa96bdf869507e5b9ce48fdc1c2305d81adcb60b8bb4c7d57dab07dd9581267bff81285186f79bcf0aaad4a62cac11c286c4345ea25a66408b27f190548af646255df98a3c40e0b4a5130ddb09af93b3e02c38c96c7bd5c29f344a20eb23ca268c877fa995304c2819800ab33fec915051a267aa757dbfa5da1d785b8481aa4ca7874b23f5bb2ea0202ee9169ad912d83cd76088b843f6fef1cd3045ba030f4882866d7da8282ba27c6354ab5e3b7a834e221f0e6a25647859f181d5bbb560b86eb130ee9bd09afff1019f45f0a57748d72a876fba74a0902f160e6a5bbb1dd946f9a3ba86bda4a710a3c4bbaa1d78c3527024079feb5c3100dd48a9a1e50be1420adcf8f88002a96db0833df4b1479619c04d39e8601a3a9a178711b724a63545e99fc544dfa83ddaa0341fc71179a6b4e08577e872cf1b6d3e8141e08e704d0ff9a513a4bb1c3ed9cdeb8aa93c59c81c1774f2fbe3c8a5a5cbff71e5cc5e7e7198ae1d44b2575bb0ecadddc253a47278b1893606cd4fbf52e9b58bb64792e4682933d3ecd7773aceee46096550d4ba1293cf3d71993086de9916b146aa3292cda3773a3cf48daae9ad5e65e01e0419827addc3d71237e05ee02ebb9798223cdc6b5c8af1e128e3a807b2a2b716336faf9233135e48aa2eee523be86c7030d925f9bbbb126f43aa32385d706b7f6900a1707cea7e0f1e878770d9787539bb8621e7ba864bec239e3a0a2f2a2d83ce07ef818f8a680ad27aed8ea6a6c472481b7fcdf83bd36535de53001fa4dc2b155efa447ac70c70910771ae4fd68580bffddf31b397f4c65a96a60c1481135d55ed8391c010970b527c65c2733fd43ed6f59ab83d03a46dc440fb86c4a5ea75ae294be9c3324c685c769f89b4c8d5c46f3e13e491b3bebaf7ceb8c0e2bd9f1e15d3dd49ea35d36e6abed6eb524e8606cafe923ac632ce47d2c106514008e3ccea4531971e271a3234fbc193302aa1d11befad021b71eae2bf05dea4c7776c683ec2cd19af1940812bfdbf0c25e74305164f0b7a77968af5d95c08b876f9a1773ecfedc5b34256fc36e1325048937cc41abab4040769be1f210f6c11ab568c7195da655b3980d90bc35ad1a361105cb4675c14c95fdf9fca95ea22b4d9a6678f6761cdc290b8f7e31b0b6b7b3de55f013ad287b43eef12578ba4328081c644aeca48fa98f51ec4d53316298f5be03e6e75a99f1a8218f4740413d1d667badb3ec1e0fdfa27b80a9ee02e6508e850f0f6cb68fd1f1757bbaff0be8e8635569d5738dea30961627e6644aea6636df006d81fbafba8dd8f23a03488f3527ab336e9945028e46c66c9f3287e7df529baeab2ed8d6c6044e5f1d5d26885f0db4d3100dbe78c1707ca25dbbcdd3cd69fcdbd85dd1c1f1418a0d7b30aba2719de1a7a1d3622dcd98ed2db2af0c8b586b104a92e2301262b2081572a78e6204002938fe5d74db330ac191ea0c4e16e70cef2263a4b2e2127c7fa669fa9289ded3342e68cf01ee89fd6903cc3243c0508e664e5b4310d0d7658a81fab1f6d13cf74793b3ab4b9900664f8d66b14da644dc3e3dea8752052f95929a4a92f9ec7ad6505c6088f1f15681d1fd5ae459fbcf8bdcff2c7db92d791cc6357093e51cb5c46a72761e9f2be6c34236ee390e0317c085ddf08ffecf0c1e1f5849808886506ba8342fd2dc5b38e1b8d6b4a328b22a1af691a8ec88df4583f4e99aac0c95be3c65bdb4604cb930c3fcc21503ce5704231df96b0d74839356cb215111018e45c3131eb668afb3cb9968ad6adbf70aa88aef24141d7f9a2820f4a57ac1eb167a8972c8d21963ec3cd62b1b574f1b252f6f63fe4baa1aeb935706e5043739dab26b8affbbccc695b9b811704172dd2f5c7d1c733fc40647916276e92211d94829c15f0f586ce6cb7c798d0adfaf76ef5ff10e3df90c3f92350abbfd8f8752364212280a66acc52f18b1bc9041021d7f810923f05c9ffcac03231031cbb34c2436f244d9ed23e4dbb43857dc32cb07d50e242b97a4207d13f7e89657c2ebb8f6140fa76b55a3d636031760589efc506ef903d3c2a24a26b7e4fbe718c2c7f3c12851e8224e53d1b0a03503c1b38c253a254d7b88d2c07ed5dc12436f55ba8413b8da0b4157dc00b36db85300d9b18d950415fc939c9c2f3219c34db2d1ac78dbd9bad677a34a20e521b71d1774575a540fa9ed178424afd01ac0ebd2bec1e69fc1dc84219d7ce4979059e26023a9dd854842c070f42abdf4fd8281efdd39958295d4f23f65a93a2a84bc3cc9fa867a06790187ca8779d2fc8580761440a54d499a8ed5dc10e63621605d4b1e30e20ff9f686efd453cef2e163dab863113fdcc01a434e30919f57a4172cf580d303241fad6c70c00e27e9686fd56acc36dc16fcc02623ea105b9886c64a5e39f2e12b99e7fa047eba2d898719198722d2dc20c77f11c71d7dda199e46d79b4131b53a31f769b9b32ebe8e0aa37941d3cca0561982767b05013ea48321da85bf5319bfb84738f5313ca743d8395fbde5eeaead0e970cacc339ccd6508eb0a89426162f554af1c9cfd9f76423bee29de09ce4510d9e1c3be9743ee663cb2e2c19c86aa7962b6574c29ef584263f2ee2f671998cbe66fdb0065cb878a608dc3d3c678cdb3ec7c44289edf0534bf0c647a6497bebb43962b6ea5a1f70d2459bce10264e2fae597c354af8d5ad9f5a826295047ade7829036bafb6eeec39076e143d0f29c390ef651f172563ef00e5a062e9526c735d95272895a266b94a40e1669652cf876e01985855c060576a3132281a3789a15c6fc7245992b606e57fd944f6a0b90f7ac4764400dd1beccc0c98386fa069e3c2cf7b2c65992f69b7e8d7d9251e3562fa5f531d79b265a07a26c0180a981a8f49b9a27b17b80a12ce576085d4fb8ee008159cd7c604b0bf703e87cdb1a57a648a30f108c54a2e59d4f28af1cb49fa43aa4bd64407ed4c378f18b5ea2ff15a25c2c1364f55d302a9c6d7f4a4dc6ade37a38ca8787ecc4ec2acd8d1280f6baca2ec56d07444db6f0d4c3b943538465ee30846202cff9aa64f669822156762a42b021c82308a5125e7f47d5b223cfcda23c26d9331d045c376cee404cdda81a67793d1e8b4b99e9426195ad22a43ca83958bab9f757e2a3c70bef8eb071ee034e6b2411f14c3f63a59f9da795064f12db8be2c025fc2d5dc7d3b72bf3fd7c6d5c39738c03ca75cad838f9401bae67cbbe22f28881289f6b808dcd28a717867a4812ed699a16620a51dde4e861053a1647feb03028db0e6c30ee7273c4809fe2141f84ec61206cbe089dd95e046785f841100bfa68c21965876012297cb5c09b2e9b071567b2b1967fc8f2292723c830ab6f5d704d691b7e0f2b1384b5be6e1117d599f2377694388ca82ee1edffab939eab3cf176e84d2f377e0299be679f8be26b49d90cb6fe977cba48ff607ae3c6c718d046fcf282dceb36c2e81e18c0408f6ba8cd9ec84b1d5addf04a05ff511e6fddd7c6d743d39af1c1e393d6654c1a3477a181af72431a8e697bec7d63703a30b94d90ed2c199612225b6400c585a13a7c6d9c21816619e86d601617c6ba8ce8000576e497d6fa1df74b75af04f5af08fbe975879f52d5c0e2827c921c1b38e5bf9d4030cc882f46caa875758f0c22f864b3e2abfe999c77f4f34b65ba4d969619a1e0717a8997c2d31811e7cbfc46b2f1c4c45a2a40bc3adb7385b03b7faf40203e5bdbbfea89d5d712ce3ba9352d9c9693bbdccad79c0cfefa2d1aa5551e1b4ce7e337f0696892517fcb9591b60408faccf19856df988b80fc95f777489f43454cc9a5d0e802a310b3336c75fbc8ebffa8e8e70cdb031bbf63a47738fbf4f35365ec6711f2ea5e79efd97a82157d95741bc5e4bb0cf632ebb91d16580d9fac758029abff987148e80851087ffc2a2471f42038c566c27e93ce5e6897fc2c81d645679763d5d4e6ddf7a3c07c42ef23ffdca831b15f22e9f6aed1c18c2acf40d4c4acd79881fe5a4546faaaa25b82c128ef7cb15a68d7740b4cc1292e5512e3701f5681de4799e87b050f53b65bcdcc5be9932ee4f9495ad9b080438db193a2dcd97e7f69a89a49f68d13fbfc05a5df5ce23fd51e0bf977063411c858bd1d14c51b028062d9760f07c31922e0c812283247c2ded7cc1f30c14db40f668f854517c6872e7a9bd3f0763ff58dc17115a840bebe01a3671d4496d6210cdcfffced5561ef66d6016f5cbbb27e9e0525636cd86dc143e3860536d8c07376c2cdecb759f8704c110d925b925ba09beaac31f96a6497cb127aa2fa8d036b1b23f6a956bcb9a9d359e76f41c2ee576a041392a58aa3ff97e80676736cc9c021d7f08ce239f4bd5e40cc91dddcf620f57979deab1f4a643357ecbfb63cf780504ca7671f5b60b7268d57d26d04f5b36163f4474aa8eedcf2f72a0ea4abe3cde60710bbfb6110f0f4fdf732fac6dabed44cc75028bb4b8405fa63f7042ba18057be9fb4bd6e3232542c287b6be2b5b24b084680d5a6314e709d61c1e366ba88332dc16ff18ab4bbdcc5a802c37eec634161cfe80708fee1552853b97364ccb8b61bbaddbceea6de28fcb246a13e0a2316472caef4dc677fec039c7a9dff43abc79fc45f37d5b5dd04317e1f448aa67c8d5692d5a0e0f81d91329f55e2e618da322a7199f01e6063a8e5a4c8eb77eecf7615f43607bca9f01a0f352ff7196324eaee638712f6c8bf2c66a0958d970249bc433dd37e2d99c2c75bfa7755386373e717a516d3bcb70d155ec46aca877a38b6c8a0730e3c5ad4d3dcf423943442cf0933a75446bfb32773dc660a04783b813c1a4b14fcc94f22c74998ca8fbaf4acda87866dfe5c8d7c202e7d7ad0a7345b411926423339eace2149e84ebe2daecd90e89e26d9c668613169a999969ca5e630f9d6f7f16dbff79f04e98b43dcc20caba7adf4cfa50906a985026163a5fc1c48e3ccc53be361cecbfac3a11de750d4b661ddbef241a5899c8defa6fda1ebabfde5f1cc973b46e3ebdf21af956f27bfe58b4d24143747a86e98622727eece611f43f49a11dc9003773048de0862ae670b93cab449a0032264b2d78d3e64cab246a1a3cbb1126ec7cc8f9efc807ecce0b5f76920bcc2ae0d3168b455f65cf68802fc041242dc6eec38bc088f06766eb2c0e20a54719edd39ba97105678a292014d88b505bc4ec87fa4e49c8e4cdc941d5b87a3a15ff46091f6dc923c34fc193d6a7b88add517083a014c9ccc125e2cd72cf4872e61cbef77c56621a6fd427c16f2b5661c986ab71087f4a540027e5f83f0d63f29d11eba898d62a3177c98495f8f1a63b792018a9103695e94dfd4d47b06c1813a4bbcb25987b665989b38e15d154e5697947451147628f80c42b178f696cb704562ec522918639db80fa989f9a09c11663005c96d62f3d4778a10b891a3269e6915cf4642f5e42e6657090c15262bdfb2e84b6e82e26354b7a8c16eb299d1f8bfd921e3d7370e5098010a6c2a02d72d10bd60d3206e1442dc74bc7c9a725e9b2c8f53e6e547e7a226d2205f4c43c57bc21ccd0be83c7fce056e233a0fbbc71959acabb16a21d826f9a22fa7f25cee25036562f398fc80cb81fa212b4618d2877a3521bac4c175dbccc371c959f5066158d32418897b7b22511b319c541c1d11288e0e52f8ad42500dfe6228ef38d9fff962afb09ebcc559d378b3a5b77996cc7d8467bfcacf5db2f302d937a64e494ff726659ce2b65119e38fb6a493f782d272993b795c2ed88786387023c392bdba1f95255b4675758ba36128513bc754887c80d1b48199a6fb55a7c43259f0aaf25ecf7d7daa3ac60d0822b7c3a75d4d28226585a0081dfd44a5c70e19a4c21f30504224e378a1afdaa2e1408c9a695533884e0d8bc1eb7f6f570a36222fea4f8bbca961a4b15ae8c436a5b487bd5f0c856e4e4583d28a449f8beab13c1841a81ebd663310ab51f79b290abca229bffde1dbe253e09fdce7d29cadd2106a93563b155e046386362ccefb3eeaa389fef16ee42ca164a131c963119a6a9f51fb4065e712e3977494c3ee002a3fb83b4aca4e0b2bdb55a9e6f15ef8dd4bc54f444d3506d27de7373280dd09d2f02c063458f4341a527d8c361f3a6f1f02ecb3ba10a3f2d41f3dcdd6450c01516819b317fa0304c84e16572c99adc56f99da8bede2f365a711b94f397dc4696e53d413ccd408cc8c01b959afad61128801addd4caa169a1df7b34a9d5573e840b916323e3b943d360aa4fde8966efe835e496f71c9ec4a1016a33ec28ef6a187d03743496d542f62d33870903e6bcd179451022a613aa903e7b9ef66e9879e7294f4608888e03007d18dcfaa3be6b650a41ad26d61bb9ed84541a825978a10e37830f1b6317c09fc55f906b22a533859c23cba6151c8ae18f39e69b6cd3023d4d78c80864c6b2490b175023ce89b6a3132c9c276ad9cf964333ec267d82b92dc8a639c3a3fc1b60c433d07f021d154ba1ba4f71d51a14c8d266c6190b9a4cf3f2f955f4be642315c027c6386ba1f1275ec72d7dd54e21d6ae5f9890646124abb6b3824d5a7b0f6dcf52aa5ebbf45df20d8f92c695f09bba267a4df2abc07fa615ac31d2df2b519a96542d02c21e1e28e26a433e16b4d390c6474f4e2dabcb11c70f241878e731cf83054050694352377b12e6192f3c114d17c56143162b046853d982a229108abef0b603f911b5323f3fe58d6761540b3d76d275c02dd6bb468cc25ebf8b7f00d2241040ab88e6d15d5e6a5f8df9a5f0d83346db6706fc8f6919722819fdfe32e04ee7d337e9f6cc40be8ddfa4557201c6c4182c4b385a74ad21d51206d50b8f7c381f5f304fe523ecfc121e5f68da97aefa15b87ad0cfd3fdc29cce2a443614eec08600110a79f9b115fd1fdae065b60d6ff528d10be36d15bf73e7b9a075ed0b8206c8e27b5d735a3330ae0b6190dfe08042941c1c5a1f6876f8852cf617f664b6a8cbf60dde6944ca67f21186c16b5c85f06ea9185147f4404ed52c361e0319915beece4c08312f03b9d1d77cd19b3be1a5332e9132511abc9accf793b5e0dd866e7670c0dcf3954964c07fcb8b68d00fc0769e80305c209f046f937f5eb7858d537559ca88345eff9b591b322c8044ebc19e67982e666222b34f81ba927db21de39496f389f36d72582fd83999be7bad8d13fcc995aa342d75bc139d4f0961343acd3dc04900ae5855c4d184e5d64888ecf28e1300ee2d8ee92293705e713f9958da75e6928d8437fabb70ffb3531c5869bb510d4e1cc13e3e788b060393d19328d6e37ed77954826176a9702ebd34d1961797bbaed34174b72d046bd502990a029fb94d4138f7cbfdb6e97305f8947156d98858d67e143c598d788f31a7aa017b947bc7309beb39e77e6bf1e566df8f82d642aa4c3dd0604eafd7395102f6bf694288afe4eb0bc8aa95e033da55052a9a6ce23fd68d9c6a9acb22bbf18faabcb43edddca3e950e45d46aa949678f209cd0b4457f603cfb6768ccc1c64dd2f6925332b100904ee9c706777989d8fff6f6f30010067eff12a5a377dc42889135a9c317a9d5b9733290f10e3d2a254894e01cf5b520a04aab519c075114dc3d81bc72645738e02ebfdc5b44839f509a5824a8f9e866f6f26a938695940ef187eb438fd3d80201721a3da5eda87f64a6e2c3540598c77abac122c2d459128760f6b25817013e72297048200b1fdf9ea96f50b568deef436cede415b3cbb463231044adf6f7ec1b2451d5b8cb43d27a92ecdedcf8a7fe416a2f3004217f44a461ad3e5921289289286b5f1c552fb79ac9b5f1d503dfcbedf840f816d1ca0dfa62eb9b1b241b0ca52506c85f25cce75f9dcf15c1593b85548415be707c1175ceed42413fb154cb3322ec526aade738a3730d6b511f11ac4b290a7e196a2fa14e57b4c31f4b8c136c67fddd60015e77b638f8c1e68356a714f38bcd4c229f0bfda09c0706f8f835208b326c0c7cfbd1fa31f243f490393a9e44127e2fb2c84afb1679263e480aef96fed9c9119cd4107e75cb6bbde58a582dc4adad44ae6b2358c357383ab3f4dfda4eb7abc1d34daec9ac423598df189ee018a8e43593cc377baa09f22d33708a0a2e41f0772c6b729a3f7e25816b6fc7e28713bd7c4d2782b3f0f82c9c46c3ee616ec7386686fd934a87db8745277b471e8327b25f1228c30c22f45596f291c8f0c07b2e75c3c3711c2db1525a5543d910ab6b51ff89619b5fce39d409167ea1b15ec2718aef3a8b9f0bbf4efaea75ce82814228377d10d52cfe2207088e193619ab3f64d59fc813e070dce53f0c8e0078c77ed88a8ae932c6d7c95a94dcceb72667c81fa088a2a165a3720c359638401fd80c6b2f0d0394ee6edf0aa7a6efa8b73236c9ad8a297c0fdf2eedcc2f3b5b47a5c5bb2736fd2a129e72c0c473350b58a4c8f1185db414e51d34eb7","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
