<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"66ad18c0e496f9fa9cc0b5da14962bf6e0e7e38ffa0cc4da4d04d5f1f356dd1a92afebdae336fbc4153602f189f244773524f997ef93da7dceca8f8d8b2144631242d2a3efe5ea7a6823849a915d674a37009f39b7de4eb3d6ba14fec989d6521fba4c8097381e234cd3a7b8c24d4f1ccb57a74d5f8ad90af3dddb86dab08f1569ec238344e165ea39447791a16146c641824c9a8a2974ef452922f5dcd64519c308e153fdef865a0d0b066d1bf2dc8e8b95976481853c2f0c4c5bd85be0725c32d2375eef0902e6d755c1f52c079fc076984e7c682b1399cbbbe4e764b166f458ec7c666069e363de10d7938b89d55f48bd06824b0a1c0bfb659a98f5c9c198e0f43b13974e6d3a247cdf3b3cf704ab73b4fefba1ef07d7d5fdcdecf9a53f422f6a79ce0168a24094abef2ad33f35022f424fd9801a903b9c13154871cef7ff04c5b3aadd725e767e3b1920f04a6024667d7225eb95f1a16a494bfc09bf7cb03c49d2067353863f8c6b74f511931acd8bc58501f751209554fcdd3253a30fd48a20ce233db8f1c17e053f267b0f6f7b442beaad10f7ca4ff78116607c8b0b96a4fefa39b311e9eb4f361d90b3d13fef00894bf9cfe037da7d4614d62f58565f208d7ab67b846e08f5ad5cc4c64774e3ed594496cae469f2af93664ac13ec54c30f00b80fdda10760569f23a717416483c9f71aae67631827dea343854779e2bc0df1e9aadafb3e15cef3397ed5176c96d254ae50978b1f771ca4f97f950d27f7ec4e97d0a449771177a29e23608e28c213e966412f60e4f828ab47691653e6d11040989675bea1eeccce20e143005e053b490f81aa0d36253e5a68da15753211d9c1a2fe74c10cd1ae243ead09ecbd8d5696d74ccc8ef94669f7d7dfcad6bbacc3957b8454bad9e56cc877a79020e8a5545f7058c0e982dbd19f9cc74003fb6e9b028576005d6a69e65aafbcb064135775087da30fb01f50a1cf857620173d9e1027a074892b84fc8c06c024d44c9dc5d7ad950f3ee111eb4657b82e6258e885767536633c2248e4e07f90c7e46cb07edfd139832ecfa591a33a449306e4c01724a5f1fc3f8956256ca5bea824d704a1e3d552e1a8dbf836bfa5aaf1ebaf7fcb5b8abc00ef581bee0dbdd064a12c7c1ef7af52c29f8468fbf1b9b5fc6289b1e8d2e389a007ccf3487627b6d4bafbae5f649316402ece7feaae1d371daafc3a1c8961bd0313191fd6e747fc231211588dba6b85a5b02cf6362f276aee7cec8cc552c44088818a02c9b629fb948a24d6b03fab461da25faa2c598c45da4093f803c6f433130d9e1a3ccfc217f48dc2ffbdd97f7028a79bc7b8d7e4e3e33e39f2c3d7bbe198489bd98ca562a2ae6048d0329da738442b5279843b23c6bb022812ed0badf15b612e9f443983aea051a5e0d31567a4d094b42f44c81827b166002dc2bdd96ac139757cc25383fe08ffb76f382b89150175eab1a7cfb348eee1d779a6247a6ecdb250c838b1d008a44ec0a6e99341837a63972b687b477037ce85d155af31a505b8bd48b64a4685e29b8cf9363c86dbd15928a5d1e78f0d79f0a5be0a033dc0aa062aa56cd81b1d409ab651b0d49d352ae09615e629b98b87d7312498c516175c88b850ad874066fbeee9240938da4c2f700543c82ee3ef25d5a0e30446f269f9ea41d393ca69677e819c07bb1a0607e31ab9d23b88d0f00a1f8746e382de5bba7827914c831cbc76288a3fe17a2a16515c634a02df924ea5abb1ff93b5a6425b4a29f5d37ff29f1020aa36791e4cdea74a1a877861a8fe458b28e01419c45666754b6261fee2ed2a5537cdd0c77866ec1667d7991a19a1fc1dbb4a441368fac0bbccf00a7fee01ef6d27516050a9ed689c96c7afc7169b99fc4079f63d8036c902a178a172d05aaee0049a6ae348760ff7ed3f80b4f8d4b91e870a9e61278690a2e54a789629fd1fff6a19b6b604ac9fa41f5a400d3f9b4efdbf058085d2235f718d8ec5a0d0e80692548087e10ba269c5a3a03261a02ec549fed37c0f68fd6e11c3872a027a125e1e4da6d9e875753b467e80521e445e3ab8f4af736b49c72f08f4f2c95fb916fc5fe4452fd60c654fa1b1061e507514b2a224f3885c63e4792fbc682afad6c6e1c1a8ffbcf07078b574417c57f4c749e559bc88f1d1f21979cd3a21f1c25edfaf39aeb256179a74dc4142fcb3569256c238a22820d41bcc86260d82ab7e841da3ce0af957d2829390566b97381a4bb9748bb7be0fb6ff7374c14acc00acac8353f344aa0ca0db1dc444bf2b0841c4808f7d043167358583a3b0523fe9f972b989761210ab2a019aa0a60ac9ac391143054373981947288cb12156683bb4c102d70b979de15283384435ec34ab6d3ba8125e236059945f7bd7891fe3abea20d5570400bcd1d21b4f2ef1c48ffdce63ccfef7224c031c025e192345e5535d1b89cf15ea5e0b3b0d1fa9ac882ce0e403d647f320085a7db25c556c76b11382690e2a3719008c5c2493ca801b9ab8c4ea1f957e6e81ae861a8ee1ddb55232fc552362bd1fa4ef0af372eff0eecda0d01eb5343b24cb40052bb11b11671bbbeedb29c6035c06198c66cf5db51132f6bbb4333ef3236a6f762dd6ce40b6a06536df8214befe0df01a2f58c1357e2e18525d5678944c020d2db8ec1effdc43bc1a53047fa373342810ab86d318663acedb867c375beeb955fbb69cd86f688d6ba87d12f87fd1f4ac283140ea4c2c021f097bf2b88da7c60f113d527ef31150300362f1e4d3431073a10ad5c33c37cb1b75f0b750995e1dbb375127396b6ae64b60b79130d07f5dd2326efd26e7020074e90f0b8aa09755af8bd7a722f5b314760a3930035dbeacfae1e0007b34a352347152fd4ff997bc93a990733682fcfbc7e624da5f1c435299444c252ca2d65d1a14a77e92e5ff05875598feea74f25e8a348d91814916a82a2337d9e5721e75f7ab1ad3ea3cb29f67c7a2a17f958d3d5e5851607751c9ec3a87b1a95ec201c0111ddbdaa5cc1c4477b8d718464013297664bd2283fb1f6db371af3a06a49032ad818e1ae4ca5e1288064ca9e32d5d75a0c0505ab7763c870a8d35115e6764952de7cef1c459f9776d9067da8130882976810ad9b41496b30eb3ef046f2d0a918f99c31def0e92e329f0cf61ebe42058681369bf99f240317147eb6d8c913eb90d7d5c53968ae059ded0ea7325a2b70cdc0990b95339b7209ff45f7e2971daad59c2a2cd14213eecc77ef4f85fcabc58cd0bc7d2c380bdbea400d83b5901899822f0bb2eb97c1aa9e89a5ce0e65aec920f3d527b9a74187465a24d72324e408b8cfd77c5faf2ebadf415231eb382ecbb3bc1fcdd109a51df332924b495c1dfdf322d80f40ec56d83dc6d56564a24221683d4d6d4a6ca63e696a8a8978fe7c5e9425833bfa089ea24a7b4277d0734fc856d9e64f15bc7ed2b824b15c06dd4986c9052891ad0cd95ee5c8c32966923257ef236f2e0d358604063dcf3d4201c49f6d191b7adeb5b88204fc9e880dd3b9850bbd6befb8866da8ff4ee26ab26ca0aa6e168a12594b667a801f5666e3da5651703a4c544ca58bd7a4db3575bebd6a19537e439f3bb5dcdd6759c6d3abb28b02daba7fe320485b1743355cecd4e2237cbc852f4779bae46cb399962571abb79a239d3b7dcb7a60bdf4d18b9e97c382905bedda1534268e4a24db518f3856c3f73f90d27719f7374ed1ef59250b345a95a2ccde86ad524450ac145cb5f5864af7eb62f7095f4c1358c706fe7061e33dd0cd039670b675f5828429c7f259b3c7b33aa731e622a36e9d3380eaa13ae4bb4f658c5c53fb5aeeda673bb95612ad2d4eb50f6f91f2539b365352d7b80f90ac85e00783619c26ec08cbbd692e222fd51be22cc0255ff75ecf0f4932f711d62c3b1f3d5fd4aec0225d86acbdf4c76b6ddbf1769571b95da5170a7e49367f3d323c09a43735f91e74a64866a0438af5c0fbb2205208ae28d6b620fb06d5348223390f293dcf508cdaf6f57cbc59213f01b43cba63a0629e55f3d97a578b4305477aba6e0cf16db8fbf9a162e8aa54798b5712fdaa7bd9f7e9d4bb4a303fc2d4d505d93c84d12c2289db1d012a4d8cbc3703c86ddd70f3da20f2d562202abba90acd179e364dcca537284da1603c8b340b87a8acf60102f8cee098a73fdde7841f5212f1e3ae37036a20278b846c56510edac4741dd66c24ce22068b7fea108860546879c02a90fd5e3a5b96bfac82f3eaa740ab72320c4a1f0681bc639459b59e9096483d1b16dfd018cdcb7291b1f865ee0329c2b962b11100e57967f543812430a44034dc6bd195593e6189faa73ca62fb331aacc72bf9fcd11d0e4b3ad8f459e8d199a07e3fcba87ca9e476b7bbf4d06101561602459f307ca2d79b6d40974dda1f5bbbb87ff9c0de3441563d1a3de996907a319c8f1b6fc2d24144f2d8c6514d182100d9dede0c085dd23b705fcb3154cb1793be82c10d913f2bf8566ec026398dc263eb5dd0b47c02af54c8849475b8fca085768fb362e55d4731427654762bea4b66d5cae99d1b873749116262573c9e838339f1a022496e88946eaad89747623532b7d66a115c0238abb54c931d005a530356ec14320dfb39fab6b1f2e4bb3908cd468a5d72e2c14e547e23c8f6fd1cf2b2c6907db5dc273ed69953f1fc5b77f4de75088c1eb1e85d191e5c3c4791f8ad775091f657cd536570c99b74235cf5b11a02c92fba8b9a051c10feaf8b15c5f5ed6fa19b9b76f3b451097cb16c7845a6a3f879a4e7fb8400e1f3755d9e6a36a1b041603d1944e44c8b0fe7d232ac1128b8480ef367ff9b5085df0a307c34e22e64e2c31a977d83bb3f7a38c741278a368c71a0c453425f2b1673d85266c0fcdbce1a81de084f73721e500ca92acb3f02b40238477a578c3a68b8f9b4fd87ef68fd5b962ee5a8cf0a91af83e54d974c7aafaa60538bab6b71870972b38d85dd6d8893b8c178a6b214dc9df92e6bbb459530b7ca320ab503d01eae6ea70417f8e881ce012e481f4448c3be45c5f3184b975f60f3923f8509632ce2b38df5e681fa92216a3bc20f38c422f3482af60151cb1c7db9e2b344a6c9e6e0328bfdc5c1b21e0589eef48befcfb0199de7410e74e04177332cec9f330da2cd890799cff68289bc56679825f057ee79f9c6e06106a9e06b1035508f92a6ec018585e1260e64d1e4c217909aeab6e247aea7b34ed384a1524e8a40c537cfea26dd333b3910c931258f3ef84d4159bb9a1c6c161edf1146a6be008fe09ce16bc6e5166af197ca9ba7d776a2849d1de58be2c16f6f0af55edde604d1c48b23c24206c2b539b455681e92feb7727d8d119352cc4608f00287f00393429e4d9914f87751c56a0381d2069a8ed83724d91fed40f2d4262978fb24832006289de0f09c38753750eca5d16f7722de32d2e62a1d50a2f1e78091ac222aac80b6c93b22384f7e4eb160c156a89d876275d3bc662b04d88784924fd274f7edd438a3728b8e3029b997bfc91aeee9abce3485f635b105530067c8b251dc423827dbd06435914105262dc12bcd27235f67f3376a8f1092cfea039c4be91781934c8b763e7b6584b3846d91610787061e1be4aa4c6b5d1692c394380c7713859b05119b1a9c5ec6985780a13ae733b99d5bcd194a6b0d3dc30c3a851baa20f2c264b2771f3e24469651f2540a7919294b5f27d08a4e308db6ad0973c8ff63d783253707288a0732cfa52a931dfe32c63278ccca3c34c488f3e542ff311ea39fc38094ca8cc33f24ff1245c1d378a686a4b13295cc7474e9a7ba63decb2a89d1ea43ee4b5ebf015a16ca5325d6881fb9aeca136a6e56ad43826d4a6b2c8f96eda1213c3650ee8352b834efa0b954359de85b3d32c5e50b1accfec89c85447a47c7c94c2aea85b159b2fbe5ff25ade1be27770af5edc7610534015d55059e9ea7b4936ff59d8c3662afa2cfd8731f1cf3f1f1a032b8a2222140fb6a3003eb316bb6a2b143688a78fcd2956fdd6fb8f960f79fe66f0e46ef52746f98687e097c2fa4035b8a25c0c26747914f4fc915e5140bd6a7954fa450359a0dd60e564369c685a50890e8a8e044721f90d4bf0e85cd3fd3c220068933df2f60cd8d564c465dc3f778ec37ff4391a8b9434e94f9bf26723f4c71eda1a60907281d19d61e5cce9ac791dbda10c813fd79a51e3a69fd2c2d0f0cc71c78e0b2c578ef79de3738768eb7e275df573a794d6d166f469934ed620989e6931465add1f5d29d5a47dd8fa29998af6910252110bcfdd49a3f7222f8dd6c0ba98e836147fa6ac1914fded94cc8db00b25f57bc7c9dcc1171d69f38651551b3bac64ff50b2d27418fb3d15df9ac3e1f8bfa304284e891391f35d489ec1a92662a2df286b62a7959aafd854db32aa9c09dd0284b25b6cf7946889de17d027eee817eda886fb9eab12939483e9fe67bfbe34d0c6825a1658d41ef3ed03845bd8800f1a68ad10f57e8cd95e5e8e1e6bf4d4cad93d2dbfbabc60d52c4bb8a49c87876e88a7a71a16558dad0b86e1f0ec43cb898bb5d4846a8ead69d617e6b4a57963be08e3f651d49e2a9a464e5806a72c98999fd1c0bbfbf2149720bf63b92931f35e668cf12aeb7e5d9f3f7999229af818b9e376b1e7c6d3e27f7a6d1ac67cdeccb3d0bb9cecdd5aff9076c838fcb47a18c916c06a2294fab462964074a925dddb3921a6d00656dc8864845a7f455b1c1857fb6d4d1c36e33458f0990f246c65435849a8811fa3a8497006f4422ed47e8494ab64ba36c880405924cdc943533191510f6313ab60e3647dff8a5b2c4ba68ce9d8cb5c8c7fe65db31ceaa3127da157e186a20989d914141b86fb486b0db94deca9ed8ff4924233b792ad48f852280a3b74d48ee0d0c1f2192bf9cfe17e15500987ce3fe210cae05220fe948d47f8b3e03163e9c37bfc398034dee703d0a1ad814a44cbbb9871e5c33199d657bd88b1a0144fcd81a6f9f11e6f63e199489860a01fdac3ca57f9748bec31315d658c9305e5d9aa4e0cf182f7fdd2ccf0419c6ac45e600e0f04e030888e0b164e51b6bc5354b8961362cbb146b10ae9a8355ba894a44d5102bda37d88086879712163d19822ba76d0e72982582ce36f0ccc00f304ce186909d3fe1c2e2d8daf18ea736240026cf93fc0ea3a2df42d34c9f29e0caba6a80cfc89f288e54e9415d83623a8e727196b80bd0a59103806e7410f1a1297bc935a1bf10b377a99bdbfd9bbed10a8e1915cc4fa9bbd585571d6d7853fa2da723eff2db7a14b79bcff0f94f22988e4db6f24d9d834d42cd82f3d18982b5c8b7e40b5a47f0c2dc2b1cb53a21ffc73617184b09c7ab162103ac62553ae63a31a7c19e93769b623565bae8ed8eea86bb14647973873cb52dd8a0c51b107faa4f1491b40b44ae9d8bb6fa542a5b0c4977c0918c79515d23db1d378c7be18710c442f0e5d9cebe1b17f44c6046fb2b263e46ab17f13dbb9b5678c6a161d1f1fbc4fcc4bf8e30c4a9a400e27dcfdf1a0ebe916f2a3d22c5f7588201771792093d75fadbf4dd219620e8725fecf5c14dfd03ff57e35fbebad5c218eb656992842b8685052fc3d698cc130b320786335783cf3a4b5d26d31a0955b37613920b4d2038a90515393a2faacacae7a47c187b3139182913a148bdc774d44a5efc00f4a0c380b48e1427372db6636c1c9b7ab8276ece3cb4e2d1582deca44b4e9fc45338cc593e140b71f6ee71bb3f84f6e9d7d6cddbb1bbe1600335fc65dbcc1623e4a40d8469e539ade127a643078c063875049af0b5141a7599c99a1c3271473a535cc1a79822ada4f31ba42e39ecbcba08731afdc36e51773797c0ec795c2beb3f132fac9c052de5f0ac928ff9eca2ae9912203a78b014e256d9c1a00269e3e08b688da2d4b3136ca3bc209136e0d7135ff8342a1c3b8421dffac68ba08609cba7c0f1295de7363c427d6a615be41193b2b1ec2759ef3d96a3314f8aed1cde59b6dc6d4758777231145360352b1ba11028090781d93eaab43d0f231c444e85e6e05f7d7a1f5cdc2ee9eb7fd223a19b9c7d3c94ae718abf004f4b2fe18c05af629c686e6aa54e5e4457a311a5b907862c0f498fcb1e4e617e7fa843b810f64a2235ea48fb54a15897280b5a36489fc792fa97c26592ccb32b27c6d1aa65747735bff8fca4e8f1378664e94529269e675f6ba1108525a6f9cdf889c97bee81fe18ae979ed12adf6f4d20ca88a05dff022d06a8eabc6ef7dc67991a24151854511dbe978c600650c1726d8ff501d9f19b89df379a933366220f01f9be89b561f27cd6a1ee19d18b0fdb5dd2482f7d830aaa2ab2d5ea30c907dcc9a938a336d913608ca61acd4f682058fd26df9e9160c4f0861d6d0b326894c562d9a9a390d09828eab5b1b05b2a9f2cd8e3aadc18efb35eac29af11e4ff33bc5c0aab145bb56f047d3e3761e4a45589b486a2208b868a73b4f3e7a42b75fefa81f30325b3272d7d489a466084459ece8a7ee487ef98ef953e273d59f5e21e464f3ad261dda9157f8d31ada6387cde0bde0708718733767ffed232d834590a6c060b3f921ed75a16728f952ea8e022dfa92f47b60221df8b5725bd277538c94c70882588a76b1660092314ada043877349efb7876287e52807d887337fdad15c9a359960e770cab9ef18ede6e39b2d7e728c081b9fe0dd05c7b45a7d5b45230a5a93e3fdd36c24b9662915ed340f6f9b562806606a21a1ca20970ff6a260f051f7d11dbef9f15528221c6b7c7b89b1ee26f1471cc12175cac91849fe558cf0f100b852f05174f40a2a3da0a53aaa9699e1a63438ccbe87bfa54a3bb2fa56b02c4865abe1e5f97bfca7498472b0fabd9ed9b9eb260cf2644f73a8f548ef7a0027c42454986f3d931fe1ca7b2d5b1cee00e57a1aa75a3da3efaeee8d8845cf47a44e9c7d22130c7ce98890d3f8d59b0ed86067236ebe47b32126336dcc3c41aa31eb201c5e79d2122627f1a112bc504867dd0c6f685838c35b3dc170c96c10966b0a2ad73da5843e82ae18930be1933eb6f6040c1137c5e8d5265ff72180185d0ae99a4ee9cc3d93ec183a41976b262a6263bf33249737d18e888b83cfadd8c6c618018446f9e1fcb66069abb61f716eb1846a65486fdc81f299023ed83632098dfbac95e26714327f40dc7ae228099c91bbee74025f0ae8f7ff24aa828edff5d8ddc39fa4a9ebdbd2ceda71327ca9e53f25cbdb4334640dfd34ad0234d82bc73d575bbac3bbab60e33a32cd76bb7be7a728214bae59d8470308de9fabe9b68f13403ffd23dfe44eb9ec8692cc920917f60d8d97310a907ee36ee02285428278e53e2859c0c6fe15fcaf7a363ffa7ace99e3ffded19ba933e7282c3765390684e6d0d3e2093f2f29b6ceec170a31e5aafbd59f015945193a948f85082a8b553ddf724c2fd50a0fb0c024b3e7970475db436f457c62c3ebeb63cad8f964933dd338af17d1568fd7fb4f98234ea4f0558d497a74742f78014aa15106b62310efc91b65c858b34ad95f3ab4c5284e600aa57eddc2c437b60faac6bd28aabf80084b5711f455d5db318afe126e6fa796172be0ad41f86433963e5e3dc76ae87b683ef26f1f04f06c07457e0f2246f2c2e044d3d7c543960e61487d8207c0df14a437dc8fa8f22d5ab5c2c97350aef3e57da4da8c2dfe6e9d191418355a1d48435470cdbf585ab40ee8caf0df207852471593b870362cba28d6e1723665411df4d146cf0e89674b0e7ba4ebf6a712702b7148ef40194f4eab0d9df0cf80958af202b98410c8f37b182b0b46caa5128d018d77a32f7a3d475d95c6c318c7449dce9bbcfff29c9d243b9657c9073d49a53524766645756d98232a76d4c87ea0c86feb65e5e1261a8f16052b89843ffc3422d4c2cc1f5ca3515fa50ef141b37030d8ecc273be2af3cb4840304fae9c41e5df81d2b38468c958c9381a3d6f118eb682d53f1ae7e70fa39f3e13fc60c9d3e5b36ceb1dc56fb975ee44f346059ac3a3d68e7013196c26b848bd2a3359602f0c6994e6b1c38cac0e7352bceb209a2719b88fdd9a7ae0d897c94aaed440e7a474cc08617bce33c8dbc7d35f36201676161bc6f2763c29d2ebdcf679e431ed155adbd4c138b6ecf01e1a1242eac8e89a914ed515cec3ca510d2c2bd0ae5033ebb3c039b5941082c635610ee0e5509e82b7894abaf44a86bf40f4f996df4048399f7da1a54b9d59417953b8df1f7f7f6b793e2d84c4961a1efc8652e0a564ece7f1c69994fc815dac026c7cc859972593bc253b98deee8968a7083e3127f92ec7fb0e7e26a3ca31925bdcbe2946f62f716c0579ebb73bdffafa76b24e656b28b8db6438c380301366760ab95fa36d392c3f9a464ffc7917a269d1955bfc1ee8143a7ff330e517b7bc42fb55386b1d3c89417608b5663ce8b1f9f6d842e0d99b793df05163a5c9a70b4b751ecaf1e5c7f129af7019152d566165a6d7f5735caeb97452503a7f74441d65277c3204b60198db365e1796c1dd87635d466513950389d0d2847e8822e6ba497049bd47bdbfdd90e64bbd55113b8c53863512864a82b3c02451c4e63b76681797bdcb4f976d42f3a2ab77bed479af4e6663c09c16ae3a9971d462b3ba3d7b2247f5c2382557e7564ade6cd199bda9b843791e4c3df533ea2f40781f658326e8d35aa12b49250a1b13fee1a646aa823e2e398a60e895afaaf1f7f0ca2802551e3c6fe8bce787f294105d7479dae5338507f22e12564d5569219917f20558ad1b62c85a37f9b9bceb8ca905837b2a03c0d671f246303a419723c781270423e5fd2799a56d5728c1e360f2a391cbc9675c8c40d7766e68867d8aeef83ba932d0df7eb3c515214ee6cc200823e85f764dd265c7bba018655235d9d1353212793ba4c7a04617af477196efc11ac883df70abbf9715b6396d471c6bca3f95131008191d09a8dd55a76bf54da01f57b7388a6cf1d2372f6043f86fd30da57c3a8228a8f0e2777c4f405218f3bef81aced7fc795b0c8aab73b371662635af77261b3ead72a88edf227ba1cf0d1f8453d871d79d8aa758025b736277ff96b2d270f38f734d595caa43ab42ed144c3e5e56947739351468f78a90b362d15a4ab8d35f949b284e5c58413c6508a094c518078f58517867965ee6925c52a3fcf135a7c405dcb233d218d93dbe39e9990350b3b3041fc0da8877a92a932241f559370dca63b0db618c9513711a04284b752d7ec9b575ae2157fdca0c25e6c79045fb704f1cfa00a1ca0c0577ecb867aeacc5a8f0b8ad3ac23cc49241155ff46022bf162935d0e94afabaedb7e0d0af7ffa49e5df1a986bc9398431151fc49d69057a2af6e85244259f5a55dc5596381588ffe4fa30da09842b4e3a8dc4e0529d45dfff6fcf617e7206cf75c0a377cc451a72c61c552f9e8d8113d09f3b330d770f7fca01c6a8a28b28716e52279793ff95633d97ebf6e3d5905c2afd0c829a6da07070ecc33ae45ab83bcb038105b48344452ddb13a8b81a3316407e05eebf37bea02e2f5a2420403c76d9d4cebfbf18ee5485367e67789013fe1d9a8aaf9b6f05b7198297941917eb7b18159768cd36c448418bb9f28ab0b95dd5fe0a5c1e196a160c63b67bd43b430c4fb96b2e7c707a4a286efd06b2dc015a1719e00334eed457eac399c2c6a1dd039ab9fc4dd3d1c3ef740cf803e76a85a74861656a3f76cca06865be6113e54ef84c2cecc4acb503126c017ecc09109dd37e2ff05780b92eb3f16e173d51280c1a31ee9aae2826ba6721cba41d293ea8d9a76e2309794431ea8faac113daed12b67ec252db6bd26f69d93c2e431d5bb5c8cd90ebba26423e9f5e4afd69d3fb6d0eeba98ea1e9be9b3257fe36ad2afbbd06b10db69bdb0e3c670c641767a5fa8e535bff4a5d080257ead2030fcc87880af0bb69e4aab37040c864c586f956d766ac8fcd226022ef31dd86e0ae35dc137b70d42122180c185f25358a840a23a304a883c14087d9770c0358af7c1177ce166c13bdf82a885f05a01215a4532331a8a8118561cb25ba8fea84c76f051c55f77ecf72a7d8ead527b915757aa9c3c0799f4cae37edf95ee190e540acd33a39d22848b9185e3a703c41bc435c2ae1cea9b20c8cd8b56e41aec093d44acfe4afaa3a62cea4e81aeb036ec01dbffd071a91cc14265d6b36ac86deecbaea5ba8ad602fdd728d70758b2a9779df1e0970ea621a871fd3d01a067593f2852d9f9eb3abd8ecd12742d5ed43a1f18f4ee2af1e5c9e3f2fe87bd28ef48daf7f1d10f7629bf74a0a7372f7f3523f5f497dfb51258c9776f9b77042325c3cd2331115a77f226be0db60475194d583b25db845f4eba6ed29994489346e416c86b88ef50ecb01c8ad6e431d45bddd7724f6f6ac7e664e7fa3495f4f2cd5c4fc4bd88e70196ba566f81bc8607bdf6be807bc2665cf34fc7eceafb46d89d34bc7ea6d8130dd1009978345967d1032cf04404e85b0c9113d1cacd9870c6bb00612426541b83bfb13ba4a993704c7f371932a5348f5a35085bf01bdde39872ef96913ec959d98177104fc84282e8223034351d4d95fc75a4caebcd8e249267340765fbdc052efb0d40e00b3c1f0f15786459698146c69024700a638cf79d6200f15342842f6f359e97354924ffa9e1eedb40a81716803944030e646839c6da82e69f70f4092f19579d7ff18efaea26cbc0e8e4927f79a7f2ec6e82c0edd14464628bee427963d03a2f8f5592b4e8248a721e07bfddb98631719f7cda6fd8751b7029cc5c71474219f276888b32dbcc1e2e69cfb513c7f8bc3ff3b03fd6f8ee0c05cd518f574df542166110e8ac0df9fd5a416797d53a85e6c6f05920aebc589b55e27f4eebfca51b160a436f65f20ed03dfd8b2979d29fcf363e646f3e35a1cd566822210ef64d2ee93a49ff847466e656123d3823bf81b0d1f00508f1bfdd8d9aa56ff6e3e629cd141aca036b663f5cc2e6bdb8f1cca57fa09da97176b1554fbc0a5e0fe13f33e54d7a5e278923662c61263a1af4232bca1a4de92c446175a0dee4a86c03f3469c8dab8d30a89beede9f975740f194abab357383b0dcae911097d0ee46698474bf5e6c859e688d142d1c7d78c801d91e06f15f87bc715894c3e4da3eb509f968026c57e146c1eca7272a31bdedb4fa93df9098dc443f07fdcf42d28600175a69ce15f3372427ec4591f0af9e312b7e133cb29e84fc6ea113b6d1e2efef47d882ff77708054a71246daa89bb9d2b2f3a0ec5704b10d3fe0e581c1b3f8e12d0caa25b5d2dd193493cd0f7886cc0134c5d9a6a359e8e8415b15fe3d0604b8f0f3e7bcc8209334ea9e61e535eea2e3e036e59391a91a8fcd903049b565ce0b6d24c17da9e10b3d87a006479c8371063d23b245830ec217c3af6264ca97f05a067047bfb998bb68482f48619449faea9c04f0a333193532966d5e94eedbcc8767f2681fa53507368e1877b931dc63a8ccaf7bc9049c3f0d8ab588a73e5f3e4f533f5e9127de705cf31c5329607f43fc471ab843379256f67b34e94608e8ddd82af0e463827e01a7b3bacc41b4f325cee768164b076aca064be91c7bdf1b1fdabb565cbb68720ccdbd02845e7d95db81341019dc0702cd69c6f97734617bb4b64bcd5ee047fa660f2966ee556d871ffdaa9f3630a7a6e9998eed5fb6bd734490f0d34b0ee2d655e3f93ce7576c4857e227979ba1c0e2b50933453c32738ea8fe1a13664eeb6695ed25dc97e5964817aec0730a124dce1de3f5fb41f6ba9483ddea9cac6d1c5b5cf4fc909f009f81d0ad480fb21fd0997a072c4256f27c2e7b210ea51e76d5c143716d236e0450ed2bc8fbf79b318e337ff129cd4be93f54763479277bd1dff0acc9fb88d2ee2ef468b63164010fc92afde289c68d2a0f916d29e927975c680e653079671cabd33c73fa7d3696149ffa46ba888463b243fb798599da828ca6264ed190f47e602d9aa333b2bf8ded7af3b75530e04ce4287093a55d2ac95d0e11fc9143edb491cafc889b33ed47ab95774ec63ebb64a08cb931f9236c239a93cb15d9629d070ed9b7845eb8b6830c8cef7ef870a82c3278ba5f3ac0422941c51cabb162b71dda4eea5cf0de95021f8f09d2d154897885b669ec7e5878d7a6de1f614f2ee78761b275dbde2bcc7ea5ebc0291848a04c98b037ca6557f9e2d969242a63b495a9320b5a23dd8ce712a593817b319c6bff09c71c787f2bd34a16ca9622ca4db8771ffafd5c6109e2f1a6b090d81cb39837ef265a47dd9cab2bfca3451d88c274a847ef700f964647f552f741c1627800cd67ef413d935866a2c78e5173e97758b0d94fe3b35f3a87d31f57a55624ba2cb4eb72185946f1a4568a8d6c2c17af256673cf1859953195215f5d289170a0bbe59fc627bad91149b4d5f4d65c","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
