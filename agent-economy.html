<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e121e25d4549d5e0ff2f25f61e70da7e65b7b437fc9fa351ce9d8ff8ec99ee3950a52168500363cc5f65f50e35b5302caa98078229b8f6ce1233d88f6a69030266f09454fa320e37464f90f6f25bb7019cc733fd07b7133d7a969800e1bb72ffc8f1ea94b176ec8bc82cba879f65cb5cb7dd816574f48f5e1749eb063f910f578ef1906c2ab976fe2285d28ece6e9c486937448373a017eafb1156ac4c0aff931134de719a44586c1f9d971ba3b15348e30865884e3d619bddd9c2944d1e49f97df8c06e7bdb57b463de3fb9cc728c58927d93b63a7d5f3f06d99f1d34e2e6139f14c8c22ecff312f6c98a149e3ab5f9d9ded54726f508861c6c45c81a1bea989a1073169d65a3ee5e8b992d0ea047f0dd544204fbec9064308970cf953ef81eb3dbf607891ec01049036fdb6474e6585796449a1ef875042b1214ded6997fecec2f59078296be870ca6894ce27eeeb8231cefa90301edd1b37136dab7ee56e58c8a79955fc17d9df149a3ec77bb0f6a2e6b5b240a082d8a30ff98aef2ec0bddb2412060182ecb4f2403a2467774f6410ad13094d222a93f6b2a8e9af3aac6e9a6bb28ed87602e16bf9b3ba8249490d39a4f8e3d6f51a516db3ab9534e2db351dbe9e649d01635cce201a270179ef297794e2f09ebfefa54bef4e9788166f3a89c23c6e4c166df56ade533ecd52a2ce4775d51265b3c0df60106384427a81934abc087a90ca385e977d50cb9e799255e47fdad8b65d539f93795780d2b396f70b05dc5e47fbd3100867893f3df364b2b8798f65fc04f6af0a8362302892a4b21bd834613a92135770128374db47ee33b701e2c0a77e547d6209a8efd6505b052cfa1f322541fca0bf5460d5de580ea75e782da225e68ad6a57411bb06610972d5d12eb4796a1085de9bfec2e397c1f9141ad7e2bf7ef6e7ee44b86be48912bc9902c7bf43647b62aced418dcc743a24136193395dacc8eb693a7ac258169e7ca1913a95d77b09be76714ddfc3f8a393ece506358764aa57a3b73e9d2cd1e859fb2c6fc47b182f6edc74eb1ad1f466e83d5e9c0376dd7fcea57a59c518389fd1a59f2c5e317f758af387f5bd6fd8953a6b8a78712a90b7e8f34af4f0123898fb105d754f9c578469ee1aa94e57c47882ec944d50cd6c39409eab27e3d1b286396b0b3fca3fe3f17543551266cf962c08eb995eda1b3e38fa011e1edfd5bcac94c633a3de74f2775c34c029c611a7f886fee3480f20b82434b2d80684e0726459aa69e255fc55f8e4c91988b48e1fab1bd7a627cddf9d47be57e65065c62b9e94e597bf0a62e5f3a521e18da7d847ebff987d5eea04e1b9cc1be5012f5c61690d623a8c025a59cf45856a9255c5e7b62da6cc395a3a631b8307f97ad1af802c07a517d021a10e167ba50299170caad9fad48f311d75f651e7c50363619c65f78dbd39761ab8be473b6c6e354916282fef901247b38d0bd56c537f04fe85620f9f6e08cc397e853ccc114c6f23cca92f76832750f0235a8d47a52fdea2c0d4528ec6c631e2f16276f16c85046b7f9a2174b8dd5e9eb0b77af5d5c3bd8f78e33344e96feb583469a0517d7f735b8b7d9b2960ea84b968717e4a97dba4c4f92d1c2493af6b97a73b00ffd5d7fd3ed774ec43de9007662ffbc2d5d921bb1a647cf64337046f1e9cf749acabf02cfa4bfb730e6406c403c8d8b9b5b735bd20933a663785eb4ae705ae60982b6862a281e4c83e25867d197201f3f9580cb7b5c1cf4ff9a06428452e9ca4596c22499de9737761b7406e61a58038d97230fae35a86c8a7eeec4807413bf4750adbbad26df9ba8b3dd07a2085be60f0c758cb325026a35ae72954b74b62c1e62fe0fff4636899186d7773b8586a76e67ac6805e6a423e3e65a9524fddcf3a6ec2ffc98e900c949f1635924d90b24a52985728dd3f68aad8aa2d28a7f8720a3594829d43d93e5144d59d175e34983cc4db72bb9d0da54009d068dc2a56c048edbc56666d311178eb35ffacf45cb45fec36d80ddef6ea097896158dc8e606ff6957ba04b8235c3748b8934c5a983d51262bace0bf90c173f60e9048b068ced17e528d36312fa6d792d5387c1014433a0fd8670b1b4824863f926a77d22647519327db764b3a8338fae14ebf0dce990bf9b64f7370a3b50c253493441f2b3f7cd5aba6135ccd593385cb088098c7ad6e3b7a2ffae91d2a6aee8010bb962acde0647cebc6f894ace087fe6d7a5132b8f4044301841fe546b0076de574c6cc0c0bd97c190b960b26fa6e0602718fcaaca69b2d69900721add180afc96321e0c032dc3e75f8d25e418fe6921082274d40e30088d2ee0bbbc356bc008250ab236e8ede0343765fd4721e69bedbeed550ab60f45e994b8b73288f964f5b5b04e262432a6255c22f81b0313cea1e94e352e3a065a499e2a41a0edde2514fd7a59ea6e80921acc1c83d61c3f7aea2c2c6e79b4279f0f9d611c863fb80ee3c90ce13a3b159b14178692525673a560f45b28024efa20649dc9161cdb08c8e87979f8ed1a6000963a2a733c3ae7f14d95d24fbc5c3f04c46c7331242aeebcebc646cfa5efc9804c0a1dd3426e5e0bbef3ddb116780171cd55b42461266114d3a34dad5dc129fece2bfc546e76e2709c6c66e606b0929001d21b41e086084b29b35752d3a51ecd21f2cbbb3a61976e564daa2a7dff63832c7908ff5cfbf64ea2e4b0f00c954d649948ac051cebb02b85fe9cf29cd5898d5b7eccc6023dfca28bc3a79a09576e8bf66768e79382554710db481f9c4e1f18890fb2754366cd74ffc6b12f5ae0bb313b2acd3a9692876fcbb27a595c5f574f29078d4bf424031a56d3d29c14c71510ee1ae3dcdfca9eb322111926aeaa588c9c376bca64b096a5ffde35db3ae1787c846c3a52a322bdaf013d2a36e4f24aabc8042b496e599899f1e7213dd12423e95fdae7cd1c7bfb371cc3567c3c901d04eeef81cc3504fe4ad45b4fc8435878114a887cb3e71fad0d0a69650b47ba6003f8a36a92bb17532c8606f67f9807ebd2b25a17308a6e4b898fff4c3f22fae3d9c549e63e24768f45ba7918035626a03e9b16cf9942ee500c6aca9ce4407cd3f99cc59aaa2b1808e5cbaae39128edacf30126a759394e7108f99130390d0ef8d5f4b88735affcdc8eee25b4edd304283eb27d633408c20e12897ab3cd4a1647de3c2fa5bf89837d30e6fe1115d2c70ba0b806f32b18ec8812ecd643f17e2717fb1baad077eed11da59e6859725f29ea41ddd286ca55c070d0c4865cff325a7fdd69ab4acf09bf299cbf630a750686289ca5ec9d55a07cead444d46554f1155d10e3853346022612036e5b53d590f9d9fe28cc9ba272cdd69d9bbf4df4b8369db18911586df4352e33d3b1891b248f087ab2d07b31d7ff0cd3c6f371512772d3c59586189a7a0bf8cbd5b1b3e5613c632497708dc75d2ebbe67f1d5a25425375d2fb426264bef2bcccfd86a9f1211098a07f9bccb1266ec782650fd4bce04faac154bce7b1dc322757e81384a72a4434e7e67dacde5ed5fe12a29f5e5a8b0a44d9620df2dcb4184a17c3555fd86c429d38edfa9a0b981403f8434121b2f7026d7633ae0150ce08ec2c28198322d6df9102012b1c04798c4e45fafed28b59b605f3ff71f3a25ed821a1e891fe8d47afabbc25d0c46effbc7fe8e15d2a1f95579a565ca725353e2b9d93d588506766c8d549dcea54d5b662eca202eb3dd378bd223205a1e0e4659eb17a18001fae093ecb57d29a7bb6e061fb5c388550c2449fb31d8c6db600c3746f8f70ba2293782b4f2fe2385fd2b56d01458ad61204843e38fdcb995b49a3ccfee0b1293178080e48dafc4db4717f6c34ae5085650428512288e38b4e949eaa47593f44afb2d82c76be7ff8a8e6c5e264591346ee3f929bd88254bb64e513661f1d535a4be364f4ac7f1cf97eee512c53eedd779ecc52709795cca24751ccfad6d019bfec43629825f03bdfd1212dde9c816628614c8391ade0f2f433eaf92c1ecfa6bd946b9931f03f28ee29208b2948f1a2451f62480712e46b596aaf7d52f4f7487c18aacaf3c0fd93de0f49ef37550edb2953af8283b2af44948d53f3b77055a24d3e9abfa7edd142e5c642f6ba047d288b1dd140bb9d1de4c6c799adea35180e9c3454e91c5e7cabba476b7365a3708a7f7c551b08a8ffb2520af06cbfe5b1e13624f79d0e3321ab45622fc16308a45c92b41e4aedf2de1cfabbc7c73b9b45ddbe51dc4392e15ae16e756755600968e9af445790580ab96603e13a961c5d3e1e25b33b9218ac951d2fd80ef15d07bfa7cbbd217a5b2454e017241d0245f2aca2007ff9af916268e5a4725e59f37db906b00cdd1818cc4d31c2181be7b9025f66aa534fc4f031fa442fe78460005ea02bbb6fe62e4093d90aff407e46d0a067be6f7b9036bd073000fdbcfc0882f06980e59e1aacd8f4fee9d260d670ac950d51d4472716a66eeba69fb1760fe98f880206a12098b2a90b66549f7ad4a2582c1ba1c3600340fffd68c15092d52feb7a748ee787b42d3d8f88eb07ffda73dffde007cb12b07ceaac0ab7bc0e531a0f6932d80204efeb92ac5f01fe11a40ca581eb3bb722985c146c4c415c132744436fdbde96573a51624f87fd8bac3116ba5d5a5116ca2f2ef7c7e4cab78c633db5e53161c589f217341dd596198aee3b435199e7b5687a63bfab0b3eec94f3339e3adc410f63d5b0bcf600ecbc03a21b7627aec6887ac664a5728ce5d410e38beffdc7e0195d81f5d51a72ccb92824f812ee46f856c376a7747428bf87c84ccfe300543f5d7934db22f679670d9d6693e92c4e8e2f6eb51a736db6317df86b2f999dab08b45e5c3fba8d949f70a5d2e3ac2ad0ab139a8de7bce2a0ac6499d501c2486b936eda6cf82d318b7ce54d46386a137e2c9906168cf6bf0d9f6fca4facd24295bead4cde4200821046ed541ef07c45b4f2316b797c1613b28b74c813fbea09df56a0a0a612a206e6810a9a1c1d297afc5959c273f078a10181b2ee1e49c3e614dab6422310ddf83ffcbd9f9ec008d9e161aae5582ff22428a48acfebaca6f86924f680751d8bc6390ca296f9a24c1324d6159bff0cc28e5a3e29ac175f85454295e45e21df1324e744fbe4642518ca1e92b7495d14c4f61dd175044b037323d519af670ab3e2b5ca31ba579e987be629aaefde8b1d68764f8c1a4e202404e064ee437899d4c7b350b394b5f6a938e4105c08d598dfd84b636d9adaff5ceffee8cc9406a4ec4131dba9523821ba374fe428f016e7d0912edff8432a8b94c852f6cb98e53ec841923a2f196018576323b051be904344fc21c9d8f5e80056bdfc301095b90d621aaf974b0207281fbcb24057d743b09b0c4b85c044aea0bbcf582efc26ac4423fc010b61ee006f2a002ce5635e06d3463e3a40ed3d34438045b225e2dba6198547fa4b17703b26d3ed589e9744fae9e42507d4ace6eae66ed0ac31eaf3e0d813263b2e188bfc53395f0e9b658ba7a83bb7e0d5bf084f96900257fa1b9a0e766487376479ce708b4d2cfe82a9dff646089ad6810132797738d63402c3b82981c7f83d1e890c37fd89a4577882089ac890b3ef89a221215481496355bd3ff1809ac6f1229cf0e60c3d6915245de76670004d833d3032228a4e0a32e5b5b1a4a31ddb625072496f173d3169f62b3475b0902606a4a7ad2ff87c1adccfd5716ac7d3695ab7b73f967f87c3b3e80dd818ba9fed6b645048dac7dcc7278921913b0993b997e81d8cb52556fb93feaccff3853be161b0106778c0eb499616df2f8ee59bcadfa17c20e2af1db3ee390bb6958af4875f8a0b07d1dec104129184e8cb8154d6e7ecd499fecc4f4aa4616002a3019399671fb25df8a353712f815a0dc956e6a11485f1cc4832a4c39b02ada76400f0b5dddb2f2bb3aa730b107ccbc9de0bbcf631d74e9935679c767ac2d9a819949fff99f237b8940f921855f6c73b38c930aec0995b4cff6faf6a6cf36373e0767855d401c36f203fd2ae11d82a35db7955d8b3e7c86e91614281330cc1b2de104ccb2d7501d09a82276c0bd5df89e7356b443c33d7a7c925afd9850980f73d7885ab16deb58d1461594140e5082075e14052ac2fbcee8972e82e34d53a0cbb937b878c91f30de89a5b4d079091cfe8ca8396efcc590ecc437589b0afaa83901943798740ad6e2f73218687dab72362ee2149c6b5d950c5f92d8064f5f188a29f99919a62df75274928d444b726fa5861aacecdc6a2bb8d5571487d2ae77030cc6eb9ef4f7f2f5a21c5ac77acca36b6b2bed4e8ffc6e2ae92f9c5658e4177ba9aed8d1e3c82a8e6694467768e5ed627203082a484e806b6e02edd848be84b8329a415483dae8cddfe12619f7dd938930a9b7339df3713aef9dddcfb77213dc81b84eabcb3b099bcb2871f194e86d1c253df2283127825f82431688db7b329992559381bc3561d53187f43b607d5de0b1c5a307c1f8bdc31d9a3bc30e58827428a86506cb601e8b92c48d6698c5fcb73d618dff9f4ad277a050d46fac6c4081907f064373502ea4f7e3f64659b909ab65b57e42c8b0f11cb5c0438a92742f8df23a14a4da220dc76b16b6523aed67676fc366005a11f837fdf9aa0c3d3f729d7b0f11509300e0c020bb158770972eecbfec79ccedf17ac9eca724200599f0164dd9e8ae3e9a9ceb6eb7c3416704cddbf411aa09dd7242ad86bfd80de403b9954d0f7d6f57a1c71d1dcb3febb8a3bc5ea761299fe214cef1bacbfe64ac207beda592c4c0b4c51340b930a49b489878b919354201b828fa099642ff20d1e64d3c138fd3dac378b8236155d9ae7bf5e7e67863bdbffffa161f4689d22aaaa00ca4c8bfc9b223d4ae2042ef95ec6cafa1848db0d86cf97c1b68edb2fd9eb55824a6257cf51d870f5566543b0ae9c826c2034c35e196c16a7fbde5fbdcfe64d13ebf9c6cadf151b790e445848f2b11da39f729615c0fc8e38f23599015c4ebb79fe3edfb37b7b9c1cfd7c0899295dd03260f1351c4212687cc16d19a2c60f000f52a7901bc3cc3ff42eb869129cd656d2ac5deed95b276b9729d653321b385b9c9a43321f5995c72d037fd8c1c98cfd51a3ec50f732b7fb0c7a82fbd43350b6274e144d365bac209c81b70928684644f44c12cfdfff2c4a3c0bc843d3ceb18c789884918ed9e96f814cafc03f68caefda83d77ea97aa27e9982b2d169b8d6903e8e0a0fa93b36eda0f6e466d2908d43094fc6e01afece31d59862c2164d8e639ef9c02eadf0f39142cd626b882c6a4dc238a45cc46098d016b50729be77c7a7910434b547199355cf001ff0b52f2000a47fdf8e8f04ebc1e64ce43aae5bef448be77d5b6159d501e1c5e25a074f9d212fd895e80be440763d3ae2a09acd7a90901a73803c1d3607d9af738c8d2568ba9bd69dfc15c5a4be16a4a87f414a64244ed702957d6b75cb05b94ac4255918e4473b15c0fedd0c8d4a662039bd991ac4c3274c610e93f0e7cb11d744baea8cd207a502ba189829242a69685ec80cc8298f5cce22bf54ae1dd80591ad2abdf8b5f520d84feb607141e1d46dbb637b4ae8c07f0a9c7d361efc62fb0d6bfaf8c01b891cd546a8fc93aa83d36bd6b83b896fed895b95e3f34e915522718d0b2e6ab852369e2acfbc2df513bdaabe1960a334fdd2fad86460742b7260b4f81cfcd4a15418a3c7006bec1e4f3e8b719f24c4144ca09f6bc135aa2f19e3d50e1824acd69db82489c830b9428f6b746925f83b250a064a385b09ef3e7f59a3c0709b70ccd3a52e9036de5072525bb217c34dbb0a8242fe4630982f7df0e3ed4bc5195c9e54bf7d31902b88a789c55ce6df64ff9bd4db4ed9433b9e22f901bf5cc072fe93175c3296be7d9775264b190ccb41a3c7e5c74f2ad04165a0bf5270d8188a13a5288d3f761286957f4d023ea5237e111d218d97502e43bf992e1eb7a5b1376583ce2372b827c5470ac545249a597d90c02e1db9635ff9dac9cc3622fe17093ebfd6233fd6be2010794e330019212c96ec672ee1ab7f923759c7ad883c08a091bf3c084e3a21b568bd1f8df819ac3a072e699625beb306b252ed2dacdfa571e8f9637cbc96f95874ab6fc993d295382947a5c1b37fe801f0a63da6d9c835219c87c4aa5a0c04e3f6f54bd19689f7361afad11c85a73e1b5909098c860f25e8c78ec26a44b44f966180da2708db5051d1f8b1fa0b0463bac53380ae837188858df08d69a99c6dac4270e34b6970cab98b5e9682b034e62079fd79595c2b92deff992133b3ec9bde84883aae6fe8f18e7feb7faeb72b982cd5bafb37b41a2f7a62ee014f094de71576015e41609ef0311a51ae1a3641409634e13ccc04a77f0b6eabe4ff246d810d8f1c5ab1a398100ab543fd56d57fe36a3e4910c8364c4545ad102978ada5266526be5fbd67de6f9517d0b988edd337a26ee3c3f1dcc8fe56e3ea2d043108afb455f7970fa900aca8f38336972b478f79c8ec442ea7dfc44d562434f219698496cf2e72b789530bc0175d13df084318693f2bc60fee5788ad2d47b2e8d02cca56b0d6456bf047ade7808499ed55d60a0e888786d4de0c5f4d6c996788c876fb6968e816593afac157c1746ebf0d1cb96a811345e53155cc08fc5bbfa6c2529f291bfa0393190fea03ca9a68ca25f2aade4775a36f515d3036f8e54cda72095771309677d7f171688e42a0479e69670640623c8a9a1c84fc1b4ad9e96532cd51f33e6210920b8237d29494a85228688c04ef932b2b43c65b72d78b27b3891f8084522970fcf6567a86f3ed9419f29052bc8864b5abcbff44ca3208072397463328402af963430b25e61b0adeecc78e41bab12d051826027b83faf8b9f3dd51bbc8bac192d7b4a13ae75a950161f6247d05beb985a90ba13d8190a52dd9e120df08a835ce8490716fcf39e106d0a0a0fb8a8cfe46c1afbbcb20148110b0cc5fe082a1b2fcc774347a9ec6b66d9565ed80485553e5b14ee8e4ed6d2d2a81c566e2ce37b4fd81c76aedcda5ff02fc4f2ffd64d3e01be8a5b72e18921d897bea60712d649f29ee590a97ce5c388eccad13930462bc9897cead2086a6d95ea6d1fc92bfc81ed796f16e96adb9fb697f49144e0ac1c92b3fd52a00a2b5112d28985c2283ece21eb4ba844a7da8c257e775296f407f36c1a2116bd91bcf1a5537742fc80f8bbb9cb9f7aed150bc7774c3ba072c8b0398c5b0d10c1fb14c857b04dda22c669512aeef6b1516f1717b4e926072087ee85ac2adef5aada68144123bfed49bcb40ab732cc6b2e4b4d17148dc8357eeb5963686849d7be5d592ce691906224ba7ca124171b6f5e7da041b36f2a398e0b2d02d72decc4dade9cdc9a20276dcb51e71bc0def12a1227faa632a9e8edef3d29c6fa70401e17d5f5f41a9d02ddd4d2bdb9129345da8c7d67312ec3401f47ca9e1cae8606573520fa15a1a13b72b55341e8fa9eb323ad75868c4ffc32ee1ead6b874268575a052277002b30cc84bfcc445d014ae6f894964056e9ab7d5c94409e5a4bdfd1702f631724c7c8850c4d4028f7d9bef91b9dd5bdb9a3534114edde3396df634fd9e336dacdbf7f843dda98e560cc324b0e9aa63c028aa35bfc3dbb8116a7fa9cc252fa4d1e1958b0c78a0e26b124896da7eadb3a28beb4456cb72293d2188dd4a935f28834e9d01e322958b4ba11dbf342ce894da5b7a73912680cae0097b161d1c4ecdbc83b570b83a3d7b27f819d7880fe332ddebdef5e203cd79781e8d0468c884a351decbeaee19ac279c3377c244bcbfa3561f8c3b824c83c4dc68712e2e32ee2ffcf7c0165b25235b435cc88280a9dbdbbcaf8cb83c82f5010283b6e3a04e80d5ed190ff00acf006b7a235a3ef4843530cf2d8bc941abcc9221781f06a01c0d55062fc2fa431b9216a90c704a2cb8cc7f13f1478cd6988b3285cebe6c4e723c149841c959b5a1b7fd49a7f8ef3dc2a065eff883f175681986122be1abda37dde7d52d26d58aa73dfd31710d199be74ec049bbf403fc5927be11842ba9ebf740cd09da6084633b4174c1b2fc9596f2bfb5c32a37da3273a2c93683bb3925630c3ade5a3b012b526ae2328b87230949334e56fa6e935238a1c8edf52fb25e735473e195fa41bf1edbf898464045bae200e605298272e224113df392b5cada40f6d1c92a4482849114051e3556aa19488773e287528d111df31ce18298761a8d6f58fb622aa5c1377bc1f6db9a6bc03707176084300bf68637caf0f7c105164da18e0c3b6ceb6ad27e741d61a947d240ce2529d0366ec00c230609f730b98b4950bb9211bae1165284300269f38396076a187bd90b21c534b632a649772c5b93d77d91b7223317a0960540dac0c5a0da697f5a12e2e0954a122573dfb0e52df9d5c9b8cec269ca42dec38669efcc900ce34ad75bb47e12cb0b533d733e5cd086533a93cd462bbc43eeaad47db3af1c2bea53cd04b455733ca41bc77bfa15728aa72970707741bdc7123fb9483f824e707fe318f72140227408517e62d76dd70b5a460034c312c7015c8133d4066ad81acb1b51c93c4f8b1f5b9e335dad2ca4ec40f63e54bd96dab840c9db15ab1c29307134e366c0c7626b1c74d262766a886ce58666c5b94f270a4feb6ffac74f09a99da37aac85ac836d8d2a1a7c0c8266e293a568db3a57ad036103d3928bb1b89e6db741963c6ce834d4c266795410ecb6fc9014df670943c1cac0b9dbb4cf958aa6440f2ecf5d4798ca263a5849e221840b22950a1078ab9129ebd0f69a02b9ffd1492da7b67e7a4ce356cc10aee20c1f23c9b000ae1b9082bbbf89088193b4c8e7d71161e52758d73ae7327de0d1de01f2dd914ced0001154e3a9b687b0b028a91ca4d978879f16c333167a11044d90efd3f8636bbd78ef0eec6e23488edaf6ff6dbbd1071f3ac67a7a77160504d63d024b9d31b8f14e8cbdd612e25efa48884e5d48914855949a78026f0cfdb8b64c4d38686ec2821d5b24052f61cbe9147af5b861c545725f5d0b4849bb14fbffb0758ad3279a6f6f937b273d0407d301241adf1d15366c4d747b44dd5514356aec5184796f24ae7a28063c93ff60bb9dbdc5099ae5622c70e8a1350ee8cb0f8cb03074bdeb2526f75f94e5d16361ee29d0a5550931bba022d193a71f38c7f3a9b821c2e4f26b1bd5350b07c046221ab596bd2d13dccc6d8deda4d6433fabaf4abd69b53f6f0633f23f63476e82d76b7131fd3478b5a8e21c1f3ccabd2e55bc34c876611d156be072ee183c5d90f8f047580d7a7a79d6e25c2f275ebb32a24a2a4f56ef1c6df3091f54683f46c04cee03e1f352f888524e8028296288ced29599bf769d468e354ad188380bdfa310237c2c7b1d5ae70b1b1f43f19e68ef80e301005fed9879d25f7d8f6a8ac5b368eda5b1078259898243fa857918e7affe2e0bf5bd92ea26e9468a09a188aca0694f4548b5e7ae15092c195c5762f87d351cd464cc2314bf7e88262b77472e760b69e09729273d8ea535f9afdb9782cd173bbbff097a11491004eb7729f3c1959451c16f1b65226c6cb3ec341fc46c227114d56c937bf29389431d03c95dca2ea40e5aaee624261a3dfa88459f96aee24c43c3acc77a30c84ea90eb7c13dccac7bf312de55d1d23076e546223c57a5baa2b96f526484a488977ae978f91d6471549761387cc759a741489df9d4dcfd04fd1fd515dd7143d6906691c28860a21ca8689339d9cecc8c37a071e127cc24095482b5e479683a3364a961baad5bea00a361fcdcb78b0c803d0c0e4304938b9cd85237fc8c6b250e8ecc0d0e1c14bfecee3c5b0bf8d4ec597625098f526f67380e918fc0cbf5d87b597d11f45ad68737432d11ab7cbea2445e1fa80615c1a43f690c8fc0cbed7cd3a62fb5e7d2f2fb5ca6eb42f2f1187742dff84e12df28ff62ef68cbf3218169b2a0d90e469821bbd9e40a2d2ed14b0ef89bac4c81f9bbb1cec13393dee34e31263c6b2ad5a199411310d8f8778ea2f69b12a78c097b4eda6d4112299726e5e8d961a3006fbf17282a7c8cca7db4a4a508e3b6ced8965bde42fd9182e847f6e4aefd734f43c0d779f1068dbc454283cf7a4c95a7af762cf3dc829f7d28fb2c79ab6dbfed6c13701db30d246d6efd7a65ab867c73696aa8a8e857d2d96e011ad1d32c4277be3bbd8341b27f33a1ed37541480df783c0f6ebf0dd7208281c7f0e80a94a67bf90de7c5411ab08664bff18e28f2f252ba9da3a4fea331c01fe75241046eb339b4b110e9913e520d4bce0d9162d32f5e8db89cbdf54ed76d3bcacc408e7d3d3f141d362d284eb1dc75aaa5bfe82f6ca34743fed573a34225756b65f2eeacc14ff972dc4b8114071afe345607140dde2e5a15dcccec3abf894c6cb938bc67400c4b929b152c9fb0c3e429c291652a50d90a0af4ca560037f6d288fb8833f9a86d9002293ff01219455f544ba55b34a830b564d1239f9b0323b07cadf75e10d02b64ae2ebf1adb552fee82d63b25f18eca3fa80a1b72f20462c417f05192145402194ef434e0d6a1b14e2ba3140a15db84ee10fe38e1b7d3efb44e29dc0395c3f0ec62e9f2fdb790dbb4d5272a428d9c08e40c146f0c27e58893764389f6518b25b991e10c2242c60c3cae25aafe1b15bd102879acde2385d8bb0575d16d90848a01f297d6a655a65614ee8a8e60cc9efbc6b347020891882091cc02d040e3afaa56a33de2b4bed62af100a3a6ed500e7744f4e4aadcb6ac0c35bcd3b0846ab74606565bfe67ff94ceb22f2e37286b9fecaa87427d79d0792355402adec08bc497fedaea22256684a7138d9d37c61264902354b6bb049d39c65758bb6a67b95afe9ca0d3fb44fcb09f501c83f10edfecb7310473467390dff070ea15519d6105700f15cf6924805d4867c3bf68ff05e60420a069da7b6f948560a3c085e8a889501c4f11b4242a81b2c74b9c3cc47fa069da62ef0c61a9414ac25d89f4df06c347219a81295817cb14c271a99664a24f79d4ab8af04aac929f63589ecb455339ddd5c2cd686424d3abfa5aef8c931b05d10919827ed8a38a93b0378327396f4813b1136d9c58bf63cf8cf31e33e7e7972369888759102e3526dad28824e7cc83ab30e635f67a9e49f8b451da281315a5f52efabb23397e26632c3769060b1ca30d77635d8d8071200917395497ecf34eb1704d9aec1369e37398253b1536259f44b21779d4511c5c8cfd59e46e4fa043e6ea5a8415be8601f17bf2d83ea346ec287dd90f5ddfa6a20111a0a11a0908f2d79e8c21bf030b7e8e2ba326249a543a20c18b3977ba487b32cc9f74fed3f53b33aacb40c11ca65dfd20777f41054ad164931f88df5899bca80cb1def42931b477ec80a180ffece0e959849bffb489b1e3f6a5fbcfd1e46085caa7f332af7060a5b22c91dbb0b164531a79b66134267f8eccf59f731e4dae7186ff9edcc927f75109d1a1c268de869f6a9b85bc40e3c50ebf93d438ed3aa40d89fde48e9cd186d738f63363738091ecb589fc14b36ac973ce8a663a21795102ba29a5521972d1272d69085d0c39348bd38e3e7b8f7dd51277dd3e93161134dc90e83aabfa89ac7aa1682e7000fcc51b45586dd1588d6965196cf34281a77ec38833be35f8499d8b39493d7298431ab0e411ebd9561d6f7f20026c1b586cdaef66af5aa29e245b3ae858049e25b4ea656fd7d90bcb131a0e7d162ecccc98ee2a492cc08d963934d3380d2e7fb7213920ac4bbbf9c7dd55fc3d23e4c9b42ed62ae771444f027b3a831ccb4c46f395482994c8370d892ccb0be080896f884587426e56d4f764b5e03dd1d9ae8775a065e422c6879950942056b3f0bbe835b6bee337e8773c85b2517085e125c0ac80941a7ee70e4cb5e4f5f2f1a72e31881df0f9d258bb848aa31b5248fc0dc6aad88140abe04f563e1b3cca6330b1e3e24f98ae2cbf821b3beddc2b2b0526a6499d21143305436f5630313bb47e54a1e50631e3e8015bf6a243ef36782c37cecbbb811919e0748dc839c6f72bd6a93b81262bb2d0842f9ef9ac2d331ba6ef132827f816b21983f9cc53c51de4a8ebe2f41a559d49a9f387dd0401676cc354f0861a0b435dde8d6723eb8e142c7a9d250f5c76f4e0bdc4ed5a7b382ae6f51e80af02a777c45fccccdf077fc69a04d2021ca704c74f956b6be8d3b8823a0ca394dca8e2041ac7a4907dfd7800e760481f7754d38f60e1d365ae0db566625443ac989db871b75f6d3b6db102c07f14a166904cac00313d3c731eb5f2cbe8402598b447fe275c068c9081b54a0f64a15e806ec59c937d2c26b7773aca340586708e37aa7189108def0e6eed123a2f0df6e05010109bb75d8e17304b6edf8fb5323c7aa67f2552413a2f1a3b104f1fd5fd4d301df2e55799364b8e187fecbc8d4656b8e1552145e6ec7b9956b9b8a259cfbf571e334175a49dd7c075d2a3d7cab876b456cc6a094a440c14190d5dc7745eaf8cd470f95e67e97a8d6453195a6f6ab0063a79b5faa4ec510fff49700029cd7862d07c82b0117fdf66a73f7e66297b9c48c4fab81f659b7143e024a9dd6dde2ca5540da10f21ddbab59f922cd51cd65ce57b44c875483f4c151d20eab0371aac251394f81ebe26c60f6dd179bd6122fed18ae01e4f0ce2821531c7a2c29d11c11d160312dacc6fa1bcbe6210af137cbc12238fecd0a59caf8e919999c55a395e1568406a97bfd516fa889fb8f2d0ed0cd7cdf14161964d2c8b60adbab858412c33a0510c7c6439d6aa3b7262305e4ee9baa21226ae143cd5f36e1f12b48fb25a1979efedc0aa76a629b09506d0c9d0ec7939522fb6c93bf24d9c3898f7927c565a6e0cb902c5be5f5de277cd37c10b094b307cc1c54e7c547568808266a511d903439da789ad17fea8fae2dd592965aa8d4db9e2b5dd1c7653a81c3bdd7bb728fe396e5a92f995a4270a782a2181c4a1c8dbe907cb23990771c4a4d8074d7475c7dc208b78ad30b9163cc3c6a4d0809a8fa2fe2374cd820a51f6bf68eaa887b446ebb0f546634930c1ad7e1f109e8196f016793fb96487dbaded85636d227433008d6697bbc880744cb9654212343d39120cb4855f82e3a7e8b39de20e2bc442ee15a2b5751c0df2eede93477ba73c2df11d0536ed7cf68688bb8ebb2630fd007752396ef3895ee172acf1d4e719196b27abc89eaabf615247a72ce74d44a1707b9b407abdafb2e46f99392db1955a1340db96f0e1453e0b12704fa6f26672f5464b3d943905c70b7d96d37269c86c2ba7c9a9c010da000d8b403d3f4095984a13fa84c4604e41f33c02191fc461be09d5bc681698c2b3a4e851dcd5a740c9a32a7dc13794b08ecdcab0fe0283867e93a8c5332fd0b9618c10f1657a49f8617a7ba8cd7efe8c07de78f62b7749e871f6eaa33f4cb31a81ceabfcc4cc1c049c706267fe84c19c8bb58b4c166609f06ee78f6d1ac9ddbeb51ab74a9c17003b9f1d79f3a49c67781d6579f9e4758a0b803a992d2e2f15d13ed8c378fbeee8f1e46384cfbbd52f1d1f9e95b1ea1d564b30b7e4b6adea792e1714104d2eb48658255c69d34dfc2c82e31b390a5e806021a3f5968b6f354eecd6d1043675c9bc6cb62902f1d3578672313eada897386361a56ae82089282a9a61dfeb4c27bbe7ec394b1702f492a132424f013d3f2afa7a954943cd815371672d84f037b83d3483e0f45650f74fdb900a859a6f9ebec23bfb1ff5e73dba4b14314a9d0f5bc7b9622e14a9e15889ce068a08540281f56388c69f2dd103212f8f704b837c5456ea4f40b21545e15e025071c8dec177071d812bde2f0b950f46a97c90f2fd8198c02815b11b6a92f43719807f96a55b19a681b9e219e2fe94acbaab425863436566b2964fb6af6da131180a7f4","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
