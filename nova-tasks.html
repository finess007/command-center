<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8b71a8142a23216c5292848e14f942b94a72cadc2f61e573fb6864226fa694a17f9530f508450a80f8b86d08a6e51a60f8e777a967a39d4b7b50baab108215534625624ef0ef9c75e6417c03a6154032d0e7f5c3ca5b9e8daf7cfae64cf3db271b87a4b01616ca77d7995fcc6f0b1b46b937f7c5c0e2ecf73dd4de02ceac761c18d253e11ec32a481952bdd207aa8ef50a90380a0acb31263462d030ce0113e19e68c030923ab237fa3d8a7854d41592f3f16663868b65b7c2585d5469388c4a58d0e456b8e2e5592d211def1e84ce709d030e73072cb8ba6777f61a58f7211baa99f8edca95da0ede18a3f84a3957b0700e6d29b8fba570a7b6365b4a8708f674efac5fcbff4bd0efe842887fe219732d8e1b7eab463690b169d70adea3c589c826280e7a3139a248cb1352de66ad013e6f106888f54dbc536cbc9be470de064c09b29c5e4976b53ed60f1c23dbd9ca5956423026e15a4380cfac88d0b1c9557de44ee4f38f0b5d69cf6c2ed3a489eddfa473de87b56f5d6ba150f3990a0956289aba4420da539ae1a094ed16f8fe071c67a871f4356a305e7cbaaabca68f4e603e0e3dd6808f21ac6a818d4873fa9861b813dfb2cf3bdbec6620d984460cbfcdcdbcd6ef7238d1b50b80cff70068f39e19d61fef230dba1a9fed613511b827288dcc033a3e0662a1a4c9c987d623a58a151ccbea29adee592e5b8ce331e6ce6f9b1f44e84849fda5c152a89b8ac74cdc21036401cfe674d0d3f55deb829b8151cbf292de7df21b3241344ae6c47d432271a36a69fdbab47455c3119a5ae819195a3997d07a384eb95cf2e4b2cc2f976de3db921eeac84429b26a5e8a028ca92d160f17780c1b77ebf8a21ba79ab936209132a1d4e93f313daa9bb2329a099d9847403d91deb2ba7219ec36b6825cb100ec16c5d4f238271e5e74d8d58f27565465aa96bf052cc60481984557760880bb6d00388adea56f68b28321a69ddd419ff27d4b2fbeb6bc7cc730c0e73a957048d2d650464d4ce7dfb4fc87c975f8fe605c319678235d55c3336c2193ffea07fb0ca11ab18cdfe2519e505f15944ae76a06f51fd8c0feeb6f77c3151d434af9042666af1f0c70437c5ce59b81c3c6a724f715c71006bb1bfa7a6584a2941f2d97373f92315cb09d45ec7bc3ea46b9602fb0f909bf185949c16504b79940ac63259b2f059b2580d93fe6514a65095498fd481ffdcd4fc9a5d77d88585aa8223d32507323784250302cf67d77aa4e4936556a98ddb474989cce5bb5171635d10f1eb8d98638adb55906cf9ae8a5cee17ebae8bc032e1b86baf482c2d879b9701a73b91179cd3f1be0865a3de34342ba24cc45185d4365812baafaebfbe8d52a16e177811d5eb19c3481cc055943af8ac41c178cb5d92d7646c9b1e7d6ef47cbcf362bee8292aee9675f3259f0df94577ec4fd55e02921eeb6b8fc9e5b37531635671ceaaf0825ce5e8a5f0c9fb0daf3071cfb45b6d4fa12c4a61c44bdbbf01abc98523c0136ac2fe9c3c0ba24666173f8c2c4ceb8f338eb35665b607cdbeec737c3935416ed50b75fdbf90f57da77e6bda2b0f191c1ee0dd9f70bd4fe34769cfcbb6d8851c1406095cc5e8ab7a9e85e7643a593c59bdde4a3f6f9c2d0c2337ff7a6d6705cc3cda93123b97b75c03c5eb5f6e05889be6396fed9c283085b27aef1cf6f26077927432b72458fc01125b7d501e9eaef8cbaff89e0c4d7cfff291def2bde90902e72358244f6bf31c3b21b17137209f88f942c852d2dfe02f5fec49fab1a34ec38cefd32f8153ccf0e1279e5543a82e0a5ac8c7b30b550d4acffaeb634b623f2f8d036bea7e2c93fd93330cfb1ce15929ed027bdfe69763a8d20e72fd866c410996f914a54addb004e9518fcccf28df18bdd9afebcf6615015918230822f587ee6103a533f2a09bb2dd1efe9a7cf9997cd2220836e461c83e04d6371c0ddf0b8942fb6cf3c6c67b6a530a66aa7d9bc867a55fc0df2e1959a8806b5d460bd55c3f9680a7d1310b6b34e292bde017bbded29dc7c840a6f1f2505da32c2d6bb5072fbf5c219c0a9b050905ed7bff787ce17754dc57bc46cfb37737eecb0a1ac1536729f90f4ff76c46f1b340396828a45afd31e530b812c6fad9ec9dda280c7d3d33982bd0aa0dd0cbd8d28ec4c2ae75b232d553fb861ca736a048015d737edf824ca120586e8c7f12bf1ade816b22dcf83883feedd17f072c244604b86226007372d35e57e949a47a58554d683c80160b5f21481a5ea522330a0ce690bf3ff282ee6f9ec37901464564eed04edff1a5068604251ad971bfee451c6c303cc55c189b8c9e0b95a34b109f4ba3b8a3742ae987b98109fa58da41b1b2082870b553668d24f65a8e61f03abb533f4f1372a7588ab0dc03c8ad034860ceb13400a5e752d68c70989004b203934ba1875fdfde90cc65822cf5e89254a8c9417dda0abce40a0198a6ad8396bb4984217b228f75c4adcdf2afb58db0208891149fd4f3be3f2e6f4f0111e1423a16f4a72767d8fb0c20bc14ad50b337714e3140daf6954232852e9003aa976fd30c40d7123a1fa691b67ad5bf355e5bb091ce35e5309a8fda910883f498d1842535cd6ed54b5c81da5ba054785cc4286af07143b1e857a3244fbdb436cc1e0a25863034f2904ae01fa87ffb53a207bc5939677e7a9572098df0dc9f1bedc58017ba6daf9cb65b9b3bcdf70a2b6f8c06634470558d44e5ea851c338a13d36373190badb739fdef40a03583274dc6250f4cd005b38cf2bfd9e349461bce1f0591db4f6d08340a741eec67e9cb4b83b8b27970bf23b7cf633915c8a23b11fc9aee8711d5c62ff0391366ecf3205202a3e0f8b00f6106a3863504e34bb1998434871bbb5d837dde64cd6b7037ffa9d1e25353b84f65aa4c4f3d12e1594a8f84d8b7f611bea9221b849054d051e64bba281ba8d7e7520de9be535f7cc0ec99a1a3adfe1a885171ce6716eaf42d6e11461327bcbebf3585799109bdc5211f947f410944d89628a35a3d998b693c0c9f259aaff65b09aba1f3507ec2ffaa5843eabee113eaf7db72765cecceb395e9e620fc1377a6e10fc7439bbb3bf77b4476ff787b6d75eab07556b81c1eb359d720aa6e5a3c6b737f80a66fa82933ef5f6977ea0020b08ee4d519af0c4e745a9b25f6362a7f62dbf2d266dd0ad61dacda1333c301ee4794821c879962d8850e114387caa0ffd14a0b8385c31347eddef65f982e3597d936b6f0d10770120ede576c2c9554c9071020bc3bd6ba29d2cd6407e04d0c53b27d07717ba50bc98af41effdf77e402305b7bd33ff9064e6bea8a1f5289fc03ea1c7f6ae4997a2e74ebca52a1cada84667b5089d4834e2534843f08c416a351de6e93e3cf588f9a0531e1bfd85f62d405c3c4880d2e76770571fee8ae440d39cf1c19c5697dcab75d4d5c687645c623b31941c4f08c0415d49bfba8dddfdf98a0704de502df4b703e20da03ebcf6ad8ced489c6c2327cf6d6d36f010908064ee6bb9ae241c7e7bc164106bec22c0de41218230d46dc281012f3aacad7b3b18277228d5e60f8fd519e8f3ed48c09cb7e66b716987361196fafddcd39010825188414b09f1a0c31e655e51d7ad5a017ddd4bdcfc8d7b31a3d2d2f951426c86b1bd00527d56f6e21544a0524acef53c31499e5483d666d221d5d700d9e9c7caf40469b4611ad0a6890b2c8a5fe97b5b5f5ef0c033fe62004802e81d8779660363b4066f6c1a9fc6011527768fcb8a3acb178a5fcebe475516604e7e3e4fba53ff208abb5cc554ae7b0c812e144b6aa2ee11e7a2e6edace0b8739a6c219e76258137dfa44f09bc4a8bad5c32f9a48b49a290650340baf0e720409ed0b12c052c2abf94f3ca7adec86c146e45c5e6c19bf30b24d85c38f49eb5fc2195da0ac9d6791947ee2780599cf46ef728c2306e67424aa621f480974cdacac4a9dfbafc16aeccb467e3c10b2be0359e111d1978a716d85fbe4e45151f533a33ba8490651067f607714c5a331046833af114f94b879893273b50200f834cbbce362ff9ead270e007e9d2c4316e1513a527f76af9de80f690912b9205bbd60a7f2fb17b6c52d45fa131c281be4776ce932152d832261d65ea59939aa38d17a0d6c24a3dd15c6d116cd7fc46a44690b068b7bc1fa423e63d6763c786950e35165560e5309eb843562661ade6b945414c048b5c295729e24df56e1a52ee33c6ef7da99b68ad6a6d936b74fcff02b0462ea4e94a4fb9375b7dd2e60d78917abe11ba3035f01c6ba5e29a6133f9310f1060736001c61832801eb96bcc74f3b69956042408a24157bf644a75eef8a05dcd2e2c8baef0d535b6a0aa4c2b2bc4db128af911a9aab1e0f8adf6270a0786a3bfc483b88848553c2e919d9d90fef8402e5564d0caea8c5b5f20bac819896708a48901a16ad9854b9826532da643c82008d301321c87c46412d01a2d00eb13c532ab7443daf5ba5c96b53a7033a58b63d1c64fe9d3e1e7a960de88f8a0da5ee4c4e3eb04095a1bb74bfbed5b5885fa6d81dc0c4336ceda7e6872d8e52cc6d1a74d0cd85acab199ff197c96fa0b31193f86c7880ad75dcd88189e26e2ffe115f2068b37f85c48b5e48a8b1b03326b2d8d69eaaac113f84f62fc0f1db96e7f44e93b2e7ea1cca050dfd4201c5691bbc5ccb5aa34ca1ac1364c3f84d79eb01725a25936c7613b3e9cd64e8ed5c1fcc695c71439823482a2999c6898deb9f17b337ea68e1eddbf6160b66e86da5e3125f91c2a61c22e0a9207f4ca404440b184c1b57852c26b152691bd339981f10dc9ad24a3e8c63f2f725c6b495f1cb5972f13fa3e9ebc7fa27a6a762372365d006846231dc57b58164107722962be22c31977157fe7ff0e268af119055b40ee5c8b09075a2211e933eb46d45975d6ba41e4ddfd3bbe9d0f2be98eda7aa0ecf685c2bf2c107139693038dc110b55a65aaac8add582547e0dc31d751e7fdb93ea6bb363d544ca6c93b9dc93471d51a0f41cc33dc1dd61f47a774063c0fa8429f03b29389e9f102f435cbc8e36c12879278e6de0ba4ccf208539dffe6d0dec135e475cc883f2d7c87a6499903bb9678c0bf1e2c6b837f25338a4fbcf841b94391ce3a3ccea8250c4bac724d90a2b038173550917aa7de9d7630b68bb591e793d8ea434bdc64a9b58ff6f3381d39b49501245a3595fbe4b79a275219747030ae9d5d6f6b2f5b88b8f7baf9384c15b020422903b7f7d51879d1f01d5506c9bdf1ef8be272f8ffa64eb5be3d182c8dcc236eb7c8fa65c43bf8c2845a07a7c7f43148a3259abe24c33d7e7c7aaa8f05818facf8443b8e2386f5e23cf96053dda47adc54ae9fbd98f59daae7116f342ccb063d7c9e7fb1656c1f9ae4c184bd54d16fa0e06a3c13aa1c60c2e4ca1844d6edc5f59fe29b36b60d2e7cb3483ddd98f3ee9c93eecdf8f1328f4f48fcdfaefd9b7cccd506168a9d602e852b5c0f3ea9cd01e3cfdd8ac3709c962fcbb94819bed5c951e816bab7afaee18f5c65a7052f352fe0b3719fd207759e748f4a5206fbfd83f5b30eef4e21e58eb1adde5e5dbfb79c81051e4d7dcdb24bb851e7d41dca19688506c3c87c747bef4e722b305f9ef1738e2b3eaa4a06ad99bc7058a6a60f6e167a8f24dbae901dd6a4c54694db5a0dcae830387f8176163c167e2c99e6c998d58ef02aba6d4b8ed8af52e2de8b649c303aa9832de4c99e3e9b37f3469c23dcebc0603eb6d1c9ceb8efa810c1588cd2da4ea4c5a2da390a5bd8bd3a4b9bf208b326790a680ea9f72e272ffbd1a80fb53cbdac96291dc61571c3300750e5c42f49b48b1172ed05d6d7cb787cac95e3dde61fbb31b59fe217251a9e26d1647e6764936f8153ca60d87c8554fa0b2f70d5ca156264b123bd85dd0a84cffafdf8d13c1688bdef8338c50a0d4712b6db1055baeeadf74a7a60c186dbf29394b81294e2827cbfc11331017cd7a04c766fce7a2243e0cb4b028683ace9b47ca31fb1ac2949378b95586cb6620fca80ce47fab6ea069e73f01dfdb1118c6585a814b4d1470b1e51418616f698fe759b6c658a29602fa3a9d0873c6d5af9a98a5fe8d71153a1b6abfe219b70d324def3dd43822257b8263201e493cfb8226843c92bff7cfc00cc9d06276bdffd612bb1d9d6e78ad42ea5cb13522170632da6b9025a79eff7ef584ef83bb689ad6d0ba42b275a4df63ee12543e447fde1c47357576d6478e1952e4c67d8f51d1424677a66ecbbd81e1d87795aaf671ec9a94dbbdb6d40cc32a277b948b222e3ec11c734208e8084a2f15b25f5df9c4b722f0adf8b7d4b3f2dfd06a64eb15d665dec6beecda139e4efd3c1732060884562b71f0c4091fd7f4ab95ecfb31f7c3250a19b63f70e5ed1404e408bc83342709c5844d967afb58c41d155f6a7cbdf79660c6acc0a1344521cf8fc14f9ca46397b8c9e6c835cbd9b2a64175c83542bfec2912ab312f6e8156b81975c6e1d6f0bb0ec004f41b3089172c2406cc1e310a47706711ecf7bc6a4cb730600318a82cede1df34d6d9466ed4f5e68dfd5a78850a0b66eea8dd8f6cbfde5de96e6e00076efc2b54776c27907cdec0ea53e8f51cc0cf2081743bb5345ef4ae82623708dbccdd680a6c6658da3adad34ee3cbf4a487272399e67d70f19a5c3822eb3b03a3e766261e549ee35ba883cea80432f6850cc6997737f32a1308f739cae220948e5b8b6af6cf8a67a8fb0cd9074293c59eaf95952e317ea337f24edc27b8b9863a33b0df78f779cc880817156fbe7d6f1958836a009c2c7aa892adebe662aeabc3ca4e0643a8ba9b84fc22c5536c5abcb26e65a9c6bc110c51b1f68507aa8b1bcff9257b8752035daad6d15b4f023f9b4c63ac5aec5decaa60a4576ffc4dee91f6c15e2ee86479084f7dc2c044445ed3cc5e866dbabe78f6ee9580e1f71dea2debc287fe5c64e732bac277027aad4f95256515f5d543132565425e949946c95902ac9a73e21976bcb3b18aad3eaafced1b476d944d01f94d4d04777b5f63321298c02f7653d69e9383ba7042f4077422928729c38265711631243e3fa76cdf08057fbebca5db748762257b41344e07ae39d0c1f67103dc02f4b349fae601d1adb3548c30ab7e6bc4da9e05f45027a33e3c01bc0bbc0380f814c760f4d44378efb50663aa01f69eaa653975b22da8532425e93e7dff0c953fc1be3cc337315ea2ff208ee28dc3a18e42853afeee7f0b8ae7b4edd6e3724442356541e24cacbc94daee9de3b469411d53c0f46e7ad9c3407557c962f211176a5812ab1eac41a92523c9e0969cecad2c703db1bd330445c327f8d40987e8b88377a990b42eb5268503405a131498ae61daf0f585e395fb013e6dc1da8302167983d628060a2baebb44f864b4a4a28b5050aea139284353698c26c2ce2c8b449fd9c1b68dfe4de02b5cb9db8eb3ce61a4942b779613280b08f991723667d826556feced347ff639207331fecae640a00d6adfe6cf3061b177d71f6ab3efebbe6164fccfcfe4377e4e37d1b883461dcb35553bb2e69acbc12c82da0f7d9659a7573576cca615a58b38343671409c80f08541b8784c52db72022ec79555b09588f3a375f4cf002bdf204cbd4ba8123308241fd4f703b74515a0c1c69550cf5306b8979c94456d42038b86cffed10b5f42c6cd606a3cbee3d60d4000d62ea81f12cae9183b0dd0912062e286997b98bdcf49402ac261487022c17360a39023b36161ae5652deab4321909c4df3e95bc4bfaf9036a11afbce841813f3e3a2aeee8a67dfe1e49428d48d774d8ba28a1f17cd9218c7268c8b0a892a5e1eae67acdd3d68e259955e005a238830ec03848ab1bf8c50b9a79faa6711b313d13af4a5fa727acd52ce496625b6a0f298a564d284ed866f96e9fe09ae205cfa0c703466efeea50b7a0a9b5e7a5ac0678b38153f7717931cb2447b6ec3bbd4f9646f18adb5c228eeb089bd4d23350eee6cc21a87314ef4ac270316e502f6f1211d924818f82b07e29b27cbb5fc211f5b932605446521f5b5a5c078244d8c333b255e1240ec053201ff2d0404f56f8e65f88bf8f6c2f314e7b361db5f4832a74e142440c861c9b931458864fb87aa1397985e016491dbc332a1202964a0ff0f554bca37110a418db42ea6b7b0c05c0c4dfa2cc97760c3420213341a2f21aaaae7b25877b5afa7cb6d69bf55b40b2cf474a2b2ad1bb3ed1b607aa2259187ea9c360f6c801452e829363af7184a85e421fefbf06c826cce9c99d76f7069699a80de003908c8ad5e0800a7ee7ca2a0ba0080a0c61aacfb808234e83e5820e0a189569a9628852d107f5691b5f8675efd607f86d959f80944aa7f2bb9078db48a0ee62ec5d147ae9aa0c4e5dd86d2dd15948f8818ad756a5ad5c83c2b01282454f0fabc428f23b325caedd85cb3f5d005e1d9d49f9e3fe55e8bb4847dcfb685600eaff2cb333e40f49ebf8e9e784fc9bacdf8b50a9e7a16291a3277d1e05a454a222be60d551c2b8618c3c2d6f3c7b9c4b965f73933ba63f39697991d189b830c68b897863c1a234611da1106c760621de608f6ad698589a9ae1985de42eae8563fe3118051931aa021249d178e04c72ea205d04372aabed01c685217d8a53130e20b58dc970d65acc97334c6828f3d7444d190f5efdf7ac431fa5f1b9e108652fc02b9b5880673118d5217f5d0e62bb4db9cbeb8cc7621873b3325276d7e6d24b089e9bb1f643f804b4273310982171943f29309cb079938e01b2724e01aea7d7127a94342127447cb9ed934d7eea5b8ca650de0ab87ba4d527d6d6028d073e55b4476814c2324626729ca841b54da3d2b2a8316d9dbb49da05f47f4bf00df8095eebe5c8cdbcb9ad60f89bdbc24067f0eab43537dd80d293996a5762b9ca84cc651e3ae59af6c9fe63f0dfe2004458a2dd8644be898e12b24e7bbd1e8e4ca05585b3c6bbd963ad19465436ffa51a52d4507ba401110887df92f105c399ff4387f7d3131d3dd3beb1c7707f90844b598fa9084100c8c3520d3607308eef03a671175c16dca4682d48c3674c1e0380c97c1b5fabdadd419208fc416c0edbec41de1e2712325249821c2e24bca6f611ec292319a3e2b13954fab32ed740ea5a7d86d39e849769b2073966916d5e71f5a7ee9c57a0a990cde0db52f0f5232cdd79038a3a03a616c1cc546e4fc86621750aa082f6b12d4592e240f8bf41381ed8d9bacf91635b4621a9acffbc3be8fda8d0a2ec801e305153207228d90349616e2e2fa19570c85282456386a0861d1e7129b4f24efa8338a901a9a232047c0de6a55023818c319b96d4302ecf6a2c32de1a7bc1a36ff1fab9b81f8cca8bb626bf54016e22695ef6a71c22d4d89ec0288e2e5015632f97d986fa1d48a40b1273553711027b2c85ec089ba9782b623be1d1d382683776066c6efea4fd2b2694bc31c6e90c0de836a4afc235cc5da85337d571ff81e188853822bce2cd9f16cd6f2705fcb6eac7ca7088fd44ae19ef87b3ecef181762b406396fc58e284bee1057d3c4b68f8ea418d1a39f6d966bee87c7d7fcc56423c1b276bfcc2fbecd3a2133e5225a26c4af89d66a177ce3db0ac0657b15b9c9eceab28b4bffa397f5edafa2c98559af50e3c5f588906aeaf5b27b812e03ec5ee50b2cd899488911de72f402da0da8a85a89c17bedef4cc70af44c4b7138da51355da299f79d79ba889846650ef2bcec276536e110320ba8cba5fb1f506486da1159395490f7a15ab483520df4afbba6a80d21eab95746197a4b1bc7d23eee024c8ed70ba7f3472db14fd8ee1c2cf4b2673706f2f5d3d2a0e41a9b217c17f45b1914c81a2335267ffb0e24684fb875e08a9963341f73677f5fcfdad1d10fa802a7d7a2e5ac2af59f69151e7ef92fe16fe6563bc264622331bf79d324ca5f0481e1cdd5cf10b75af209ac02fbdce5df8497ecd35d97eef4ec8d916b76adccdf289f4f8d7f58049224cb48fefa0b836d3f4d1bf6e5d13f2f6495326076a0a26abc493728f7d311fd0dc63fbf58d21ea1966dd1d50d3fdecbaa690be62967ff5571f8b4413f1becc3490cb3a60e450a6abf27a8561ebd20240db4151e7aaf7f0d64c8a3144aae9f8a41636a147fed8eac608915e8b9d825da772103405a002979b453502ce1c3fd07510a6f601a5ea3c9254ba00665c4e0a8ae288cb2e6cf8b669900a7d1374f73e6532bf138ef952ba9c0f1979cb1fb28316f297ecec9df6d72054584a8ba6b2ccfa70cfcae71d7e2b0a30e6a38705e1733c61855a2937ce6f2515bb8725e580168589e7534569a71b3022ce4cabb7d68cf1203554f077189c4175d411141d1c41e44372e6e47b8bc6c7ec5424e849fe5608a3e31f8d40eb1f38573da8b0b1fe5fecc76b58785b2224eedc1ddb29a722abcf606ef610479dbd12f55e9b3db0420ff24395a0e61fb8fec60dc8422b1bd23908cb23bb03c56012cc6d7a06de0b97c7fb6e1e9c1a6e490c90a7867357db472ced7dbf14aabc58f4f70ef0fbef2e3c981c2973cd648371fcb052160a8005d157ce44e34a240f5af513fdef9523bfc822d23b89049bfb6d9857325caa547878b3341c40e6b0957d5c40a2832944a77d7253ed45f5fde07a8a0dce51b3e4de776175cf11f72ab4b2743f057353b165f1930750571c1daae78304604afb7ef874a08f93f447bf822f33e9ca327d44ab44608ff505bee027afd2d0c672200a44a9b1b50387c1c7eef33a09110d99196a1a10c0d0713ec1e242199c26c7f75b1a6ea9863b0c718584fac48ec37624e9bdbbbd10e02e09202683bf7121a1155259f29ecfbef22bcd729cd41622c1656022e7992ca7e108fa1a328d0ffe90cabf02130097158c686d6cc0def0125f31a98ce9aa91e412784269c1b24626d71517d2b6ec42a6e221df0f7bc28300d23592f37d1da345524bc9ac600ab07aefd42dc7b62920ebe6b2b9a3699c7dec8069f3b5fb31e6f18b3c726fa9febbf984a43aed93337419690f7d38be35aac357593b50cea148d9d08dfba8f16226f2ae60006153ecdca47ebf08f048b4f3ae58d36821c7bf2ae58441996c22c77b2fe4413f7d611f3546d590c3647d9ef8880d7814dbf1a0ae47546579f915bc865cc8bdd6572250636fb4055a3e1d9f86d2538a8e51fd0aece6e1061bc9358bcb62bd3e1cc82db24b6e0d378a255f55263cd39bddb95baa909f0c332b7fbb768e8bc6fbd7029c3c9a69f7efbd0eba7fd6c394ee84cd40b03ba88b366b6ce429f568ffd55738a51519e7eaa124ef2a3d587f4011f368a723c4a562629154a8bec0a913abc3ef60877d5b3bad8df6b3b34fbc03daad6cea8726104b02a9cb1d9452d55b3548ae043a01177a438115c2715e815c9376868bd9720677c419d4503b190d66bd0fc2eb72a035b4e9ac1769bc3b9b4f6ce33b83c05500a644f9d0a2df01fb7f0bfcfa329c9736cd42effdf3be538dbe94f47d83a79684b8f077bfca2201a2857333472a43a3aaefb85927b9d3f00dcc9f3396b39d9c1ea0e9b1e399d509caaaeb3335aebe7236e84c2ab23ab6d2a190502b501d25468931ec400878ccced28577d4fde83f68002d274e53beb1d9d569e4683c8db535272b7c04219c51a091981b2ecc5a4231377579ffc59fe102d481c560bc3cdc557acb3be1754b6a73b489a4620bf29f9cab7ad9842547a176b57fdf22632dfb8bbea8a7e64c66f7375454e40e21d1cb8561403a3d7f894e194d211413b1d00638c87927c7f8402b2aa267dffc2fafbba2c01d6b1770e8ed0849b07149c6ac8e215a5f88c70a98b735a56c7ed5cf6caf465413f1cb2e4ff7d8fd8fc54c515718193180ade25528a2199bc43f668bb973519ead4438b507e420962c0d23c8fdf8cf44a508653cfca2ac9e651112f19a800f168d4fec608a81278efcff1fd7ba127f902bf8be33d842536b7f3abb3142eaac8db25c4c503357debac8ea58ecb9a81f5f988ba31d65f0eb344548b0efd635df5d582a3270bc52456c8fb5b2b8773c065097306e3d1f1c09a4a68d55d334934ff23dea70961eec48e5212599363347b6c1b737ce5951dbf40c3612d0283ab05fed63535f01dc2c8659c32e0eb8a86e7871f1fe6ad6f6895574c2f7b9a7f1f96f351ed0433a8f7a961648e95c36a2c40b22cf0c75c56df02f29d6d7c99ed8dbf2639be940fc81083fd0e1971ce75c71d2091ab925563bb9eee030e62ab762b9a90e6532429bcafe06cc26f221b15fd7c912c32da9c2c81ec15a33e0660acbd4e7ef812a46e8ef67a8ba55ceada37576630cda8f763e70dadb37a429168576d8fd36c97a4bae9703a56c9f014a2f9d4ff4047a8171c1d8eb58b35084d913ccff437e0c002f8c85115e5030aa6087e72cd18d8a669d9f3bb8ff645faf0c67474b9d9f555567c0e3bc32e884e11f2c2ce8819c883d58ec683ead2e39bf539149ea32f83d5ac1e09c89a8a4e59ed16d8ff24f23597df6c220e2d5ae024a5e6e64b67f9672a1a598ac96578cf29260808ab7f0be7cb51695e670571c58822b3e5371112da431bcb0bb954d80fc8cd166e2cbc7e8b505a1599cb3fbda3e1756f1f258f58f2217639870ba736bba120f5c1ecf43f44de53e8858b0bcabab0677b360e47d8c7e53380289fa25252a23e772ca00fb0c4d2f515a25b2c2da6745bc02d6651313a25f04f9de6b32f88ba6e70353702031ca2a0934d38df47180d712d80457081ecf82e875ffb628e15d9f4c39c9e6ef64f3fba73607612fb871da3d305bcda9ac35d70a5e995bf06025e3ad4b353dae6c4657083dfe8dfcb70b0a02bc4b90cf817656e3726bff54425010cf04cc83f9213b49ad4bc70c35e1511a234256092f69af1f8a837d93dd19599e68a269cdf50c25ad7ddce36de38291f2a1372fa956a5807264d6bc004e044b76baebe444282d707303d0ec8ef4ebb2c6b0abd67bfcaf3714aefeca96ecf234ef6597073105757289567ff2a8fa006238746b21cdbe59e45eda2a07de5b56ec905e7935864907575e7d03a38306409108d0801339312529868d41b26ceebb4c5a258d79f9cc4ecdd00b14024fc39954a996130dc4a0e89fb5231b203279502ae0cde21bc877f85582eafe584cb272c145a2b82ad6e93171f2f22c066a6ae005fb29e1460b110da3c236169eed46764a01fa97cbeb0a678b7276194619873d702c83efc4c25600e75b29c6ea286cbf88b1d04b79c58deecd42757a3dd0a31b30c75215ef3bfadc009a6c95ee1829dcd42c5b4515429b3064ed613730387a2a340c24d25ba535b72331473eafdebe23a4470331347eb0e9b268b6233d4c1989a15a3803509da2ddde48dc1977e24e4fd391da5ed795663a83c2df2ec354f82d6f4923a6c482f6b96d8dd6ecc1d3688988e1c51ef4fb2ce219d4267a6b7dd5b817deb1ecba75ab595d3f4762e256ce515c41235d876101b07f25614615666abbf2a253470b3e612d6f459b0a5d9fe52a718f085759890510aefe871ae800bd8a68c9ace144649b76668fede23b6de7301a9692ce51300093402660cb2aab970c7b608365b8036f093579089e028dc91982344d60f657f15993f9877f1ab9526ac54398a937f638d80c7039ad9c64f659c3db8d5735bf4d7bb62dff448557f33d7ba12b492fd5ae16ddf03135672c7da453360c8dfbb968d94f0819e2bb1dc1489329b47953715821774969ff91f41d245181b09c660e617578f23726af0086a704b538dd15d819fcb45b52a8a1a8b30fb7911ea25e495ad9295942f67d44cb1ea937f0aeb9e6211003c96a1f6c4e6d2b939dffbcb4a790598775d58fc3b3080ea48cc3ff8d1d4a6591d4e38e7d97b1c677e20712eb2654e62153ae5e1b59dc4da166290e9942c9e0d2c1bc9c1a8f713a403ee164aea052315ef78550fa4e82d3235c2ca73c72db468d01799df383e39ceff90052b8ec118534d6ee08d97bd9a434a9903b345ca64b8184773a64cdbde2fb9361888ef4d645f90b07b7ec06c4dee53425a5600f78ff715f891d2ebf82d030376ed320cc65c377ff6a3280e56b611f04e1584d6e7aaf35ea19c756e5a7331bdaedeb189fd240de1afd1f2e12bb4587291a706dd2823cb6e0eb32a7c3e428aa1d03caf130459255213fcb29038d88d905ce045e0675c8883e16909b8120bf11635d8c96818dec208fc14695893b51ccefee90eb7021e8a08d85e219abfadf3e559e71bc3c484fef49f70f34f0e14d890f2b98f11bdf63813d373b03ce77fafbb4aceebd2609a1c4c2d7a3e0ff3748157b4c3192e30098861add2058f1a5226e3251e201e5f27a5c5d583adb0ee657295d4ade739fc78e264de73896f38fc385c81df80e97e5b1730561c6aea41da6feaa7fbabd65c28ff977f3217cf32d53a0e113673f66003d6fb6fb1dfb316aab40ff64efaa5e603781262a5759","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
