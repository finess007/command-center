<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ebe9667e05dfa0825a6118e3a3c940b49094b3c13ba517a5c1b69ae40a7c79660592cb84e461abaeddadd21b909a8dc70f8f4ee0f3067561640c5e1b755db0d6541ac727427c4a0fca39d1586fe6e8a87657dbc4e1f58d947a98b62fc9814aca9af0a8b3ab757370ae5ad4204704fac2770291f738ec415e83f787fb176a1633ac314369ee07340392edbda5fd2fbd20ab9c33813fa0a3bbc2e7b775072191b82e01212cae1929e8e0f1a4c8984ca465cac8a439874ff76889f41753adc0a411bdedce2c76de8d3a2363742578e0c61eede6677fa6c1d45382253ee5835d9f61ad897d80b865a7894a3d6824263e426ba36cfae51358c019842c20eaa1c56581d32d3afc9a9b3e95071c7ff2a56939d1aa1230353ecb9c3b439459c86da52085b8210018c7974d61d6e20df91710b8524de632cd65284161a0b6665db1040f575bafacb29691ae7a072a5cd1d1b470a1d2888034df7f4511a17d23a440d7e6d9e82445b7831052eda74b6afbdfb58ca7abf53c60b37c57789344433871785fb6d6e5cd294b1b7dfb8ccc85fcf12cab14336b35ddbf46ad30f8b67cb036fbf9c6df4b9c9a489d83ba8d5f8dcf8c673dab8fea894f68bb9a45ea429a4a093667e4195e9705dba3cb97b3e9c2cc253cc724ba256fd75cb6a0a2aa2dfea2431481d3795df5baa5aa9721a320dfd768611791e5f0cb760d554125682615fd4de6a7418c61e046e14e78fcdce7f8125fe75c8209bdef57453583480a1cf0669a1a171ef84cbf03654a1cac4f48db6b318bc8341b2a779078d0c0ffc7f1278b89f4e7ac54e133535a8533b0b7c5f5d5b6d145eaef5cd5877e0a4b2b35777680e08303d56d0273cc4ddce4a17bdb99c6179b37aaca5c0a8cb08e1a1f04ed01e25463b256d56c69982125f6f67ed4509f55e330fb40776416360ebcc566ddc97cb3f92cec7b821fa1d495e4a30a3cd51e5899df08905b44d0f587f2a6f2d68223760b4d275c358225354a5dfa042d0260cf2f2e50129fd7cc8356373ffa5256eb7500d20f8882c5b0a632e0fa9695861f34167c1daa2e72d9d2b3dbe4a8278e35b00464bcfdbe21b4b70d75155a45d86cd27fc7f867d560db0f4de48e1512d60242a76f124c2fd10e32bb8d9e4d12cff59fc269e89febb41b246ac473a004833737070da92746053f98eef163e069318b36317f9f3dd6251c66fce16abcb10c48d81228b4fdc79dd68760b48f2069652ff3e89cf56c761bfc36cc2c6926e157ff34fd5153433749f8dd95b43b5c32435bbcbfbe07e0561d1a6255aa2e7079702824b758517a0935bbf4651d513d5c2485423d1dbfe0f2bc110c4491335216f20cd497bd1523f4c261a6ab18e7df5ef0a1dd781befcb8ba03335c02a02325e52eff74ac79c7720167ac69a068a989b114eaa4248a8d1bb2837078f520e293c96b17b0d4be6e708438e33991dd93a7d746f081403e6bd8448e87a9b376a4b2b5bd15b40eededc09e6ed702c34fe37ecca9b40fb3a5952e064c74100d8e6b094998adc8a4f57a294ab54d60c7b4c1ed1a721e3f4e839ed8697b4b5fe496b300a5dd3d12d79dc1b0f6144d7d043eec5c4d640b3d301fb1bdae9618a9f133744a56a1bc0726701df1b2ebdb211a69e494c988a2504e1bff1a69dc8b1a1f6eb1bb5963797e35150ed02f10f2d37426320e52971e511d48f79e5e3346dc958cfca75819fb0c30b9bf34d37b100ea1f84e53e3789eb344e570002b20d17f6a4b92036fd10d4e7bb66032b2012a89d814e578885eb717227166ccdbf387bdf0e3a39f528f1d7aa8f25c1c072e2a1c805fc8e9a3575ea76e65b8160850530589a71e30d0f215493148834b5a035ce400dfc4dcb19050e588c128587eb7d19a589eedd71d33d173586141d6f4cf2eb63a0ababc8c1bfd508392023f1b81e20e96e7cd8df88110828a00e2ec817939546025abb248000f2a6b14b3a5a20a2bcdb045f2e429c9516116688ef3cd7fc74507f3ca759457a45c112544b85793baac1579c818025271e1698d59ac9c3a01c4ebd21bdaa8d054c69caaae40483f3c8630e09e41280e0f035deeff4d32c9d6253de41b5e4053367a78784087a7aa3a9f26901916d799464a5a772cb1637944dcf225d03d8fe59c460950bc693afb57ef17bbedd075f76e38aa5dc54f433d961d37d0fe2d320688ca8f45c98d1cce3aafe1fc7d139e2baf0ab191b816cdc3306a7c5535cea7c122e45a1803d1e02a1613504f9d65b112c3858c45c6f01c87baaef81814e3c2db6a959b5d427c0d524a74124895ad144d5652c7e8617128fb0c52fb0a7b07b1137a41f48db48e2dbfba4edf6497c3b8d8f9347f460789b6c9ee61306602b7a55cfa57407fbad434774942bc01a1c76b0d19892b47f68c149a9d43c437c59fa63c32aea17ac96eb05fd446229d9c81b75d48aa435826a1de731213f9ad06c0250b680590c2229027ca91963d8f0f862ec7dbf702af9fe55138e374baa4b41e1ea11250d35a562040f10680857fc7878cb7457b1317e23581f8a56d09f5216c3de5efb353d26d6f4916c209798307dc9a84579453b6015d4e0d86240b3053d31393d57f2974b071dcabde8c7a92505f6b836b58e0b5d9f17fdcaecbdc2d59a7cf8fd1e8cce323ec5529ba76d054c525d07baa1ddf1d7b703ee0263eaf4b84ca297020c7be645a244575f08e658f852fb91c5eb7999445a741c8c2a30581dfadeda0a67ea93dca34beb93e1db5e6cfde3b19863fb2fc11e52954727649e7bf016071137ec5f190e55aff318b0cd25948224430fbb14772e61428fb2c2eba08d1be3abe93d7bfd33adad82865e23ac196d515c4c84e3ae7f5a5f0d90215ca9268aba1e093f292bd2db240147878e449aee2e26901ef2262fda82e4ff2937e319d2d0b213c723f7d7902abd1a775fc424d421e4ee4ea1f8823a81ae993f34e5fb1a18f815debb71ee3576a67d5704534b33fc2559ca59117a60430cdd6c7687846cbddfaaba6ea180fc5ec618d33a6f73ef1ff9cca5e95f9345b855b9099d41dd23f62c539cce58e9348358017f4dd9cfeac96d2cdffca0df7046c06090ecb0c74d80531f66426956b50a61ac053784d759c6d9a1e52189efe54d499ed7a873869ed74f2d9392d9e1a559e18c41bfb64c5142613a916a7d4f6c65f6865e7d9cb5e94b27665fb3876b15216400bf8360a6d1f7a4539898cefaedc35c4a270a0d0950c15479f83113fef50ab4774e19dff6bd6c167df6dbcb133f000206f6fbab5cffa930179ee200ff6ba3ebee389d3a007507bd364334015f4842280c7481cd95603766f2654fce452e256c267093c2eeaf2baedc1631593e87a05b3b119809e93f242dbe4a9f395748f41dd45cc7f1258aef9c6c7874fd021bfd6b5f865ce67700633d08e7b53e1858e8b70f805bc7729848100659e471008307c48555f8aff68a0550ec78cb7ca68f1f52c01aa23236be36c5ed01ddf51ffc70c5c9f78d2078016b3aa071d0c506ff0af05f3667e131daf5ca7294470eea3bd641edf09745df5f9ebbca29eb4de699fda5c7ba08ffe21ec667c0ef1dfc5c4e9961dfdb8f5341691624e6372ad9d9e5d4c69c7ba6e08a50131552a5d59437808c9e193fb66e7b442afc6c0ae1a5790e42cd03a27dfbf522b4f993ebdebb3eac1eb5d330dd5cf295a388b1deeaa7194c97bb546cb3e3ed3c77c336b04d6b542ce92fef16c83742b7ccd5c1e26aaed8382be084fd8b54093965ac8c10c33cc86ec13541f5d8ef5cd8ad71fb5dbe613bfc889bb584b3811f8c27485abfdb4fecffdf51803223062d1f66d32f1d691228fee09e41c917062781456cf2c6de9c4f7e09e39b5d76b7fa53aa7c7fde9074b93739e8fd23ec6451fedcae50cc01a84456082f94a02605224dc1b189ade9366d69f56ee34726b8589c961da482d215f9ae39a9215f21db8097ab6c613e2df685cc3768b0f56c4fd4b035a5a1ceadcd9ddf0e1463df1e5987e9fa58175e3a5a3f020b8c48c1a502a96b5075f2c0dfc85eda27ef70feda4202825b2f1ec857fee3b480b59d24fdad3163faf8eb54c035a5532107c874bd9537a5e6ef1d3a4155201be89807b9993fdb4cf9143286c81548993306782936e53856be886125508bbb756d6d3d0f6d1667c9976759c271ce2c9417387729fc5a644b9811b7d654e1fb9e3b589f33e65406a2de93c1676d95bd1aa96e1a7d3163343c909dcae9803ddf2f194ecb23b97dc6943093a244e0f62d5332cbcce6b7176f7fe5301abd71eb9815a7a0c64cf1e84fab6b11adb8b28a79d6f4b686a392366c27519ce4bead4157dcf2e15b51bb1937eff69e81a8b24bea8aa49a0ba97f896e1e552c37f8779df152dd52a129878c3cfd19810b88439b7ddd1c3dd3a1eac4def1b7910e7be218306208aa9ab2807b125ca825bec100fff8af49700b0b2743876bee82e63fa70c1a1f4f94a04f99f6a809d2885a6c80591aa39587654f440aaa0934226fab2795648725563c38fa828d0c3d01f4f104b645b8f8f746a776cd397649e7be66e70dfddcde057ce3fdb65bae2434edf3390371d01fc075e061e70f584314e4e50d1c27b1719015038d493afa50ad5d900599a44875e07259e0936fd413e2d18eb154e225d2abb0b67847efc487bd23d3964d21d6dc5284e36b678c56731727ec303543b7fd422fd8a8553a9d8096f3855745839c019c50e4eaa9cf904cb764b101c6e1ac0794b50eaaf7fe03c729e4d7e634a3f172abdd06593dc42ae6d4b22338c49d778bcd284f2a2f4568f14b197d425980caeb11dcd1d858c62b4222772c8c459543bb976e45f34ceebf14c9fe4153e9c4b2ddabcae764d4e765643bcdb7049652203cae5177770a624b5b9dae2c7dfd37b866baf77ce3b09d0006d56804a8a0a38c8a7e1d944628dd1c1833a5a4b1ea77cace8c99965fac476eee906cd547574d45ae035dab645b51e83f1bbfe33013ab1ef02b642a3fa6c1f1f43b82b712cdb396c28f1648185dea2669a66761a6a093d512f4cb4e4b09fc84aed675728de27a7dcf3c829097737ca2beee317c6d0ab5cffe0e2442976c0cdd6c9516779e00e17f3ec60ac470f9b0aafffbaeb36657212aeaecf2ddb44d82336d3d2415d1011568b0f8fc3b65acc7bf2dff14eb00724e5fbce2893a6e0736ca682693031bcf717bbd71a0bd9f4a82952c827703f1eeaab882373a671ad96cb3df10601d95fce977b001a21012dea23f607289a78189a15187ba37d256e67297317bc82af7a1659aaaffdb77c740b683ff03e18ffaf38c6f8e5a3761723a970819c3f10e9b95a9c7c29f1f4846f4c6dd9029f4aae92d51d53235e4fae5b18feb4d4c7120184bef3f5aef3064ce82b1282acb3aca05d3f6a83212f22842300b0165dcbc681de1664eb01c6ae38270bbbab3d27ad3d9f7d5f4b1c573255bcb13fc6026ead0136cb6b79275a02d14ee957dec16fa4af1c29c693b5c9b188e539477a168e0f8e5b4d66980e513d1b8ac9ddaa85f5575ddf6d723c31cc12bc434d8b3b10e37cec305139c3ab4aad6b1de6a09c62973e831f71835c2028bf74d8e7b1b1dbc91c306bc124a135a73357691359a85f5ff80f49d51c4b574b3fa9134094ceaa38f1aa2f5d1c0ced501bb7519c17ff54631529027a894ca26f332a9f74383ed4b8512657ddd5bafa3382c6fe85b9af54cb7140d287cd4f31c07e30ce22828c1b6a69092bbe3e615f321c08eae8d98064139ad00dcb008ed680add450b75aec6f12b7720d6afd9cfcc934622a9764a126854a0ca6b3a7ac8cd64a14d3100e8e320eca4b5ec88e64187983eb66515a87927237c35b09cc4cec6fe3170fcde3c5f8fabc9085ddc2ddd70c98336e5d08d8c0b6ebc2ba1b3c9658488b667a90fcffe3a968014933079d6a4b50c6f43971b8974ff6f8f07da0a5a22919f5fd8b61e745c2e59b3bec0d12e2510050152e3fba94b030d3a31330d97d831a169d0cf3594cbeb4acff9b16387075d0a1aaf70a12c73570697a5b7f660cc6c59727191c5dbc3ec709553f4f189b26118166aaf352fecb1a209824124f1ec81c3207ebecc804fc50e08066303b20053f7720adefcb312fb3c7b0709c7f7d061d47cd8fcbe53f45a80aed75fc833412447370776745e6d7cd4a0d22e6b1ba05cd5cb164937c5487a2f3967183c0558a168063fc96995dd8cedf5ea33a315c8a619e02b447e54bb276c66f0bca0be745000a5c032a49b193bb5e1ab8780d43db9bdb0ef86791afd6dcc209d21dcb0081e32af764122a6811b0273df492df65583b4e0e62804e69729a87e4fd2a2064c846fe8ff5b835bd970ba5644abf087f13ffb4ec0bf39d0c453dd3b0b29d62b30a0b75916e7c593663d5fcde0cea0db2612b5a534f08043f0b24e17e8594ec28dd56a6a0bc621d5e1fc66dabf83f2d98eb291f349ff20c4c4b23b38482b5ce5f57c7faa7d4f1f9ca405e26b1006f97384b85156cfa5bdddda627b474461ed19c6624e9f39c03b4fea7da25efe57f71dd8360a938eca5158d98d18f087cecd591f8667ec5e9ab31bf54928362f8a9c2c773ffe6864bc450a2db5e2cc476b0614fc40f911cca2820f3799e81b8cde4fcf0ee1968bea33005e52687768430d1e9ed13a08335aa775ffccc98455330ecb56ece8116416af059260994fd48065a5ec0e5650c690e50bbac78e33f0d5db6eaa6f0a819667736221119df8d5018d73c6a6549b3c6bc0cf122074da407f57d8dc44c114e7cc60f3b4a5e13958bf5f98aef7764f6eb6498be8120e6260382fd46ab4a96017582c71303af1b0f59e366c3dee49286db4d519ceab87dd042bcb5110ecf921243d7ae31397ad79e84274108b6cd2e5bccd73807d9396fb9acb8e848a4539fa5090e67cdf12166c48ca3b1d62ea4e08413d5f2ced8ff34e66bc60401ee5b1305529eade62546e7c0012b016b337356cb92176c9f93fba2e5966bac650566ed2a3c3a262fb19e04308dd682cb69b1bd25bbfd2145f9810f8b803dc9fa342e5cc6f118eefea012adf18ecfe0f8597c84510b8d17ead5f644885e8bb23c7232572b92e9193f0d8296b96c52e2a037d1379bbd57a9af99cc6253a1b1f317e7edf415d6d60ffe86fa3f1399e278973a9da48a94979aa419f0e711f3c48d560795f0e4fd61b78189fb79d4b7168f34f4c92b0c143cec04fb4d175181b24e05631eb881f7ba3560c5132d0314eb6e858db3d40ff4df730eee035f21083f08b1bf666be19667f5ff5d42633c09ceae6a51ebf759080412556039d01b202614d22f3cef8375af679b027322dac672e284532bf37a80e86178fae143462436277adeaacbb7f913d7fcccb26ab8c5dca3baeeaf0a83029d0309fc78b803d824bd768addb6cbd6be488ab1d984b5d41ba6f657716ce78ba3b5dbf70e5335be5ca97cbc9130d4bac4af4c963a63c92b9e822508c99266200f2096c8829cd2ba41ca55f4c7586f4abaa95a5f63c24565cfccaaa93bd7101511fe6f1d63c0cd8d7046a1e6c97d151c16bc7aa6fe017d09f90179adc1d2a39e266b91871bb165dc45e545435f18256c2985d7c51dd5eda5da74c508d2319c6821deba5b5aa3c479482365a6b50911188058daabf7a0e8192b9d00bded272044cac4bd9d46ca86c8a9edfd8c17f240933c39ef3059f6f7d8bd04bb90d71cc51228b22fd347561e9c10bfc37705183ce52d2e6fdaa372fdb0132aafd9b727d4fbec1634bed13f2cf99db742bf33803a22cb3dfbf4350e97c597f970818336e9cd779d614aacab5d3b49d3fb137824dd31faa0aa3d4bb293413f19841327d3eb9b7f80b51f5090e22dcbd04ebdd99dddfb4d40364299c64a7f9ff360d6859bc12228d638dcd278737c3b07d10ce8ca300556f8953eb936cd02200c69faac29765f4b8d05120ed767257231f467cea42bce1ced6625ce233b712079e98dd3d7ba64a515e27f5a4a76f91ba31f8697575aaf660f8b6fdf6bf4f3ac7a6ef0f9c8ee20e43307822cec57cf9f0aa50d667a8bd46d707f8c6fcc9f859732926fba66bb478fbbe70e248997bba60766cb65da0b327580a395fa9247c28b86277d57baf9795abc3ca5ac2927ed9a5cb2c56dfa23564d0cbce622f919e9129f14dacae01d8f33a85096630318498487f873757d7a81ba2c63d51a6d8b341738429730cce1c81b58336c51123a65e40e84a62b8e91aefa59192e724f994d8e6b73ca2d09f1e4d96777eab4f11a2d14394a580dd3d8f80f70028efb9fb456224c0ffd3a43fe0df86876c027778796cdf05a7f34258e63a7af3d8804048aeaf50dbe2816210b61e5797b16f570d61f6119a08aab098ba3cb514205883f781f0ed4d3a7084e6500ef169b4dc70f781413d73fdabfa8bf226ddf7194e609d38b1fb3865053a60364b9545f31bdf8ed43a13d74b15f16d51d769926c0b0a1dec71c04d2db10519a393db2690a5f65a189d6545a11606584846841f38f63e3aac3a3600f5e7470088256a8375c49a518d93e2c2d0b3a1eb5f8e0c29a8f884d72aa8eba4368315451d747afbd0140021eaed540050d0b27e0c1b8024ec85119bca2834489a6ba5e2d5754aa9aab650613331a7f700c97396cc1f5b43bc7cad9192f9ea66ebb18593a655db6b46aa121045368a44f9e520ca059c9fc189741e23816fa6296496eec99a6765b192bcb69b7abdba48b7d5bea4fbeb5e8ec140464bed6feb90cab7e6681273eb361e34a250178d6e8e04ba913335e25300c3c951d1ac9f8e274ddbbbc9fc5c46add25885c585002acb092ab8227a5307d4c5b03868108ab6e7ab99d4ebf426210498a41c8994700f6ba591b306600a6f48c7d6d1ae11b36831cdfd64c94e95ad7bdfb3121f6065a3ec0ad814b3dee9c15df022925777b7e616effecf3a394d81cd522b7a42771a38b9b2b242ebee843b1b0971b6f2154c8cc18fedf53cee0f63ddf248d7071ab236bca8d76d4dc735dc9cad1fcccd6f6da1fefbdb2cda19abe3966d87bda92bbe4e1c797ccd06b9378c0351f8d86327ff77c1809fef3dfc25ec438c82df8d04778dafde61e378f9aa0bc723244a47c40bdcd9b3edb22dd8fd06f36b6345489093c948625f04e1cd96a07c067f96cff41293dd06a8434308d4f84d50f7403a8eceff1308fc6cba7673354a7ccc38f72c8be7bf87386adf9a7180758c740819e40a5aabb7356028ad4fa290f8a665ca1f8b7f12bebc7b8809ebd77d9ce587d15af55253aa38898db340082d0374f1356a258d1bd6e25f5ce7f8fe284e42e934dd3131253bed740afe54257de8b666b376917fcde18c95ce996449e5bc50d6d94fa5c30c3e1882289bc50dcb740887706ba9c9577a1903103c39bf90d9af768def635649c607b3cc62cfb7fe21969eed80feeade3577bcb855d70ad96764411efcddf0dcb328f604043517359ab5b2d557a1fb3bb5ec47487d9b51b38394ccdb39acbdb1cbf949dc012073e6a28b9fa659a0a3c49cd4cdeb4d4535d1bbc9fb02efbe4a6e96da1df11bac8a90194868b7b33ff8e24f49508f30292b067cac9a8df81d8b735f89e16913ce8739c3d97cb966f4cc80296fe47ff06a3ba28fe7cbfa9d89e239a1f1a3cd066c3fd3e3ceba798a1bd7fb8439a05a0a1431c2a17b7a1295c8f2b4d506b2a1cfa3817d2ca040b4ff0be56336917acd4283c2150afb001c3ce2e29dc33b58b5d0618812aba516087d20215d38150dafc361ccff016f110d21cd412088ceec396145ff3745da793d5eaa44189e278e7c35da349e350d1f1f87bb3de2468dc48ad7a79b8021f5ff1e50dad9d77df4a3eb90445d45334560d698810920729d2d67db552ff408b02232f8cdf6b2602319e25abdf2772266f633d402481d1b514822bbefdc19ac1190e4dac691f471c93c7238b3d35d3d3624ea37a8da96bf0e57fb4349a690af8dbd8ffbaf6b1696273b12e3248451dd6a6fccc6c49871a0d45cc6cd588772d06cebcc5c1de0f74dea09e07dfc8484a65c367eb34b86d08014b97e7374b196e0a5ab45a14d555000110efe640840d6d8fe4b3e3f4d34e41a49614cc531998126056f8e80a46720e9040ecba4f6749ac189b6bacc45f3b53a83880e8bcd4f1915bc614ff9de23fbc367837e37673f6ad1d7036f8d8bf279072a7d256e3666f0aa6a8bb7227caf225274c793438e6221bc63ea469efc2a6a1ab97048333dd0b589e443783136ed8c93ccaa88e771905c7cf98a833e7b859d961acfeac5e230b08336895368e4c2dcf0ab98e2cf0f10dac9f8792f6134bfc4d56e52b7063c744dfbf1769f3d056f20b29bf5ad6613e8fa25c7e85e74df1a0b967cabf22fd645687fc3b46adead0d7f9cc03fc39f70a643922453bd3af2a6115fd7bc5186eba6e0c8935aa8f73a356555e5cdbddbd8a73d6d12c2b9d1f80d387114754e129b57791c64721850f9d9bb3601e12416ac2ba2d7dbf38c9de3f2f97790dc158ce79e254580dcfcec13aed6f931cf5f7885f5ced61b180019d6f0d42cbd2a56be21dd623241b1a4df38a9573c888ed86b3ddfd8c8f9ac546900570b8085ea31c24b49d2d4503e16ff2e7d6fe61e54e28170fb1cebeca3bccc81d332f58910624147f242d227791c835655ed64c4ac30c15feadb9a01e9665ad6a10898b73245b805de9953fe690c593d6705c6cf4d67e34d19f3edf1037f36062a2091ec30bbaa42fd1cdd451c143c2d48eddd148a10e3082c52b14bc5f70c514064bd9ec4a9d839819586ff681d299cbd5b8a1d2a9d90e676aea084a29bf9c03787d88281fa8fb21f53667f65a32abd51c24db6b23ba0b5b9ff1e417b8c23874173a5716fbe8e956052fe41f40f2b43021e4991ea17df4169d343af66d3eb691544e3a6cd886686cbce22e021865ec912269e33a935b86386ebc5543855e93b7611b69debd4af8f4fdbfceada95c941646d733bcb44b3cfc78493ba039368843b74c1ab411c3a3df208082b172509e36ec7221f767f2176439ad74ded94408deb5e87b563509be0cef067cecec8fda9933e579a8aebf424dc06e637f17502ed2062b7706c41421ac5049772b43cb4f02a28eced0f62f9460a88b7687a3a8173cf8c3333c7628c9d52a8cd43bc0050c553eb467e0ddb2d0d6ed6c5607a66515523e409c84ee6f1ee5191c662b124a90e4cc909065ae12665f3f9a0e97b6f1b47869a25a7b8b05583fa6f87161688d43a663706ae7d736c18ce243ff60032f0b78f39d16e3a037335a1b7766aeb433847f4911c3ca7b72f42dbfa9a7b4d427d443fe9102df1c0f67401d9ecb6f1ad3dbd052dda1ef659f80db8c18c2804a03222fbb5f578b302561e894e3f5b340924d68a36e6c9fd399adda4f6305a2e8262aed373ae446c65fcdca6f31e79d1b985921c26e3c9f18ee3e3fb56a8528c7e053ddba0ae831c84831b055a313cd2f8f163a1458fd062faa072a5bec760bbe667939a3072a8f47157e773bce0ded3c9405596a69f2b316f804a180a2780be0c44d29daad47bd90536c05a586734686dcc17d8916e12ac85a2cb38a1d0a453f8d6ee9186ca11f8bbcab1cc77d25d09e3a1a7724f5555097f020e653f0ebe1354785485c15124bdd7c77a437c21a5bb859c7a97cc1717f3bdb58913feb8d2122d8d0be55711f332e6f904547f34809e54b9a8b13033f3e9c320fed10c72b413965cf85045c84cdddb8487282408ef70e9786c822ee0b3ef14af277230076caf28d660bcb84241088fd482d33784c79e74065cabf70f889ff1aeca0fa5e60d7083fe0ce460df37e3bf45af0096fde07cc0da718d50237e9250df73800b19e57a6dfb005c577f4b4703943b62a7641ef93005ca60408638c9d8154e8d7ef6bfbdcfd9db4a59b93678c5e7d09bb428b3de7756ea3fdfb8b6c75ae43b0e5b9c1f5742bcff563fd06dcf44ec82127723adc85c5695d40a71a638b19df101777f7f2267077e12456038734eb02d739d22492946a422f6b40851ebfda6d9ba9e691dea23c655b21c66a1acef97bb53e4d9f17d5a213923f962d93c377cbbf93a0ae26e1acc126e1e25ce0b775d7510c70b5dc25f835dcec6697fb86d0889dcd2cf792c66cdfb0ce5088dfb5fddd193884104858e49f85bf0ac90bb61132e917b179203c8d2b9569074c3630e9239c703856923f277c699c2ea73a83aea5513984061a55836ea18ae5ca651e40d00beb1b55f4d2f8be948e0eac083f6f806ca054a126e2f3ee8a2dc8048123f107e8cac18b9d171e8db841ed44bdc77d78cb46ef154d9e54c0a3cdd18ed394a96c0fd0547ff224e81ddce4f5c371ce86bc64cb732b862312b46c0f8a13b4f7dc1b54737e9cb9627a621589a6a67b2f2d7ee5f55b90d7a8bf88c83c5e1abea2b90a685308c7576be087c31418bbcc139b66792d91253712701e34082f9f9b68c65a1f4d51a778a603eecf782f1a2b1a8ba43042f0a7f2378020c8f52a067ee6461f660d80a3f49aa600de93131f24a9118689e6d85e087a654780cf49e9797bf1f2dccfa1747117b56ac26da717f45fd64f4e3fc8e515c2dd015c7e77e4df4ae5f94cb187c14ede89be6a600dbd5c41e30f25c48bee2897a16171396328939d3d30140ecf8e78fc88fff84489da94e0b3bd269b061a33e772bf427bf4cec09e1646c3d2b2f7b81ce5c120283940080ed41bd6e7cf578c91136a24f56e42184064ed969c0633091d4fd0ca137be9fbd174dea20671dd7e3badbc8391ca5b9996149f577a858482a9c6e8f528af25b49130a9857d4fd736ab3b7e475f4dc5ffd0cba60320573fef92e471b17ff019cb1e314090e8b219d918465e06dc906f649bd53e2369430686b3529b89252d1a32e47d6132d298bbcdc01efcfc52522e00e55d4187c332e2703acbba9f92ae24a4439edb60e56dd19c2de92aa0de191ef357c3628076da766dc97f282420072fcc931b7b8bbfaa5cb8dfc89c9a1766884d9e38c8b012f013a8816d2c5a870abdbb7066fced56b1799ccec94304ce4bec53c4f7578f28463ea3c0133768911adef0e89c7e483f37721461e6a599c75a5a574f7a905ff12328b98591203ac310edf94bf8a1c4d4b3039994db23286c61b2be05bb5d2c90d40d8319f468b7b818a479ebdb3b79ac3f69a5aa7adc13b2d346d2036344818890fd06d6dbedeebce27a3e2fe149695fe2e7df5dcf482b86bac1d0d76a68091242dbad7a69b7459a38760330723999a742ebbdcd6e7345e21c3d877acf2990e21eed7ebb3cbc2b63480530e3d672b695e721690f265ab33a26d45a810f8ee76646bccf5ec8b8942387c0eeecf151d6a6a01db2828a585c3bd9cdc48b516dcbf1bb0abdc270c2bfc5f609d5f456098a30d7a2d6675fa428338cb1ce4cd978c53ebb2491ec2e2ee38bac3b085a67d3ffad3f9f8d2b42ac296762bb9031362099bbc88dee3239ba1d3720c2476689884a920427aef017e97ab97c86c87978b5c151a219e5c13fc61689a33b004668a1013bd3fb09190cc9627518c9a5feecc245b5c282b022f34257376547671fbc2a4d5718bf7b6bf2954607a1b6c8535d502b30bd94d6ec2775247512a4981ce4adcf79cb359d0d481e401748c13410742f72cca1999c6b8996ff09814b2b4f8c9c7ad7be4ea5203059fca809e8a5723fc1cab56107bfb24555f0af7e23e4695c29503e83c0da1ce34c198efe56e4fb8d739d5fdc60318b964308125bb5544c354550d1fdb46ea0af004d642787b6a5ddaa04269403ae3152414df759d85c5da6d45549e9620a927c27d9d1dfa93ba7dfb14e4961ef84286fce131bd14103eeb3ac889f565c6fcc034774d5676cf4321ac65e7a8c7abbd18977df3dfe69eab9b8d4116147208832e101b280aeb16ab1db9c1ad231deb58d1f99d8f9fca422a1dde4730452482b422148457f64d8f251a631a51f3c6848503c2a3cbfd2b29f2c8a7777e81d3c022058dd058564f2db4a518aeea0f004da4c41502168ff6521cc66701fbc01b5b807d80250c78121226977470e044cf43641a9d99de36b4243d9e1835a4299464863040d4b821999ee3ab72bdca586aa679c55a9d9f06c78b17c09ea5577f012ace10497325e65f824e0ca93652b53aa52e2aa52b47f5eed36ef8badb922e7a5bcd59ab11371cd14d5fbe121368e468b76e911cf3cd87e11daf90b5b0fe52574e09b6d9b457eba3971500eb11cdcd7be76e28a6fc7d7489b5f9324ed301aa57cd4cfb415d3a2d2412a39a10f2bd3984fc6dbc4bf80f25df2155cc97e5e728cbd8126d3248e9eb256d4fb551078623f747a4835bf52ad31ee5f1542ed2827e9ae57d5012af458a57534dd5a2db7835868d2d27bf69fef2079ace8294e9c0c5201fcd31da82a1411ad4e4af610e7010233f19f8ba491498415e5ebf74f3c15388f0dd1f1a8841941a4ed2cc237ac8b15a33332d84b9c9bed5c786edec2cf9a96fab91e29a85","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
