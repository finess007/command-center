<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"42d3af38c2133fd6af509d9653544cc4def7208a4f178d0bcaae438f9360c06459446999b89d5fae6be22a235da09e6bf2f7079c4bc840b426ba42238641d10a7c965827329ed2306cfd8d1785d9bb548eea88e86b39f2550fc2dad2d1d5fdc8021e9d61c6709aa1d26294ffdb01be758d935b079391faa4ce5fea49861441d32056f34d4cce2fb32e6353d79d5644e0d93b8d1670ee49f082fe679917327257a6695b05438bc2f5dba1259e1796dcc231388c05c68c8b0092201905bfc07ab0a25c8b04994f4754e383f5aa107a6f96942f7dbeacf979127fb1f3a478027ce75f658c25d4ede4240b0568f5784196f091c87c27d40d0a4edc09168f2a82198a7c7a1891b27f2799a838b6fac4914a3b870ef84d1882b383a144baac7c9dcdd0418cbeca71612b1d86705d6ba2d2b6649460437904b296d7be681f46356c33f15b4d42a4e517bc06645adc86735abe66d2ad1d28b2421af208efb0030ee76446b466bc610d4bb02b58af5749b8120a050b07de0e931872ea1ac234357dc882662305f9f3fdf4d5de02f72e75ee477f560632a04256391114550eb7724866442e06b785dc4eab064c731c080bd6b1d536264f36b736fd08db1c8fd79b3158e1d6ec43d7e782d54d015d6530499885cc6c457f551a7c41dab1b77f0d1a0a1730e8a823956a2012eb19b95dff46c804467c8445267d6891a0fb929a7fe2e23e4bd54571390c1efe153c9e8f18a0efd8d32a85837039fc589225efbbd367ff996a53530838237e79b3b615b6e78419ed1525390fb5ae7b7fe0e073d46977fc0de8daf5e7f5eae8410e7076a0c842e4c080b691e4ca4c2acd3622aa1b8559a35db0b92e025d5dc16bb09c77d696155b511b89283c1ecbfdf3e2b6bcb9a4e51d7d51e79066a8dbb49b1efaa8cde7808d38e43a781336f68472a83300cb85fa775dbb0f6081c379334c4c00ceab6ded36f0724c2dc9f848687420cbfdbc8831e3f0812ca6772f45242510435a7f7d543592cb55310668a067070fe910d9ca0bc17c35b40ee25c79839737fd9af50e01143cb0e4d3a80c71c5d9f895bdefb6f9df793d4d4aa8ca7c4ce5a8b86e4dbf1a8ee62f4f647ab6c0045cafc14a939b57431b5f898118ca60f8539cc5b656f40b47b78796bad598dec3a06ea4477c801a78574675da873fad8c667cf41b9be9b4480dfee8574b031ec8a7e62acca9f48791e345ce30e13c7ef8623f62b12f080a56fc2b0c26df074b929be57ea61884096193d8ce421dba3a3f68efd7ea4cd06daa38d0c507aa04acab85cde372c04578cbb079352eca9b8857ba6a2b94a427cbf673f6ce1cc3cff2e9713b0a13e7de5e8499784b6c52d5c97b1bd1651cb0c75024eb33582fcbff8f545403dd54bfbf290a869c56078a27a3d56e2d45201f3f5eab14ee4f9967318d7ba41960e023b3d11f70ff69d6f0b84a7154bd7c0711ab4addc7ceeabf284f024daf73b24e3454fd7f2001c2486e73255b200d3dca0155388296f214e4bd0fdf9990f114275c8e5e58b0fa9dac7d07baaa21573098e34b8d5a79ac2bff9373cda5557747f33d10c03b4020cdcce5edb6c86acba67e436b90738dfc5a44fbbb2bc81642f5d7eb9c70834d5d6d191562d846793400ced8ba969c9de8b5b3c485d0b9c23bdf0013d4500b6c30a5a2027f6a9db4cf26f682f8b04de5f5eb733e3595681ef04f2dc19dcb87f5060c7671e2ffffdeb005135ed35f2621db0f610e790486a47ad20f31804db4afae2ebe079c42a7220d9944146269d22af32b5d01aefe4cd444a504df6b09d195dc18a5dcbf4840219ac4956ef88c48ac4985be4b40ffd805a380171c73dd3a53b8ce8bc020b2aaf2a0c25816576bffd32cddcebfe4f03090f016d641c2acdf99d7914ceeb0596b47ba7fbd155a77d330b760f7ae9b2629b0fca7deaa98baed70cde15e8b9af125d1a1d3ff2acd8a3f6c799aaa34f6de6b73c076cc74f2f7283fa112ec9c1fe90702701185cdbc43fb9e241707d4ffdc05eee62b8a211bc271c551e2b8dfa9877749f586ab55a444d77121bf8128c5af097f60080cd7af7f1a1d06ac458b7dad347eb3c4ed8d24bd9fb2653ec2b3f25e0d1f6ab6bc8798d35d3a54f364021fc83da3e17a4a1dee80538d333599ec7b5a05f8e2bd5e8c6c2d8ee317c85c0413c48784568a58de9cb2f2a5b13edf476be30e102f0c3b0dba3dfdd72b1010e34a17cc8f9819a4e6205f137f337e44bcb7e8d305b0eb3e30528611bcca36e57f56fd72b268a4ec31a58da295fd17d5d5d65893682d4df6f61a584ab409e06171510295fc67b19328aaf690f874934b6a8ab2bce47c1b3824951e4da94ccd48724d520d06debd3fd2bbe711ae853b3334d2aa168bc425f3e1725dd3440229b04fd0efb3022f459a33e64efd78e8e45b5a7d2fb5483f1b2b33c4959fedc4511bd3644b953daa3b48396fbfdce4f5011bce59761e345bf58e9c10b42744578fca65a456ea94326ff80d3b7e7f9980a8f405768fc663c344510494aafcff3405963046bcb17239ffa26b9f092474ed575d10d167272ab0d574efac7b23552160a7406302504a1f1777f382f5a01de59334de19db56031033be14210e254cd93d869accede1905f3cba1e9584a04c1265fdfd0f36ecb18e2e8c314f9ed4c80a2d6b62d0e616ca1a22927bcd51aacf852daad85da2db73b22c9785dec57144e4c3cf3d04f96880f701eb8766e73e0d84a2472451aa1c1d2faf651b0aabcee60e74ac307565c5009fd95670f2b7249e9541b2245d240cec31993fe0db37e80f06d28a16dd314a0928f19f52ba6fa592d9bbc2a99d22590d2bea670bc87587c43e95725d963077aba0ffdf573657b011a23892aec839966032ca7de57898ec55e2684c9d5418468b18bc050832bdee470cd8ecb5d7e81f42ba7c7055ed954c1c6ff807aa20b13fb689d988524ca798c3fae39b44bc13fccaeddc8d676c0519c76b3bd7a2f7515fe62a98b4fc65fe67e8274eef0292361f95291cdd970dfbad393ef3e3dd58ad9210497cb7c29effb93fb672065f95b2dfddd7dbd6c4a80b2c53a4ddb1cb824e757dbcb9622c52fb66ca8f7521545f7e9e0599a646d248f7b10e7a4230ea61a50fc730fb89101fd9323e5e9a069ce30bac7b801636fd259e9f3d06391844630bf74f3686d77e7e02dca8a5fe00247038c26a1440aee1e0ddc947452e62b33036c416fdcc7f27d8e7becd4c7fb601ee76622baf93f82c8f97d82f0c56087c68355406d6076e94bab23382329c0ab0eb05be236efa807c7f6f0fbff82849340fdae9a512ba23ee68d7fcba47f0c036459770ad7663304c706200cc80f4dfaf9d2e708fcee2f9727a677c3fa29412b5355eb800af0ce74cae7538b7b9cf9b0822994bd8734efac9356f6f98f15f451132ce80dbb7d8eef479921bc975740cd579c318541fcda21b0a3b5c7b17004747bd5720bb12377dd1ed9e7e7ab7dc1e412e283affe70d68a6db7bdcb8f8f5e96b50af37eee7d6b989e54a7f3967e7a78a40be3fc720ce9ecb123ef86d9bd2aa8fbb2e9ac767b430f30da553d3e7bb478a75fb1c04fdaead39e8d4b16bbb55789fcd866f701bb84db10eb8c00236efc4447422206c058dafc7239dcc598e2749d2cd9f0f297c48a3324e43a9a16ca57450aed487ee9a15b85851a76e0f2c607706840ebfa7fa8d44d5a07e2ddfab39bfb675e1a7eca2d59b49d11da3b03b26e78a1075229bef624df4c69fc101fc6f5308bdeb6e9c3967716a2736a8bb4f4c71911eb58b076c7c8f52d941e0b9e1bc0f89ce322d31c62919519efcd62c9e31fb569a5a50a7071fd12c86880bce96f8eba97f76171f1af70fd4afe2de60116d642695838b6088d4fb942bd20d1ed451d8cf15df0a3109e4ace8d7cc396beddf76099d300ec29cb00b9823c81af40cb38a604a8e34b0ac409bf5a4107e4c1dc843009abed52ecbfc851299c8dc7405aa13619667dfafccffb513f2f8355073b2d60a34a570b501a554de032c6218d2ef99893ba59bee58aded194a0a95fbe5caa9d47601868b737a6e4dfd1ae82e1104c7cbdef8e4826f8b8022412a69e72dbf9d3508dee2fe5dda37fa00a8d826cc5b998524f04b80ab4acdab4a868ed5123a7bc693fcf4a022b4237dbbbb4b367efac119775962730208c6276d0d7361c4f781ce1d33963e82f99683f8f8b626361ff45ac81a7fbf6d9818d4d6b2fb897bf312994f2f56e338f17c1ce28fbecc1a0289470179e09ec094db554208dc40b1409cf0414901f90768c15cff6cc7506ddac860c0fcd394a3acfa9f639e8d25327377d6526c196512308590452f56a22b51e1910adc71d578c57a0a30ae4259a9a2bac144d9767fe3a27ac1887d05bcc9c5ba614883afa506dc59f7117a5c8e6cb0a6ac37dbcc28d70ca249779a3b27e3c753b0d6b8a815f692011d3577ceca5e5957cdbba96c0b102cc4824d13de894ab3552398d31be21129ef57d7d9ca30550bff3d3674acd4f651982e95cf2258ebf80069359fa9edd8f7e789d9d8ba0afb8361835cf2e90f66b963fd7ccd6a3a990cafeb56c506035e1caa059e221c85dac8471cb4708c823de27b5ecb6ea1f684b2393bf047dc9953036475a16b16fb7383a3d392ef77c62bac13e8b11f5719c90c1bf56533af04fdeee9bc2bb1009380fc0f251ddbfb9fe82992683cab55d584e7727d05d563a2f9d23460af4753ee348bd0b1a28928ec9b8a4ecbc02e5d53d472eaded0459f8beec21cbcaa58a50f04f64859d23e6fdfaa3266a278e4aecb79a72ef6fb4b1d3c11d76bf6b002c00135f1cb81d9059ed4e7c16718dd3a20e11937c95a6118892238019d11bec98e5c8bd98d7aa17ab3db73a76a55750a2932035a17d3750af8331ca7d98412da32c5997d3284d3cd1b91241babbf1405634ee1e59a4090b418b5308f03235205149d74ae9a61608fc86d2b76147e6f898525a919bba0c740c245a8a4b649d01ecea8921ddb9fb0fe63160469682dec571b7b571582e332fd98e4f76aa19182acf41de81369c619a431cb8fd579675b77b4952926cb111eab9ebb662c2e91e50fa395b836f8016d2d2807298ce8b271fb525f580337f2442581039c97d5104a62626dcaf53168d5353619cc9a63cb5cf9d3f9719f02894d445167e695b7d621ede2ac42c349e2868bac2dfe49eb57e78f429ac060e212846795abd6e25076d69b1855cce225baafb281e25bc9461ee788a324fed47cc01612bb8f34522e325d206ce47b66332242c2677037f39cc2221185e6078f26dc7cb25a8e9525cc5d09d994d86e7979b3541826c64b3f71838436a9bc20f4a74265c32d378d09f2d3995769dbd7a31c5eb7af626c977c272d78a5852d8a75bfc2780cfea68e0d4c1570dee460f79be5cfe4669456404b32c61c5f7777a48c54a8e7f287dfc3f2b764f08a8cdba62e0ad0fd6ace9ea34a9e1aff65dbfce93293bc0a988b5e75580949fb56140f6eb66335a19764887723bf8d77277a66b6312f173080bdb299182757eb2b51f6e177022b99d21332e3c4f4e4ab05f4bf792be5e2bd9e5e81a4bf8eddfdd0c47a3f4156661af6bafa243d479a42bed6eba5f0d5ebb63083561a5e31b150533d3cc8a726e1eac5ec71d8563c0f13d55290ab2e15de4f89984e5b9ce844004c6ac38eba96f369c50a82cfb98a55fb7238b5ce9621b78f1c49f77efae91570aa9f3ac7c852bd85484ddb136aa49547e55c23836dbd1e3108cd7c70e6f2fbbc4c9c2c38a006e40be6b352eebe822bebce0868bceeddd77d4438c408fdb6ad889ed0663c49618990c45b0ac3f0147a4174c619797f5f1d7b531f3bd14805b5a0b3d4bced961fb43d3a91d1035a3bb67664cecce1e344074a413e0fca7adf33368f9546d1619d5fbc5f9b39866cdc72e8896e618d2e3ea38c3f0af0f70f0c3292b774eb7cec0d104008507c8a3322e9992000b86d156807b55f71881640c9dbdd011a46c8e6d3ac0a46a8ccf5bfd6db3b0950a555ea8e71dbef8772d00e7d92aad8c20daa4cc79c65b6ee20e7ce99c11a1da1842110c40bc2756ae5d5d31ebcda033dce9fb5e2b811a79477b6f3ad36075cb1cd918401d5bf0de3d29c7a181a08c91199074bd84b9303543d59a6938aaea5ece50dac53cdfed743c5428cfac9e2147ffe41b81ff10099be699fe3a686381e1da07d6288fcac243d7f784a27d8821b906d9d0fdf1e0b935b604d3ee804082638b56c9bf40f3d499b956b8736a36a544c94492f2fcd69de9b94797f04a5a46d6b65512f23eb7178dedfba3c548c56df8f24e1be88c68caa6c159c542b8475fd2842e6d3a33dc6b494bde9426d72eb471976cbfda950271604a038e537a45d0f2c383214106909374507f15c8c1f4cdc9252cd3d82db616aa634aaaeecbd0bb4e43cca2ef07b82a26ebf4034d43371884dc8156912556525fdf31373e9911476fb041584182a9cd77b3b32aa5df991d6af69e08ffe08b961a467a71f94e413330ce913992064ad76e4201068fbf042bbf7d2086b8c707d3d104d5b5e92feff8048635a7f3ecb3cae67afd22191d8204610a649bbd1926b550e11a1f11d529629e8c9d914f570c5efd9cfe35fc13819c18136b19b861841c01123946165186771e076e244a0356d0fed5f5c1bee9548d9ed3e986b1a5f5517afb0b6c462c86e54be8c24b5dbb30411f8dc205d5bfe356674c74bf53c4343f7fb76ae61f511261883355e939404fe8a66d533f6b7c1c521869e8228a40e27437564700e803a26c21166343a0d0d841fbe50565d69a02308e5f10d0267a1ca1922555a82a1d67924749e8d5a1481a1591380d77904547eca09e4d2f675a1f95d3de27eb346ea8f6766b48ea6c5de152a3e9af356f7e612d00da47a271d1e6e981d19c70dcf37dac91096ca98521a8ce34fd7ead9bc70651d75ab4079f96cff77e09faaacb3546940c98ae5d2d9f5394757a66fd639ccce89450b6b75de566a10b7a71b9a42bad37bd76c7ec85c7b2ae8a0420e628bdcac0d2231ff7469c9f55d00d6f9b24d95ab3665d5c8bb1215006c5f629e106d8e044ca480f69cc4b0256c5c95ab9c528dd5b93c608a82b0f60e7edc0db2f13d2bb51273dc0d12722acc821d807cb9a686a96eebddc6a708425ddf956f01badbd09a92835806a5b02d8f473befe55b505673aacfd14d6513c30419479adeb524a50babf13ab41f57d7366f08a4f1a37d1e1a5c630a5ca0b44b2c4255588a9d2565b2667afe6f1379eae7acd259b9498bd40a9ad427e3e4657712b4dc9520ed6e2fef8cdaab220c589ec280488a8d3fa1c141e87b4d79b420e65a2800bb0c13e5d4f8aee5e67885e5946b21eb5a89e9a5595a380d83c8ce94fdff699eda40ade121a73258e72d7ad5abd5c8d968e3318c7cae96a43ac536d2c9de7b2c19421d23296adbc0d81ec08746886d8b83529149ce8178358c9dc8c65c06a46c9866ea8ff45e5a8b387e9e66b7952a3becb8f67bfcaa7127be021231f52f6c4dd3c0c857cf2b93c24537e126e5d69d98adfe8840532d932a71e7636c7775c149d045dad11c2c167f2bdfd2ca88da0c4ea6d4a0e9b9296bd982fa1ad125aff9b62af4ebbf2922622479e396849ee64fe0d1980c8b7e9ee85cb92739523fcfdb33bb3fca2d305c7986bbdedad020e6534d3215970a262aa793e9c6d2554f33515dc76157140cb1595f978e05f82bceac62f7ef14723fce4ba7b0637b33b3cbeeab9c45cdfc3f490d21aa21021bca42654d57d8ba76c0112c80252bbdb0f934f92531c093a06fcebcef2874eaed130bf97e0c317a46390f409c8b1e21944747aa48f50baa6fc8d461373841b601ebda12c4968b648657c4fe042363351d0453d4bb237f0199715ec84185accf384cef582e0e5072d445c59f0cb15541ed797b3477229f8096b7fd4e373449dd9b226ca0e2f6aa3791feb0464f30506d405eb074121bd94559f95d3204390f55388132b811116a647bce64e61398a28a0714c5337fabe41f9fd284c5ecd4224dd5d501b11aafc09fcbb6cb638c1f011ed82a8b89c3301ec25acd24c5d17ac4eac034e18464f0dfdd64410db1f47b687c832a050a4d567361faf677c2a73185eb3ca96e1225353b8b6dd3c38ee8b782982fa85e5f091b8a646f09af6fe845318f04289b6e9f7c060adfe17a68074b565b2d117513db53844d3edf07e6c4e91a1b9bda419a4e09e170157ad6b514a0ba8292eb6013b8753fb548e61af43246f04b6f277eebd025d0f76872459ca6d87e7280731f753b111d0825678b328f4fd023adcc929ea8bbbbf80dfa2c5d52422695d56384cb16e38a7270f1f34259eb82b722f41b790c224dee1eee9ad3175683cc4a7e8fe564c5e3a463d03b22aaad20126aef0a6282dbf4f42940175c0ed8e664dde354ab67c937037973fef69e32c384abe0d84bb192fd78ac17e51a9d56638d71d40f1cb97eb9612a3a277841f4ebb0ce93d19c02f5fa8b2796444c2d74a95dad99c46e595ea2809bb7f05343c1c9bfe3ad8798a474ca0e5541a4702c678c8c9e5a0fa57ca3be84ec8b59862495ab26dd75bff269f0188c59d4b1cb9be2c8626bb610f6167d6b242d655614ee6a2b3076d2709c2789a1ae33c3d14bf6db4e3fe6331d95b36a6f3c29a84888cdb1d740450eba5d44e39e58b1260f024effb9a381d0b968b45642daf20a3661b1b5e9717a327936f280c7ff73d12385652b004b07ee84bdff355410f8064d1cb887f9c124a3e56ea1b37daf82bb8a6b597526504bcb058ec866a7205dcf68db16f9e39515591bedee1822c20dd8ecb23585b5f3f76d4d867618de099770c85175a6d51cc5662bef5db97a93b454e00afd16e45a6c397a6f5ba720f47b7c16a97dbc73cffcb880fa22518999e9039392a025d320ebf58e40c74d214de7adc0d1f37b7e73d7d34ac581c1b13e206b1571891509b8bd3d936b76abacc47242b8f237555bd4c582093f31b492d64bb4ce6106cfece3f3162f4b5f409de7409ffc5bc40f8cad6cfbceb6db429b190ae2224432be246c43276576c7aa212e29dd5a1a58688cb80c97b0fd5c596ce3fc3d6ae90dcf8765ddd1efe942baea3979d50f923ea993196252fa670647949e36fa0a843ee94a07db6b3016a8930d382b616a60b06b7c1d8518d0b0a6c59bc66b732052ed083a46f99568a6343ee1d56a884bb804181959206393889ad3d19e2c9edac16dea35ef95deb4853e3105f6af8395195f9cb21994b612aec908449577f819da1d1a35377ba9128cdcb6c446c28828b467bde9555c8bcc494dd116d2f8e9459e274dd0c711de8240482951358e8fbf9a4cbc1f7b3328cc25a18b56c91d120219bfaa1601916e743886a899444146f8c0f955b6f6adb46977f8843d8941f6c81afd90eeb04c2902d69a304d1c73124b990122ff8de8deeb010afa842debd2eeeb62ccd655369c084e8723103fc83d35148b3c6c4faad9ac0c1bfff9623c6ae33e1bd85b49df70ee184534a77850db98e3f1a59c05e87b02b92dace97682944e7b9197bc03be0260e27105f5a1a8610c48f9af2dd62b488036b0096dd4128e1895fa306aba21227528dbb6d4ea73e3e561b5415cc43eba8aff340c6af120815d24ce80e6009c2bb5075682380a01815aab5f477757b50da0cebe97127829143ca53ee301e03718f15c9c149964f11d49074b32e064623e92d6561cc4e47f667bf86d917fe8f1e8e3e0163e830d0a8049de95893302e0a495cf43bb93bb0be1b5f8cf421a2a66bd0adbd8ba85019ebc406cb4ac9bd64c8ea521d210282babfe072c5047ad43deaa6bffce1aa1083294d42f5404b648bf5849f69ea76c025177c1a73ea49b3add3e16c3a43bf4f785400bd29d8ef46e8f5545fe4a001f06fe7f816b0729ffc0913a9096596a352fb4114be6c7cec627bdb4f7f33212ace0f0a773c096316e9aad363d6090a960a8cdbc7a9f636cd40cbacfd8cc0d5aaa511cdbe6bc8c2c396a4c8276f422abe63b8e8adfc557c32b4cfe2afdb92465d1cbf0fcdb37cc31200d63cf6df65ee7c72a828648b8517ba3821ec1b4a0fb334ab307f283b2501b13048acd9b8e412582555843dec40ca32a8a463adc79d804d94f47198bd80268d8b010a746b464bccdd86da69f1d4e8278b6d503a180d1d3cbf7573e4534c4cad2bd63a76fe29ee218832a7d7cb271b6a04a5ec4cf45dde84d1a81f84bfe9fe806576bfacc13ce0ad62a516c7afe90a76a8f763c35bb3b9d784f4c4470acaa13c96dff616828b264e53f381ca2c1065c14d2e453ce3d8cc3f6680e44aeec0758233752efd5ffea9ea075e308f8becd342e53f32893151f0f15a30cbf5d72cce341defe5b1ca4f69f0a904353d9662d4931159ef87f5727fded453c12484a4d8d1143adb71647c16d167888dd62e8e02ad2cc0d8fd4e1321004679e375800155ed52d3bede8cb86e0703faa5195fa52216c5c4ff8b03389968ff04913d14f70fa78d28845b688ca6b76477e0ef5c572b6c74c158e5e799b0f08d43ca570c8fd3bf818ba1f549fefcd0d9e417bcaf37b4d34617ed5fa6208bfc9a143b2c11ef353e39b920dc709c01e72c851e3ef6b468e118e855a276351a5a26edb279b4cc02cad5763e93a695661fb2e68c1f496f5cc23f896b032880a453fdb112b0d27515da8102d17518752250c419bdd19bd06fcd368c6f77f701c197f5672db373cf4aba4fe4f64bd4eb7d405c5144b3f11e60e1c4234ddf714de9b91aee413cca35cbf323b41241c23e1d9f84fcf38c14a98501a28689612291d97184f165292f216b7f4691be2c5de0185e8633b65a809096550de8f1095ef453418ee8e87e84414e2d30989723e78109d1183da42ae8f7b9204a122e4d9ba242df9f719da03a622e050292dc324b94cf468c5491e878344876b6502d32487dcd1b7b655ee4502e7d5fc5afecfaa62ee28973bf5285405ec6ca0c427fd16e6cada96e89f7de15dffa3bc949afe0041a8b61f1da0e2847a9510e436285df5f2ef3b37a990233d592b215d3364f2e427f4855bc930ca776a22a2721a0706a394122effe0e2d31b80b9f48e283bdc5caa716454c4d8aaf4403525dd1de7ef7050740f21cef566529e70d8fc36c44dd62242bfe0ec2fc450ff59f1f8b5e7873a744adfa9b39ed2d10af4a7c0b98a63bee0509ee3178c32f50805c1009aa6d556bb6ac5f65f2a552cafd8f012bb4b7fb157e702b5b192ddc4516d2e855d7e2323ce762841b1fbd592a8895b5049e1355c73439602f7dd7970777f64697d4aa81d2bea30e8905e5335af9ae794b00ece2d0162bff9086e6847dbfd3ff3b705b7fcbd5795f92a36b7a2ebacdd239308e706e758fb4209b8db7e1f6a34fbe9f2972aa9238f5143b7a39abc62c633ceec67cbae2095abff7710ca2ee1a8d105fd79b6bce5bb9500bf8713fe2901b62266e237f0b68bafe895e7cc564e1198dcb2624438b891e16d4faba23c58a5d27b22b0fa515ccf40bcb622fdcc910ad15789c8efe4608ce4a88ad9df71a65728516e274c4315b4d23e9552c079e5eabc2e9044e05f1598dfb79a210612e721f1865607fa538e3443a0bb4b4275e9095268bf262ceb50ddaeb15232cabb65e0aebbf014a882f254b3be02c6c3eec662876a5558ee31ff006e8dcdb4a23d896ef3f80d4c0d68f98094d5ed75a4d4241ede66d0b976f8cfeaaf5255352538453ddaaaf7077b403d2867d72907a55f81e8107d7bac54c1558f0199471f745fe97826b33ee9459c6cfd0ae26059e4a2bbf12dce462a729711817b19a2fc970cffe3515712eaf11dc8f5b9fc09d692bea68c8c786e6a6b7c7829d121ad948790449c11f6916fbfb0b863ac5c98d67c1b37d225f14dbe70c3db933cc9c0505e8438fb9a4ac9b93a59b3e818209ab59a814b6b1c9457a9c0ea9df9adf56242e36f119ddfdf9a5ba87d117041220a039bde115b691d991229cb21d76d5aa5f0e7b0e2744ca14b6b57fdbdf43bb81d63af11ece13bf7458af7314250fda353f986a81c22e5a8dafe135f3a974cf39a6a7df7beb60ac5a6b60444426fe205bfededa3238d996c48c4f30a7bfc550f15e7f7c4c81186134c8da306e3602a0cec0c80ca05d8015e418306669dc5aab167dbbe1ec61aa1c39df078d703448ce9f49e6a07eb9bf090ad11f3d823cd42991bab73ab1f563a60c56f85dc0622b91f5d23b27e703467b63360fa169304f5576185dc554e2c5ba9dfdb8afd049cda874252ffa47bf50d2a8a61caa7adc8b146502a28724ad442934db5b77d0ec2eb5096586deb149428944378073e8e53a77632e1a43f716fabdff08c289fce4b949c48273bb084347cfed0cac243c06f94e81fbc0ae5f782413fb9ae8ed8b8b85e3f2cc434a89fa3299b764bf83efd65a0d7485f91b1313b4971e3c54d8b5c3d48832fb8a4b2aabd3b5f14dfcaa87492aa58a0acb5055b3481f014484534ab90b4a341f1b13784abefd06bbb451491728a83639903fb9afcfda28db3544d5d70a00237f138bd535256d2c036c5213de4c49d061d4d29273e2be691e93652ea1db8c9bf248305603506083b42d0ce023f84ccde207a3754ca39e2518c4abccbee48fb6e4230400fbb2a1ae23e95ef65024c0f58904a10301ff7a9072cdc4f77b4f2834ce7fd757ae8176ac6560bdad621be0bb2caab7dad8347b0931b800c3c24dd438ea9dfd2761b1f87829a9b766b7c5d9f421a45e708b34ece49ae17e56685d06b63a3e93ed3550441505f0baa809fd8ceb756687bd4b222f381d13d977bfa06e2128484f6d45edbfe5f9189ba81a3e6d3801da96ed411d2fa092229b4da712a506c899a9abefe8fdcce22d316cf490249c486d2b50c9d5ed93148cf20d4de70d2873f67c26227538526e07725327766fdd25b586983321d5811a55f5ae0fa6b0dda3555b4d9eed84980fa5efc6cff2a26ee112d85ffc0bd9ebf37d71fe2694114f7e4c6eab4ed55457887768d6982dbf2444812f121706a9a0ed99ebc1b7e0ab2a849b8b99733d21063558e9c5c963d37e82edf7345e54b6489b72a9dc9fd492b8dfa938c435de7e843076087f18c452e05cb884a3e1203c43697f0405ab238d0543c815ee6bb60dec44bb82611bc134206922a0d9f1507cefa1351ab6826ee24d3b7bf8e4cb5dbecaa868c67691e0f6671322f8184d785186a8064cc8504b53b2a47b32bce910e63479e5dd5fc6938f588f1f878dc6a7650e9d1c60a3fa6e72a92d529874a562a00b07af8c0d7ef81070709a5e6793f4a1f7ac4169804a1f4aa90e72bfec492ec6e45ea56e2811fa02c57b92448e9f7815e87518998500acbd65c286fd439a886eb895c56bd6f747581ec68a34e4f8c43ce593cf2d9e611a68d109405e6f4b7edc0a9247cbdbf17f16e0ab21e8a2647f7906e86ec07ac1fdcdee68a69046eed094306f51aa4b2039943dd0727059464f4e23b651bda1c77f1bbf5b20e07187067e7a62ee1b937cc5eb0434a9e6f5c08a84543066e06d054bc64582bd2cd623fc22e0b402c6f2f0c7929011799998fedec4dfbd63d39b176283acbb60c3e1a253146c2444c382137a3cf33d48cbfa1fe8b662b34149a5dc53104684419cdb4c7092b88704a2e6d75e423e92f7a6ee540546cc725fdbcb9029c122aff488317ace3aced585d47cba9a386416e499e8e68a757bc25d227ab9f715848280cc599125fbe0e575a716a5554e227c1e72010877d9bb9bbe86e15519dca5e00ddc85696a5d473eaa44adf6c54727b2eba9893e786b14a551f9b92bdb143325082f2d43514069e1dd847433925af3e423778238302ee6291b7ea35e5b0fb1052e1dadfaab27754ca5e10f5a191f0a80cddee2f646ef967b5728a25cfd0128dfdadbe6f5e7d6911ea947936c5ebc95628e8ce6c20d7b152a77d39efbc8e115543a65183f6832e4ca2c906d85174a016e7b673cd220600844792c3102a4656d87aa7db1e6412d37cad1d9a27e9c7c518167bdda423d915fa32fd5240365bb925a1058e2bf9d30f15dbc17e220b45d99bdc8b83a4a7c430b8553fd0f903dc843e9363e875490b53b7b206a93632ae85424af7ac0e1c391c9e50ccb1cc4ed211888844679341fe5894163a9c64ae66810e988fac1c78db22","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
