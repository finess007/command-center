<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"015722138b0061eb9f936fd9faa1238746ce198bd7662dc1ac7257713a4c6ee412f5edee0272a7a42515e23acbe789ef1db91e5dc1ffbf6fe8c82e25e1147ff74c228378c25e99cf5bcd75d77dbc07b9db088522913b8fe32b58c2001dac10c36d288b9e8539be711b19799a2ec02882609ce4a654aaecb2f0990b11bd8e135384cae194bc8a2135454ffa20d7c4698723b2917cc3382c77cee282e1232b27dada6637458b8247323e2d6f9a33dca92fedf91a323e458b71b3ac4bbf1d9f98667993f2ee0a7312afeb723f2cb0cfbacd81a041d0d0a5921efedb942741488a0b53a8dcd821f49608e68caabdfd09253981b9061a33800fdeac7524339834bbfc3d38745c82149d42bd404bc176c06b024ff6d1fcd50d9afcfeb8e1e3128fa5f3ce684ade9fefab5eae38feeaf5ecc3ddbccd2474d775e0fdbeb103fb9ca469726119b12db356247729186d5e1514c1acb3ccf12a7c3683f8f877bd5d84b2845ff544ff03c209420bd2463e390bc6aaad2bbc909ab93c7a620d214d249f95948b524e95d703a52903cfcaa35ceff9f62f795636fe9e77c7ce1776ffc2dc10e6eacb20db26c48f560938d3073c00004d0a53f5aed38261cac1a2a265699b53f81c621ee8155704255ad74ca9a03dab486b5759732571eb0c531013dbf8919afb10d263f4861c00cf9272b68bb65e08d5f56ede9ec5744566cc7576b13eb5a2e6f38fa2edbb3e0d6aa8a47f6195109b5bd358221a5e9c939d1992da7ba8e6441c2de1d9f5619a015e121f5709815ca7611b0ad81a6b9888998dcab909460c73e33ae81646a0045d28fa7cbdedb7d10bd2baa13c2cf0ebfc2c273e1a14c186a62b9e9244306f123429f46057b47b1fddb9a7bcaab2d4d6a46ebbee1a710bbd692046d0edde7c77691d7cff80ec66b38a24645a56df6fc20e3c45d30c5d2b8879c43ba08655d535137ce2856354d876ccf4ed738aa1b1ae6b4c031f17a1a772ca8a68124bcafc285c1359be63b98fa2cdaf5c3f42afc4f4fcc72736432bc27fc93a262d30af21c1cb69fb2ac9b4cf1c3b84c3b4f2f94a5a5451a2b2c0a3350cb347dfd34b2d9df59af5e7439d8468add2db7fd798fce7bf43dd079e17b3bc6e1fec22443358eb0c2dab20af43ae2721edb8876229347d4a1921afa1581f3e4f857fca2a5ca40a5bbbc662c8b2076974b1d30b54280ded23a9d3a92d5e219aa39d37556dbf89442e3b1fa9334afb327ea68aa9c3106ac0d2f42621d0eebfd048909fa5262c1bf3a7e37a944104fb8117d1e8133dbfe74b31f98c7b3a21eb048a725faff13dfbcb64fae74eb710ea62343a4c8bd4f14811ca88a8b3b091a92b0741dc4dfca4aeb7a24bbd387dbd577f16e43ce0faef96684b171a9d26625dedd8593d7c043fbad5dabfef6a7e03a284790d4b507c9a8508e5e87b681aa5b6af55683010291bd7a8b1bf13189c1a3e7d4b77379d3b1c40e209d108c702c2c3a779ee2e79508e4e62fb0f9f1f827fa7112555a373385c0b239c6f5e7ed172c72009e5a0d6d0f68f7a769d49d835f4e409abdd7974d272742f00921846c5fc549f20b1c67af05a8012bf5e46706ca11eef9e4b0335f1e2f8df61131db8dd41be1c591d358eeeb9f6bb15a245c58c284b3411246593e008712a5b167b94b8fd120b019b1bfe5106c6267d81c7f008000ca748a1ad3c5a0aba6b94c8132b985ad9119c49f5c61d9a32b65c74cb280753d041c6abcb442688c5e2a93ce99c6834ba551f0ea36df21968024621271d5fd8c916d3c20299e2bf51b419389f5e04164bd205637c4b9eb96461ce9aadf8dd8ce884868723fb5d22448bec76a256ad61aca56be714b76da06686a4b9625e70a767de12a07c06f0134e51e5da80fb8225bbc83d906f2a12ef8f74bf80e4ed894b299f43940ce07c7b95119e105ce0f949e2baa9a71d3c796ff710fbac6457c96d8cbf010d34b76c1ba6ba2ff83118221cf70e31b700492a8305d3f8946e8e601aedb7ddd9e3d284f742156d53209df87a7d3722bfe8c6bd6ef17b21bf744b06a881380ec34560b0df6da598f0808666131713d6e07729a44ecc5577bf9ba4f84eece25804cff8737fe4be321480fc218052d2ebef851425dd0245a7c2b9b49327eef68e12877d304f9733086796760d65013ccb615ca318d0c08b6651353f78362c82c9a9927a5e91e7da383aeac3b31618fe1f1e9bd012140be846f566144952af6e4a1eb7e39cfd4047cdd32adc3381744eb6bb8983f4acb3b30de85fe7c34bda175ae6c7f4140c3a0c16fb5e91786bc81cc3f49c8d6719d85c97bd774d054b5aaef1b9532c9b1a0054b079db3fb86dc2c415fb53f12c5e3ebed6f37d73dc539e273fd6c3e5a5d28235a24e128b4f52e7884b9c859889428709ffa7d91ef75e3e75e55a0810e257edea0ebeae55d34942ad366d50d61206dd33ae0b1fb1371881b229a2637c659e528a8c359ef46642564df3d2e079b5e9a498d73b71178a729396f0c8784b8de2863b82e1c07414a25ef0f28de28e9128b5b79e5da0ba59e0dca5926d8454e24dde2acf96391100757f8dc549f5372abd9b5206e4d2e435f2d1d080f4ba80fd46d871aa8b52e87b365080a5aa56be45633b3c6bb42e2e8e074eb2c1b2b7cd8b392858c74c0199a9a276735f3afe4eb637a691f5cff6ca1af70b1b3ae7204fee1973ca4c84b62930377260e62430149688000fcf56b2d2d33cbd20c9ece9924106837b5761c42e6088cb1bea589c5a545839e28fc9894d68450441c20be71bbebf194f637dd75ae946a847fa9dac46b9ceedf880374aec7aca1e9b7212aac4805464bbd48285469af25dde4c4f550db04468ea2d9b9822edf9685454839a116ffa2785beda1b3ddb8f3d89ced13a842ebb3cd4edaf58d46ca61945d861a60367636fee07cbfebd2010440dea0b2cffd6e87a8f6e2e68781ac850c67381ee3acb289b8ca938abffe965964a9201806e8a59f544e7dacd5fbcf3557e2175d3869cd821081e5a0f7665cfd12b188a7208538cbbd968755a25f8e51bde947cf0ff2a9ed9a34892810129cdb23d7b077f7e607766572a065d4b4b0280791d1aad251cb5722409223a75d993896af4e9efc06f22b031e8bf701fa6183eb0ebb0a06d2cade83c9cd8bc13c1b33482e9c3dfa481e9ff5380e70303de9a7d4e65c41b1a80365a84a2be8195fca15d5cbf1790e88131dfa1c774f23bbceca06474127a5ee786a320c888e07c9fbead6e3c8a0f6ff2f6accfd4f96a40ad70b94145f4cd6a2651e297c8cdcb6d5937f15d117413d32179c1ee7cc849e4839c23e313e5dfa667d02af2ac6de8eba359ef7d8aa18664832c80ada92fbc1540121489204349b22864d62ec6c8c688b23e1fdd670d86d2d7320d29ae65e6500320fa2100f4e85073f0d8c88d06192d88f82bb57ef7db09d2e30194985f5a8239dae6ff5530a074b0e2229be67d018e250ad8df5131ae19b4bddafc99d3334665a4592d841ebac849f62ccddd98cb6d031069ad05001a4b0425aa5b86bc169085c29f24877d01f4ac8138ebde1b837a3966dc0ca37e8d2a7f4b437c450af42dcf7a852549c2abd071b10a13c5a011aea3b7fbb1c0bf975a73a02f4307b3e66a982e62f633dfc596548f5b1a6e5bdef0b2db56f14d63ed1a390efc95138ceee194eb5eb455924ba88dfdba3aaf06f9c5795a3967868d8d40ebf9c473a6df440ce85a6659b25bdd88142a7557f1dbd6563a2f0ea8bb4674995aeb64a69ed59976e4152755b5490db20acd708dd7b961c52005b824fcb7dd5c962107a5557376b6a0f0bf5a7a5fad4e41beecdb2b93bc60ff85d9fb1954d2cd09183f0e911108bdfe6a8f042fcaba15409ef7c15f7690fb170e24cd1d3139a145fde7d827a5889bc2c4132fc99b594d27c81ace42e54973ff3913e063667cf596b29f3fd088e4708e1523ace9da130dcc729075ff6fd846d1e988b801127128d6d7faeb0bb584ff081f11e07a7ab5b07cbf2dbd925e6bce7e422b2ee95293c0ffa7bd6d1a339bb637caed8030a37bc2182072ebf13fb43bd16895ff28f12747caf9d47df969a06b305dc358bc3acc8e21e2d1a83db4239f995c2c860e5a55ab489cca5266640df871a326b67f2a02ab2a000ec1aea218fc91adbfe31d6ff37285eb8e29a7fbea01b0fbb3ad7bfdffac51d141edca17101a0a26fb3d9535ea1912ef6539d2d5367103586f65c0d44b605505eb7730884fd131ea3dbf5a6d0e9bf388472c9fcfb0e2952500f2eef7161a4dcf8fd9dcf5b5dd83d5a11fe866ef23bce34c784037b1264ab8ff20313b1ad2cc3c689b6dbe432386388eefed54984b7633e038769d559b917246f1c45d779adae5f25a74815083db2fcac09233185abbbce9d4ab7b2b007b9033e7e5331bf50d816e683701ddf08a74387a037f6ff47070249a1d334a7416cde01c6f9b555a62579a6cbe725afdd985e35c66d19058944cf6ce569c637f06311d5b5679dca05d9812259bfbe94473351ae9945b602a7eff4802b9b914b0d930dd05404a1c65399cf09de3950e5f662b3d651c04e72da8fbad800a2e4d648ff5255fe9a1bd3d88adf20060ec5a44f50bc0978f241e972d1918f0823ee6b5fe7b6d1a2ee833ff2d740ac7df64d9bf024db901a0df7aeea13de33759a2de2aabb62e5356e868074ec1da4bf63f3527c97061cc68064d2988419c40e97a004218f24be9554ba163e72e089b4cf5f875e792ae6697ca5a9b63513ba82c609c38269e9731a97657485f8abce9985d39e78695703370ec84b9e7b1328b3051e7f14f49c64d4102689333adfc926eac72fada532c37b160fe7b24717e9d7b0f60bc643f9c4bdec0a31886e4d5da1b07ca7090172b4ae15824d3d0ccf0029b0a325d16dcc8e8e721c13deb7e128223c591c6d7d80594add21983df0188e2327e01bd5744399e2336d8b1fe6d97c89a8a48bdb54f96042747092727c2092388b935b4a424513691c6c78db8f2f7f3a4a7a2cd71445bd9e8772a3a9c7f3146e8ffa04b6c55f61cf2c45add529cc07e75dcb8944718eaf81d17d888fe4ab062d3d5623d005aa3dae3ce342fd1f47ff4e51d4da6319a544e8b9ccf500cb04099cfa93054252e53d94f216a4841444bcefada6a6df6a07f49d6d5c06ab0b4da5beb4bdb124ae0ba9778604df95a846afe8d03c4f7ca1b8cae96263527f382cc77943e3440da1dc4c17f2a9e41d8fb62f265fbfd4cd3eabecaf8506e66040db820be1a3a954cc2dd04bcb965d868bf86e1b1c60dd9ff23819240ace91f0969afe9664706f552eb0573290a1fea7aa33a96d0bd49dc708376fc24427c42d4b9ab1306edf80314a149331f04b7e60307b031ecf20fc886d227e33d117f76a53d8d048e4c2fd9c938fcccad6926fe667e851bc25aadcf590d21fc758cd58872d23e176a90749fbd0ca0cb8db63b23df7d0d6f9e727fc04cb32ea894ab23b9e1a7c21d99b8713cbffa2ca9adb8a4b31e582d525826aff30b4c5a14d037f765ad069d2cb28f11f839cef04e2a999ebe48826d69b1ed565b4831b5df62e9626904da6a097304f231fb057fb7e7f31ac594a8928448e3d6e7653115799c42c75f21d8684847337a2ccc3dc9769089cfe326d345d7786353e557afa68bea6aa88af14b1294424d653948da3487ff42c7eadd7bd4067284b7e94f527feba8e6541bea829a35435521010bd15a985331eb18cecd6f8d5a03cc17c53d890d37a47091d1838672f3cee2c2ec3db05c18748fb3c002e75fe02f28192de491674157c5cf7b4c33ffdf0eabf177287af7609ce7026b3b234c0d9d89f829b6325fc9d5a213b9fd7be12a06a6c37944bc5329c17234e2026fc73d437bf787d2b0fbacf168d942d036a20a9c6a5c38d2f7c840dc7568920ea426a244d8dc43299541bc2d06d586582172a861d505ef12cfc33cbca5591a2e428b75a3a01cbc4faa74985ae6ac6abd96d41cbb340b54e202a4d81cbc4c87de62cbdac05d6d5b1dbce8acfb235611660733ff23809f610cfa5220bfcae2bf14fd45b1fdfafc9162614d9c47f237d3d1d79bfde294d0c03121699e167b2fe957b781134ada98c5accd20dc2a1af0d4695e1a328b89464b996158f60f7924accd254ab313842fdf25ac25e3d9e39bc02e69bc42f79143fbcea7588118a21bee61325b955fc8a91b59fd21f905a5dc8f9a58b9c5fc7fe6137425f90cba96385ddb54d38c3ecdc26e75f903597c5f4ab5c0981fd81fe6fd857934ecf098f4627600eedd398ee0c723ef882bf14d8112bf927ed13d06f44a03abe94a3c543ba0cfa8f37ef5c773f5e394edffa8efaa2dbae982b424d1e048b9630f52de7b2a1ada3e498c52385bd5bde4e5fa4bc034b448f8a1e901e31535fd8a2ff9c84503327f29e195b2f30cf86667e0510a5bdd8c3199cdbd36cbc12ad07d1183fed72039c5f53ee171d802b559b614d782652ba5354d7935ca9e0903a9b755bc114bb038d443ca50d6eb5a0768342bda0e3b6b437899bb7d63630b045461ecf76880ce9010d807679ec68d68b47072d80cd9cfe6a25b3f0aea3cd012a74f6b2ba36abb021d359b7a67df324985c6c1ad1a458eaec7ac32d887661265bd4d159d5ea3f01c6a4957b5700015981d744daa24dd6076f2f6cc9f5cf51521cd500e9766e73be1f49663806d219618e93f575f77d287d84ac100349aa049cf5e9181fdba81e6e7bd5ec7d76f29f59ad42242844f3a5c40874140120c55e03901455632517c7c604bbf55b18a88d418a081fe6d7bf8761a3469324646de18154b25f28c8e667eb3c79cb0591cf0721e489247562f337d86f68e22a7c01edecb4364999b9864b35bcb9937c07075a1a73427fe282f904119543e077f591eba7cae89abfdb88a3377acb471831b4e4ba831c4a2e9d357e47938015650ab1cc1bb878c07f5f1b7ed4fd54f76fe129b0e9df7e57810b6499ab2f3caf73e744ef2dcb3d0fdd38a03b410da801946ff57c92a4eafa7e9e6376cdf0aecbf2c1d4f1d198af9b35be40e86aac91a588e8be9c997bf5d99f40eae76dbfedb71257c50f72e4bebffcd45e38f9505ca6dfd988bf1d60d1f1a6799799e39ae7ab57e5c3e47e739dc8d72df20f64bec32bf0763c822a1bf59b9f069779b3dc3d9c7ad9e3cf0e688871942b77d25162d06ce79ab88a2a090f10fc83d029898b273134eceaff5b97b761a1c7e3d533d0cfabf8ce71df239d47201c9c613ac87eb4fde03dcdff5b3adfe1e39fb11c13178c9659dd63becc335e43a17965b845735e26036deaa2e18e8a0ca908c667ca7c05740daf4ae9eda290e38166ceef8c9f7d0bad4d3de685712cddbdb80fa25baa56a02e5b3ec4e9cdbc5007dc410134d1382dc612a7dcae2268ef35d770580db9ce5cda20e091bd6fb29baf7d96e33fbea04e7912e8056d5e498bfce9d6ddb29689e956c8672d5e9c42c7bb54bf18a9896b626a110fae1a435be05cfd91b57bc2df36d21a1aaccbd3ce6b926798eee7f3987242e79c8f2ddb6b6961f2a3dfa757d0e1f43118a76bab420848ba63c810ecc8fe6a6fc9a036ac14850bfbdf23bb23e6392b378ddca924c146d8da97fcb86d278988e546d0dab01d44c90a6521430fd7efd7149c353a0b8df7e41f29cef3304717b29d9cb021e3935927fcf2d048483219c9853235494bdd8d3a7e06d8cc3a895b939e4a5897b82cea495d8d7b9b79cbfcc6040a105eaf46c5c0ca0a8faaa091b4362fff2307d55efe52755d2fd7087be34835ff73934afdc1b855ebc6b4dae028fd13e02fcf8168708989ddc05abf7be2b25fdef7008979a6fd4fa88923f1511b91c9f9796795b9eba84bb6626ae8701e92b0e29d08bc16731af9bc9abffcfa12f8416777b8de280eb5dc1dd0faf856d4e42628c70ecf65c9842999ccad8b6d63574b4f94eb291c59106c2b1e448f9e3a5c0dc89e3e1f9da55f24df1c6a9b51eaae18682b63a8ebb303ca449185f3ce32a41165f70d7b88fa9b851455392b8ffe2c94d6c6846e1099423ebeed76947ee69219deb41c30b5067827e81f303c27cb1e784fd2d31b6d345868d4a274783a6ce3e2be7f4a23c0efafb8aa0734ea5649d5fb9089def139564078c2567ec63182a331556bcd6959e4f6edcba95b2911b916f1dc6436b439d71fa092d813fec27a6a98639cb4e5ac2a1852de2fa932402ef4657fb8d9d84c36249f23c50172b507ae3cbfb1c5fe78516bb043bc28d6ca8ba3ee49754f78af1cf7ee23554800820f4bc7529cf00c0818cbba2de2f28da48774fc4c9fd07119cef755e7831330d143e13429d8251e8030f8c919995fbec3e05802443dfe2cda9d430f44800bc3ebdd779b138470f1fbaf415f29d971eba25abf1627200b50115aab0c9ea42c626e8324fd32a507dd02192098dbbc691fcf4a5820231489c3fa37b33cbea662acaf0838520e74ee9788133c154a6b1aae70140306fc35a0ff96d9887b7a14e6a7998160d46096810f6eb6092f879f43eebf6cde532dc4fd6cf55957170481b331a19f5e8841373aafb13a1e3d42c946900381f0bce2da694ab19325583e0e5b080079a7860665b5d37de333b13873f7c9ba6b4a8abc52aa145d53361f3a9c74696029e0725646d657b48e8847a9fabaf817859f012aa8576808b72b551fe4d316398906341e1dbe6325c3265088b280ac51459b3d846b12fd01efd55a617b6af62ec02fe87a1592143c32df4cc04ff558ed192d9acf68fc60f967df4e5ac61dc9b89b66a1adda781de10704d02c5cb65de15c3f6188cbb87da3b27c33151cf5c37a0a2ce4856a26550eb8b6ef7c261d9abf35d6d0c2065024a2920e05b1e92ff9d8cdaff90ced0c61818daf4c517e331daf868d107e6dd2e4e8bd484869bc1e1b4ffc2d2f9f366b00dc835932cceabc4eb38a083de368fb6c27fbd220d047bf0afa9692671cc8297045f16eb4ba0d9586fb3fc7d4eb3980922123cb5a6310a29c3387f32871bc1dda6b00021e3eafa4557776a03bf7ae0ad5eb203a0f563c2ef4bfcad5bfe88e08215bb39b90b474c1a299da4fbca4e14b0408886c80a97ff3b5dc7ee5a000a0879a0d76b62b623e753899ee727809f3aa069b73b373a6cb6693227d5f24e3623cf11fb8a5fe67d446a76559901b9ea4637ff733633b08c5ba374983bd957a1c6cacdeed72c9648c5a183e022b0f1a5ec2fbb141fa9696518851b0c156a1167ae146ac44e06915c8aa16227d2637d30a87f208553f001973440605eca9502a5d3ae135912b166d87bd6452ec108a38dd81e9a30004a8467f415662b7ff0b6a6c262f9b98146e150bf2af49d09bc092f4b4b20db8c8f1886b093aca8bb42940904e56f812549dbbdd2874f36496b223857cab7cad66075ee1271c8fcc7aec22193ad72a7a8ad641a25b78f6bfab13e631cf90cdd5de465546490963bf979c3e9fc8bed9eae6d6f4740da5289b9f0ff3a5c7eb0bed00ccbc9c0186aa063f3430bb70af15c5ea12db8403624a5ad9a1b87c9dc5b1f8f25c5a561439d2c756a4c7a9f744c410933aec940806f6e04c7862c8d28fc698ec6b19c3ce395fb46448ce7d02417ac0282bc11dbab3b4345184adf75f6d0efa5d2fe2b64ae14fc4b6cb66c6e60fdf9fbdf870b0823478c0d497809c6a80d3423182ff9467ce2d5e3133ac207bddf5007187e533899dc54af2d611f237bb0a848e6821e073ee35a4a5eedc2dd88fd7829b494d11d8c6d9345d5c9593bf63a6525d4fe156891ef7bcc4f7612738d67c68052314c1c8fdcec893886e12bf462a3c2e0e0979f040ffc3f4cbfa5d63cd2edecc3f12668b85e41dd0d36f02468974e217ff4ffb292997a6420fa6cf252fd394ce6e96ebdfe787cdad2c67c3639649fb5b06d12196608873445d89623219d754056e79af0df0e8f960740f563c2accb527a251db499ad796b23030423a68a4943da4aef0179a0679bae5a5c64a4bd70844999f3fc5f9fac30e5dd12a4496d8b38f2de9446d6cbbf7a04a39705e95c500bdbf3063a6a94a43b8c715ccfdcba5a24fdfa5d347b262c11fe956cb44e763629abf316a802b801fe1ba35d17ff2dd9e00879921bb67402b56ca6976939d4c5e9b917cd69715e73145de2eb9519b8e245a6f8a4f5c05c78a450c2f9f27b7cc3636dc52e3af7793e2b4831497a4f51ca9f191e8f3ad3e374a9ac2538a75caa833b3d4b28841c1a04643695b591d20f47c971777e9349172e9ba1055ade9469e4db362c5839cf965a2a45fc267be9b096c2df27d377f1b6d74287699f96bebdb514d7146534668fd26995b437e480f90040a4c2ad4c1ac9c3e61664645e19bb2b1da7dcea923f27fd560bb4e3b5f1debf1a61a52d5b6dc8e4049bc62e20b1dbf5595579db1c2aa0fee4a04bcca1360e18d4c00f524d22965c2677693886c03848d58b9a0a1878428f940ec06f0ad09a321f149776f18210ffcd95c06ad0941b25edd32f53bf63c4fb8dc80087f0ba6782dd59d066ce998be2cb28a1626fd193a76d341cab1072b69e18c37384c89aa94730660262cb5cb364f3d742cf89bdc2de4c22a6f19b2e680c600ce769473a17b6c41574d43e125f419a92f0459253e232bfd969256f974e201a99a186dd1c2de4de6f17a5e4a27996fe28c4724d7d048658d5c227a7f7d45d09de78e951c49794eb0cf49ac4fc6fd58f315716157c5d53588a0d6e7df2fc0659618955a54ff4a99a4e269db75c69c80f8091f341e6d1ac14e621aa52fdc8e91ec3d947fe3a5b0eb92b1fc9200128753741a81effb31aae0c966575084b9400c66c667538e8304f05968c377706d48c99d09eafa1b29fc51252381e21663e8117292555b7952a4aaf6ef8ecdac6f67f5664777e88bf5b5394f0dccae900871e002789b2f94be43061da3a8570e32bc5c5b2469d61fab33444fd072bde7083065ddc11d6c27ef10d75c12e56b6d8bcc9663996e4df8ae6a083dd23c1bdd6a1f5a60d454fc57603d4f19407f8835ecbf6433acbd3d5abdab455ff998ae65f607ef5201983bed0054eb649ceef62400b6d53c3c001d1182d70192cc47281b2717fb606a53751c6d065864942093bd413397812e8aa336e3c85ea7b109f3e63ff653818fbb62be6461cddadee6c1624f4b77e83aaad84bf93fcaefe4afe6b1319f5892c4277ae27ac7afb5ec5b8376fe3f79e9696776086aeb390e064448d971b822bcbfcf093d5c0b836bc8ab0c20b883e785145c228875cf9395dff27fdef23654b17ba16f7c3fe3c86aced765e577f8b67d62425c7db8e70facb1bd9e64a62eb20660679954e4fa75aadbeb18f767dcce8df47f07b062e7358fcf2280e7b875f7433d0eac1e81e4b340b5bd2e8a44a10867e9051358e5fe0b2f1a34db2a691d3fb488b64ff53239e1e6e84e5565379765895bfbd20a58f8a67af877cb19b90b32ced77c74771953ba87ddba0009ca255db0c9e9da945e800f3277aaab1a0e38c8cf3fdad78baced2c95eb724ac507638d59eaf51ed90c4772088f1d1e992f3817fba5bfd2e2d9a71c6d8a0550e17f5f705e12f29df483f94a81164b87e6c870a841550a65bef39cf5cc870e19a3b316628c2af509ea37b8b7d717750117d52aab4ebb60db6f92af3613f4f05a8a591eca9938074ec3a9e117526e03f7b5a353fcd031de40f2924b2fa7a32f5a11d3b87287d67916b6e1857d8dd21c5e01d163a08085953f1d5668bf7745c2ff6a45611987b5fc7309851949c6ce30124d080c1c9cda4fb0b47344fa81a8155f5f77d7b79c13d657c552e2b95ec507744905a6ee03414af8334fd577b667ecd48f761de79cf74b4e689fb32da59218990a57c33708931b48fcd2f6eb9a54368bf0d15443767b7ed268fd87ba6b879ccb6f67939ca16f3c84f127a1b5aa1e969c48eaa2bc31b9bec05664d2d59722bc07ec1fe47cf5821a6f3e090c7e3520eb753694d9a905c1ea0f8588c1cf82b2cf8756e612ae5f8081a79c339decf5a38e601a69d28b143a054a34b48acfd9d69c6663bde010b40a54d037be6ac52ed49fe53a9c5f1ebe04b826186c427737d7ccb4408c3b820f464cb791b25af291c34d77cd517ee884bf9e79c9bd73f411fdcb0620c09dd86baedee8dc992b06d18111b73dd35e0334a27134b19f48e2ef21c7e84a3592935508f8b31e54b9dcfc0e04b0c66b6c193846d047806479e5b32cc69949caea0caf273f3d23cc153c25f0d0757c2f5dc2cec3e6ab5bd5833fc50c150afc3d4ab52d88ccccdb6700ab1ae771f5d833b5cd3e78fbce2092e1effe591e8553816ebc9383dfc04f8ec7884f88eabd50218a6dbaae1fc22468fdd301673f0250e3ba7ade92eabc3464f55e47314aa36b743b315f82007ea99828cc45dc0ae0b7250aaab1a32e62d1b1b23ba70ec2be001194b7e7362e3a65d90df5b38194a3f826e2c6990a85f3791028478e2c46a7b320913269e26688f60482dc2687e2e3d26fc980376942f40fa862af58693d16983a6c7157f71ac671558077e79991c8641c7a6a7fd1c41cb4f7b302cf4d79a7e09acd43b749b35821b06de361504580402f9fcdc2e28ac59e011be14fa58ff5552a161afd84993065add2fd25520a7ee16ffe1ebec9461d7bf558b5bb8de2f1a98d3d640f4db7390669dd1e427fc850a2e2b3192b6ec29e085037d717fb6aacd6ddde02c30608fe75b44fa3f560016768d44af440074514b97e10467134023f72b43282e39687e862fa5bb70fc8c0e3c52bf0cff68f48372c31dd51b857384d51698d11e05ae641a0ba95ce7be5abfe000a1716f016b4fe2e4025ef88521e8dff37c5bdcd65bea772bf33dbe5d79ce6611015eaabca83ba85d559658438265d854e786fddd94614a760ab3da42b8c7d6ac87754a15b7bfb9bf358ae72826132bef858e04140178fb88524382e8667aa25abe76729ea1d0f45a2cf1b994f567f6e4582bc991b1107cbd774376a945a0d2ab85d85d44814eda975a9e80af0a2fa33522718f92ebfa12ba15159693a97b182df7f49ecca49e814ed4ab8cb6a2ec0c350df400393da66eb7f7efebb5769ef4eb3340c031694fb4af8dcf5df8fdd85eb6f599e90fcba5326db4a1e70a68c71c6a85028e78b81e16f0826677dd7a665600524e0ccb4c9e49f78923ca3584d295307a6faa3d2edf123a64fa4290fbdb8ac8f7365378689493619b24cea0011fdbc93ac7e371bf557720ab8f639f80fbbd9868b4092c36fee750e3c6fd190d4b3937bbf32b6ec288c5ae7dc37d92b742c27a5038ca1f4100c5ed9fb877a0fde15b839d07b6eebacde0a7d9279fe3164a734496c60306e472c7f3189ecefe0956f4c2593a9fb2709d88dd41f72feefa970c38b88825e0f6fbb08511dd5da27ce466f8cf0861ac33ef9885a9eb6d02cd453456222a647d798baec6891f9f2ed957b9cb8ca87e7618c80012757c12ea6b827b897dd9f984b7584d3d10d5fce0385b7d0c59f1da62166c4249b02292dc42ad2ac7f79ae6f2b35cf26d3d0584126251ee1b7411c03c54672f8670c8c4fee161ddc90319c3a05764e9d5cc0ab8ade29b9f524f57dc410d3dd4e5913c919596f31bdee32f24096b6d91bc73694e3a6bb3f3374e1734e68820ff5c3370534f75f379ced2c28281756a09e3e432f62f005c61524dad0b33cf31a8ecacedca3b6e80ddcff853f2b2458e4093a7458fa158ad1d8f3ad42e0babd7d2d1dfacc5c049844908f2203d7cc53d276b961d428b68527bdc2c5e9b3432f41ae6343a3fe219e284e15f62cf80f28be4f95c21436c94d493fd1202756bf52337e2f61615558afac3729be10178ca91c57eb95839029f6832ce139e339db3afe0cc69454bdf83a6739e2e2370f189353494819d195a4a4aaee50898344da78dcba0e8e25ecc1262f44639b2e1026d23ed47aa37af2df2b5c69bd24343f754542f91c0922835ea5ea20c24773eb6a0cca40cddaf47fc73cd2cef15ff20e8b9e6d42d325f59d80149c863c280c6b0780654c08a039c2587086981b9b6d088d362373e14f53448df4ae1e88438f774c19e8b356980b90f677ade3a7f38b2b2e39cc8238b6afa225bfa539c1bec8269bec5fe50aaac0256f9e39accc8d95df23a552ad74585f9c1837eee54442cef296f3518cdf6fc552d1b4673bb696ec0c1cf3aa0be34aaa368cb3e0831134a2c8990ba834258bff40801169a515a6675befc74d987da30c96e0aa73fbdd692053b93d802ecf709f0a8fd94d7d6f59e0494d84f35a8d6bf318128a1536df2e939e9668d0ded3043b0cad5fb763c3b4278918fe8875f78fd6f9db1bdc2ce09b8be1ece83558ff53e92fa4424c2c0254926947336552db625bee21f08ec784fbc4a58ede00fcbab08de80948bf0210d1dea309f5829f3cd8d5d1e02d62021854b67b8277cdc476992c4a2e2e928940bde85e3cdc5a82fce8f21735ceea6b2","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
