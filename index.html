<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"04827de9ff5d46a622dc0dff7bffb62a6c73650659980224d8057b188203f22e997d39086471de978861c77b90647cdba88d2e26a65ad5e84994d727633fd60581c6a77d308d1aa4907c2577a11867f3d700f653f8fdb9b1034469b0f068c56caa34157b2328d2252aca8a84786a5ac293f37115e50dc92dfe39f430ee77635a16c36c0d82522c57ada468ff51a235dd9477c7111bed39cf19d0f052aea360e7c95093231ef43990e3ba592b09412957c4de2e4dbc5003d9362c2a0fe031b1d88980ccd12f09a30b3d874d2667cacdf187cc185a97318e6f95b04955162864ee1c7b65ac556f129b9133fa5aefd4b7e67ad64a5027dd8b9331accad03c0f3ec75065f1fffc4627507d90974400c79fe8ee08163218b43bac6633278353d239ef63da6a5b539e481dfa4fa1febec11aa7f38b5c3e0e6b037723eb54cc0ebd60aa8a05a85047021e539c870c03907097abdf45d4e5e72ff653a8de404b9ada30469944ad5ce96aabed8d1b85f7ad3c97e9b1c140acc589e59637af9444e4f158b94c5c925a90fae4a7513130cca0171f46f1ca6ff37ff37b953c14b007049544402971996872d7d223571e5a33e5a8a3059c8d222ec265e8d7362da813ef2d1b8bea474064d575e61e8b2ede16486369c8d7d42809aac8bad97606853db4af19200af18e1ce9c920e1e2e96f5b5e93806bc4b945248fee1b36878286171719ade2426f0352c1ed41c069924326a559b406a6c0a546c9ef82c7c64e4a62b6239cb78d4f97032be4e3876b076b0e7266990588775ff5b192519663ece499b9de1ad1882216e6917c2e768e52fc69bac4f136f3e7cb2c33b62636489a580e28914ad30c1b21d48b7b2659851228062a2b6faa37cc0841b29f9912111841b3c9e39421be070ee39974c82e9237f48947902530ba0f935966f39d4e81aa166a4d70d4674973db5e8a91dd7b81872248fe623cc0d393ab3b5c4f4f25959b5e95a8b4e72afe2b9188a674fe1fe127f5e7828622e6938e840a287944a9ebb4f25a1c12edb81f9bb2d3cec5728a4ef60a6f33aa8e88d6b630376b0a8ab55217ad1c86d38bc0fa54acb41fceb778b94862913b4061d9690c60c0dd8cc9b2c7c54784c72b885de7589faa976e13c77cfe786aff8ace86946e70ebe4bd12a7c6d8f61cee3324910b7ab927243e464bedfd8501771f55eca9efa584ee9f5f7dead6be9307f99414c98c9ee49a0521d87773efbba29e0ef3358e0d9d6ff93f10e51607ee0600dbb8ce284e02fcae311a6cc43998a1d12b4f2a4a5150b8cc87ea70fcd75349e65a7ab0ba62af487cc1d59a9305bfe53082e00af3b8ad9d4e44bc2e1b0de7151171563496a0440563d11d107339e4fc46c1889c08d9606c54a417af56e7f1b56e13dec2ed85cdb1e38ffb0b48e6eed5c8bf1a9e6f1461ec24eb2cc03d0e8f66611832a4310eaf01bac9ada48344a00285cc9a5bd6ffb00ec6e796bdc234a829c5b03e2f5f2054495ff39d74fdfebfa6005f8742d68e51e73252e9f5fdb2cfb681c715fbcb25a01bed87be557a70caa73dae2054d0293adf388a15a489c7a359796728faefc8364147ebf14a242a8bdc55359809c05e50d36535c941dc12e9a43378ea596bd0d2d595faab2d3583b9bfa5bf1aad0d17689793341833324baa468453479c93f1a712016c6f08aadb8fc3c83ff94a73f1d9c31cb994f809edbd3d17d52a36317220de1b38e37e4221813a44dc67870611e020419faf9f75b405af23ff043ed0aadc927c10cb8ce3137841d2b8ef1f9948acbbf5b27e6b8e3975197dcaf2ca5913ff54dc3b01b3fde82904dce74217e23c27df1f2b3d0a90d62abd5dfb1c6199e971e2926ac7f8bc61a10fd2f7dd6d9dc0b414dedf12f1de79673194b71a1679401a148175050f7e4ff568b0d858a63f907c4473166b760e626ef1172b9a54447788eaab6b09c57c1ce7f53d3b102c801ab253b363205ec91db0a0800ec765c65e9d07ed6bf2378658b1b9768d93d9083cf573beb17d588595dcbb44b660f1efef05b40588e6a0655674406aae2c3767b7f9b05799027f7434a1f635ca2df5f3c8875220ed6c32e7b52601f1c75d5925282f22289ee8057d63786e6c7562a812342acf0b828730b5e20a7036ab4ceebed706bb83c4445a8b793bb5e529a9ca0c664d45bbb485068be3de70d4e7b9e32ec71a99cbdc28a49b9e1ffa89b299ad14dd86609be80ea670d0b4e02b6610f69a83c62667928428455c49b84ecd34e913a282ace1e5e142987eecb89f7bbfe9a0d2200a403385a4d388f7b6d2ef96ea94bc8fb2b88326c6d879f6f7cc39e122b09303b80c43746cfb861cee4dc6a8208fd221e27d41b147cd0adcaa9151fd5569b6246dae014961f2e7c6769270014da70a2860c22cb8d80d5a65d30530ac76c2b571275531964eeaca855bc4037535cbe4f0284d72bdcf4270a4846c139ab379c5b5f5853c544257a9fe1b67287585fbd22853e75a29a7bec0d4b82685b963a565ab56c3e9032bee723c885d74152df85faff0b9ca6b0193192d02f2eed9b92e1f8d1d555d329dee6c467396a5c4922e2eeb286fe73985db0aeca672075b7341d1e439df8c7a967d2f2b6d04e3d6f1e6a5b0829b34df3bfa9e0caf11ee753ebaae709bead9c62074c296161cb5ed295934c25a0c633fb43856fc552eee1a2feb85aa80af00b3c0415ae01a9513abf94115e24d52b09fc1495609bacbf97f36d2a717806ee8f16ff41d55c9e3c76106ee20d3db396b3daeb2586ff5b5d517ce1ee8a1f3254627acdfffceff11b4700a83a149a18a80688a5b565c6ccfd63a2232dd178ae2953370c0771c6092c0d727a2bc50a8b267b36efbe4a818d9d572538a054eaa7fe0de0fde0d674d2b7c172f734ba23ecc14f646d1319afc916ea86e86173584f9fa07d950cc05b49096d9803195cbe817a4eb2264648008a2accd979fd09af079ca94bb7d8a74cb072d3e4baa0b388f5d193c5c40e1d2b8d7b97b142057a980215ef1932b514852a7cd40f0f208df27adb9701d6cfe766c18decbda071ec2cebe0ab0a9fb99647c5aa3aca5d677fb8d223d757dea8588bfc63b718e632a86412bfddd10b7a7643474dfa810801c2a7545cbdfe7525ddce6d7033cd4a26c308aee6e44e6b313d7bce7443443cec3a4fbbbf6375869567e8e40a6a963ecf828b7e958c53941d2aed142fc9f9ea37b7b1a73fe5480609a32f26d66ae116a6af560fa59acc3d868697305484b6f596cee6af6cf58bbfb846ef38dd60f940cb681f61210297e5afcf06a4219f8b9ff959d5f33f3a7650ab2494883a2eb6c3eed9b2937856618bcf7138e5042c2151aa4628614e003357933a63d20fada5ec8257e3877668185ff8df555227df3f40c8868eece7400ae1d8f471806a2e5b192575ebbea363eccd4be767f1a007c2fb66747ea36f21a22478a34ed40f9fc529557e68572c5fd80c015dd9e9251a8ea2e8ad996b246be55e8af776f274e29dd9388708ceab49b9b2790a19cde665cc28424e5f7c60496827c883a94998752486c87b1df7a4bc12196742a194858840986a35032b875e7668f79e9d30a18a67396418c4756c9202f765e40c4dcb129a9df50c9e168fd0a378a18b44660096a3d1ea1e4a24a9b84a4c33c66c29267362191b58a41fceb224a5922e94db7363c3f7a615878b15dd8eb182dcdab7aa136d0265ad668cf974bc4aeb61e31d24f32d453d316c529ede51123297065933d0717bf8a41207e6a8b101c7eaf1bf25820b6982f130fbe2fa274e3b8bc32333f2640e89163345211586e17f4e7a902906aff3e11aff278fc4a9309ad0a7840e4577300b8603616aedec9e58ab82041d3af20288b63dc9f93bd8d639537cac3fbcac8cc691ea7367acca94b71b2d59d79c63092ae587ef44eca6aa2ab9c7a2eec5cba80c85ba36f32d5b6e6fe3f864f398d61a184b22e3ff5be0e1e4bb24018c1636091ae0482183c1841cedc655ceb976b17b6ae3035075c18f840f77f0120ac231aeb8f4002bcdcf176cc21538be3cba5ff0b01bae7a976c32f57680e9a1e227b18bc28d30f9dbeb08845bee0b840dc38a68ee4b1551a9d54548ec60087f9bf7427b046ae61d88932ed277f65ca6927cacc3576d6467144e0261a70b9c7ae13128f5feabe9c12db5a692e729fd118c15886a0923dd9a8dca7f1acef2df072b451822ba0a0ce65d64d56d8daa4193deb8d55cf9db09ef0b234fd4bae739fc184f308cc85edbac5afd893a35926301ee8e9ce48ec689f86685b485e624d700916def207ca2949fa14fc4604488e3be1658b03a21a41fe7887cf7a80458283190c5c0cf5be00b6b0370e03f0dabca2a6fdc3c2cc795a5e2c15f8474827edcb0482d30eeee86ba278a606ec06ed7f15fd46945569604c887469a3b1179d318bc84eb2692afd1aa0ed2326ccdcf8f22d9d0b25588984d679fa2afa845c36807b63bce70e105d536803ebaf86acef045f00a5e5d5add0c3006e97cf1c82bfe681f14e58f7d4d688157e0ece404b285d31398414cd6e82396fb82d2b41d73b8e9028bdebce5b7813dd7296eda173a44a121ee577ce4f2bb9f50f2bf73e08bf12c96986a3b63538c676a9d6737f0ad617bb05124f7db88b92136b2b734d35fb353bd66439b610ea0f797893db6005f85518a7ce710dd2580bad0697847820ecac81a67be21ba1a20e1c3034dbb1af171ff57218286390f46c9d64fac71e115222ac92364cf12c3804bca473c04a05be18200b91f9cf26b27fec6aa93c689c6ec9a79c2ab0cde6dfe1d00573059b4d98282d220874e5b17e868d4f2bd008568b449c45ee29fc19af179fe487dada52dc66ea119049fcfda499229f17a0d9a27b4f342a65c00b0f7e4af0e9e83a3c87edb8896b915c043a181b88d540f2fd4340ad99bf4d8bd176b1d8ce93d630acd0c0c8d91ff29bdb07afd3b388e6078b876ce5b1d12c06c43cd59f5967b9975b1e00bc392774ac3cf99bccf941d8d3913b1b6b6a3b37f7293e9a751c9d4069eeaa837253cdc69103bdca421eee76f0752675930169042f404ec256f869e10a09583bb40c89c43d9d1c5a6f065398c2c5f4c15644948f54cb40d301f6b8f927e96c42c1375adbb6b53386c1813c27d818ddd0990ab418c4fd51673ab04c1bb67f3c6347a6796ef423d890697cbff20378b8db39858d2a7ce41a91bdc80f23e97f3fdecf617de0eb436365cd97b5886c4f6cbdea2c4d9fa07fdfded6eacb332a0ae0e8c042252efbd8547f53dbcdd92cbbabf7d6b841fd1998f6a6e3ef3741cd2c51b4bb1f466f154f6ec98a57f4332a8ebc6467f939437b4a34b8083c5922e807175fa16eb6ca31cee8a8c8f50b4ea28851123da607c73bec2215cfa7de75f4d56ad7cdab8618d435a945408157acf2a2f77926db65cda672063ab7b7e3a091ffbe5e66ede8168f61a85b63564bdca93c575c9907009f4de6d39c6fb230cc855ead31a9b009d8976259ab1e843b45fca2105a4f23bc7f9b93f7b566b7402930c09a82cad0c66bc2eda7724009356c28e787d0fc8163fbff1cc9c05052740cdaf45f30a7bf3919960ae02028e6528623eadc3eb23f778d0eb92ea2caf5db801995730fde6bae16ae863cca113a4f473299dcb36c4290663ad4038ce091dca24a9ce2667d825675f090022d7232d1e834be8095ba1d67d3992b9e22593e0b0bc8b66238da2ee7fa796781704aa164aa81956b5f9513c1392291c702991bea35439b09ca1784166a09faf675c864cddac13f370ed4b1fad6d3b78e2c9308855a1736e1890f877341f198171075c09bafeb2191ed6aa8b87b11a3a852fab2e636391585a24daeb3886767b6125c9ec07980474c6669bdcfa4fd57e9379b66ccb5982ce70c0e01ee10d66c6bc9793a49b36051bac222be54e3efd43b68b7283cc78c54e49b304883ce35ea62f86be8b63de4c2029aedd0eadb4ef57212344d1283aad196712722444c0162d973eeb5d33847cf0087fbb9d347e9a8f8a3499b349e769770032e2af88d09019bae3c6724a76c6109a425600b4e9a13fd7838ed5f4de352fd7beb294324f0e9b9118ee04e3de5a77dba4e9f472ed0765d8c1a9935106938436a08e768b481f05ada81950bc61483f04a04ec92d8e86941f478cd0de25f0f0c3ca62d0982cb68f02276a0a28678859eae4baae1496234db4764201090325ff6855eef0b96fd5282ccafbfa9bd312cdd818b1b0eeb78b1c4163d83168eb3f626fa95bb55e9ce7de46141c5525b06e4324e58985771bb5d1cc4defa088bd97a72ff5d3ab7251380c590b04812e1c3752fed3001e1123645a537e1ccabd54aa15d10c467281af350eac908a253156cac13a05df2b18023a1bae2c9c96aa958b8023fba1bade9d83f815d41fa1873828efa7b553445620e4b70d6bd2aaa66f1dadbff49337b781cb09e7154c92b444b20bb53f6ffc24e72119868ef61c40e1c6cd7558ee76be50cf0bdb7f928385224e8578208c9031de201eec41aa3b1f1c3e751d7e0dfe28938bca0adeb378104f3b398b40ccd486e7621c7d056c485020462fff5d679da4c4263f48031595072059fe73a0f76fdf50c18783ff498fe25ecca737014486943500e22e023ea0f24b596701612f1932ac08088046b60b4b09426e429e84f2ede4f89eb2e5ef6617551330a2c3b65c8bfe2bb2e19bcfdc0525c131d0097c47eaca93fc4cb300990ae7ed154fcb52cb3c056b1dce6872dcecdcfe48e2cf8928919f68a82373a1d4f157072d19c712fd647c96972574a505b915e85a0304b8c7443b5941e1843a176c1e0a1d3fda6899165296906e45d117e12b651b1f556226a2ede84e1caca4210a3e22184cb816dc0df432bc565757e7739419320a2e773ec8d5579c49f557ac2943cb68743c3bbdf41b8b267d4e7d7ed87fe8a110c531876e18a9b4fd09c9b2fe96868e03aa1be6745dfff4c5cb801d3eb9711445b4ff9ade74adc92e6a3676b1a1177b060c4cad9a9e579f544c1048af8f1ccd3f98344d77b758d28796b41763dac67b924023bbb18c2e9e5d4e939ba4205388f610c7e500fcc37a5203d54b5e3f36cd5b1daab1dffdf95018e84fd1e505d6321049a65d3f74c39b0425f9452495e1ee44dfa5d3e44b5ea364a47389f98ff30bcc4302dfcf34cec99fc091b8ac3df2266f9575b23b86a3be18f36e08a0cd82165860674f31268640582aec34499d6bc987c2d4c730174cc52718cfb1032252ce9a2782df7abfdb201b93f9b73702c217e8619ab4b24c4aa6532e2f4763c72754316f1fcfc7070ae4945547fb601d5427cc3bb2748bd9a8b3a70ab3905927a4517bec855480a9ef2fb2576f4610c24d55ae1cd41ac03979abc8b026ff6563ea23a480ad05e933db1dcca0953ae2a7065612f44f136be1bb352bf466f2f74d93096d5bc9ddc42e51be97ce3f48d4f04bf0067065a2aa71c65557f9321287e432480e1c25c3555f7943de4e9e15965024d93aa1366b642d49d067f0d8e48f19373a45dbe5dd1405ded7b5073232f26efec94430e743f0dc494ac9a6b7bc334bc42d16fbf32a59641e436dbd4586dcacccddbd7648ed61a3aef75752bfdf6851411c719fba22407a065e81ca0495afd60f4c6255c258cd2d19cc5210afd42429f459126d49f6d51356940931bdc5365c5f4360c37bebbcc83916b7062011a15cd64c660fc593dd26cd92fe30fec80a803d0736415ba4396d063af1c8e24a8b839dc345716eee3847c413e2e31d45101b16290011e64feadeaf1302d1fa877733e047bba7be7cd2a41567c7442cb8f0934e3e4f23fce18a512cd40b7a6bca6e434cf3ddc2897e0cecb1135cee98ddb7399ca07ebfa56360cd9cd1a1a02522332986f0b84d6f464de9cacd59e4a041b246a77f0f963be9736625a7b485fe5477b41a319c5e5ac22cdffba776b78c7e946b3b1da164f479ef53c5e26a01997df72f5ba24f844e8abd6cca48ab48f1e2eca908eacefcecbb9488faa8b4f4ba30670075cccfdb41eb902ab2770b9182b0a9c2bd3f99d4b17cce70251b436c96e3c0517a074e145a1c52e5dfe5c39c5d5b2bcde32facc5ee8174521d5f16260c3057e10b89f09a93fbd4d45d6b6b0054a0f4d87dbe5241b613ddb557953f58a5a374a1921235f295d9dbfec9f1774d027e16394663fa636c5f7a8d19c7ed9979ade85ef096505cb625c1786a67eb027af2c383fb35bfc2491606ea9003c2358b9b19bdf68943993e4b151242bf4a7c6a725f795062a29db427918722e2db4f240ab5b14f0b45d077c4a93c859eaad7a26c136e834dc4a4a7e800d8fe51f4d0c795fc123cca3011798af88ff6f700e5768c6ad22f612d47cefdf44b25f2f94264ab0855d6f9f450687a4131f58f8ee944b74e0c1aa85965c1a68dca167943a35d77a4e20b08631ffac54669a7c66883da4bf1b7702c2d916d594245a8de7be6a537421072ccae42268157bc508696a6c9697b74d2ac98ff9438d788fd8e747cff9f18f0607357ad7b9c30be7fbba56010be25b0ac9d0d0051ba9992671d35040de7c524b777e6703999d0c381b026bd8f6977fe0a955b678062ab9eaf9199edcbb73d9433306ffbe9e34fd7bb53df90e6bc1078895a419bdb5be9300dfe22ad9fe8b038b0fb686e04a07492499e1aadbfbf13f8504c01e4a5b589811dba58201def8d54230df75ed515956060859afb70a1a247f4277986790f895c31bb84ed0ad9e71b781365d362882c727caa25dc2ae9fa70475d2c19227207291ce3537a9c2a13e90dbe8b7dc853fe202178b0f3a58f324a6905ebd35887b852e98cdbcfbbdd2c3bc127e3e68f2d1406bdc8c2e480ee955e137671147b954bd265f7db739656e2836960bd875379b1d6e71f26b129ae18da73376af392bd3aaa0feff9d5505dae4cb545b2063dd66164791775e6f457ae501699eb031ef31f8cc497a45a024c39dd7ceefe7871e1c05dd5a6a4ae1fd3081ddbda0bc7b7a6209b28ec25f13f5cf0058b651be269c14bc215b6738e1eb4b337786737726b24f262d126fc86db4b43fc89cfe920f7c792c79c94d222f0f3a1c8345c703c0e23f95f0af91ff875e5c0ed84eb4c625067f3f0d8b79e70b761b2e79c5e5cafd58b5d4d4dcf7331de0853c8d1075617bf6698daa02532acbe0b45b95a04c17b0541cf80f5fe583df577e815c6f14c4875e919b59c140097e9de23ed5a77d10a212acd96b0ff8803e53dc5c0ec03dc84a707acc33ea3e1b99d8cb4c718985ff122d328bbfe042054426a7282d888779892717d60be5d39766b2e12848dca71dda0d39736b045213ae7a5f013ecc2b37270172f59433ce440833f87ce4d1fd0b6651d4f555669426572e2e6b297db1360fd1dbb4fda905e39449006ac82e7853abd60f19e4fa2f49647c009c191d055175960eaf42485026e3e35151d74d2590585861e44069b46a4d95fd3e511d43f0285bca6e61415889e508ad3d168115b28c2ed1011e4c7254059c443c4e90ef157328156e7194878e8b6e79f0eb4e452b91b193a481929340308edd22b7114fed8ba34b2c659f55b774935409f231b4c708f595376c9d35896d2651703b756b702283e03a9a2fbd37191967936a1e8a36ef389550ec6ef447f3a6f6019e83377f451dd6ae0c6e251063a622c7d9974c7ff55c268dee6e061bddce7c19dc6108b7217af7950578a0dd30cff257fab5b3acd4b64ad711d31fe52b15b2c370446e4d0ac6ac2ed412c0d14913186076162e58f4ed4bb53ca9546e85c27558a4c7d770cb0b5812a52d520102d0e1aace00bf6b0f33682965b93b5a6154b4fcf99465adbbebe75626f0ce8551a7f4066412e734b02a24f64b98c3612f32814383aa008d580a50d0315d2000beea16b2bf35ba7e3e168848280e0c370a8fd66b6d8c54935eb468fec353fab8f7bde23f50e54fb2f02202c7a39a802bd636c5efa30ca29b5359cad06a9b5ab351bf5d195021bf66c60fc1fc1dffbd3ace2bb079fa8012edb3369371930b9129b4b7ecb3365096a39623259b16fed4740f43b8ef424bb960504002e0f2d3c8d39dc49fd61ad02dc304ba9dc134e0c447ba25dad5836cfb76eab3a76076459ebc5a5241144f69990b2888dda060535f08799e23f390f3ad41cc5004da177661e39e1cd5937dc0e253615f5c878cc937479fc4e6a36a09564c985289f2a9622e02dbb0b34ecfbf67fbe1f32870544eb7deb9cd45d884e83ffee033ceb0f2d6479f80010173ee3c26fdcc9fe39beb5e0a0a8f3bc75383e40191e663a2a7a4ef436924adbd8635eb3cf9eab7004e6fbc0a0ce4c901d57a2b1e3372ea5faf16d5bc9bc7d98f441b25df63e6b53cc9424ba065af7ba4ff56aba8267e4ff0d38435782a350842677f77559ea885410ee7548c56150ec8fdcff706919b9d9a3910a903e8a76071600d59de64dee15793c7c804da6987308643f9655641405467ee251b50125cb4936074ff5af50d0a5b17f62f86a30a0f047e6482630f7ef44e2be947ddacbec3c9bab642cf24fa468365f651d476f5960db9520f188efdb236076e2f50295a0f8c2f677d55f655675492deb0069016d87927b206667539921112a36a82413002c432856e132f3597ede88c4df7d315f64e48d18e9463860ee649d75f2285a3ac5773b16069281a3167fdf2cbfbf5b4911428ce22af9ec5d494908b99d00fecd6668aae63cc1afca33cb8d9548c8e57d47aa5a9925d7a94dcd23408ccec56df9a390610d5073688f54c87d6e11f8bac7a4af18caa12dc55deb46bb843cca877611de1c3af2d5c3b763a8f9c7f08c2371ba3d1ec1ccd940d590391b44dd85a9ea5e4c7e52396614d2e37bbce648535a7f3f1aa9f1d77cebafd41496aef21f5c0b862dfe0bcebbdf26eb6ff3288feb2ac1759a2cb9c3b2307e7a2657b03d5dbbf762efeec247bf633ad120f82f91a29f8f1b3e9cf35bc985c339fcfeb4793dbfd5ab2c832ee5de891f6f0fb18180a94e5f4b8df1fa0e6591a474ba13504b04f94b638b017add600085c777e0e4d8c3a8054fc5beb06a9a964c7dfb797b04bb8646f4286c4dc910250934abada34aba8ca293a9e20849887097776ec051b433de62da6d5000af9130eff73bb34af91de03c0d18436dc494ca6030185818cccfd1610edd640c15087e487b9049dab377c948466d861c1d60976369cde5082917da2617023bd999489d11735e5ecaa17544fe886b551ddfeb5bb2171cb6d5e6a3ba4184be822597776e150c61b0fbc75be955b5f9ce29f1512329862833494ffe044511b14cc3dd4e78d226dc7b78e340f4c8fb6758766d3945423ce838e65192ca67671d6adf6a29d88a7c2b869c486b830182c5c53606b3b7f2c9c5d200055c429377a70acce0b2dfff826bc0bb8e38232d0364673feceaca534b074fe31a6fe3e45e97ecf218ace5185e236d497df58c6c4f306a5082162ac96064d7e9ff4015600a370a3dcc9016dcec0e01517fee0bf99c2983e6765e3b1ff962e3e50f13652ab3d844411d68924fb98fc9161e1f5b1057452547079e14f7e155f6add47b64f0d67fb4c3f22eaaa4990b860ccceb5710441db7b86afff5ad5f4000e12f11d90607fd4ca329dce5700bf9111be4954dc07a90435b8b315ac061dde4e4dfb902321b2eda975da5bb0a28cfc93e88a10faac900fd67339f8f38b1b07f2b73c9cb47d2771061664c16ec04d9f719bc97ef46f2d5221a6af9a17e6fadf81f51755fb4390ef642291570163735105c2b0e939684bf581e043f142871b4b860807aee1a8fc7346c69271e589a1c8d24bdaf7032fd04d826f8ffc1742dab11cc11971ba893a3a0c815d23d466ab1fb799faa4eaea35d414335659231f41b4df521302b27c3f3744f20386f7f4f229606d0259971e973dd758e2b25ec8995e6d95c18fd4fef7c80cc4613da3a44c4d21e3031edea3240a5f352957a5241ad5062d299e9ec87501ceb9ec3de4483d5015388be3bf3ac1e73ca2513ae10ac5d41ff0ea53b92a7a3711cf2e46d4715bb536e256011de760279c68d80d1724add061b18c019c127cc3fac8138876982ce24d113373fd868aefe78f7e77e658f89e1694dbbf0a0b80a38d255d35dac8c56b401924fb7c9d1ceb58258f437ee0f356424e675aa991cd3ba6b567252534d5b7281ce36783e6f5154f376a09bd6008c383463b22c06045b18d22d3b8b73f2bea648dd42e3932e22a7c41558aa47e1773817615baec1a38738ad33140e35a2b77a72f6d34c25294e952224fff644e6acb7d9a372c9f2dd703c49d9fe5df6acb571670b736ea8744ef541ccba4503deba439f1be6363f9c44688a6eb9be0e7ac9a6e5ea1d430b01c5994521036c7bf4e1a744cd195b9857e75f9cbe8427541dd70554c9d8192f5c6781ed7add4606bcecc61212a03b51d167d641732455ae581efc55284c4c6d9d72221bd35a0746d91ef5c53b73e924264008a492b18c212e8579a801f3f0b4cc7324481ea982553be4cfa2a54f2741fb52910185f81f325eefeca055a95997ad48d8c7cebdbe055e2e9f0462676cd4efcc23ca8259fc3c663cc8703eaff6cdf6d2859aa650caf52dc1aa8b1138df0c394087c8171d97a6bfda39207f75ecdbc9902023c3bf1b798ff92878001d48016cfc0c9381940cb45ccd6d4d7b07b34413855f589501d6a8a350fcd5faa2291c10083d73181b122ae82649777f59bf65eb7527a4aa0bb4c2a427bb2facd09f8228f3abe10eecf521727e1755f7a32baeab672a636688c9004f7ea87c92fe1b477ea04ac196178db5458b542d2ea6b6b6931525aa79178365ec9e0dd61c69ded2296d95e991bd430021fa5cf87e55e4273b1168e77fc2b3d269e510e8b4e03312ec24fbdf69ead9919e8ef80c72ab5fd30db36cf439102f35dfd041edc6e161f0933bd2463d7a02d3229675a8504f5b1fbf0c141bf41a75d813665484bd78451b09a89c1f896c2976baecb0a665a710d0bcc856740e8739447be514343d1ced1ffebc237b524e6a9d02e91a39ec28d51e9fc12fa1126e2cb87ce714796db6964f57e5ca67f2d6c8bb613f2fb2191b1b5834b93f97b9f87d61cbfb9f75ca8499378988e07a120f3c630c343b0d79dba45947b9eeb10e44f299919c3546d1ddac4ca7a33a173368ae9d1bf742d986a0ea69a96c9a8c1a432ec28cfe3a023e98e0afd863ebdf05665978442204812bad8ef87e2c0059d89c8cf53aae88933d21b5676036f9de4ee253f95fd384ea4d23dcb04452cd53824e9f7f29a822cc2370b4b3d5f503309842f23c4094ae9718f2a54405abe3fa0219e100cae9323d5a5492c9d7bf10c7fdbefc89fee6c6b5a754b76956250a22417ef217a082035238b36541361e3b34b10fb94301cb3293282c540cd8c6bb0319f95d1cf4f478ab6dd337de8c3dac2afed4df0d6c806067bdb4c8842430b01f5af670ae858b606621958ec4ca577d814acb8f2023b55d6e1424d07e24fea1f8e234a7beef89e5cc120bce1e8222ce9846483f4486734648dd1aff12f672ba1c4f85a4f77d971a6e1ba6824a9007b29f24afb1b4094db2f4e30f5ca5ce56a3e44b67a8cb4c983b5d9df1205aab11a45b9dd42b99a8de1129ff7ab217e5f513bf5c0006831ff6a59081adadb4b7caef0b45de5cb437b2263dc525aae02de3e515e18d80d4d6652aec8a3b1f9ba515ea75c3c780595649d0354f9b8e7db6ef52bf1397ee3602144c61ad5da3ca05ce5f51aeb6ee57d963e1b3dad9fc2390de3a8719d3afdcc4ca34a193df9b71a44e053c783a008997760b07b4ca21535726dd2db7e9ac81b8bca1321f49d1270e51b6a088336abee8a18e2167fa2f8b072b152bcb2a3e465706b3e9f385b6cae21477be20051dd4fb47b161c5e8293576e0ec2ddbaefa59ddc7b639d0846857acf02ec355185181087e289d2f19985f3b013eb7f8b4f90435bda1d0e2929218c266866387a29354473ab39d9f69c487240c9a85b551c10e08728d6fb9a782d1684fe5f5573711ad7e55295ca8be2e636bc821b34c3609ce64c7d22d0d35be27f2873b08340fcae692251d3216c474924c99baf811fd57d5049f8c06116999fc459d9b73b1d8611aa297f8067935295de8640232eb4b87dcf9733d4dc0b1d3d73f5e4aa6ed1a5ddf2f5d3a44d7bcabb4d46b46f145999dd1dd5aed9d3774df8e240bc0473b3488be0f99b93e516bdab32b02f223d830dea14e3c64ddaf7efdc61da5f298ce4c6bf444d45ad155f486ff3457b0fb3325cc702e73b6baef934af3cd9b7df15211e80cbc81c681f3c6c54bc1018bf18b9ac4130533aa13042be558decc5f8ff8fc2e5a2c8ed29b54c04cb3d9d337fc2970d99f555fe51df15e1ca1567c5ff36c12751d20aaf580b5435d015bdcbdb69f68af634d082f17f27da5609282403016729fab148c50069f174239fd1d0978949014a304f300f4f83bcf85eae0bedb09623ef5ed5639f735abc73c2f38c75208fb5e326dd087b811d90a5708986e61e1d0b749f53959ea9e8769dd927fea308f661d13b893c3a33d4497ad0c1710cb4712c14cdb5df3b2678b13106e5a101cac0bb4e32e4663e31a0589ec535f695a54bf1402049f23d2845926f2adcfeda9b43e99c897353ce961647ec0e1300e8dcb35c86fe08d52939f3d2e82e150aad060e90b4457b731100606a9840f2d45e292ca1a5b98a6eecdd0f9305e82d1286368a5a2bcf01eee738753ee6a86043247915848df5f3db91f7dba6605e35b575947abcdd52b41896870e2292abca9747e2ffa5ee9d51d1d02be25b0a46e668e194b72a5287032f6d4a2025c92d7fbf369d56d28c6d7f33544cd9a056ed6d52d32a948242091654bcf23ba9505401f99623f9b3cba4b642341068f1e633e99df103cdab67d2fe200c7e58e1b29f88f041cfd7915aa91fc69df4f6f816639f533dd2a3f4a2b3ac6c3ef232af0feba2b757103b91fe99b650de02239660ccd63ac12c3bce61224bb24635261046299fb2e4f86689e4591f0e45a4689dc4143230c49e1158fe2359305831035f0b75700b33bd45827822c5f0ca03434619734fe6bdd1778737c7f8aed0fd2ce6d0a5bd27cdc9cdb08fd5dca4cb08ca1da56c8d79ea77193e6c2ef8ead749ee0463f461cf2ae58abcf6bd40ae40af42cc9a8ae932ea37a95291904a705e7d8e283f086976278c3b96fd6ca63df5dd0d653ce7de73911e29a371eb7664f705427de3160e35e2a6e011c672485f81469d1e425082544658bcbed3a347dd050964db1332bf30616133cb86394bfd37aced2343fa77af361ff4266ba7695c282913d55723f94691225b7279dc63cb8aafb43839bd36204782b9e1fcb647035f9b936d9ac1ccf64891ee9b1b314eca554bd06f14713ba8a684e7637020f0808e72fd2c5563b9048b75802e00ca423471f7171932d1305724c7e5512655c370df94f13c54928a50615f1e4f0f42b225211153e44b4fa88d3f65537953736b9a1c0e59cbc90c362c04fa3e3ce4e9074e8b88ccd3fea8f5fcc07c83491992a8cb843bfcb01c56ca2446520202abb7c27487c6a64862e5d667a7fab1a0948c6fdc5812e8885772516b4cca2265b6e8e85afae81fcfc166ffc96bba7f53bdb52c67d459c02b04c7caf2426a5edbabae8aae56cf5521ae447cb45e082ce0ffccbae112a8b90eefe7b699263e1c2961e646ae9122765a266c4fb24aa44d3f5e4e2d3eabd975a9b7f1e8912237c97c6440d216cac3d75cbaa7fb029d098e5b17be8d32a05839af6258aa82a4aee7bd33d88f7a3c7c506eb12ec1ce6f82ce12c7297ee526a6e2e112dd22a9e0155df62ebc86d1cec66e9ecfefdcd9daf3c0373e3daaaacb5cdc553bf883a88b4f750273bb7f148dc710bdba4925a2574ac674adc4285196215cf4aacf74032a730af7deb080001d754a7ef6bf650c5bd73c30fead21309362b103ea3ef06dcd99757fa89c52cdbb9d7feb48e4e90e4e76594c8496eeff4b1b40021453b2a3dd8490c51eae4fef6d981df1e594ecb73c42e44319190920cdc6e4666713aafe741024f17e01fc1f44ccfba5d2f1937ee687a5ce73d09ce483136cfa8d2e3659eb807bfa5754ea81100e8bcf00e9c21786c5fe85bfe2ca20a45e694a9c69240832eeed066e74204f6f9d4349a085de053a6f2c8df351bbd246447d46590c1a89e52e7dfb9bdaa19eed39e3d1102b71158326ac9518061d30e453283a75ad659e85c41de87b3ac80321d6a074f4ec4ad510032184264e673b2ddc849109f397441d4753e13c3465f6d8c8fc923d8ae1667a499a251f276dd485adc3c7b0c943808b61636c4dde93412289bca4f2cba89450a3ea4394eeadbb61e16208e6107c0139f1d3b5a7422e37469156c9845d4d731a8b1128530f4c0c6a8f97129b63f0c03a940bc21b9337f89da1672d7b538279ccf0cb0fc5d2cbd4e8cd5554c1ee8628285f40af33a046c8133220960f0a77cfdec6dcef740a4fd2a88577250635a6f217b3f06aec53456d22016352058c22297d944980a5e547255c5cf050a5cd019d3b21b38077adeae25c80f9a1fe0305880cfdbab8ae8caa76fa95c644c9ed1b946e0c9da3ca59e06e61f373c5ac95cd43aeb76b89fabae035ae340bf107309db6d7070d28958a4ea127134bf9dc3123386b4f0531448b61e19966954d1129b51247f245a9e82772fa8f1712729ca46d285d7fff3a6ae4d10a56fcf79823c392088ba3b14538cb01d3ecb061f9ac4d8870d130f807f41e9f2a704fee294ff1c4f9ea18d78f1d902fc119f4789ac8f2d060ff5d2646c5a781cd5d62b891664594629a5eab77e27bf1d14980f4f6ffdf9b23ef9c00f4636766eb273e446551a0b3654d42249ca1ac7308cf968ee8cf9dee4c7084f8034e0f4985a3b456ff822654d28322f17062bbfbe26d6e8819564543fbe33c79499fb2500836a95a7b02c929480bb77c99d94c0ea6cd3a888504e22ede3186aa6f72b7bdce21e1ccc779f1d7ba3db9835badcfc8032c96cc9891cec10c4c3dbdadd9e36770c22ece6db9aaea2d40f41a88a560adc83dcbe642c13739aad03278e29c3ff94c2a6702380b7b72f92ef5749cfcde33adc1d8e8d0f3ea306722a032f9c6186d5a6c5d0563075f429943d5ec43f7a0173eb8741264056c3bbcc965fa99482da88163f9d6ffd2273c1b93ab864e2a3e3e9c49c2f6685b2f87e5bff7bcae6da9e0df5c574a02bdae5840c12717e205123fa4b189c2b2aaa8d5e3242eea406ee7855234e7c43d5f45e0725df63a6fb0b3d27a86c3d58fed9e814f0fd8977a433cfa4065d3e659e5ac8897fde10538b5065a52c6115b34d0e9c3af711a474415c82af347b495edbf7c82850b740c9530d907b6795e33fbd73dbb3cb1c5b420bab594e9f212524ce65bf482d3912a3796613e6f61fdc3549be8709d22e2c09fc33f52c0","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
