<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"15b13f2cb7cb35300aa58ab9c6d10bff7f5966e1d2c28a03c240c98d2c261a8ea58ca105b0801fc483e5760ee455b5b8bc9c33c68f239890a226917034add4f6822b4a170681ae70f23272bf3070594909eb5dd28a97c84c20ab420cbb2abde1a4f10a40d70611080c873c9bbe0450d3df1e940cb29a56d175d359b6faebca4ce373682176134d78cf0f85ec6c77c06812a36c42162f6b923e71ec9466ca5b267899cdd79fbff538cc8ad0eef136eafcae3d7208647f26be7942b70844883bc1933a266a482594a8502384e50a54dc297fe703cbea1649d7dc52b3ed3617e52d05d0872002b1e94f8ea286502086d5d5247829bf0734aa39522edecb7a1a1240e464c7b3226dd1012b18ce0531e99507550a5c4d7629759bf6ad6ffcb6e687e154f6caeefefb2c5ec31d224661d00f26fb41d72c86b3f9c8988601630fdccf541b18a8f673e4f861d19fbce71800cad83a538e55a3c91a3b174c212ac0f690da97b1544bb755f922cf28f08ec83e0f3f0520d549b77e31b6a60f94e2ff3469c09d0ec31c7f9fc6b97b09b0e3aa3cbaf2e0e7beb2daea8f4d5213ded2a6837c3e210a7b3b9900e5f0bef343ed0e7d8ceafaafc8cda9fd8e8a34712f1eb9170140a58c541337bae70ddbb49c6a97b2b6e436b6138c1025169bbf7da223f1653a5966d56e9ee5f6837c21b47ea552fd583b2872df4718470dff0ba7a744e5070f949ea03324c3788c98c9971b41f3dd2c48acb54f58a0131eea2c66f6a470cb27cb161bf777ee667264d7fc373fbaf28acebea317548da9a96f2d082dbf6c2034d7007fec9b7ad25fad359771539e5499be813ced86a9ba2544d407b791904e0e21c13e83a7911321ced354c1e8c77a55500990958011bd071e2a26ebf10a18452362a404e99df7db61a8b5b7d5ba4e024d6598116e285d8d0f96a4f6ce2620f0eeefaa639511fce18367ac6a6297b645a453edf9b3ec953dce63178d36f7d901709563d02e8c9fd448c9a71addfb1e0813a7b9d73b04eecb1b1fdfbb37cdc46895b11592f81173db3b0192a69207d56d896310ec3bbc00a814695ae9ea4b5636eb657518ab0315c3cee4f2577cbcecd4dbfd257dcd9279537539ee5e8064c538b398667ce97613b46ccbb07494d9a0d71051e16190ccb78f9a45ecda86d48742fcf85eec4b6aeb9e5cc775cb7dc739ba95ec78a38919df4bfa5f873ad3e3048942405ee77ee99a2bd24d7e6bf16c4291682b9908ba0bb460a9d52d54bc3af5a5089c3b926309093f5a43dd49437740325a8f055e1f059d2bca714aba856ccba769992ad63e977880023ec1a941815c92a334192c3a080b22600c94de100639e076e4d7e1de8c6b2a92371306eb2e4c7c425e9a2a6793173d822d5f465073db67296bd75f3617d0e9f34a622e18f2bacdcb62d103ce4b6ba2f39bb91273aebc5ecc5db61fe0df3ffd1beccfa104d405a79e1e0a651b18931725317cff212b1e78c84051026167226710a2620f1b2b764b33ed199e3c67ee5d68aa5e4f269b7634a9fbe1810a5dd20a5f4088dd16df779e556d9c478a74696c7c72a1ad06b5102f3960f9f118dd1208d6e08348987bd04a959892603f7e3f75071cbe9c74d9ba167f826b610815853d229099428296c9f181a5cb1d0d771b9476ccc6877d7bc4ce268d5aa382831c70f103d54ff237ef49f4085c3ecd65342a96f648935da32529446e877c42db829f2d6f64e075b93dc5d37bb2a0185af90a4ff87716d43a687a3b239c7ca4bf679db7c59e7770daa102093ee993f759a40debd13e0b1fdf0c2168e84aa854e43d4c23da81c9693c00c0208408123d044953b7416c822c7635261cac4a411209500e1242ab3db1a162ebdd279596084fa2a2739d4d6da903af1b574673de69145b8c6bdba0cbec4057e3d59407b59747fa4c8a39a4ed61596964e6442cff3e8e0b1bce002fab5dc8d828093e26d23f7d5ab91894e1dced37eb492ddb6062cd9a5830a92dab8fe4580b884cf4b8d842664ddf2f37d5f0a0589efd6554bc5baf6f7b70de8a80e7b88f26cb89d00eaf3fd05d02410ba9b25be6e360cee2009b3930eeac72a58224f15724f6125ff5b77b18db016a22fd4208cb65f7aa29fee5b6deb7ac9bdb9918f061f874d55a09b909cc7cb86099945b4e4079cfc7feb03522db6ede8b7048d4cc958c803f096b05b3960f2c459585333d1b68c836cd5c6355fdb3c44c8a76c664e36e2d37a5d9b1ed929fec1764e7aa46c6e9524a9a1a2e49479d4cc319f119e7594987287235b27d9ffbc23f794d2cea3645762576a998a51a7890f0c51a46620c3a38930bb710ff905eec1b727d6832ecddb080465790279b24b95d1e0a9eae329749bca3db6378ba5cfc14e420af7a5ea80493e81bdc656f392505360256810ba7e9392c49daff73f855f1d5e4920286d8f69568caaf97ef5662d5d7d852256fdf9c7e1b8dce6ff9091cbe9ecee14b60294b285ff23a33732e32e17ca1d90a27935b6514c479954d5a7c6e7e7790cb7830f3d6fa55720becaf2e0ec98b449329d67dff682d7a4164784566c821bba52a027ae9def6b6740f708dfa7ea29a46e81fc4bbc2f78433892323eed84e3e51de5751a42b02772391f06fb498516ff02f9b71bd23a40056910069912c25b8ca3d808bf2c1e3bfb2683bd8edfd877debbd886fddd856ce276deb5588f24508329fbdc8c7730050d7d5811f52c0457d60a375b3ab1e5ab6b0b011ad058b65bc270ed709fa26ade8e08d1c40c09e32a026fd2ff2068668a4c78029aa80475aa6d325fa23f77562c921ae3a8904bdb8bcf44ef55650c9d7ad6bb3ceb01ac64cd8404de58cc977451874fd52dc04a9347acab484aed9b7859a140efd2b09506ceca3f3f70ecfb4d58a1fd7a38bf41f4ed225b2fec594b265633675ecf9168d6df0062c6c956313bacd00c8729db6c0e918055296be643376736dd7047d3823eaaac633f3361aa973b4ba916afed1fe03b20a585b132ad06f87677466a4ed52249a0a96240ec6446d950855f92cf04f1e155d60d990582ec53eb18f8dc4e9cfa36958f5ebacd7dd6c9631d30406ee5cc0cf55ff9f6c4b2983ebd7fbb385c6795186b28ba2dccac98b4097962a7c7067df20f74f445d8b863c6237e99e980573324639bc69a713430de43ba40b676e04fa50f55b32eba87fe7ae3dabcc6c6b9f9f4829d76e2f67745bd73fb87ed4861f1e47471d6606924a13a4b41fa3507b0e4f4455fde5923628a9066d632fc4ec9e1fd36162b1da6f5d21833a575eef2c7c1e90b66f89fcf14bc095c8f85c62a2ea611d95f4f23f03cef98658dddb565dc18f4205d8ac25836422ed0447d6581db6a3f3c4c7d02989164d51c2c0f8bdffe505b47e6ff31297f6d2b86a06119eb29db2257ae77916505571ffecdd518d6cf0a9d560d0048d91ca7307141e28f547a64a55e03fdaa021dbbe0a5a78e0e3820609e738eae375581bbc72928ee286575abbd16526d3a5b022bfb12480420ae9bdf610f00297767541c406f5bea8260035fe479c8e6c12bd696a098fdb6d7ddbab0d5ede4c8ad14e9eb1480c14c050ff531763ed0ec24cfcebbd15ec89675f377fc0036aef5679925c46bfe863d1e69f9f5d1484b850cd2ed877d08bb86f2f8d800e0c7565663bbb75047b551344457d325422ea697343d5972438e0eab16ca0272e15060c24146ecc85cc542d7b07c8ce09d0d8e0f064cdb18fb856c2565893938f3f0464da9fb7922f43222f6a9ce5f50096f17241d6c00c60fc09b924595733105178abfc144658658d9473e9500d00e5337f9acf9ed63ab7d046e735c829eeb818d832f40c7487a30f37b4d5af6e682644ddb4160790129506ad46604eae74e63754ff4b23513a994ba277e189b036ae25f69492654b01d0bdd0bc0065f748a366422781f3373b4f0f6751b1964692abc0e2e15010acb19908a95c98b6ac459631a33931a2a44f3fea64439e8708724bf53707727ce9d08d2f85a5b1c42684ac52b6bcf9aab575ad023a2ef9ab34e43e83afac136ddeab3ed46501e6ff748ef87361a40f34e814b65349ac22aa6b43ad5b7234f3b73aecd0ce5f8c21d02ab7001673d94f618dada5b64bf64c1e00e51414e9e3efdd653859be2e6f968f844e2300f69a7d2a7370201f9e92422dd8f1efb0f014481a767c04b45266ca79ddd0764bd57d9295b5df57cac514e9b4a4b014bbb5c776f33b843b6535da996198adebdac5cbd55bb8f118cd5eaf2eaaa5d02cd9ab610c24aff06b91791779012228500266f924e869d0ba878060b0c5fb496e3fdd966dd6ff798ed13f782e6668c25b8c24ae2b3015c0f9e9bd5dececf62a4e583c8ef2a53c5c63328ae343003b9cb1cbd0055c17558ff87520b1e67da0e7d98337a83f2493b90f4ea5b5544c2ba0a16437de16efc88a098ba01a27dd716681ef3e612d73993110add9d5e3abd183928d4f4ee32735c810746640d9c44b756e7df621166b172ebff0e1429ebed24829751bc52167d0eea6841972bbeaaea3f3db7e8ddb01def71970372198e0b5f2fbbec172ff510429a65110262382ce1b4aa8b7ee1fd0806065f72c6f677100dae99509ac00a2cf47fdff2b44651332e0a1a6f81148433ff081a67efaacc2a93a5038590b9c519fbd1b83dfed53d00ca03fcc21e4ccb5a9670d56a28947fc32a2b025ec7bd659bac5711725b772f5925eda8f3ce41bd08dd9b9b47e3252e6ac20921b0d7d7b82ab02b1333fdcabd53694fed01c2979aa40889fef03e97a54e304a7947fe40ba142da23371a06b582eb9e46883ef2c86fadffd55bc721889cd8bb249efa06a66134430e698faff9de99c737a7306a8883814432dcdc570555c5c416012afae232d2492d8c842a3b3c5d6561aab98f362d661a32e16fd7f6c3fbb6148e15e24732419163b6eb34503ada3624ed0ba03179676aced1ac3975e895766cf949dec2e7fa5cd638284dc198ee8f2676438d97049284bfdac5fa6a4bb4712f9a2e96def91f60705342dbcd04e188a43997c780d33e08ac778c0e892b1843c17c8f76d44e364e9ff532f52f7f2b9593138ab6125c4a365a88ba18dd39d2bfba6232ccc8d51f248e79f37c87df21ce90656a5045bf82ac913f6fbbee6294c801dc2858ac43312d13483cae0c4345137403ca1865c1bc2f831cd77e1025f92af425e96d4d96e040ee989dedf8e089ed553c855fcd9e86334f0d06912b28729b2d24917ccfdab17a7e361878e870fd9350b74c55c6afb13b90ea3539f964fcde6ef6b03feafb430c0fbe38ee8b214084c442d13f929d0ba77694ba629828d00fa77e270007e611372ed07effb8a50fc939e651de1e1c514259fbad1d598a9ce4f15d70f04fb67479a3dc4b4d4679b6453ca8dce43a36b911e96fb3b0ed8c311bc2fa0e5cb74a5ce396cc7af6cb2bc7074c822fab91f6e19d0e64a43b63f1631e36e0982087739a663eac522b1d82094ba8935350c83fd1c018ac14750ad9aaf1ff8483a3ea4edaaf7427575a13efb271ebdb9e2cadc75b8a087b84dc0223469dde8b044f0c234bc2bce192111dd1d3748b7ff3cc3c83bd05feed3cbcc27ce3627f0219f465fa6799448331e2c9d1583e440421c8f461ec6e051b707f8b3dd90dd0fbcc77f924abe683b27ca7a0571e43b36de5af6c56a80d975a6581722165b2acfa367402d2e123b665efa5d7dc16b895d141d252bc64751cd28129eb64f1a7c3a5fd278625c6bebf00a4165a318bfbb4898ee9b27f38fa6119b949c844cb4d02daa079dd4ac02718440873e1ae2304678ce7d835a94e4a89bedf55aedd883095aa7fc9bc2140ee6dcf02b172de694915729de631ead2bef458dc1e0e876f3661eb079a7df97043e83e077bc029990f9c84a01114856b49ddc0871268833da761b8a241be5dcbc496121619222c7273c9802ea11619db255c35d8dbc8f03381f6ccfc473b28be26de622b2f8044386090a80f7cba6676bd0696cb32a8fa5d23f50ea8ff4fc3b23b6abca9018b6dcadbc08d5c8f97591384ea9c4f243fa932814b8eaf3ed0e623d3f506828071dff44da6e4013bd337e3e0b4b3947eed42bad24ea2629a6d635ae87be5e1c7dda672526152704999b99f16b7b5086313a284bcd44c4091b272bfeba204486ecc8a1063d3425c61f598a41679d1a07b2763ad7fdaf88506e4b24c2f31dcb3e38e4f738ca5dbe236e0d8970ad7c428411c7e62517915dc9ff6fb07466501f73b394b4f574bfa076097fdb0272b2f2c6aabb2e6bdf21634140084f799d18902cb57ce17d47ce86eb820a3fb050989c657c215aafd684ef18ec66205e1d03622bc9367d43dc090947cf889e2bc17ca0915b6111a3a87090873a6804d80b21ad024f42571dbc7c18d9eae376e96dfbe5e5c826c519bf67f97757bfeb9a009021bfbe913325fbbd7a7145bd15ea722d9ad65b81ce6a5e1666f6dfe3ed7f6648cac54235f8910bef74d6caff95c429e3c5343b77c0b44efeccf042daf8018156701e5faba182f1195a34c1918a2b4e2105976537ab42f83c1ad8df7edf18ed4fc913ba36ffad69b9a066120f305726049cf24023e2f5234f0fefa327622b0ed4b61a35d5729576bfca34fa0cf8bc095453c2b5aa90b7139c4e77f69a249f44217c989c9ed6dc469ded94c15e894a6ca8e56e11733bbe46837ce214d144f14d888dde481f6c8fdbfbfccda87a88926f03d9e89fd932008a3ad490bfd3e392b3a2270d441c705d734f9551b2ef5ce19e26cfb41c7b71ad1b92e7e07ce6963b439353f9ef52abf7517a6849b07efe9e49a9eef36c3badbcd0ee04151d2b5d52e137d9dfa3ccd2b8c95b042bbc468c2058a3b99b1526a9e5b0fc35ce7ee8ef7e368e670d0c8a2874209e2c3453e02bfab8a7e7fb971b5be341800f9d948a2a568764e2b2143f1c24079a98ce98578c008e4900ea2299c0e3abf13aa0f1297e978710596cd1a6e7478c5500b00d93b76500e16ed071460cc19910846b62e8935194d675f5e5271f1daad117ac37f5955c536b95029eb055c45d48a3de18998717136e0134136ddf5b825eb11e9bd99392a47c5db314bba49d76870a499d7021ba087748eca44a4fd9c27163943b4e64273ff08ae9c887e3f2a16ef922d3d0cdb80851ffb1a52d76c8c1c4a6acc350f704be5750bcc25c242093fb2a87efcb722572e3201e2e104c0c6a09e0311d81dfc8df37b1a71bff4e5d1c19ce97a53032c777d38577fef16375f47badcb500f57b611fe27e07268d7a83fa7d07431d7417238e913e52eeca2bbed2a2e302d2dea4a2d56c8e0efca36d23b315e71debb8d82515aabf3513b6609e032c3bfb853e36b25cf85bd87b3258b74bc714d4eef56dfde401ffa4990471973aeea9b43a90b8811bcc01083a5dfb07393f0bca8fa29f63f7ff4842f95cadc68cbb31184c6d3b68bf9cf9872f8eb81149f6cfce19a9fa704b77306ec2cf7a0d7f7e5e436c3b451d03270ba92abeb102449387e2801cafb685966ba3563159d30c28847b55ef0d40155a4228c44703dae3eacef46675fd6267a69319d3da2f1ca3f27807571784832107a1134ce6fc20378df8c706856b04673516a8d44fe087d4e3b16dc3fabcdb9a6b132e8a7914f074604a8bb8b9089b50317113bd7fd9a1135c73796088266640401fac5d306e05f29a18b5c69d4aaaeaa9e1a3ff764134c38465a05fa05cd4e7b21f21fe803cd756678bca9ed6841eb649c20359a4bec4ea6e3ad00b1a85bea6689ab788ddca2077123decc230957221338b4c9b02137e49d59b687b54d1d2bf2dd7d8192c33de75022a56b0adec1466afe4cdfc17f04de97cf87f4d0c680c0028af50ea8945592cfa88c5c809ef456b2d38c066b77385f54c2031199a44d3348c5dbbf7b7056f3d2097e73375333067a523649fc62c898a5ce2f8a54313f23742101465430537ab942f54b289193acf0a961048a1996d5731834119802a371304d22c13e682af61c852cef51f89805a34b1680b29aafe7a2e0713244d1e63598c6aec46e2078e69ab4e110e97a7cd6eabe6d24afe4f734d224a5fd7feeb197a276886e6fe2092a3443289788719baa61365982eee30dd0c75f05b23f3d759bdcfeecbe1796fbb75a90fc6393eed52534e312f7bcd8bd553d1400bf93ed59a6e904fc12a8fbafd7f404d9850cd055cd59c01711df5caa9edf99f89d9b52a4393e7bd833e6254b0d8be5d7446468664930193274bf8479102d798820ae0ca26188e8e11eec51e3a2f325e43a046e3d8e8129cce2e2d638ed074eef9e87c5978a78a67cd5cf3e38f8bf59b8445362e30d3ef7daece4f6642f271d2aee1b09a3a58756a27164d5c3674f29c14539f64527624ff57b2517a6f0152873f328217f39bc9033c636bf279dcf9e4412234595ba64dc84e4c257fbd035a6d19ef08700802378a18fc5066b5e51a94e718677559538cf682c2f47a5d317bc7d45727cf7d6c47ee681c795e9f2f4d236669b70096521d97337454b3927aed4153fecf83f868a64cff71bb7ec7e4fa5968efed379fe62527d1d6bbc5615c42e3fff4d987afe5c5e7a2a14e3b0335aa5b5d76d969804f972a881f19a8b9e80a830e062370bb322b9ba85066c1beb754f3b11bbc8303153e8417a6e99c2cb5f9f733a77a0e284f740867072fea1dadf7f117cd8fc57000a7f483dce182a8542e676de5444b9d92a903305920994e6c51b3d190396e1d86410465201d7c1d25d93cb9a01066626f7cd865697bfd02ed309e485a514fc31ec6db4346ec687c8016cbd5374a7292dd8cef217af48f776860e165ce260125e1670acd3ce2cb7adc262f362e5fa81dba11a010befda0f792e38d7ee3dacec7f7a0adc5f68f669fd0d277ad4687544a19b80f6189b975804bd135ffc7cc37c43ac805037129624c31187efe1600d38792d0c5ccec10fac4d332c95717524e5380a5d637814c3c1bf200535fe079f397a885cebdabe249fe10dc819456496af52aea2dc0518bb842c26fea26590b5008e8da5001c547e01fe3247009960d97e0574d153ef0b4a8b714db4275131167c489a4d2f7a15be53ca7bb6f1923c9965ad81fd24b551494dbdb6e9c6d6e9a602c14aeb376acb7cb044cd47d305c8cb6bef9d24444dd9498cb27f4a9f0d77b1a5c2a0c66a1d92642005f41b82224ba94b4ddba873d00ed57d2709abdaf816c11b9e77a7498de710b9089f9717b8e61f04b92a59e42422b5a77190ac5fb017248f1533fd7fd8dde9a2f4ea37b2008156962fca116f2e8b788ba5996169d5123f08358f857fc07bca97b1fe49103e4b7c52bb5c4a5873f4dba92447e95181e32366427c738182a19e6c096bed46d153b2fdd4c888c4548c647b3d901252175c3117c31d2987c0f276423048edf3c9b50e8b17ee092ee5e3a3f2274d65e50a373ae362cdae84d5c33f105ac7d52506083416f2a43c5ccf328a456233243e82e7d80783e7bea0f82f523fe0d9c9d915c05396a084fdd2e9d10ebb29619a78032f0e528f65e4a2f92dce97eb78fa46d4b9f7cbf5e5130702a47e4d9468fab8c6565ac66a62b2b02ee3ab763142977ed9816f07d11cdedee7bb4859f0fd14b15ab1297c385d7a464b671a48188a1794afaca05df20c574d9beffe08bfcc4431face8d06d8e78147ba0980a6ba1ecb511ed4c36d48aabce475894f185d8da5f73afcac6418585278d4cd681ff7a280c60dad303d1d6d62a29cd84963f61082ee3b9900bb4012167e78dff840d9442fc4dcb04c69a3370104d2c311db15b1f9de910b3b3eb233c284936b7ee58f3ec1cdd407d095afb2af06c3fa3a71f5838e8e605c74cde183c17e50f366f1f769e7e2d7193dd214a1ff3abfb03e18d2411802dacbc73be23cbdbaff9624be162bbbd3e02f244c2acf517c41cd76cccc987bc4defaab3e1e55589253df082eba5e39f348991b62334e6bd05757655fbd3585107b2b4be64c5c14f86a0bca6fd4f5631f5cfe208cad8495ff6be7d7c75486603ca9d3d0b3b1ea0d91e199ae42abc35a22b73b75e0883253e9c1b9eaac0778d823a27759737e0558d8b4bb776fc7a879d9f8e61310f835bb3eb144b85ec518ad4aa04b29ca58f5eb8765bf455b06d3c5f45f951e472881cc50f253c094933becab07d12711386702a521db59a518000aa823663d19af72d97fb677aa7102dc57b424423a92dd9d505f4ee57da3a1740eec683bad82937cde32bfb540b9756b8267a718d99faa40b352eedcb7f621d71365c5f3d8b68bdab0e6a85424655f6d445a388b7762632f24cb8149868555f343a1a61aa106816fc07a89f7e32807a05b2d209b91e25b97a0c49a0b1e558e2688a9e90a21e5facf8d496c1fa44d8bd89acc819a0014e31e37d6b56ea66c2dce0754b2f8748a8270cc24776df5e4ca6481c8eb3621dc64975065b52b5572e5bb3bf38075da64f7eee6b790aaba2f2af51669a393c00ab226912d2ba3e242ecc094e0156ad91872c69052d953aaf67565cd263f6fd15be792f99466f3993da6a417180d6c149cfa8e8be58f928312d582ea8c6350487b5c24ceb26cc9b5240def368aa68e6a6f13c23ce147123e7eb14180e1f2f32fa8eda2c6bd4551dd0173f71002ab7c198fb62fd87bb53d67a104eb2fd7ce3829c764cb5ff4cbab8487583ae735b93795c34604b2891c76e3871d29e7094cc23a5e82f0dc0bfd75b5d9995d4a7eb8706e6d82b66292be2cdfdfed81c0d30f565ce68edd84e2d7d6ce3438469ba0d72de55391c9ff237abb4f9cae402aec4f3937ec6e3d3e7286a8d84accb520c2c287401024be2d7c9334643891a9bde08fd2769a7d58575aa4d9d3607ad5a502c7a598efe27e1938e5ec3424304afdaa9252b7857a0bc1192f8e2d1b2aea07a8dfdcb51fd0188eb5ae498e96dae3f830f54d48f9c877f0b20194469c502d59350bb8e2616e0949d23861adf6a38d4f530b601e03d1c170a6163272369ad5242f13e28f4ab32d00975fe62cff5353f82d90ac4e025cbee0382a6c5168901c2aa24eca054e169758b2c09d63e80e192c05e02ec8298bb89834a6d40dfe8f5b7629a8e2d5b86400d946981fb3355e7274adb3e15cb37e22adb65fcf434d88c01974a1ce7928684aa4480924547ff6e49989273914c0d8aa3f5fbd20e96031e2be040dc737a88b0b19770f103045733f8ef1a15d56caf08738dfdf59ad3650c450d8c5eef3563f90840e275f06494eeafe3c2a3f17b6453b6c654ff61d7104c468c6d44a360585a184f40912d6847af20ad1673afb4e3caf3114b98144789a5eec02a02005c37b8d5f26835d7043728c55c5c68194237b0557481f5efdf41370064c4707fe6fcb8654f9a7534b02e27154fa18ce7fd99185f28262a61897112130c1b240953ed5e3e30d79d75b43a0352890900cf67d683c4273038318ddf8b5e123d272dd7d938d644076dd6d4e40a30251a588c9f6edac35624afadd317e38ad6f209a93806b6cdcbe5eab902e700dbbd24c6ddef37d96cde43a116ab2dccfcf136d62a943637683f1022bbd99ea0635f258256bf7f19c665b2a0fcb9596218c649d771642a1e59689e8a688409dd145940941831e62048dfa717c3c5a4ef049f014183e75860850f61b59876134a90e15162e7747c2414f8e88cf75c0eabfc3d41353f4db5aa0368b8cde331c87f283604d6ad73d2d479fb78c90b38d2803637bf3364a9fd34c455dfac55d4b4f9c9483fa0cabf037ce35b14c8b344432ae91c825793c1b94e71c027e901172198594a04dbb00aecb38e2a0304ebb365e1b80da616be2194fb3dade6f06b20549d1e92468813d0a20edd28a8f7eb887580200d178742d8db780c4efebbd461a8b1624ecd74970303fe64c141f2aa93ffde25c97adf9e7f8ca1423317c0db40084e4b4fe06e6a2a08a731bc3a780d3b4550024ef4d47d395432b14d993d7934658574f6cb23afdfc84eb5d8293cfa1de4d4d663de39aa0445db33e37cb4a59e25db23ed3d7d4995b049803ce451ceb696e9b9a669b8067d6f16acd2bc65d795cf0e78c4b1df25762ec543446be0237d1ae216defb4209c9f8ec16fe84b085fbafecfe19681cea22b1cea0ff742c9c5223da271d485621d9ba55ec059bfd8a7df62b36bef0e8e953fc7e8121fac2c96a085776f49375da22d2a5630e246bc7cdc54e152a72448489d8414e875fc0ade18f11b674f73e44fd76d6f22815c6af5f5df779014c35515b35ea46badeb7d44f8673f010c61bd4cd3c81759dda8161df650b2f14ae970d283c43a6ef752ac6e7d0ea9bdd394754265e37a46b0b47d326615501f95acdcb3f668a506d0d74d5a39938fa95b5832550697280d4839d81d468ce0742d768390d7abd489192a9da70e2bda80a822047d0d0e3ed6007b6a93a725bb4ced3dee18821a458b41bc32961a306f8779fa31649c3e9701856bb2c15b72930178796b38b885c8a3b84b3d50e3d4ffe239e4f07f3b275c712bdc4d65083197a090b9f69c998d77e6c238af75ac0127abad19c3ab153c8973fffeeffdbcc4214719307f96e9eea2a83b18275fb45b95f6137dbea15b7e7e09a15882c3573ea312c8ea59c7ced71659036394d6f50db2458ef2b265ec1bdce9e8a13eed14e46109a4b7c5b8b19325d8a9c229eaf01e7097e21c8ec25726d56bde3d84f20ae8ff61e98d2c98e04001b760b89e53d49041e5587f47a4c7614fc29405a5cec9598df6e52578e63a5586d65f4815f4fea030af22888605cc0fca88a4f80e0654dc3435dc174dd938630333b5b79015a3194889f94ecd1a3b1df0c413281f1545a98892c868574ba2eb078994e377c6a75f57dc0df75b131a95086b45a402f523c9a4e9df2fe5c8312fa0d2517f25bd927b1ff362128d06e8c871f6a1e49197298a9c2114fde81bede9b87629d2767bc1bd93f059763a36ad884d91f6cefc9cc3f357fc393837e8be28c2c30e660cc88a7b31287b021d7e898bf72cde7e89bcf876e6054856e93fdce58ee99e2fe4911625613db75e2256fb38a59f007800694ef09e7e6c909345c41faa11d80327464300773aaced021aa0dafed6da6a431b35d3fe526af33b4b6a5eb29aece9ffbd91483e397741cc2391f1532627e455281434eaf280cb86073e1e534a7e8dd55f99da790aaec4d24b72fe7bcd0673826c431c0a2bea0a315f23bbdbc2e99b012b471217f201059a10163be99cda40e66ac4b7b7b74d65c3c6aa8294e712c82f39a6ed29e94881c2780e8dfcee41fbf9a9dbe1246323219f16da49b225054693b56e5dd3b40a7601443adccc574aaf508ce8f5df9577ada4204611e00b22e2bcecdd915bfbc2e4536703405556bdd34d9fcb42f46db1eea1c71e21509616d4a68f6f1488a99717fdf26b1bcf3c5af3689ce4d9271774c4618e2d6c70a465fdf854d493537e9ccbb1c476222bed80634a6488814463931c67842a6aedc3154080b7ef78cdc361f829efb1e114550b50d633e6b23b1e5754b727d9a15d8cce930ffddd13f0ebc4108a7842f854af3c2cd8b4157d06414b0a1a560d2f76430fb9ba1a295d32d9c099a1a97ff203f01de2ca4e0029f1fbf822e3247d8551433ad3ea1868ddc68eb9e870d61efc0e744bd88f66fed3ad1d8eeab604ec22de6aa59fbe777baf22892ad25c4e8692d57c617b372b2780bd788513cfa818835f456b210cafb12025cc6354e19d8e2e2d57f38f9d6243db2e550e0d7220299f97eb9370a2779ec5f5632814d573ef5981b31b966874f290ad646e0c9753b8b69a173ef7b43f994ab2f71f67e61a4a7e301cf12c75f11feb904a565252c340f8baaf98dec927ecf38cde5212a37373d40025ad2f6ef717af75726bf620178297c9c040ed1ce00a5ecaec96627de2aefe6c592ee1060f3fca76bdbc4ff171f791ae930938b51a804c05bc772fa6cf22c1d122b440ac053bb959851db64b71514eb4ea0536c087138ad1d40d1f0814b84d0853a5fe39f45c6c8e15d84a3774dc0cec6cbc7099259a4dbd9fafae6425ec145e2062041c65eb3250180e7cdc4aaa2b29fafe1a15fd0fcbdda3b3b3c8aef5634010a98106566dab97a9e905a761843e8f1329411ed50ba00e42c9ee0038d2798c5cb99dd42b1515e0d4ada69ad68c7592a404f09f41461bb78bc03251de55a1188a2d8e008e473a172fb2ceaf4a07fba0e096c1ee326e6e0f244c7fa9b94589104c37d6fee6faa9226eadbc5aad991f54d0f50f63c698f204d91c86110c34ac5fc5d60520e829f0c9938533114a08914727231f3a5fd08a9245157fe025098ffed7c3d28a3f58f5844a947f48e4468dc425fcfa9659f12128f2453f342c5b534705e9eb46cf22339c57177afd8bd9d8c877d7deb6ab4141ef538ee277c3fb34fbd38b2e25cf596208d3a9052f529146b294ddf19176f7e845eef5db90fdb","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
