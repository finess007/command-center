<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6bee97bbb4d7dd35df44564afaabd9cfc163bca9adfb97f2b06a91fa98bba82bc7e5312718266c077da77a137568e0d6e9239d643395b663e393f1ff3b52958d9154ce00932455e253e4b67baa10ac4a482929a7c30a86040706043ce8c2ccd0a9a471ea6ef6c6671e648ddd13e86c91e9079d14d77f04771dc090caa7ce4a2aab033d966209975b87a95970a562449a0e87df56ea44b91f8a4d4c43adfda57b2532475cacc03466510fceb66d282a162a068098d13f0cbe01f3b927ef184426cd8d507d8cfe35a6bec4fc668278223bfd14e8fbab5e2df7b0eeeb7ae5ccda8cf0325b44712612f098b4dcd5d9127f656f435ec3eb4fc899f225508c5d06a897e372d3186118d5b5ce7f1787313603ef2fda079c8db375ebd0aeb948547e9661e90ca90c8ad61c4479b199f0ac82e14d3ef2c1779b731f648bb665b2218a8c72a2d9cbc1e63d5f120e8f5b14c01b46ed1da43794fad6cd8c93788d3b96e92499115bbdd8c4c70ef51654cc998fb0d78eecfd9e6648f9730f91c8ad82cce309294de751497ddbbde58c7b10f771d69d593937c38fcb24ba87428012007fa50e09f70eb08cc68bcc44508865f04ce7f4696a9351531abfd3f06759033fae21f187236241887d92235d22c70f8b7b6d1f407cc6e56efb706ba8c367f1faac79e8df1e6fb0d9cd3eb24ffb51f93361fbc0a7dd03247e02250fcad957a43a702348ec1863a8f522f9db5868abef42ec2b81db01e2f960c7a703f3f66b7f189d8f9857ead29a10e9a668ef8706f78b37c106cbb1fbb0d555ea4944f91a01b0e0efc9650fb760288374e76e81cbe2a885f2241753a16d060cbded5a514d1001e54481c48347386884e1414074a3171eb884a71eff4dd8d2ac2275a36f4d6d47af87ba705d5d8e53f4973976520505b1d2d439db52c5634581a82a34764bfa7c58983dbba4701783fdb6f14e8ce279a2bb9acafcc10080efa146fcd5d2c28f5e0a8ee7563658e96b261ca40526247e5e15a98bd222b8566d0fb2139a5a588afd01bd8cb8a60a792e98e5ccbbf80ffdd8bf86adececd39fee74a3e8608c2d3e4a44fe8903e772574f70f0ec018306b1fda97794b0ba93197d95853d62c9adfa8a87eecf6a10cef58ace67496c666182178745a71627df527a8f5ab79721df8117a9d4e4575ccab192e066462a138038f152c2631b04fd74d2a12feecf49db54160c5ae5f25fa4ba26d10f42451c32570156e5dd76dcea06dfebf014d93c082c98973b73e578635823f97ce25b66600126a89394c7bac68f6ceffb901acddbeec587f83bfd321680d5a48d8e9a56ea0a0c8bcaf209f06668790c78e2b29e2e7a5425f3f99e1efe5ba0c68b16d87b6ddc06556f5be10e47e5a2e8b52f8881aaad48894f5f3ba6d51d408804b11d994a91bbddccc1ee8c4ca434f3b2f4193648e766fe663bf2867fb63c41bb92440664fc587b86499efc15a8c15269045dc60517b543a7a91d333bfee147985ff4b1243beb133b96038f90ab8a33f97dca495cf2f03b59464a65c9c003bbbe1e0ace431e2c77265fb2a718ce70955c8a59f38e36d47954ec125ce8315ecbda2488ab0811e86a3cd6b50065d2c7d40dcaf182ee4b59d45f409ffc15ab2d7aa1abb26ca671861a1d37937610570ce88c4eabfe7762b8eaf420335f7a3b2b53c869b629b0c7eb166268c2593d3fe91df21c0be87442e9888e35c773abea2c79b29f9cb3a3c00c2cf03364e65e696346d650d3acda4426eb6c5f99735429c60e5250b2d24d474c64e948a18cc8e1b13f38c59ca5d7089df093c07d44f628b1741643b971d2465ddc77dc91bfac068bb6e4d34abf691f9d5c8d61ea9a5b9a3687da31263bc9a34cd0bcef3aa35d124a65074f814fc7b7a1e9c236f5edc39c729d4c6a0ed264ac3d50f7ba493c6aceb17bad7af5398a2c1b81814728ee557b7b3d76f267b6446a497e2af20af502a295c2524ae16d2711c288282c93ba14fbdcee8449e842b7d108e8823b1beb995d37cb13279f52866c1bafbbebbca69dd683afe815c837d8d53b46e206e466e0ce41dc0a6854895be04c7bb8d6de28eabd7c2c5708a82a84f9e95997f7b890dccf1068a381ed3bc2d8c4aa2c5afe2db2c28ba084a09e393737e62674bd2d56e1d8d151288f72fe593d9b4041a085c5bb196b003911bd6f0c52196e9c33c29542aca3a503a2c546881935bf06cfed3d458f3aefba0cfb50a56803f02cc9204d5b85e18c6d7154729aeec80f0af7c10d336813ae8657d583dbb656f4a6a82607bf001ee718227723151184a4ba31ca863c6174953da609bca2ae60757857de0d0cb0a63b68536cb20eb29b53977515a4fd287c7e8ff585a61bab5ff6d6bbdf66d77fb347b291a337387e9c41be475eff80816da95e2ce2967da1a1f94c95350ea8b1826692a990566a8cf42472d40b1510810fa44b4ca4dc7b515ff2d23e4fce5af5f1cd94a80defd0f3ef39ae5ed1bafdc4f280357078b05eeb8c57ff1a966eaed403237247e794b8479e7672ab9f66ce902913488360620275466743ef6ebb6445b94012f7d3565aaff8fe0fd9fddcb5272d0f612b04b2d40c9952fb31d5b93354f761ae73558ba1e4dad900ed92e051b9af61958ba4dfff63610d4ea4d5a6271bfc9bbc08a72103e57128f9fba0940f86de7fa895b614765f80b77f0dbafbf375afd76c318c4c4d2cf54dd5c35123ed42614772fbd35200cc6b45e3d5dacc447939cd6c3f1646bdb908c7948e9a9cc1b06a33f6aebdcd4cdb76093276b9d564aae5c32fbae9504edf397ad00dd18d63d52b9a6c7fd98f13b3d1e32ebdf0d09cd90079487bcb2de421133edb60ad48cdab4c29f0f4238dd4eb7f56502dea73d8473f778b9d97d8c7eadfc492decf0990795f3b677dbeaa642c9380d2598d33e12d68ce9a9be22431a4cc39dc97e743254a9cab87eef4b68302bfa17142009105994f8d0142ae82b9828aa2cfdc984e4301054c092704848db7773fdcf671f2373795f0613ed0fc929a398038223d12f0600564d5fb828a8c02585d34cdfc3abc597494e427688e711777c8de0c8f8990946b85920e5cf5b9994d721cd0459bc1358265eaf6a7ea9d93892e7518185841b7156c3e82b4e1dcfe84985be7de412e45df4b5c91dcfb193f742a1ef62ff19c76500c105e5ebbb65cc8945920b5606e4b910ee349fd3a9f18450ae920a2ae49725c00031e165c97dabe685e4b1537411907dff7d494e4a4634516fa374a17fef37766abdb0b53842b5d8666ce2fe138a2089e22d0a96f737ff743316db83c2c68d985edca408e68b89a1f9d02fce594233707cbf48bc967ca4d0ec6d02de7c875130765c6397cfa2a8df26b5bcb20c13607ecfbcfb17ac749674c843c280e6c77392859bd77c7a752e88575c58b0fc03fbcd18e5e677ab9fe2280e4b9fdbaf754f6187e164bdb5ce067a81d7071459168e42877692aa9d83fd845ca9f77999fdcc98ff1c2978c6db9666228e2dc6b556f6b88c232b3e7e30a1a09230071c8e80a0c4ced339a7368ed1fbeac2937e89f9069754939a0b47e244eabe4bead0c893f214c47eb20678e43cb4894880fc1ed549ccfc9ffbff727e2584289e09581b6e55f3db21961537dfc35f78734e8fd83a6427e237e840beb33684055ca9bc6b936f78e9a85630f06a1d2efc7347cc3078d1bb4e93eee00f78faf15ec0e343852c6f6de2d751dacbf026f7ffd98bea94df4dbc363d0f664834480af5c0aea94a98cecb41b73ecc52a49c32b14fba351653f6d09f17d69bb9599d18d9cba72ebeded9951be3056eb8a47598047e9b3bd8f34358760a94fac8880835a80015e1b055311b054a2416f644c532e1dd8bbbfe735c3ae9e83c62b57e89da15235caf84828b5e3c1ada77a14437e5e6a156308daf64a954e46dc5040d869a2a3b07cc0a1c3df08e063328632dbd5bb2904c05e2e6cff7b132948541b1858c5700eb05c168b9037f88179e4a8b229da44561f72aae31555351d2373c1ba0d49d0eccdacc9510a0a53687e66024d14c9fbabffcf54ad462fb838a15e24900b2a7e61c832c2bffc1a96b185e968a65fb383e68757f4cfe048d8c3919db57c024b1855ab836379e7d189f145acaea04c59bcb713c87d731e368b5e058fa6d9b1d02b5a898fa4e7ce5be7503faefd0ff9d8ec8549fb56c5b40bc91d1ccd6b4493a14f495f424367bb8a6338d2e1bc834221e043d8bc8570a093bdb34994050368de8d16ae43b82abe234c3fb524bf378d6ad70bdfa0eb6566b40db1be0ded866756e2365cd77690120cfd09afc4f49e6bc10267a00015d9b2126880bfc20957143ba8e2c2da3d0f60afd5660407484d98882fbac7235d7e7473dba04b981fa8d23b7c5bb653afbabdaa482cc8eb10ab60cdf78981d7cac5ef956fd77f95cc02da6e3d47603c39ef89347700c117d9423ba51f383134f03e0c55da8538eb83290a381dda1af5b1009a7937d6e29a1c5c8687e8750432e5717f6c8c527f70ed99426bdc122d970d4aa4647ab86265f1447204310784ea283627c0e4a525c1aa0d965dd988fa78d7aa0b3dd1fcb70445fed7d97d5c6ef0b8f208bf5e806946854fdcc36ea0829dc4d6d62c57cf8c48791b004afc9234c5042af41675665a62b4da588dfa3e211e77139fd97673bdeced1a269e62f1809b5a673e6561bb4e82854db27e3246efa1ebb16011dcafb90aaa281254918820d7f2fad45d138eff83da242f9da2cf5492962b13b197c686cc1f1ec8766a450e1530ce9a3ac2d9aa4a59ef9bab0d18a8089b016367a8870059daf4dc0e2a2d99dcb3d3104df04ff723daecd7dbb2f9c29394760cfd46473476d90f6ccbe2395491ca2ab50c18fbd388ad30d6efd396a04f8593a3668b4cb02644c399389d7c1b114b8dcb05532347ec10dce46b68f141b0a9fd55164cf7bce7ae419fd98b55a46eb8e6f254f31922a3d0798ab64ea1dc7d0d41b007c6b6aa2a7e0e1a72f636b1042165ae68df836b6b851cd4262a162d207ffd7db1eb684095f7d2eed12502fc69fe522f91268a6e4c0d090b93b7a2dbc5a3b771e2410de9a4942d4d226952f108efb4055a8d621578fae8134fe37e58be96ba6e740a32c22b13699a2efdc5d3ea44cdf4cd35816953352421b7979466091c1c2e6db2d8be10ae37a580fb29c3f8eef2b7e908fa789ac0ec3ee80b7e937784fa0f58a4dd73d73a18a6614b36063389d1031340d4288b0af42720104715cb4890c7cc6def392e51a70b85ae3f157b9f219eb49726824f567c70de8aafaf5c42e859856aa5db3d8ebbd64f2fb006ba641a9a89861850eb50d55346886fca7de00ebe5a61ad98caa49d8999f69184ec1fb2e47d4df99c41b3ecea57ca47849fbcdb019cd19a81e8901aac7191f867f60833c554f03e7820535c673fcd60b927d4bfeb6221f66c914cf4fd70e7e94f4b0b6e30b1d4c2daffcb77491ff8b8b9949a8447b24e285c0b1ced90572e268e32a6eacab9d150f8548d581775fe94391ef79043592463ccfa05f55224f27cb5761e714b1b72906734e52696f23ff390bb7cee0695c210a7c445dd045e883f8148abaf0d43162430e0b9073c80238379bb70eef2638f853b926f29bd696db7b35d553ecd9e64b4e2732e9f2af00790d39c48d313c8d63bbb45e67e4306e617eb12c8d3204ea707a77591d3abf792a832a232f55decc6aff79a46052aec67f7cd4ad462d2f183176fbb75daf676f289adb2b54adb0e291239e03c31ca4b5e618ebc2563cc134c878a292cb15b4c06fa403deefc7315e0ca30f7bfe4f1c3fba53fef5ff17a32df18e6433d7994f22a9e7cc62a84c528b9215939fb1ae156833e83e0f31cfb6a3fa81c1f09ae0556b38fbf4ae9317bdabbccdcc8254a5928e5abf7fe0ee264b0264d90d1fd17096eae60bf3fe59c3a4ca71d841d540bbdfbaedc109308b0848de214d32612511d8d71713fff6831fe177e51b5146db094d26ecc0ab6e8b6a1a13f181fec73108f3e6de16225ca0778c1396de726c2956c631754d2305a428a822c6c26e8cc71a87d4159bf3220c4f4f93c365efe1ea1f828ca5845728969152224c9ba3a92ab6ec2ff11ee3e9cc7d22cbc159f6a3cb947de8749d808ea0a5c9cf0ba0253d58d0146b26a0b984f83f4fcff7450cef87d6b0b29029a3176721dbaecf8f6a4e9253bdbf973b75e706d0cd559ffef14bb3a12d1fca7501c496c86876cfbc22897b43fcc5c93bb0aa330111f43000729091c01989ce33612d39c1e41c1c757fc22aa60836e9426356489edcb020df390ef33a6b295a59b5a6c97b4ec961c7951fe91b4c037822e2e39d161b09f019061d2f95420ca598ae3bbf140728ea316e1b2100b3023f168bde7693e7fd347bbe5d6c69f79fbb5e62dc8ba04aa63f96a4468ead412a00f79b3b94800ad75b9df4a42541fe66540e4c52636e6fed89eb5e928ee53cc1f8b1090f8548f09d64a9bb665c5e30d7ead6cedd341f7d8dc0ca88fedb54d4f927f7293f8c9a5f5dce3ce1ebf738d961c57f6a071709861d5b6ec431b68740c1e46f7b66b830223c0d6e8e696a1dff571e683daec92001ec9e3767e26f24ab861e00903ebb3a6a2a7cd8e7b23cb2ca1ab9edde34e07cc46ff7dfe6efb8c389ba725d9f65fb8ae686aa8d9169041900871233d57795b3b73e1842e3086841b9e7beb9d97e0c41ec47ac812ed566555ba17aad2390544eede3c2abcacd401e80389000bb76fd4a6a6718637abe4c42f56625d2940c82d32bfa42d8933bd43fad8cdb3034967ba367e290757f86ca40ef4483235ad78a4a5756ca704a6896c4b4b201c77d4e92abdad33b228ca41a5303742ac64a0f8439adfd484251bfa885993337c1d9a1ff17528e0acf5b1e04b8d036093a69842e1dcf6147109061ebe941614ae047a253e57e3f6da4d2c4be8d530a5f6d25380eae9fd757a597c1246b60cb688412e42cc2a4178f119d76a3f9db44d4a6a34df0ce0a83bd2ceea2e4bb4f2b7453ce3085f5cdb365fe657d63e357f861d4d08e4e9b16b04d73923cf3918644cf3e5c6a18b069335f1115e12c8bc99013b15d323ad003c72f9d6f36ac104042b86db3bc7024710b690387eeb189ecc9b1ea1efd1139738ff7ab8bc459f700b907beefa6725bc093176452d367c0a82e5629390e633c5ab6358742789e14ec57309f9c1a91df206642fd444b5d24054f526f31a26c0b839fb7711419ebb4fbfb353d941165c35e30dc7a1eb162b9c3bae9e04202758d0a653c2d2fee502af6656fe9c51ee7b788a9b35e418d42a6c206a4cd47401226e0ee85fdcfe0be9d809c8b353097e12bbc33e0b4ddad54fd2c4b0280a0d759ca63947e5bfb45385e1acaee8a9ab72462b8c9965bad2d39a2c66cd5045ca9601a2e4d155d50caddc415d8da8b9d44833abf8ba1d9b6d14c35c1966f143bc466353fbf8026a3f9f4b3a11eb1af599b6d1cadde364084de315c3176b1d11f15f2a12fa29ec95d05fb0780f9e4fad43bba660b8041d683e37959ed6fa66e05d9a9a29e93425548c4ebcd1d0060b7a62d91fd3d67bc0d025ac1cf3fa8540812feccdad1f5afb02c0ddffddbc31dba2aa4a59dc8dc0483861fe8b5b911422ce6fa16cf4f8af7ad83d2a64d4b326dfeafbc4519135dd48d20b86ea031a1dcab2f24da25e3cf78af239be97f5631a0c6e8b5696a68a20db291dbb916ff69049e9d71b50a41ad2d3ce38d8c81c9194347cfa54eea486242fa0db9c08889602b78c9b611971841570b2241f010c7416e5a4216d709998a84bf78a4bfc3b725cb3db71565b7d0295c73a853114035145a65899f75ee9538807adb2f69272e76c64779634706fac30c5cfe75631390b9342a76378fdc749c4c7da5f1796fd7f1d05510249c535bee7c9f8a2adf9f43b40f732c8c2bfa0dd9b0fe332f8b9dfe061773fa484cca8ace08a2527831ae1507cfd633cb5ae88af9bd0b5dfb5e6d5fd61500e7c1bd2dd3df72980146b13549d7eb5334a13509f8695f3f65b89e0c70b3fd0743c914c5190cc71ee931bdda5740f33e40ac027bb9dcdc79275fb43c308d609aabce4a63ee67a481afceec3fb2e528eea565e885535a3def8d8314fdd6dba39f3f8e6852b94bcf72c2fb455d1e2c8d09d48655a882381903330b58f60b0d16438593f7b709227f6bdd217519cb4c84d690e3ae24b9ddf74b9934d89de3b2da79dff212dc8cb6a97018d98902eb8fef0b0ef9bd18cab8439bb09658059a94d9bb1225c199389e43a08a99e989cb67fdf102caf5a65dc41fb15fb4c1f6837c6c13e9faec388ab1382700ebea5702d7a03ff2256864d2dd1bc206192d5713ac553ce6d993795bfb716313a5c2455f695aa0bdd74fc68b39baa0326fe12bbb3ec97d8d98f36ed6920675dee4ed984e205524f684a328a782e07b60b611f84d675f7475ef4d2a9b190a2c5ae2c915f2644710e6180122e3f58b8dffb35c279b045a8f87f5015f05db747b2cb30861b9c0ed566cc4f8394efc46a0751fe53546e7786645bbcc12b93e3f8b7cc4336e6dfdd1b30fd992f9574e8b199a84d396e58a1dc1f0ddb145bf812cc289ccada434cc2b9acbaa6bd109dd0a4b08eca2812f6f9081843b53eb514d6b35f878a5ce0f140e6895f90165d377918d09a6ae48215fdfd6dacd830fdcf655f49d568603300d119b3e01473f541568c5bd145a7c05768ba5a4a1997c683b01c8e115da2888eea966f6743c1845bd9bfda9200551dcc09e4544a2b348fd97c6cd3bd8eeb22ee4067ce43b4abe7bba51638022c96332c463b4418cb1492b92f840bc32ff90ab96c8fd6e6a0ed14276f07ee23cb447442091f66ea4c466ab0e822b3c40dcf523a53ddb9ed8dcc57d56b9a4cce31ec6b2c6b560c97c5788dde2454cf34bb366d15d5cb869b6276dd0962f5bf435b35d0118c89c5d51979ea5ec25163e8812bc055e19ee0c1c131ac31f958dec5d2f1a82e8508a442ce12512229d2fcdea680925e463306321ac9c454f21ed68fd42bf0b51e8ac22109a71d9f7d58fe088449caf8e38685169d745c5aca6d106f83d9aaf20918502133d0e7979e92252acbcaede0343a621a292a5492529a2d759a4cb3e2ce3f31edaeedf47d334672ae93fc617a82daa464d1417a9f8a5e6ef825537dfca3be461ad2d7da13a9c034c647bfbdce1bd77cca8a65336a8d799b9de48ea3e7a91ac8e26b45d32ca970620d44556281b0976d6e06e3fbb927f5fbb0d7d84876368cd81079eae35a80999bc5c7e1ce2a8787c48da15416dfe2fd432d170230d174cbe65c421b01045eda6c8429e6a1c6c88eb773678aa21518a6fad55d7f3c6ce76baac9531299a73ca349d94bb8a509b5dbe556820b7fc95bf3c6f2331311a9965adb9014bd22ea3438538c2a7e40172ddf1701b262400e56f967206cccc41e98997e97c18e2816c2d6deb7760fa0eb04de7686d4c5ac9ceeec9a3076e9e3e3219a951c7410c7262a731434815ea332985bf35ab26352800783bfd840c67ffa00d62b059535045205ab41a8fc9bd476322087e586873a5b1c06743aff5b8f68c3abfd22938737238231491e0b9d4604e93ec150675703119f745c3561af04b6040d6b083a15de5992bbf67face2e7946cea5862f79028547b3b77df7895e0cb4f2aa81b8e5f30671e963823339966f1abe6580573bb1cb6e3758200ccb15a81b7efc9d1dbdaaefd2f45fce4625e8c5617a07da66025d7a757777b41d416cd01fae9130e463280ebd9058a8699bd2fd59a643b653e3c28b6c8af08a22caa27f50c6624965acbf8e3e245e17da102c6974a0a95dd7c1c0eea27883a3c6166039e2f8b70e9ef98a449dd3d391891d6c093f118755692bfaaa061f814ad127b5e6de7f661270c987f619515204cc05ef072025f1c36cc526ade899cc629a99a6aa38407a7f0a2cd08dce63ca02bbb660d6cfc958c01f6269bae5490310f90f566c66a227d244eca810ba8d5e9a286cd7db86622738c471c8bb2dda993ec7ec9c6f3de0534a97c1f4d9e7c24c97160f0403adea79c033fcb16d63669279cfaab0cb4753ffb7620ada301339a3204cf7fa3eee2dc8a3d7dced6205750cc10dec18cf1668d39b1f496aedfe0aebc0f46bf38823b1881d7ad760b0fdbb47a98b60128ea418715207c0e07851d1248992817e7f412ffcf204524ff1ceaa3e7dac900d6c0efa2a0d679151c69d65128968cf2990a05264364cba5b1b575b268f080ca8c8e6031001ba758229df309c7c07cdc831a22085670eb31150ab2e7b91843fc248d0d25d1909bb7fef24655566ef3edeabe4e8ca7df9ca666eef43b7a5d93a770c3dd25f7e00615d122fea4de5a7d84b35d391c7d73edaddf57f189f940da65965d253780e1689035f3d4813577dfa0254fcca91a4fcf439cdf7f0c54256d3e4bda687b0ef6c87b92050138f0a53731951cff38fc58e81035d1f1780ec1208aa934ae57600e6e36b84070db844c5a2e2942462595eaf70c2db18341028e3a6b14973974d9a57985ded289ec97c11cd764b4364b51bc867e0fec566fc0450a01630bda4ddf25db5b5f1f84b5da7e859ec0c5a509b24631537e500d7d355a88e69a843577f49c9fa49441a59319cdbdab18b89767b5fe249e5a9fc46ebc39d767669b7bcdda34daeeb38cdbbaec8037a30ec1c0ec6b00592ba527438c6f1a90024c48571daba0ec28e6aaccb9fc5363bbfa380ae7aaef579297c494eebf7b5618a5594e605ed5b3e8b556896e074c63a2cfd24222de110646c37854803343be85aba7b723a9f911afacd76995fa13e1078965c39928841cb364c7944ea6f7e7fb980584c607478be90f87142c2e44bc3176ba66c560d20ef68ab56296faff60e5d0b6967c84a8399b9ec5cfcd02058ff16e64666738339b5183925d2388cc0dfa8bd8034c17c49f02ffc6ba8d1ec78d7d8d7232db3ddd13f4a02a0df7bd43031b2f7f6261f13918fb970b91ac350bdc9f6e5a972fbb8afa92d2b0ca95cd48314850973d1438a9bdb639907fe2e6884691995df2826ade7878524f0b18a4e9322e1bd5663e257f0f10315866634eb546dac1b23d814aa000668deaef87dc576dcdead755e96146e8273f7bf945e061164f6b95f0c8f9a6121493775f02595d7c76984fadeaf842fbf0a38688d933584e276649089aa86ced5acf9e2554754909163d58ecbcaf99124619c93c38e29c6d0c187906d0543d8c9b8a13765ba36fcb7441ee112a9a3dff036cf024801ef2f828925cfc4aa0dc3ffd873a51b785995cadaecc27a861bb19729455912ca74128eccb69c251aa1f86db3c7439b35310b76d99faadd4c35bc32d620531c59a930189b4360bc9cab72f9a699839f2bed60839642ac78226e3249fd4ed12e587405c7e44a45c3d5c53a5f97b3dba1fdebff0dff61f2055d5e418e3eeae6b84d13b8192ff7fa06d935afbe0d19aeadd55e4892ff1170d6183729d989983ae7f7beeacb6400cf3f71d1dc44bbc246ad4bba876553de9801e0ad579ea605a6556320d7883e228954d5ce8ab5591426b12a25765866e5c1d5b53077b474d5a9f919d0b18708437b5280576b51b842be45eb1909a9982bef84bc14c267e894a3db8f57dd2c30edc888a9be67e238045e58b8f3aaf1f91c87137eb3c23e125ac3340d158c97b2b79413f77e2fa77fc3e3ad016ae8cbe858033a44ebdcbe3bf827eb7fb930dde2ddae09dbc111b3d26fb878f87c5705c7993589e53b942ba00da6a8c619553fa996b9caaa8b3bc04a3e62a7217f5bf552c7f812877dd36d5de1dad7187978c637045c2e084bf1ba096585d3c59b670e12788ea6f827630b6ce0cdcccc42dabbd355d067fd0570a5091668b2bb50c12cbee5d4f412a1ed2f026887b35f94ccc61abbaca834b609dba21df25aa24708fa2ba1d57f4da334730d42613e25c2510de3b6bf5e169c9983155504e0ad92e13b931feb2d3b689b782d0a4dafca56dfb734d8a3b6f4054c60326afe9e0e25b16ce5acde0ecc1d5261faf1aa57f0d57616c37c89fbaf428eda97176ca68a8b6b3e621294fb88ba5677df1d1b9342812954ea863109c30b3ee2d03e01167ac5cec617a69eee849a71f425d8fa17ef53102b69cadfa0c12d3ebcf33a20f3895b66eaa6da2db8b6f6c470290b1a6dca17a454deea022b83c911eb16176083c1e8d30e35cb1648ee8a8aa58e31668eaacf1413c031c8b7305358910b6ecfcb1ac1cf6986782e9205438fe4a3f4744cd4acda35ad90535aa3289eb21c125b2789a30ba9f64481786fea478eb1ed802c78f550b0cf2a9bb2d0627aabda6c591f83b184f64561df9fba946801aa6bbfafd9d7a32e64a80898008d0463f5b77d63019e8f416c7ab0ec820aad90dbed3a2a52bdf4f20da4190ee3608c41ce36714a4889e908f56f17ec199ef3f2cbd119d98c76d1e4625eaeb757be2c723575f57df3d31d31a9d02948d3d4390096b48e3bb7070c1452d94f02a64f306ab3f28602da9b62a601207e5f74eb155bcc80c9353a824209fef8b73dddfadafd566628ffe9d69d509f0c42c06459843773d1baafa4e1c754221aa5e55c3ca595bf22d3d01d2f6aa4826a009f6fbbd2e5948143852ef799584243f4952427d583a53e632bfa63c5836b3202f3e005d8a8a2782d4f7405112477d7f2bb5ad01baa5493f76d770aa9f4968467ed30cdb2ba601de3b04b8ac51822d4ebb176ac76c9a32b5d6dffcab254fad6d86091c735cf4a30963984bd12415fa6a4d597f47b3750f313a159ac85faaf82271ddc1c9efa14b3440e4258ba04422eb66ce884534ae81bd20d5e9bb13a57e07c72c4486242b9f41013493bb7aba7963f4d200a1746703cd97ae570d900d5501434424866d1ef0938ea76bdbcbbd231800c2b7dc8a91ed04f63f7ae68a828cfaaa2c63f028219eed9bd3f106bba2899f7f6ba328a6e34d96e1242f851a776221475c7a2ca651880fe06a650151dc7dc26bdd067fdf0b1afb6bf264bfe4674c38c8dad0a04d69a892801a5b9eb613c434643440865253ba5e903a8720a81c6104b9ea36aad1aac8252cea4ecb9e961429c7a405e1b4c184c4a50144e03f04e52a588e867c6e0d8afec5117455bcb7ed3d8f5769de3609163cc8d9620b5db142fbd8efb995d2682db2610c7d7351e5eb15a561f2b7987d807bb8bf5175edb965b36fa9c8f44741d678ffbb52fb016fa99e57606505ae7122dbc509840b8d236b103c15411b3b7ae1eec1a43e9813f7480985b8d1bd2e08867f24584ddafe76738e62a96f1720f23d66789ab66d21b8ed7bfa2dd3e1a6fc6bffe6a4451252f10be5ea58809bdd21717a4466f1a827c1f37dac7edbb109bb11a3f7e7024a54cc876049c4cc49749353ee05f5e5aba4f4e90e897dfd0ede2deaa2a2b1db5222859a972f4b69a0ee90466f2946c07cc5caa65419f296cce04a84453826f638645ee0310cfc6de67b4818e5fcc43c49b05d0f439385676a417e34c45dd315936007878ca585f03b3b0c68317eda8f9af9276470251816d7211363da61ed9418de4d16af522e2036f17043d6d3d818ef7e006f25d0371bbf128f856c773e2f777549d0be8b9ed83fbc3dd61a897ba7c9193944953a144c6d2a57ef9debf7ef75d7665d52bdfdb8c59110d7302ac60422bb334cdb9e7f4b5dc40fef916f4fe26eda3e9db7af252faecece06190f640a6a53719d67c4e464b9a5deda5e6116b5037a570dc3e0abd9be24e72bb3a1ab2c0d491b0bfda863559968aa9e4bd2910e97cab5416dc406fbbd0aa5f3943f5b11c618155ce3c74cfd9fa0def9367e7fd12f024165f2b6cd3daf0b993094e79f2ed3ab704b8b52c2279155447e9b25ef03c0f544907e92f915972048fb89def18bac2807228517d57f065abd7e600520aa2d6d60e2749386c6be2e1b3f0bf3442f65169f9e4c8ec661e48f2049c086ee094eb9ca29074352de8483c583e31c31dae67e666a32d4a3e83f12a1ee93bc94549b2a6dee9d62b265edb2a64a347311ba68a35f81387385564196378e0143bd0f3ebabb3f3c755dbbec94f31524404fc5fe82cce28b1eed3362b22184a0926c7de3aa24ac1d7a39b730a14c9bb4d055a1734dfa132959253d9f0060aed88179c50a9edd913eee48d9587bf65fbdd04371dc15c98321d0640fe27a63e3b152c633fc9417f82eea1f11e15a8f6c3db4e8a3f4c90f83b296b4773058b11d9e8f4a26deec450f09dd91c3f17d16a3ed59d3a0ecf730cbc6f22504798321ec8ee980bba3eb89ae66e0890d8d05ccf97cce43ebea9581ed96b6e386796bee0b832565937226e7cd8aa7ee5c71e6d16bdf9805ebc824b5dce5ed3cd4ee9a9e95a3db47c69265512058f60d7b31914a55f847d8115aef7f29db3cf90cd2a3f2f27b3b48f2cb7f38e137ee0a908eb1cc1b94b5d111362f664caf539ce71fb96110a4fc663d526f4d09c554d1f43968c9122127baac47511dee57bf393e62ee77d005472b4cf3160bd68bef7e76e05b998a0da05fbd26757dd3bbc413539a7ef4575be23cce40dc351615760f67a201c4ff6ce44ab2230916cc4ee31a811f9c8505758b7cf655d4b409c5f0bce544eee457903f0b0068d07f2c2229e061dea6d3a67ffc43ef8bac4fda5ae22ae512b410f1cb1aad06595308e9bff13269e9a28b7fd3a96633989631dea53035c2aae5d926e93c740a419437f00ab4404dd84c409d03a74ff74470a50d557aa92a0245f7e83a0c665fbf3a996a5cfa2248182cdf1296edf47b9b8834f96b25e1a9257ba7c08f5c3f3fce60ecba0c199809d8063b31d09cdae17ac2a8b56c74907caa6d94df374e61dbf60c630b610088eef909ff9451d5afd57b911b3fb1d851662002a0becb075db52cc5af0781a98121bebbeffc8d037708bb3efe3685401bff41929793258ee7c10fbb8248f4d440db9f69356caa8fbc9f864542964ffee8aebacc157fb1a128d04347ca227051042e1a1010a41b7ac6559b6d10728815702312f4cc7f0d0693f65329d917f138ea98fa5070f8871f1e609c8bea2e29d935ceb57ea81da0e181dddceb774467f6c4f8ba676196d508095184ae96b9202f56e155d6b82185762847c225b3f19a1bd2151d237a2b7f6ce5f49944bd8804b54758632a4641bad9d457cae3e86705e1bdd5bb0726b8b65a473cd61764bd625cfbdf503a67a75be94c47101a34885195e04a386ad04677e89940fde273f50d1ce38bd124bdb82f674be3c111d8b912e9b6c52a59ccccf0384cb9f4a27bc65221d207470909a9c70d68b22c908b89a4cc19398075dd6fa9bbdadf809f3d43512499d25533f9971eae0359df36f7ee4234d1bd9dfca80a54fe26328ef06bdceda3bcaba24f6f3980d6c8f319f7183a5415d9c07dba3fb894faa431c1273dfb18db5eb9e09b7e034f7c3a455113f100545f8bfdff2ffbb254bf96bbc5d00c3bdfc9d85c58c1b037429dbc7141182f4cc2090116a607ae7a6c95b6396bbfbf381a94fa296a11bcffce2fad3d4d714b3585e5b617f8b1b00007d75942db5a841754a1228974a9d93884d026b897b668ba45c33650e9c4e1408fc4d7bf568d66762519129dc5e0cf491e8065074f99814f268d350619c359e65ccbb430e5ac76b01add3da8b3f281aed3c6c5aad8678e7d1193e33067845fbe0637e166c1cdf76495bd3e7eb7f3a27257560338091b7779bd6516277909903fb0b68e2d3bc61c28f1f3097750171300f6355a2f04e66e8cb6da32a324fded019dbeca4a41318c5dabc2c812f5cc4eab2c270f2fa27be2f2c1f9215d82d4fa58369faa1f03890ee43db3602368b334a5b1fbbb8d4f92e651de9b3ca7d02a9440fd99c36a6ddde9c2d55bfdc5a6bf932d69f1b7c18c057f577719df846eb322514d0ce3cbbbbf085db8cf7ce65c24556b4cb6a86ee06b2d49a8ebd828","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
