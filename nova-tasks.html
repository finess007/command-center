<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"94e261096e32fbe432291738b4a0e9141b124a40eb0b2cf93fb6598e856aa38a76a9de550d2174b20894669c30905e85f5b0d8e0e6f00de11e7368db0012de1ccd359a4308eefa76ab95b919212fd47f6c665a6e5755d83ccda78126556cf3bad220ec1fa89499229245488cc3d722e526a3fcb067ec15afec96f600a5e8cacfa79b79b5b768070aa2535c0a65c67f5626d5e1abf27fadcfc11e8f80abc9ffad0081a14cbd1606219b157ccce1dae4d0f48030feaf18e5893dcb4732a652c1adc3d09f9534d95e465f7f8ee101a897423fd8373c681146fe1e9825206bdc6dbf2c1e78d5b010abb7ca17fdf5bdbe9f2cbaf3d7343fdb4a2703513d0f779019f2ba66c308d0377aedaeb7eef5470cff64536d0b7cea4abafd5ab50fc46848e540e7f36f015c033be1f35c906b68c3764c35c04e08d9aa073f8fca5c70cb639c69d8b033d0d6caefc9b4cacb9e0235ced7327e212b53260f8b3a1d37f3c1ef2fc35b6e1148504c7744dbf0084da25618b68670a91e9e5061edee532d43ee3e45141a8d2b885e27a3e816879f5b3e9231021015c42a84422dd60bbe25a57986e90836774616d408139121c1b25e8aef7a5a408ef329ce1a0c0a257be06532ab69af3b46b98681811a34556ce6570df9cc74326c878e7f665d746d25e9ac08ec38e2cd8b1f8d7395ff4310dc5460dfb05ff74a19a182ed4afe3fa86223b49ad9f9af262fa01799595c4c5ea5dc6119ca508f26fee0cf3174c5a4aec1213f491e26251697174b103aa809b4e6a14804cded2bd526d4e6473d6cc88f26a9b427469ca7c7a4047c5280c9974b4608a531a020cac87c4dac16f825747379cabb9bd7505f121fb101d8798c831ac967199202a81e4692df72b95bbc5773372396b57ce833d34ae3ec8b5c4dd15b09e0e565217d49bb00d39bca3ee75e7e586973829e14a2ca3e5e3abe32406259d6f5e1c055e58c12b5bebbac3481abf93ec81f49da7ee2ef0932d4711397d4d6377c46634e9b5c8373da3e316ebcb6c62b44f5e7d0a006a572b9779c58ef65510cdcb57ab59ad2ddf661eee2586be692090a9a2e755cfc0cf6722e958b575c37dc23d7d669fadea05c46eb80fc6ab46103dca853be622d455f9d62ffeddd97080c72be347dde3e2d3c109d3376357d2ac4d61c6ee634343e1e7f2f62d95da84b0cf638ecc74a6b724684a4c79eb620d572d620e309e691b161a9bd306ce92fb24014fff16f7523c755aaf07e764aa2de4ddb975d7de284103030593e2cf4a408e2f66ac35890505b363d0e694f17ef24782f1aad4e1c3d4a12a2aa42d6291453df2bd4f7f8512d905577c45a61788ef8f0ccd38477dd18e1239f0f46c7a2d1bfa69db9792e1afb70ae27c5d52b6e80cbc5e63620201c080c60d69ecd90ad59972f721062d202dfe1d0057effd9cddbd3c8bc72fffce7b53839a9c701854e4d55974993051e3f38fcc386f27d74b4820dfed1a048ecd08beea52bb04eb6e369c9c4d81c109888cd73eeb513166f4fbf9496cc7c75f5609c9db970fce7490530099cc55f3e5efac51ff91074060b0d80585b183d03771b74c3df2c1df2df5ceea9c9bf653f4c429aee6013167be3ab80dc85cb2eb317ed46bc0fb6cf9d810991a3569b3941e1721a01cf38113f1f8e4be4c01f3270977bf0814408df07f6164d7e9c983b5191b2f235256a389eec7aa179d8353b08f99428db2796747a0476b1625dfafc461dc04d1b46918d782b19e033af421ad68fee5f65492ec5b9badd14ce924a3ede8bc5813863bf2fe21c7380100005c38828c942d2bfd1ac617cdaffe4231d01874e75e0f1809a6a8625bf9b137831ac5ddad0bf4f84c49b8b161cd4089135d0227f05234ba8ac7ffc1c435776954648a986514db8442abe4bea21e18dc67d34d520740eb04fd95adae15e483f0dfcebc87bbe03c966b5c2a18db8b5f7d0848b9368d522f79c9bb6aa857890efd249a2224d25569f6a9895d771fd9e7bcfae75edb79f1d239a0ac6b457b4dac78e6ef974aee5b7946044b5ab809d356c4bfa7c84270c822244ff3202c0a54c277e2cdaadc29032e9282ba1dd1b82fc99809b24bd00b7066c152771102cb9502182db7be44661cf60c2ecd198bc92b9bb387d01026a2323d83d9d7ea22638de8500a8051f89e933622f2d1e63c9101e393351e58442f57e9068e20a53eb31125046fdbca890a1c651a1749d5231266f980a0a699b20c8a0c730205c3a167504e2407aeb4ed29375feb34458c144eb492a66d5bb625a6263af5427899ea21c2327df41d731bd46a83d8a0714807ffa1583a848ac500ce01e3d99eeafc61413f39bc89c042e59d23e4f6b81ba7c1fa10a9deba046d923b4fbd2c093d6e6d425b4b2794e19edbc9ad67fdef509a6bfcfb35217df2958a2c409918822663058c107a8ced2bbb1a979973153ef6ee4bc7677abc978d7fd07d64c457a4b601114f708ec900d6c6fc5e287a9e8f749b927e7a09a43907b2c22f2ccea3ac45fa7a8438877ac62d9fa253fc6fd01650f65b4985600bfd13f83652868c32a156d345125ed442d344cdc78504ff1efdf1cf377a118a4c34215244b46780032530fae88a5f54887890c99908e4bbdd50bf92457c28cf3a753713637208d858e95e49d150a039ef80c598847ff9994e3974fd1d4666f3ce26d8a34f131fbff7da0a06ac434fc71c6c26f63e782e61679ca6c78f6bb38e2bad78173124bda017e11ed0ed6c8519871d931611231fe036fe26703d9db030967fd519baeb6a2430cd15ed95dfec3fcee43d11d1078c676314c2dbb25cdee78badf01aca361afae2f49b1c6b2236bca14899e0514c11fde7827d61bd1f59b416aeaa0afea655f16086851ecb8a6e959e3e677ad64d578115333dd875d98affb6b6ecf4c9966dbcecd55368b7d54223315b0dcccd64af41896575a5e4901d38f773c78d234b5de505a63c7f30bb94ea3b3ed3a293c3c1de1e8a455eb897595e3e4854923a2ac2f09e5d6955cef51f6f28e09c50105752795c8bb63558f5ba0f49c2155d501f04b2e8502a746b64fe091018ad8af926a42905b29cc224e0ffc059f9a896683a490521cd5c45179ec69d7728178d7117d95360f758e49b1625a9b0e8faba18038e832b7e8696c5d377ede9a39087fd8f982032f3a792064b51fe5b8b3f5db989a604165cac6d816e9f22208e5ddffa377b83bc181441bd8a9893e3420455b31cd58c5c952f029274bd7470e20affed2590b2ab1d0f83d1c1f3e6d88dcab2590983131ef478bf363048a6ab824c79e4321654ee81b8546b0d50dfeec66c869e08d70afa634b58869b12e540ec946df45b89abd073348d95a417e36ce2b37fe6c81efc23d4eb66f259b4eef6e5681a4b9f65d37d18656c8bd40986b207ff9197634bd39b0d97a1dd21b52b73cc4adc4713bd86d837796b4376516792d5b5d5d28f5364c62b959a17eace5bc13643be4fcbadbdbeaffabdb3bd8a3dd40e5e8a1aa958853b9fec72cebcd947ff7e938081772dd38602a2856b9e7ab6d9ecb6cc06be71cdba7dc2d0db2abe5e854b867cf25cf3efa4570646120f7359617fbb3a961c1b66030eb9a76593adef9e78346dd9d0ca01ef35a018fff0208646754b5737acc37826eead0e3153f79fc0bc1c29ccbdd60f7bfd42f82714a9b2d83da5e6e2021f40f344d90849037dc663f215f87a008d1e62177083963f0c3f40d4ae4fab54e636cb691a01046e371fd12d3d30fa6e32d7e095fbeb9c0f83990750f86435afea6c88576e6600b1a8d2e80ae2ca0ddb57fd7598b6657420730f9fa4b54fe8212003ecf2a50587d1d3dc14197a5467f0c13cfd5a5f50d216800d6d43a7aef00638ada87457ff7509907f4a7764124d7c879f33391569185d9349048a05fb2186a17ec6c64e8288d97df69ced2f09eada99c10a1b0d02bba8fea4399ccf5f36714dee37d3297eecd9b2148bd7ffbb48cb99f0d94312a4c832d75ecb959fc4852112595731962dac82bc3a9e4be6d2eb6f52dab641968f5bcc218c59d525e7aad39cf7e8ff149bdf3507bb8f235f19115ff6cd8b1e750e52b7beabcfdda26787a5210adb54452c3a9c96dca11a749f067799177070a190a82b0d44291333ad84d07bcae664a33fd20b94940158de0e780167d9ffd981e74dbbb9c5c3402ef686f706d3380d778435bcabb5381c81ca5125723abfe2a9ebe38640ddefd86af53498add96af802a4cd54a2a72f4cac5cab7fee138a4b085714e0c41797d351df859af31963abda9e855dacbf018fe41fb6659d4a7abc51b1d721e7e842669c4e527f30945fb57762c616f3cdce7926d4d826cede068677ee6db2dada93a55216e587abf314c900923484c6b42abf889238469866f85074645458ea29d2af0393dfd371850018fb7ea8b127dd05222a22b07f2f4c616e3fd4b04ac1ce58c0d22a0fb38ccb3152a4cc6ce03a011488979191255d1ac5b670991db57eb83f73d62d1f19f0b715b19a46df06088933be75bbf6e47448a4bf64b1557a2456f30dae9818e1b1673f91b36599c42b0eac74345feab7eb9c5831e4a8a4574f819953c29bef074003636ceedb9b89f87a69820441c609f925f0f9c4e2cec58eaf7e4590716918be3e717d44c07df1e8380152b6282d5a215a69feece15cb83564f7f6c9ceb90ff7144d4932e6a2510783ff0cdb2e3a73de7e899d7f09a029603d9be08867264121a949a3b206f4b257768c9fbdc48de189b4cc8b4f686efccc4a428279a355db8efc61b8898429747f4d33db18a383d1b8efdfc706e65b5ba25199a6ce6f63152741bfdb6616ff95a7c6ab520c29981551493be5b68420e2897a027387ceec5f7e16cb3f93dca049bbc4e5f559f3af2cd6dac957e516e775f69bc23461d840063fea11c19ba886eb115a58f388127bc240dfd3b93be09f53a911f37d1b980e2da07f855d09ddaf2b37dc679e02bbea13605e037f9e206388475a3233ca98983720bb1e54fa92a71f81cab70da58498f4b501ee532337c8c88c2cabb684d512b374d486ffd33404a936271f3406a9f78bb0742bd096666f29ba3d9d01a630205eff3ceeed03f5946bc8b85c4c2bf461cd6c306a634ea49878f2d709c1543004eb2caeeb2474e8ecb43f6a5e9de0d8f16982b3229b39ff7139ccedd1aa85ddd8dcc162d97e61fa3a5dc397fbd4041186c4e2e1c34e6411b07ce4009300fe13c3847a493fe86b3bebd4ac1bb5c7c4ddf6baf42e26b574ec8cb0d0665d72b7c4d82572e261f6069749690eae55e958a36d2381962d18ce2808865ebf78b5bc01543b420c2b8bb5a7c00f586656184cc5c42ea0a4fbad59cb9d3c8d1da22ea3d32682936c259a081c5faaff8aee6cbd95375a9ce2837e7c3a01bd2219a54e37f4231bd3fa8c8fa3f4c5ab646091b42607b580ec2b62d826209d924cd605d5e3075c6914c6658c69eef7f7c78d03aaa3d02c5cd17fd5c0fc7280371ee216babfda8960eb8b1e7f00456011b353c244e81e578534200cbfb075d64ef2b02ec9d18b4c231284ad673e9ed873d788e362eab933cea1ffe52b9254307c6aebe23fb1738a7bc0ce2aa8467859fd153fdb1a42302bdae84e09dc87485ac532fea6841666814a227cf8f7a01d54978a370235c9dc15d23eafa37e9595095a0da7bc1683d919830b80090911d4f84bbb8ba06262f6f0f136d2759b20da6bf17f4c8ddb1eb5fc3d250ffc9c194530a10f02a0c6d04560c914e86a174494b913fe4bb825588d046716c8476263b5cdbc1745e0acbe6f56b02dc64d1c6aa0cc9dee7d1345e7a629d1b03601752d2a1ef75ea955cb9716b7959fc441efda9ad06645e454ad3c451261b30d6158933e24b3d76a1ae35a5dace8ba67e414746891848db89f7beabe814f2a33f52a055438cfd4a88d7ce94cefd5a709cf21ebb2a8cd9ef8d820b11ad1daaf89d3b8e5cb19516e78c032a3c6f5ff3ac438e046804ac61e37863449f6d36d2452a7afe0f4d4185ad3ff06089d64d6f5876db0ef78609fcf0c23b915db7a6f4f8244961d79f4b325cd069b3ea947008909f11e57dd107124cbb974d7f6139ca3f93f8db4be90e31a1dd0f8858fe2102ebafb509ae05c65fa559151c1823a4fb8941633e24abdc0ce60f38e3bc50524c1f5b64aef0507553729b9cabedbb6d2eae173f95235d1d7c22a8588a11ac09f36948fe56d753854a977bef396aa89c77ce2162a0911199b6345d48ce249a2ffb0e1cdd2337a8197000b05168230d0a3b6566cba5ed61c9dc63b66f0fe6cbd1441948e83057b6640f21ef6fd3053fc2f015fc5abac90c88ecdc010d8dea44a2df08dc700a76853cc74fa344b6518a7db4d8e796d9aa456627278363eace63650faf15ec83ca8b23757646dbac1ec20f3e2eb3b1a6c0ff2a0909320f451bf21227aca1aca62dd85f1e0637a6d05b0e1cdd43b423446aa942f3d039e3e777d0350c84e7541ca97d08c16ad17db5209100b80353befb3680cc0b886c6258d2e13efbe55d69e96149735521bb0aaabeb5a27f27abc4c4e221d10d22b5c148749a044cd7fafd68ef7623d891a9cc5b60defcf83701f678298d697234d6d295f6f11a8a411cddf219d0d0bd1b7d612fe107febf2f35b68eaee914196f87302ff5ffd8399c69592bb89a3785d7c9dc5db69a7732dd39701f0d844373b852e25e11f693dce3c060c98693cd178494b78462aaef8e35b17b50b3acf71ac4064b95741280e480b591afb02c2392d12e6f93d31b11d52242c90c294a91a096945c635966600aede3462ef647d212755d7d340f78a6a51871ba5d1c185933973a99a14ecc6759f545a8f42674b402f7a72b8cc05ecd4084f7da76441524471941e26bf9a3d69912f744f79470bee697568a5223ab343aa9e16ff5ff77cf6712ed35594c4373f17b815aa7ff02b1396a07e16386c9a48229382c11031428aa9e77d9492798adfd6fa2809c750eb50cc3fdf670ab969c48b2c1518eab5e0cc027dc13fe4b6ae1f527f99a7300c0ff578c47a179ecfdf97eeff47453994f2cab9842e6da2514c710ccf5fb95af73a84145b8f8ccc43224bb977ad186446817d523572b9d7275bf4d1a3cf8f97937557692f9a5c719164b81389eae1ea1774f568c86e98a26bd36a9903f27c66e5c7651c83b3e4ce2c4455e594f1a0959ea5d28af05422ef5e4c970f2e53ccb689cea80f9233586621f0488a25694ddc799171d86aeb7c86686e9186b07ad680b15f177c9e1679f40b40a3c4c47b8bb3e060636f4ebd2bd4deb33ffa184c797ab557aae55b22f00fd82b78a0f9a8253d811c33c7beb24ed83d4c68a04f3aa683a7b259e6b6e316b0d5714668a78e933e83e44166e9d3bf1a4ca68668ba319bdb6d0c85802548efdf459a836441bbd75d790b1d0432a11c0f6df3d08596f9268f45e7163cd12dc672a73c9c2c98f1ccf34283fbf2f4204fe45a67cde8505721b657b129664b7a72b571857d44853a62b11135eca9e0122d6ea479c86440ef3ee965f6ef92988877abb6cc525c69e4069190a5e29cc0c08c79b00fe022a9bfe3c3525b86fb3bd16772e413c5a8728002ed8e4d6bc444f05e8748f20d201fbebd555c729b51c3a6071e36e0f49d5249261c65337c36f971f250b36585303546974437ea83d287ee89d74dd0aff8432994f229807ff752bcb4cb26c5a53b1ded97d643c12f868f5b0566d9ccd745593e1876f04c691380c3ac13032124940216bf09b4b1e40ed84285870f82cceb5d5da2d123067463c2b41b63a1ecc7527a8bc8b3493b6c39d04afab27feaa13f55f7eea150f82e0900bcba9481d785637c3b2c151872f4d1343e9dc037775ce601b75b46b63f89f1f0af1e1d2e03fb5d2bcc71a47e6105f63e7ef6f8f655fd9aaa1924d69c169f2170e4a645611e693bb2a94ae96d3f26205853fa60abdf72b9ad15c01b88e1093f4b8e586671761813115e6162aa7540b0bf9c0948c8f75d4c448e55781cca046f28d9a91c6457c021d835d44761957434a560899eaca0980628b74eec0b2766000bd94865eb0852c5dde43afd32a8dcb8eeebd5fab26b8d6fd2b9312bdf9e4e72de0e2af4c56ad100f6585cac7b6ef1034572a2b9b8060514b8c322b4e233ec2a73e3e2c888953806414fb182f28a0cde7798c79be7df084e055a933d475aa6f272445afa1bf4e463593575d30d29d1bdfae43a52ce35cc28ec4c51d5bcf26ed24af3d066efcd31959f1d82143ba07255add53a12beeef57cb8550c73b561659eb395044c8f50130a004aa471442dca7fb4c552478fc1341aabddd6775d4e68770b710d11158eab84e5d207629f1548dde273001469738e7263a606f27e22236214ea19c43ea76c10a934b852555ac755bb8a996481fbb3a77a4d9df71315777549db5d07e0cf0cdb23123921dcbe3c29ae0490ad5b28842702e70fac841a03b1caaa16936c1f6ce9702c6e181551e352b58f8f228f840f9571a5988fa4ecf23ab49234192496c06d89a971c72dfd3115b6cda9545f43f670e6c8ce74651adfa1ba0835e13eb7029f9ba987b7774e08333f25d31454d0fb1f619ee01a46862960dc886a531e0c0888c3d279dacb1797ae21f808d32c82e844fc15a6992464fa6352b1b38437a61a8bf04025fe21c6b82b5732ffc1125cb07384a4d0a78b569f9152e27f70ad306763c4ad639a77cb458d976ae38acc8b5fbafebb88f4ae007f53d563a158c615de07aab05b2ac1f3fe1455ee5577a35bdeff92155835dd4db33764cdeb87cc7973ed8d76e9ebe1ecef815196fe0402ea056a3f1ccce4ac63214a5f9d17c5c7ca39c06047e96d7f31b1a74aed7a6417cf4624c650c3599dee38ef7025442ab5abbdb6dc2ea778b933633de7ba05739a86e8188cb14ca0885b2faddd738395a588ab18bd890598624370994587ebc4579b1710d8300fb3d6374f3599acc0b2f2878a995c832eb810593f25069680de03daa1bb3cba3ad06f0cc8911ff0f041c4ff3a3ad9331f574afb98a32930cdb29eabaf1715c0946c6b9bd2b334abe2d62a8165dd4d1c3f6253553515c4de4dcced94376c710f635d750d51d104647663c042dac5b2ee29d4cd8a169d0739c34af928885917b559b085316440096c80ea9c9f74c898f6053eac117b514ed8f386e35593ed3dfdc85f21e18215977332856c28c8f7fd98b6acda642f2b1070e9b4b5022ab45cd8167b7d3ad55801ec05e6a4e67c8387a75944d8e87a62f240eb0d53f3ca86a982ef90df978af24e2a3c182608d19c7876505b113eec765eec44ac72a5bcfc52deb3cac815248b4e1f4e03c2dca5a80921e11e94e980f5a39a49e867378d853b587ff07493a8a89d15777849bf62dd97db52e9f56a7cfe821cad39ddae78dd0b98760cea08b7f7c4e0c23addf02bd7ebecff602c210b2110bd7a22607d36ef72ac7c2f78782ff4152d4b4087fff0f6fcc29bb90c66a1163c6d4d105e654367e5fc3b7cb51601dc4495cce9b39388dc6c020825792ab6ace34a819242302ea9ceda7a03974d5cdec3424f3d9890a5da2604a6a6cfdbbd1c5c8552790ba982a5e7364e2071b4601234bcf64538af406e585f973e21894e500d7d324f3dc69b0f5fa4a0b77b37bda3e5c5b30af6459978d0fdf45ff1c4d5d04a7ee2c577ee917782450f18af2b1ee7281db3bf66cbf2fccf6d49e87cf893b2f2a1768c16e171cd28161fba55dba11d05ddfb5ff8dae5d1fda96ff9c2864f3059a65e2a950c6f5c58dfddf0eaa1ef9212d712647f890e0b4021341f31a9a30c957ad1f914379869eb87a14d20327d0152456c7379f945bb44ec267bde0d4b91de43fc7fb67e6652e29daa348247c39b1f835166300fb52f8915152e0d763ea1364e5add6fd4080830f87eb012d89f217b6056c85ed0a53ccc68fe9db2a3a5d7bcbcb7462e027804477e1a0e141d0422a59087a3d9861f76daff9651b7ce3b7065a16d1f13493f921b054d3813dd3b87804bf1e5740d4b925089f0853f835593ccc60482e2ac6d5a3b19dffd75ea8b3c92f91555f6272ba47a746f30900c7e0d5587c321045988834058d01b8dd73beccfaf544a191113d5cc85352d1c595d7efb344a7b157572bc2743dccb432ca782d94d75b64b30997391de2e626277670884dc6f6f4982a2ec772fa347882c223ef8149b1f8c51d8ed070b531077ea76e554a2ff2c2ad36ec85066bb779698c3987163cd489474633940323e14ce7cbb0c52cdf37ce726d3cb7e3d35c7f8782d0677b0adda14a10b6fce699a2e1bb4c833180eba2ecec741373080ae0f6d117f9e79c78d78158a6146449e5bbdb4c554538dc0bca2e0b42d3c4aada07ad58ba1c6c881ba94a17a72cfaa360cacde74466eab43c08069fdc6ef7f914ceba8e6ebc271172f49a78e80609bce981b36bb9cdf8ec73a535f49825a1ae3f00425ede7df472a0a56b37545af2e647838c9fbb6774b7ffe8a300d87d427b1a33cce96a6dc7f276930ab3f57bc134faa6cd122c54dc2241bac1173f442682ddfbcd6d343cc047b0b1f0ce0d8695bb15c5b4e1c61ba35eec018fae9c3778d565e272bbfe92def7526c43782cb431fb74a67fe579b3674a77345d244a211ad6ef2ccdd62fa96e301c085ea3d6e150f9c83492c190d1ec3e6231f52323ae102a1449afc92274e2125d5f48ddbd9e696f013d119abf0cfedfc93fda45e9fac485e5158c1b1e93107ce566ccec31497ab7ec06a375e93337a6a2d2a7709f63564ed2bc646ccfade97667e0dce2bb103668bdbe91bba8ce743da26e800e2e102b55a2ede4f959a7e40c33a6b47fd27f374843447aa7a76fbb56408691444b11ac0aa34b7184fa5d9f561b60aca0776f605f3a1b90b1b2768082a5167f586408bc8c50d71e12a9af3cca51f90e5144805691c10709d7c5bfec8abd05a11aa25a3aac9a0a988bf6d107309564eeb65c4038d71e32a02d5facf1deae5313fbc7adf6c052f64dac80a480c0934ea284dbbd33e885d0b2b9354dc7b667eaa2729cdc2579dd46d1a06d7a1388733ccef5646ff9b17a64cf375d31c0db4337c38419eb6d976cab457f5a5fe72baeece6466fb92f1ccb33fbe4b37f049cdf2fb528db60413585f350fb303eaa27b92f025a4a7dc888beb7e334892c07389b629e4ff9094ba1e57d329078a9a4b383ced919d01863a3a7e186b49c8295dd7f6e606d6aaad21cdd87f4d9cf5fcaae6d3c7286418d7efae25e1c034744b1b893e76639012a85e2af4d34e470d72ca9167aa4cd011688728e34fbac8aaae069c0ef60414601e4e69fc6cc619ad4c799fb009d3092e6c87e7f6f217c56b7c0b718463c6747eaa20e6ddc05b3401f8c05a70d942360cd3dce2d6c028e7d78b7f3f1762cb797c4967698220b854bc810e43c16e87dc77febf955c63e20049f68b47d5a611849d157ab13ff3715fba9f6d0977d834f6ae0326e5328b2a8b11312aff6dbe957defcb12c7da0c2ff968f855c1428fbcf34290bfd89f035fc7553d474fc369a55f4b8f383b0b1607192667d5892f669d3e392c768656ac16f3e534d42ce2ae5383d6c8e63e0c3175d69ed9462184444dd67d94d9a1d9dbeefa83c0faf8e7b84b133af102de2717f5cb8a5e905eabf6691ec14a43ed40e7779aff7f911f85d7e69a90442b2072f0a48fc4d2e60ee040c1477bfd0f45dbcc07f9708f3d3c26698fc2aebaba6e3945815a416494df4e3a1a59017ae19b1b18ccaab9d58cfe399de074f5ac6c4fb91bcc569a50ca912e755630d116c27557071ad74ee34cda4e73476358658b77e11c28d2bc7df19a86d1def8f2252c6e740ba8ca10e0dfe2e67241aa48f813e8e8bbef61c58081847ec28f51357c77a774a627e729178df11c01cd595f093b07440dd18e8134abb85fee34151de2add3969b07f44247ffecb9595192c68c8ec623f7d423559e89de1a9564603596f5cd95463869ff3f6fe4a8173f70f800b071b3d2eaa5d4fff18543a724dc631432fa07255e9a24bef5067fd0bcff0190648e55fde0ea545c4dcdde457d06175c6970d3694e529cb83f44f3a31089a4ccb57207af82c7ce377c461f3d071415278c0ad4940126476dc2de418725f65eefe82774900f4cf05b264f0765e2c166f560df9762fdafbd900e94f1e150c6f89f98b1f3c321a0165df716780d46035b81844cf1f1305f1aa29843b51a7acdf972dda60a5691c8d71107b4c5185974605954c3aa06c1bde2388bebf559493f115ea9d627d245e97dab3a27ce4e44bbca2a7fe4f52f6383607cac31de4be398b1bb8ef42341c3b5f11780f526024e82efe4bb472ffe7b0deb7bc96afe11fb76068125697e772b8aba997fb9b55aa5629330f05b40e6057ad95be9c70b640881849f3baa6f98df68c6bde3a6d6e120ffb58b4e3f223f563f05b4287518ab23e7c0691b53b4df0c575ae3f5f3efe663af190057b848f7e239b49bff43f9121e44d24737a2ede7eb3f0fd39d933180509e97fe28bf066ab197081c06bc510273009e67915d36a9a738dfbe199d13771c7d7fe0ff25729a302722965bdc20a4490b4868073efe4ef6bd772148f3a5ebef04b45634b32bd4c47a225f93167e336aa5ba51ad35c2ddf746a723ebae67565bcc6e94af24bdce6ce496b4247e204ae340613490c39991be4a35be0a1a7f951fe99443417c7a1cc04bdce4843aeff89c50443a624127528fc4666f7995679e488235d4420d07c0074631891a39e7edc66a26174020f7db8e5232dc73aaa77bec2e2030c5d6bdf95adffe69a7331f145ad4309106c56691e44009c63cdfaa8f01fe55a46513d24e25523bf7db3b6e2dabb70f9f70436a28ea69776663d1f41babc73e622c8a02147b3c2bbcd8dbc3fb5aaec6557c0ca49537bd28c180ba243dae454f2b85145739b9dea84346525f17fa57ae261947ccc96da997a538102a18e620bc33626e02d3e3fd28c28dffb7baab97335dbc941f6a6f7d592bf89b56b310cde5acc4f691b083b28d82bec98dc1ee35b3e301f69a6f2b287499a102cfcac2e769bf2320c06f548547248c615feaaaa12ab7f7c2f452caa423a1c2ea19d585ef35b2a0d35d4480606daa016f7915cd0cec263a5d0274dad652f96fd2edec8fc25793b521f88a14b3af8c10b788be287e214fe7546955eadcf8283a8083120b2907004bb970b07197b245a1b91269959e3894add4fc8ba94912fb4339a86afd7b0da3cdaa5ccd55e351bc4d74c8e30bdfe55cf17ffe07049317a9e54ae01fa8741840fae4e25205d0f5debcf26d459560eb7dd908216fa6849f2bfe5f38d9b9d1c92e0a0095f868a1cf57bf33212d9650efe178048f2989508845212897bfbb4ab46f9aaf030b3079a33bdedb4d4277eee7ec7f60918717c45c7e324b5626d1ce9706d199c2e8e6c9d1eb52b7b931b0e0baba16c7d569ffbbfe2c0925116b467e295d9df995b88ef7b4456859b1afd23c5c566cb69d2d1007c1d1453464651d26a3d952f27a0766ba02c644dccd34f9647bc585b8c6956fd88ac3e94eeff133bf181ada0b1482af5c6a2ee70314fce632c52f172e5fec9aaa42158076f9876c6a3695a2d493c00614d4fb45d390131fb1f7c38a53a01f487bb4fbaee3d5f55a8e83e6a33f91f50671cb961a056f3db946679c0b795517d6ddcb28ef5b5160751b59f0534f884a294e598ff0a163ef7188f7382921f749c1ab177871844360cd6772be61bd1728978847aaee7949ecea8eb8836d94fe5511b896b8242bbdc0e2c46c525df595d024e9c81d43bb5bd8b9258f07fa05f7e8116bd7c28b5bb60bf57fca57392f354a114b0ea32381fa6dec2bdd5c1f13e81371a2032eda00a7d26699646089bbd6840c33b8f27863fcb8f6847834590e835fb7bd52dabcc22b9b37e5e97b002825f18b1699a99543c1210eb3ab3878c5f8124c52004a70367cc48596ae4f3f0b4e8ba85a50635b3a40cab0a918e3d8ec92708e3912fa68d27d98a2b093336fa3ff11c830734f88226ee3fabcb21fff8d179f2eb5d795284bcf0a0f9dbc1a7ee77e5b3a789b34af17c89618b49df45e18024bb77ec464e5a672b151dc6e2387a2ca08661ada1bf899e0cbef085cfdd57bdc959d6f1bd582afbb5954b5ee5cae5168b2339a4a4a3555091c76592352205f2c41eb570206702ea941913abe2f6a1bc99128f2d386b3ae0d1372b87c94ff9f592348b834a66f6b8ec88b6c3f9ed8a10466562d13b8c995a7ca468aba21d33c78ef60df22a3eaea5adf82355a00495720d2176bb46ee631e1e16d3d7ad4bbd20f95b81cfd0dcef2ef2c610402be293f648f5d069c93aa5bf7151ec6d23e8813e01cd79ef31e345ba6605f033b7c293fbff150b19ff3562653df0f84cb4d9f745d2a368f24f9b9dcac5eb8d709b8968649b8b336bbe5cef29dae9016384c664484eaae8d1da39704a1cc8384f0280","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
