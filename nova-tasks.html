<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ad73d465ddf6968c72b42d4872ae2934428ce5cf3c587ca3322dbbd04803453c2a47f4995cc3065d25dcfe8ebeb3eab2ded1be00bd7571c1c276a527eefc1bdd4edf481276cae456198ee9cd800d8437ac0d8212a1fd42407bc080a6f78968f706a2195f26b7d43db116f9a764d858a6df19863e940f238d93adfc89f8c79ccee3e05186f9d91816df7fcfdf012f75985556299de1b85398abe850e1e1c1099469ef85294e1da6b64a4cf053eb0e48c8c392a34d57de13727a03464255976f78fbb3d659f3645bbc7274cfde46f9e51893e29d6ab46db92f360c136bcdacef1665fd9820a78e7456ae58adb5f9fb7746dd221c94e85c4dc02426608b09beaf2b21d1016fc2995f6772bc9e1c7df2e2a47dc6ac56c5c2494f5f9556b13d4128061ea2bffad4966e84c2cb3b1a68d894783aa2d47ea342fd8df72cab176b34a21cb70d3cfc48e45c27639deb8f02bc0ebfa4ace52a0311dec41995387afac00659b609e773c1cef9e7786d4c22abff74ad62b7c8325474296022aa088f903f35bc6e54f3a52055643b7d587955f1fbbfe7bfdd957de18ba4f7b7164e1805a79bdbd3207b3f3627ed30ca5d974c88c32f1ee4ef6e46dba625593170e6adffddbaa8664fd95f8869bf45400a4ca913495c1dc3bdc27732e58839a9b48431045908ff527954cd3d182e0db1b5a1bc8383a3a8640d555e5d33040a608d3df1275d4951b2083d096e129538bc0a6a87983fccd5372bd791ff57168585d2f7c46061fa86c92370ce37f3f3b87f20304e67c496dc6101a5fa49a829ef5d1137cc1fe3c2cc161fb505f1ad7bd7dbe72def266b1169edf474ff44393b3f987824297cebd6ffb202f212b558d7424187d78dbc5e0c116732baa85dbab6f837bd929ffbb775ae01bfc1763cefc748a276ed610c2389995d9077ea4d3689db6635e67548ff04d6a296e51fc3d406050740a55639c3412227fe2b987bbbeb45777502e27f9d09593d3fae31fe4204d9e78527627135c0ce770c795935b2d16fe751f38959ef6f699a580e5789ff82371e76dea2b3258fb33dd3ff31013111143992e98309137dd3cccbf9e4f09397eaddb835bbc6d6be84a22536dfa9e9e5e4cc6af30acbd48c0298b47a6b8ecac45b10fc087bb6a076afc5c998e42a47cef481fcf6900a53dd58292b144458f4623c2916ae3e12b2909534cd8a7f6d1b62703b7d9b52cc23f0e17860a44c16e6843bd0db6097033e54d0cbe32a0546b7b52f0af3fec1c94dc79778f3cd0d7de350f2400ef133d84913b1cd97b2179b6492bad40ce6cfd74be7a47234c90144a9394ecc260a62745358c48c784a8657902a7c674d87207fa9e093af5c8069955f2447eac75079d87560153ff639fb178f7da8d094b16f1d2edc18b9e176fc1067870c564daf1d54adaa9614693c4dfcc2c9292cf23f4fbc22f47dd6d507cbdabf2c2a04008f95216003e6377664b2349c39d6f04a092dfe69efca3c42ad6682fa3aea016155aa95f5efd0b430b0cb4e7b218c4e3e2e10a92c73d2b7ba2edceda5a780511f002e56f4a346d349983a29a0407ba198a5b8c786b3930d7465abffcebc9c12cfe293d695988bda3b24d4c5715739369384b6595299be8fa4e33d53fb848d1dc1023e86a9e60b17805d12dc6e6ca2182a9136c389c45222e74eb30d9ee10878a448136040f11759efb016ff7318828fbe62c1587bab8dad8654db9b8a292fb3849c57cbec843fe6b3a5af149d60202ae1f307e11eb492381c5977a04da32d31d8c0b0fd8844cf94390e8e0af55cfdd69943cc82235e5a656f3059b8fc23ab8f3d486466f2f62dc2eb0575c7e51f9f533ae7ca1f82e5bdc03260543b7e4fc8dc048915bce81294cd77231c2bd5f4b8603e8450a357a28c1d4e6368c3c9615051415502a429fb2c4a49edaa1abac9dd998f97eecafbe176ce07c2e45aa27f89c6629922ed1fd1e437af458c6b3237f2eb5583f0c03b4002df4859ebdc86d4b6ff4fa8643e10f6d00f10859b962b96de1f443cb261a235dc25b464f4b470d942706f409b30eb02891f0f2bf37af030bcf31ca3e0e059cceec5b4e9d80388517ab91b895f65a2e3b69771e6cd61a26448a95e969bb0d1a39eb3530ad70d2e996e14f597b1e2711cd70f9d0a406d87454e0a4a357611811a0eab6f696e3fb4c644c45a7042d3405e3fa3c4153a25d443b7a66077a00d593736c348f97935b1b82066f7a74d70a52ff9bd59e3a3bc05f95a86fcfb32882ca2ff55695d35b70bc1b162f4ee2076251f18cfb007ff0ba2fe34e5e020defae984afbae1689f7d2784308d09863e14f0f169b43f20b8b793a1dc0085020841d20110ffe5f2627954c9ba5c9ca74cc757c115fad7ae7d83a5c43bf2962a16a78ebc47d2aa1a3331d486c4d9cccbeed6e82a79b02a8115b3764106d1bf873f43aca601c5babcb846397294820c276daab0c73a4d108cbfacbc7de7f43b164a557437986553300c24a98cad9cb2f9050d8203f2caa11dd50a69f8b65a5ba422874e5348860aec94d6d0c668c96c5f6c0fd2b479dceef2a197544b1d20ef192d026f8db41033ae83ac3ee7309156c98e15854a852cdc21d3ce9136eb052bdc5cd3d57d5a4f1b58358d27e6308ef4f684bb68926cb2551fbc7b7c6d5137ed421a23d422dbe1b0c153116dd4a8c56d3d33b96b1c14fd47182da212cf01c4f7a42bb02970f6f82632c72e036e3edcfad1a28206cb4d8fbe51431d714767187ba0daced62171b5abee69e74678b70ef2cc5666db03c9813a32aec9ece8929d0d60a2f2de5838f6432fe0700a3861d97648aa5e242636686324aad3bdbc0749e3e7961059d0fa9037d791ef351fc45a2e29fc27dcbcdcb001741c1fc73f76e145da0075aa8760b0cea4102d40e50ef6632124e637a3f8db6708ab13221029fedb938e91b912940da36b8d76353786412ba9f13d56a8dce87ef31345562684b5ae780687530237563b334d439c28b7e236c85ae6952fb6a99aa352d4f703292c16398c7c6e78bf714ce237e0a7dedd01d5a8fd0ebaf2da5a7f23f8347f27da78e77a4b6d055ffe99b9cc26fcbaa45836fa712f82b75d8bcd5a70ef5bf33f2ac072441b4e626b758215c3b215bc6d1075fd252cf5cc1d24f25ab9437233cdd8414b9daf02efeefd939444f319cf7c877631d60f8336d4b91a5695138c63d3a04ea34975ae363d042acf889682dbaa7673cee492a3015fda68ed57131f6aa469262e7464bc4aeaa9f081c63a9c30774819e592984bee41e05266c178131a94ea47367221c327d343c49a60fe9e7f63c344c388d5a17dd264a14ccad8f6f73d7df93bcfe85cbc52052c5b864e095e9e967068ea49926788ee6ed8e93e7d3c6d8f3d802cf593767b00510e635f632f439084c116c03d8103bce45f9cb3fe0e123dd29dfd7a9da84c9e596b4d3bfd51ec8ccf5fbc7efd9181e69a329fda2df15e1bcb4c1697df7ee311d8e7677d9105ab75fe0d7ba1e2525340e89915ebc0f7f991bf96920a83fab4eefbcbb06d090ebc51d4b27973ec2dff41f23edabe1b747fc43cb15985f33b58c95d4a30e806adb25e2969232360cceb5b46011905c95cd4e30791b0f8176a5f8058802d81d744a8b7007e10735117688fd87b9b36ff69c114d61487808f13406612fb1697467ccc2d3cf4449fe1e33000651bfe3b292d9415b015885138ca01cff7f2dad33f8bb79ee15f0af2e88b14e2c41335111fd0797559f24ced644d0b6df2a8b522124a0a3827e30772b46c25c2d2d54fea80c9992af3b3d305df8c1ee1e802bd33ccd4e7a8f441dab1ff136101cf52d76f3556d595f4dce7ba3331886818eb063eac14982006ce455a32377ce49ef15dca07a311ce6b73f12dda05108d01842599fc3487bdfa03fc17ff0aeb0b0799861467e8c2c1629f165189e58ccd4ee7e3239280a0c0bd5a7d2d9f8806e6e4fa62957c4c6db12ffcb1f7a77088ed067c341b2bd1b74514a696d5be3bff7e4bcd05d4f883d5cbaf19e0d77354d84554f6b7a54d752e6df805861dc03097dc3ee105227373f10e6f1e2fbc46fb3f4ad280645a5337416a29a6961522a366438bf0cb15f370a58b800b2ab3f9664a90f00a69bf960139cc4306290f5eba14a907cf30d7bab865e1c3b21fcb447cdeceba467e482c9dd593691691127325797974e7048196bee2535b7eae9c7632bbea1d33a9aea11f808ebae5752c95348cb1e9eb264f8c5cee3904e303dd89377365e51c09aa08f7c1b71f48a78b5e68d1f349d7455c0b420aae93a5e89cf4a7dc4286a2e672e45415483faaa5497fe764cde9ce33120dd58ced2a972e97ab41b691346b37e5b09d7ff6dc1f7d5928e5ab61055262b3301917ec90dc7c20c4bf1a59a51cb823273a033d323f7a9e6ed24e54bd873c33542fbd79f56dfe2b0f66c37428ffca5817e9bb987b7c408e81f6abc5db5016b3b4675aa1f01ce2f36a6193b53de60329116d58e10da065189fb1af01fc7a613201fc0abd3ae4c6a2483bb492bfb9e865cf93d75e5968b3c05dd1242cb6f0d0f7a23b1e92bf94eb2eecc2a30f48b74a07e106bbdde03e89aaea733bf2c714c95694a237eec67167e44e5c48f0cfe86c2a0d9a85784e5d2d9bb573477e3e3b141c617cb27181704208c5f3b92a916bf0e1f2e1387d433cadae47e587c2e921dd83d6559c863d9664892f7ad751b7f3774825b220a4e2fd0f3a80ba8e6f6a2842a05a698aed7071334c96727a796bd3f649a6ac4686e55fd5215372612ee091cfb4e2415eb8b1489916b9ab6a23c0e5b2d542c6247fe76b32641fe4836fd20a2b5203362923b6893ccafc0aead29e5b1cc9dfb96e811b6cc394bacebb79689f91c93f2ec84f6217fe0755fd0ce69d5669ed3b1181a279f7d0e693a98df030f03957e5a2e8be3880a20f7867853b8cbb74006121000dfef66fd360334f08d1b7a7d6394cd8fb488160a6d92a9e879cae0afd413bcfae8da5bea4aa0ec28468734322165846893dc53605a19abce7874bd5668c6434baf7675262d4cb90e17eaeea1662b14a483f87894f40e3014b6141c4b2a62f3c6c2c6e2cec10c8d7176fc66285db4520169c813f65d2bf77e8f146e06c5bf45d51705bb0e49777f2442e042792e32799e7a4b02ccc9f9fee6408d4c070bf1b0be0e36547201d7de3b485e06e392f856b5c1f0eeda22ad5da4cc917d8842c845c954425827e53549cc757b763634e3015758e4d9dd1f349e0ab64deb3f0d0efb6122cbc7fe457e11681519c48cf032574b3c1e4d2630cd148174193a5f42c3e7ec20aa0e4c241e074606d80611dc28747d0c995fb148e8bc32e744a6647dd3efb4dbb06a031587df12da4dc03f62bad53ccda54b44abc55da9d2b5beb6675c3ff709e07f3eed7faec7ed5757368685c567acba32f69cbba6ed1f802c293347794158c10c65ea3b7c3882646b7a61fa70c52504ad66b94f92bbccef3104ab81bb5510b2f846523bd9426de228773551d03d6e5bfa96eb6eef0517f3378fa9ed95f5bb720d43ec05e7db65c2b4976227b470d81216db57fabe325243329adeca142dd4b5d48104e94305b6403003db7d80c7ef600ac6cc7d65703022f06b8f7eadd5eb1723f97dbc5e7fc65f5260d2238f2ccbdf60034344cad95cfb59528e4f19001224f18b877052570776178218045985b34dcf7425ce2cb6dd8978ede8c63cb0baacb23445fd4600f7fed6d262e164980a287e6fe273c36dd408b1768f8f74455b826989c026f038eeab69b31df280795ef99390f544a6d67207f2e4c9d39a59ebe55f6846fb0569ba97f6b3abeb898a184a97f9619150e919d7e4e54e618c41ecf84eed1ffd25b47feec4426d9677a99885c69f7f340cdb51291d6eabddbea879404ca3105fe137b30ae380b3b960c12211fcdaa2b8950f0e719bf7e8f3bea5d7b3c8e03b9f32e14449cc5fca9a4da42270f8ff909b409de980a1fc5a8b3746fac637d0c8c7862059bf496730313ed4a706e09ded14072b5831d9ce684320b1f6cbca04325cc40bb7e97719d56a78978441bde47a9b40d508b72b5629a4e2d7413a851b2934a3bc283e3c93c9c42335c02cf189047f510ace712aed85e77e30ddc9c5fae38b64a4fcbeb3e7f1239662aaadaaa979b798c47261e46f547d534e159c23c585deae9cf37ba34efa1bd156c574cb012795d1ecaa37806d007a68d6ff681ab14bcac9c9ea88f609fbf5f6b2616cd60bf165147ca736e79c6a363943a03d4abfef11029ced5176f4907c3b4b8cf32e53cc73a9e76378fef91fd4a92ee9e90ed82e4dcffe28094172b8dc4963d0dc6210ee0a2287088751fa396e290ed893a8f5d78e8c3e9ab39e5a609c98155e44dad374472d99abdbe5f95638454002eeb3a55b538c7c65ef4bf40cff428f3dd705c858ada5329dc1f5316f1494d87a019cb99a1158891e1ef315749bc8b421f33e6d15b1615f9c3422cd2eb84201e9dd2169ca3f7ed98608492693be52ed53bd0b1c925e266da9c308fb06a2574e0f551d7a9e3447e754f7da08620d23357f459de9c2ce6b63bbcd0f61c34be5918cb9729065c7b8f060b57c4f8fb2aec463a24d3fa38694d5532b3b3ebbe1679b619fde35511eb19096ea1562087e1328c0d3b8c0a67011c63c495cd9eac0e1c74e603317a02bd08e8f948af4a3427d91fb90eaa91838400e45c7906cef3237b0977886669ae342ae440313fbb7617c107d13f3513c635efce7182c39f2a9ac5af666a7760a2dbd7f0dc96f4a5afd193fb980e4a66250132c14500fe100c73de5afbeb1c76620559b4a0d7091afa49619488f53961c6a949c3249be00e3016d7667ad294746335bb0dc54be79398d1784476a226e9027397cb05aaf6ace31a84e9d238060ff1de82d78f1235ba792779dfc096ceb0ecb33165e9590160afdfff771aac4d20acc7ff3a14dd09e7ecae742a7455d1c78059bff9fdff23b925587f0e3a3c6d384cb73dd49581ed8ca8004ff3405570e8f166d80a174eac4205e3655c60a90b9bae0c51fbb85c49cdc71173f0559fb61688991fcd3450d8695736d5838e64ccfd7fd1d40d344f1bf4a672947f9a3215cd7176f793e3fc2a9dc14fe9c19606b5d4d3805eef7ca92783d9e151186e9c518df4435fbb5830756354f76e43cb29f5a19c1d6e408d946552890733220a9b2c3412ddaa0cd6e07dc58009030ac3d8df9ce2ed2c237f28f2d99a6742fc5c23c9d79523ac9105f867e06c5a5b7a70a04185743292d7a67ff3fc3c8224faf5de90a080c69dce04e5f9cb151355831556543186243759289d6521cfbce75fa2beb5567d6cc754300dd105a6544f2a9cec56ba3d5024d4868e95cf98f2abc7d248b889ec246c920482c5746181900b6081973521d013b8344a51214a6603a0b81a16945dd6e879ee719c554c5f8870de1a315f3e79f1de7ce46b15c189295f784f48d8aab5333ccfe373bddb7897ad7abd6d74902098d00cb8b1e5b895f76faecdce915936fd7fb99b69a6460d5194f9b7cce87302f34d7908c5cf81a0b5e57ae42e535bf314a9e15c579cb1260cd37c11819c015c5b533862e004224477ec4f3dde05bef09ec5fac270fa3c36f9458f68ef95b2774e62f85cbd5540718148cce17be319280d08d2702a0c32b1abfd044a21ed17b56e227f41b4de5a12e7d8bd7f3df4844fb2a744febe36e442a5e4a3189777d2817f048a5f549305eb3a0071c728d4094aa090b108d5a09d2a27c560b47cad697fb3cb9f91974af443d16d3798de81a43be9cf90230fab9b56b53e43d70d8185689531ae34518a438e6eef959645dc8469f8136bd452c31612e7325322eef7889828eb70d8395dfa377ab7a748c31d2775506e7920cffb1c048eddbce3ca84e5a25b8813fa1340c895d9fdc41ebe7360c5c804af88568ad3e0e728fed64849d3886b3d48b6598422a9c13488eab12863ce5b7f7fbea33efb278c04ec4ec04b984af242e674674221c70532be8f3f1acf81faf77a8e117605f55551794a0f37b4fb23940ef4eed5927a1c3d41f47b589c7f35642d9c6eaea685b254775819c58212b3e8c0a23d41ad46b8b6f598ea4a5720651b5e81da5aed339b9fd6d515be1ff7c4682b3020bda36a7d0554721b52cb156642b50c10d30294d5653d2ace19270506d91f3827f966b446f51b1ee27f815caa705109cd9b13c0151484ef2eef3bef6d4bed9580fadbdbb9f8f7f1ffb3e82d95a6f2687dd1dd6738e3de82a1b1e3b8326097f49044efb9ea89015448c2e5c4c9d2c691805a1602130ded1585a4a155470d07c107a071a448fb4303677168f5ce1f488d6c3b2c9397e0cf386ed86ba74cbdbb209bfe7fec07366e8b275f50a4f9e2dc4152198601696fcca615c993ede8bcba330defe4f7f088b62a35a271b1f97e5115248f4c8035dd41843bee9d892719366c32458158fd32fb77662be319f6da2520539e6ec9e8f8c990ec1d326c955aeadc48d7f8dcb760786f58db6ef76b4bc2f7db8991b3d6f18fd9eb671c2587407e5b70ed2fde017b2a87c22e6fc13497a09e49ebfc06a2c31ab5cc12bb6babe41e2bce9ae2836ba4b4da397d87247016e92e04a8e3ea953aeb18c96a7da42d3b4a76d57e3c21c292a24c20065fa569aef1c20c0b784f2e44fcc2d0a2342f146825f75646574bbf911dca96a1cfce720909a98dfb08caf6f08c75198c509bcee17ffe7c8a1a4bd90f509ff3069d86e794e6bd16ee13654a94e97a1fc982a2d904951303138da976ad4a022e18c77f8cd17e8df73727afaadcfccc9a81e57166fead4ec9b3e67a6f2ddf4e6824850c2bcdf6b7ac71117562203a05db09a759219be840aaadbcfff2d5f485c5c032941beefb8f12a1c30f0e481866a2f9bc4c769bad5404c5199c6a5f588721d51e2dc7185d7d827c9e986175c1c4405d77e1773d1a6c1308c4ca7b3c59d95e5bdac03a58ed4f55faa4289793642d8551f40fbfee4bf656d7979b650df546ff6a1db7416bd2c0691addd56a27c53ab0356c16cd9318afd4e0d7438ef7e629e53814353d3a1f8735441997780bc041c058dd2b6da967ee693ac654eea64e93e54f79fdf52ed03d9d6d132b26a91193178913855660b6665f4e22f2f31c815e3ad939e4599f009912c186b83996e31883617f4645cd43d4754225e296bf9160d4a2a56fee40ad003064365c55fe1b2e85bb5ea88378d0a118ef285a44acdf16a1f6ffc086eea7de9eedcb517a1a6fd5ecc3c26e5489ba6a885cba48a8e8534d0ea86a903d371c95523a4e61657900ed8aa68a0fcc3b87cab1956119f264a3e70a81fd73a1877570ad8366557537184bf2a1110d1bcfa9ca2bbc3c7dc581ae3901ac25d8a3413d120090084697879161447086a437d129c944815ff6a19f37dd117a67efcaff8f7ce4f791f52bf3faaea8918709a7f140799b7b3e657b356bdfeff1fd46a32836c7d4c0b86721ce893de93e62ac66736d3192fa42364711bb8cdd6483ef8d2a2f70dcb829a0d423eee55fbb4cd203a14f6d2a9b2d285a145c3d2fa9219e9375c16f82baf271370ce4f83bbfc8b045a2258b02ba662f3d2f8e4357c53d6b2dfec1ac53548fe74ab7a3925c3eae6865d4606340cbbef626599a3409a15258a2d6c47baf856419bb48b73c1f11c02587e9b2ad57f9cce296369ac1ac0eb23ffa9e3961f7ec6ad2bf57b978f96d3879b6e22d2f9b98474509f244858e62d0cd14fcba717ebf4122f43dc56d740dcd1328d645fbef9f66c1ba6551ef297f9a0777ff35951d65e763de7264dd333ae1101d8228e2b62784771d7a5b8a73eccbdd7b848eef9eb7472a5405c1c37bfe05a88a8990fd661e6b8518a845f84fcd8d08d7d52da721d74add16e6e246b26c5554b60369bbe0f85e5b337b854cd8e972d8094bffb0e2f02ced77e564e7849c08b0fa28a1ea390a302657a92e1e59ded5741ea373a616452daae85c0b2b76e240584cb7cd160e25484a90114789a0e3ae06b304afcec88ce59e9a49f52c5dba1c61fbee4928f5f7b62ba773a4e20b95f704293069ce2326bd550b77e0abd3282ac04791a3baa87121d94824355190a583fec3069cb46c0f983aa92144c715798dfb7315494aa47d0ce3d710da6915f1769ec27012dc4d89f0e470d88251be0555f798b66dcda7215757fbd7b288b73bc304bfdbb035afcab8daa4594e83a325f7e0078a3881ffcfa5d82e476c515bbbb4312c3d3f401205a3b6534b0e12859eed62219dc3e4e4c38fdbbc0be1e228661519257fbe52aca384818b4e92a09d03944362f6b5f1cd163c36fe4b9313f0ee2af54a655ea563cf35e6e035f7e9470f523940632f0542111a6d4b7e682435e47bfedf80173d216a5e89787229bf0e1e43d855efbeed401f37e017a16e683cdec879f27ac1f8d49a286c0ddb629e508579d49471ef07cd4a5276f9c370b2916208a63f92aef1dca34daf0733f02a3acf3a1a5a01499b33cf39dbef81d1614e1f100b36132950cfa7b9d1d0581c0be55db47d192f7422ad79130afc94c0a773b271e36b3e456278f13cb22ff79ee2bcf46fb3b94a2b16230d2c90b7db3463cf40320ac19edb18eb73942f076a86d9f05583a55d05717341634b0a480d5138258c034746b28fecab1cdb221312b12ddf303c2d34b12a369d14b9ff127b9e4b82838c4b55289a56a79ef9c6109c414e5d43cea679ffb4cf602c4de671318cd0f94bc256cf679e781b07a77352c7e1e501a20369ffd814a9929ef14393486696175000197abdc0a207b9e0ecd663a74fc5dd885f39be62c59d1db804231cf02e5a233f98a1258fa1433659b22eb4bbeecfdf8057faba1a30a9e4eeaa6bf92e9f8085f751b7a418cb7d61d9649e30b024717be1eefda8ce071ea4fc68bc97aee606563cc0999605a6a0ce769becc2af9ac252f970588af37c91bcbf0cd820e9b14e451d56f1fbf20ffe692da1be5ae5b83b9d1b6a455503d05a0e223ce094366c30c84b676806c7ac8a5938d54b219423dd4f01ad7c4f6bd7e75e6c93bb5cbb3d1df6b88ee487aa31f99194f98e7fe2b1c3fa76ba45e7ddf1192699db3510332db218191ca9a1ab6f30e027146508cf47e93f8bda857ce6c00171ed8b728ea23681d3c9daaf2ab9273379fd421d3ef6d54d0ec967c069a702879ccde68a5cb552412e8a1d965bef8521351ec9f4af6da0d504ca8038323f39e8d779847a03b69da395b27f4f48b7986b710e5e5c584e755a4641a0fe1b0880c3c5bea5c02ec6f1c3c2e6de7be6d38625ed0d65860829961ed8bf76932707c2c6836350f4498bf673654618a169a604ea762313cd56d6568558d181885e3569c7fe61c06857fe0232d4e8c3ed0dc5bf417b94217fd1b6ba84b9fd02c1d4f902c450cbc3d9013046ed8a65e68bd0269c66d42aecba0afd484d207c94f7b9533c9bdd9e31126c918314c8419cf816f4236f7954a67049dfd5f5b63fd91e3038be5e829ba1f81fea6df1c3ff4e8a59a83a4807a27e3097fdddf12df50e5f426a8951350159838c0e5b3ebf061c135720364aa041e6c347a49b9692c84c6a93459f1c577376223d43142f4397bcb852233867fe0a1b333bef800b72bcff73c23e4174a670761d36d5377ca3984fed09e1e25bbb823e1e41395103cb0ae940197a3a620d7f86d600ee6ddeaa8ad69694b3edc92fca38e365e4c08249da6215f2e2387513de6fa6b66ad76dac275e446a7ca1b9e8a3324c0310e7f02d238df978070b69e5a757d80399993873de539f80b52f62bf624759e712bbb4ec0f423ef9763be8a4773aa40a1f4ca00f46c530bc84e523fc9b8ef23ca5351d637cc0722c2aa2a096f8698390c799b299603a75160306d8dde5904f92092594f075dfa6929c41c1045ebef56ef75ed24b4f77a2f1c2bfc8983177ad9900044cb78ae798fe574adf99ae134c6b067ddcc26b9a0e151443a30c8fb7a4d54f7d600369c86e57868bf57001d3dba2db26070305b7b219980af5e36e38df06ad66836c1cdcb7469ac5b3c0a59ac824beb4024f6e0b478383eb37c141ef27a18ac529f9f0e2aca9bca1e209ee976694079da24211b018d1ea9c7ac4739763915dff46ca318aa2fe9e99d4dc3176b42b53032066abd53a1e0db8e369dcccf9f8f02fb4dbbc97bf92d166cd353699b66461952cbb1dce3e97a3a182bdf796b1816bab75ec6d4d3247acff3b7473d46ce6a6207096d01f52f4c3d9afbdca51f82bd609136e1931d2b8d43384fcb58de1f4a8fd702c5985093530990838bb2174ca304199fd83f53cb9581c1982e705ebb2f4d5cbd98c882dd576abbbd7cf0804e7a366ee71587d368e06e3e680eca282207344e5abbd92b940f2b83b0db872ac35fdc104154905c32021cf3d13e33b10b821b9d08099ede4859423a89c892a02e10fb30791038b0d5ccb6e0a4272c9ec7fa250a663dceee7aa26956b4532238252f5bd614ba818608308407ddf3bf15972fb76158ea2d4daffadf76e580725af8262c603429c68f221cb68faeb2fbcfed119ef85055cf05d86e719dd85040fd98f43d3bdda44fd3fb8b87c032e6d649902e2fe8eb2353d2561c76f528fcf7a336dd15e8cc9641bea5805a2be54a2d53a38c0436b0a1e666a3b56bf1a23448f0d92abf650639ab43d78d38265b0e0d7ff77aa6f57ffe9da11583b88e09ef4f9b1bc898c91533918ed92eb27ea713f639790cb882d78e109722818b1e79c7c17a2fe7edeebdfb3964528f332481b05dc9a243991453585e90d0b3a752079eea7fea6e465491dae3567c7d7dbe4b7557d4abb5c645452df406255575376b6a199b4c1f7405e5e32c9540d4b342012cf23f2d0c8e64414d168a794cef5ff008b25c689088bda7987fe8b90e35a95238288b8a38156eb4f4e5eccc735f103454f09a90bf1316b7f51dfffd4143a821d4b3790466475becc003ef5f7cd907080ee299d7932761d03bf7559df2d80c1770f7fc13e20e01ff03fd1eedb443f04352ef00691becbfb1db8e6c900069052a8b04ec3829a543c7a092de5c98a5a0b96e94dca3384b825c960c5b61a0d70f3d3861dbe01918b0823f8220037ba6cd0ebcc1e3d177ad3870380f93f664c640f71c2f479d8b38147f8dba603fd972a96ac67a32532decb7442b496d43755c1fa3c6591745f53b2ff69fe6ce67087aab0670635bd53824b5776da46e478c737c2ce557737104c72c4485ac9c435f2baa9dd678484c935e04a7af5cbb0d70d4b7d48380700cfd38ac2767d825aa9a27cbe4ff00e9745064ca76975b7162de8aa59d1b193e1883dcb690dd39ad2841a2dba06db8967fbf2c202c24c13c0b9009cdc04ef87b115d82cc1ad39c635f8675598c66a36b944925435d202a8978aa47e6799e4e2b4e6de12e46acd1bdcb3671802f8cd71d3e9623e994e07bac0aeaec8af8c3c84521f2335692bf613495756bbbf45d00a3fcaf3b6ea6be5dd61c996b40df7acb415057602f72b464574941c5a5ce141115f05c82fd815c89a2975169ae5613ee0e7ca5d75a9eded7eae99e49761aede059624904b8ef15c14ea2754d0a39d18b674dd7c0ce8bba25683a73fb82ab6056494b090c560e32f810dbb7a2296ed36834ebeca87baaa28202774458dafc3e63852dbecef01a5546deff2539fb927e5939280eb35f0d138080f4c1ff878b50f069a386b1311462c4a4fe87b29b3a8925da2df564ab5437e945e6e5dc5d87039f53113512337deadfa854c43597c82c511edd26d6661740de4d3766fc4f2ec99f5fdf8bfcee5ba562bcb984c47fffe4229f58af55384f076e7ab378aca8b8e0cd70d55d20a54f40e630d339258c11cbe2e29cf1f347955ef11f989abf9faaed8e364f07da2cd50bfa9163bebadf39be9f49a4702179583ac9e5379fd309f2147fcaa521ade88752c72657ffd39aa200655cceb07b578b39b9be48c1e993ecb54ea5b27285d4e9d910fce989879f654814fd81acd1a30060d7b3bc1ab6c8a606ab1d9fbf1f913049ee6b23d82197f708069b49a72e2088651461f624c6c244faa0e435724a2e6393527ede2484e6f14207adea341513cb0189a0c65ffc3f96f209817dd3af2fcb6eb79ebad32f33ae239ce4e3a16859adc01ec9d7430cc250d0395d0386f40a446c411a3a3b216a951e00e193db041184249b9117d7711466de754b87ff11bf92063882f16c90411d1b95f1487cc920c8a3412a026c8483bee957a30c0233972f5fb8e38f6a3d04c920920c6b065bb80c2af738a851a04f7e3dc632b8614de7940cd6122c022468c25b9cf80181aa48f485cb9cd3ea1529b0bd830a4df051c2c01ac2d5b32da3a7a8213bd64f7d5228a38bd398a257faf1d19753e5b367304f4ecdfcb581ba49dc5c1ec9cbb9af5c062c3ca9a1dd89d3a9be7d98cbb9694847cc6010dcec6f6dfabeda210b224667df65bd1e25091","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
