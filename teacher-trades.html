<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ad5e24a4500e084e3c569fc4d2658436fd2238763217c698b8f95c8ff4a1c11f2f85945769ff9271b5aa04e874bd30bffc77fe89c45046b380fe1036dbf21729a3448cf63465098c0f454c4a47e295cc0cc028ac0a2c5c9f1f741be4c304ea4ec65ea6cfb380c8ed763792e7bcc02100d7664b29ec269d86a3e9facd5f762f060afef30e4bebf03303c2d26fe2150e4e66e8924b905dffcb4c47ff4b23e19b96c0f0348ef3bb8414b072cfa3d3791213ecc5288e5f99734c144941c83be7dbd2e286bf0e31c18df1e3597f27662e45d3659c181701095d6bfb169f7b7c6eaecf230aa6561a28dca5714aa233428fe03546129363caa55c4e1bbcccd50fbb5e00ffcd582e15f255bfa988f6751509ccee701b0a69583eb8eb592a704f56be175500884d2a980ff219b9d3aee7c1c8b356a94e8fb8cb443c58258957283978f9081f91406b4b0245780bbbdfc5d87f947e68510a5940cd41c6c9741d32d237f21f805247e4a7ea45d5a37312ac1c081a409ef285441a0b07528a0ae75ffd3c0e553bb86bea7c3c33434bb8a9eebc81b4cfa9e8248253a8442590afa655248b027c6918fed60f406ef4407d0fbcaa0637d668a62cb31acea4de9ae3e37b1646469d81d1eccd210e3f623187d973bdf5c2e9e22b02995b54c780ec3b6fd2ee366ffef8721e1f8ac1a23de3a42e2c6add3bd4ce009743e2e5c8d4bdd831401320bcce9de69921cb807cac1f5ea50f807ba9563bd3a65a10328c1778d72536c6941bc642a8c907aed8cf990bb8105241ada9ba917a4c711916dea49b132f43256ef9ce6cf87beea56fbfd0876c4b5ff5c8dadecd84a1f0f6d0318fce6acdd97d967499896d100a60886dac5fb83fcfe67342a49e7177fb6c1e09d6bf2bf92d833d8636474269a96b84f0900417878f9690f1081ecc7b9292e70718da1b18a6bc6cd29ddce07535df64beb2d3b10dd64f397f6f9c782b09b884972ecaed2a84fccc76e26460bef5bed49d46f4d278fb21382c9e0268317e90ea88f9673cf264591f3d7edf89fb88a2ff6c3fc4b4a74927ce69e20111899c73519c75713d0520231693a0c1ed0c0f451b1dc5736bf7d250104f952eaa49cfa783e9456bbc6f8ddddeb9caa286c1c10ab9dee92d587e2982ed75687e4c3b714291c2b4a6184a032151c1836e86f4bbe89fb462cb50277c8a684a137b9482d3788ac49e593226f6983dae516b876c6a99846117be6ffd90e9a7d8c24b09a6c2261c4e60e2a82817997603a0a11768a610e9b82b75605775b33ded5396f0563ecadfb0c07816d94129a96b0cf3cf05b3b500f4ce263ecb6144b35d8f32de8600ac75def035fdcafa17ae0b14db22597c4e7c567ca9b5bd1fa5eb094acd0277defca6d60fa2f4d23d9c52cee9bf926f9373908468011d9767b0f35f36c14d2aeee2a055e1ceecc194a67a868398e65b60f7c00e57863b3ade725c2ea6f6173f547ee9ddb9fdc63cdc8ae32659d01ad499376010a414e3c62ae533638190e6e8ca94d59b95f8da10d336251db5e8572ddc74ac1c0bf53616e1397ccc01184a3cd9871ac41638ffc84277020d2a2e231dfc6065092797c7daca1384c2f072134bc2e9a8b911e982f3d7153fd4d6d1cf76bf0e983d0053d37c0565aea087b3c5d7ff14c8f89154b802a72321ea4728157d9687cf102c010621bba20aec00c60cdfbf9bb0fdee81b80693df65f2ba578af3f7642128bf3166b6efcbd37a4641b79af211ab3a89bfde7595774747bac12076b39f94b3b49e3297917b82fc601a1bbe2514cc8765e6c842e1dc1ebc76f378c1c2e00d92f2730c7055bb5376d4c52142ca3fc098a9bb2ebec6607474d5333f370db04c4b2cf29011a19287266fbef2bcd96541297b6f4d211d872aebbf68d2218d9bdc56b9072451edf965f6b186ee19fae8d1eb33ccffcae564b78b82377d563ae18245eece6034e7e8264bc251d243ab076e920da5992a1453371e35f4d8c30228771a2bcd23db83045df1ae3721a0f810c5bb40e17dfc8ab069a0e1b4ddff6e21c599663d11cfa768fffcf52bb3d532b98a3ac81e196b023e60eb2a88f5de7be7b8dfb89657df78af0e8e253f0938801f4f5f0ae87339ee9eb6f8b2ec08cfd5c4a6e3eba51b1850a9865c11cdf62d179faedad4776055edbfe8fc1e794a627860d32dbf4608003139bf246fa9571dab301ff89db583cb029c5fb085bf615733f65c0393b7b7f8c7fa74e00763f5f9f2c6f6537b5d72b2bd4a4fc1ade6545986b322a2581546b36ad5157d411da1a5d8e67efab4a06c33cc55f13a9301f9d250de81b845bfe56e1eadeae9891c5cf94ab76b146552adc829f10649061a91c9880bade4acd97285bf2b1cbd6407ce5a64583f215a874df8c777d60146bfe7cf76dadb6a1acee21022a1166576776aaf05f1970b55c16c8165095f41625df0054fc07953181dac5b815a1820ac59c46a5830348e899b060801fe83bb301cfaf47e91a24c21466972a245f5d75ca7abc9967d0104f1191ad55125fa29b1aaf8ed051b22776c9ae08c081c38b7c2f067a0d978dc52c66e66d6ef2a45874a0d0a350cdc6e582a901af0f0df4417445f3923f89c6ad129fe6a58bb0b3457be1f79b4d7751735bd08795854d54a435e00875cf175cc3f293fce70ed2756baca248a418fabdcf2c1bf0afbcac566cc28b57fc3e88dea731d5cd60894c13fade3fde3625ec7bd0294ad009729474d70e9f70d8a520406da845c00c0103e7ed56a40a2dd38ee1a4b057328042110d91ea6aa7d21752424b7881c7ed94681ac8dfcc2a9cbb772c7829c95f72d46d0d7aea7c91f8b2b7c1f8dc1debbcbc51f68295705e92abdcbf6b50f44cd6d75727dc52e0e58252b6d9b3dd3b9160d79058e0b78c51c42c7ac3130e038eab259364e25076d40cea8a021d0861f48c3276ac896d14479fb0eb2fc70896c9b94da8f339192abdbdc704abd71b01117d634bf1dc2dfe3a463472734efc487176a7ba6db390e7f2b34402dec508eae6578ec0be6feda96909266191ee4b7c6fa593031b40ccc1c8aff955dd6c0652841c3bf600d9bc03464fc512ef8183adbe0429568b72f04e106e4da0cd5058b1590aef87f01da7f65be5cf7527144dca4c79331c8c920b14fbb7a8639cce755fe4f3ae27869ef28dab6f3e7e5706b8de0e5a7174a3e3d37bc416e9ca4c2fb275eb5a71afb9dd72bbeb01942ff61e038fbac0c9c2dbd7c4b96515c032bf4d366795d777d01d7d6753819a0bcbde224c0835fbbc834634986150d24a526c3afd0638d3569939138d23a437d9488d070cdfbf887bce7f61ff1798a9f414de978f8fb8187772f408408068eb1b9ea0205414bbcc3b14572f85cc3f9a153ca9d300abd8438f3af5cd957fabf3f0c08a80b5774e686a501454407de06ced6b93c990f23d0a5114f26334debe71827cbafcb75d3d9fdd5cc8f96ab3073f12426a7f5e8d0ce5beafcdd1826dd753127f97b3d8eb7979d123928af7b3dd7a3a312f740f1b62d2e41858dfb699e65923f9ac51f1ab80d4e40a0dbd570dede4fbe7c371a13ea813cb19666dcb4e3f449c5bfac9869b549a784a93c3aa4d179aa55d603752fd822333bd3dd5d1ec45557e11ed18dac13b0473458c4fb2844c3204523393047ee68a79519d17a6d0eb7925a06c33b1a081d55332dcaed1f3fd0fe83a1e18b9623f449b40935870c4422a8cf020e1607e29e2fabed54494feb2cd73b2e6638622c787741d327f43c20a524bd58bc27f0c9625586ccdf1574cda029e18e12594b7a4de4fb6a81b1d5b3744ba3d411af7297d8920702fc74e6224402fcb3c3add7732ca3de2e758b02c289335763680685e288bd8077f475bb643156e1dbb3b8cfd2677c944ae355374d3ff1e80a898f7a286867e5e0b76c93b17ff02405d8ca5f5dd60165cc6e721164aa011b42f89f1b572bf37446522fea46f2d89dd9d8ae3db245bedb15c152e750b2d501f84a6f0fbaf6d29e8591592f48973896b5a95779a3f235b83a67c49656163a4ce13205d53a337ea6a58d73343d4bba520e8e179e49fa7d566dad9607b38f471e92306cd2dc432e0ac891a7e96e192839954708e64e58a21f18c9b746df57952a35fd5e4603990feef8bbdb2b4edb0fe686e34ba4f54c1f29326fe38474e37e481d3ebfd3d53173f91f82ca27ed170179175f373930de269096d4d06a2f6471aa25bcebda0ab1db786141070dee1a2b683ae50924e15664edd449381cc6e0eb0f5182d3cfe7eab9c1461cb666b1058e5e6772968e07f7ab25080cd31410a2d3aae79dcd810cc9467b157496019fff5c51432bfa9e60dffe07edb3635791fbe22f13bea5f60edfa00d36ed4ee1b2e32efd208b37c5cd98b442dbb43e1ac44d95f0393cb9d1c0362b24cdbfefb0e18dd357289259a9cc2e0a50f6fb951f600df63bed25fd887b7bae98d9ebaf173becec86d3e0d8620a99515dd529bfb7649884f5f4bf5f6de13d9c278b06435afbc85e01670d5d3a666a2c56ded393501981f29164c6625fce3ae632e6ed34ad5bc1e6dde634a3a650158d7e0509bce20b7ee6e42a0c73c4d32c11ff3ef61f79ca407915256a68104d9b294a5392316f4dbd055163c1fdf4d42126f64677076f7f20e74ba44a67b3fbfb263b0ec0fc32232a1df339a5dd5e3ece6a9374ba9746ccf7c2753499b13ab7ec7f673994f56434a08efa5bb71642c0e38c722e8348ccb2a2192d57cc5945280ddea1ce1accd1b43a9a0c8f591d36405360e2fe47776f0c89efefd433cf6bef5162f9283b120adbd03cc42e25b614303f0d20f28f6228ff7425859a8ebb0b24a73e5dfcf48abccd1f2abf601c4d48f8165b38519a1cf9f4fa8ea27826eea9b988ad8dd8d2a32c9ad5cf77a56b8fc3bf8ade761c915ccac7441b87d8d9113d97c49853eae97bb357c334afd83ef7be5d0bb8453465530170d5e52133202087012ae07b2f47b0b4e0c07f0f680b0757b040e22613a9c3c3cabaca2cb7bd1323f731e2f287fa69582b30549b9b40f5a138f4808a2941b43240c7c9a269218009e8174655265d32776e63d7a512fc97d361505c96e2c35a16435757024b6ff9f63f166804193c15b65bc11a2179fd03f1e8955209a87997a7291aa02ee75c78f1e4b2a35d2261da4ce2e1aab9ee05a436ae7bd3fce80d5e66dc54fb9e81fdeafafc109c045681493574ce3c5f7f94881b8f1c7214cf6476a574d80e4170d5a33dda5a67b64b5dcb42b8adf27a7a7d2cfdb4b9ecdaba1f95b2cd36e6c5b1166bdffdc8724ff61c272128a3d6dbe42754c936d9249fa451d0815cb42bcdea42be79c2d4423de9cd956f1237fc8ffc247aca24eb1a9df28729fcb4bc4ca51c70db15ee6da46b70102d3a9d63b738a81110f604c8a8bc079d23f83fcdfc2b908a563529e7c357b878c2abf5dbbedc1604c571456d17f0f4537730e76cdd0fc772767412b1172e74934c4a16abcdcf5d4b9994c5ec69497a7e702a6d62f5b40db3bcceb2f11da769062614c392644c1ccc2f29011a33a1552d9d9cee71c808319b34a15230c8c3e42585453b7fcfecdfc899359c72620174be72728062432d15ffaf1e82a0ea9cd3a260ba7e5043150f0a6072037a507dbc38e3682fb7068b29418a1426694252696f4423fa70708def7a7719c6ed52e2afe96af3e074e0fc33b71575710572c0b2036c55efa978c861127d7e01e8391b61ad64e4920569d2b3fc868d57d630554f42333326b86a8759d346564ef6cc0b278085d320bff06cce78ee98362511c9e4c21ca348b45b8369ebde81d1a4d576d0ae22d608eeafca06195db4e5d6fb88340f7be852015080c89bf0990b345398ba3b0fc77e6173aceccfcdfba63b2ff0d260c3d1a4e659ad9d1ee12b00f98a3ff30d08e93779ddcaac21a8bf7658dcf6b26900bc0c0e93151f5af04b0ecb190529159554a3018e638086912141f9a8b78a2debda3b3aee0decb3c721f4574296b9d800c2321faf8d9a1dfe31218ef5dec455fd7c43e82569d279b04329ca701165b151c36941e315c86bdeb5826beb1e774d00b9e3e8606727375cce1b9febc6e01b388bd833095a25e2fb14bb1cf64f33dff7c73d4875354a82e34a106dd0b6e7e1af1afaf5960ae272ca004be869bd64016f394a28a20b57cd9396e9c32daee27f5cfd1305ef4bec76ade0acf3673b548ff5b165fa5706cacff0714d8bc4b14e6d41b1046afc7d72746ef0495ca734a864ad4bd280824727e91f64aff1c56ccebaa638e4ea07b422c6e12e68be5905b1b59c5ecee8454ca2227f6bae24395c5899b5b2cc14552cc3659cc2d2dbedf2c101f64982e1db6512e9ba5372bc073c53c560405e9ae452aa6d71237f5358e4f84c3f78011bedfa8660d42a44ac1f695a6aa49188f7c7c8728646221a6b3252e120e509eafb0998a57bd6cf6a708bf6f0a6be1df60d9fb4766eeb34627ecff8be32522974c2182d7c7c418891e6a9be0a90c9161ad3b70b4f7d1bb00f47179a93db4ae768976bfa75f892ef93d54d8ea094c531ff3b41b6585e72688a89b0de61b36fea8ea39299d5a14b2ef040c68365832232f15fc0e09a3f57c569c89110bcb247739f02f8200ae88fc29205d0045cf65fec7933cc40f20f52efc8de662398ef9345b9400e59bb6cbd02802d36588325fe7141bcd2a6ca8d0d0d8312c53caec88d0b503a7874175250859e7e7d0d28b82cd4e569cdddd58dca88769b2811b087c37c66a881753bc83e9d500d4d97fec43da5111f979dad3e091b086b363ab745f5aae38289881b964268ec1fb74c74bf8463e051a06bc44464b4f50e053d1559c18382f5d51439de86341e8827e00fb2d760ba372758d32b26f9b7bc25c8f8cc83a6eff5f2fc2a9860e5714a86cf0a4b11d15ad51378e6b348ee7050fa32dd80605709672df48fd3ba55bab4b87089d2122c21bd4de04ca87946217562ff338744a7f771006ca85018c31a2748b4254cb12d7cb53497c8ae81511c930a6528dc8785387d49ecb80bd30170ed4a061d96d41d4735052396e387bdd23cd608a73f2eaa420447db7446222b36fff83aaae6319fe3648d039c1be9e621b2a883d612e5f1cbfc9bfdc01ccc6e8118a6a37df325631b0aa95aa7c1a3fa7cefa0578d675639c045b985ea20447caea69b752f6663d0b957688a791d4144d5fc723da62a5a5fdfe3c5f0f58254ac41aa01b89f0777b06187b818a59fcfb229f0740a4a0081f1729a5def52f25aa51ba47aabb91a9474bba621493f2c2581a9ded31f36f6a697cda9fab641788f8c42d48db2e9d1c59e8275f7a39be364f54255b522120b3c3789b8bbab740e969e07b6dc1d8087d9a8758f5f9d8825a7106559e96a29bbe16eede1bc5328976d97d3e34eb1fe3fa3e4255ef526cd674dbc57031161b9ea92a09e350a1d65180fcf6159408b0812919b709b2e88d1bd29cb3dfa813bda5c27b93a9aa3a099486b048e51d16e7f9ba0d830032aa6ab9418a55fdb55212902c89d25d56fe3e5fff9d60b1744444528dfff9adc9127566aac1feaa44e27e68954239874a8b8ebe68ea7f03b41eb8a16397902760433f624bdf6271ff256b046a8dd26cffaff05339f1b8dfd07e0af3f658f0cad418132d83997dcd6e5cef101282ea3b95de7ec0409d13950eb66b3e0c9a7498c59b165d32bd0349899bd68c9ccce63239a89ee6799bc8de49dd3c79edbbd484b630c69ebf25c85394c52412d353a1a300eca4db6169ec361b8105a09609183dce49d61d9a7b239ff1af53cc76a8537220f28551ac2fe4b7904774c183f1b483cd4869ef0c0739f6f3f6ec47487572ddab0d0523245df8986920adfc773f67455a77af8347160b242043b2fc489d1c3fc4b598551564da0042fd0d745b5a77ef2be586dbd4ca8da19e028602f72d6077ef01f1bf289a1d7beeb83641b24df451e388c01549431fdd112d47587db847fee31f31ce1dd187a15684d790b87fae3a7d0fff486af5621b85153362f115436ed57e9fb917369056549583ffcde680e98904deb6807a021f046e842ea0b1576f686a515f6c6830134d2c7f71e0b7369aa3f915e0a579fbfaabd4628287a8814b30d979655a159fc19b1bea6454edab183338bd91313518345442d1e87060604d8a3cf4cff1a3f62a669d772cd23762d15c1fc7702e4136e8e135adff04aafd36726386f3afc52e4e597065e70e862940712ae19e3d7726c3d898286c8e7d74a7bdae584c33579549a8af5fa32ea94fb6b3fdf117a2647725053791db3f450fd1680aebf0945685f9fb2a3d69e0eaaf237e069c344f2fe1a72c81ad3c17f37c4321202beebb7a05d6259d107f97456352aa1cca9fdf33fc36d857da5f05e490f1fcd44c2e812a3c7af1706305c466c6f7257b191067804f4b205547ebbc693f64df433a4ce210b81ceecb3a3dfe6a7262b76abf454ab1a097313948ed80d73a18ef61d4faa4b5657d779e24d3c5e8a0e352ffdd322626ea2f181fdfd8a7ef546ad57eae5532f2a83cc22435fe96cc53a550d92fe991d22dd3c7739ed969aca193fb7f5fe0f7ff363d63f315fe8af6c321a80bc752e3e2441248e19da57d90990df27029a50ac1de8225ada8ed10712892cf7c1d149b0d010d4ff9f487216873bf9a7032f36d7d07d53886836525ad9fc4d1c58a127179cf74f10f18e2848910d66bc51819eb9b56d67b4cc0f0700307d887e50a20fc78f6514c57ac1eb559cbe7d403b738875f9b1e392dd12c122891790194d56bb2db11fd540caea4f3b26cc023ee5b7cc5c813de1251ff21d63e5597d7fe841f6903f2294b00506a6c16b4fbfa54ca6e230d89ba84f91f63ce8d76e5be617323d4679a6863872b7864ca24a186a4b8810056542f6abca3b5b1b4c3846540bb87506c055d5a0fa4c4ce8e9a0d40951d04512287e339f582dc89937ee97e5f95f38bb607e86bd9d6fa2ab0cc3665a09d229a49a2f7744fb24f2e18f4e4057539ede4741989b63bfb3c749c7532461dc85b534914fee66b0e04eb9ef45267bd1cb9638b6b6830cc3bb1b602a910432915e8b0e0d53628cd7dfcff65d0f8980c7a9e04623be6907d739d88cf0cf26ffe62fcec0cc02d73aab5b95d9944b5ba129aa382e666a23d2274617291359d3269d71d154f066880ba176a92159da1fcbcd196929a16835bb386b96bf9623c95fa8506c0c1c541cdb7763b243fa31ac7786ba7d07036b59833ef83e2366cda5bf2fca6e6f5ebadbbbd7af752e4c966845c9d9419e461f0284ed17b4fb2050bfefe4757d1f4f6e6b511a5044437597421f4dd74b292d94f6e6177f138889be71bef632785e17fd0513ca509364c045639c5e8eb3f69eb78886b74292f666e7ebfb5406944bb1f035691b8b6e47a17009ea8a736bef74ca3816b667817430ad7360de8ae3036b753ce29414d48824221e25a1168b4970162451e6d8d8a86a51b3a6df913c11eed02b91d979674e063356625f16b6b20de73ad4755db022fe4f121b0f9d456f50219e0fc0bb1b337062b0ccfebf28813fb2bb75b1f66c0166e7958e4c5a43492fd292d0f2d5ed3fb65de1e5de344e98fad145a17bf97627ec336309889ff23755347a72b3f887910f2b4f7c575cd67dcba70e0e72f647789661bb3282356bcc72ac7a5ebf615e920a581b2379f0134bcd9b56a54102bcd5b72d5352c69a0d6b8777da4af7e2b52b11ac04d6c1f8c40541e705b53c9da7108091863c03d1ba484bf2e313d446e22294d21f1dcd2c0f69ac718a7d7244ec2ca6a16619aeb0312b4235b4f2e3d36daf94f980297ec3aaea3f0064026c26b6184bde3abec9f93c354369006a6c07c2831f0579f1cd16262e05e0b619ffb61d94a5921b24067943ee0e54ecebe8ee9fdea02d3b5130b817291df7e174fc103af4f418c84294b0b038cd764935c6f6ecbb26b5a6e6b13255caec26cce86de0c4bb6691764c948a08571644b64d71a141c051ff25123b285b942b3066fe7167aaeacdab505956b0833bd4eb5805852415ae92b329b92b7a39379c62ae95543e3e33c36414739ac99cb81688606e2ef1bac58338797e0f062264ca9f72c0fffc21789178f724ebd9a348da3136388d80200bcaf2fd3848de898ba06d180eafda17d518eae5b2ceceefb30e7a47c7d770fbba3d5faee4e5fca790dc38b761a0e38c92cf84269f68fb0dcd7b97c59cf05b29df0b95b8141d7dbec0b0d69db609f908342a50f1115afc8067672f91bb13bd7a2278b9398f3dba62033ad05f9993e73a09cc13505a035417a5325a87769e672ec9ace82a2bb2030f229fbfc190c0418bb51b7ed8c6a62f395964c0a0f63d865b71e66f89db0baa778a31a522e09ce7eacedc4dbdd115c8cebea017b434229437b94c605f6713cbf418c294e0c9ba2ca7a08afb7346759cd4703d093970c9eba884f7606817da56196441d9019304ae45e72fc8eae5b8e502ec57a7e128ac12a1b69e853f259317e0e66152786be15b0921ffdff71f66035cc2216995edf41bfa95b0b8a22e877da7300b3e006839d319753051806084d9f32c1f48d7d571575f189e9ac210813118123eb1e9fe9c5216ae8ad80b4814844fb5a8b3bb520398224a83c08e2c7c26e6011916d23088e81694345eeef3640d6521814e98444ebc42830cf8d703657fd50b27492273896603b11d3b7c2c8d48c4f895b24020f5157b422b8c958e260cf5c5526e2795cd927eb256c449fbd089ee9c06b965bfcbd9c5ddc591776be1dbd2ac8b5714bfcf182a3061b2b4aa109aaf9a61d4030dd9caa3793d08249405f8725836ac442cfdd1bc672b2032220e8d848687600ea6aea34dbe234924a1f1fbb066cad9ee6bc439bdac6792e2331bd9398555ae1e33dfb6eecf8a089007dd0aac681d85ebc6b03f0659411825b32ce76bcf0ca1d274a2a6e88d4fb8435f0b1f025bcf23daddf01ff369a44d7cca6fa063494157dc2827bbb0347f36ae6779b4fe67ddaa82a68e400174732b068425c4b23d28249ba6c2950f4acb146b3fce3410b615d1c39670abe56ccbc7dbbd229c2d28b55b204b16fd894af0deaf43a084d4df5bf669628e6c5254e4d8fcd9801697d1ad0992c17462b66e02a70801c2a1c3f26d1f97428007a2950c5c5a5902082796f26729bdcd5bfba4fb6d8493db9e5e336908c5eccef80aeeb0b4a01419d6b2692a077eb6d548bbdf1fe00e38e39b8b6b18aa43d85987893f8f6a60f4c45e16af72dfdb8c4f55ad3ec7449784ea583107b0c707efe2897feae035eee2b937c8600f1213adc06998da411f2b574163134249aad1e289e00714bc437811fc71735b080b466eca624a5bf712060a8e34de1700f467b08b5647d45f17f54e593fc3b275d093d3eee4cf36877a62f86069d50832fab684dd62e7673c2d7df40783ea21b9ae574117cd3d75ba9079dfa412056dad805c8f8593bec2e2fc18642bffb9e8f0fafe5d007fed5acab453191be85e7cf315348b80b3df4d4875c5719c1cbc86ea46c1436904f8e9a58873d22e0b538e1f8041087e51abc72adad96f7ead4311624cf36d9a8be49246a30eec40fd80886fe143d202293eaabe848752b8d37c7d4d5b967d1bca4a42af5f1ce01b224faf2c17fe2d6f28374c73f66495278a0841246a281f051e920d69bff6726b97f7e135b168f54036a13ab960fb49928b2ac204e5d65524d30dd9cf328ad437555bc79f554a421aa86f02042f90e584c6f71fcdad2b5875ea5fc2f98e2ef2eb1bbeaea19705d71cf4030c796d24bd91214acf0d018a39a79957a639e6ff5f9ebb10aec98dbff9e91afa529796569e3753c5e107f492c4f89b9f7ac5cbf0ca81fd450b8eacdb97dfe775572f75bc8ce69478ec19dc3698c06e231de24d33bbedb6670a08e0c0b81e30a2fd41ee31ab721835cc714f59e29a752a09bcdaa9860c5d06d60f2d187354b5b67bb414405092f55644f513337973132993eb4f6a977802740f351c08886076baa39b06b1940ff4b813f4047f43fbec7460822f6aff9264ae10cd64beeba26a120f7a237d262107b624b876531905385eea210437e430e39a6d24a0499bf9b4ef584cc7a9fa4961c5c60cfb3aeca14a044c53910245b7f330c5e861ce7183e71db92d0db8f38509b81229aa1597f6b3335cd4fc5bb4975e6972cabc6c07f930787fbe265823527135faa7228fea6f1ae94ad27c04e3aae7ccb309ffe66c3fb6d69033defd07226426457f7844eae8e0e58ff3ff38944bc015d3b9a7180629f0288d771d07ac9f9d72aceb167b70512f1623648157144c4be2c82608828950ff27af1e6e5d593b79df60f9451a83baa540bcedde6d4104da36db1aeb808723b5048cdc8671ac9af588a7bf69a8d131b6cf6cd7565c1f8defb2bfd35067fc4e9b6e6734792c02f12397ef86df3bee5f064fefaa0ed436e60f39b20acb2c5d7bcdb4456a265d80aa7b874e0436ce4d2b9d753ab1fdf9590653d703be801e30f943f9897396da658d9298f8e16f912825f81445ad4b8f15f1988d8b12b49d55faf873a73574bcd7ee86a3e737c0ce3cb38a86232af729aabb588ec48b553c588b69f71d202031b1ef1799f2b895044702f10f49d28f7f2740f085d365efcab85ab70692f29cede6e9c07152525026b7fd8c5c5f98797f1434d93bac8615fd1c075fca1a7c7964d4feb196deec26bff50cb21dcada50e6cda0a5b92d2143bc18ac380945fe597cf5db7bd41d7f9e5481b9b0b93afd94944ce4f714b387d49c9fc81d01f0b1ad1171d58daa0efc99173682eee4c5cb6f1a1b887695cc76276d69e7b11ba042d4aa955daa71d90ca2339f49d64bd7ac2c0f34df877b5e4e3985257f3f79972de2bfae3f2e05e555524d119c78b0618b78104309fd7e4208493e0e018619666cc2d05e5be09ac62a7da72510dbba3bb32c7b58f7da69a8bb97a11dc1a910b31d0dfdaf3931e67c737f612d5ebc3eeb7a8a66970048ae753e45e9536bf070f792f015f4754807090cf2723536fef71abddd3f3a95a15aba8c7a9e435c1f61f825dba587c7a4deae201e999c2158236f5ecfe8743108ef761f153dc80c58cc2e40ed9764eb414fca8103b35ef02ed66b3f56df7d0a4d75b96f348c6862a7c5cebb59a6ab2f39fbfff84f2b61995efa66ca6a0946164287266f632ea5b1b158a3cbf1ac82cebfa35b2f0a3b8cc742f0de41cfb5975fb5f0fce5ed74894b0cd952c388f59dd1c237ab0e2ae9c9a61f8ab7458df799977a9d175b35c3416a934dc698ddb2eec2754e29ed96a022b272a407745ed7e24e168037ab3420e5d73b2c9d7a681f41704eb5df1f8be36f39ec23e704ed3d7a1cdbe4a1426d66839c15e59a8ed9c875bf372409c4a511dbdc2c4e54938e04c416d012aa96b95fefe73230effa13a66a298c79707c2e11cf14038c8203f9f010078b5d64ad10c018d2bdbf67da05b17e9751f87d8ae41beb4937f1aa1e3bc7dcc9fed1ec8884b75162993d146646dcd0b8358f861f0c1f0062b8a05cb66220ec56ddb9123c37b7fe1beca900c0182b621363af0dee9e5404cece1eee768baa138223c09ecfea94e098a5e83c5cea4b01124bbc0dafa75874e6cf842397d1ba2d3803d405ee855101490fd229eac0e56aba5d8fa7c90eba6ccec3fc24d5e59b3b72f6cc9e41820e2d000f529f682710d34697dbc6a7135ae2ccdde61e77aee21547a80e9208c2e617fb4f501ed48d5c1a4a22e87ce0bab1956e8df18507af5826cb060c09627b1648028b7f69c1546499f715165f1f4c5579974d9763709c353fc2e53cfd4aa0170c519e5e79f0559cdd22b7d5bf807255e2b1174c86817bfe3986d4efb4940ad68487460abafd2c3fd3ced353c8b9ee6674eae8ec14e24d89c713e4674c5a66cfbdc1e9ce23d010c44544fdbc60eb52506dfae2b80d2f876791a1dbc345a7ce23fd124afe42c5fcf30015d5aebad170198be5cb0d38fb6223f9699777021986c99a915a0e72d1e393ad5f07bce50258ebeb81b526dd7c8fae73ef24173018c2f0fe7412678acd72ef33d05c7db47b45f3de20b7d19185f5351d7f8102cbe8f39193d17c13f537dc21e6a38ae1824aa78bb472730c2b70f295cff5b8c5a7f0b9b4297bbd74f19a","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
