<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8ff7b3426851f15e3f78738bfb9c077592af1b80f900837f0e8422aacf4588d7e98465db23977f3b09454e236fea599e5a546de692f85cc3bf50732a0e688177a014013bec92a698700d0fb1b107f15bf528b05ce57b34b4c8187e471a5ba6a105b63d9628492d8402a5dd5a66d22ef12c6e44288487390864fe9cdc6a41a58549bca0a14565590cf788a14b2b2333bdba019e25548c608ffb3f13fd71d97fac47ac196663ea7c99bee43cf39f11789857d71005a9727901acc623c585f2e3afc012749d9f3acb8102ecd0da4b8df3bfd82ae5f08d51c17034be55ff07412d90dd6e4efcee1d910ca977996be5ecfbdfb52aa7cc1ef2adf43519efb0dd1523b661bb3477d6511ab310a50171e98e779190aba041c5f10583b64de09203396e2583a48c6c2c381072e8534dcd2f04b54c96c4ad9ded5317babd6431651f6bf55a07216c7c92e318a2aa5f73fdfc2129e5ef88ff4edb5b56ee116628c785514038cb7bf459f0d2dc6a64fc2cc6367160489c7a50615fd8a9c25cf56df15bbd9790ca52773d2fe556276d071e7e1eeab212fbd3c16dc1f01e717e3276981f0603e1c0bcc1239e9c29f02af3d3df41253e55bbc13aae99f58525aba9c1e2d2b843b751afab1d884a1e7b42346a8cd8d4c863e8c178e3894450e66f1fe3bff3ee87195a3b0e17beeb6aa4d2877bc54b5d1a45638185824400d6554fe1dfdd6206bbf5a68e61693a6b2fce8be1175229a1a7bc21ec31bb0a91b70151c36f525721dbd74f1289bd4ea6ac7644eecedd80252927ab2782ccb3119c3ad4dcfb402a55ce348298f6fbcd99ca8766f473c7c9f4d238df3533a3cfea14da23019d0bf13324d035d6eb0215660972f32aac51e6c8cfca9a33215f775f325630a7c11be5c43941a6fc9eedcc44859b567f20a707f514cd9a28b3ec1b81b0f84061c1f7a6531eaf0bbe9d4d688035e63db71c405f539d7619e709a0afc969a9682fba6c5b9b0ede8527d22182236c27187449fcb0e9885da8de1db19ab3f46ee3c728c70bea6452451101c3e9f22082a33dbba5bb3b2781e363485d035ce2af71229a9a46ff68562f8bbcf9450e2000846fec9ebd29847126f2820c8b9e866a3e1d7b15ef109794897abbd908cb5c54dc88b0a46c15bc910adb20cd058c0636005ca05b1be82e36945a53d0be3b1649cbe81b94af2e38cdf5ec1f56df776a6a4ec88b3e88e21294da2ad7e0d33a36e65afff2988c5cbba5d6a3baeb92298bb01ed61e75b0d03628e45b016d4bd2281f05a0a73d3e590f9b282c8533919bd31f7df9a0e80aa2d4fab3cd80cf8de5263596c4d1929d11a868ba139d490c17210f49c206865ac380d2cf8076333bd6f273cb5706e76b56580fa3e744919f72ef871bffdf6a707eb0a3f7109a2cbec8c7fa17eda75a60117eddefde45a941ea3e98848ddd5d8bd6eefcc3456ccb86dfc9f9c62ff86dbe0a0782a2ac0c681a7722001b1097e94a72732dce9e47800bfcdb7cf5a8bd0d3f7de649099aa23227933c8d479ba981125334ecff3fe3af713e3c967f8ff5cca4f97093dc56b8f5ce6877169bf383d1fdbaa01c0cef26d986371f1b2b7921f4937aaa9c2479caef1feb4a3ca65f7b095f0a55e8ae628e3515df0309ab31f09f7a343cdf88f0b1c0845843a712218545ffd344c4fa198727ea69379d56e87cab1dac9487363a116f34a44f871c0669f7d7d13d4f065b33907bce685700f4cb9a30d7f893cc3ea13ab3411ae0b5b03367255a83285a11a67cee7be4dbfc0cdbff40b31ac56906d1252f84849d5f3acd063df8732e83228cced81afe05cb8402f2c7ccc44270813ac59662410cab1b20465c2efcaa14110164cf1679d4cd905c47ecf7ef4fab4feb689ff1edfaebe82f9b1821500722ef3794150a596b4aadef4667a06927c5e7171b0c65c86299a3eff4aec882494c9191837287448d460e13e86cd9f3e453cec935266dbd03b6e1df0f365ece968bea68b141de5113cd270100c1f4e2626bdfd3a40f0b924c080ee1ff2f5b4b08de4baf181eadb4814022b94f0d9583863ed84b7333ca062b86ad77ff8679e9b1762d0f8d2dd7e84d57e9a5d707cbf9d6892b865cb1298b97defd7c3fe108c3d55a94d7aeb2359d5757bcc9b4a539907693df0ab5ac8635338278585423141b5eddb2095cc8ed64dea494575420b59a62a097780b2df81f9685f1d820ecc1d677c8e02d0f9da725e71c8ad05c4453890980f424ca192b15a9bd988ee96a4d226f3016894d4725481b9a682d36bec159e7880154000f7db6e0e34ab837db1506b3d589f5a969ac832d8135dc05afc5b08cd1037cc6dd6f237714a4837436ee9be70729df9b78d8efaa93d0c8a8565e0cb4bac28eff45274e32b94bc9e8465e9ba2a21283a33c4e43de002009c0e733dfabe8a558c0fa0afeb6ba5fb4dbe8d440dabacee5d6e75331924f2f996d332b12aadefb9ac569207cd4f32df3bd5e5d46077c21de1dfee2e5960d077928b2961e1c2e71114c8e9639bfe1f61491d8b3a3e11e59e457386b33a10ea706e70749b4a08ba5cd4bdd551b7609ef55cb124bda898db1f78a3a3b66ebb70a9a9da96ea9a708122d700237e8475edb90ef0fbff947798da5e03f33edaf773edd590c8329146f2844aad3519285cae009bed7dd920d4b86a460040614cdd41f63c1024ef84a6d5f3dc326a4afa8937057065f1ef35caa9f488b50a0039acd6347a6d56d13880d4945f00ff50a6fca9341a242ccf7215f1b325e088413ddf18aee4d0978ad66f3618482c5e29924d13d877e5d6ab0d0bc8f31bc98f8ca09c4a9de7a216aa6ce2b686651812f6023c1af717fa088e24bc7d9e1f2537b4c66bbdfd0e9421af916bcc63ff665593ef7dcffc511d58730681addd1091efae847d9cd247b4a9a6f306e501a7fc5a0ad3eb24b2f1fb5170f03841a6ea59e0c43a290d120419c6428cbd440653bd4e122275659192c146336a57b14fa1fbd52030d79b18122fde9f4e6ea4d5ddc07adf22f8aec9b63869d33cc47b70a2ec85c884443ddf06d5635182cf9eb56526dcfaa87f61dc562ef73e502a3cbd370ce5a611a3567a6d315a5520ed2db1cc05ed0fb1ec24ce7e95dc155171f10941626cdbb8c10a8a273a3f16a539e110d581fcba89e1e8f0864fcd51a10d695154d401722f58c258d939e4c2a053d5b3a35d0185cb2196bd81a5e77c64a1b8a1b0dc75016e095e6f8a94d689bf945c5b178750df190f4eeb4e2e2345f71dee86d8b678074f0ff630564d59eeb1afc2567acfa8f70ca7629d570c831c7bd14bb7858441f5e03b0da39c0fc59f56dd9a4066e23389ba05cdb3ac381fb871b4538a3be57551a55047373c46ff6bfdaff7cfc1f30077ca9d4fcb9b06eb5fcd3e7ff5878657a1d68589d6ded7a066db42ded5fcc31e8de5a44537130d4226a72e41b614d6d688e69aaedbc3bf836e2ba6f79e75c091957fb8054961cbc295ae1c7cadbba1d0f50eb78fbe95aa3f178f9fa11ece23a277c8ff88f2f62b3184450227f9d2cd6e9ad2fc20045f1638cf75420e3f056634543684af6026f06e0b510eb97c5876f7c526d8b8e37622d4315082cc4572695e9ff28c2452da6b477d59b1db97bc9d82f70627adf9bb9e3fc31ef0f505473fb114c5b4a5d3d9d91341c95de82cb5ee8ea5e9fe50cdbfccb005ca48bfa5a2b00f2aae33da9256dc8e13eba7b5d29c379ec857cd1ae760e44d5f6746f6f5264900c23daa7da00d0c48ead79e3733e1499943a3a21c53c600da45b429a08c1bbc610775fc3b201b97d85357cb14ba4783a374794b71d13a034c3715aea1317190c4ca05dafe24d57cb6c45f2cac8501434a5e6d2a602a8796d008395581020387b7e8100ccb69d063b4260cb7e2d815e9a71fbcbc8c1026d4a3f3857aba32d5fa3d15a00d940f5e04b08012229329bdf20b566fa81a55febed682337d97c91b9731e61a7a389fa6394db66d8c23c9ccd5579adc23ed3edd79dcb9fbb0037fbc128631c72c4874c4a221978141c82fc6e99790de74406731a84847ba723e69016017f4fa4bb2b2ec6b099d52b074a41d389250621ad7aa9a4f176ea3f83700ca1902b38bbb11c62388ba42c0aa1d44f0af1506877417c565b78690b8c347863fe5eb7f65af806b22caac0077274f22edcb752fbfdc1c62f902f2132d6208c3461ea5df7aa176e1af3b59e454de66dec1f25ca125774e0edf54164d602c27d53b6005a0894a9a59e108aee7fc00a15215e833bc8a143e672200bbfd489499ad324fab4d6ec09ac4b25b60e56281484daeb6f8c704ca7ae98f2ebaf43e4314b920ab96237e24700f25dd8977f6961716f045e8bad4d2938206c37d9c02d72e9f86b94f5f44b8e3c8a6e0080d4f1d4c036647d66741f1eae6f2e06ed216600bf4a019a0abb463f05ab286edfe6a0db805fd63f4d98b5fd9e3402e4766ebc0702989401c7b708ac7feb9d5abd171690bf3b6f9bf1333ee6b5fd959eb8834ac2a50c10e9f30b4a27c218afbe8f6ca6ed8552b429d26576d7fdae0821956e0bbde63172e140956fb04555b93f35a8b7c3a09f846a35ec87de3e62a81e1acd4914b734b51236770d06b629f99a0878454f8294a7eba6b4f8576719f1fb18495096c3d2ca1d3e08d8b510d946e940b0fa8f971e50895a7395f679a1143cd62adfedaf878029e17954b5cc715c35aae4acf2ee962174440ed534b052867c1c8619ec311aee59fabdc4e067b432c6bb281ace5c852df7fea44fbd7522b9a665a54502f00aaac8fe6d4e620fce57edfa0fb8c68273539dac9b49a706990fb3c2144c3c6877e4241ece47895f5d4efc3891bac3a6ef5ef0258aab99ecb78b083b589df922f1c5454c942b887d6fe27858b5c54059107c53d7ee086d5a4f7ea4a804a5627e54d04289185e6e0a3d46dac636b5e6420104a126378a8525d84dda4cb050c10bd9ff2b20237639f3683accd8cb1f2726cdb9d8fa74ef325174fa57916eb322abc97390a73401f649641e7fc8a8593332bc0e0fb8a534cbcd7605f423fed090036cf03eeaaf68980714dad384b6d74c2e74e8fe408db7e9d32ce3d0c759968aa3b08e4b511b5178d07e2635bb67d2d2361edb90acaa8a839b3f4fe6bbe157385fcf65709250cbeee87c2cc673e4fdd619c378e195dc97e6bbdafb2a2ee35e6d15dfd9ff04bd37aa31d98461faf59ce63bbf9906cc07ed15824b89b950fdfc890ca6f72b7e0ef8ab6c6f34ddb527a3553c540e0b6b8b89550517f10cfe88c69024cbad175dff6fffd9188cbb3fdace95ffabb8a909f3e1aeaf360d63c890422add0388136951fa2258e583e66574cfb7aa89b4c4727bc7a255759d2972ac353609453c6f2dfc861e1ab22bff8b913d19c6bc97c669a4896accc5c15f1e9ffb263baabec332c981b18928ac264970660f7c3a152c8affb97a0d64d7ddf17fcb2508076d3a376f5b5de7cec5ad452a99ba85bbad479dd6b09aae00c62875507c1a00abc98cb99f7500a25f5328e2999e1b5bd1e52278a52806e4bddebd3bd514d082afc7729a88571d3dfd58c3f8eed26a7cddbb8aa3d25f830fd0c89682213001bce251522f272acbffd0acc9573e11a3c9057dcfcef79a3c146025a34922467730633ff55a0c2b97e7934185e63d71ee575d8f75f387345099e41b5912c9c6fd2d0a124b2bae110c29eac7cc1cc9d2427c111f2df697cd9cddef8ef11a76839f09a146a73984b89c756863b65febc63a49df5efbe53e022e5ba5cc78d2b5648d53cf2aaf85d90dca3e8ffead0568f4793456ea12e35408ba6cb3cd27c2dc1d8db1b702c4d4e9d0daccdac770b3cd69e72abf91edefc08f418ee526a95feafa4c4c5aa0cf44d655520dfbef5fb98363d2852349a2bc8a9903086f1a533becbc623125726c42fafecaae4100242164ee42931290ed471d360774c13ac08dc9a7b9d712f6a7446bdab5c4daa01031374034aa983ad9d397775622b1700a10f75ca7f66b9926eff792f70f0a0d11e793976855978f3d54e7072ae036635773c511eecc4ed42d4beaa024d0f22a83cfd6dd0531e8cb3e8161653625d36d41d84e8a0109433b2cf6cc982203d1c39b717adc3acea4b6675268e5bf1955050c1f64989f3805d3c747a64395349c14e0ecb0fc83e3331fcff06d4ad411240ca4c452cbf69473189deb3bfb13b1b113ffad2ae61033fd75fa8c744500566f3ad941c7f84404f4e82305069b4a0ed9170c842c8627ae576bac09a3e8bfb8a22016506f9925b152a9a247fbaef3411503aafb77fad61710c221b319633a3ce61f29a0c4a3deaccb3783842aeacc6d319ba050394eceed70acc619e1607dcab36d62d5749e4b5ecfdf0af6e81e7620371aaeec06e19c652e77142782b22b676df1e69a99c5c3401d4d6adeef2c6a48c76bf940d0874b9e2cddd530887937b8f06fd8e0c765e514f2b0abeba29300bb4047e3188ea1047785a9fda1a92e5b0bfca39a4ed5a31656fde57599ae8e338d4182ba9c2e4d8f644dc4424cabb0f2cfe6da2f9764a3f0d010f2ea71642ccdf76efe58c30777bf0efdeff12a4fbeba609a5c03a15dcc5b71db4b732368e05803509f854c2d4a6527a53e0bc7a14ff79bedfe2956977df89403df12e9083b4d664b7c147c5de948f26b7a942d4840aba56183b7d0e1561de5a80a54e5920e3756b58b136a1c209a49d2bf40f3a01ec659627c5d7f8b98233c7a017b6248ca84168c2b0d35f1c1da1033881a183ef718e65ec079037fcfda6737ff35736a8f1c8242b52f0f68accffce27ce46ade88d3eb17a20fc6e972558eb4d9ddd18fc5ec37e0b77b5ee1d407fc9d3f99389128fff87b90b85923d2e61f59bd4d6f4ce4ea5acc93b420d4c2aac69090917e6a23cc2a8c6c39ed11b3824655610f8302fce4a78a91dfd8339d5a737f734fd1b4564a947c263929bd294b30de4d08534748244c513858a34544620572138e40b10d26cd9d37789bf78d66f4f511ef980e5959ecc9c429a3fc5f303784289bf0a82560dc31745f90738b85a7e7963b2fa941f18cbfc64196b5d227eeb76a1ff60847e75fdc67e6ebe4ef7c604d103073f084b526abc2358460a2bdfd130849b1a1705219faf34528960389ce841409d9d822b8df92139c80f3e4194bb2fee24d926830ab574886ab4f2fbfa2696973012694899f627b9157a8b10b4c61d9eb83b6d369cf88beada7c64f83c287550d50e8a2ad12f3423e42e4e540f92c903ce5cd2f1489cb16f8e3a7a04bd325b59e2b5009f62f45ed4a162d494b30e1677d5cf718dd8ff3eef9ab92cfc6cc69029788c0a03d77f6cb7a04548fa15539b4ba6a06ac96ef11bc5325b0e72c6af40a5466c7072bd34d625abb03c1c7dbf062b0021817bebbded14f2a8caa66ffb75fd08716163b424238e781ffb8edd3584f726f4410ae3abc3e86f2caa47c2b4398e032e4b315bc6ea3b874dcb3f773ae9dd1530867506dced06457855d2fc0b4befe5a1d0bf216506b9a482e4b60b766c93348bd53d5ef9e2cf83f141f340cb9e07ac2c9b1d171c737b285ccae3049a4688384a00e65e94c85927f1f9fa779ec25d155beff8de6cc1169ee0b0e809eb44c67963539137fa6ee1d11469f1d5b39ccb489d3632cfea350fd1bea6843dfe8834db3b67d8b15fa74764a6cf5cef69f954c94c7a25ca8e7ceae9cc4720bc12f0b3b48cb292d953459abae00c0519b8d1231cf265cd65166d32eaec8bd3c9b6155f3e0731515b7b2c1dc7fbd8edcb14d678966daedbdfd1daba2a50c7cb23943bc6566e1cc94a75178f64178231593b63e0a29506a97be24b19704497ee2759ec14ff57942e02855ba719bee37d48b1fed9c98d0773ef2422fb67691c9b4de13b76d510be2347620cf59aca62cab4d207156ef6ea157e34c3dbb182c72001dafb461af8043d38d45dfcb8052338550f6ea185552656d42029b21af1e0894a329a274c7ab352826ee59e0fc0178b100f1aa410bf0f3ded7a661d33ad838197963c1f389cd8132c0b8a9724b91755bc52f1fccbf731703ea9752606b65fd36f6a21bd543f39008ad4400a02035dd82aa9bd7acd0efee51c649d221cfac75a91eb46d9b336b741bffd0962c3d2d9df371efd47c1f5ac6152e9461f6d37065f197296d0d092616072509c4e623fa733f6cc323cd930fe77109bd117b04882fa5bfde93c21b88ea41eaaa7aeceee1a93375eb54d717d2ce8c688d6097dd4b90ab9d239ede4d35108f17360009fe42ca8624b2845fe3fc476905f26e8d9ee52cb19f0a32e4fa2bea002f523121087e218b02d3fbc9250130600ba6231b5bb38c2ee516f966af6c64839662a485d0f6425c314a7bf455c19a931d827baebaaf0de6d341ee2518d7a669054758773929487b05be9f9f0f3a192c43ed774f64c0edbee3f9c4fca5722d216264cb785100e3c5ed3da2bd65f30208625dc9363a2f2b46770f001a3ac04f13da39586a91867b11f3e9c3ba38f7509007ce37fc32d5dde47593c15c37bf2ec39bbb14c46670633fe062dfb3e54a8eb2eac486b7eb9f9c3457b4ead71e7f256452a07c1ba71b9730703e6313ec478ea642caa5e8897df48aea113dd916399e26758eb86c80cdf20ad1b4fa8f1d347e29af2ba00ff586cd2dae3dc9b4f58427fbd08dce48fbf786c6812fd36c912a6dc39461692981744172f8f2607c13fd88c01b74e150504297119a336f63078716961473a7278d8d91db4f66227a23f900e4c74208626a1258966b386f4b962f9be4acc4bf188deb700224478c069a607a4f462dbe43e7223e29eac7492c618e80f911e2c1d42643daf22956817aad1d367191de6cc315dc1fc90279705faa192b63aa2c565d81ee439da221a52e3c528c7dbc1afba795c22dbeba30776d1446d2e37ececf32b6df83b705101a608a740f49955951bf00a992b89dd0190201b531af554712fa5e8cbe8015291dc348b74804092e2d069a09904b1e8f2460458701953c847e025b0bf1782d3dcdabc6e53916874ecb3a5441cce226cc538597034fbeb342a22e8293347edddb2328d0354128389a4829f9093c6d880eacab7381f1aa9fc55425371f9bff1c747a4dbff4db0f12d9a5f597c68c6076396c896d8056839528648a8831da89cd992cf910dabe21a7e80ec56c19c5bf8309685bc1b1c2fb96318c7550083134f84e9259fd99d667879c90ad6d253b9f05788918d6e5e1db4ff43d3bb8447719757140de0436f2144855b95f4540904beb008a0abb10406655992e44b4e4497863ec8671b77810590604bb09bb91c4c161256ffadece60f215588fb6c8dbe2e66f02f862043777cb198641ca68b94d510199dbbad8098fb9946bafbe91450953343b56fb74945e63d62febc35b9d2f0582865150ce49601d43c32f57ecb861c7bc817d17df22c9e5414e43727a481329f6f8d6e51911ec6eaeb9037d0ea928d6a2769fe545eff7284e5b5f7c15fc2cda6aee1081d2eaf2bf1187c80265c1fe283314b7d31a2c02522c1084dd5b74b24e5168b208cb8d43370d10c85fa5f00e5b4f6d1049f85621bc11f849d5a0afb6cb41ce11208fea8ed374a6a2b9fc4b38e7e53b5691b8e8f82b50bbcd7f9cbb3f78da710518a9803f377f2a379cf27f7504798670e52e9d82761e33a143996c5b4c8cb97d054be6c3b13db250eb2968db4b6ab0e0d32c5786276ee5f1c1426d234c326102a927faa8d91ad7d66b81e79d5fd895daea53e0e4431b76480c86a35a6a284f1585594ba85f6a1557b08e50809d5dc9399f28569c7014e7515778923bed6568744dbf83bff2c39c09b279a375b13205d9dc4b25e1ec998ae80f05584b398514c3b98a6821544a8b68d2f5896ab3be7b6246ec8355c6ca219a00d1899cd0ec72e63f569ddf663f0f4de1c47cf2a612b576c70ed1100dce0d3a92434f4b9ac82d8bafb68e51340149be078f215194b9dbc9349e1f4d81f2e10e192fcc1014cf23685a374be924b19e31abe3268c0f5db7326ff1a726f5dc923d8ed9172bf94688ea84c5fdc27a8f14046fcfb7565d2a5eaf1f3f12e49f0c0fbb2f9901a337532a4f94986348bf312d5df70a4a8e43db9a9b3ebff71c7ddbf0a026792391e48a7e2763f117af23834003d8bb3ef0f9b2ef96d4bfad8df197fbe217080b2ab2c9c66134f02dd6df9aca34457289a14fa494c4b595054b194afaf157f23b30b32b73d2b64f96fa204a4aa56dc4a39f8346ac24b9795dbdabdee9223196da2400a70cddff50a3610c967f88fd00558de87dc061eda17cb063811b73b070993c62e67a9dbd664dfb39bb7e507683c2a42cc5b43fc2e98fee9290c508341220b00b95a778e8de9023ee2af3795a435d39e3deeffbfc1f1f91aa31dfd90f145f02fe534d7f511f3a489fb49b57b2675462d53e3f354f39d9484a47b1dfcc7dd06036c8847578058290073beadfffb805457d68498b5a7c9fc299c9cdd1e98506cca123ca3910d1b852021ca6db1ad6196d795f2893155f5f4bf367b3f188addc8c395bf21ee8fb65b2b9ebcca3a42d9d08cd04a8cea456c1fd4fc561a653c432a0a8c765ca2aa665805c1b6d3387f6a11f2aec8d4eaaaffa7c54f855d72a517d4a6051456d03da06043931db86233acd0806e53220f394b2431728e52b205f6ae148c45d0fdd194368e425199d4f03d509bee0ffee60450206492018eb60647b5d13275b5db0e98c2ea87d0ca09c7e30bb1d21e79840111bb8cc321b00dd730e276500620d3088117bf665256f88b7d307348c97740537d2f772e9024097632b11f520ccb9e93ad7051319a76cc49ac8b4d14840dee303e7ec22bbaab70f3422352684eb2e3312c65fbe9a61e4cfb2af7d5736a78f4abfee58cc4f2da58ca1749397ba4a79034cd7e3703e76ebcb4e2ef7df13e7df441d4a3a812e42160a4f45553b00ad7832db4ffb75409fc02ee435c2abc85180cb772b85f0eb56662c96275015ffa056c3ac58ab102acd8ab74991b21b97cc566307d2cc452ea4f7dd00ab71896567281f55bf53e19f1da9a326f7ce7cf6d09be54c209728097063e1bc8aea66ec72df9d6bd97c48b7f9599fed1833a4e31af9fac35ad94e3537b72c442d6362c046daceae76435142ae7ba465b7aa7c4871b3f9563d6467111555a316295f0151ff9808ec4238ab31eae26f9ec647e4a21c1affb10185d08dfc82ec5e6079f9c72e4c92e0b3d3250df524c3d233354f23260a8335ca06b775be3500184fb040fc4491ad2407fcac287ede27a13737ed2a41259168c820a307ed56941fb568f30306fa9b1fa5c36c76470ef722c0b342bca21fb14e4cb6be762781217ea6054800497476f9b22feb082a038c4cb7545676d910949b026222bb0784f9a1da14a48ba49d5bcc67053623c1c869ed04940f66b6b4ee0085eb0c271255496d3705d1ead5f9b28371162b94898b25b3b3f7d7d193f978e2192bb0cd5df8e5a4be4f97cf2040e6c17550171dd383941078cdc1b5e25cf4ad6defc4ec0054fc6bad9a620d3488f706ab5ceff2b1233f4492560781f97a586e79a90eecea4ec82a900943e586aa3f28cf06050fd51bfaa2a8fa4d37dc958dec920ce4978a3f5beefddca45efff6fae6f2493dca0e53e523965dda255b6bf80cb888528576f442c33da762e11f5b2a79101ecf865b29635043cb040c62c0b3a71e80bb5fdfdd3e2aa3ad6252f4d5e37cbfcb94d78e40c54c4b72c2c229fefe1b4a571e95282a68d498db7c99acdbe8b4ab49463c88e119098b427872c15160a663adad2184ce8c9b7d2b6e0528a7f463180da63c2d62f03da9d78de8f214d4310382321845dd8bc64b76cca12f61cff8665ca2f678ac160c33dff637724f1808a2ce8783d2036b9256c118d2c8625881d8c2f4fca192e51d13d3e37921d546a310fb7e2293a4bb0ffd12d4c1f0d94d22c3e1d19a5feb2277e41645ec915f328624ed88237ca20581a56418a4b5cfec6a76e1e2deee6ca36ae752c3d2ef6e0469251e9e0179fa77be9a224dc6e548ca64e003bae3c328056a73bdecc6dd9f69b83b5b3e9d541aaa4fd41dc13f7cf5ebedea3912d366c0c2a64f542d6da875cc337b468af5e7b2fa5f93a8e7c6010e1c1819b6ae64c9a0c5c9bc9f2bbfd835cf7f4eca4a24ad942904c233854efa8f7fff792153643bbb17bd94d606c3ee9cd2311b62351d6ee2171653a435a1c6fc6f96226108b5129adfd03c961d2606d93a4d3403d642b57d0bf018716e0fcc41e50a7381b3f68a81d675c905d6fa79c958fdbe3606d7315060b67633b2d48842657253d1fe249a398fb313cbd21a0c405df39b0838c2fc95361304027fdb830248aee3dde5f668d4143a2115945a49bc7b544a2bba0fb861d26a979946da5767b86e709bce2a1c64bce1c12f81a80e4d93dcb69de6f87f6dd70032929f0095a9a9d4b7fb8f4113723b837eb5dd040d410c8bb99a559c51d92183a800a174f1d29557b5359eef883df170e747b459c8c147f4d8c7cadabefe9bfd2758bbf8b60b3ff627f9d978e04140a8ef8ce2a3655ddb39e8f33f3263fae0c41fb7aa8647badea5c5cc9ca79006521b6baaaba4d2f0b021cb4778b9e4a14dc1b53fe0cc54b6efd40ef92cb08a2663c6281741d79acc50a0799cf61c9161f4e17a49370ee1f4d791e9322d96e2e62038e41eaa224cb6c6a0dc9e965b1b963cf3a502dc39be0f8b4148d8890a47622f0db406e5cb46f472269f163b9c6f46eb44931b5d0b0b0a25050186dd5aeac3ef36352e9a7b46ad0e32fbdb612d3275416892015f5e57b87dc941f41bee166d47dc86af540d4982135db2760f59902920c213f3aade0ee3d554736810e10c70052a1668be74d12a78f793829b613f67f9baa4c18d43d95b74b4f6130215b42781e07872331651c44168f1c0a6d7291e160709f7b9127a91ab66a34cfaf26805e238b2d9cd118e419e8abedf8cbec342c2383ffb2f8a680aeb06257ef0082e4dd2954bc6ae3ff7b61ff120fe5370b8a324609b8cad4529fdfd595bef5fd79bbee69873a07e8d5886bb5bd1b359a012be07e9640abed97e90410d41d6195d2ad6e322032df2a986dfb6f47353bbb93c9f2dcfe07705407fa32064afb092a809ef843d8d97b07a2dc776d035fb13090223dc3371e06a80de3bd3cf60f7c26bdee0feb05746165b85bf6e4bd0ac8ec87877b32e9ee49203e6a9b292fe4565ea7f4549b8f4f16d983aa2964cf19fa00001f5ed659510b104a981be1f6d1878c79fa4dae6dfb48b85f5358296d94184e04895e641e897b83a22b2575d9bf4dbdd59643a5b1e6b7f6f1059237a3a3229aee8ec655ccbff2c71686c0571b2a9898711511d9487462123ced0f31ba011dedc1bc3a924a564e6f0666d7fecdf350a0d82b34e654fea36208f431e88c22a26e93c141428825f5489bea1a17025a23df3213f7cd81a5ae70bbc1e6404eff9df40f8ea502a1337b5ab6c653fcef8b3ab760536b4979c47eee22db20b6de1a73cb3975e72a2f0b545fbeb422cb25447e10e7ea1a468e659b8ece4b495c7853105b24098e06a54503bd627b4de3fa47ee2d9e9ba61af824b768be0efca145a6e9320e2a0035ac71ded3668d9da7ccbc9839d65470e3329fb5cdd657f378a7f2c6e946e97710a537b4798304a9378c540643e44bae93ce78535ec607460d5989639080fdbcbaf0ced93fa468a95f928f0847bb9c7ba84298db3c291008fe00afc75e5d8709aa755cfc75da143d186e4ab217f00837dba86c06909228b74002f08c1368018c968d08f7570ef3d48a0fd049773a46459648fa3d44d53dd9f659b1892c966541b3bd624d52db471091513bbe7172cff853515c10ea1f409ce58530868caba5ce907f1d82284bf279b6a21bd35343d0aeafe40a84a3969f29bd33555ef93475ffdea79a2509386d1b381eb1af301b3514ba709df0feba2d69f86dd2461f0ff032db44c32f2658086bbaed5832755cd39833457e5f2f2c3b89ed7c37932f5c838a19220dfb1553173f5e4ddc32c5ae63dc47975d8a57f968c0df89717bc80c04f789436c2ad4e7ecbcf1c3b0e6e77446a87b9b91558233f65da5129393f0346561162f8ad8c3f1f1b657a895d00a2a6fab2fbebd1d2c63cd11191369e7d1f543548a18bb81ab5d6c33e0625eed8ed62daa5adaf7a9f9ac9c1cbecbad93c8c1023b6e61077667cfe2bd9feed88e1d86a1ceaca46e9a9dfcfd76f8460d14f41ec0a99a48254e7bb154313ed6a91d9d7adb0bda10f7feffb52e002e11d2ab28c6fbfff011fd3ae1d4b0bb57c39e68b3939ec49c6799fbf6db2e2ce83e16dd0a7d36ed8932dff7bf3abf706ffaefc1f2bda0e91cd66d7fbdc7d20222976df0b8e996978e1e491d076708735482e2f5c83a3ae73fc4bcd1e999cdac7a56087a42f8a1471b530603848441c6fdbf685e5e9ee22a5f6be78","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
