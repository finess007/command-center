<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"64ce5477c2c043b1f512a443a4c87ae9bc1ca60be55fefba985953db22cae843e36bff20aaeac2f6842cd060db392527b665e97cde2b577d99619b12c30f6818c133750977d5969ac04be93dc3cf1a6f636324d7ab1830fb778b78e0dc2d6023b7299d30c8d181bc61171b6dc136edf7311849570e3431078f2fa52e31cef9b960922f29c447f38f127d4863538e6fbdd53d408123a173480efb7c2a05b38547b5bf161089ea71a9ba3f85bc1477a4a02464e3652432fa2aac56ee54bc06524ba16934424e27edc58e059a2bc944e6fdad39c9418d596a33ce03266a816613cfe2beb4beb8867a861970d09c1454d1a5ea8479bf1d5f2016eb6a6319a6873fa9e932560fbb1ab4b7dfe9de176bf0bfcaac658e117f58deaf0aeb52dc0067eb4714fdf0eaa2d7ab80d42f6a5f2f74e512254f8e70db57a502b2091f2c7e409197036d52182e11459d707be774ab3fd2fc445713c71410d574f170610a215078bef20411465508f2a1a86349bc758f3bcbf6507d2b0e4f0d29aaa893df30cd67bb3d7d445aa5a3af0aa8d16106d273b1ac9042f596faf4c860a1cf0adee0f422610e443e5b8337d04dc7ade2b716513a1ca274e97312c66deda41d9df26e44b49b82de89464f35589ae262a1c0f8c4bcc04344c2f3955050a5e2c65214ad2fd789c0ee66baf797a3126a90b53cbe258295fa86e769b6e1fa57b2c9a87a8d507251f975aa8d7924b5829aa266f81c50c41016ae7883ff3248ab4f63f17e2aafcc87519d67e58d7109a46e6772ac0d6edd3413fd9da271cbf4e4b5b4727c5ab4a7e8d454f1b5f9a1318a05a4db97756a15e8eef42b3b57e3e31eb3477941d5b9025eba250ae89f3bf56e18f24092d6824ae8b8ad49cc987705f82caabf0e82355934a8c8958d5a1469eafe0f291c5cb9e6fbc031205c311089c683ec45993d820ce0465a10d6b321314a57a3737eccf8c49eb0eeef32425717e6b35db89892276fc2c0cf2d0754323887b6fbd93b288a41437852110d1949b45f3c9551cf5af24d915bbd00567b506a2f563765c0abacdc07148897e4ead26ebf4633ae67eae4d6723b97e01c779bf2e62b3243e5b189e640f8ee67f26538ddb3207929989f456814f24fa4fdf4347bb668de93850098b9477780c1969458668957e5909a500b61d94915c51f87eb33d30fce0d044fa88f9519225837e4a3ca415891ee561644c17d78bce1e4d9e8cf90015f34c1cc0f6258e739ce7823f42b4d7a1e393ea8f7bee667bd0adc2d0fae97fed3b2bfd3e5f07fb608367a9533d7e6ed7dea6db008329410027b9223ef8c3690054202b01ee663d818331bd69ec7dfe55d730cb31728b059280bf3887b814ee9c619ece9aa48317b3e5fc9d0a49734ac5dbde0eeba6acaa3cae484a0ffa2ced6743265cc4d45534178afb5f1a484fcb69b759ce27b5fe6f3d40958780cfc0cc9f01279b9516e8413f5410317d33d1ab0bd8d350979c2176e64bf6472e3d3bfadea8ba7a684b7dbe0f049d8eb61254c850d09cf8b9f116682437034bfd46241a9108a8333a4730d2af7574377b1476f0157a3be588b349a7bcf0e1af3001ea9150306769f216d138a9594e6963a70d3e048882e049f5e2e024a7e69f995d0c0ffc31753b5f58f98b5c079c3ea8466314f7bc13db8aedd4aab7c64b6f9a9826bfe022953bf5523ae69cb5899b1117ce30d1d278be2f82649045894083e04bfd564295774ece687e8335cc00111b156bd021e45f20b2191490fa53e11fcf5a55dace4a5d190d4f55ba76d3011c0a15f010acede699fa0e4be5356967967b0e33ce0511e4b9433b7af5da200483610e17c7848ad0823e87c5a0c2e27d194be70f45a738e915a5f75df120c673b99a80edc5a97d3ab04210b55aa6a8e3780f50b8debaf6c3e3c39003944733c810eea034679283b65ab93792292323bec79c0986aca2657980d816f497d35dcd68db2354cafbad1fc6628de0814aa88a5b407e0eba0161b878b3062dbb1ef91c224e95ac7b237257103baa7b03e5a34b1f8c9650a9abf90575dcbb931a3da4346a40d4913ba18ebd216cfc137767da98049867c221a25c96f607ae5c97568aaef1dc340e5146cc2059cae4ba58d3d6d8174d1e52920ab4d5c50788215a1c82efa22a64010f8d5cc22d316f3d4339288f5844dc6899f6e6529a748555e067b9837434e569538fd172f732bf68765d37a636652e2d520073b910a891f3fb4e782b55a971fef2d8e486ec1a9461d7521ae4f092816235595a3596f3395746fb1a9f4206c110e6fe83266389782fe62cbb2c17fa81ff8c5d64f014507b751e7a629ce5747f5fd842c99c1d1f4dd200c0f9197ffc104d3dd679d83cb81b6f350ffb5b3eb418828f62aa5b26011a9e1bba1246681919832dcfc9431652cb2d20ea9c190fca406315aa33be99a3832d3e297c7b82ac6dd993141012edf00e2b2e43f061e17f6d3437b8be364afc2d12a28843055748f6a77417c4647057885a2ab74b46511335d88fa9a97c62951578f204c93767896beaa4bf4e91603ba4e1948c4a0d65cac79b597304dc0b75bd152c5c7418937f9695a729ed2656c126036ac72acf8cb2adf256cf847fd783e1916802789b05c5a4c770a81804708185d564451521198d5af5525612a9c0598a0533f5665dce7d19b38fe682e8f760577e99841810bea5131c755bc2e69162c3ec41752e8325ad92442f8831b7a658ec84dbd39aab1e99c4af91d59e80093fa7e83e69984c9782628039c5f2affec0e0bdf27d831e1971a6bf821a93f979b0635eb32ef8426b8ecf23022928ffb8b331f3415e19cd30379f215428733bf909dafaeff3d6d37d44821ffe31c763ee8a32110c371e65e5034e1cdda2b9eda0103b0fcd6af2939d9ff8e00f578c23df7ffa8cd3f8bb41f2b364a46e45d732e92c3442060d4b2b0cf9ed329088ea22f3d9a49063537f0cd09630f887cf8c42206bfa20cd78b579ff28b40a56d39f7d586d95a577f4a52c254c9f232f5eab1cd06a44fd9fa4cf91b504f2b6421ea0ff9a20692bb0de2d7b278e3bea57b9d6c4579663b534455a83be6d0408bc55c54b220288199a4d1d1ed9d8878ea5cc524d7d364a7be11d93d13b9160e83c4036db7e8bfcac6bd076f2ca547a948bb9cd59b76dc7c1766a7d5464115e94e28839787badd85b1778aca7e1b4924b7a985bce3872a345ea39cd62e90f0cd2022f67b4bf30ce4cd9242e52380fa42686adcc98577e17cff751647e4af844d26cc278b4889ee1b69100790b48787180c45fa695787402e94a059a86e2c8b63740bacad7059634bc033b9162fcb532b18ba06c04425ea8a08560fb34a64a05c7b746e5c86f1e20555e9d10b3499cca68853c714cbd166d40e84ee8cc66cacbb3a31b1da4c620428f88eb7f0203c97d72385a244d337cdc316ca9db8d9f9c40197dff5252514c67db10e6b707d014520559fa59ea62435a8736b09766cc27e169984b0e20713cbb6622ab19e25a83434dec8877c04b3e8be8e892d6742b5806ad057189a3b4891143ac0d1dad06e13cca82a20c784fdd1bd94b30a109353613125b3d61000c772067e398a263a7f7c4e2fc257807641b3f136c52d4c102528179a05d79a8e7ecf1287c433d060ec8bf7252713212a4279c9628ff14e0c570f764b2a9210d19c2d231313c9680d04293c4416f1d8d688acf1bcdd85de4319dabb1be6e9742cef39bba27b2359f927e837362d6c42be34ee8f5bc1409abd624f43f90f2809b026f2e2aa05ee9e02d88c9b2e4bef2f3af172296d30ddce19fcbafc252a7c53c2c4b51b18e45750b4f851daacb6a7fa6bdc7223b46060a1fdea7a79be98e4283fd30e4e85655dd3e0ed50c746408743c2749e583fc45263e5c2472ba901876ce8379d6d03d128553c14260f437def22c62c73c79ed7e0825352995e898296036a6d16f87b3c7bcb2b7ae031aa856849d585c9c91458c44317a418cab091afc92095a060a05402d4fe553baa84679265bce285276a569d453ba4fe6877d711fb0f0bb3318a0fa5742ed2b05b100843a7d04c863f542389d7a291d93d88700c652c17a84b9173286f97a2a2c7a16da5580656edda919191d4782d112d65602b5acab4b7f1839cb30eb50bb9a4781007c022a27e123e98d6479ee12ede64e4988fe102204143991ccd9e24132d7dd02fe63c40b0a403f6bf55e9df1ab651cbcb8e2668dd6237cdc6b494d3dcbb5446da579817f97bd02b401e38d4d0919f207c0db482b2476f59ddefd249705dd999876e0e287473465c720e32715cb87cfe94ab306f2b8c6bec9c95f039ec2c9f9d1e2161750dc8b81470712e2414bca12479d02e9dec66cddaec18532893dd4be2ef5cf208fe1b162c8124cb713293850321da24be17b33f41d48c9f5dcb8733acea67171b699ad4d164d654a1694d7122c9c9bd12e5241b7297e664b0b771c6c7336bb34660a61b92a8eacfb31ecb8f05757c9034b375f8f23d3611631f1c1c8fb2510bdd77449cb5c4bcefffe95b0f3a4a75a0bff9626469389d5598110ef80cabc1d299a9c5ecc3fc41f7a4a80e2cbaff795512ca724c6b4cbb6b75445f4f37f25adf196da6ac2fc0ac4843facef24196ee2ff8e00fd1156822aba7587ef51233097e014e128689fb6cffefd12a622ef1282c02e1f7b46673828c76b2e6259e1a7f32e5dd4c6ab4228076092ece747f875b5a42f0cfa5046eaa724ac7c20bdf67622de85deb0d7b6bf5bc927e6ebfaa62a0f4039b3dcd42130408d2cd420a401375bf7b7166464077f5c4cb0aedd2dbd2c48916206797f05d4731fa6acae8f7fe73e6c6237967b4e36886c8a031bbf983ede0169043ec39b22b7fa6faca4be0296e35775ab3d0c13ec9822d5bc9a982a8d4e9939216c844bce6e0f60bd55645361f79573f1d6af132100ca0f5fc98df02dee0b529359f3e75f10e00e3001edd6295ba3985529a70670a5c7be8bef4b443366f98166d7ccf8f544c028112c1aae7be4a9089fbe2aa49953607d48366735b79c6e0038edf9798304837c05c8780718dfc4e122b79f1ad40b227dd3ddd516bb9854904d6f233d974869c06b2b69d52a23458ffa5cd36b2cb56a724b341dc565393f7f9dd548d69aae063514157a2331f226fced89af10496bc03fc2a8b67845bec199b943ee12d34ea73f713ea18fbed0f1d96093ecd8342bb4a6d4cc40dd8374cce79f4c8c79440095eb92d01dbde1ad7475e61b1f18a7613d0d5cf5bc24c84b5eb8e23f92ccb285551637b8829e68cfb75e72b331145571968b31d351c6ec4074e205d0701bc9f1de3932ef05e6c99605403088d2bdf43ca68752dc2ed8e2b2c22b100be4b40718a6897ccf151486d9646b22b4dcc950fd111d3e5a4c0d416335a2a8ca0de97fe6c6af4902ddfbf7cfb6134becf8b7d27677f6ae5b22484ff7e90faf787c2a20c99664d1abb5ca9e6f7c79859de40ae76cfc29a5ffc4e369af38630e7a77a60a1be3365d227f7b4bc2c89197cc1f0edc61e92685ea3e2ed6c86e0706e994a434a2f3f09c586000f776f60d3a6a1b61c48dac8da4afc75b992e43343a97f1a2ca213280fb8daad549ab40239ea97b7be33ea577be64f27f87803bc262cde54655d8cd67567b087be04221e80260db278f6cb8bd113e10587ab2582c9a009f8d0058a728a7bbb7346f38c3f8eaf5d511a49ed0447ce5933a35ea598b46641596f871a8316e0e2a6bfbdde9705966f43614ffb54b5b27858eb5f9e6de8711ddd806a5036def65d70165d588103745ccafedc95d156b2b819270a40aef6bc9873fdada1a9e1b228ff7d39ef87842844f6fee2386990fb1c206657c00edecbb745295a4c78803606012ed37b1c9ab975f48127277d0c9beb91a05d3f3a38fb2f0a126d3c48e5e0cdc347ef7bea512d6d7414d061af52231ed2a83b9f4a3d61a3ee8e3a008a8200f9d611b3698c5448a1c92d1638ae0394a0f8e1e250fae79aafd1f57a9b3065990cdf8dd812e33373c3d582797cccbd0aba45c1f88d57c8ddd3245890a1794d49d915b5d6ac101602d71593e50920eaad2f4da71837c12de1d11f1b8447f8dcae1a25905b0f9f13bf816707a46f4256358c6df8ac6ede7095a3a6baafe30daf9f1fdfc5f6b68435bad73f759b4a128ec881fc821b7f6e56b0aaa4e3d1cc96259bb61e49cab275e6a651f54cc5ec5c4826621d9c67629893a0d7a2f56195fef5cf9b2aea94eab57f4a5d6eaae911da8507f8af1cf2b9e8836d1f18954aeceb024d75e464d134ef1f62003baa57bff8c1db17523e7b57b04afcde11092c9721de78bd11f6f165b500fe66b393900e12a05af977538ec8f7e1062afa5ae3447238ac1b479aab3ad5548bd01efad5e4f531d179cebe524c216386f8ee69ccb469b961ee32863999738d42ef2c63860a85151395f60ba4b629243a713bb24f092380abd72c56a016cb4fa75b2c683da5d0545fb91f6d57e07db1ea88aef8e19d7b3e9d7991dc607aef7fc7095ed8462bbc286e19821021b3e9314837a0cdbc5c9f8e5b5e300684121f40713119c2fae0399c24827d296d48f0ded165009c6da273486e0be598107e2874c17978bf443a2e7a3e4e34e86de2838a9088c6c54f7f6efa1131b8903f1e774b1e010e8491da12fd1cdd063fe9b61990c093510ece58e0b2476a82675cff6f8712a2e8c98cacfbe2000fe60004ef3dec0fe8c554eeea57c1af28261b957e0317f84d5aa8fe905ae90e46913c22c4b5c462f547065cb30f7f8c7e33e90f5fe320ac2f507d77d00eee3a17175bf07e2785f079012d1019ca2e7725e98be54eaa2212a424b5af5c514bbccb21eb1ec595956d21cd5f9138707efb5433e27dddc5174240379da83463ca7ada2b8f9f1564e385ae47f99e121ac0f76183c087f1103acf2bb71b520c50879aa1b727ae502b0f499e73376c2c059827c274332384860037e7e65987d1977ff4f79ecc4c9c467812dd068a7756ed87187ce4c10876eb7cb23847d5f332b5e475d942c90fd8189e42522c2c8d5df99bbb7830af4e6c0420c63f08406d9289ad479caf3435e83d7e8cda457c3b062c2fdb0baada11460a349b3126d643d124624937b4898059bde01e12109df025a3169202b32b8a77b84375c497d9b36729f01532c1f214ef496fb33e2684471f30541ad1e6a5d6e9849a51d47be5f1854c3775807d58f086b53f219bc5b61c0e7088e807d0e1f745ee907595636a926468e512116cb18a67a1792a80f6030a25c7e107183881c78a726e6d2c407da86f509a09520faa2da154211aaa43e426edc66996942876e9c7b48b9996c97581417e7f0141c0544ec46297dd2201268f568530d1ef21835496a102e23bdb39e7251f5880fe5efdc2d5b723e6a06c614f2cb969f4a8625c2aa03f916896a99d1269642a2f5624b2045e5b033260f1b552ed34bc157c72f4c70d6205a52128fe672b7b7b6daacd49cdd8ba844cf7cd7189de4efc394725993405c03810acdcb2f9a72b7eb190982763af43257366f2ad2815c2433f865a536125b00b5ed44b2c36ced068a33eeefcb002faa002f004e89c3a0950e2faf3943ddaed73085c93ba00bec35e99e73039345f916b8a3d8c5bc1bde9beddabc485cc543666d8860cc24ec137125e53fe9f50d307dabede27a5d7871ca3da2a32fb898529796214498a70a1662015224408e42e999d48fff26f5a134d29b2de603dac6a24353b0832c552c46ef820960ab10a9febde016be15168edbab5941307496dfe71019eae970a6ad3305785de3f159df463782922ade3029dcb0c07154a3666e94e334a5f8b8dc3860cf8fd7406a8b706fd6fb8bdce4c55a342a3fefef67e86d05d7687c052c61d1a747f367c95c722ef0844b0250119e0656f7c5c1a3d5ff1b233f5f57092e0487da81f69bfc4ee861556960217084a3f709e34a1107781df656acccbb7b3c429b872b0622f443831498ea943bd8e47fd7394f5d46c981025a8f676edbc8c5e91cbc724fc4a692ca2e182199318ea808ec68cc48c07bffa42f980930d8d4308f3b3c61511aff7a0f24759bab151afe46060dd73573d961b39076d1bf24ad60d2e599cb5ecb5a131843da20d2af5b389d888317e5821a84445fb7e15be10329eaac91dac58cb5f858f75f3951125fffbc2327bbbd170e9915128d27319f98a7f0a44c4c7e47b55b10e503c5df6b2a8a691ee23db2b7785838c9662cc497dbb0ec60021769222a3714e8ad8a7517a90f857c929f469b93f2d0075d328aca3596ed74dcda784ade231a6441edd295d201231b2d6b0f46e66ffed5767f148bb4cd804b0e19d5dfbd4c03672169cc9e67b7b30acd279b0ee883434f8eacd441ad145c889ac69cd987b19819548df0c746aaa1f6482caa5ae86a45eec500ab34f8a4d4a59a374d07b2bd931819c3185959a2912ddc0d99968768d7285da885358e9add667c04fa588dd029d978f54e8af57a2aad2bea213605c7b68be89fff63c5c4d786e8bbd43bc0936c6bc0bb875d921d75d9d7a869862a366ded90d379c954f0e341bc63dd6d515ca3eb5faa770a6ae9a3749aa18bce89d7d7da872616928f85d4a010eaec05b9f211705e9590fb7e35feb83e0114bf09385e0fe5195cec0066edaf704358b7e826b6d4b47e5bde90aa191045b33dab95ca4995739c230214f3e8fef5068c9e184e6db4da917ba6ace4571e969cb934a16f3cc084ba3a60f312744b903525d20673dec377118ebf2b11999a3d0cae0fee98296af7e2e29a64b62cec87a4526f0573dbc3234f38ef4f1c6e01ca8209e5e320d581a51887fd3396602053403670db4b3de9dbf8861219f7929ce4e5d00c1c1493589c7f8c974515428a0ea62cfa21233d207edce2a8fb00ce8b81a5714ca439f02b0167c34d8e6f5ea446811233ab66f5d2503e2b9a52b7b84acf2ff21fbe4b4cb1d8396ea69557d2527a35b9023ae5d2bbc9e08977ac2f55149ce63f2c0a8c57fc322ffec374f3b12bbc043afa9db3987fc973005635b6ed5ec4da95a4cf8915a7b234f86eb2c18566ec442b4ff4dac99dc76b622642b1b1190aa0d7755ac575ca7cad640c7e6ec097f6761c291ea6ae4492300242b34c4297474fa5881de945b4c9d6ca0c811a4decc5f9f687c58a73ea57f8455affe2755133a52d3716ed6fdd905b99c9d04312b1ba9fd2d6f6780f875e9d74695442f07b457e066e02b09443f2aa9b0ffb45fe194f01ec43076f45fa060f18e88fe19eb7019ed300e5d44fb17fa1e70e5145abf2ee8777778cdf6f213f5cafc9fe6ce9196f8ea10c8e966983cc789ba0a4e6d871c1060cd0cf8bb285c4f01ea9bcb44fe42ceef3d4f142a916c1f767b1df8ad6de5e034a40f6cfa92c8c3dee0ffab493b4d9761b9dc4c6e538853855b03b6e13966afe893934317f20ab720d20396874676bedab29aea3ce0df72c98257baba323f2919e3b42348fc2ef787e2c5e6b05868c1ce3af8c7345a30776f9d27b0ff19fb961d6f043975d8b2ad5dc69ea458a05f680783eed1b6eb1320578afafb1c44709198aca25aa7e4ed4a5e0b0ffbb65d78ca9eb2a6715c4ecaf407521b0c7a0cbd48549a726e58269b4130a8dd8fb6978af75d54122a8116e2777315ac405e457aaa1e10a1f4bb10400ac4a35b37bfe5663d8bfa06217157b5f59b4e413db0dee3bc46a775c407c4754f74a7250a914913072b6c076c3e497424fa8d3e66ea5fe0c076817472d4e3faf8cbf986b62fca2c46f3d8824c1cc2239d44bdcfb2758f23adf765a9cb2e8bedca1864069a78dd7dcf51598136af39d2e847fd35d8456d635906bb5b6b302e16b2b30a2b747958cd2abd4b5c7dff0b14cfb9e52113fe7c035b0f273f46149e85af0f6aa01f45488828937e28ca9614d54e9f0a4b36a47c4568605da94bc153414686f6f7acd0482574cbe7d60db5356c428a3c6b93fb2207d5f6cc12106a17d89b8ccdafae4ef8682cc6a23d87f69da35eb912fa1eb01a68e53c0bbf7baf8e71b513be34e2ea312379af92602f50bceb732424043823a40154dabb3dd870e0d75f0eba7864c9a8c3cf1128f40db66755a34b1272b94aab466f6078ceca55981cb0498f94b6ebc484735780ab757813ccc6d6656504487ef7b0479e1baee867c4dbe995e08d8fd6366255c8a7e00ab679fdf154c6ce18755cbb0ed0e5660150a372873ce5d72b48422952ec5cef0c34cbd6042585b03701b3a886345c2d66a00d307fb6cd63c1995e414aaaf8e4cd44c02359c311d2fa5001140eaaa103554d17aec1f25f2733f803508ea5e594da86f6b30c207d099713aa6afee4bcf6af134bd29a33f0673edeeb70f93154ed46b402f0fcbf16def646c734127f7b67b3b24c5c65391f99d1c6a0cc76cc9f603822b69d400179b7d278d55bbd692f8a47958eb57b0fe17f083cc6c6816d07073c072f024d44cc42e38b1589cebc08d2dfc2e6d0e691a5053d361f4bfbf8de481571a0b24f28755ed8f63ea27a8a1e0347a11e182484f9e7c3c0dae2a2c564e71437b159ba507cd7705997aebf97c362910386590bef083598cd5fa67bfda4c2bdf438a3febcb69d9272f4bd7818ef14064b15d9b67ca0a3cd2bc7c9bddc5ef3fcfefc3fbd423ecfef657f08ca6c4b8a6bb2c6ba8cc6db58bd10196f5bbe296fe50855530a1b46f7dc210a8f7a77b91aff8eb11b5a8e3df334dd44adac9994a7fb3ea8d583b85d6a09969f991dcb8c4c7b23f630dbe9e3b2abe25a164b7cbb93630ed987b548c2875d297beca76b780ddfc6f4b4c2f97001d04586c40b2afdcdb509f849a5d2fbced6d20ad1815304d9e811524d9bf373afe2d61617d4a341eaca1eb1cdf7e79bcfb6e53be5e76224e861e352051adc18fd752dbba6ab0d17785e88e1cdf288c04a98d3a7bd3fece49c34ad28659f3a3109bb851f21da125a16656267b4ba2678640139ba2f2e0102bf934f291bb3c81eb8f296c6d38cd50f50883546b567ff3472532e8802d8278b688070a3e34be33691801b84cbc2c6782fbbc6cc00fcff911ba8e66230edf543e24e187d9b1d5c099bf1c34ac1789257e2301bd23015fea8f127ede6f8fb4ae2c059bec75976ec7b80123e1ad5139bbb8a382d6dd63e9dd417146244946e87203f66ae0e63be610c48445079dd56245bf9c4076847af2878366c95439c006cd033c036da51cf87eee4be890de05823e2a9db142f367cfa52d7edebf96986ac664a7b39525a88906f46b3104f4700659ef7dc0727c5dadfc4f65f44fc465d1a4c0d020cfae3cd571d76ca85a670eac21d9a411795b7663e3d3351f0802cb77b0e49d443cd4712fd8f9a6dc4545942e4e8318b3e148839fce025614cf3469459e18655eb3100e9dfc4fdef9b231790aefdc3808fdd04f40cc7a04a11e9407e8fc37cc758bb5eef8e189edf4be55bc067610acabcb628b8fe2b055aae1c412f877dd2940be43316b24e6b939302e414bfff1db5d52d8acdee3be18213887b0fd62a1a3fe7eb9f95575647f918c725865381d294b77d36e9f4e27563911f6e69542a594153044fc8bc6b326814e7bf5f359a14324d93a708bf735a1bac13a875fe25f8e688d8b0a7b73d8034a3c3535a9c17b6739c5376be7165af6ccc78a0bcb8f5ed95448d41d1ca8e692a412c0f4c517cb3db108990984e3d040bf0b2a68e015fcb58af0f72f2c7e2b615e33e1d4442920bdeb9baf329ca71d8c45fad7118f0fbd2b5b2f51628b28f7fb15e9dd17b6ae5ed4d59ceb30cc850fd2cf490e2d95941fe373de94572bd6f3a6546cc398ae2e1a645198f007ea3bc8e237c29d039d02e45be4e7ae101d4f3952596a0ef0bbe33cea297926474793be3a000ba9f1b1427815a142720cd876d965195e49e255b17c21d599f57c1d93830a2cff270e2880f11c1c356cd8f634cbea236d1d45c2a20fe547272388a2b36fb0f7867f987018af3255f831ac243d8b12b86178cb3efdc157e92ae44a1cbc8ccef5b0507690d5f276cc2d946f5c0720095f50514f0b4970f726c8c0f89b5a3abc01c2425ed7605782654fd08e997972898a2d2d3275915504a7289855cbefcc37fed315253951e78bb1629ae78897c69c29caed09a178c79cf500d9a781881ab43ab1d8b7d10159029327933b142822e09ddf6487354b248b56a740c6465fa0edf9497bbb918d414d9c657bdb519948cb2e6890eb37acaa9d38540a25b9c6a35b17eafea60aeac514163e8fba153d3052f73f9c5aac82794cde68e2fa177f5e043ed05cf013eb6bf10644a62309704910d98c0e07ecb5bff80a89905af8a2d08107fbd2e9f40fb4d117979bab48f2fe0ba477524ad360e07bef4b133a4063212b20ffcdaf7820988f0f7709218db00fcba12eceb752188d8b0c287339d037f27d1f2290de75215d6242573e97a47989b0d985527ae2d8f529410aaf06c91a26bb5b0495bda6ee28c099efea882a33cd3434213530dbbad98fc410ac15660d2aefaeec82c5c51f8a024c5d8f56a8892bafaf42633e79814a49fef3482ea18c37173e9183838bfa1ec747b6512da80f329e62f8b2715064427a1132f6e8495e850b2fef47a4091f57d2717875a5521afaac07db96b758558c2e657dcc20e8eef51488cb44aa2c318bb223d0e3127a671282b056721a833929dc502326702ebeec4112b05c93f43eb686dde79582b0ee834799e0222fea9fb81043f38fd17b00bd54eb12361db54da50e2ceb578dd82dd6db849d43cc3679e7766cd57ec30436a019a34e6a357eb09e9ec785fbcb90075f336f80ef42e43cd0b86b8380438e3ae7c6d3827f575ef2e144d7ff592b1187e19bd54f10b201d80b6cc2beca9fba790cff5fc148c6eefb4e2a2bee0bb9def3e088eacb4c32deb1545986ba7ce10de658e17677e68d8d4284aa65a69f2175d53bd456b942d92adfada04bbd28300b925c5df4077941a0e1267cbb6b0033f7560b804e9919f71bec02f3838b06d081d3167d2a0ba02438abb9802e56924ca6c7c4e91f0cb07643dea2faf35df59eef230ed3888baaa6026d755ffc23931655d082a5b54db38051a68720960351e30e5aec7e59ab4f9a56749a809f5993cd07e09d575c7ba6e3389215e8437589077c8c66ef62dc2361df3fd56b8e4fc99e4d0b2f370d01e8bc0ce5e258a56d522e8a03983c9ef593c3d31b4e38786d08337cc92b37f375ce3b82fe6e0c49777943f94f42c02c74e6a8b8480ec9c0541985ace95c11b90c3992e1db504030f299d6884240634c635bbe06608df7bf925adf1d3e6240481b73fa95a23238d8269050436f5f657796843f169840eab4d584b29f052de2b4822e1af22386fafee4b1431403f63ccdd3a1891ac48ebb67dc1513ce5b358f371e64ec9f47e6a6a9663803c9ef7b45702735085e5529032900e64ca5ee143b87933387950f9640c0026714de4450e81ae709960a6be5ffd77a7912073ded1c00388fa2cfc056d149fa9faee36b6a2158c704a252219a31150b4a8ebb9144c9664949d519b3d64ae51fb345fc093d594c375ba3b405f8a9bc44e8318d41c102cda9a4854d83db4e2b8da2151a32a259a70e5ef3d2db3d2e5373972ad6705274b59e572304ee294717af7584cf69dd646f9131b7ce003315ba258b658e57fd0707f795315b5cc3fc9d5963ad8336463737e4eba8dbd5f242d36e530a4bb27f11eb3ae89a682fea8db1b7cb7c4b5cfe9d061b9988e256af6f11f2bfcdf25515eeda5f2e6462444d06dd02f523d7ff974bc77bf4f05c721e228744adba9006d612962db9a6a221cb93654456f65ccd1975c9810dd8ac852c544ca9d9b5b510af18206805b02b73758586b1da071d45cddf433995571284a71e013f5910b18d3ab2ebbe7684208967279912aeb6df7f39ad46c7d3744778817a998eb8a3d6ea551710df8d6f51a03155550965e17f2c31564d4057333e4fd5546f41c52c3ed5be9ce2a0190f62b44358af12ac2dc2765d49f67775dc6a733405e1f74f58b13c9dcf0f09084550e47e70b05679aa048a0224954366c7ac6304605d4985da5aa3bd689ba6c351ed9947cfbcaa00f650e8c39d511ec3ca80c82ed5ba9fc3de89ffbbe474137cc5b368bb16d90b3b60ff0951cd97f962f96532219f3ee40274f323f13ca51fac0f38ab1fe7749d478fb9ff2ea4aef5d4aa4e28d2ed8224c589785a3343723b2ad149cbd2d456c485801288885aa35e183b770fc657cc1bc3f4ab8a98eaf0ebc677b1f681bed1e6119c492ea6701fc2ccc2f825bda65e642dcd9785da2e29edbdbd015b6394575532ff7851345731a0f474c81f283a895783c450811baae273ffe5711c5b7a8211d857cc1288075333855ecaaf87db456d187484b86d14147a1197d99dbd0b6c5dfa816dce1dbd56b9bbc208abccd78a6e77cce7e08e2aa12fc79e38d97fed4d25f0003fc5f","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
