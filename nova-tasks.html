<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"99047c6b41c1175124ebc7158212bf9ed4f0b1868374cca88c58dfbe091329b5292cd232164e2042d377420430d5e4d47dca682d81d9a2195f853755207dd1d676495bd5e0a8ea447310f6bea7278f30a13e2ff320c3ab43f8b6e644449f160e8027c7f2403833e79b1f15e079dea683ab1085d77f641f940bb32bfeae73d398744a5f75f95c7defddca76a23ba5e7ecf35c2a18740fda9273a511937de5e5dd94ff85f7b3ec85c60bfab5003d6cd1f7660e541a6c92c3cef4ef132e63814fa0dc7c6d5069d6f4f6ceb29c03daedc43183a9db8ab46eb5d8e9d9e3a9b3e17b5635e39521210cacc26c9fd2d176b3d2b320c816b05e086c696c8b12ba149f43e3ce8adcd6b7810ecb3f457beae39b26e4594db2cf53d9ccdba6e86c715f1c0a9b80e63823a1a24db344b6641cb02be1fbaac2caaa8f6b6eaa7426b686ca9662b1f9cb23f57a4d4ed153d05b7c97e9a2d385c264d9426adcb03811a11c5f831b0e910c47bfcb8c030d2a8d4cf001de8b6edb0a39d9ab9b34b7fdcdb5f9f0568b1003ae2857aebc185e7af196315c7c1028616311a508b091f10e7a5a34a58fb3c0b985242f3a1af9e218cb17bc754b3ee319de1b6eaf869733ab01028933bbe1d1c2950b73aaac13c3ddbab167bb0b8335f6cce1f7e2f2d4457f1c7510e475f8afab0cfbaf3f3c46c230109a120bdd092b3e19b67b73e3281a39b5592cf497e4aee4eb8d5224bc281e32237f6492e09861761a4d25d2780d43989ca39a3da82f2c4d07eb21c5d6ff5119227ca6d60f1092340f2447d37fa6a3c14fac9e8571bf396405ec5e7240f196a57e6502fe43e4930e12f7263a882215ddb5272b51008063edbf88e0c22e462826575c34e5fa021ca5402242e8b6dd3e261642363a3692536941785a7732bc35580ee7d6d08295d4a61d1b14394ec7da0f06925e67ce5fbe97b1b8da480ded25731880b72697a5567f852e579ac586c83aeaac3bb517212cbcb816ea2b910f4bc0681537a2e4ca10460b91d2b979f0dd1c944a3b94b2b9370ecab9f98e45ef4ac2b0c949ecdbd41313c603b768b5fc781ab3a84693b017c4bc8ee794f6a050c9464559997fa709fc4cd756b2ca80d3c948a7718dc06c15e952e3f96f66a528f164c98f2e61c0d31c721e3184f6c7688729e1cb8c8bd118e747c0fe3adb58c45f4ab2ffa4ed4e53b4611d2d67bb2b97c1d2a34b9988adffccdbd43b628ec52070b3d40f5fa18fc30247f6b1545fdb58d99876d4efabeab12f36fc64d2632bf2885151c4a08aa11c46c483b28c8803e32cc68dcf6245638dec26f849ad03bb4d4901efb21c6a9e2659a82e572241a9851b855d26bf84ddb0dab99e2228889922a1b3ca75b1f68074241ffcd41404cdf2ed336f567a0ef98b3f4d4f5efcb4d23b13b5ee9378aebfa36d0cca4499b1eac2675b29da6e898923031fa31b66ffb11caa82e9734b5524ce14cc1a61894f36934f2d085bef4a922fddb9203801641eb3ac15ca45ac0d26d59b3ebb9b7e3d96654fa2bee0711780725117e9e9020b73a42da93143d07392d4084559b2ac6c199917c9a171c9d2566ff2efd521e8c0178cd7ce01539ec6d9425cf53d9230e9f52f41c688aa08cc03eb41e2d5d015b4600c12c659be8f01d3d8236b4f97847d451f618a1378ee228739c79786c6def8d936218606093a78c41076a281a06fd31686a2b1770aba6d363ac237cbf7a5f7af164ed6df3cd8e728a41b3dbd50b94b5e80ef4d16f4901c709be40f512ae277dcb621f9b137b3e0dcd1adc4d706df6bd05105ab84e63c1fc63f96a8916fd33ab539b038652d4f763467f5bf561d6bacf9dc7cc94696771ab1140c00b62f22934c5243c939f075d15825aec49a14d946f51a1d0e00be03a84bcecf3d3042317d685e86cdf62d4475f7e4e53630c375af40de540c7fe36becab40d6cf6c0d266f13b92c1e1db029f1c34e06744c71ab299bbedc8a6ca8d116921deb122a7325209afc0bf3c1643a7084335a7d0d7c7db5ef0bdd5b7a32247f7f1b9d849e9f8f293b1550651216105e9f8482ab30ba1511c5f35acb26233133abf1c62d1d65cb34d998922bfdb22f30605706161a514195d85576934816c639957d3be7602d4b2a0c36b36739547afd8c8f2af6853d25611d644cfe4fdb32cc5c22dd02ebea1a1f1dc3b6fa0def5a04aaa5ba4fa3b78c64523394563592981fcbdb57b510286e9a968f2f04875f039385c4f95f05d367e4374eb41ac9e9f02ad837a2fe4110f8d6a7dda3605a055840c62fb97b549b7c384f089f537da1034604d32d75db7f029e459c5df1062d9f6ad6d00838876f7d6b35b7537917599431027465435833a8efee88197e71ac896fcb80da31159269a27e23a64587e187e89318b20d1ee2024c55901bb6da9735153662b40e81c87430c9cc8e48df4cb0e29641f82a9e16ae59ec5cdd7cbf2c70519ed93f8cf86004e03b1c0cb31af593742d0f37813fd4465e3684f3401c7508e2a25c266e93c617810104725c59af5ea42b1e2952e4c615353edff046bc1284a943a2d2b53667e4a503baa25265f74923a780e6ee1cfce2d473d8a9ae7fd62b29c1a23b5a17cd3dc5d0d577a0e532a8c1c266215a75d0c7d509c1463f4e9f8744e1c16a74553517b07a38b0a727949971d03e78e2265c776921dedc03f18b80c04b0b6481e98b2d4756b25c0f18b97ac71401e5a9b7e16b4f75d9c429b82ce65e546a9888ede3e4e8886235f90616e8b162df41d7920ffe458ec9b98dbe151f9dd61bf80b2e4fbb25d45c36663705ec32eb3c1450cc8bdf41f7f95d51989eb42b676c46de88766259b04cbe5311b79386faf869849bcc39c66a96b791e080ff0ea1b222ac8477c50ba5bb99a5681deee295ca095a233759ed0b0fb4c2d32513853c84d1f2fec6e90d9cf6d046d7250d035afd8f0c9e634dbc7b5d2a39b3f3c74381253c4f44d27551a7b74de090bddaf766bdc830f3c5581c27aee2bd76b96b8114c97533bb4142e05b1b2f2aa2a9ef656eb22ca405840b2a765391f4affaa5aaebe5351f5cbc937beac472bb47f52d95b9a18ecf00368bd1fc02373fe7025858e450b61157c3171be08252fcad350a6cce6575ae33cabd13afbd88f877392a8cb465c49196e4b8cd0ff80aec4a6ac2388afb9147548b5209c1e8f846d8eac92f5719d1d1dd0f44a60b9d248fe8d8616b7af545fe812206cc5f13307ccde094af091385108d68ed9318fe503196de5ce0fd39e2926e7d3bb68fe2ea91f1c96641e14a36211799710089c0b5ee6a79311d72e385483caf9bde797b1a99e9b2d2f7cff1635157141a51983eb7c4091af866a6884db74cfdcd06a1e211c3c0817139d3d5d3baf6aac28a98f2a4ef235e343d8862d64ef39c62f311cd45a3a01ed58d35921a8e004ac6aed75ad87651b8a1e81ec328576bc078ff90b3230d1f5ff63be4d0e008fb34cc50e4f43e64f8e384cc9e17a06311630fe01d70620029f9a90a9a2e5c147562a6f3b5b6d5d87fb47e6da55104bf5caed883326ee31afa30698d6c662b6349c6edf137538dfa64986bee79767375230a63d6330301a0f51a71f2e2a81c8ffdb48478ae459dea0222c258eaf9cf7b1794b747521b099c8d228d1f5755a9369835d1ee29d8026a64480d84fe0779b2d64fe2cf64486b4ed6856ff7fb48aac096fa959f7e804bd4475ba7a4283772eed4ec93085098f69f74f89294d563062cb673a20fa61a2861b0ae661910f714319159d13c0c04e87cfbaf264ccc7f4dd14c27863f0481f91f2cead2785551fcb9560ec5a39dd515ae3263b46842bd6de870bcf5acedab768d6d6bfc85a4c0ff657a9727ed2451f1bebb25c2c8c8f189615dd4eb2744e14e3b2a1aa1802a9d4e0df43bc7298042e70b687868d66c93014f0d9f6c252a5165bc1e0e58432c8f57a906ba617490575f65183f8c1bffee736502935e0c90eb4056c164395529a068912a76e294e744957d21dd568c32eb3121c65ec5f289c4f3be6c29a854cb2f2b86fc75d2cecfef6f57a00d68d6b61d377e08e0710dbca0c01bb6dcfb22635b120569432eadb2f8873defac92f6d86066bd855315b57a337fe3d587935c3703f9663e51fccca1355a9ff67820dfed7ef118b40bc41cfb2960d96f80836159dc3e5f65d79b7e3828d4de55475fb722626b603e0443efd69bffa32ff2eaf31dce1e92cae3c38ba56c3e24d928edaa4aea2cfabac3ab3169aa6ebb9fbf23300381948c46a7a7591fa63e033f69ea22266da701e718a93ec14e011dbf7d39d03125b889944f515fa41c02a369c532178f386187179923195c02c1b134d6e0d2be281d78a65faea7b76f9c720705fd1e1c97ee049cee36e2d4650e161afeed11554164d10bfd2bfb0d1d2bf7b6e9eaf467e610e20bacd444ad7b8b6d3197859257ae70a2f0b9fd93e8803e74a031c3aa713861c720911b10ffdd329de8eb6ec1dfa3fb9fe54a0b6ae0ef57a7ecfe47ae11313ce8472836a93c1152d0b403f2c0f2a4af950da8edb4f843ce9fdd93a60736e3d8546577c8540ed097124588ffb541f83938f0b3e68bdb90cae0aa4bc44283fa4673bc74c7a09346554fa7817af395bae7a03304c0f16b38ba39b0f7ed33676d0afe9dd63c1e9d9c0c2d6f89902ae00f88574151ba4a4688ae8e865f0501531fbf2af693446185efdc7adb719dafec88283bbde0887b981899201cb6ffd63b152a01537d9197c8ee49851e9dfeb259d959485bf6ae9cdcd3968047c42afcfdd1961684dbd544b255e57cdff23a482c56e61385135c3d0b5b24710c3769c472289e804c0061709ed5a54f3023e04ad79be221776f12de31aca9f26a9fa57a23d00e79d70feb402bc11df8e9ab7c3116c58cd3c31c3f683a174f27079249c8769d5815704b3f73679c395e97b688d6b5990811caa31d80094c181db0e3ab450691e494eaac01f86e6107533c42e7757d38df06ca71cdeafa22a8ba6f6da3c82cbe90ef44ff066185279c593999829b2230ebbf77c28eb18bbbc607b4964b00e0a5a2711648eff3d92cc56a356fbc3a0696c305f86f4407618d717f838f50f1feda6977335e44386f6e4150884502fcfc2f5a91d37bfcc22be54e21e376ca9df5e050d1949c24e2e7068050d3511ec0d67fa36c6c6c8ba495d5536384c8a8a3bcdffb5542a168313ae8b8ec697decc5b81d30e886096553e6e6191d4adf2dc8fec3b60586ce10758d047b42730e20c241b93f0be4ee57109d4cb44258ef1d51fdc4622874fec4c7f3720b876f9b632324c3bb0e84b0831202da9592591c5da52510ab26d16b26964c688113b3f18be5a53e8981fb54a42fabcd10a63c3a2594621b17b76abb210110c760a23a5c5514545b1f15bab3dfd31822ca79161312a80bf2a8ae2edebf76e3a9dcf2100151d28b44011b0df96d14e9619fddd1776123dbd8fcbc573ed86f15657e366db758e753df5c17d103761a51f9c681835ba70715583455445d5613e2021ff9744e2417e51ba799f32d1be442108deccc07cdc62a1bf2e557b0644fe12c25d3c633fb0e14491bd5f2e6ec879ce71a2abcce4d2a092946cedf939e95a397f32fc4923d7aeeadb58e4150075c6403d6ef1d83d194dfc4fc44503374a1d72bf8ff9d2ebf9d38b1122cb683ac43a150daa6e608059d6bcd2242634f4b373db9d90d0174a4577aeab7ebba353fff0b199d60b17de8d2cc2869776a450d04a57428a904db22cb7443863107d73ae9772cb9d2e2f419d1dd874f1b8bceab5583b056d0730eb32f150e9e30a05055609a194be5be6510fb29a4fc6d5295c4ecdceb8ae6c9064fcda45b88f1956204fd752a0a422c35dcf88db3a9326dea28c974b0bf5e5ac3d40b748b812587aa01cd20fefc7c68440f6270c8dc316d0ed9a537dcd8a04c98ac7c803a0224c2962bd90d5edc4ff831e808ddd33015dcb10987581520adb6e10867dcc044622f2c5371b491c729168059f3300bba09087e394134368d34933bdd492b898ee67554627ca9d25cdc891a23ae50a735d0ffcc9c5ee6418ac9850da0ad119bd8ed66f4840bbc59a6041c99510f3dd644f0028fbdaa1accce7563b420aafe653ae862640200b844624e49c2bdfd5e19b23ab7e6033652534d785d16f6a8a26a55981cbfe3adda7e78244b58f3e19608ceeb8c68ac4dd818afa1999b0fbf0cc4c6d1efe061b80983e743352d4eba380c866b537810827b146167e0fcdd0c5008940dc4db38ecd7df989ce3e5f52d290131840f946400724773b6f2302b2cfc89b1e26bbe6c16d69dfbbf602b40f7c7725896e49c619138fe1b747261b24e20da58cba54f2bf54be2068f7af308b1bdf37da46da50a6f028f00b58d7e0fdaaa418775868a9048200df28277637c6fadd284bcdff0504b7bd27e438c73bc4523061466829ac8c969cecd824320a43089a43d5f6a5a9a5ea5ce61f64b5f583354e412f2255b27a40defacfa4d7083b9b1096f4bea3396a7495623d45a14ea2934309c8dc5d58e905f838135a0581e6c82ac9eb006f15fecc06414c2d5503eae0c31471a7fd2fae896da1101cc2ed60dcca9ee556552199606c2ce851429c28c78c4854f8d7c37d848e5e69fe770977532207c726c181133b9aaff06840a48be7a273caa46ba80871e1928ead0e02eb58145140fe1f14d0cae8ec279651f3c3a4f856801a586b60cf35234f8c775c256c49a34a9da963bcaadee58dd6702ac3d5756f918e66b2cb586904346785ae076055ae49651dd9f8e3d3b852e3821a0173d97455105598758b695f7c44c44b0d5a1839e0917a17fbbee1d7135564582eba1f5f91625a400ec3e4b9e404230dbe41c42ac4beecced83112670849f8e50a6b09b16705c7fb7ba1d588954a829e422f9833cefc1edbe981ba2e351ec60a30b4f92de5fd15743be749de7a67ee0128279d58e5f1b53aedd815cba1a163c333e3d4b8d44caf3d5b49a78f4b946040719b55a0e86e068456ef4cef1c2d5d1a6b2e3535636debad2a86663fc19acb390ceccff60f3aab73ac065d1c63a3f0a377b6ac5f97d00d7c6eacdd25e584771d8dff6cae16e0a072c99f9607a3a6b5329368f3b9c9f314b9c0b15c1ae032e52b87bd2b9999b1799e2d13c21110e6783c493ff5c3b383f04f9447b663ce316c24627e35e107ebb103f4d36b202ac3d873d34b024f6e7ec8ac9112b820563de1af9585745a86ae9b05ad902fbcfb8b3162a408bfe4dab47ffbbe80c9bc518b5a338e9a9ce5efd39ad8321f6b1fb8c722ae15e940be64f1060518488f4fc2b3794b63fd96dc7c0c427e575dc316472e8f10caa99a1b4b0a2316ce930ff4e84bc0614aadc907f053b06add18a5f5d9562f5b912a7f725f121b249d9a5936fb32c89c8d5066ed1d3fe802f0e32293b035a84c8f1684263938936bc5eb923b729309d2ac09af727b3ae5adb23b892ceef272356c9e325856850629cff38c54da8e3db5f3f3168378037a077af03eb75c9f08e90c64f53cc270fac0f2d886a9287d4b487c4447193f2d92aaf7d1c9c55c0f918da78da84ace407c9c47ebac2ab70efe21ae3cd747aef9c28ecb0f191d515c294677a6258b5909a74ab59bd7e0044d7ae0e791f94cb544ce4a0efa72c8c808bed3c90fac819693cdd6a5aa6ab65e09c1e225807d143d693aa157add1b7d3c6ec22c6ad8ee04f6e2427b2ca1edaeb4be0d766714428b01c11d36b3c4c3182c60147cec07a473462c0b0a44cc5b71c8608eb22d848ca02014af11deeae77811435782ccb95e48d7c1f54f03298f399d68de42d0f4624d58872ec6aa5cb99ed4575e5c1a81699fcf98d51a8f34e12b137708bd102492c6d74bcf8c4ef0dbaae26ac6e02240471da7675fd9b62b507176b7935585f880ab608ef4b6e5e31de5a7d389c62e8978dcc7cf68c70d29d16e4f0ce07eaaea1c3d6f0f6d5c9c7d89e080f395bb8ff07c6d662b1760cff6669893b98b33fb89c3d8c8eae99fae43fe4b6088067b8d5c57cf6d1aa6716e5589088b0f9b311057e5b53b4d712415f091c306899ded85ac2e7736bc134ae7a952aae140e9c65ec8d51cc0cbc27a511ffef74bb82f831c8da702d1c4757b9acd389f06187fdfeffcd7ea19e3535ade7244e224d1847d72bc891a4e51214492ce5be69b1fb6f256a90d19d9b3d8e7fb18376e6cea62f0b7026359665d50744c068028f99a083c27c1ce8edd64e76d074f21b7a4f338e65efdd25b7981c943b4a9e006d482b2e8d4c69e37a5241addcae41b3db45e6ab6e1b1d1cbecd652fbe759fe07f618071e6dbbe418a6c03a0142d428360b161aa14d51cca34553877a7a7106345ed12b35d596c64c8ce4fd66ff06e51c201e37e2077fe99adbbcb58d3fa58c327cca6388e08a84908bd12e077f6709b562e375d7f8e20b455e6230a0f28df9b2fe1ca5b550308b0087914da5735a7e47a5e613e2f45f843a4bb3bcefdc403bf334c4da99106b3a164542b299157364c2d26cb53c86afcafa7d0a971fc97804de173cf787bdb971e8534034145cf1a3e52a14c465b0618340018cc64759814c21de690f1d7bc1d358a84f320cdca4e35940bad8365147aa5dc0be423618ed9a20622e9004f18a4d7f24cbf53c434c477176a8abd68973df7b75cbe6526f7431e939d94cb8ddff733454e308575258d32af54aa729818d4748cbc98797a98d369a43f3a1d2945707f5c365133e452e0248438384a25203fce4b9d31f043929bc604cb6bc1b1978f4402e96b899064e549188d5a34958483504298f1e64de3622d9d8924b316ead492de1c67a74e0cebfe35165270014bc50482ca8e7b5c680cf799c059565b0da20d28de481598a56852963dc14a6f3047cdff36ffbb0397467a35cf685f891eca8694162e69d56109757e57e706e38eb3dd443a41666745af101645816f522d8bea53c07bd0ae7637e9b93859b7e2f1b36c52cacc5ead038f1c7ec0ebe47ccc16808943f044a9b272155029f16fdc8a29152f80bcf25bf113b83703b20916fa6e789775e4403323506702fa88b6acf22597a4a9397db2a67b4e376a04f4e17d92ed8b3091b91a24d2e2f1b640fdd64cdc1289fbd62fc70b15bbb22092f9f0f1c9a4383997e2fbb94a1dd6ec3ec63621a07f863e69e7998ce87028930a42fca60257cc11f236f931722ae379428e3b16e2344689363958c259a96fddbcd95cbc5a7f275e634e8d34cc625e0350d48de378e7647dec34e10307b607f159d25d5794a64d9adbfbc8891818f28dd9b6894487e5a0cd162007e91d5a692841c718930fed926c1de882e3f167c72b33eeef1aeb52ca365c8e5faaf031b9d50d82d7fe38b8d28c0aa2aa893a9fe007a8b457912864cb346eec80d8480ff49b821d0726111c5b1d73c5d0cc1d53971caed2ae7e0e52309d58b3d36baaf59e25c6eb51bb26dff51f6af31e3df792ef3bc43b5dcc91b3b7560f3cb9a440604641cdaa6355c3c160a6644c35459e7ef7ce49fbc6825b92041e3ab62ef8637d84a7bc745c976762cdc8156e169f0514d7fca9a3f224ffb9e0cba21f75485bb5170bfd4e70a7c16f028e1af760a804f4cd80ecbb7d51aade38131e577d414da11f2b103a6d7bdbec98a5930958b79ee335c1b6e8966ee1ee6ba442c29879e5549dcb6df3a64579b7a5fab9347749004e468be86c7d7d67464f701f2f8870dcbb14c61a73f44eac17475de825373e876fc80c8cb956c4c1d3f0660f613dba9da092f7fb4a14bcb6a0d4cd0f12fd3ab309624f39e66967c285ebeff3d990ab5e6c96ab2bf0c2a90a652ed3416b74af813d561588f706e30154d09cda83eb9c71f52e09daad7ef3c5ae6321e24ec02b012dc47b65e6515c70cd90decf896f4f36d4e519b6bcce13501eed777d1186f974a41724afd2c1e8dccfd68b8483dd9ea4e4a4f7bd53d1c9e75eb1ceb297bca84ec8bd63fe6be0525ab6bcafc694dbb24b38fa78fc682387a087ed863072e745415a4510e8d33e5b9f6c0b5544d271da879263dc2e469df1c14e0f16a962a1d0fc03a09d324087853a940f18fd757148dfc6e25de9d5b1b5c5f8b4a1d9a871a8e1f16c3c805801b9c08f18be16a1cd959d789d61bf58b32ceecb2531606a363833fe4c7e33a5ff63743aa84aa2a3e26c2d24a8331c9d31071d11047da7889442bcc6c5833ddd717e492776894227e5b746514dcc3ce1748358bd4d5611244dfd3e89a85fe4bd2c2e5e4e0909ce54cb53aa84f8fffd0a35a4fe8db9c7bf23e2935b71aba92cdc3e5258e46d60be01e1a70835e10d05438b91fa6b792e875b73e9505113fd2e9887fb97f10ad03eb06039791fed08055bbc4d3853f8be169b91813f00af2392008bd50fe8e8ed0c55189e161cc902c21aaa391e33fe48fa75f7227335e71f9d82ebbf01c8a7f2daff7ea6fe0e73268784ab12552dd0b36a79efb4d6caa086a32616c70b6c1b5e54fe9e5d2c742ab7eadebeedcf43b09062710c01bf2b9e30bea762e3e3dfaeb8ab9bd3caf2c0daccfabba0810a8e279fad88963909c13b89817f210e1d6e82a81db7e505242472fe68a489628e83c2c4187cd75814df4b63e66448e7d849146f53ef7526737568a5adeda525b830bd32990463c333140de8fc8492b4790c78b41266280c9cf4265822d326f1241c17d1e7b715f7b8ec005009ab839a5ab9cfb4da55831ceaec05a2d9295e011dc6a7aaa2d3ffae8518dccbe6cb894583798de3f8f3581418bcf026b8fd8ba76e895c044ea40d79a7846c20a7de4453919ecc2f82dba1c0f1eaf07c615ff6dd259d697f91f1329953a3ac9343c36acce09214ba9b1a8c3c66d2be2cbb3a94c8d2d2c3371e3764d16cf16568ee749c8346e42cd9ee531e04000217bca86ef56a566555a561f32ec6c981a79f2cf77abafa9a7b0775bf7719f450cc90cf9291361b3171309ca5aeb2a66965c48ffc315f818dbefda3c107f36bc1ce8f9c287ea6248e001b1885a402087667a2ee6fd0aac05462c20c69101761d640ee9d5d59401eb6c9f3670371db24467a95c41bdf887f18fe1f0fc6ce05ba1f4145d5fb58581a45140357f19dfdbaf158360f43262d87de2cc7c6ac159b75c95772904d95f67098c30e0a7a8a74c7b83f6934caa6e1e9e1b054cd229daeda383bedf5c18dae2e4ea7f7f1dff947c85eb7203172d0485394345335a40018ebb85fa6c2c54ab9c7657993083661956e6874eec9efdce4b5d5c5193daf5937d3679698776b15404fe1fb85ce29a0620f66ccb86ff17dc3e97321ad251f6a5e969912967fac025620cee2225e2c02d4530d89b09db4c97f49d927622e567bf5e9bed7221d408354f580f682f81639f6daa170ea6bb061bf3571e2bfaa6fdda5f89eb113ba7e8a28b61d1130315c8a0fcf4981003a769042300a4cea550f1594b2540f46d4964dbc28b7722bc36e06bdb0b7305366bcc57f34636fff2168340ce506ee055167272e9d4467eccd175fb6116ea92732be3c47fb3731048a31e30ef1a7b64298ea5126ba43808125376b0d5246783f949606d93d847ae58f0c001cff9e45fba7f46e10d58634de55a96e2e5bc1fd72b06434d748fa849cb4ee56b39c6d2385863f30353fae3d75e461101117b7d20635bf2427a9aab7d5d2cf015b517f8b65460a4dc6796d5a5d84d32b96ba8d1809db9f0a923a9b86e5a9511cf9bdc22e046d96192fa82c01c31441b115be6dc679dc13d2f595355cbc166774bd947d6f18709d6cc714ecc92e86fd1db7589670c9af3fa788eedb809e7d5ea580d98dd8009976e4acc390dd9d09b51783979c271b2e5dbcfba764e1f57099b41fbb7cc69a600ee34b6e0e0ff072eb312e5a1908bcbcab4f4e75fd2f91afe1d1aa737993b5b10ddc1f568ae872a9637b52a82163912e67e35a434e246408a029596b116f46058c7906ceaea1521f5895fda4fdd0b0ed287541afb10ffbe7adb9ef2f4136cb74b79097ea721b836af593bf48e3c588612849443d51a0271c5ab62f1d47925f7b4ba8ae9738d918a82ff7769e31dbeb9646b91ceaaaa5253445bd541c5767640ea78b2a4605571e15e7da31d35d2515759a4684fedd4661dd81b9aca9221f4bb03ed9701a4086f027b540589dcb2ffc9d0f959de6521ccb300f7c9878e81c9acafb417ad9c504df1340a1dc32f225baf9b8c6f100f5fafb1738ac30baa5a4fcec2655ea2309c20429e9f45e30009353fa0b9e7b76d90d13c99b49ab606256ffc1bcef099531d60ae1b35f9e7ec5d7099e9f8e1b9c0786993a30af88e42c48c4916db85aa0476d8f3cae12d484b0aa1adceefb68563b3707052fcdb9d52b222068f6558bc96b7587a75fb57dee5e952562d6c485ec7668c36d3afd0e26cf37e66f5d9284fea8433aabc5e48d818ecd9ef28d4d8942d3078e933a965c5fa65899a9b0f2d19622dbed8794b86e94596687a2f429c0db8569fc1329be0819282c61f067053a186b569ad0c063a5723f16c3048ec5dbc189e947cb047688a6292f7e1fc5d62425f6f23dd3bfa867dabee6412dc18c683c813f6baebab1f20ca3cfb63aab864d1b682e3adea3f6108508aaca77d9327003cc1c53a37e79f29484c9f4b2eb6869ad6800c147aed207fbab0c41c6870d1df3ebfd30d2675b8026ca26ccea7360a608eae41317db9e976f67ca4fbcbae28e3f7cf9dd5a636af438b8437bcdf6e2455bae49110f7d34855a9bf84689d087570a90a830fe8823d8b6311a594f8ea1de0f681e22724ab7d2ff3e0d082ee81f84ddd9643e03b08d28e73a8ada9e7c062f0952e07bc8e9fd6ecd975781c2391a776e0fe125b247d68966ec8611c6918edd082c421d3d802d50747c6d1867ca5df20d7606ef5de49ecc61f69e27600fccb8018333853c59c4695d8678a4295da81249c04c1ebfd6fa945085693a4008756e497a63f45359f5dc0b2ba917b089e56f44dc8b6a887659c85876094a47d3aab52828f8a0ccaec952904cd68e2d545f23dab9d4f8908817b6409782d230e6938c5c333233fd0b31543a5e1b95129c7348c03922f1e587c059cdbfbe1d15a3d6cb75fa1a2318b8e12e768043eedff0fcaabe7e21f21a5ad99e6db7214d74a3bc6ca032a5b3f6751bc9ca14b2ba43496e6de75c674d4ce81a17b3dfd09831b9fc6a86fda2cd2dba399e49e1d2f3972d73a3f11a2f69013b6fa9092df48e61e56110e415248807a4de622d9f885ad8a665010ee4fb4906d20cea28c01ce39e44e215e498eb776f375d37977383e745c30b9257d0708162c8839fd80a2fbdc7f91eb6b49e1840fd7ae91340df73581577a6ea4f88fb21f2f54388e1be069eb78ecb29de1ca1f8f7ca256cbe3afb11c27fc17d3352f1e16da4f0ebe5876f11bef4cecbf3cd4d356572adf1fe57fa45f26657ffe0cfc60bca6b9eb290f6785143c9d61faad695880e4282a49fc88eef1bd829468b917db4fd26b1d37d3c1263dc2b6c9c6e7d8505ca1f1850807577d42192bac3adf9a352f5695e6411327e22b465c4adb1dcd77fdb4257ec394a0876156f742d4e7df1891e33757debab9d76ace57c31d68248e51811ee2286eb1ad18c778e7f6fdb83a565bbc90ae544765a0d40d8957b23539506eb28e0a51824935d678660cac89be08dca5c829b28c8b08b1decf792cb310099de39ed964734b304cfb3725bb3e004ab7e2f3343a9efc86fec37b99f9294774771e19fee93a6f6f3681238ba6cb55d71db3fb838d0062710fb83437178c554ed1ab25e5ed0301da55dc11f25a30542a0a74b981e0be47b2e1500bdc9e252f57f92e217f3e96d05781c6519da3e0df020074113a68553aa48c4fa2b1dcdf00a81607310ffed5efe10e55d78487e32c733f69cb0125cf23a570bd91e5d3eabffee60c9b4f8714a6f08ee16b716714e6659c2f0568839ead7d6be9f39d014416b944cf65160d65ab86e2fe98742312138f745603c683629fa2fd466e54de59d0aa7697407c2ba69160110c4f9d9548369000445b71d56d7b2ea320cefdea0633deb5181cde9d9244e4170cf8e9e3640d47a14df059a15c2ca993aa1f6019fde2750244f763a381cdf599541bf20bb0947ab600a4e9aa6888ba3ae1d95acee2592f1db1679507b06f2e9c4ecb8bbc61b1b8427999c7a259daeb9aea2ef7739bf4ccefa9eb6fe400289b4f947e3014ff79b875b15270aff11f4f10ba336031f419d8225ecd92bff95f268a76136209b84b5cd879d73988bf2089bfbd79669007daf2380a8d96db68029ef828f7c7adfae8b6583eca2c8d70f418f32733f21937e0f0892b0cecf5d47d2010dca92d1a7cab5efd3276498ea55d5ad36d05a7f7b80c7604f08d8b4aacf680882332528c6d24cd4dbabfa737581aead7a66be1413d0672af71858e5b73edfb97fda020893b0f0cb7ef3dc2e107d92a85bbae1bee47bc1df40a075b38c6f944d0d56b8824fb","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
