<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"001a1ab57ad4ec5b1eb5ab5e52319c43372fc21fa8a234b93ea255922e20014d401cd1f6827b75ba440818c5239a1cb5469aec914dc25feac82d8281922b689b52a573707c2904dee4a6d42f5de8032f6a8391d46d873c9a07c91327027ff0c84e21c3410ce50fea655271da359211c1b8a8c689ad37b464049e37b2dfd45b9946a8d3a3338fe91f3a340be4a7debc8ff77ea85134ff1548edba5f9bee4df3748eda59e73b3739575700f8e9cc664481c09258cbffd9b8de4f2c870c20361f0cbd970de7081bfd34d62f0094cac83162ab6d9d2bb125cef61cb741aecec2d68e3c841ab1b9de9568f65c3746bae55fde10977f8e1728eb77634fb4b819c770ee73ef8d111beba45be13e677ebe6686840dff6276ec4495184a3147ecb5d061c7eb4aded8f6e191d7ea1d00b9f65fdd0a846ab309fc2034088a21e2e3d4bbb75670c5381e2e64bd25792e006b398fdaa7d45be369229de7c7c65c341be02f17cad7ef783f20a71d8ba0bdb1e90fa670e98f0ae2145e8f1d20a0919684d6a9d28be3d666faf411ea3aa071abf355df4db93487e32a4eab1e8479ae505a5540e2d687aea60309491d8af71ebc6f45eb8ace9a005a656f07834d23811d0ea104b26909a26f73983947ea81eac761396862b3a92bc7d871a926e55ff31bf3c7e52c39415cca26cbeee4eee02df6cfdbabf634fe63a3f4f550af9e1babf2579357b321c18498ad9cb95243eb6596803f260bdd4c4e6569c086594fd21fd2f7e284ef94e190fdc52015f16489a002c9c3fe6cea5ed4a1a5cadf787c63ce5cd49bac25efded65baa5991f38bd3a339954817d4bad5438dc44fb977c000483f2a433ad991ed6051a8b38d98f5e5ee578dfcccfb7ac878698fdebedd402e0dd4247ada175cd20beb2b875c713ebb04dc82d32727153edd33d0b96bc1a2abe44c655b6474c9f56d7d512576b6a89faed1ede50179d20803a4c169221081feb79261b66655b0339de2fba9c77aa73ff7ee8c83b99afbd95fef0efcb81d763ae346a816ff6b2fdd05735fc3efc2db5e91cfaeafe6bc3020cb2490ef82b0f4f02deef392808beda3d80f3054f0379adfd2ecd59610af7384ca9343080d6380a6d0ce422438b7d52b35447b039c3dc519a0fb8a129f27082f11fe13da871631a1e164052b6603d35a2c3fd56461e6e0b58970a260bfab77e58118d41b227d5fb57ff68bd3537891976edf5016b1e72210d01c9c71073b63bb2ad71a0b452649f225f2136fd18f5be1a4afa039b18304a938f0c3b1686b8f61f22c82f289470d7ef80e291e9a69f3555cd92a6366a1c60e62be9e316a7bfc5dc4bf57d6dd276a99682c3657449265dd3eb50d4ef1efad8e2ff39f81424551ad3fa42bedce716523e059bc08189c2939c66865441a433a9d2df23c147643822c5ff3a38cd5fbfe4371fced60169a5b848c2a6a759e93797c6ffeb858f75117488b95a2c224f32587bc68005466caa87c35c47ac240ff4b498e5281f03a04f989e7b0fc6e6347a1857f72fbe977edfc5b4aed9dc5851437221aef533286bb791ca87d6fa0395c7cd7cc34da417d21181943ac2e2d310b515b5c2903f35e64263380e80f504eb5ca09e1c8ae3feccb2a5dd7c7edcba96b28968daacf1a4084c6269c676442f52e6d04b77e8a5829c83d16c883cec5a31dae5aedc50360c3c01a6c25d2f0824fe10f26804e95f3e6694944de5e8b349a1744ec9a735958e753737430122c8cf2c522a5b9934fd51d9f51343beb6f2c952a301d95afcf100be509008de1c7777c89372bfaf5181f04ca262881382de72745fffb96c63f286ec97fea4c143df784578b9f7ccaf85386d4aef3e8b7a18761276de3a85e27fbb441af6eeaf02d5b6dead6967ae75124c847ecdf0481bf0fbbcd8c89043a08c63c2d11f2542c5c1798287cbfe171202b801bef3b7777e305cab3b7898f088e71bd98e70e8bf727f4c4dcf4ea774c55383978a3828eea707dc767bd386042ffe68d49f90ab9a73e511fc7e5c17dde0196b8bd78aa5a8b485e795d15cee77b080f7e6c91fd6d809beea038ec9d03a72949b5d5571cb42d7d614caf94e8ac3df93addd134204aacdcc39a1675ebc207a1ac25add49b70eca0feb8f97d38c5b037017c07b949f75b438216cf1bc2db95b681db8ed5899db60540341129c61cdf8bd92536b84c35747355481353115957acf17f675759d14cdef8e67502d1bb2957b2191a7c08ef70a5fb08e36b22b60cc080aec9540c09b7b324371c9120c331d18d41d794d8de15840c265b9ea22903409b8d1557c5795b1912a88abbc91e96a807752099d8cf14c8d5b695d877d2c0536c538c5fbcd2648f7bff27ce732b21997693db65c048163ca7da62d9de14f31f3d48daf81fafd23f3a015ee999137daafe4042e22b76f4172f4fb0c38e53b640fe62dcf80ae5f4b90dc8675b0973b0525b39b92a13c9b3dd5325edcae63122c31bc449ff346c56e52c1f15a3bbde463e6a2461a86851ede12b1f90ca83e887450580ad566c8f6a21e9053e339b8fe0b8294a1400e6fc039099a228e17d8d2d662d44853ef8e424b6221b122a8220201937fa8191998dce0b0e469c373b78e39f2e6b76e33713999b28c5b812c5ec10c6960358b48e5f70f78a96e5714a69f532c6c4bbadd911ce5411ea98058dbcbbcbc8dc73c0b77cff491e210df00ebb95e8c62cc11434a1c5d1fdf092b0e78577980f465f0dd13a7a7ae96c29567882860e8391cb256254a4ceefb26dafd54c8ad2fbceeff1150562336577f3c45fa1cb72a3f83e77fe29042141ff1bbf3393b367d0cb4d229af770685903a1bb58b74474e3e5dad467a3685d741355bac64b7d8be690bb0b565d40bc9757366d2c96a18fd5eb2ab4a604b24ba2a7a42861874739f34fd33583e5d03145d427380a9519a80c9708b633fc618e5049ef93dbb87afea9f584e88215fe99d8a723bd0402ecffa072dfbe4c6f731e5e88ddf2414f3f4ee24c004037308f841e0ee3f7164b0b3fbf213b9461f3f7f992192a3a95ed753fd9da207ff661a2a3f8b5c793676c44410840612974d8d4da9cbe0298754e5aa65188b54d41db43f8fdce7d8507ed27d34f6b0f333feb1e997e2dd14cf14691d2670d9beeac7e9f0f7b5f50456944b7b803407e3242da4ee00663f8d26f735541d667f228b7b18129f1e58aa064972730ae0f707e7fd42e9d723a3f93a53886e5d82a8d7402dc54fff30f447052f002a7fc597d61ad4506bdd47b2468cc2257d8bedbdd38477a1e2887e109ac0b15f688279943f468577a5c15a42dc7d34186d6c6d711abae92ababa4970db1b9b1e4a96a6de476a451b327b201898cbd0678c4fcecffa112a2f0f66253051dccaffb965bccd6d1794ebabcbd2c6f66e91fba29086593c104bc828210df0b3b635f18f2b3b9e63fd2b01afd5f1727618533555fc066580705f059b27d6c2f068a6f8a340efe6887617f15f74aed25731d1cf16f204cdb0447169300e89bd8e44d9c981a1bd52e90d27b3bd3f2859221f6aa7d59427e84d311483ed7f9e63b7140a14cd3e3f8c8c87f490d500984796c26de1a3a2b82740f7f6bfb118da25aeeb0a1c8316aac32dbfeb843dca7bd424984bb063c65a603632a5719ef30b65fae3e678d68c1637a98e550679a4948134280bcdaaf2ce246750f40b7483939c7ca44c66bb4780a5ab99bb71196dc9c9bd8b96e04a3f7586b432d65a3782ad8b3a1671002be9e9ab510c277a457fc5937142cc53c15736f9e137993d61f123d8589ebc28a448fab7ac335e61476e5dd05e0d8fb715b37451ed656ac4123d97c78d25398f89a717e0f9869e7dc0ea225b5332a83839a6d0d831b528440b832efd02d4ba1b0f5f409751bef64e6ffb9b71e54739cd54a077482670d8fa5692c293c88e116ed6b8479ff96a12b53ccdc5a2379545ce5eb14dbaed6edc30dd3b7b9f10ff35c1b33c00af32b7eae86f41f1d0f83955acccb61cde136e873d87b11afc5fcb79d91a0acef865b75333ca1a4cad342f7a55a1f5c923ee87fd7f161cbfca2cebd9e8c3fa683d642bfd12f8021ee927fe5aed08f37881f84acbaefe7129c4f707bbe4d92902939168fb1e02370f9ac8705755ccf824d6352191f549cbb6c887c835a2abcc5b7a7cab7d396c6ab0044e930b9ef1102c119e0a57ebec97c8db03b6c23ec72315b45fef5ef9d105ca5b6c6298d63918fde26ac66e4695005c7135e129429743a260071e8b27ce846995915725a8c760b8a09bc334dae06ba8cda544311052349a3b09c785664992166033dbc8d221b497dc45d927a6c203d761087dd832d0f28e4dfcdf8ed964ead8c463e414981ec49849a5bfe3b09f79b724a004b1ae817c422fdf49fdad7fea18eb8a128c02247a5e42076d9ba2c1a59099b78554c77a4d3f4a31df0ea6e5a269e95fe88d995c2d263c9f65e01afe69396db040f3c9b303643c0b336238e869bfa61dcdf31f5d20393544591792b679c8d15b6efc4e8b4f54158e7ffaa0a576b99edbb19de9e1ae51a4f6d324d111a6c0b5d411d0e00a77b528c0fc1f0441b45e8996cdb7e26e8beaf5e43394d8dfa75a7d928149461f3513bbf1bc506a3f60f7396e337a97d3c1b69bd71ab0fd1080a2172654611990ed3a4cc17651bd226351a5c6de805cc7317ec8ff83248eeaf52117b1f889e3e7389e99e6064840fa72fbac3e6d50756f0825220ec9157ff854433ce049af98326cf67350ad54fb56348454f858f89b9761f12b95212d2a49e9ea41f3d38bc3cb98840bf99341ed2f188518f4aa98d8377ee941b54a9357883cd17c124a4d528fc4ae9241a557465277a87809985feb69a26991f243de34d9c7ea8b95fa4c6af42ade147d0d73627be0d31303153213ee896cac3ae93c48c9dfea407629563aa19edd8dcaa971bf783c9a1be94e8b9d462d94fc108eadbc31695356b4f74e79c9ec4868e02a177b63e063c761f710d5fc7bf88b0b8aafa0b8ad49d24ce1a24ed39d24ce106bf949c855a18681d1c07fddf59964d31308c397bc3dcd38fa07a7129f4d0ce1359a412b294804fc4cd633cb90c4c97e752c8411195c2eb5d07a67964f933f499f3fa929f092b063147dbf2b71ce2cda633b03062aa6042804eb0cb1ad65d70c82fe9b5194e6f2a3aa8d9fc3829c8b3611d70ade56a534272c83c0b3bb68b42177b5258a1105ac233a4316136475ed13a433b93617b97c9e5120f9a5c4149b02e5a0a0359781ab9fe311d959282abbd71cd15387a3e3a2af5aec091a6c43ae882e070de1a8006dee16ae490952db9f186a2d278b36e17557fd8e7fae51808177d0d5d9a32d92caaa2d5de19dba441320f285175d3ffc8f079bf2009b3b03efdbab8ef51d160da6f9210986d51bb37a409716cead19f9878978e38f110398b660f696a64af9a4b795aebc4f518f42b7ec703ab60998794b5de01f40c6062a2646be67a1695dea5bb08e1c50f25de72b6bcfb02a117b7208eb19bf7ad6da2de0b968c5e11ccdf4eb189083e91ffdbac48fa122c2699017244dcb8d114bec618fff8841d3d3475aefae30adab3a87d5866e06cbb3eea29ec18543560b15b83a731fda488d95ab58479825ebee8829fddf26ae60a7d5b05a0e8c510592c32dce215199cda4b2131309d6a5bcb6d2fa191b6c1360ac6c98ef4eb0852eb030493abe44694ef92228b90f26f68a1991b0ac78ff9decc1f162f5f07ef1da4c8216eab765e5ea7e3e12359e14c825824c44cd78ae23793fa83dd82348259b72d92fb8a66fb2676b7ba60ea42131551f316bbb0600e847dd23252d8e6ca613943f61b8fc1538fb4121de5dbab0153c931bdb5cb4293953fa53a40b6b464c91eb9be223b448afede891672181d33e6838077b361c191d51f44ba48b8cb3fe912d2f8fb7a121b8deafa45a5be3e0e728f20d571421a6d26ceb09343c9d39ff7aa47f33727fa162914de3b1daa86d049b1b4e6fd258b8b8d75c015a9c68581e604c703ba08f25dcd3d11c0caa5fd1327640cd911e6f527ed2a45d2d2409dbb43af9e0b16c22b7b07079418e661c78f3c85403c347c9c2f8bc2e2a6d705ee35695fe933d908435715230af5835e13853be33b40f2d290a665e688fcf0794f99af0c7ff9a8ebe912adcbe90c213e04553b953f3c4480f8328bd1aa0a84875bed385ce6ceae58fd8b3ad9b0cddfbb4485730fc726b76ba0cf995d977fdeb3ec30bf520e3afdca7cca0464864b3970077b57510c1d9bb3d9e54ccb52b8f49d08db2ce675336d693b2286ddda03a6b3545ad88b1b4f1f1137c261591a0249f94d3062b1200bcfe3703f8e0cf6336c7968c478232be222a6665c3462937e471e634aaf0ca4172abef1b7fbe3a1fa067387827745cf9e38f64215b90195a8273306fd31975822e3b4861618162b80ab97068715896511edff7ec575add16392fa485f9db4a4b500190a2512c2afb7ad4a3a45463009d744579c7a9609a13f20c0aca7d99e184f8eb8f3ced079a9267c6fe1a4282a6de346d261bf88e6cb9d90c5310d7db1b383fcc2ab7bf3a815f56739ee9533c07ea25aaa3e456bd55bc6f0da6fe6d3e78dc93d2b23cc1945272b8a38982f7a0301b0d84c2c76e39c560e5401f3686153db5c73f69ecbf3afc77134450fffa2fde47ed8f8a607c19d5e1ee85008dca926c6a64a2fadbf5ccbdc31e43ddb6805c87bc7e5f1e91ac8bcce98efcafd37cd70a529ce454aa025d9242909e4626aa50f050fd7997fcb8ad5294703447c319fc527b3b903becaaf6637e451d9ee71daca6340617e0fc2f23e1ec98711a8f99faae53a21514cb671b3207eb4f81e6ed362453479c414a9982bd61daa11e8159f18d078dcf72c56b8c10ce1cf3ab7dd928f2c358032f0c103eb38a86fc6e583fa76525f1942c69bca0d545e11f2f0f72e63307abc5973a30a3d5700e8832951de0717431edd5d67cb93f102537144022a9fde6edcef192da82bdf5cd056a23345f1329fec2a5d41ee42d332a2d180e5f66e23d7ced3215166962ee60085c982fed8e0c1a047d8d802dac29fbce0f131432506fa20bfcc4beb4b5a3eb95b88904f575dff84daa4ba8de0e630763a22dbc5963ff2c57ca0466edce02d04bef936b054e928b4bfa83c24b571c9842b3981b8e30f3d6978342ce13203187bd7cd40ba10a954b598d04e93970341527d4c423fdb237fb52ae6eb0d0b1153854e1253033b37812f715d957b74f9b368cecfb16ba1a9246d30d0d4e69be959c963c3cd21a476ef7142902753f38ccd00751520e698bdb037e09d9c375d37d28b3da11c3f10393ea478c4e8ee12fd7b9314c8a2d85643e60d60da3660051f82730315c4ff569526ee77714c8123b9608254452717d1929a591f87be9fe2fca4b08b4a55a0261743cef0631bbba63fddc4a1e4483ca60c6c2264793880a184a69ec48d20b537c900ff4a31c9fe53565e5648f918446ed4790f8017ae23422b9a8e1860bb9d7e3273dc78735426eeac456ce7b8c3f41fd15f2877cc6710837f6758115fae3c5339a35961e48024df32656431a12977cd56c39588bf6fd1ad4d1b131a4c9ef490f6ec578d2d33cac3c019ad352414ce0b01ebd6299467c0f4979f053dcdd00c0674eb1ae6b975f9c48e30e3fb63fe49c9a5a405f81393746298041e6a3524bc0f2f1f504ef23501fb9f2e4938e5198aafe83836b9bac47bfaf0c90cb46cb550cccd473afb88c0f89cc2bc1e65c32559ab6e588da05b188bb30784b165e7ac1142c7991f7d6cc3f72555eae3a6469ae0b793c89f4abeee8d0f1a9c1320aba0c005cf3ba851ea3753df7c8f623d0765efdedc1f74beaa6c9ed0bcb2f3ee89990141fcb4a9dedd8b107b4cff391fc677569f5d5b79e754f7a57eb4922b44a99efa839dc75dd7fef4155d91b23756dfa47fc0dd0173b2e94d4eca7d173d5b504d12727dd4e7104a6c82e2f565ed9743b3e54bff16b0073191422e1cdcc9f1412d51c9fc2d67ec21c024b7e7cf5baad12e73e978422e193b27f657193346a7ff74ffd735cd4ad68f31ca501f5ed272374ac35b3c596219b5d4f980d2b95530116becb53a81d7582dc2fc84bfee7282d0fd6e5281cf8eaed0a2c111348515ba9cc1a2917e902e0f799b0bfa83e8ac7a28595522bec280011769a9bc5fc4d58a9070200092f17c7dbe712c66d522b6d13067bdb0f7506645af77399f19b271a925f3bbc80380118a3819b2258968cfb8a201a1723926580456fbe7dccf9a29a3172ca6fb54d41ce52ad1401198c0052db04a8e5b9bbaffe8ffc59ec76e84293d01c017340bc84104ba46696429a0dd1afd4ade06327e5bb2b3bbe258acbe9176ba09f447387ee6ca2473b37f23f122241c42d2301c09912d43125c183ba4687ed277e24140546a273aa4057fdecd36dd8dc1d0bfbebbccb362239d05c17411e64157cc7ff3fd716dcdf0c1c12f7846fd0e4256dda40b2685b1934310d31e6f5a81107ea589d47b1dbc86459bd126edb9f163eb269b61edbd253d7561256c66d41c63c1722b9ee2c91e21d98d34fcf92a1bb376dbf5dfba47d4d997cc173d5337ce806d6d832605681722d9136557af61aec1f6ee18e55c875de378eddb02b40ef75663e474f8dcf86b7cea556bd08a430bf71ab20d09cdb2420e3e12227481db35f9570ba3ccaa48eb34514ccafe4595c3f23d539602de764040e7337f9347436e4838606763f0d7fe93d9bd91db5980b175e2707aacdcab5f3acad787c1620ac9d3cfd03c18c7d4136e4693c05f2a209e37155b9d362ddb732bca8b60cd7991affaf0a3867895c33d5a14ac1bc247f0d6a76395163f51f4114fa3864a8c73db220871159eb391dd72d8ebf317bfabec20eca098b300a004f65bf4ea63b1d40d430f9f872b176b6a658d07bdc808139047b0ac67e704c836046fa6e811340f9e9099604be3b05e38257b2d641a39c5f7bb9c5368eb97c27bea09774a3ebb61a8be369511070ec8e23291f0741d6c65115cba31309a617fe00e62fb556c5e677fed325fd9f3d18764011a518e729a0ec6c98a18c795fda7d540a5252c9917c007fbc01d3ed19a08167feb72f40e0f47da686efb35382c924e52cd505c714a4a371461b38eec49d74e3abde51af77f7c07c40cd4d194bcceb748cbfeb20dece231630687537163ef1b03079806709e813770ff44ca336c0804fdefcefbdfa921e43563ea4a59e73ca24eea676c9f15045a4fe009ce390420d04b6ec6a6ba37448f6ad50d13d6f7e406570848052ef76b5424fb73bce00be7b314539f878d8179eb9d4a6c71934b8b7bb331ce76e9c5a6fc97f41a98c11007d9ddbb3ecb5fa63b9ce9d3b3017f91f3d73f26b218bf0f4e21eefbf3a3dd7a0907b5d202a80821980356ba32ce547203b2d9379f6ff972646fdf6ab898b9fe25c28be2e3cb5df7fa381b2e610e49e86be87325683de6a40d77fcc48ea75b9c856462893c9c975911fb893edee6a33d4a013776dc6d3a47171f862e9f5fd5ee376c5bf34b61d512ddc068709e4562124a188a921abfdc0002f790a142f76d108e709de0b7467c2b9ffe1c813f74ab3cdeaf2c0eb6c41bce98b099ead7c42018f5a23b0399d2545398c1435264d2e9e58dffb8fc002c11f3e2721f7c09828bc80490e140444e9784d2cf90b82425dcf2ca86eb72992519a1ca5aba89e6c6894a9faccf7f55392e7a07f2879484b930d8b850ac656d5be17a7eed6351a6ac27d42317b2acc358fe30d4b8041757865e9aadcdd604bf42221ab0f62ca26e55cc0cd39e3793e768fd5761c3f6420561d4fd77811d7277eb05c2df4c411c0b468cf725f473fc78e6d4600e0df3c11929c1720a8e07d49e0387d74f990e4333aa8fbf61588bca2747f6e950a26079edede23818b92c0fe8fd46425c1f92c507a0e749f1137dada1ff1eafda5c46b5515cdd3556afeef32ca3a9635b97889c5fca6b9a7827bf15aa07a8fabd2091909b91a9e190ca6bb69cd094683f5fd7761b211fc07f205f3ec70701e85e125d25c16cbe23a5156940ac2c1b9a034cd06ffe54a4f244edb1c06e392671f5b49b0f42987a7bc143d7aa6cecf25047f8478fe03cb765fcf16cfede04de4575c8d4a81bb3df6dc51020efb53d8260b199772bda8ff07c070699c087308cfac5d0e7bc6b2e6988ed79ed880a56065394e22662e5d801f58a908083f28a8facff3155a3c0e22ff25c60626c8d355997d2ee8664db0ac88b6c0b96aef24ef64fb6a851d7f9a98b067c8436da18ec8a31b0aa2d58190f00abd7da9b98963dd0b42dd1ae8440d42e2725d54dfa3145cab82b225907a619016c5d3586c2c42dbc216271c6e7625ca4b539dc817f7f9cae1d5a840f2a28e1f84e8d340df9652e0d0e92f19eefc8338b1872943fa889da0eaf1085001719a69c746d8f032ff8434d88b8d77f83f7b05a83ac707823affe93e1f3755990b30e8ce5757bb88f3128c5589319e553bcf841ef825ff516f5828e98351d9b6fc682a7b96146b52acced360485b05c8ec57e45c091cfc53ec63df57750d0fde63e163fa6f8984d92e3dc69806303d6a194997a1ab9d158c9ff4fd081371a207fba27e610ea96c7f85788192ab653c321654beb87811b3693e2e130db745bd7614b5f21dc75b7c9eb4297b128021315c5300ce5cd5a946361d6f5ce07c8551e321dbb9c2e979a42948723e51d8f9a35d02d3f33d54c2c873a109558647aa4f88d6e9fab8e5372fa2aa11e3a57189096857b8e2188ece7d20c159becfa7883f7943685c8c7d6988f4c55a2f9ea487dbde3c3d63a6565b6fa05dd28a00c7d1be982650f070120f5a4460529b6abf7c0de56c8c8f69792392e43ae124846802b467e66472e6d811c5b5cb8a9faab251ba8416f491cce3f318caf0611b8554faf12af769646779e7c69e22f781a34058bee86d8dfb413b5166ea5bc77b2d024c5c586e5a50509d17c56cab95d9cf208e8de0de04d8def127355ad90c536350bbf1ce28039d9730fc1331276458066f1291c91037d0d7120c42b6e257760cf35652ed1dccd67cf69a5eb3a051f108aab5a8f467f4784387e09319d32fe6377d004727765f8c2539b002e84f0c1bab40e0a418fe51fec1f75cd6dfa7ee1a61213d369be91af0a944d6a53ac66bca0f6bb56d2b239e1666a850b0c7f1d94f2979353a45c656a5be9c2e7e5e9572bb1e1ef1c6d47adcfb5f67f22f6c7727b76ea0cc598608d31c1dd80e75cf93438332416413fd1accd9f0faef605802de498648599a7cc02bd64b6da5aa9ae4aa059323264ccdfaf7a869beaf6580355c9c16c943b5164915b78de6c97246500f37b403f91ab4d6ac40c4033eb468ba69f5785af4023b557349cbcdd5faf57f29fa3796a3ba2dc2351276a816cc05889c5845c2267fe472a85b69ab15685b291d2ca8c0ac2b8ed6a0203006238fda675d73b15e4ce045ade62dccaa28389483591796476048f5959fd9d2015b960fd59dc53d723114544c01d6cb4a99f412fa3aa5b5f058ce791205df5fd604c072b97d18574be784e43409fcfb93014c00d106e2f7467918f04a41a96605a18ba8564af8bdfaca75188f43c4dd03e988d10dba44791ee0b71c3e8f20f07bd15a1f0374705b415ec6f822e278f66f2ed5354ab383a1d629d15c99178b87506c50ca6d80d31acd263f06496bbac4362c7ee4d6fb064940bbd94901f8fdc4c4ffbf65195fbdaf10594ffc89d9ea082244f6e887f116e8c72993cf44dac2d849bda004620e6a91df9631782aab249eff27d01c7fd4b9b3c975feff06211598a32550dada76ada7b37cf4cce2dd09f8a83eb4fe02e140432103d84ff6083cfc31bb5d6dc05d6cdf359c9a9ca3c69508ae76f43ea2a00d3bcf1a87cacfce73032e18f0e94b62e7f5ce1a9235ac0e41b9dad9a344b47fe4bc1f7bd86b6569b3ff3a33376fb8be8825c5bb267ee016df743b495f96ceb142d815b0743b417e77962f5d02efd812d776eeb54b7c77237bfd583c89d26b22c971ae03bd683e8ccd7d4a19d3685109d5a30bacd920aa3584015fb819f4b942cd6c15780f5f4e1db4c654dab057f73e3e29a338eb3e514c1c6eb5422f6ea003df075433fb2b4811db5263f582f57dda95f915807117536ea6643401e210ee671aeffe867ae410302df9cabc1fdfc4e779c8e3e89c490a1808f9756824f2c495e1f31a8d961ccc991dfdf8d60c12bdd727f15210bb8ed08f463245511ce5102fd23fc9b339bcc19d8eaddebccf8327617c9d20a0f49702c538d2c2bee4ef76723b53c60b9ecfdaeae3d1325ef52e3efa0f47e3aa04d729e3285a48e0818bc1df50124d7c34dba440a7ab6e0d2957645a967949f24f162c7607abb063eaea92271af2dbed175db00c12ac69d72380bc141752a1d085a9b1c7383dc66cb12bddb514ffa1b024553449752086a97aa967acbb2f8afaf1eb2a6a5d079323e3d60a3382ed5ce7c2fed9690253e108ef9655498012d7381202fa909c3500a0e387b2c82d614800e904828562ef33a6258474bdf40ec75f7d47a3178bbe11574724a58f9d117eacba4c07b4f3c55e8ea59932f66c9187cf3cc6ba8b33d0ef885f6873d0abcca362c7bb78f9e6b238cc560d14c0546404143aaa354efb565d3fd984e2f166acb8059bdccda6fcd41fc7798de344b9eebad94085b5d9a51c1e985701ea771b06189fc318e3393ed22a07f42531a85c35d2085574a63c4be44c8c994b316cbe4bb63fa0643a9d0e329d24393ceef59f78adf76fc2a5779b5f0cc75b8eeb2c1d7f57cc3a2be96032a596a97f0b7a7526430e8670a8a9677e70e3f3c412355c0e21c609ba0dd7e85e52c94c442b4b4f9afec5460eef784b4369617b1073aef1791a2c22f54d5c7116480e487a7b9e80d53b393cefdd2f54a13e7b12475083d001769e18294e5925a8c48a9357cb1c5f01122991a08469754ddb78c61507f818352ab638a7f82a770fdfc35ec11d7ae8c2d8f8bcb94600e9dbb31654cd75c3e30823251185d9374fa555683a5f1fe55e94d586348aec3c00d5f4c91833e0b112411ef171bd65ace901a7309ee92a9bbb735ef56dd3acb6648639e8681b44df9f63eed797432bcc6bff776c35fe9d1b2162031b737bd043d616661444a896170b621ab2464674e013ae76b41d6fde1ebf6f36a16c7e3a3ded5e5c7bd087f2364324a8586648c5209cd62514bda05ef012a56278bc9e6006805b3ca5a3f6a84f740a39de22305d45147d8a41fa81584b689b2f28fa22ea9c0fa4b1371c5bf92db041b0dabe196bf47a7840d802389e38596f566993d3dfda6153074627edb63dc12b8f01aa203963c313fab35b0349900bfefd70193b5c7491d6fc508db98b396a14a7fa34e7938ec89e4729aaee4688e11dd64f34d77e0b1d6d5cc4f1845de2e579e0b2c14ca090bdd11dfe8b27481971f0e041d691c263471bbb4c845bd7148e44e1bc11e649510d43fec0cfd4dcfd4d6b4ec22b3e641b562e6dbd2f97b3300b0bf1e9671ca8f630aa2d149c282e74406c4feeb798de5f70a3f01204b894af24bd8e85249d9fad133cd59586b53acc55eb2c0ba5592fbd05657b3ebe686dea6cbe9c900ce8cf96191179edbd907ffc26bbd7c830dff8460f928e30b3c237439f5fead78317c79590effd2474154a3df7c1252827fecffcfa21fb6911297dac03a500df520a02cdfccb997eadb9c41a71b5c3c50f349151b7fd40b6721f5679184ef4fe10a4d5fc0625dc7cf474f985f0f5d556b78faf6b4db9d64ecd1f1ed2501e6ed8c241be7759280778ab5945ed59165a3b4431dc9ea2006feb00140a002c04beb6818752291bcd0af75575505879ee42d7be01704c7e7063e9c04ef388986d33df7e65e422aa5beda6db447d40c22e9bc6d566db9c79b105462fbf1b3e3309d99e55e36e165e4bc3a53734bfbc32e108be50bd92a678659f97285b3b17087a8360f9f0375f175ed66a01f52248f16e5def80cc078a176202df84defb16a68b395776ccd19ac1457f05f4450f11ea71f247624da4061591bc46d32281574964e049883ea517077de3ab13866617e760bcbf3d60dc1f3355eb750f7bf45319a3ae2ff8c7de56ca2bdc95e108928013e8f085c0494abe33b38f188fa7d7329bc9151bc6c1480af5be06084cb224a4824a934df1be774efad73d46cf5181f946679db8144859bc3b3e47056e20ab35c7dd5ac65b8eef54ae7872c28b8ede22968c9d700f037e1d8b26236dca8329b58cdfb87048b07174330b4c8b2c3977b55d53bfc77c5d1598f6a890e2fdda43351ba44c3aeaaa1b4f25104906ac70af84209e7b4f78894810113c694a4c8e613a53c8f071a8eeee19903d7b04cf93b468e4a94a97b6b0176a031dd55f29edb65a4a6ca99639c09575191d3dbc82135a7da2bddb8c5c34e96dce12716cedf8e675dd018edf9caf586149928eb61277ab9c427fb6b1ee5a3dd602a282d1d371a221e5cdf29cccbbdb5956f46636c297a45ff36a827bb70209a47ff4b2fda206ca2ddfae63232d1b20354b6b022c2278d63aa95ef352b6a8cbc5484601a11e3e0c69b8dfb507d01fdf2eb389b6bf6deacf5891c946ee4608a6ac6ca36feabcea3f93607660e5dffd3e7d33fae5f146fac34b74a92fc36066033e928d2ca77f43f32272802fabb9d403644b7af7f9cf531c0f96c3ad25bbb6a56b35b05d37d52b35321603b31e74fbcb3b90937e39532fd35fccf44ff921d6d0b9c068045504429b3e16d01d84edcdac93290067192914c4e3edc7391f7959db739df52063b7b86fd487ed9a0b3e5848359d1ca707dc8b57eb393b5d2d8edca97ba536a3ec7437c5ff9c232773f6c9b499329cb52352bf89c79b1ddad35246c1b6f635e26a1ffd471f4bbecd954d83fbf3ed12b7f4241cc768ddaacfbba21ba41b9e3b5012d57c561cbefc88a83a8c7aeeb8c5fef38fafa8d750147a9a692716c30663ca32b6afe744bb4eca5cf7d619fd63815b9ca5579310ead8344bfe06fda8148a341dbe50a19fdc7dc61021855d85ed8db5fd286481280cb7f7f92b62ec50d56e36ab982c91ad80ece8f9147bd94cd02a842aa5f166206466ba80e299e5714535899723d64610786ec80e424750ed3a6419cbe94ba5ab66ddb5128bc04ce3b05dbd5bd397c371d967e51b444694607e7edae84ec9b84592e0c662a6a7e838f7ec5f8f7be0a74efb7f6280a6b373c0edfd7beb3d639c827592445f4ba3cc14f40b775fb1365ed33848bce64df91cd489f129fc16e4fc92c2458a10b8add78e5f4b923875fbfe1ec98da5375983f429126230ae9e2f7f050be7312b0305c53bdb0a89c7241036d5cc7de8dfc3d8bd83f32a7da5571f7b6a4a4d92df8281a94d4ddeee0505c5ee473416184aa8d1956aaf137a892e511bffbe0fd8ad7d652c63c8727b85b05f079669a4ebbda8f26171fbc81252f976dce4d533a7e7c0e8c682468d0b7bd14d0425b04d2f5a69955fc5c3be9067f1fa30b2b70105f8438e92e989647f59213a91792dcb4d25300789e0c0a1e9eececf676d62597f7ee3ac4ae9a7c3eca66e32e4489f73a81c85d9022169b7694684d3c86e9ef2ef1a293a4ade5ee1955c05960255d127eb29118bd9421763789493f25e2260a25270022c9da8e4ec95c65d1eff2060b87abfa1a31eed83b4ef8e257f39fa8852cf25ce66ceae7b60eeb626de21c18b1e018133f499c64fbcec352b3eb7fd41811102bcfac562f6fcbd59dc924164162d1a14b5c466975aea67f7636388473c6b782719bf59cae2d2b92a124aee5282a6cab2535c5293ab7cd177689f654f504188ab60d4f2955a701304925da7249bd7ba16ecf04c921a806e027a12b8844a5ce5e409614b684738ec15b310d56868ed7a2996ad452ebe4a5c6b1bf18e214e34c724e04d1c03bd460b9701b8796d01e0102ca4b9098f2826e27d362e20832b1887697f697e270f17948a270458eae1a253759e09ca9912880a382e73fee8ef33eef9a9e73113159e8d907ef42e957182a013f6d065bc190a9bd3bee498777fc6e3dc119d7f9b5f6ee19b2c61625215d8328bf828794b3f0f9a3bb61eaf082e01d01caa17e78dc41f5947d6e2a4e5c35b7dd140ceac586ac3e68560b7d47de5c149cedbaa17337611729f15eb125c30aa47aa9a84d2dd032288cd7ead3d3d99817f5d3782d85e2752d1abca885aa7594ddcc0d47797905e1daa786695eabb64b8689f9743bb23fd34b63962813d57770a53360afb5ddce6943c12ca38e92dc808f83332b97e04fa1481428b5843f42ebd4d42c4e9aaf52ae56affe9335fa65b1ba9fa81e9ea0de8a73de6d284102b1ef44a2a4d45b58ded90e7cb362d7582f27e6e38fd6dcb9ddf5950861b79ff4baba9cf8d3383870ed16183df5b889bd6ab16a5943e24232e42de1aa164020da0fb007e3bbe2ec8ec6963ad4845265699a58f74ab5801436bb555ac346b522f1774d742f3ff3cb745dee87a707b26c9d747b887e6c5a3dc7ea17cfe87ec3e3626a9045d875bd32dbd583aa20eca80420509dcc7bc418a1f4049230c89d2245bb245b40b392549d9c53f12e4a2a7f8eeb306242da8af76c2fff7a662036ceffe16834ea54cfd5dea8733107a30f384a8e9a168626b2800fa603aa26c1e05b3dcf088b0d4ac16bea661cf3b8d5dad681d7e35bc2ed4364afdc50a90608a49cec666425f89088e7bd2f6d38a710a2a638c0713a356403baff26b5ec10a73cbc6b4ddd730ac92066fd946edace40eed27da01029dc59e5bbc6740e5e5552e5cb4f5bb1c39f326c25ff4628e580e93cc4ec7e0781df8028b4e34b03027ecd88ea7a3d8fb597ba60862a5b7daf05f23d13336eb4688f5a9626ff67f08cfb040ccaac26a7af0cd1df912673b1d0a04795b56362","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
