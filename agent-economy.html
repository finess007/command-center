<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1eb03ae50d012c0373d3023e5bb6b3b09033945fad34802b7caa9f8f077baf27cb3acaad521304dd6b717384d5c5ff2ff3f3c5b15ae2daa440e43282c12142e8b77aced7db309a93385fee78cbd858f45e116e5b3a6c42c2ef4a867105dd3a712a5413aee7b1a0a92d1e395eef384737ffa2017a034ced3757fa80a034f9f895bbf7bea3124ec65011cdffc15a8d4624a27608809f1b002ff26804c9e2bb152db1f02b61b0550e323deb7638566de99e8644c378cc79f979210a41cb718334e26ea86693d2d84fe43336c29f6872d1e956f52888a641c21bea85b4c2addc992e3b8f7d9538e37b886b0229c4481166447803434b9b8ea2c034fe17ed32088bbe8b88162cfddd338b2d7d7519fdf34501b9f3d2502ecada95ca788dfd9b1dfb7ca8e645144ea38377857b429db66675a200032cb34e7fa5b48b557e5d378f337660659f9eb27033b921eadafaf1dffe20aa3b2dafe19bbaf4ea5cc96c8ab3f8c9748ee36458c16a96d39b11feb04fc85c57ae9f1128745529f0c555b82d361ae33de3304bee618be6e377e3d421cf8eae7b3743353e9589d705b2585f1d9fa3e7a613714e81b13f9c955b1b41d458dc6281d5ab6d610a650ac17a43919a5afa83525203f1634c6fc82a8e27cb3fbaab76212ad607a67235aef40919f0a428d1188453c1c2926182332859c4cc9fb8ad2dd39c4d2e0897e9f70de0c11fa4264536d9bde842a4444b394cb8b0c2c6c54335934d94cd0df093e9aef6791a549872e6cc2e51ddd9d3b81384c3be4087654681a1d024dc3fb4edbdb08935de778f58b400cc2c7bd23a661331a94985501801ea1252b0a88c03369e01763fce3676eeb57585f06a6c0fd308123732ccc6496c3a8f900d8469cfea6a01fa9b00959a044b0d85d9db9c1dd076714f7f89bc18210b265d1db97e85dfb1e7b5b895051987e8e1abb4b4f74bade6af1e89a72e9aa43a154afb87ee89c1c2c9f079dce895f8812bb91ffa83a7433d7eac495f962fd4c4816b4cc7d2d23cd645d15d3d87a7462c97b47d3575865eea6362c0e7daec64e7891b4f8c0a56f540cdb93e41f94a0787ebe6eee6c05748741ab1ede05686dbf0e685f0248c213a6c13e57d82f01a530f19dc710ff5dd1a8e721e47e81c1491c0c06d45b72c159c6c91447da80e66869947e6cb190e593268a0933dc14adbf229202e61017ce2ce16ca8ef16766edfae2fbb8cbf1152672b8809368f51743f5d1f5b8cf6792d02ff616add97ea49f63e4bd23d0a08cc9d004b93be1bbe1cc5cb411aa5f173b874ad65c58cdb30f74156f44f22b0432abc25b1be5433f2885a37e8840645fd2020c41be4fb8b38ff3d51ffa68127a3e31cc1115b31eede4e748087ba866a986f7a78e78e99dfa8cf737a05ef0f7057f3d38535da9f6326c8844dfaf7f0970d7a75bbd0995908ceccb6e83eaa0f46f1b8c0bca6eafaf85a59d05f346f1fa454eb224a6aabf5a939b29664b440a8649e759c044ba6f15009a7cb627c767caa7d81d58b9f77b03518279baee1ef0071d235985b1fed2736ae77b94c9c1c468423534c22cb9aefc3d695f436998813b48ab3ce8b55152dd88bfaffdd76b823d5e8a7062fa4fb70a63ac052c239e7f3cb47c00dff5de96100089251f4202172e2ab850ef2fa638152111ca6c85bfd1a388693e2cc62822edc19c2cb1a2355ee7f007f79ae7e96e5dc0a480dc6bc59c841a6c37b26d53b6605003a0fe38099547036542c927573180e0702a462057969d3b60a338b88ddef65e89ac791f7c8104c8f66b1d232d33786084d8dd427b33c7599358dd060c5c2d594ec2182b11ff79731a2f2167bf895e59a0abd7c29ac66258d431d79f1615b4971d8a49d3354f9350bcf4c23c370f733ca781b38ec0a7dbfd2c4886b30dca148e326076d091e277f0054fcabc02c79f109628913053325ccc11550b2ef9734518f00f21553a78bbb2ba2317052edca65b4dd635bbc323e5ec97e4853cc7142e469ab19e213f7d7d2dc349488e60418795409923b18b98ddfb2d8b7a9086901826a091e2f419ff9f9cbd43a93db291f1b9e01e6c231203f917a1046cfb2430c3be78cf4776c1aabbb7572f17922e71487c12984ed83bf5219c09417fee69533d1b5a850ff048f2068104ff8a6e7264b501901bf6a0aed6bc5e61e34836b5ce4d4f7649506cf86e99435eb08f534cc8684e8eeb69e5684fdeae38c052aadc0dabfbca94b39589d975f637d10d8389f6f321111e31ac9b0a22196057066501ed2865ad6268bf4e13f08a6d9b6fa0be0c8f7fff6f9c1368814d32843bec0b8a267697315036edcbc0c10b177165e7e95ccfd65498317b80796a6dcae69afbea299ddef2d2871dba7e629cc36f6e92f0527d8a32f530172be71c14364738416080fdb80a4a5d004198e758c463b9f358d286d85ab21d3e66cbe6c1da60f6d4ebd6e1b0500bef6e2456ea0bdb07b22015dfa75f298bb3c52005ce5f93a35c4603ec03ff3c0e28f63634b09e508c5be062aa5f99c9288404aa30967afa54435d0ea0fb2d9c315e1c9a3ddca92f3f49f68e5f721c8b00a5ac8e61c53056111f846a5cdde11a6f4ea8bb831ae2b1288400304eb59d7090df398504ac1d5c848be8829e258a6ecad37010578f615d7d297cfe934e4db22da75219bc7d014a794cfa4794bc3b9c525ae8e60b59b18a9642b64f68a055c25fd5b21644ce2a6ab755ee01ee4f5a8a7a5facfc018be5b2a331b56bd64485e6f6411de46fc2ab54b28af50096c7cff09e52c21556e228add910fb23d9f96f5315357b12b0c510c1f343fc4b8bee855e09376ea6cfc270c2ee7e0300a92e8cddac7c1d3c003c628798b37493bc8e38c7b1b5b4f5fd053c98da58cce56fec12eea3c259b38d9c7df002ab5fe6bf2aeaad3f638651e10b4cefcd49e844a5ae6c0aa752f71c37a510808ad2d8f8f868737e509a0ca3d4bf914fe3b2310f27f908885e398b7034cb429d9c6ea27e2f06a11b35804b122d4409e7f3e2d57863ea81acc51c52c3869dcc6234bc59fb905627ea3ba2889a9f88efc5df2a7fe1addf5bf16f59b222075bf0d349b452f0d1c76e8860e4c24a3d04609b06c415179eaeab5caffe5ed83923946cf09a8126e20c6e3f607394887e50d13884facf35c08b6ec3ea7bd1abf219fcf45d7e37b8237aac38855e8ff7584977b56c4b4b18b4e5d740ea19f034889e9e53825ce939f99e0411987ca2ca3a3f6a09f1cdc73f80d47c03b0ef367507c12112bbd1ff7d1d63e734d4025c3429668da8e454c76ba256ba250e7e1bbae3d792647dde76eaca9810c9925492528c9110099bf01e297408c624182420aec4cd12dadc85ba23f89109201f2b315f2d95845cbbcffbd4f4d4a1cc522c56c6310ace9dff60e9cc751cbe27cdf97b37ced7b521020747b9256964fe9e0df5152ec896644dd53ec8eea4099710434aacd410d85688460ddae6944341d2ac649af8ceb2cabceeda0b6b36a5a2def873abb492bf0d379faf1f6760d0c1d24f9aa065dbc3dff01e80681d4eeed685fe050e7ca8266d4eb16fa5b8778692209a6494cb2935445b61b03d07a92caccd5195b1500292d1425809aa3ea3102ed3edad0fddb6e888ce2eb0b78fb289ab26712dd85fa24a7016ab9428d3b9e0dd6a497ba2c272286ef5a5abdff11517d527fb5da609ba3c567f7703136df69ba65d4a1a6090091a63a2177787fff92abeb1cbb894030eb63529e2e3ff16415ee9758878e65a5296082e0382373d2ce679963630f7fb95a0d6429f2d6efe67967f2c6f2dd39670d0924af6dc0a143b926e19b58126a3c9acb643d8db3353b764ce3b8fc48363b443ab54ac6322cb44a4d3bc4327a083c26f6cadc4247147ac57bddebf4fa4e8fc2cb24168d43e4e20d2603d59a8d99c556b423d1651f8c99b1b7a00f9e33062bb07dfe4198ebd4e6cde4c568484bf2578fb39bf146d6db2abdaeb6037e9705db78b85a2a0a57c0bbd59330fef2cd29a4991dfaa0abb25296159fe3ce81b3420c96402409a51f41c118582113e262680aa9fedfe0ae71fec8536ec740feaaeb77446c5534823f29a657aea7b97ca29abaa3b36d3e527d1f34511b03e9f2dc43c5d2e5655ae8cca8112f82b1edc2eb38a55c037fd2cacd02092d0a3b8e4b93bd00211f07938e3d7bc56a7699a6f44dad8af5a15ebb40062b8a9d50dedce9c5cfbdb9c5de799943324b7ecb38ae710a3bd060682c6e1fe67c12a57a703dbb90ca5485cbf24aaa1998bd41607e81281fc739bf922ffe6933478ed066b7ab0da4ac13154fd1904224685dd74afcb9fb1762868b1509b598e9ac72839d7393020c754c7d7a0d1abb43e34f7fba641ef2c0508ae06d98945b5d85357629956cc87201a1f9a14dfe7b07b75cfad9fd3a6f9129dd7824424423fd1852dce9f52829888448b8a73ef80b69cff872dfcd18564773c2e33e145929303335cb15a751f31cc320b1b176b06c15012945429e5effb12101d5c979eb245e8308e326baf53ba6d725a675e0715747de70766a6be683e966bddb75b165396707eb7879a723063bf293a8c3997ded333979e8a36aa78dbd6a4712502b9e26891e6e6f5e167ac1a1a633b83d5dbabb27f309386143a705718762768a5d60e2f638ddf79c571e4af197809cb702d8583b83fb9a2017c64f0e32a7d27dbb74fcb17589a269002a3bb22d9cb27d70aa9d8aae34fbe8fe92e331a971f100ba36bde83de9505301ff5e8e3345cda2aab1349919db32c3cf1e8898b269f6cdac7a524c449e82fcd11c1236f2d4eb6d02bb7f028d1cb1746394b607617e98482b40347b4c91e1e195b6837fe1a0091a8fb5246a40e0a660eecd851001d03b5eb1925a48cc85e51c86240f7e78503fc52c2c3b993bf7ce98f4dabb008fe93ff3a57d042be919904b6231b6254052a962365e2c7346903314c0026af4dcce4338a24f0e353950fcb9f7453e08d3270cf28d5227bae927ce097e52d147c1dc0ae6a34c82ea2ddbbac662fed3d79a269aec51cc51c001083c4c7623d5f9fd4455931f31aeda0888497fd547522ca908d8ad8a272fb97243307dbd776e762f98e9c72bb55a284e9d6134393ad4db6914c87f4d978167ddc4b82ed88d487e8eacbd9debe544c7a47bdc301e84c63efae2a3a540d00ba5ebb1370131e562d5e60844c4095c61c1933bfd21488ecfdaab0cbdd0dac85e4cd7766b9cd7a0cb81f79934c8b15e434e2b943705ba07ba74b774522fa2b62b51bcf2508dca893899a4c4c50b10f08f49cb49caa6eb7e18b97d4a53e2d9b182ab38d1e22007c46bcadc3332158a91f820d2aae56c6bc156ba308b2795cc929fafe96ef86489160eb4f32e16cd0eb42a6642a1dceb85921a376bfff4df9809bb2d325856ff3b90ba4280b6fe104be13cc68a2841fec0ec1ada82af14ab94a9a6634dd38351373805e33c91b1e9602b6240b125bf0c070b9520943d48d3749c8a6e190e3b3add0309ebcc913676ee50a6a7f691f8c5ece527a8a8ef9f8fecd36f396c496453658b4f5c1a4aa74a3e83f3340f7ee4b1a13c64fa49a33320ffb79ccf41fa2f17d6796314f0d657458eeaec403390adcccd96ae2e27b4bdaa14b36cfdcad2255fc8458d20b3e4173f34664c61778aea3253c556a4548fb90fa3c6e18b07d4c30a57bb26412b3a80dc73849b37311230b6eb99c54437f3f47f241a5ab267a4e8cf0e8550e052443ede4392a85cd3c677dd71aa65a3079a78fd92bae1bc76aa1284d6822382e5b11a8e4ca816c5d6a5dfb23f6e2f46f346285c0814f94615c2f55b5545a5f7a3c0fbe08a76f3260e33d5b91b6baa8571ee752b83beadbd3188db34ee06108ce16a50e51a084611611c9e82882ece06a66b5c9b375dd0d90c2434560ee973110d9aa351eb99117ea0669b8dd69088e4da5f64209378088f9ed3734e828c897c9daab9ce2269c08a6448b42fef0432b3e2d5d01e331c1ea119cf73e551492b1e13721babde3132b0a82ac3a3854569d893a193b4e90e9cff0e12c7a061011e67c9ee6230185febe989584d1b173a286be397b5598e12f39c559373e5d1810b281d6dde7724481dec1e5be749a489aa243d1dbd50bb395649b2762029df36417b6757e376bb4cd185e05a3bfb448f702ec6f5ff241c02cdca0528d8e3d34dcea20de1ba92c6577907fac78424e4c8eed11c1963cf1172df6ad201d11bacd5062a848f1e90c10ad7ae5725d30b5725540bf17b6cc889152cb806c92c574dddfcd43aa2f20c67b5416ed1a1b4133aa3f1f1f30f103a9211226a92697e94bb789e49eb53502681a96a3f6b4e28e5889912d8c07e3678fbdfd1348099f0d1de47b13197377f8ee891a8f260bc1e4152eb2abc534baaab5a15e6ab0f392a29db8ca6223b3aa6f761ebc1228f273cd93984bd50616a3ff8a9bfb0d61011df7a3f62dc12aa893e9db21bf19633d219692de59f73893d6407e7352bb81c83c69ae334d79f08a2d8e45606f7d090433dd6ab1158eca650d7647978966b3f5ae6191d9f82bcf71594d1b1ec956b4245b13290a73a7cddd57c40e4c3867fe6f877ee04e50e0596861ba7f3d859ffa1169f7bf605911223832124052db5328c3d666ee8d79c9b99d3d30c8dd038e1e6e400ae6022d0b2ffd3f457c6715294a75c762d17c8a1048b1eb61a25fa6b2dd03c02f2d1b3cb7483aa90b49efab07256db52acea2494b14c579b6f96a25f9e0e86b702c2efe182890d1f26456c186c78d587df1d969b9c9f0b91eedd6c80f7183afb5949d562f1808c00e7f4ed19e2e817e594de4b83860e89934b022d07bf8ce11abdfa46c42b958fd2dba7a751c1ce5146e9ab59ade56ea08eb912ea9af766afd642a5655e211a0c5b554df54840b7694cfe91d8e8402e37a9b3a9f8a18a3f22309f28951c344b7946835292f22e968da4376f05b7b99ed4a1218e4efd61c3cff76cf570c2440766113e2914e3d03fc3e56040a4123b037ebb01ade58af0f08c240693087bd6f902710b7820982dc9af4c06b246a247e45659f32f6e4b9096ff949d269ffba16269111daa8601835c278b38832936f8a4c53e6021fe70b36c0983046a8c187a9f16dd9879a4c8e6aee58692dcdb3c6d8634b77d94c645f609d09c295f420ab3b65d77e3a9531621e5d1091fc186f7ce0b94de3df1b1bcc5c52d8bcb06eff33978ba2f5f0e268c54dfd89a37d0a3926ad110d729c2882661a488eb7ddf11615cda4b36dcedefbbc18f3581a7a7f710d77cff5cc09577b2e1e3e30d07c9809301f73101a9d6a9dd8b71063745b9de0c33ac3b2a7f8ff461008565d5aefe88e94a38aba64edd0b68526c8c473b43287a57909a3397eb8124ddc7f994c2b5426b48430f919c86c922cc746f2b8b043dda0c9c4d13b98a9094193847ba7d9c545a573ab8d71b14a54e9d1df24e5d8b1e4aaf214f099e52e4484ed69db7e18bfd6d475398702dc76fe7a6eb216b6a9536e82f6ee77b454cccf586063bc1e85e56afd06b3be191f6c6674c3e39892b2fc2f484af19b642c83ec5572c0186f1835a94864e76b5103011118c4c2e9e93f1020408820691205ddc55459a4a54b8514bb43bc57421c6689f52d8b5754091bedd3a99c4647e3fe53dfa1d1b550dab7242b8c559aa5e8a38ce4af7934ecafeaa30d5340a74cb76de3e4ec4439eb651b20b9819219bf1b7963b4525d590a7a490871117beaca3127b46091f29e53516677c3454f59a90092a01a299cfaf77b1f37c5a92e7a5d149f4a231125d0ca83c03692a99682fad62e7853d97d9d172548993b99fbe996b4ccf04d3b02daafd8f136f5ed40e28cf15230c97048f35ca5d0eb3e2033115745ef62f29a46141e4ed1e48b9e7a1dc1a75a223823b188de239ad1a5ace90766c5de5d9797fcfd631fc5d279942f437f6a5197e05326b6649f91303edf8d67dee0b1a95d4e96219634905088ff970333d3adbd25460902bdc037413ec318f7dd2615cf8bccc6b784225b80f554a10b483e1cf47c6f061ddef32444b055f56a599c0f675a2660858a96abc26bc6d13efed131ea5d66f3c5664aa94e6601108a5acd2dd5f86c43d09af52f3e4cd978903a2f150b3aa2ae04e43d4c25323d915f30f34ebe78ce551462f8ff0cf27d424fdd81f801ff9356ccd222ae2259c53d118bdde9dae23cbb606e9f772e6c0175d115c4e6182920c176b7052f8e65ee0d909453b625eb05d0d35613a4479d201a25d2d5883f8cee0757a5c6e99ae9c466bdb673e86aaf363666670524f9174fec4720c6cc9d36772b0cd1e56be3e09731f3722f979f6fed9d4dd28a05a24596f14e81a5265ca463e2c0c2c47883ed6c018abe5c6f2e50acb1e2ee78b5ad3f9888c5942c88dcc1267d8874b29922cbf3d084f538a4f187ac36b35b2b0c5607373f854b1eb0ef630104a572a8ec8ae71a2e230e8549b0499ce19399518bd36317afb53dc768264bcbb699cb3cea77b9ce6d7e3fe05f6430bee15f5c00c23353a9fb540e39a69213a3e3e936bf8f019ba6ae90a2482990407a334c5c789f74a32f84c68afa30206646e3f1fca2405abc82082358add9c537aa80b934c80cb40d33c336bd496914ee7b61b2231ebf963e0a7699645bf42b9401686606688bf56a9fa2bd6a26b8663d2b0189808fe614da42974883e07d12de1e433945317b55fe742b5f74fb37aa0a061cff080b99094548683e42adb9fcc72a82cd817c1996d9f3dc2e81e0ef1abf8ba028382437daad007b26b1b4b8c7d16ca569fc432d703ff3175f7168412f3497c2688669362d3d2d05c8161393dc11462367bddbeb475669aa73ff98ca6ce069d270d2402dafc1608bba48df4a3ed8ad4d321d114d1095a19e1a9a6ef21f443656876f28e04873a67591750c17fa9a4aa9643840708633e6925c9df0ae365dc5941e16a28efa637623d5855204dae207da171dceb94242b4fb1db38a3957d8cd82ea8819da8e42a1e7c7c357ebabe0a5364dd642065f60474ed39be24b42e2aa974395ff5f7c5c93bd80b2d202e176d49faae318da3b752c4d9773993f7593cc6a4dfe1d539911bf22d8c3fc031fe7ecc471125b2231ec4bc1ba0690dba317e17c890f79ff62a0d629c56f0ab7ef5ad19dd04158144444c3d9d311569991e02efee45b3967b5d72b1614c1ead5a648dce4bf4c65c088f8ae5c257a9266a9b923b55d3592e9460597f0fc6f0f86bd765c2e4fbd3e37f360685ef6757738bc83315b856b292b9bc5fea3f1205bc330536984bc2061c23b9d02ad22bbc6437a75679d717a72d1a3f15122996ea278a58b1029af21052bbab4a62f33f12a0c9a2e29312b03de74da7b28446c73785ab566d217f62196bb3b163750a41fea003dad3dd8b07f45af7c834c6e9e05bbe1b83d31792624dcc8066f391cb8a5cb2ac6e58a49fe901d824d63e1f298c2e079f2e9efeddad432e849eab93e91c09521d575365dab7fbad96c8be641e38910fa031033d1629618bc9d0f4cb1f22237febc8d9f624507666748fef9d6505ea81dc1006c56805b14aaa40279449f0eb4a8c3574726ca7eb32427349c1ff4eb1005a755e6039c499ce8addd7035749ad9efe8ac8260b3402fab9be16076a94f6a5279a1589c60bf8dfd1126e3a62df18f6c4f1901c47a55c94f716d5bcdd437e066745eb39ed5abce999a1bda5712ec96c64ad83383c0b9eda0ab937f41cdbf1886a4ab6480a1a77c0cdc7f479f62ec877f5b55fd1d1eef862b0250873b47cba1e02713eabb651b947021f9fa594444b09ac66c809278d7f573f07a85bfcdcb1bd6291dbf1c302f17a3b1e29b5dce9b306839d755aee0cb763b6ad9053a4f6c0903cca8784d2123025c5917f98e4acc91a68dcb097a73518fc3d72b9e61573124778d61a68c32e08cd31ab2dcdcc938afd0340a4c2d86bd15c8fa432e54b2fbf26e8a57d8e1e2451d95775a461f28d28241c9d4a0d4664fd892be1870e269e9b39f1c4b45293c96dd5000cc3f42677fb386578e447d483d6798e897ceb22a7f871940e4d03e0582e210cdf25c9c8819b5a10156255e80c1855858dad39ac5006449fbc87d0763113d2ed368e5a05aab0bfebba774e993a79da9d49399724574c085f53dbf6b5df31701c021c92acf1b4be82c6c1a16e3e4b9776b18087d98846da7ae8eeaa3781b28b6a492d0cb01ad994e783c2a9069d0dbec7bb606e936c04f45ba3fbcfd4abace01302cb9a3cf83569d1ce25c47989a14b14c78b60f247a189d4d01d6e0fac5af6b8ac1a5fca630b503ab575c28de02917ef9eb966f4e00629c59038946b77abe163377a31dd71c526fd23c8c7e13119cebbc1db305b230a001ddb2eb444c0bde31dae75c7bd82fc0447576d1572edaa4cfbc6988ff03d0ea0be9d91192abae81cc1e3845b7d7c312466a66a889a4367ab050a235500f3e7e0a70eee339589904c26bc137e1921b4c77ffa5aa2ad6727512d86a63c9c5b374aebb0887410113496fb96300bb55b6e4f324b770299530bb594f1a4efac9bbe150d6f683f948e2890a2130cf67707d9256334bf6aff65d281747448eca1d755de1041b61c583d8a706eaad8fe424ae44c4071bc5ca6fe9a4d5f3f0c53c64ede8411462bc44145da27da89b1bbfbc47ad967a225995abf264520c6fbd9aff9bb1bc2a145807b21d2b676a9685d51c585f305c1eab33368cffb9cb8a20915640fbfbb5200985f3d3336a1582af03082a427180e7be6a62e0b78040d20a71e1b892f8a417ae6dc7dd561a951c57e2531994a257485e35aab6d51959a61e0e00aaf96eddec08106fb7c11bcec2a9fe50bc75721a814c6488280b650429932e70fcfe005614b69d1210b32bc495392f7275ddccd1c597565069f04948cd841c015c9f42fa79d8c3c9f0a516139c30ab869a309db112797ff47167e347ace6b5f2a93bcf9904482840593bb873a033efa85686a70a085398ca52600d5d457e4a1993323e9cdee53fea80f68f16cc75b6ad6e250457c6e2bbff3bbe99050ef5205eccd2baccf7845bbbe79c2eb19b070760fba606af67cca3707bd759dbb2ff26b91836ea4099c7dd4e72eec51830678a1d3b94cc88904399cb9136b7ab178180eeec76e8976a7ee00aa2355f399ee9f34b35850edc7058ea89865b5c745ea3d291cf7cfddf0fc0cf4d54fb2414c216dc2855ab5998a80f1cfc1b5fea565257807caf9b7eb0c5858f4559aa75dc945a70557c4cb0ebd42f44fb52be56a73cd0e2763075172555d3a31bdb0a110d5e198709e07d917309a9ccbdcba15ec3fc702e1a840af837c06e46de279aee095b138db189c8f75a07afec33382019dfb8996cf5dd0176b68868ff19bed7499f4c4c9fe2c40da30125c37e8073d3d4309c0facc389806cf58b56ab1b742fe1133003ffe71e9beeb9ca368b4d72918d8103f550febee3575bfcc487bd4da405ebc6a5be86965f334432082571326ae38cc261bcdd8b2775c678adf573dbbbce28d49f798eb18dc09fea997bf915055deda7997e1d5d639c69e5f2f3567af0db07fbf948a5b65dc279a93d02e6f30ba778de422f43b00137f0a6cd2de43255d1ee7629333f8ee1b3cf47a7c27d6305165755cfbeb1582cdedee84c3b30fc02ae87e0927bfff16c2133b6e382a899d39ff3d9f915e270c22ade819bf55ed6b678a9825a4a21f2ab046bcbc0cc60933dce729a0bd905c16d4003b90843f81d848a39fcd9a1eb6291d584f5519d65987fbf6240f9f0859f5e788877bcee4df5aa0b05811194e93134b1188a5c6f34e876596ef049922e4fd783c0bbe5a36a568e76589645d5f3033178f10f16be32fa93eacc30907035be841d8c0b8263b0384d43cabfc67b625e6d6e1db5dba0894d39cc92588a2225bb02c2864c472665df2854d46f95f37aa75ddd42158f674240dba16ae8599e79fd0ae3e7249ab8d8e609211d44599e18f2db7dc20862b2cf151a6cbe3ddbea13852fec0ee0257bdfbf252862f8784aac03bcb157ef534d2475f014721e445faf84e3219a9ad8dd83b93c318a70c0dc354a92cde5a83d53bc85c14396201c9af66a881b7ccdbd251621c6dec3f729da2a1f964e0fc65c2eda266c810a50a33946cce10b487a5ded191120edef34335fb7afb5f99909ecf98d051420d44bcc7bc286d711724dfee27d0e02a8176a59b95023f7d12bf2d2a9c6309f11ef7446f5ac83dbc8ab508f131718a70ae0747bd8b637f851ff8c374a18ba3a7c7dfb3df83e9b4c8ab225f94c69114c43593121606e1398b7676221b06f21ddeb93d661732c2cd7f2bacf6b47968bc336bd433095cff3dbef104b78ec33e56a2eb7fefd21cfc1f34fa7fc0976e6f24bffac0db9b3ec53fecae7a24731f0461e28e3366c002356874972ae04482a0c3dd491f5cc9e2e9e1a2fa9a1553b81f3536e2a44cbc62cced08e211d482b10027cb74f5cfa2f661bbb8b7a9d92b18ac2d5367993260b1e608a97ba22108d1d1ac987ca1c2d1f1eae7a4c73d96b7fbbea51830bbf41f31c4fa87e3fa1dc9a8e998c731e52495e61354a23150bb35a4a925e39d3eed4a089bef676bd0a1a75cac64969c687905056b6e8fa3da78b969b0325e5b2d271b3bdfaf16c5af41578c59b34041abbe574085900dcef61610266ca2f9d98dd1e100e88025351f4fb7c48ac6d69f9cec99b7497d337375273c7cad74367b1d402248bc16810bf9fd6c25f93dd2d3cc062f07edc3b201a5ad3c30c6c1d08cd710411b878f157143116d6da908bd58978eb5eea295f188541d5eff7fe1cc925f40f25bdea3c037470de8e773ab83b46e4b1f609fb8b7361adebbc27e608dfd503305eaa06aa1f3f8d82825ff7429962e487064c4edcd8e20d8d53552805f3aae0da7c8e0b30e3ad0e77d4ded6b2a78775e03df2c2a3927f45224e93f30cabef52706103b9b5ed7a8b78959f1230c6831e7c22e61798a7c8447a261da69d8d2f67264a628b5c2d9020604b28e3d6b84c472b42615d657459079f44cf60f96f505dcee2e4ae6d4493843cf040d960ebaffadafc4124890d631b4871552fee7ecf4735fd27b6063ea1763dc4d5502920dd4ff835d99683ed2ff9b33a4ecc834911a6bc42e60181175ef4630a2257edc643e47320f14828053702944c60b52e36e181e734d76a9f2bce8080ae13b3e0d90c2053f67f7e6af52f8731f335fa39f6874d89bb852373bee769fa3014773e3bafd0b5d7b40a1a96fd55b429ef4f3406fd732474d4837c9ebdf57c88fa18d78fe996a977c8711a57fb58139bc94f8406974b3bfffda0826d322238f3bf777ed1b3afe3acb952c3c005be562ea537ce7b9d9a97b0ecbcc809d9cb831b574151b19c6e745343593608380adc31b03800fc0eac4c0d50dbd6d7f87b6376fa044a434b3789ab4ed41b9a265abe4ab7aaf3b610d80c62457ed7b76eac53e32c18d9db4bfb2b06d654bd9f9186a4fb1dedd80b3a0290913f022bf54683dd34328e996866cb40c3c635d985e4a8f245defbcd32f2cbac3e70dcbdfc0c5aeea687365ad7a906cd5c7f50eea1ca2a2d6194347bc2b891f178b04ca23b0bac06ff305eb321ffdaef8dbd1a98f60a0b46034755ba5eb5b1f73a8ad10c351fbada5587c5f5275b65a287a891d23ee6f69179e20acff0a8e45a3cb1f4b25390a00aa4c1f43c2eb319cab35adeac6b96969ecbe6d3e81c65872fa65d0852a90d95910438889500e0d8c069a14d5ec85eb4ffad811147987a2bfd72717256bae2d5e6e99ccf52c3ef053fd5e0f9d649d2f9afd7de9fdd2200fa1883f2da166585479e7846fcf21b2c6024b255231d7534f3814abc0aa9e00a6a15b1ca1ebff0716e31a967d1d138dc71b54dea07e55231abcaaf922c51312484d46e3c053da0aadf302a5f8d36181b5041211e7db4cbb0486d69f78b315c30021653ddc176c7a9dc7e4978bcfbd4c0f594482af7a60c86c5666d0e5c53fb2ea74bb1e9db5b78b9069fc43f7e815b499cb19290a9db553e3ad42602f56ab1b5dda180c53acaefe4575743e78fe02f8c02f4705a4af1fe77ca5189d94b4550979b8403cb9278406a847173550249f3822d0c7ac7fd99cd5678863e9e5dfbfc1a2dc9c75fab3725dbae9037c9f7a37df0fa32056f5b492f2392e88d628c1d1949e3f381a469d81b00777db614b3685859bfcf226d5c02ee2f1f682ace46d0dcce9bb74da88dd24716bdfc7d762780527861710701287eb9da854bf5f8cc160dd79722d105eec63f6062de50ab7266b77731f3db120d77911183811ee19b1ec56c8ca4358d115ec1702f616d19ff22025628cf38e09cf5b5a70c5b726c23206f102724980067166596843cb19feb8e502774dd8ab6fcdbc0a9f546bafb07428a8c8c4f1086a2759b905df284cb54a1b439ad071d79c9898a56fd1dce56d4c84b6cffc588e49556aed21d9011e49ba9fc2de23e87a898645d8065e419f4fe4003f5b0674816691c800b01cf13cd0d9eec3e8ecf1ed13e9a27adc53c11a1ef13ff73e686945eea773a2a2b2328ddcc4977491b98ff039fda2c5e93840b99acadbbfee3192949619b2544d7a9d86d1ba110bc33cf937939d42c27c6e82653fc09b4c903ff22ca0863ce64cbff339ad1bf16e09e3e81a92837baa900d692be7600f652a8a987079a1100cba619425b35bc469dee60513b4df95cff2f58d489b5af026752519f43480b8ff5360753f82260e48aa1efd42124e38cac92e640be0a1b3333c1d5d02c66fd5634c30de18763a89ecfe339bd3111e57adcc62db0fa9086251991ba2eb3f7ce17ad00d23be09cf9396508ee71348153fb1ddb3a76a53e836e03237cad4966054404c2adc53738eaeaef22de4a41cdd4b492f81109b774ebdbf03799bd2fe050e27048da56c23ef907acada86205501bcafa4ff9bb694ef59227fb955c1c993e510571c8d9d927f3ae246adceb731f7c4e31889cdd6388896ade4f6f7a28de68ec4d67ed0d297b9a4f32c86a0eeebdc6cca7568e39d169b9ad5d67a1ac20d8e6dddbe37b3f0173ba4a00d41e949e01bc58a503a56c10c1abc5d4835ef299edeebedd7f20f5f1d7ec76b9dffc6d6d1c0541b6fc861a8416f544ac3ea286f640b7aae82639415b3daa73d8b7baffdfa2d217e12363d98628291df2a90f03b96328353679b0b0fab71eca33f9245892ea8bb146da581a1fed9ec2c634588a10b94cdb2651cd35bc05e22527c80a8113a1e3b91c7b84c1450e0d4f220b238980986d33d438980199bafb51866b88735922e7635129c7985936d8465e91478e9888210f8a6d11a2e9f596f2a49e3cf49cac5fec2bd7f96fbb2670ff26ed92b3cc20dd7778def41e1667aaab37723987a823a65e0f96365a4fccbbe4f069914183aea04b762c90d4b1690003d0c64495077ef60149f3463774d481c38a397914df5e23858a54c08f1843e7d4a0d3a0e10f719a75a91e7c5fb3afe5a5a3e091e12df5b59a6b26c0240cf513f98eb7e762d23904cee7b0ca75a80bb3a0f84b564eec6e5aff78c56de58f55d83c36ec2cc1be19729d780ccd82562b54724dc363ef83c492763de8ee100e0475344ad7c68490130567279670a1ceb6418c6dcb2256884c566e2a80a5959c8c8b87cb47a97d6d07e4c7370246a1bae4a43e82b0bd940d5f38ed49db877b26f3b3a461daa3f6ae59186433ff22d36ba8b86adbd0d9a4a17c7aa90a89b518f3432d4a91476267113c7586405ed852f600b5259e988eac7b480e4163907f9486ad120f3ae5d6a403751fbb0e29a0bb7bdc1a95445884b2668c787b1b912e6d1c8580bfe7ba0de7d8d073abc798d62455370fee8f95a9793b2dbbe613d2e28e151ca89101e5266a0d8a7072ea9462ba506f7ee59be1b294ceec03bf7247afc261439ad657ec836f82d426910fc97088ee892411d4941d8167deaca182fb65d1daadcc4ae678a3","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
