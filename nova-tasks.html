<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eaf70c119c60fefc75f2fc1c6bb030197838631640973bd7195e7f9a850e750527efcff6ce4fd36ee773be86b075ff530fac9f31688b4545c1ae9f01febb08fb3ecd481681214d526058d511e7a35fb99b015800a0b19e109a719a6b5c11c2007d068372b462728f65c3eb5ae341fffcfc67c48a80059a1d124fb94e74d33db1b9a372a1fe1d156271a6595c253f2b17adfc5412f1f6632e18eaa6507930b5baf0aafb454c4046d23dd686e0378bdddf8c37f6c113b732a562ea273b2d6b4be295647b5f1571bb406a68290fba16327d5c9aecd5881b7f55f8f7260d3b6bf5123558395cd5eb62b1606def9ed0bffa06e8531f7cabc1d810bcd358f2510a6e58428ff26d5935b9c4a3f277f528041e9e025d69266e9ab2f297ded52eb59b949572e5aa8835e193eafe646fa63ff46e06f93ecdcb03a1d0c1eaffc458e43e784e4565c4b088fa336cdab77c76b50eab430d6abe01936d3a7f8b1a084d9c940f7cb6fa975f801cb67d26e3cdaa737da19c29154aad4948c0116931fbc80bc46c6990994861c7ee383a3ce4bcacbac08dae2b48074ddac20b6f24fdd77ea63e51ab41c4aa648dd096073f51b7af01b255bfacd44f678debd703638779ee219037151ad952422ffcab8aaa492fec18d62b567f20fa26a58887e5c577f92f4fbf0d9d229ed6615c3d7f37fe46e0a93e7eed51a5dcd40020a18ac9d84be3f23af385727d2f08f1c904b228aa8e5d75c5aac7d86ebecbdc0836e449610c669fc0af26001d103a541d84d8c18efaa92b6392572cc50d53bbdbe6ef3160543c59a1094b0e84e88ddd47705dca43e49819748f20512790a8d0ce95675c78813f46b9529c65b67784ce5cf48c1a071a4b570f8c551a93200bdc740d2075b203d250d19d6dc65fef2ef370a2e7a19871e93f396d0149c464b2e1401ed1d79f9eb46c8e5b29a838ead3528fd1e2656772663a086ae3acc3c860e94856f183ae7563784dcb0e2a90a165129fdf494e3583dcfdb5ee11b6102e64e18fddc8d4db3e79057db7c65706b82f89fb6460090b5dc5e1d17965a90dad5af0a01e4d06f075b99a0aa342913aff2c111634b1a3338e186032fe438831141ccafc4e18474368f67b04aa9ca78cddaeea1bcb054450b47400334acb41106fc7297d736992f17ae91523eafc6c484d5e692a7d26f2a2daf0028d6cca9ce81bf4e59cbfd16a8520fe6ed9e3e2758e9fb7b89be3b956aca485ebf0fe583f04384c7be5aaa05e8b08d91eabaabf70cbb393f688e2ec6c8122f03a0141c241c2b90b9f5471e5d85adc796736e652f512efcbccf6a9fcb9a52b30b4706a6cad13755dfde37749146c306b4d73c77159a01838126afb4be38c12ab107f044b848e7beb15e24fb3579c4285609b6d7d17aedc545755fd913e184d30e546a03aa844afb1c20e8d55763bd55205db09fc3d7effc4ba5897b04c0b30331026783fd57e669bb33845148c5c067f786daf02c4f968b109899a0fa6aba9b3ffa3f7f3f3f90201ef035a0f6181529dc880176866bfa7c10b294e696babdebea106b7c7f917dfb4aac29eeb7afdac43c1744437de6415db5cfe5fb7ce4d0ec6610b11e4448efbbfe6b90372395b342580454a9faf5083992a172e15ec951643237b2e8bc48be849584d7acd27756d53cef772fae4e5927812e6da09c776de61cd400f3509e0c95695d8011d876c49ee4af11b427603677c1952ebd1ee9da7c80ee16776aedafda39cedd35c90ed6c85a35df3c6751524f6ef4aae60a6ef70a9ae1c81ff6a63f257261631f6cf2622a2b15873a674460e315aa051efc3f01a029261139068c750a21a2a5709e6a1910a4d0b0598ec24415391bfd326107ca20052492bf99613538a0221587d2adbf072bf54031e8031fadf62a2d82ca7fcc96463c80cf2b5c56ce0fdd5ba1d25d823b3205ea3ea07e3d956df626b21206ff21016811ff1e0c8d086aa29665371657884069bc1ecd56ed7944b72477886f828fdf842907266a88d925b82af42f40a4cc904790323518d5e006e303f5757db6e73eb29524c588bcef4e3419a6ba429e7cbf09055606752df06be19b12f90d911ee3d0242765d15413ff40f969873ddb459fb09756413dc42b9b3b41bfc2790e59544bc57ff0088a331d3d6edd628c799f0122b29adc3d9bc20c3fe7e3ccb559e67f7aa4077313b62d1dd91b2a7a15d8f6a792e758ad1e73a466f14bd16f8334f1954f876ca0203de74f081ccc60963d6032a2539c9b8b73cc8b6541fb98c81492c09440357cdeaef8aae17faf319fe0c4dcde01f48b1f7cf9adc3aee9aa18f6a0336d22728cd819d19b2909bb54b5e9859c7c4beb8dbf4bf7e5d9c4e37c128cb220d9f1eee07907bd7006fd3bdc442fd6af768c6a0c96e18b75e11ecee2ee2741b0463a746408407c6b36e310322ec6e85bb978dd7122dfbd6274efb98f44c100cf0fd300f032e1f5c2ad0248ebfc4b8193da2a9090287ff1e82af219c2f5c3ef3e3a8e35aadf5028733b183d1cda50c061d6fbbdf1ee8d55f7fb3f2075abd48d70c6af3babfdee54b6e0145da875f9b68bdff7d9cbf0eaa9c673252638fcf67c9d6ddac5d6470202df132eaeab82b87d6010322cf26dbc8d0610e3cc477526d3ef5fe143a508423396ce9d1912edccb4bbca1932bfde9c5cd2688559e34a1f2dba0173a01775d68db8a33e6553199ac7f47aff1fce4efca3e1470a39db62198057996bbbdf0cce09bd7aabe528df2a8eb8c69f4a0c4565ad8a114c9fa4d8aad1d3d663d861e8f35d760dd65899d9071c98d343687e77c6582d957f93f9e1aa8a8d159740d53ddde3a79fcb0b093e47a8bc8cbcb2c15624cb754a9874a6d2ea8ad7e8e8ca64e68f990f77d492cc5554b4dfaf26b52dc03c81eb73940621738d9c943c1375e23d3f2fea6dfa79f41f68b09a33033aefe081a41e7e0559039cb9c5d9be874e8c36ea18022604e17cb85066ffccd6e666138d9b460cca2e128e72e50ade7c511401332c8619c8f0912a4cb2ef202f4cc079b26dd7d33c017d369c3f3b68a569aefc117dbf8a5c35f7052b201a8fceab929eec59ef635b7ac01ee64ea198e33c9d785358560452c946f3227dfbfdbbac899df6c5ad9ad770ef37c492524ddf1ab85b8f14045d569c444d4ef2f08589fed0f789c3137f70c6624438026d9ad234c211c82a6b7a3d6785698a0a6df40c9b157b9c8d9368bf7f8eee0c962e3bf15e2168e12b92da38a2bbe63f962a7e8bc9596c484aa5fb78114f2c57db4627883a79d9047e866b90f6938e0df67194202edd4b76fa3635beaa857801f68593042761205b6dc1ba753f526817cc007007b3d689faa6c6f322b36387b2d6315dab0c60426a83539472f2c9a67e50a7a81a5e0a4b307f7a10daa0100e6d5c1b6d9058dc8f6f44ea135eee23098badbb9352c115e0459f080995f31cdb6b5663249ef49edf066f2ea36c60e7070fdb60302242f83d729ccb60b0af9f91903a6609c60ce72eb4c8df8412a35dac37623ccd440ceac5bb0ad2262eba998cb6f82822b42ecf223dec293447dda5e6178bfa1bd656a80bf954865582bd0e74fdbbb27f0e15db913e0c9eee1f1264ec89cd1524cb1af17e91b1e8c86b63133fbddbb946a07774ac829211d8928d0b36e46d64daa40d2ff329ef671810fc9df303669b03f80666c5d4da3029d0da71d0589eab2e56f4d00e748d34aabc3d27bc05eb9a44ac16fab9e68dc3e3bc84817a8f43a5f1a4f086f033c154800ab25117e28b1342429cc2945c653cac572083c245a6270657a7b8fd465dd0a4ecfed68cf46c886377d2164bb427180d6178c3047af825d89fb49f0545277b6aedb69f6b98d8b9cfee36993e1fd638f901eaf4983c2bc8c15c4018b87cf0354704f28d053aa7e6df9b0fa877a350d6e7c972ba9e4a4b1ebff079aeaf56dd4d752fa2b02fa63f1ed86ce8ae1f5a32060d485491c44ea6c4bdd8088e51ccca08d8e9278b89b6892680330ffa70c6d6957a7d5c13091734069912c2113e942c2983fde470e2964ee33ecad3eddefafbb6603d29304e1654f0eabdbc2645feb6dc13f1383aa0fa9f746b55f351fbe5b37aa77e2f632709126582ec8c1f45f251649a5b305c7f5d973b0cec02427efac77c9241c6d8a9617eef55728c195ca43e98d8f92b2e70717858e544069219c0461853c3d0a2f1b48cf7f928dcafc48966c87a6138110bb4b1cf53abce4abcc6db648b21209c73f2248fb7218e81d1676ca2573ced85cbd4e3e5049b0794c9a4a138de9a9babe91542f449b0eb6b6eec2b9a7cf07b7fb98071845c41ee87e24da64b98f1a453a8c623da3fbf6659eadb4fea4b97364d974891d9721fca320f6b78894bd27133e58d81c73556843c7bb6c77079bde18fceb4585b976bbc79520b25f2fcc977f3efcf499a9848e6123e6d78f7f9aec068374b3fab0496fe6c7155725771dbb500ece3db12c1548af3803044088d5ee2a7eddecbce96a59aa93c26d098720e3008f3d5fcd437aa00848336a81a98e7ea260c8e726f1b30fb3ec4d8ec4cebdd092b100fdc0b36f2ada197f5cf2519f6eedbd148950c311607b58fa83b001ffc653ecd57f7a4ac427a922ec541c5e6ec5dba0cec3fe29e1f92d2b94613ee1802f5a6ed0d2296f20f1ddfb27112ab62ae053030c5af926b1fa4caba6b15e09e01688459e3a8ff1ce6bf84f62f681a447c9731f85f621737b74c593ea54a1a9d2f32a4fc37f8b4f8083c2950fe681478e31cc889235cb14e5e1bee2c7be0c36b9d497df4d4b087f91193683b4318bb4518b6feed228be7aa98e0efa3bfc81a45d93b07edad713918003a82472c309ef9c23aa9613764c0fd4a2d50040be394db3aaf6df2b413eb11f256f546abc5c4d25d45ef6cd2ee0cfd33bacbbd4e06c5fc72dd579161841811a2bf8ba2b40b34bab9d5ec0d81a05493b898c1fb471585dda05e654ef31bb5392e525801bb029630f1f398d9c3d3bba80f8c31e189790802bedea6102064d0ce1d154bdf35cc673e595a7a43fd082236634bac73a5c684e59a93da72bf7043aa819979cc0ac74001379a6db255e679c1cb9730d45c9f0a72f10bf73c2df97562aee30a1c6d605212dbe6449ed577b09a2d208fc7b8f371016d55dbf17fa1ca29ebddcbc5ddab93ecab729dcb90ae9725e311c920e589bdcbc759633c9afabb6615c7f5eda95cf5e2d148a13fb56cdd282609bfb8725fcbf83bad04985d560d1df9e4b535e8e0dd95606bc3c3857293681aa3508509ddbb866e7a125ea357592310f190c50746df361944c9399e64c295e1cd27e9e4bc1a7be4d533fd27dcf338439a9b01dcd636ae48c0ad2e8301eaf05e7dc1e2bafac484266eadc05f008d686875eb205aa579c8f6868f1db11989d73319896ac3c043cf8fc69c2ddb9f4b88517501c3572929ce9d95e24760b57d592cad262d4779d61327790a18cc7ea6ac5b811163cca34d5a371a1a1c5a2eeada163e3e054807c419a76ad964a2a334c797cab433fdb84ed87512c1764bb8c9eb5d81bf0661308a929addd0e45b6a705321a2eb56b2d9a00af346e2adafd15ad8d9ded4ae31ce99959cb666da5fcb7447bf0744bc7fff422524ef5a46e35740d8c69f776bb51aff56a93fde97119a23051215916dc9c390cdf16069d26241fa2e44f7264a0c1389442765b60916c8233e214a79328a9f5ee733d55bbfde11c87453d4f15efcd4faa6ef2579690e850c656d9e2abf6794c182539dde1e05127e580111469d76bdca5c0cae74c7ae25e2b61afa4b4ce010073bec3d2f9fedb46eb36b7fd223efe49ef532df86353878e98070594cc064ee4ef691c3b0bf58cf4fff47eaf6bbaebf9f12fd211a6ccae5f5ae3817fd455b40ef877fa6d4da591a331fabab43d79a0775e58b428fcd5af899e87593f8a9a1b8f324874cf5312b54ed42eff292d345a5cf6c78b300d7b94754a793156aa819e4394e8689ebd37ab39e1285ea344ee51f99df0675d34754592c37138ec37df70dc53f75d53022712255547c3499f5607e5be3050a9e5044c0807eaccdc00d43836fc5122685bb4592d57c9a3a42bd3e836d80fdab482999cd0bc876cfeb2c0c4e38be1b8d91d08ce74585b0e13ef28de728cca7889554c07435ec98b9f65a820b4eeb95fda7a446c91075a76e49915205e9d12cf4a81f3572bb64b418d4e735b88cd6f949aa020cc28ca13ec278ca4078ad7cabe12d4dd9ee0c12264559dec795d48e5e9f7ac892d74030dba3afa5a9623c93a4da14b12bd91e7ab4570baadd952e8c0e76d2ced5fce2d63bb2e57287daa339bb6ba34eafbfeaf63793b6d8416e11e2b4f8c8c823e2fb3a4cefb06fd06fd0338820046a58b8de6cc416b9aa3804f4d85a5293c68cbb88cb3ff658ff0259c50e3445132e811b85cb483e465273df7b40c461e581013205d84df23d3f639b46a26033533aa0a600e215d27153d7d9911f3fae5df5b9bdfabdef5445dafde2a3d00d54a8d2872e0c3892242f8415593ede168413a84311fdedac6514bf884f1305b91bf3d3501cdfd960d9b6165015a0cd19de39a20117b2c23413185f2785116d5d1c76e1e3e6e92e11d7a659b1503bd8e611927b7a63e2ef8b4be68f953c02d6d4ae3c933e42b18ab2ed627144ee6cc6a260de56ab3ee7c07ec473f26fb519bf14b60cc73c821aa7d19ea2f0bbab2c6b5e130c23a5c339620cadaa312a719597a6182c4fa5145be8812e2b2d1d38ebcba7bd5c21b236fef1d4294a881c51e517101eb286b3df0272a97087faaeede2992b1dc2ced822825821a8b4f30c968aac6f35b28c6b7a3a5fbcb7c94fb39a490c5446003f230662fe6f03c2f0327d6a7aabdde1f2097ad991d39d322f9a1c25628dc48f31dced0e2202ea996865c8008fd259c895cc4f1534fee4ff41666b9b4f111b5fc5952dc6dc2db4366d68754542c25e8d7ce73b7cacd90553a4c50e0f2a88c94f53c6e17cd291e3bfb80d9523292dfb933cbbbb756bf410200bd09aea080d693d6b7bd78c84bd35bb7ae124a345cbfa071c6e2a486e8cf19dd070664f4b9b52b2df44bf39d59e734e09676fce2d1f16f0563935197b204e97aa75d5cb0e6d1ef8bc18fac340f82ff93e525b4d67f7be8c41d45a893852ebc0167dc5837c8ea867e51c3ed57d93326f870c5b3e2b517f6e7e687a859c4f94f24390498996f96848936fc65c5ee2bf1d3619f2d14c1fe8195355ffab073ffe9ce53d10eaf23f41b87e6a86ba5d393387f538548f9a43b5872e5450c053377f587b525fee39c9a624666ef5309ac822975e396c8e988e649e56eb39269cbf760f1eee2f4d2e81f90fcd483592659c52a8240991155c3469f6d90a5f4cd157b06668ad426e180c76711c25eb58b4eaaa4cf6052aebf7b87bbfcfb5971c414b84e647342e48a07d92144155931b4ef8e295314382399472ae40864ae5a1700eea4ecc49a21a876536a0571057c96ea429faca0ce2c91a9b7fc699714083f6560b609a9a4d05c371b11f44fdaf1eeacd608a3de9b250ab8a84d64526d15bbb50f7f16a0adec487dae6a2ecf646e0a821a2c6e36eb4c623a97376e72db976b3b3160a3c9a24cc575037b06c7ef97d4709f50a538e210fa3f171c4e2781262912e505aaf2d9bca0cca95941cc17a4469bf8c62e8d0477bb52e28c2d6ec312ae4ff1a1e519fb03aba30d686c14844816a1b720f5dc3be2c80b526dd99719d00083a58f8c5a675b9d90b986685d1f47f8349f8cc4f76550dc03dcaf6962589e9fdfa3a0c769037d7910078f7da9f30a1edb38bbc0a67198acd614fcb63897dfe420de068a3fd45da32354b9bccf56680263731a77b600ee5537adeb3cc45a5e31ab3cd3a0bf405cd44caf93816798293cfae1e5098f7a396a8e0d62a17a1bbc002d7e221322adbec4ca4c85d370b045ba57c57f6985a53611d7d1d3b51cb535e9850f761d6355845f51bb2fc550757649c8128f85859965c6cf80b1f7cb4db8dbd87e14f0d490efab25ea435a6c854bda3c07a85afd6df735600aba793a94a57de4136c3b13223b2e71bdd89bca3a41bc64472c2770db4f36f636d9771986c5ca4fc598e1a5eae2feebdc91e8518af28f3e8efefff2ef299ab5315c6dfa89444f4c9459812aa6fd05a54551f81bb058c9070366d7e8de1a7721c6b0976ed5e961ff11942dfe7837a8f416f53487f7fdc72af8e126ab2b2910f55fee37e65c3774b7b449202b9ff1779af69f5324d9bd179e9e606a43fc71e4d7afd4189730547d69f9d0fcfc8f38278b7720ee0891336ba859c7d22ca0fc7c8fea562b39dbb898671acb054eca034ec14c2762b73ebfe9467b1fca00ea08a5cea1c28783cf35095a3c3edeb656499eedc7549dc5540164c44697f2b9424c7e5c8dae900fabcc4efb7a1fc8a8ecb6acd610ba964dc622f37245f310f950c1a6068efbb77eff881fdcfea812231eadca88df8e3569b90befecc9b4a7e2822068adbe319538c5a792b0152ffeb321b72469b7069b871c47ec6a5b650cae37284795f485c55f828762bf33efdf480d340fee16a77c59d8ae0247f2d006f040d348b8b18226c7df94be0728dbe72840481b85b35debb98408e08807c35b0cfca6ce39e03277f57d56f82cd9279803fa298bd48fa32f14ef0efcf31f94f4a278ad7ed2d115cf022b8b3906813fcfd68455d1964071e48b674f4f62dd826a3d433ea477898f952c7c53ae4db39784b35662a4d2476ced5e171569bbe88fca4675343611ac1b7b2e1ccfe5556f548f669a9214f6e9192c01eb1d24f3709639a2e6e94bd845a279b9ed09f9b7be17dea1ed6dc5a82e6812332d0abbded6d9054cf9470ed8e423742f21b1423abf41d0ebce429899177570383cb5cea0009e48935f0bc20bda459ad6c98e49231a6c8440e858a1a3e1c0e976af19e4133cf44481b95e06466cde84df7e45419829953803e811c5e764a965c40bda40b4f7c3ad637f487a78fa1b57cbf6f4cf00aebdede6dd08c9fa7f3c6888342f5187ce3d3f6fd373cb5beae48566c156ddf4eda14e159f7fc4e79bd5c3454a9b259675ce492a3cd9ea5c18d6e322427ce805fe42e9f4d648c0ccb7a66a626808460a5dbd01d061278ded7cf90412e05e001b584bd8d7e47f5396ceaa8d9076bffa807c6b6d0a033297f7cebb1c33132aa28b26e6b2848423a4c866065b987c2318cf4ab7b377572f22ab5226517822abd11f336bc13db68a5a21ed2edd389cbd5c32b3d9d46be9b500c6fe16f27aadb938c76f514eff1e629b410510e5c60e92956a0fbcbb172f9aec00807f04ba9cf3f1bbd665364467c76612d9b2c78eb56e4aa2094be89575cd67ffd281fa0ab68f3eefae58e61db128acf34b74e5f62f4ed82b520882cc8c821345f41a2e4339645a08ebcf40c529726fb61c0e845a409e826f33423184a87e6d8dfc4a6a320d18c75468788fe2804d228b42dd3d0db83614d7112b404fc9b4a6c62ac7fef8a0a7cd707c62e229c44592007477ac8e04b145642092b5f4c96f7fb266eca6af5ab5cd8e3ae59e835df6a1c31ed0efe0e972f6a0b4368359010b0a1d4e44c391d228325a9f52970a0423c3bb1ccd6215e5467256553cd69630e2c3629127f9dce7ee1f42ea77f415703b81ca383d85ecbf967fb8ed2a3edbae874107a2a34fcc3a59996be3d9355f89655773715c1573ba9b92a3ce5dd9599b1f90f5580828f28acc3fe1e19cb492b18615abae13cd6819ec428ff46c1acdbf27fecde2255cad8ac29e936cc457de9f5757f85c994cc285065a32cff75a85c3b9b8191e25ef82f306fba9346a938bd20e8cde08632188eb9548f22cae215c1f05aab97c67e50a9530e38bcef99ef5bc3dde61f83dabdc88e862dd7f49b8b9041c8d87a435bb31475cae4592bb2fe3976c6a9920fabe629a1b3f1d5a8b5e7b87a1d5374f39049dfac620f7dc016371bccd7e1bda7c0241240fdca156d117a13d90660360c8489187581ed3c6eeec5cba1281e5e51bc58199048bdd8438a801401a73cfdb438140d12a79bbf76efc088608b4a5bb851933d66a1d300deabe43c108310b102bf396d23e4a8ca88137b69ed9b6701f778e16799e3678c9142637f9da088a8312bf95cad6fd8833c78c3371d582b68d01ecc696e8e4c00348fc6544d0831170946fc23c2db50c8827b720281f0c3247c4186c39499a6abf1c727483407050b6864da68ece026d7e8779cf5df2c6bc4df230ee282b3eefa60895252ec290fe05b10c3455cb0a07fb50aafe45f3b2992340a4433e204a4bf83e077c52cf9839920f8130e4a89cad84a4755d9b5c4250c51d39e1fe42ead39d26358ca9fe3501ccc06cededb9017d2564a6458a7222eabe268ca4fb240b8524dd1fe900b9bf750501af5330b037b74227348f2676e6290e7046af3407ff999164890bf4c14b27bf6120a33e0b1a032fbdb9f4d691fffe5a0e9f8274a7adf99e3ce9d503a40e28b99ccfe94eb98cfb5d7b87a912ddb549f9d5013dc93fe39217f58699258c15e4658c667afbcc8a64fa3c01dd63b565c82a072fdfa15a7948612761e85f0133b037dd607538033ac10f9326882c5ed263f9c0ace80d20f47e38a7ec6fd60a2fba85e09fc96ab8a8fa6c79ae9177044312967e1680a7ff2e40ff0e0dccfe02873a7be3f2c16151c40d80c62a84ce93dc80bb71df0d6310629dfe19bf0faa2fa2e61c1217997935ed946c7f006e4244318af409d1a769b7240ec7d4d20244cf69a0bc35d36c4879e5e01f2a76668346fdfd4a3725216d458820db68515e3c2614ac89b8d95ea835df7ada378b1bca9e500d33b3d4f832009da63e73a60cb85a5fb7c409ae1d5df3801ed0a63e30e26913319e8e49a4708ca2c0549bcc1abc8191dbdb765e6e76cb4255b50263bd860cb040ee4d8ce417dcdde7fa94ca534f0a9fbbb2bf0bc11763bff3739fd60340896a9a360184068b88a4eaca424a571b389bd5fabe55ec9f389b98d25eceeb5969cc0e4e0a4f3aea0d34d5a6d4124ab08363e007e4eee65f021448d6a332d302e8cd9ef441a297aedbc7a482b86aac5026fabff206543052d41456f70354cb5d0e43de6036534d0a2070e12ee674c9905ae0e785b537105b8aaf215a8eed088c37f946c5f03b56adbb48d52764730d81d657829a9a34573d06b34cd6539d589b3d4c0e08398a57cef6f7665e3144becc2cbd6838e4b837814fc7dbae87939f3246dd57b132aeb8de4720496e481c7eed594ee6ede4167c88f0b36c401295d35fc5b620e032fd49e0893721a41533394c7d51e75ba76b9a4069762c0c2be43182c4eda9404ef4de49d68a60394c969cb3e6e59e2b44b13d9a23dff24a97c8cf2eca8949359b6ecf7b102e80a4510bc6df2639b841f7c54b47691998b658f6be0a3156ef6ca2a81c4c0e6e0572dfc197791f6e92508fb0c4ffb31e3fded443807e5a08ab24daa36514a1ace09ec09999e18f07b2fe8493d5efdf6e2cb1ae5021d23911cd2882238288b80ae8337f5d724555afc0035a3b8efde647bb019eb64ae56f153f980db1c446757f281c2a51f7307b8a5ba7f2bdb289b720cc8a0f66ba6b7ef653416aecb48e6e074b273d27c64415d17687bee73a17425c2c78a3f78d4af7bdbf97125a34be3addba50d712100fe76aed2c89d64b7bc9528e47279b5c337591d18fa678097b236d36c1a5ddbe382bdf1409f14d2844f9cb2640ad9630ddc0f0658311bb31f7d22d2ac63992844628744d572466036717217d0710856c470801570d7128d533ec3bba7b7924e868f384acef95f2868f07e1cb96db06d35a581c4bc980078c882fcd5d0069d91cb61364064e9eca31f019deb5e64348b0d73f6bc17f627ac4109d94e7a14f0e5eb82a7317239824909bb60ce44fda89b739dbd8c542a7bd0c94d7d0c07406f74f63054f89b95c34c3a0242032f5156be69746988746259d4d6dcf7fcd891b42f217bf42cd49e1fabc17cb33b189aaf8c819049bf75e57794bc032b50f079f0d38ce3dbff9d7ab1ca3a5a35b4087e1be275389ebb817d65c7f2f0165d26b306228f954444853ebb9fd66d57bfa591c4b33f03ed27b084031df3133cd0f4c15c69d62efc4f3eb261ba2ab73c73a64d800010d5964fd4f28e42212fbfa88944dfefcff38eeb65e57c6845a9e6c0824633cf69f56a3a12fae0d15573af04e25b05ac68b1bfde33b8be322575a60407eafcb10ecfee432e0ec3d8a410951910adef8e524c5a38b2709a7663178036ce33851073f5f60b01278681b268fa61b1ac7d21acf9b1356ea6b97c8cb829cf1c44760dd00b27fecb2f9e4ee218f018a80ce014378fcb97e719e3faaea0b9821a56635abbfb68510f7295dd2b510bbbfbd8deff60ea07454ca5690c9b73064b1de53d45f3681ad099429ac4141458de32931a4e96415d1325a026d1fba3793226e6155d8e390374ec39fbc45f5870eba823a6a1c6c02ed8ad40a6f2bd51201707cc0217aa5dc9e2787cd0d5dbb6d6ef93ff55c78969c5fd085819e2adcd621e8a181805903a0face9aa181cad4ff7021fcbf72bcba29311b6138e2a63b7ea5a3fe641f00d8c3b8254ac15587ffef2184bf4fcd80a552ff3106aa42a462d55230a05c3683b8ce1a15e07d307bcc992f5f630e7f1f262c36397bbd31874c4c140f5a9e1c6d10e7d6aa15a56569b5b67d5576498c4df7bd529143f1b32a3e9507c94e5302af84e4395f45843551d4623886d2c71369586627de327969b6499d82355029c3422b9dddf7b28ab5745099650e358b722b51617fc86396eb60039334b3722c6927131889342a5a3b0c4c141d88b8dd10810444921c8c34eeb9c0ff2911483599f271ad036f76ed2639775f9311a6d666e26e9f8d6fb5edee3e2a6a0d6435a05202fb6543dfa4abcf940709328aa6761afe3dd41cfc40068a8c724bcd24559c3b71313d77c5c01992c36781b3319b7573d28b66876148ea799289365f743851e5cf39a81b6ef1f062fcacfb4815f87727aef42a9613997a0ca3c14aee6ebf7549c0f8678a31d96d6fc4fba631b21a9175d3847c9c10e134f09e8339a6498f902a3bfc817a54ee0f7cc9853ddfa4dc6cb23e153b3177550ded83f421ff810d9ef2c9cb60cc795ce1cfda5b2d0e22d4e36596e7b1a5f1d658ce69e8b0ebefbc57b847a137ec7d32ebb6646271beaea6d49fd4aa574f1c7e0d56353e3a2c03fce85f533b4bf0c88fb7b650864e6e86495f5710298d6251da09026aae4e67a1c44fa843349432dae93b09093cd8856b5a81cf7044af0083d2a2426291e27896e4127b14f03319adfcc45b9779404627242e61f4e850542aa39fa87cea2775022f39558fd26b63b0778b83612fe851ac8b9f4fbac9ef9e9ae6a1f34623afabd421b46abc6ba6281528becf221bc3c3cdec1cb9c5fad6d01dfc13917d48604c40ecbdae21fef3dcb39ec8013cf95a9da2c594ec98e50b3f7c1984bd094a089caa98a005444ebb8f4bc348481834e90aeeb8a7c460a6eeb83a8ac9ccd0a8894d375d0cce0c5190614b32d447d07e9081bd47fbba09dd0e863717f245b72e483cc44d737ef586f4f256572d9f91dc4a183e058dde97371d19e20e014bb72e24cb0f788af2f06aa05387f1e5ba619d26f44c8316e34d1876fc39fcfd8d6f731362082c1b50d47edb8283e77dc08d79867af6e1a50253090d6be2256c5a771d09b25abee2102766c853110cc46bc5a35abf204ae34b57e473466e0a3672cf0fdeb66880b68c9373beb831838f5b47cd82104f4b6557c1bfe92ceef898d82e59424990b4487f5669192f32e1c8c05bb6e9ddbdf5072db0c9ae53a9a5a009b6ecbc2698433359af94b390de7f7d11a2c9c4655c99538a3341b6cdf658e09df41ffdb24a8ffa588f425256b59475d15a55d009f12054424d2444fa1be88d4c191a191ffd95aa6f8e4b84e294ca680369c3853f9276416e9aa0a0e9890a00e9b7c07727bf9719d147adb9bd8bde83ab331710ab920f13bbc3233967a99c1fd705ba545fb9cec2a0598047b759024dadfdc269fb142f5ec65c34362e728bcb59f95d6c7f497cb70b7eeb2bdf85beada9f079ad6898463af33e6290c745203d986cefdd083a977daca7e3959ad267aa2ce92548fb96cecc6b2c3ec80c1c0ed31966d1430480eeff4b250906fe3c160c3c3057d2c84a56206d50a97c373ab7ed9d1ffb1f9d3f4489cb60ae5038452e863d2bb5f33e3b32df9b728aee097e838a4c224362de214761e8813bc134d371ee8cf592e0ec78dfcfa8509392b58364984645c48a3d974303f428654093c1b769cb3af0f677c043cc214b1e737334e0b049f699e5f2d3f39fe38e8ef960adc03fd04e5cfd72d9397c4596f0b03f59f6947e6b3a72c3b96c1020a6e0dc3b665b0b6085b6cf1cd2f4091c0e99cc90515279205c1b67ddc65bbf7b","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
