<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c171bed1348dc3b0324fc9cbe70740f8641aff2516493acea32b8dcd71a1d9e6d97571057ea216a07cdab2dba51c76cfa43ce855cd4ff48f114b2bfe5b32124492cb17c768ce54db373a238e14a64739a09d6788f334a11803826f4cf776fc8803a8fdd604ffa9521bdc9458f81124e3ebfe312b41a6d211af1d4a8a7bb2c7b6e397ebe18beda1ea8a6845a628b0e85990c7c3b05994ed7da22189fc9572e9b57edbb465768b4a7c9e45bd7e4aa0418723c83f3c070d231d2d77382af1dc297d36f5785cdc53c855e1e331f4d7ebbb3a4fd3afc8f0996c5227f95e277cddf9b7a48c072131c6fe8e2be10cc5c6e20d4f2b9549433902ae313d81563739de4beb88e1515d1ebab5dc60f2ab4f99cbe0dbe0f21096c2b1f7ad50d17da10345ecfcfee828869b1cdaa7aaa1473f97d00494bd77551dee657690de23481dfad956bc9dd3d1e679bc6e06c656d70f03479ff10d8980173d1e4ad5d21a0d299a08c6374988eb26bdd7f474e06bff6cc0ca1fc21eb1ba071805409932fdda82a48099c2581b3f2b80d99c5c069bc8ab544a409f1ec88d456a97d40b281fb9e9e3add16d026b0728003b4827bf9548abf1fe5046ce584f7fe742f886a42a4b79bf23e13b5d72f2907b14ae7920b64951247bfb6eb504dd7453a104a7bdc9112ed5eef99fdabfd210a6a578c3dca1f60c0e55721ceb7d247e0ce93b319b1b9877bdd3f585bdbec0568512797a7e0eddd14f6a30e362f11e318737c6821e9f3e770a16c095c54e2bc23eed29248d0d7798b7a0a049854a3b3271e71bba026d103628052b7172eda7498434ff0aeb959e932295873eefd76d71a6c0b495115b545917b25363ab42884a0b5696214bde94e2ca9c710a4d0802c6b82a5a4d00c09f60aa187226c9370f295699322711bff7ee938eded549dbaad978984dc8337f1eb0fe0a116feac5d6370f5ceccb829e18e47234de9d2b13c4c04f1488009d546ef17188b55a53d74973630553811a641a814d37ddb83e2ecf3798156452bbe05c68f47978f88bb608396367a1fe69d8fc5a6314e49893e40d7ac298813bb7406a410af7ab2ae6e3932347df4606594cd35ac534d9503f82c50ea1e1e9b0c7a0cb59cae44df96de5321678237cd32655d79aac111c47417d2577ad974bd72295ea3e3cd1473b0a775d45a5d50b88f936f6f8bbdd5f357b3ac57c03ef7fa1d30f2c494680118282fc65b37427a8947a6142462f6b70a71976037eaee395e4ce00516e646cf383ccbd37f3511a60e61d114d34d115fb4b879ccd7bdaf63aae2cc961bc4105a64c698fc3431858d7f6e107ad9d7213d962ff86938af662639f0e725564fb9ac36024a0fcc18cccddde5f7deb41b10e2acbf3f87f664f1aa528ecc33dc521eb8a37d1e3ab18a370a66f191c11b5cad0a4b8ddc1a9dc2a3380299841527d58a0951d19fc7d59cf225a8f9d97177c54128790240e9e1bf5e360f5fadae0e8daf968e4089838a72a2a7386c784bcbdf64499466512a1b58ef12d8dd4aa393b4047bb49317ade4b2c3ec0eef4abd8c7d864dc29d66bf46d15ebd4c0f4742124801c323035eb9548c2f24dffeec9c69de3780c87fe9718dfbc606b8a984fa9b99d1d7da0b2f4e6bb9be18144dd876042da44c016af856bb2404fd757df0c52ae05799b115801612eecb10e31d775739f65a726c148d3414a4bac123803f0dc492e3e3d11eceb374b5d09ad380ccd64bfaea30bca7ee16a8cf20d15bc1e11769741cbf0ca6ac9d7fec542ab7ad30b2a828a3180d315cd7f4dc6a49e9aae0ea9e8a01539d64efb54cfa08c511b7c96b9ce1201c98509cfdba1eb03d3f8b89a6b260a2d3afcf2845655e0e8f1e8d71ea0f459e93dd076ab256a0b33a3ccbae1445218f257b45adeae99d8676ad64e3d027fe627cfc8b9edf0868821ea08d2830bb802bb0450411557ebf4d02a8740b8020084685b5eb82aa601ed0e3b24ad8372c41227f532c52c6549bb72ac02653f6cb728c71da6f389bf19a2775cee4c2e6b22530ed2c32971627320dc6e7e3d36022be6acbf19fc22ad2f12f502e24fe29a08be31719158972a8ac3f95ed65677abf4bd8edd2ab0bde6fd96879c859c171fe4cc07bdc3d41b2fdaa1706db26013857bb5aa9590af796d3614291c39d77436625dad1f05838a66d347c947abc662809f7d9f2af1d5320ca1abb65f5eaffd240da189d07bd5f3d829f7a40e7d5ec0fba33c2462a2eebd4ac22ed892a640fada7e0464a09749e2ee4b7c2c070c94bd50ab1c575380d338a6a399f0ad7c1ab3ed9995c62455418fc5e8551243e32624b2fc4e3e90e0fb5c634404a219bb9564cdde1a8aea6a97d3718bc5328401c977462a88fd2c98b68ba214823ec8f1703adea73ffc1f983add3c4843d10319161db1b8d4a1b098272ee75548b6d90540b1935593f2412ce4c89190fd9770d79023eccf7aa60dba3d93cd668e24c6e5a7be92083f7fb8c3e3da47cd8092ccbcdf60b2504cad5724c613d6f46d81a9df2b1deb5cf1ac6ac8620e2035bdbd9912a07f3a4c17549095e719f3cdfbc85d4a56fd669cdda182d5d4dbc2ad973083662ea203ed51c93126977d856725f2ef781fd5a5d1458ba00da105f1718cff12f25834701dc9b6187a0933a5c335613133622dbeacd44cfa5357a7283b00ed9fa78bccc29d213111f59e2b04acc9ba3ddf72be48f80134aabfaa8cf20f2b9a39854181926e2c98072c921c3c8a4a6001579a5da704860cac6e7cfd7d7a39c07bfdf34f72ec3a0147989fae8b0407982c1182c30bea25ac066d69de63f7a60e0d39265c304920b07ef718ae86e5aa08d554de21d4a6bc6df76cac593d3ca446af89d36d0c73abc55b441304507588593d9fffea8609a1e7e608775179e8c20db061b54b4c52ab29c9a3f9787fa242953f122bb53f0c0935d34674362ed09a90c57dcd879658a6f0858e962cba21e5c537440d542631bced62111ef1c70ebc3b478bf8657b45d58054cd5bedd61f0277b7b7843274d5473b9a8278abc61e0560035f2ade5c57022457fbfbc1eae4ff1dc76178bb08283a393b919358290f76b244b9e459d4931498d0b0b80fca61e8e628e01575fdfecd2ce081281701614824118bba43b01d44777e8758f0f8e343a9c52d09f5f1a842a52c9a6da28ca031e8a899b7e2cb9f8aaf5e42719ed5bfc085f3644033d2b318ce57367ac7189a9bc4c15f3e4b90c9840682e8b1df485f1ec6e2636fb8251c2e0215f95160c5b1de55026ec69dd045bf431c59f3ff44215028c8110cdaaed468c58b778828ac00b73f612deb8ee75d1387f14c09be9bc2ff49e4047623869763d824635ab4b63feed3b05b9a130734e078eaaa1ba82e834e51459a8cfd85fb7210e96757cf17f3e179a54007ed6941ef0369db60ead21cf32e8340489916f8134e4cbda960863cf8b7abbdb71d0afedfcf7bfe2b5fb28d09331f4dee618668e6a0e08c942092ad4c36f87f87fe11886f378941a7bfff0221a62365a63c30ae6e8b0e89b3a39251a494f99f84d51995b0b1abd8b3e9d1fb36ee4b555f992dc157e7cf6bc6d5d370e6ccd36592e3ede85aa59014e0c2e9adfe58d26eff95dee2b667328e9923fe1afd0c2dddbba9b2612cd7d7d5a9dac966be87c9019c102134fef7f6d250ef0c8d47940818ad2c0da5afcc5681b2adf60cf3a8fdd78e19bb045ca4b50e510f874cf932d3a51a54601e57f59845ae2e2cbf67653b6e36d1a832577afc80bf00773aa284e288fe104e69bb9cd0fce391e37a2cc56ae2eefbe3cd4e15059355faaf4af3fe09125127e706868763e7f73f5e60f5f8ce0d23ea074d35ecd8dc3ecc51f5a3afd701a2fc16b1b243d74e370274f4202562b66f39535150f8fa970b7e1095d9d29eb592df804818fea4a101e8c30d6b0e66c0e6eed2f2c23ca3c1065875b6a4f358610ee97e23e027ba313a8859639304be7d7a91917107d40006ec0eac8a62e89c53d18570caa3c18173ba65017d431227dde384af66e1b38bf66b0208bfef0e18ba55fdcdf569c4962dc4cd43b8030dca963893144aa40caea1fde4e67093a8551a786aba27f120f8307db1e404104315f8fb6f7e2f3bbd4714c10cb5f8f7a205025fb5484153ac317e12e8d21f22d690f3d335c33965aad076ca9b9f29cb24e889892a4aecac2c0271b8687bc469271e1908b1bb2bbc3cf0cf2c33ca2e8d1cb95be77c43f3ab7ca7d86513993949ec4e1e586185f7e2929d5b6a078c2eb87eac1655096a5b41f50cfa8322e5b701da46668043747cafb0e71db536597daa055aa6f2cec10ccd7ec3a82d2ad7bc6c1459afb974d2984c47c2542ddb7c59575e37b6e3a576dfd0b5104d05ee383b7538a9f40ceda14311fb9402dd949bc439f32fa597f982d82f60270d778fbc3eaf75bda47537482a202c85883c37192f1885f752fb995f9d8a6d04d98244fc8dae390306d54b05531956bcd5e1316e4726c09349e420568b95ec56338150184e39542ca2fff059e8e3bb60ca681ad5c9377ec594da122283b0726729bcfabc1836d88c80ed0d5ffa0d43689957283162b3d8f7f3194e858296b6bf88c5e37a0f0bc0edadc0446dd66488606fe9294cbddae542eff4137a1de96409a1b5b7b801946e8ece4a4ba5736daaacaabce6d0d58dd5d8b5558b7d2dd5c4e2a01f9ecae15ff2ab012d943fbe9e4c9198548ddea578ca4ba238d4e83abb4c0ceb19284f0e4d3e2f1ecb9a83e8e96738e120a281e76b6927137dbf34334164d263a629a344a871a5f2f32adb66b6771a0757002e3ba69193f1f45d6692960cefc046b0438b48a89891c4c8e2509ca0a08565b973ba8c886a75643cb0a842f8289f64b52ed77ca5e7a10ae944255bc4e7cdc7c728aad1d4d7944254ca059fc3d957d64d73a133428caee2f108113a6d35bc68e08928b5f2268a2b5db72b38dfe3856601773b33bafad498d8cf7573ccceae16f419100f3249e1c82709f180620fab9613b289eef9aafd929835dcbe72b3d5bbc48449878d79f8262d29076cba30479ffcfae333bdc91f1ea6a320fa7f67fbf0f9949cbc9ea7359c06c9d138315e1ff83207f327ad97ab0eab0f358be0cac3924b157ccdd6ea936e26d739052c6ea531f8e67ff12f14a212304c04584e115670d6bd867464ce79296d8fb46b20597a5e475617ff5cb2c42ead7ccc480731b73256cfe46a43368abc7235e870442d41c7deb8c8bc11a80563bb7016a3ee962656eafe3bb3225ab58233e952c117c84a64cb93371df3b062363a7a49cf699715bd20c70ab00f07474be3d6c55d525bb0f5446fdee017a3799eeb81e58cd205b0fd244b9188a811ff400113093527c7e30b644e55394eb0a1e524998267df1eb16685be95912abdfffa4a45af465ea744d5d8c52e475793d6eb6f3fb0fcc91cadf6b82d9554efcae3ce7089c64160e3ada5a82c2c582bfad7d73a155f36930916960b86e22b6e41aa02ee128f0c841495647408c53de69808740647b744740924c538a42e2357ade432d820da89a3e75dcc34436728744c301bd75c8a26d02327a79d1021ad768beb3613628d09304d5c42a9fd10456f9e9aefb8db1b043fbd3dc267db66fac0c922f6b7c53fdab29a77d7f93f27549e91f209d587a4889e209cbf0235118c048b288d0dbec475101c8b8c0e491499ae36897dcb2ef2019caa33695d27e8cc9d09e9939a32acc0ba6fcb3264bc8a3f06ef0072414439798574feca258f32bb5d6ee07e684c3ddc9593b8d7996c6ab9cac9d7faae3d59eea753a71b32f475c61d3b1cc8fbc7f7e958751fb5a276bbdf5a16fa17b61b4ab03ffe54134b44499c3f9eefbb1a548b331aab90f94c7430d2ae3d4bbd167cbd0d39bcad7a8accfc7d218bb0f71e4f3269115083058dd32d6c8efde308e7e0e875aa7eaa857810f4e1a0c233d7709a0e325f364111e8bcc6d3601b3eeaec0bda29c64b9d9c1bdb5f65035cd0b5b723d1dfeb833783dc0eee0f883e5c489ffcbd34b9f295d3a4f43a5f7e2440bdb6cd80b31ee01a2391849e980a03f19b5dc4de596071c24dde4e0a02a2d9d1989dd54988411deb0447253aec808737a181d745a924fc38bbdc5415c791da34c6d4813a1e86a07eb76566054532151d0ea54b1ce99d500beb0318f48fcdd5ef6e184e15608ddec751405b616c5beadf700d6ef50734fda2856faadb8da353030e0135f93ad1ca0ea5d499dc87ff0f5480aa30c47cce8e55016af85ceaafedf090e5b36c165dd37f496d474c6f1ecb5b2f73617c391b6d6fb1f5753d81ee7c9652276252ba4175a7621498349dea3c1979f97d93992b78e43d459c54a434d721f0bb41a1754ffb740647164b606a36a557f5a196b6f55cfd6b0b11ca6a731874738fcc9b90bcc0561c78725827c0cbbab6d953992f5629d216a18297607152daef87f46e7530abf7f9c3cbaf607163b5c418ab77c0a3b93b67aa5af8e4493f5d3ed599d5028dabeba688ab3c3c54d1a38eae5cf1d42ef0eb45ef29a303269c4019bbca8fa053f012a049504dc5bba15aa8906124d7b9d33e1d48de76e84cddd0bd2f54078eb5ae7c3ee37950f4bb092a7f3bbf26d6175c5b0b148d666d78df2fd10e85000e45eff2bdda57a1151f63cc22548fce4545567887126483df6dd25905e8a64e38d087820099664b534e072861372e5ac7d9f55042deb8528520c80bd12b56f9eed967eb0100fe6676f94399c76e54a54f7727fa9eb6276725ce1385431bac32ae3aa25951c2f75839ae7179c2cf4eb09de94681f3320b69a2ee5851b219711d4b7540765852513ae86b3bfd415430d1d85840945b24671434635d767b607cca94d49319b69608d2ece6918d7c079ed2de9f183c831ffc82324a2ca7b316a55471d938cc21377f9a03d15ab2f21c8683377f5203ac15fca38c857cd0d80f1c5d1e1f638b878a6edd06e6da0af2eeed8447b4a89c1f461f48529656df15a27951e9a41ee6f2b68493b124a313439825d39743246fa5be991f64808bdc6ecf1f919dec432c90998ceefd004f6bdd2a322d9ffb809f9cc63ce60833174cedbf5344426ece50810ed781f7b39d031a7b0829ea466725dae65dcb79607989615bda4ab4d15c2a6920e8a14214726d0b1daf3920112c21a4ab26b799574164868dc2c1377d7baeb0b94fa48244daeb7f2854b1ac5558ee706cb56bed9206e8bd55cdac10ac45fcdf8b78dc3bb958564e432e1efc43137754607e10b959a5476a42815a4e2150d5beeb72a7d0981fbcff0353f8ba0fac51181883bd54c93df421e21d1d4dd32d1fd03c603b6bed9606e25ab1045356377e7452ca825bd28903eab98a6c4c1d51113299ce183bbc6b70ff133e13ed6445baa2dfd08661f7f7167f17994bfc4186cd14ca422881357e87d050fa6cd32bb6414098af9c999d006f7d33edc754eea88b7087030fcdb904bf40f467eddf7d0df80c610ee1ca0359cfa58535ac5666a35744fd1b18f879985867db06a66bcd40d1a002e3aba56c0a17d5880e337396d56afc61439bf667945c1fb2bfaa8f59b25c5d9186eecc3106d7be09fecc08d932dc1ac94841fdc913e60571da0d24498c1c8d6dcade909eaee164e40af4de83ae32cdc495787ba8c979399019178e1d7a72acee16119f3f91ff1c4f7d427ec1f708e1e36da0ee1f03844a99e278a43dcc6ffa29a2778af51225bd42eb2d38b8bbe6c81cae2ac67627ca4743b3456756407f8830e008ee46d6d50091acc69b94833702f8d4ddbc45a18a6091f4a46e4dd289dccc44f49c40e547c4570f13f02c73cb627426142de0746f55898362f28ee3ca11c7eb9a90f2c1f1132677a5f7f4a736db99ce6d26df5b3f5f2c9902af0ec057a10551cff7adbfbd86d9bc5e7fe77f040ee406c9ca4729cc19a1bc5dba2c343de15f37213a70d34dfae6f683508e5719e24f542336a4e78c12ecf534af26b4da68bbd33e7ae45f4aa115d47e26c4b493ec5d502d74c59cd4f951a42f94967bd304c88f2988acd58010cb38168bc6e16f6736b7536f9edacc253c2fc7163653241e8385b79d0d5cac00c24d13992dc6c31b6fb8f83c187b4f6e823f9bd298ea2aeb0270e7676b1ad5296237f705c15e23e2a051d0c04b54bb64da393cc7cecf8e23f219933ee15c9080c6dd3cb86530649b821fa3d0765821db180b658641760c0d07f2cc5aa594ff66c3e3fade787113b48c0550c68d0d800963652a627015cdaa2722cff0cfae0fefb89e2c05fd5708ef977cebc8ed1ba541b1a9e5eed3a7ef65ed453f2d631aafa12ba64a25e03788df5c89caa29d05bee9da7bf944b4b50f593f97e84ba53775ad387bf1743c8951aaedcd17925e4351e40fb893b0e2b2d027b96db9f98286db3210aba3409dee31f422300bad7a7a7434412c499844e162358292135f9783af95c647b3cd19a37c9a1f4de83cc69038bc1b5c78ed5e61720b6fed4fcc7626459392b9e7f3b9595d9119f5d6a67bbe1a89937ada4e08b5c407d0a391ac1017a991a15578a6ac82ccb60f4dae2c25acfc417cc067021717492eff529415d04d435ccd4a390687eac7e940c767b3f97ed64fb7590bf019a3d44e3730ac3a95471b5bb9188e76e8df413207c3f6b66da954c33b20907fa29049b2693982733d479944d5a13ec9d64bbfb875788c89322e86bbb8d04d6d5822e75514b31f9ed272a6298a455d0967457ff3d6eeeba0848647fd998a8d9cef26ff064b189d6cf2f618c9ed98bd83bfbd709e63098f9cd5bc4f4aca1d96e09099175fc4b1ed073f6ed871a1aa8c862b68428d59d3c36d264b3fffef9d4c7bd33a2aa3ecb51ad5adb6616ac392d16e8f60d56fea7a46a674fddf2cfd24e5180217d52506f510023f012133faeca57c68bd0e32e116f9040f5a3af25dbc2cde069a1fc2a28f3d277f757d95da46eeb7f29d29e92b88a8d1027a843f055accc9492864749f1ef0b60a774bef2b055b6ee0276b5cc1a9e2f0cbc88908d4c9b4bd0498ff0350cb8ee65ddf9e67685f7ea1b6d8b0459360e1b04994a8675f5148ab548cd66578d0507972017cc68395a1139b38be39718ff26b518f360ed7cef77e57178ae8ff7c28456fe2a9f46e96a4e70527bad276de4b275f460fd1aaf9f58d9d7362882685ac6c19d7e106f5dfb169ad68a6e6c78dc68c51c3892cb06d1e40ee8369ff2ac6530e820f378388f31aeafeecdb5c91a8b9f50d60b5ecadf8c51bfabb5de668b4c0e647aab8ab29ba10a7daa2df622bbf4042f2327a486eafca7f178b3cc37ec6412d17662dae63d004b0ed0a9f325160c4a9cec6bea164fe378ce20b6022b9be456765cc234646c97a7aa1d5fcb7238fee0e98925f8ecfed4e137449d20de2fcec51d76ff4c38cb80a9464bdc39b50f75a14fe9aa7e2839562069f88d255165e6e84b788abe4dfcd82e59ca9450e09eec9b23cde9f6b81d8660f4199048904a848cec1c5b9fde221a4115a7f632dcf7621f1befd7b23292dd2b1f63c6748d2349ec3b5fedc0b04842a305ed92b3e5c5aebcd55a4c3c61f23d2f7c76fecf3b8237ab4e8792b18274a3a58c604c2e9967cf77fc9d5e4113be51df637ebc2f5e0efd308d09a5e9b0d3b0947b172db62bd80eb21cf6f4a55203e4bbe31072a1edc2367dc9f5d852015190c8ac73d5d74577e0abca6f9e9e4d7fd8ac1bb7141c10d52b15be224ae521b6890ad406cc04f3973ef3d965b559241e3661f493162a13714fbad389409249bd43366e7cd2d6c857d043b328bbbb86697ff1f3a2aed9d6c90597357cf53fbd2a576386efaabbf117d66b7459e9c87a35ed6aa2d15bc5c662010390b9dc7e095d0b34c723ff9918c9253f5fd5a2d458162620ed5ea0034ce1bafd4bcba7a6499fb7353646680bff8da3d4a130a0d077a32479a7a6029840eafa43cefe4d1fb244854757663e4e6ca8b557fb91efed8fec1d7ff5be2e4056d2b8da712a18eabeb34e5b479b8f937f3a529021d1471ab6061a74268ea7ff0a70b234620697a0b5669d7baba92d82d9ab9547c977a2d8ff3fd3f9e639c96f90f5e03ca76a198ef570fdfa2ce2ca002e689cb8fa9619eb0f0646f2089ac9a958fa7e7c078414e54a1f8ec2351384be592a1946041a2c1a63fac8404eb98e36382903a9d95178f1ddd032b8aa35c698b6e36e5b1f5663ca5a6a222977336a0eac1261787c88dd03467a13604eaf0673a9bd7c6d0c4014044f57a9e01b3161a8ca21d0ca6e1741e2faf7c67fd88e982a4a90cdc3aa1bf43b2f40f4e1aed637aa89ada7f61c529d9701b28be1079f4bff6103737b8ca2d0b74dccd34008c09f6f9b557430f80ea034ffd47d71386a1c0f7240a0e70205815810a0f668d4e8ac74d8cb12a90badfc9509f92d155d3d5ceae883dd3236143d7a9b825466b1426e45a373a41f73a8ead26ed15e29f695b30b5fb41277b2b630d2f1ec6f00fb54473db04691045898f2fd89361c4ede21b7fdbdb375c82d189028302d65eb58e5f876cbe72b73d09cb15dbacba3ec501ab6111692b28e794bae48c3737184237e27881786236b5020aa90236fd1aef8cc7e0ca3825b95ffca7691ea37cf3f5b47de1cd0c2eddcfe1a89e8002f5f10482e57720b703b3b49074173f9b9b204b39b99b1d55d69f8735a62fbeb1bc1d657dffcbd070fec454915622f0fb3b510a1f62b8b3b349529ff289b60da32b91201409bedd8ae3f9fddf5bd62061eb7b30b2f25fae3cfd8fdc9c1b662122d766f1a4fd5c7286474ad2d8ec652d22e9885aa60e56ed798d11216f2a2ceb6932763cc1cb8354dd302a350c3183cd8321a65d4e0eb0c09ee75fd6e020e9a466cfb3171a478f9c42470a9c7c625ad1db0884a8b6ac2b99dec0ff61b75a8d00fdf61536b6b9e13830653f528ea09e7f1398edc9221dd15a1025381a199c3e2f9c7e55e9964db64f24b35c5f8282d8e8be42c3f268740f155cf0360d7960d3a27cbe43f658e8af99584771604151b6d0c764b0449aab02554a43fb9871b26eee0549164d679af96859a014f2ee89f2765fa6cfc15aaff4689c4c84106acbf98e7176644a24c6ebe115ebfd094fdf25fd41c7faca0f5a9a53f6ea07ad84864e8addf42e906c8b1a2f6a1da5133b55ed633a5a8412070fb111d6841376c5ceb7a17ef95900f84316d9d52b07ff8f45aaf5b328ed4dd0d39a990a2c3fe825d164d65c156a6e4160effd9fec21c09cb454db350f7ee34f993e889c21d50fa52454f659f0b5a53e0bf693829921d8b9f26e9b725159ff5101dc7f6cca3ad38e585d24f632e089186da8b236154261848b7868ad4589c0aba27e45dbd8f8daa1da403d8539ff18874c65a282532ddd787618567d5ed0d992b390bfdf85da4059dca1c6ef286a8e3952521d5cfb428a62cd9b89341ada3f20fe2a20e2d3670d789311c005cf171b6913db04fe869ff06e21d847384a720f2fe401caa9562c51880862460c76f85a9505c9cc19d1dd858cb8bfb6c60e53d12a5290ebb7c8066faefd73bb41c040458082dcbe519c27fe3355c3f5fc4e4c3bcdf875303245a317c5a0843a5f7acfdd15a8138f21d4546bb26bc41455f94c97801c866858ea951338c997405ca584d73e0a9c16ef52fb50cdf70be6b1cb40680a8588a17a104aea8fca248e0fcf048e09b073164ddb75a938363441726a6e90f6a95099a91bbc88859d4b873e867222f56c0a6cc2fae5c04a832b92b509d89d2e026aeb0190c5e5847c34c6ad5568990ff54c0e0b785b6461df925bcb4f200e104d97d436c88d58f79f608058582865f13b90d71deaf9bbcd6ad390c913017b322e6bf3481defeea30159d2ee2d02beced785bb87e4a5520da77dec554479421255b19810a638b037d81ccda5f18c23135cc047751968d3ef2553f01f7208683918a82600723185da2d0c311e2c93eae50af8b062936da7a69b9404ad437a40a7dbe84cc0d2c6997052f5f7eea0cc904af9d32fa8b019476f6f572c197dcbc90b4688b190e41f11e03dc16179d31b38d9a78eeac142b84d86756ddd6bce1f551a59b64fe601858fd4376c29dbfa9781873dcb2ddc427e113604a673f412d78fc1e96578d647f3fd96263b1a9f6803b630407a33a4f50ccbd7971fbc31f2b83f9ee4c50988048fb06d752b793ab823d94cd204e88beff8d9171981e6bafa61d79672e5e3141f42a10872ce7a9f882e81ded873518b217e139e82ec1efb37799417f415309658aba53c206a987f95b74f1d6adf4c8a79daae6084bd837503db7431290d2c0713e55cebfd584ba0a3c17bc2c16bce695153cf2bd3b18a76e679c84ca7cd05869eb187786c5767e8d39fa5d661362e38a349e80b077c2a78319e351e4ff94eef2da033b9377a2756f73ed1f3d0eb20f606207895c395931e5748f7636d3df319e3fa260464400e9ac94d3ad42171caf6c0ea4648c221d29b09df4375072da9eb506641117ff4e5a4f39499cdb52e41efe852170a52012295825d4986cf33a92f0a29b14383ccd4ab01004dafbcaa399bc8833d5e51a3405804858e10e57d88bc831643c1273069c9a61f49d2f97c1a49fb69386f7c359756e74abff76e10637ebf86512fa97ed8703a8e4fa43bb83e71862658ea5931b1014b219b93c3ea112450310e3ea6b10bea7004e1985d64d8bb0ee08751101b806159db00607b86ca22463b39569262126457d7363c96e70665e732b18f7a0f9bc61dc58845afd0f178c773ef85605702ec0890783089ea0d5d947d39d67a8acabe9dc997ea9413ad4396a511c4f6dcf3e68a60c19f344703bed1bab67d3934fd14ca566e534a8a8ff6c8f02c28596d4c963b81d6c34b8237725f027e7403865ac3395c7a3c5cfedec23a6d93f1b09dcfcea17a6d2ef629e6ac2ac557c94d867882200ab8b4b4936391f1c15711ab05cbd3702df47f6702f55c4a2baaf140cca0db7dd83237779d925dd344e6c75d7fc670c5a6fa6a38c4d113b25af7e69f64735c8c1a24ed3f899ba14f4cc80bda9323e4c7f1a7fdd0b4fd381ac691c1ba073259fcb7cc9b2b6e14d8b1b8b932bc4e455a43e5012ffb75a5b481fbbf97775b19d8ac7d53f9e2f5f5f5beaa94934b40b0c2978445be4a90615e2366c97ff750e8752de71fffe35a03c5e5fd5ef4411a0bbae5d9bc985c8d297cd3b649c6e47c3e56a12e9260667d5b004151aaaf87f72b209f528b1e03d7b5af2bd1989f858ee5c3a92570da45e4a58c6b21aab66c0bb44e34cb93a8089ab8accf830b71eaf067587df48a125e4d50efdad40eed9f77d55a4d9aebc0148d81740bd5af434aa8083db431642aa461c7ebf9105313e2eebe8898a99b3270e58fcf20721569e199af1511d434bab9cb01d0a267e2d4d5d9bfc3345f4d1e8381065eab4a2e9d6bc927c15bf0da67adbf0f6833cf7c44b6fdc8fa1b4ca422c5866ecc6f974cddbf49a3c353ba05a2ecec838713915f1aecd8979b100582b85970aac59786bd05f5b112c5561778bd0cf8bc1dc9063c9bc3bb4377ffb9556c0a5b79f74e055fa3536470b0e23781b91a8c7b2694f53ccc0cdce1a0d768acf10c3bf0ac8feafc647019a19fa89c44d80ce32ad53bca94409a36a9df04116c529379387ffb2901e1675e12f6a26efbf3f42af78f475be9551687e811585835794207e7d7d8edcf3980364bb92eae644ab3a858bf030c7d0a02b343c55acb1503e668c4bfa2a5c9679dc6751cd1f513bc6fdec7f1f35d6b6a5c3d8271187f564eefbf84bdcee2760156920eb0d00215af32924c2e91c2da4251e086dd7af0d09a9230bc3672a3a7a5b4cef396bc18aa4d917eeefaf7f1596b37dbe637c1e1c03aec7f99f75375bb1b90b5615da674737a13f2389c1a812f059b4357a5e07104fb8c7a183f25f906aa77ea3e8fb596a7a8f75ada6174e6eb17fe26efc6b9a5562c5253baaff1366541959e2279608e71b6d426e31615ee26e5bbfc0a1732282c986aec2f3852115153580c09914f8ec0fccb1f6202f710ef3ab191c962eac1ce5a0cbccc575c2e284601abc9d2eee15e7f44d4a3c2e88a0c38b00f64bbf2ce792d859c6ad0bfb0fbbaa9aa68cbd1040520cc15f6cef585101ce805d6ca6937e5ca838c4e56fd59535051a029c5675dfb0006221d4ee3db01385c68ad1e60234bc465ecb5cb2c36ac0ab5ef5045f70092fe02103428978a3a60bd147be76b46cd83712fca99c16e1010b5d101a734008ac7749acf1a232bffb1f202520d0ee16432a45883cfa5f7b01d9d29c463ce83ec06a994c4e4923d3ef36c83c8850edb8027f6aef1fd8ff684a603daf0306e82cd0384b5792cea4b6f21ea7661885e5dc4707e0f8257b4b71ecd1bba89b30ba29802aa2bf7c9aa33ed9b6915c3fd07f6b56e3688c520b642a06baff32e14040178cb153adbd9d3b2189a521615aa753de78032ae621f1eb92be4dcf63039642ef57cd2d5","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
