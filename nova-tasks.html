<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"922921299baeecd9f9676882558883564e22ea4eea32f77357884793a55129fa6df935191aad21f75ba7126eaec532f0cfa2ee13ac8125710a920d98ac3bff256dbd25b72c700cb7fe2a07024f7a8659e51207787f30078c81a1aac7c7a1668663c878f43042db0053027f338d285535fb118cf552a077d6eab56cb620b35771bf76eb6f8cd467ec5f12e8724c28e1507af0ea3e89f8d6f0402d9b934d3949dd2726062c47c46ecea80c327092bb10bc68b4b578d13911c64aa42aa9c2b171ff93b3fbfe87af415bc9b130136a15f39444252b980137111dc3f31267489620f53c7664a5ddb4511866feb915558b04d4537aec22590eaab3bd0648038424d29cbb157a7f29eae87f3f0e2654b89eefc674f44ff6228391caaa232bd18b1e41a91a76c979cebe8a5dd668a54e25dade3c496b07ab29718964e78ab42fc3c8e8ccfbf23f7bbd42f712487ba3ca6732b0db61ff23cc19d0f760e4661a4646f6f398f45f72a3adea25ad1369fa57b4151f503dc4670be55f594abe926b50486a648b2bb4dc2cc517a8e5b70bbe5ae0ad0d3adf3571446f045f690317812c18adfe3b5d26a5b088d8d77adc739f7da449f63e82bafe6b8f7153d09b4883673f66fb2353fadb63cfc780d99406846fed49607c27ec8ee9945a90f8c5e73eaeb1262494035119e4c268e4d46ffeb8c14759be7c1add3c5de172e7642d5b05b3778f500bca57b95a90bd9568b543dc1f01a096a2de90da233db283a8964dbfd32564dc41daf45504cbb823915387d9683e0f9603a6d75211c5130a5581bcfc077a593754fdc2aa6fa1b573cba47f23ac112060c3bdabbe7936360d5efa04862faeb4207ff5fa05c0a97aba38ee7fc996abb7821d07242b8dccd5071ed87c03068455797f893c5b7cba45a647d129c8a324b74bc246f9e85eab749eb42e3684783da49f3ea99d9cc3c5bc11257d5d8f64b9a2124925ee548d0f7e7463756adf6cdd2d90504e632c93e3d3cde904c420be7407adb5bbe2059a8373d7c38b7ff3c1b98bf5dcce1425a772966e9a1ce400f49b9919a68993df231400afb9d126265d2d3ed74805ed4bf1d513318ebd26fa22416d28fdf88e2a3cad7534238cd2b0c8656cdf289d502731e52afe9718898549a6ebe27a9bd374d2271c1b1b88796d4dd87d38e1210b08c0995b4eb575492917952529f6afb87a17e116537679ee4b17246587831a6a97b0aab70735c15ac2e6fbb0ccb3cb81066b67f83233beb815f7787f30c5e166300612c257d14a92ea4b4b6c73602c8c2c2ac2b6e68d4cda1f1a97c58eb593457c0b4898a8dfb22eaad716156e8f6e2ca0250eea2511b61a8e8f17595d054b4809324a38194f159a8583e6f877f2c8b3cc53689241e5c65fb3e6da94fe1a861e9d8171b9c30c82539346509f7746113d38bdbeeedb1bbd8b4518b66eb547503041e9a33aa746550c124b3ccbfb47e268684db1fa43f0dc78cd0dcda8e89ae55afb90cb0b2eb6db194730e8d5c8f9fe7c54b6efb773aaa7785d0d143dd60b50cfdc438f50c49f248846f1510db55b43aafe6b6ec51f887b3e8fcf7eaba9797b255006a47d615e76a5c253a15d23bacc313de4facc4b93a633dbd1213100a873c8c54eaa70043963f94226613aeb036b2706f514f82b5cbdd482f312d794a6f8e0bd3e9e503d29e9bb4d7ba486ed0d3ac317a4eb34a5036c9d898714259b58f989ceac7a0310d64bc3a36028304cc044bc1b906e000adfdc5792f42994ec2353592c67517d02bd9572dc6af8937ec758bdcd00fb6eb63399c472275cfb5425506a5b9ebc431f2404c29a37760a8670490bf8802e466241cbec7fe08ecc2543a5665a6d09f131185f9995a058bfa34987e8fb01211762f40fdfb20f8dcf4000c42e202aef9616e40dfa3e575db5a49e0b8a0f18d3ed88d54000fe6d9d506b254f6008b4e4f2a2088b1236e70d8505943c83cc59bbbc7e05688e3badc57a8d72d76ee5bf4f069e5cc65cad730fe79fdb1b60db5df6bf44a7856d0f3b4461ddc633b3fe904add1dc6a0fa3c9419927b9e499e896359eca4527297e5ff6fc8f454840a07c148609563207904cf27317803fcacdc4db783ba6b0511c4cdf7b4983fb02641c4ab0364224d405cae5ee6cd71cc18b7b4ecb585d033b68bbf353ab400c9ed24701f35453338d6a496e6d6c6be8a1c9b2419fe54a69fe5f291a62f24151321106db4f23e81570fb8ed5269f028962201b62957687e60a0d889b537afa81fd743bccf4f668bcebc0777f033b41106c75883f34aa3f55756646b9e892cca9f686e2df4d770a6eb569cc647b5671068dbd9bf0f50bf2beca0b99d2a34a067a42dff9b9c240dee7cfb403aaa652c0cc8c20e021a04a2f12c4bfd659fc0fe3b176a59b4a097ec8e0608461fc55e363afffd627fa42fb4d28a42e770723a81d20152e8db804a33113c55fefed9b746e7c9c44837d8bbd4e8042b82892a78b5c79a1bb01bfaf5127f7e73053e08dc3ca2c292b664deb6004d9a470fb99675dbf9c5cc9740ac3fdbfe4807861b2e01226e46fa63dcbd95982a2ab7cf126fd0a78dbe660759415e92dcc4146e42721a484653a625fe09f93dbde8baee97a9bd227dac83c108417d23f00f1fad305e196d3f49669176eae9b3180f3098fe75c02c8f7edb2cf08d770036688686be3fdf1e9b816039782a4e24eb61319ff4b39db2b33c0b1b63fbe6145d3c4696fe74e29badc1ac379f58a3146c1bfe7d1d1b3c553114cd456e8bf58b95fbb1e561181fb501468635cec2eba40fa176d96e5b489c7b8bcfab25051675dad144374ba2b95602ffb039c1771fcc2935717de371792a5fc39130984f3aa5d0e883c77ba2b75d81839bc2617888e20e20fc3d32d1136dcfdf7fc337b290fc421749ffd44634610dc8c6791d21ac251dcbf34f3b84ed4d4412a4714dfcdd23430ad6dc7de93b77d19d522b2fc99d91bffd54599eb8f8d9eaf5a86d44c742002fc20ace8b2a27414c18c57bb871047bb915b11fea35c1c1e9aee87ca26825c1dc9ac27e7cf2edd9809b5745b683c1ca4e5a7ae641b03f979f966a2951b1015bef736617297fa5db3c331f1cfe51be6cd71d8f4968de4fddef848392148ebcb8d2068780548025c475f2cd5ebd133977044e7dd90ecddb7727332b4549a0d5cc7268dd9c3a1ae135b2969ce96f338e5d7157efd0976698ad3cdba5cc1cb2132b62b26318a39d72be05f3e7503d123e9a12b092b52730e18731fb07767bfcc06bfd6bb72375084e65d23ddc6a08e916fb4da00e358bf1832dadefa65b766c13574962ba1bb99cd37a783cb5a617e0836c2a039005b9cdb9e827603527c4f1790153b360d6dbb7e45f2a864e2ee4a410dc938ff7fdd693b0474c6a8a26da4fd8e081b33ccd914694c430cf738e1771dd450289fdc79a18793d8bec55aea5550570268219c0f1dc625b1c42bdb60bf8e36f8f1de2efce26052729cb3c386a27ce538a7d0e671f61dd8ee3ca3c2eb8f52dd806046ff0b39c23c5944c13928a58b483fb125ffcc3be6b7dd497839757a8623983b129b5834a1f706da25aab0925b1b88770ddb0e489fd5cacac47bbb5863c73d897d61f4765ea635b67e069c6c4f34b034f78b47acb8482eb4715b283a7e18ac13ab0f424fc403b8b2fcbc231e259032859238ba7d11f194ebd3b6815574c9dc66564c68d6de134fced519963bc626c825996020a65da4ac2ba97225148369b5493b9f59f9ab5df9df5e040690ae8abfbdcce8f17a8899c521c9841db0c86016f239cc173c99973e88645918dce6f94f74f243889fad1762e6effd40f7cd4f141a1311421a68802c574a27a7f2b706335afa040d2e632e44612e03d7ec018dac64c36d373549658283b457bef51c209796078f3b2ad40b2ebbbdc5418e453647520bc19109fe1bdd4f4e307d1083f1449658d6ffcdb32f4ec84c0dffd2c4514f45966c14e64cc8930c91444d1aa3e393ff5e5309a2f553e84fb99657531015db425fb39562de745dda37efbbdbd2054f635d7ea7e529e58679507f447280bbcfe80689a3402b3e8dd7ec70fd9a64e24b84a27d84c6c44733864d2889dd6ac205b93584b1407c58f9e6082e49fc57d0f70e8e00ddd88094537dee4ed17f7ea4b5134f130be60f651ee34aec058defb05187ac583eecdda328b4c3f1c463a69584c4c3d01a2c5a8fd8ca09a8683cd7e669d7944bc7d03fdd365ba15c5651e5e26d393d9fd6ca32da48ddcd4e2676abfbf6ee0f8819763130a8342187acf1eea92981256291587768cb8c20630816594e9758fc464f596319e413aee820b0097ebbc60486553f19770d3b2636c50473c86d33d1b78fc0a05fbb78129d29ad6e4a4a523a62dc79f4cf94188cd19098a6872069b8a4e5fda7d10b7872e0c242e58c3932f52b893aa29c276eee3f6ca8a17038dbff5522c599cc524436d24ed77d45f7734bee46b283de438c267b8e9fde2c117acb9e7008a876b57c9efd55c84ff840653533ee9760c5252cfe2e0dac1e62f2887dfa91cc5bbdfcb4e6a333ba2fea6ec37c9058eb97e51c2e46b4f51990cf94c9636820f77bc04709296b7bdd3172d8f774b0aa5b2478be0b21d7586ed4a5942087172b6a9e81f8a4d4c644c3ba56fe7222ac1a348e0e64de47f7150bd2e640f11e5dea99f55a886a079717ddb02a065ebabd9a9e7b240c1b8255a5447d32f9f3e57475803bf9b529212590106e68a4b079e6274c73bc7d90089a995c827e764921c1cf7e82ce7f3dd591c5ae0603f3cddbc20e62138130b0c050c9e571e6cdad931336bc074e980849f13c2aa58535e3e8e82d14144da80df15234e61571d58f09bb745dc17c77e1698fbd38ca2353ee3fd2ae062ec99e96173b4fd9c4129fac9fc005072da4c346ba28610ca8dbfd761af1f2a89061ccf6800be36d6e7c883ae02d15c88fe26f1edb407d3746037edf113ff5f6e0739d6aee6fcf3cf0c750b4fff7403bedfcd22044347016e475d0e382bfa33700163553816f6cd21fbef579fb22df6be3278c5bfe94caefd409475601d3de99448c32ebe48c22e9a3cb3606343948e5ca3034840a09b6227e1ba9a64994b1023b8211e109df597f480d60e1bb60a82616647bd1fe63aa7a802e8a92588154f4e90447627c5553fe63d1e76a381bdb7ab262d5ea054b1bea1ce3f7eac738394e82410d5c97b744946047ae7cdb63d61cf95f86fa6e2091d7c93439e9da7c94da5ed1fec8e7832a650c33aba24bfb5165c492b4b2c0c5cfcbb8fecae652a73d54028efd403865d2dbe89b852f686ca21f8698469052f8cca90602cbbd9b44e74802d95e77aabe67b08ab541899729ead62347c6d08e6d5108d331ab20e08d9cab5b086fa1b4bc28ef27b7a58e9ea986ab289d7ff3b7f9f2c7cde993efac4f5a4c109d1a50561eb07b198c903d55d855029626fb2fe566a68166ace6c9ca80bd7bfe4b1aa54fe3073147af9cd4bf971cc21ba9e3ad0da313cabd6e684437969177bbaf96e0dcb1896204dce1e72f4f21cbc8942d1c3cbe6c44ae7e500a07348426a38584ce5be6e66abdeb23b10f2e1f09486551a1bb8585e616bf54cf4c41d2945949577df4574580369a4c281602d07ac8472a417264beee47329178615fb26a701d134c185c75714f23f536622419a457659ce51f1ec768419cde392ca631bc164729b250b75979c16aa5f13f4d7060c258b5abcb94b04e30161da0ba2c7fcda596fea99467aa6948413501ed505c0aaf3bb36999a875528850ab3c9d41e05889bdd34d7d6b59e01a658f5b34301987d37faf303802e76ae2e4bffd55d1f91073394a5492b2a5196e8f0b3fda29a4805dccc80a30d903ed3b65b171acfc976a1c1ce6b85d1c6ba19bd37e0a4e53de55d29b847bbad9fa0e3a3543d185873dda51e15643cd1025f9c4c7dbdc2e0ff5e1ba8ce1aa2edee409dcd13bb70e6aef50407007817972ca07b7b7193512495263bcb15d8b5f461efd780fe444d57dc8e3f6ae726d4841cc86cf3a92aae52afd29cb0368a3ea5f64b680610bfdebed0fba83352e140cc613f22a5a1a599526410a3f273ad7e0e34c16c32291d0084be5fa8cfce14c47759812a4aecc69f7fe64ceeeb0525e2e86811a83edc2df3b7ec3ffbe73f082f043dcea1c68587ca60b3e99a1211db04f24f89de1b130d0d156822512acc9556ccc0d2de011b5583b2fd30815d140730adb35efed405bf7044c60049975651cb521a7597cacba4e620598794c4b6accab0801e893bd58333e25caa01462f4a5267b7a43e5d6f4584b4533bfbe472e41c31f01919a135c6cb35e016844bb38f33df9de765139fcc4d6167c6cbfc9774f514e69fc792f4af576a5a53cab5302d7e35254f5c7ed579a5ca45679b461b1e2430c564792e5f5f1787855070921e69b9646d0359c8c90134f1d1c694d73f34d20c1aade0ebbc57bfc71f13149db5466bed52d8d27ab71ec926884a342c2ac5e08563b6b8d59e026d2bca02d636d14e0c51242626d3b99cb216c27ee34833bd7bf54379ad2174351cc88e46fd2a8ae160f874fa13ee7e0fa9a877eeaf058aabeab2a05f0e2afa11bf266d7a3fc8724d65388e3ecf7cddb8f673a94fa6650e082e2dc2e542ac4d4e69fd0a10b038f35953bd4d2a16e6da24cb90523a38cfa985bd5d8e26542950a53c0b39598d3fcb3a7e03c6959d2412f90dc22f56348c359f3f4ca168058e6a4562d8b3503c56478074f34752d7e8e4f85a41138da707344a16b5d5a47e295df8ffafa53f2377b8805d90bd5e48fd3f59948635ad16a7719bd8c470f1ed42fd49651697b8bcf59139cb36e71d46ba761711e1f4a357fd356052180f0ff607eb354b18adbd50bb7351f5d60871218c3b37fc566879f1c5b76952d9c4658ae7b3980a304cd93350b1bd4e5501acaeee6b63abf1c243bb9b69b73155a889c5e3a0a8848978576085de0bb0931b983141f5fd2b3fae98b72a791d34c6530ebd97cf4d459c1daf57ceb17b7fb407bb3e92b7b238eede1b35159af9a15a5f1831125cdcecca82abd144197511fec905baadc09712267b9ca73f3e20baab7bbd7216f1d221a70f69317b6ccb56b3364187e4058b616596aed4d5ef8381574095c02d6f52b933f73c87f2c952a341049a6896323b307c449c42c12af45ae07fce946af50032e8d6cf81b36b45885b54093ac3b59beecbcc3aa79c36b960132499a73cdccd088f9fcda711992240dc8dcf0c0a22a71bee3277c6ebeb6b37496fb5576eb305cdacec2f4fc66279926c9d4c2b70efb7e919bd9dad9cb556b4693d22cd334b7dc8c76a7debb2da46d266365cca1ea50d4fb9b782056ced6c30f344cf013224c79a19cad4c19aeeaae0fcfef4ea179dcde6e3ba029dd67fe6105b6ccb6e947046d5a1427c2dcbb383c3b6dba14b3d3a8658ac86c6d9e46305d144ac26da61ce0a36fc9a8a0f32ea0495b8eae5618af2b4a949e52c717577207c09cd3dca492221d2675ac7b66e9f85f269962fe313494b928aca2156752e67472aa89d0a5b13c990afdb81c4fc47e709a9674320ce0c4f1839ce4d6618dff5c430439cb5a3901d5778e4ae0eada0aed35ac3875851cea6a8ad1c339a94d71e54aba206ff8aaa499b5099bb62373e514b7ebf5e810e1ddce00efb236ba04372e8c5d6083d85db1cff2946f66376526efe675c1a0d6dd985e3c8f61c63274f6f825d345ceabadbbf14a4a8d8285fe823cab9ce2e7468df1dcfb9a4a5ba570caa7c773d41bbcbb60ee674027e5f29f70e07611d26bba4fb65d62091f30d7b563045de7ee189f33fb818fb1fc54ff1741068db3e1b0508a5a632bc0ed6113492d8fcb08d47207ae447fba1baaf40bde832bf5eafa813c1c51514980585a318aa23eadc979f5b2b7ed84f988eab5064caf64359389688cbd746db9f43a220598a0cb8225926b1a067676d334ab3ac1674a020d5e49062e8e818129990ff1a418170329c7aa13d2de6c61911f2dcccbca5b597cee2618412cab23537b4816747c191543f7aa90c584ff2a052d8246439d5cfca6505e452790a6c13a77593ae427eeb9715b46de26e8d8c6769d00f1a2b9b4a8b9819551f0c30c84377d20022c9a8d02038f115003d0ccadcaada3c66388f5c162afde601d1b9bd40f7bd6cb5f496e7d1443485587f5f9f9bb497a343caa7855045c557f85e3668e00e0e232f7b14a703fe6122aff091d6c8615444d5405ff0846c170425035745214fc7ed75e90edf51cbb3cdfefd76ec1844fb38a389d65d4d20cc16402690bfb5365ebc8894e74d5cdef9733b466b5236c302affa294c51ef4aa08c21b10526a12b19d3351a668671a3d8e8c660cb12614feb79c98d54e70a8bbde694114a0358575b40057a8db223aab99f6b4195c9d56c06109404d4377b0baf65f594f6df97c3251bb816e6a5c8c26e2c2878169b85e5fe80ceb8d4f6d981e3f445a1c075b621e73864eaf12b6913ab0596b387efbb7c7266eb334d3bf8bd121266e339a2f2b570d6db0532d9d17a7e951f2120e1a3ebfd19dfe96a086e238c670af3c7bcc86abfc7acc9c8f213be35c6f34ba8fbc925f62d58a239815eb2fee485e9dae8ae12eb792feec6d40c4780718c60bc5421322bf04dbcc9659b1331f1f95aedefe53a0273743fc8cb5ac6a26c7ab464edf0a986e62240f0e5434dbab645fa6b91c536ff7719315765af27eb6ddfeb11de6b0a52ce7bff5d8ef06ac33719e4023c9975ea6395f5fa95c0f987d189bc932488320a29fe30430b5f5c86e8744d4ccd93c3593ecdac983d9504bb56c2ca93b59064b2cd80bab6d83b3c32c24e5282764799cfaf7119a4119d555b5e370a482349a0da08b53b7476df955e20a75ae5167a8a5479f04895daeaa10c023e35d6087e50e2de3e26e10227fb7bfc8b4baae89d49732cf7e1a92a64d5d21833791b340acd17da123b7e46f46e49f9b90d0aaf147e053c1625541d74a34f0c496fd96ed7cacd9773a10381d1dd10027a05761f1217b5eda309b1663b81fbee0b6477fed7f37a21fc2742a1af4fec796b5786d89f3545ba8c46005fc9257d6e85ced7299a8c8623ba30cf62c32f0e5dc6397eb0d0c2fd6958fe64b8228ee99e42b869d729519bc06b3bb0e4890434b605814392ce90c02b314e9bc24d079e8936d5e4ef88e13ded2ff5afb18a1a4f02d7b03e0333352bd6a4a595cedce8f7bc66dd9de2cd90514253a888f0f9c103bfddaec99303f9a0d663bfec3e70b75ee8841116ff5f77c7dd834986d35a8e825251cd18513511402ee3cc57f6cf440cedab40effdc8f8be03c5c5717647018426046b9c2921a4b983954cc2bb2bf72a1c3c5154f16c113e5fe462e49e00fefc235789ca8f6cb4c9f6235738dd4b533d1564283179e5606c88f45a20c940a73d62d66cc644a70307b559f55b120149150213c86c4250d790bf5da85bc03922e29b07fe240df8b96a710e6b8ee596e8cc57199cdd4a64baee52b17d1e22025ddd2665ab4bc4694acb29c847e7730c6deb23ed86d504f469f7628bcd42edb5fd14ab0a42cf470c47be05254dea45ddfdc0e502343d9cbb0e37580be3ba744dd2678cbd8b3a45bc729e579b1f42f7e5f69a567fc3babf43b7ccf27b77b8bc561447ab752f0c7e2759d37484ed4480d4e2718469c57da1b8a87a5d880fb74758cb451aa8efaca56cfbc3d93446130d4a7e68e08a71695d00838fcd3ee65431bb9de0293dad5a545df0c13f356af30adb1987610b32d76d5afff9cd918bb81319eaa9b1939591273af465b1f840200c0fcc1c94656d4e4a6d6a537e28509cbe507b885cacfc824c3e9037cd4347193c8d528243ac6e8b58306350ef27878579a96f9243c6fd5dadae6788d38fc8098ec9e8c7f751fda782c6b5c68649d9b909e26e3b862a146b6125d47829e70da0b7852699fe110c24a4664a83c9a31eed3780f213a77ef725b27b0419fe190d3ba2123c8517916d021c19f62d5b505fab93a717d757b7f5ce719820243aa793feaa11ec6d68d083f4c2d8269ecba0d03bda1e0e980739c602102dd32585bfcf249cff5e12a6607b75e46d5b87a72c6928d4a25c875d032ca16b4577c7c6f6bed8994a54609f9be8e503c34cc2348bf1f231e1c167031d72fcaf6b402f0af2c46996a43d627b7c4f40c5141e8a3a057c9bb9775b2f0325ee6922b45f94808a4bb0050da47c60f601bdf270814f28950cef188b7427364e33bbc1d508d55811b7ae908205a64e2550eeb35299a4617290d38a21bd0274cf477da09f59d3c796b5a87b28f77790483a2f0ad1fafb553f9476b2cd15f4c59c396c2955d9583bc91d5fca03c7ad64196a85c73fb11572843b1a391caae4cf52dcb0da83f9929695d4eebc7ddbaf2af1c823478c7bb1c157c460970f5110695e441beab00785254e9969e5b75b9c665e03d41c3d6a286ed7cef8d7efcded4e32c04b027a5cc9b63caea011238135b8fc494a3ba635900ecc8130f67ff35b78cf7f655bd0b6653ff8f485cf6eb4dda21f963bf44943a2b8af463c65d139db4c35040069f21c49209f72f5158b946a8fce21a803480b60a30d85a9d7b5321eef59ea85a3668dabe0c29a40fc46312119556099e6ad28db8e3607dfaec393428dced502eea1adfacc6a8f485e23635468ecab1f5358382daf3d9b6a30d639353718c51a05ee7f1e322ee1c3def93b9555e66404cc3efbe8baea370c0448a6b1409ee7703d60812beedcd05adefe829605b70c42227e07443a803a257ed59d61d62381350c743acbcc2104328d40c0ade5a26b2e8d755fb0e956b5717fb6d3b609c9110fe37f1f595853738546068eb6188ca23d6c4302102fd6b68877f4896a5f4abe4641aed7d95c1c8cf9eabfef002afb3b9092d72ab585da7b61ee949627604b4a32abb5b21f221644cb980a059f8150042ec86f0bc779c2f33712642daf9ffb33d662883bc53934d2678401e938e39022f44b2cc39c38fb85f5e372fdc7221face691c62a301a066cd5285eb7913ab00c722a9645809e67623252721d2ceff9b27584769a6d4f2824266a1800b9904d4eb201ab36397cdfe1a00a8a21309c344712444bd2965509fa0fec3a4e1b85ac4e115178b7aa9051748a7d515a633bcb608abfee669e640910e9686915ef8768b6b0fd051c49476c6b7f2bd57abb2c74b9511d322c6a838311acbb11a573177e93a25fec1e60142825079e7deb47a42a0bb7c5b06cf4a3a52490bc2bd4a13334dee6dcea43fc2ccb7c0c5504494904a40b9e5a278ff8a6565deff67fa1590b194d302bf2fdb48e14fca95070314598ed7ea33b192835b31a04820fb2c19403afadefa6420662dde0c031be774f843ad11ccc97bb6732b812134268a7d220c65e5fdddc88871bbb96df3cd5b21c6989ba8ff5d6423d8d0a0bd0bd8b36d906515b0b6bd03ead858ab5ab53b862147d05e2d84ca4634f0edb5d7d0ea9693bfaf377bd802301d72890aef870f02ec3283a8b60e431c6f58f693b42ed47a792fbd0114d55450f478201f9d6d8c5f0f3c6470d3a8bf5d8a5480d82cfc05b99d9cf5358f70fbe96ba727fa2cd38fccebbae76372c2d1055b73ca95c2bfea39f7d29d24dc584e7b438e8eb9aae72a9a0594c25d2196778f4329870b6e19bcfa4b989ed63fd39ca7ace070a4fd1e67dca19d4b7915df8c04a3ed37ebbb22ceffc249e6ba7f987b002badc912f27a533cdfd0a722aa04a78d8fbc39ae514c0a32f21a9f7c3b42f018d83c626932b2eda9bc5f10809944772f57c3dc09724b15c39e047681c4dbbecb96c19f72678007eb17c2352b4df61199d6e5d207316482a20a041546f112ec88012439d15f93ed1c3b0db88da422e2ba00e8defaf3a5a74c9ee3b16ccfcd6f609e407864a817eaf7b7d24234c202e58c9898519bbd15d3a68efb9fbfcf6a856557ae92fe57094e4b441ce853de4794ed4fb8acf4b116c6f9dc4bd15d9466d7c026bfbcd199da1d4d210c6123d9090e318de21f9aa4a95ca2d9faf11a4427033ed0341545d4799bcf1dada052f434249a5ab424372d30c747b29dc92aaf7554c9e4d626f092909b669515a21dfe54de40d01090e9ef7ba85743880d5a6bedce381c0e185e55750946ac757df3515cf9570f0bf994fd6f99742b6c6ee96bf77b5f13684eacc16fea8482fdea751b7f25670acea3eee8d4e43a3d8ae3e1eca6c99e1fa71a1b3e864cb20d7ee30491cd2d15379bbdb5f19d8c2e6a62248575d6713931cf6ad16ab1d2c3a5468e2b01a8d412e21406dd1b70110605a433805c1302f9d1bce689331836368671483a0f7f9dbc614eb129cd73d96f2ea5b7d8d7afda10aacca8554ff1a6aad3be8d6cb3f44621ae7da58ab30f0e81dd93db0e692524229cbe5db17cd3c37f13037d05ff75dd64d8dbc563ab17b6a8903b99e42f34bfc7b6729e23d732f6b7f3fae70fad4015297663aa3af64d58cb7a89e6b3ff6267253a07d82b046443f1e5bbaed1888fcda3d20dcb7339196b2cce190b7e0bdc10352f7a5b4c3430d026e4cf4fa1b62255617b8751fdef80b77d937c2eabf8bcc1d4f19c82cfd265de76fdeca7382073d5886b3986e92233ef31692eb217088ab7ac92708ac751fcbcb7ee06ede07a00164dddd5a029c5aab28e5acaef332864f8c5b0d78d6170d8b62194f3723aaa58e85a4b740914b22af331e985ed79a68c16d407e476baaef9ca238d24f74c5ed1d5fa34846096da4e1ffc85cf3c9fa6306d7e3177e7baeb75dd169cdbb6cc1107340dd73a7233496d3355413ab29f935f6b6a63bd01114fd208f2a53b695174bc32bc25fd2854dcf9540498178d79961894c6b01bd671b74b7e2fb2f80a2f8af58036973871e6c9d5ec48dd1cbf4634b44d658645400da1118b54a8d608d258c18cad300f69b71dd7aa053767089cd9e868b74d593014055ff60a0813ef74a8922ad1ad7d3884282f281ddbc1d931f5e87ceb26f6d910d3f166d3adfd6c2aabcc17e4ad1bc4d100fe18e9f0e30ef32831eeb65afbb8f2471a213b926f485ec429a0adf9f7c193ff6693434e28eda5c9b0e5d40aaa7e9acd25afd4356389cbc75e61915eda433fa90500029a75f727fff19bc016362f87333f9d7579505c440b61ade0e36176e0834387b14c78b2ef89f1c32c4a0ca28493ef62f5177852b4293549ea644cd4a4b37a950bcf0cc77acb970387f09a327541aea4233051e3b49fbf6807a3bb6951588ac3360838db6c078b6ae35ecdfe0a349b9e5e560f4bcc3d77ccec5f72b818648a37ae333034d8223b718be26389351ba13024df0705c08c81de46d92e2aebcd7658af1afaaba3ea2903fbf498f6e3cce78d42b21fceb8776da272de1613f425231707fbc5f441a5f0722f578f4740bdb2aa68ec447e2d2833a7ac5728d15d4ef2301e2688a4709a64ab994b40a2428c4c6210b5c16e533b633be9bd8b078315787958ff6d834866a72748c74a489aaddd80f01802eace178d108ea789a906bcf84afe50c89ebc3891db7d380c73605ef8fa3a0368e499a3da89b2afdffe81234afae618bbf58bf6b7da3ddeaac4f0ef611197f7ea3d4be176ab09c7b79e9025ddcd3ceecb2067575a642af630bf8e721b010373c06bb22dc9978e9a45750c9a2107630d0c90c168097bfc25a75acd1cc284f43a061af7f00e7660c12b61d03427368cff6c11d83ad0cd741871421053bc36620208957e4c6d9cb8530b5cf84b980e3c3445b5596dd934814dc28606f9d109d5eee1b3a3c25aadb2bac1b7b6b78a8c3aa153776dfc4584c8bf49f8e120b6e314cd2970d6b907ad918d566baaefb6611cd5c86a4ec35a3b9746a514c7ffea7aad7bbf215cd6dee79cd79cabc152f50cfd2fbb56c79f6183035f8a9bae6477f010ba93be2f075549f95209fca5e5fc0de171d47be9bf6f1a0138de7db0ea2e0e4672e396d0bce99bf735d168f8d5768f542769e632a716d481a6e1c7fda753229ff58ac02932d4f01f1357012a3d570e8422f4eee226301910bfc6e274cbf250cd66388187c61c80a567cd0eb95dfac2fde0d83bb858c9c9b64d9f55456e7125a0dd7a6a53423bed510c84f2ca53297ce34da4f8e4b574ccd683329f6221dbb2c0030c6c5200a696a44a0852b623d866007ba1c53abc81c00d4be2723fae5bc3df6a2a06883fb7b9c04c563fe3e1d601940a1efc3729822d821936b62cf09b8f139d52e0a98fec6b697d36c7c365af89e5d250c38d789f368413cf15a9e0930a6ec6183818c724cb2815c3804aec1aabfd29b9b26835783072e95c0f7a7eeedc664c4b505ba8ae0263b3e6d172a48009c8f5ee5ceab583be737dba49c8eab4578fdfa04c949529e2979d78f14bf69153f6740ae36c18b685c65ff8d36e2597909daac41de8377bdffcb703ab9cb6d5dd519a20b5fde1b5de51ddd9f842f9ef5db","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
