<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"02f7d1c25a41f26057163c6888990d40cf1a8fa9716517efd70e85d7851d0ebdadaf89cbc0b3125af2f82fccdf245e42407d1e3d028787a10c39974eb60ba05bf4f4192011d438fbcad7948cc299c679a3d1f5b5f5d3d70ccd1d28ea1a29bd7f5313378a8a616e0629c8ba46d150d716a1821ad0abb30eb5ad667fd59c5addc53dcebb2974ea7a116275110603b33abe529466df9365617caffb5f0dc77db0d4582a57f54455238907b50a40994096186d6ebf7ce90ac3528e64cbc170a78aa55643a0544eb2b2599e8f9fc7dea41c452c7a80cc6a86e9daa7855bfa737d84c13c4381267dc628f39c1358bb69ac4560f010ce20e0dddfa4db560b8c313cac74d6b6ada3c738c88c83e335f082f61c2aeaefd749bcb614c7ca22c19933aca0f299aa0b99751af2051f68330aaef41cb562e16985ebf051f3a31cbcc4f3592b7bd2dae158856bd789bed5dc152ecab9054ba70b8b0df36432cbef56a8cecb6f247bfe3941f558c21879567fd5653e305e9faf27e0162a60e1b310191be4172f13b461b8354f52f197a3e144640efd7f27016a68755d9b3729d49dd2410411d77d563154195964ab591600bdabc7be6d3c7023f6176336f94caa832be55915da4cbf54bd6cc90e40a31334f8b0eed2aecf8927b619c627e21a1d8696fc2e0e159629115d769bcf81fe6ed482e5a204f1fbac224173629dc72d51b7f4f726a31de2312783365b6b23be04306b892980bd2593160d2b6acee819dcfeb390ee36e6aea3889840c7fd171e9085bdd1c80e315b869ed28d264cad9361a1a76b202a5af3dc320d7dd92e9a6dd3733b6a3a7f8728fb06fc7c46756798c6d6f418bfeb18cb7c08b2af3fb51e111d745094cb14ef686f33aa60c2a5b7e684da27da5b1ffad0c616e7807a67a24ff4d4211508d78caec0c9a908e60f4f6a822b00173c664cda22d2a3799efd60a8063938e48813d81358f733f50821005894d94970ab14ba6ebb43cf74ba69a3221a52ea93432bd00c314db36d9a83a378c37563f1e78c9a849f6a711a167f75d731c45f79f5e3aaadd319c1329084ac6265fd07bf6acd37308ed3750a8ca66026eefef285f371dd74f781fbf02609bc2bfa3ac57a0ea850b6a7753975088e4b9ef3be18ba4c939bcb4465429215b3191a7755d6e4205bcc2fbebb243a0998b78db40c899720d599c1740e47ae8d1d78aa21f888b99cf597f7acd41bb251832b0b540ee687d57757663727231f2cd5bfe4dd42cc3964443fff3e8b227828091224943be5e3b5954532f83b34096297db1e378345861fa6b24c552063693b4c993950afd0abb4eaeb81409aad2a3b5b4c65a472f8e918eab4972b03d038a6fb4ffda630d99a1313eace1210a7cd8c2605b95234fd14eac0e6cd91541ccd7ea3c68b74e9e49105eb1d61d2f256ed1727cd22906bf946420981410786f5517af681679aaa55edd28b88a558ae54cd829d58ea17ce21ed23c25202bfc0248861d305a0bb1d23da75ed67ecf6ef8086b63fee7af309841ea6fd596643e6df8303bc35b5cb0f4ceff188e6077ddb4b5346d5bbfcb959f1edf59d66d520e0af6e6f47b8eed889575e9e17564cd03e75964369f533bc9037a3b58a042b99ad86517771ac82992705346e06748bbc4212fbbd3c9335bb3603697f5ec69cef9935d956a0e439f0d42c148b0a01e52b0e47e5ab6029b4b64ebbfa7546359d96f4d5bd40a4e11ac89e4b837f1a8e0834de831c9cc1affdd66faee8f8feada228e222c876a89f295f18af4e32ce231dd8ad3c0f6cddc3e19b082c7d0431ac475d6405e11f82c31682adc1b7a126d09d28363a50d589c9e4acf071fc2e837e49c71b0819c42bc92653a884b8748a2c7f37f1b7898952c2f5c635316567a0318bb16f65b20497090d1934493fe163cc0ca05b605b1b931212b8f3c3172e13f9ec80da496d1a3cbb56c676e11fc13a897e830300638c1fd0e0c71b3500e79589e8d83fa98e1131809c01207df79222023b0e3d25adc5edd90af4a0948927cc5296b26bceafbc091cc00b98a0881b4861b4d4154d785ce78f6770a0699d0b652dcf2bb74cc3fcef676b305c79ff8df93b3f3aef07234a71c64fd5cb1c056b62d1d90307a2b5a07b9689c91580ce7c4476b610ef57d8f234613c6a80d8eaa3653e194de748936b0b36f35f9ece63055c2b9d069c345c4b652cad26f85cc0104d969c7d7aa83ae6b18e57710b0f87fc4baac00e49eaf67df23dc45b3f50e16515002247bede24e6e1a8c841ecf2f10f786f40430dd8b78b3d198429233764a980c7e2a6475709f0d46ba0d63d383bb887cbe666adc640389d43223fa29e3bd5ef62582e10668a1b1976bfc441dc021c664e86a2653d1491dc7768ddd08fd83abd2b8ecdce09da4dcaecc50d4a0cfabd8e698de387015a30135d7a239b02c7f3c9645c531ddcb4115a18b5bc0f274ded8ed845f0969a9f818db0836fcfbaf713fcc5c5a13cba11fd39915c1a93d33876aa8ccab1659f2b73dd985346ef50cc7beae06c743028297d6e60b0d6f70b5a869a4490f190d309e3d9a7ff8972b580cec49a7a1e6efa62b59862460986a4f48297c9fdd7aa0cde0dcab0f779eb23f3be5bb1a5790c1f53d4beb26f078c8a1b4689e412842971a7576fc95b13c955d79946e28abdf801e378060473069954b8387da1de9cba1c3ac496f2412f2ad385fcec26c328a1b71a845724142345a40bad7cc6e1f7dacd2a19e18ad8391de1b8c0d2f340ab63622f4bee93331764a7824acd76021320049517d8b45f837181089b6b56b3329c817a48a87857fbc039e2121541e2ec5b4ed2e0b3cdd8edb64bc49596c0998ef60d99a30da1d3530bdd33a2e5dbf4dc11162bc5187d65805f03e6970555a65712c05f457bdc05dd60e12a1cb80b59387742b7c5451fc2b0d6d2732ad5c6f98889c3de5dec2d17292f8fe9f117131b17049348c14057b36540de06dd4e013903c9132f5ce9a1b2ba7015eee493d9e921afa073f47c88a058e156bd8cce6d70796bb29bc0bfb013d5ac00544bb3999ed0ce8b10473fdbb33d1a8861bab349f2e7dfffb64545bff70aa82eb898ad41fb909e2560beac8a1abe9fa03db36376575678aafece3dbd241083fac3fc7013b6897b9bf801078ab66fe3f9fb1b781dbc6aaa810b8532c109b845643240ac3f69808f3ed2254e750e5b2af77d6c0aa9a62a3cde06a5d7b5dbb8df982ae7056ed697976057520eb149d2fa199c02ae61aa58eb910508f556f62120b68c25f14e08521c623de515daa84851f2533d9c8167e8908270bfa689d4fa69561e616be7e35b95b1e92c64b02fd9d562a45ea85f115e8cfc59cdc805b902c7f51a42d330df39ee533070b6f599c8bd79fe56ada74a85ac6f81d83a898ae025ff865349c38b98d7175e41487168d20e48e405a0b803a4b0f71f97474191169b73e069dd98aad0e70e93b964b668288b192079f97c0f18f57d8dd864985ea3b6d1f07bdbb188101c2f726c33a51bdcb5480512e9703f880c68cd8a103f6981a30916eebfc138a9a34c83687ad8bce3d4203d7abd6e903f28e23bef7c1d664d520a1c91ab5c31adbbbe3b39c9fa95ca4bf695fc179af02e730b0cc886634d4f90afc240e11735804cb37ae4c3030d1c38a073d40e8d44685c31d0d3f301a1b733bcd881db6e319a0844e5e19b597d243a2bdcb70e7147ea8c98e904262af90a79a3baf375eb539cf952b12ce9f788d7b743d1d3c6dd84d2025529881cff5ff04be252db53f5784ecb4daee5e79638eec0838494e219964f92e9feb4fe73274ca5c41cb20dfd7fa3fff3564694095634336be9caa6702ae429b9a200bcbb4cd085fd8f534d3910236e6efa05515505b3d4344cbcb9e84d2f1ec3954ca142186fec7f0a68cf06fe640a9684a0bc5cd1aa4a018c9d3b5b32e98fada6a29b20ce0a062581192fc2c0ed0ec0950e4ffb6b6c6c425dd68a53fbaa270b4424a3cad0f4333a82b7d49a11b7f586060bfc54d82b1dc72782aa38c50f1523eda72bb666ef001847f43960ca6f969b39b415789898b052504851137fb4a6c3ada6cf5cef33f75f4df735bdeb67f93470f85a19d5c7dc168346e03051c1cb46ede5f1b8adf0be7b1e048530bb82bbe9b659b14c2f9a852aad1d9f8cca4565d54c6503ccff65cead845e43f3be16e1b65a2160b81dbb18c3e3599736b3369e9640ccf41cd3a2add9da4468828689d75b10070febf391b7ccbf0585b6e0f2b9c3f3bde69988fcf3823c6a66702e018bd6cee8144a75591cc20696035693b17cef99c346f910f556772d60c0f1f4a31cbcfa43a3ca5ad5178d265e2274e14168ba523c635d21ef3640bdb268fea78788963c3bef785cce1f49704c96ae1e630fdbc28641348af79c7fe81f087c4d9e930a4122bd7a64cab1f42ac83fa1c97d12d89c5eca5d88f2e6814163f3280655ab114a628bedf2a35bf0d0ac5d431c031bc74f3ba1a2f33594ffc755690fd0e0e28279a9d44853d2f624bf61ccedd310eec1ed10dc4c763a58d6ba18226c9367929eadaac91d1bb2ddf3d8cd45f4df6585c4d83510fe7ff55bea5074801c6b58fc74c297bedde1330a5d8c9da14d1e3f52e04e8cd3689b1c738c000bbc3e76df9fc33bab59a253b9ece86ce49e37307026b64d19dc272e6eec14c6780fb927948a79a16c20be020fa89040dfd86d79ed5ae0c75b5f5435743fb572ed11441f06ac701ac7fb8f844823e1637e1129672934f07be374c3ddfa45cfd10caa249470ea4a6a39c12611b0e67b9e76f5b1590a00b7fdcaa55c38696f685db58a7c1cac7bace88b8d6383eee5e08519e65480b757b7b528fb4139ee4b07f2412e84b338176970a5297012b81d6e07e4d5b3adbf4bf8877c8ffffc49be24aca9800317fbeb857505a102b2e2b232088ae06196ed7c2b5c36f7992ccce857588920fe7e44a5662490975eb13ab599c408d4aca7a710ab54af272ffcd5231e6c53d765cc66d91fd9c430a3613a650af490c4f7f69d868a64b2aa0ba973fad4e412c7f7fa30512ab323a785f80382019878535dd1dcae861c57f7e4c4f4a38376c47431c22d9d5f7228fe856669757964b6748a35164c6ab156acaee0ae6542b6c3c01849f455b9d13d0f115257fcac84a88110784baa5cf1dbfaf3a849896ac0027d540ba15664d8e31d9335036d7cfa3e715356a01a92577ecad1295adc2b270ea37f5e741a54f5328d2ec4e22bfe10ad8dc33eaffbf17f0ac61f3e6425a145c7d5c17ff37f94063d2032cd9d102f9a1aad7b85877be57900988253801bab2c6258a4b48119d6c049587b91ac47564d6d54760c950803473ed788878be0322d292a1c13aee3a112da4bbbe8c913da30a2303405f72b5d7f9b5fbb30f09572041493c6337f46c491d71bc10af2e758c76afc8a3cdc4303dfb9ed21e71778f911e9587a1eaa15a5ebc3ec6fed6b04efc22738a95a97f2f4366b370aa1023898108998bca6405f8f57bc0a639047cf1849b590f755c7195346917dde4360f596ffca8f90c43d1192ed9685eedba9a6f5c8ca6933aebc63399dcbd89ab2feb3049f54e1c9c9d35b28e437be9f8abb56466a9f0af21503b4d8d1020fa303fd3ef2f35bac7a411832af0e839a395a836b81a52b1318d00a6a087ae153cc17ba5395d33f32f804948c7bdb62be77230fe280c704dd0d1f00649db9a87b3320252744c963d0816f1cf6946b4acfadf20105d3c455873d6f177e33c6952deac23a03841de5d3e864324840aba377910d0b306aa02bf76b5b8809e1c727516635bfb2eae7ec63a32feda0fa263001379d60a6696a64eacde0b56583ffba00ccc07c18059ad4256f0d03252e938583dbb1b0be9be65e3de1d05346f8adb147be7246e5c942e5ccaa8ba4c0a614888b9065703ce634f334159dd7ee9394391d64d2c01764a08b426ffb77945202df889d5f863a6798e09ec3217edc28b79be69dc959c9b380f60c28cf182506fbe3f33ceea29b4fdd2cda71e7a43c5e40575c7ef42509190ea673fb0d5b030cf6104f492fd95ec22cf8e1007a0881a4eb2f79cb43ec968493b590fd09d975a04a835ef77d0c1eda80f1a07670bf48e21fdb9dcff997583cd8ad7ed3c484fac493312548438a073addb615b9cb8a4e6a9eed26dbc11ecf6aa81e8364c5e989640a8dd2fe89a1b1c9c117d9dfda5457f8cff9884783348e70b4af2da614fb1096ee8ac24c8676dfd4b3c3b532c18e4d5d2c9445fe65a6c5c5f9befa03ed8b1b55b35121b833af48bfa6b8d0631b1cf15144e674634b23f191eec10245597d3f79f7aaf01be84c4406942bc712fedf80e9664fa5d753e671f06a8c19e7123087c51bafa79a20019e0cb64284e98a0c6e650c4a7b42a6580ce7fb21bbe8acaa099f196de9be738f070ac20251a967ce7c794ae1aae7f5ce19a67b0ce6ba3269885de8647a95b2c8ed87a4f026523f97b8fd38bc1a5bc3e2f8e56f8b954b29298fc67edd871b19d14c0edcf6eae491a470fbe5a1e6b14dc7db0d48037399aa3c985cd7f385cbc38406efd3bb2b6dd48e7a42957de288424d5f67e9089924eb7060053e746a5ea567781d38b9de6d45dc3e6a18a212518e961529d146c6fa4615bfb7dba2688592ec0625848caa3dfe423f4c0e6db56979d8e5aea879b14643b1427ce446d56fa62e46a4ab8e1c9ad5de85a09fcf0c61e953d6e9e31d72af17cfebb2baefd5d4786ea64e672b83453498d2bb4e2001e94837da2c506de64911d6f32b1479fda70cd764966875dcac628a8a1d65f575b9beb363c570afbac018c5b07d7f16b6813fefff18b52fb0eea97063c453e9a423ef7d34bc72a182e27d7fd75ba0aaecec4b1f15b5dc6089677eff697301f634e2436c9807fba9ccaab26743da9ba2c305c261f02480e806906463a19614b1a73c84b94aab5c95a0be70065c70aabc0e0d9b87fb9b5bd606a01c8e989a657ea78b0f6423888c593ac5fe139a75184590b363786c039215ee456ba8b55a7325bd3d3b18b688e078280afde259eb50579a2c98415e35476e84661a175a85dfb24c3ca2bde7233028a7e1c31495c473f923efe7b201256f62c31dfd1651a5349505e97eee7607271fc414f7797e6ac7e2b70dbc838175dc5d80c32cee641dd8f64908ac0dfbabe54e5ce722a4816e5edaacb47572e9390ddf76dcc786aa437c4892ac257ee3f323c07f41031958a94eaf9a90676e03a3042af159ea0f32594cb033563979614f4de3442de58a99210a7b9b7b3e57a01a1f67c0382983fedf2fc8a1942783d30a38c37435cc1a83d5591a27b5b48018bcd40771f00a5822520adae8b50839d3b358bd0f3445e53154478b27a2cbf1b1a279966ff5c7465340289a6520f339a5bd12eb27d42efdf9283109afa8ed9b39e20be61c9496670a59d3f55f6d9c2a8bc34c76febdf4fb346c9cf3f993f73640e9dc0c68820c60a3b08e53a11813cbc2d91b582f78d809b3edee3c9d318ea0eebad2a440e8954aa68447b52b973887730d08bdbbf6038757ae2c5fe2b887836c3ec68f1ec23390dd4a4010fbf16b3d64bddaae8952851ecb056b49e6da0b4c4cb070b0e3fb12d07445a59f4c40fc470c6c76714da6ccfef04167698eb0d9a5d482f7f8b8057daba711f6e31eb11f2425c4a2dcf03f3ac41fd1114e5fe019d5d6e8c65b67e6ea71af871c581d801afe0d367a1fdd371f335700b7ab90ec0c78cf9480cdd0760f42761ed4b6e8572c029aa4a73b1c3c8bea14b46600df5dcad7e1b8c5e3d8c0245e6a21047fd12a4d3b614748a114e0079f0d0e24ded32918b139f4bddd47f6c68a74b72796682c61c2cb9e34cb39ccc44ac9330b6d637a5ed6cc62204fe44b81168fa40bc49287b39aec4a374c45f0e35fb6e8f749d368a217781c8179ef0e97e088e96c3554d36428a9af6e9c6b4cb41db71febeb300db6ce3eaf0a3a66b68988affa92eb6c4c521f119fd91bccd3daf204463cd65e3bafd2a498cff83700683b7a94c69bffdc6d0ba06407a23ff6bda56e7485cb3f1dab271b7ab3f83d658b840c1ddac39d95bcd95c83783c79976dfcb7c984081ccdce79ca55b6f7b67e6dc048161f951c8a9108d2f9dc12ff7ea361bf259d0c8e5823d6a2393bf2f9d6541ef3324b073325b8a99e589025562f46c79ea301cc7047d231b67865bbca877b324531afcb35b8a664705910b0cab1e537654ea72535c309f9e2d9dc0f07ac6c6fcff55a84061e7aecd03e042d0dded421cd7bdc345a3e510fdc787277d02290648634d48dee4d7b332ca2f0583a63713ad82eb633ad61f99c1ed38f405dfe1d4fe1420769c3448f651ea041dd7b5421e6bc3fc12ff53e3ceedb42d1c180ee77d50174b7e79a8c7d00939bb5a5c9b74776735be7877a866c5c1c42f5608cf8208a6496e873279462fa05e99db823eae49cac1bcd999bdce7bfcf23048c099c1f345f367b15619fba53d21fbb54035581178ce6660bde411bf252f0d89021c46a9739d4d458ff4f838d2728e9ed97cfdb454f45a6563f2773fd9dffe14d44fdd3baa1f543a25c0e0088689d05d368484e481848bdbcd7820b7f17182459d4ca286d79642cbd09e11dbfe4fc9437f41a8c6d4b255ff9dc508e9bd6d76afb6ca42534469c39d224bf4b688d666769667d74866c43bada6562e5901ee9732f35ac3121301a6fb3942f264565a43fa60c4afd8ebdd02d108503bcec7f576f43a774e8060afc7cc1071e1c1acbacdd79eeda0a2032e3bde99ea35331f50dfc8c89814da18ca57664e4886a606ca10bc854355fa29c798ef75305b0712c9c140626c358a7a345b62c4013dd1c75ccd1c291ed0a2d69769c570dcabcc6996f2da147222116e8e792e691c89b7eff74fe48941b72c3abc3c4e2cc1735dcaa6f974264e33b98ada8cae7ec9fb15f7f10e405e74794db01eeb784db5858ef2be06f036afb924b3d79e10a284a90d4eae37f8400184fc9e4937b8708b349f3a061a6be06205e7877ae7a3a593a17546b3ab7d1d149690daa425615dad4725eb8fb54ad8d6ec5e5832cfd473a79a38c6eb8334aaee2505125138127f73484655b2f2c0f545dda2c586ef7ccd50acd53b845051861d338500f350a24fe9f7c93c9b4cead736f308bd2bb85b1b29e6fdf896f03bf7c81bfabda4625a69fee9caadc747468f04e149385069b55e8e81c978e88012f6f31f13f8c7f44df5998a53523c57300192beea3364ac07158b9ed74bb766a1d263915823e8cc60b37540199c3bf9c7f9baca909354157d4e335acb6f75a453ca56b8368af78467bcf728525146bb7665065cfdc0d2e86c4077ac1ce07acfa6dce86dd0c8c6dc2aff0a01914c96677ebf99b53983d8368858e67212f3df66c6e9990fbf5d4bc17485af14a1663e0b0d070f670a41d214e078eebae195aa5a66a5df3830686247041ccc8aed783fdc471c3525418ecb42b0f178f6811dca83be6faafcda5a0902c45f6c6b46f1111ded17e53f7a3f15736e91ba5da15282a042b10fe166119047e8fc230f459d3af930cfd9b3726553e1dac8bec13f30d414ad82e68fdcfce8ae0237b298a01d1f741add7f961e2120968009dea5d49bb0cf9f9e4b74d27fa3bb4e8fba5a479797227ad35564d5ae1c92a585cfccf7fd3b0d4f1e163bf9ed9b457ed60d715e70eaeaf7f1ec796d09081cf1052b01b43daf8e041802a7018624a01f4aa47c4a48fd720de0c12bda862e05f7f069c33880d976f641040d4352c64c5ea5ce59deb6594df74b97c3beffb83cb3251dbffe80d83d1a833b119a383f25e4aa4f3516a68d9465534361d4e6336fa9a8b8457b492052ed47e148d3ccf3d97b687d516416d878542524c246906e7fa8718f651c347dd3f6641e5d308823fb4b7a48e1371fc5e2d0efd15c218d3c34a6357e9d9099c3923bd6bc51188ec96a479f1d35e13e826ede07ec72171a362ecb89fbbc181b6544829d4e8e13cb2cd0a08ba460ccf55f9d4e31988234ec2fda302d4c786d0876b9fd76f8575115c5063e999a8a93a15c93d7b3de7a9ce55848c9b63ca0a05b9cc097c877f0cfa9130597701ee77086542eea3643d83358ced79227b5d8c2045f585997f7bb8455a26415a3213ffbe84e4668bc8096a544e09f7e5d45c8ab62d6c175b01f168fdd79a60204159333a5aa54a192e6b4c9261334238d62fb25d019669dd93e2d0e392961ad641bc54aa14aaccda81aacd5e5bbb42b0fd85a61cbc6729e90b4c5f95edc08549307802e40f4d6409335849d362652b0916079b42c31fc9439a7fe853885e0f9ef85fb9b259a54acd5df7e53c77316290aaaa0e68a823d3b8f6542566595d586190569319bb612fa4f372ac87c47312b059bd5423db9eecd3a56aa5db081c67b2a3634a6c4420735c3bb76c6eea741106bd83140cc2f38996c289c5675aa007071f283a5c71858e5bd9992ec44cbbf95f7be660c7d54f2f6bbf8d456827b28a1d96fa158e24c3598d2bb06fb3a90b43359f6d9bce636da9e29e33c90c80e6d7dc6104cb4fc87e07aced670343872ddacf17aacfe797f4c50023c4142422e6c85162e2ac1f882239ec489ef0d5348dfb4123df5fb639a459f1c38373f363ef1945bce835a46ee5dba50c72e97293f97b23043bd5f89a6ae4a7248e54fc1aeff7a4ece10e86cbce0d6fbfebe89a4580d15bb7ec8e481d2189b22faf251de07ade351b969b30c4d0fe52604066011cd98ed24f1ac630c42f263fcfa32f44ac23dafd10a3c9730f5c8a050b04fe3d3a5c14e351697edcdc996da8d1607ac0665e62de9a9ac20d338074aeb88ac6d0b95f5a7c684d0e74b1fff367a5153662405fd2d3a3ba2a6031aec162d9895c817a89ff335513c1c4dc982b4506e1723d29572b95c45ba1f643194d097770565e0fedd211f4c21f6ebca97ee7fad7970cd218fac6e05260ba7322646446a6953038149d353692ce82716886c2e197b83e10aaac774ad02fb50f0b482040f39a0bb5c78561eeda5f19f7a207a9c97261fea579d1e6722ab6dc1910f95bb5a423af54c2553a586b75ea8bbf229357ef38e2e52e70c0a2a0a11c8d76db5c17c7eb454e883425dff9ddcc4a840859899659a54f89c6e6a963f5735a780f9f250905489dc99bd9b170aa1bbf3441fe2ad9f9169c4d4b98f5ebf793fe412f1f5f1101b4ff1f24a0bf91df61f79e6094f62bf7455c21818596eaf5f5a47f1682c593162ac0f8153c362d95b450bbdb49eb57010c405980df1803c24f616918124689c611f8f7f4eead8e2f4cfff0a2264b76ae9d730f4cae056e173a046eb9a83270fe9611862a6d3f88dcd76f46c0dabbf7c2be733cd1a94a9caf3b469bff791a79866b7e556184ac11bd5c64f5b606c0eaf9728e0266fc81671d6f4729c8b7b12ba0aca940e0caf824805ebdc475a008df17e9575fbbd42638c32d70939a8dabf1c1e198bfc9dc0e56e451bc5b5af29d29bbf2715a028a4e97c782c6aca651eaa35aca89dc3ee489c1a6e4f633a369c5455b5a417092268290a783d4a81bd44ecb20c30f68b280803f14977c63863512b349b912bbb8565f74e34763c8d16eb2d676a3dfe0ea3d8c818b283a438b78876d38db4af5ab868c6b17607e1e5736414912b61969cdc69355b5e1c1eb5876c09cb49d4daef1eb456f1091435c4ace4db56ead665f89aeee4b8e2734e57668e37534e7e67840927320d12c8315e696666ab4be164a21bf457cf2d96b0934eeb90a800dab3192f3a96c6abfc6eefbb4d922ce309b2e18e891eef79eedf40989efbfc0605414f1c6f3d9162b732046dbd09ca1428ff6b2d18ecde7fd90cd29e97ef322cc396877501c27dbc4cb58618e8ccfac710bfc4547426cb2178df95c3387fb6b3c94014a98fa457b74bd2a0c4c5c162762f09d7ba40c2da0ac04c11ac09f8318da67629be3c3c24074d8661f2ec626da7ff8d0f09f2a6dfc946e942bf03b4c2007c6566f9642afd348a5d67fa28272e6a74f66e53de1c17ef36b8b9bfa0590694ce03023309b6d130df2ad1aefb45e56848a472fc249c3b3cc5017175be22afbe95e57358930bd4dad715530a6d07e7f3ff963d848908fa9207c1a7e9798a2c1abba95a8524dd660b24077e978ac5e43843dd9b3e930f0729d6c9d7e73ec56db110f58eaa3c0d98248d11caddcaa3a4c84b4f6647d76e40f9378598a52d4f037db5b11dd25193868efd397b293d748d108e751753026767a0b251ae08e87f4c8241543be897ed94557e787b203982897da8b5d76ffafa8e305a48f0f83586a32d3680fc0323c5869cf9aa84fdf6c4b21945168f178beab9a498585cd3cdf862b78510e08aed7f7bc5e4b5d88725e72f875588a3e9bf85d92eb73a9eb66f7d31319a0343c0a1cdcc5458149fed80e0c7c54df74b1a7444e80e35b06ffc0025f268d01dd359ad4c07c6db474b2646e4548f221e00a439d0eba4c918d5a8ec2b9f800f76d6e7ff0a00d530ec46b016023dcb9c5bed640b2a762f980517540187491af41069fdb07f400f6f731faeb98e8ff3b5885e52d9833fd311d581c3ec023acf12b6e42531904aafd61580ed358af517688bdcdc3521d3f7e26baec2882dd31a8c6afaa8b325c2387058765f536d849a804260473a723baa61074e7f9cbdc0a456063e87ecfb789cb76f8caad4f12cb13825b8c0da584813ed71aa20b206504945d4982bd05c24df6818553116bc0a23f2f8a3c7fc634f58c140742e68f6661724d2eaa4697fb3f53bdce1f526a656f3a0eaacc3e466d9ee03ad337637f57d35351d11f89cfcf3e6dbdae0f5730e0afb1c5d794c93daa5f6ab733b756d51fe508f8bdc01ca29ae69bda3701d9430929ef6bf3a23b0d27cc813e12649597169aec533a54cc9d7ee76cf59ca06d7862e3a85d31ed43055e50b14c8200d1270af407d749fcd0607a962690e047f5fd9d2e4e5930587c33e61cff03bcd5207598e6d1fad236f9c32c75218b40f39a7785885c28251c76837d7a8e308816ac8ed641cddf9a3798aef271a034c145cd09c88ba62f496c9c09f3e3cfa51d0185625176be35054705d936bbd4ce1d71ae2f38d4a386c3d07e8e687f553b34d5ac3f3d81d551348e00c5962b4d918a565bb4477d1c001539226fdf3418b0e067369763d5fdef85b6104c49ada38b3eb2b9df4c756de1746bf20eecf81ba4c032de05627d8fc35e436dedc79c7d41a989904f94e3ad5f4221d14e757b5c44627a9f8370d69489b6fbe68ab6d39545f0a988e464f1f88dd5527cfd293ef75753707f7225649aa840aacae1feafd4b087bc282b3f9ed38faedd32e29a9e149dd3b901687e76462e5bea01629b7ed8ada4fdebb9c40bd92b3f507cf62529f54f6e40309141a78e4865922aab7d07246302c9f1525edebf3d647a4be85da5d337c6116b27be11eed3c891f8db0e79875886758661fea6687bdff1b5fe7e7850d8721dc529d4d2fc6c5f68849849dc79c68d29cc7b18710ed6302420c0ae8d9b6a37dd4c056cad436be915a79d4d45f60d591f0c0394e53b211f92917b17fbbd74f2285e968e4ecfb582972880b2cdbc0ed4299d1a0c1f37ee108582eddf8acdc69435618b5e32947635c5be7f5a9ea38b9206b83d74a0a348025afbc3651b6f9727b16e5dfd963124a130a955d00e88d00ce7e8b06b314b7127a8aade501a2ee4acaff1800c263f01e2ef61eb1fbb479ff609fcd180bb1814b94d456504bd618ae335fd1450938b06a2be342dd3f503929178976fb9a22f4ed2ea4e9583b95ac076c3fa3241ae0dd2583f2a2dfa88d6817a19b98867f6f1c33080aca2fda55fec78f593f1387bf5cd72097b79592f91e6a4f60f214762833d6b781b9a3d287168f482d623738ea8e1276d6fa64c280cec5c0e45359b0880e4680a890f499567fbb7db430ca9b01cf2c24268f492f83991d64a7dfcc49711ea964dcbf1c8a8f32f7ded6fb7900e6726e39c41f86f0d4edb1eaa9aca297bac3f963edf0b071fcec68fe76329b3a0969229d185be7b75fcadac0edb340ace2b7ca2510e3c7dbd3d2cc410c013c8bd0d91f11e44343d1ff5829f29d5bce3a74099851ff4c69f99fa267eb2321a568b40700104bcfac6b7b2a00b666384089d578034201b2731026191a970a77c83a77fa59da80c48ecb056ff701451831be7ca925799360f4977e7cd7b1d989852d25dcb91a4084504f65510772d24276d25b33a02682f2f5496cab91ef87fb4667aacb37270abfbd11f5ed7e29c5b28352ba2aba4052eacce3696367f359f78be237fb32969d61723a780086653b1894a3752135152858a05efc9b61415e562b7fd9c2e6a2ff2526d418efa6db101dc420fd57f98ace4a229322a9ab896b4111cae6a2e204702a68f4a5942649febb6d87c8d90672b4b433f96c34919a191dc823a9cb86bbf97330bd5144834a90bed28af71324d627d4a0aef8dbb38eb8065374029a6eff187f78831a0389042ddd20438adc718f169ef62794fed075b69c212270b3272fc9501ecc78e79e2bc8d37a6f6d31fa7b017c23e9e18dee80d810539d8fc8adbbcaffdc6a73e74dfb2e3df213ac1c681d03bb936873da8e320943c643a6ece03f082f3a0a7109c6371a05a9afb2d3699a229ec27407ba70667b444961726f37ae74b5b1a0acbabd2d28a826b8e7aefabd254c0dcc61929d3e6934e458927e9dc2f3e0e6da0262d840b1185560f8da10ecd4ab89771583dbabd1f429624fae31bd990cb7b7f2ed55e2d0474d6975fabcb799b3ef69e25895b656f98b5f51a4d95f9796943dd8e1a2471dbaffaed0e02c8d5d386520050e454460571b2712eb6f660d1d93dd53daff8d30d4e6a5da2be9a19409c3f3eab700a67ebf2436b57813aefb942a64065b1ad5666c08c26345416a07e75c559a4b759412df1edd5cee9735e72e0f9fc36db1f612901115ffc71c68683e23ce359044db15d4e8762478e514b2abf992754274adbd93002d98339827db3f720f7bad6bcaacffdd3db7317de6c73cf640d2b1a6b6b021c11c6d24d7e04de994dabf9c9df31c197157b84e1ecc149f60bd33136d2ef8153e4dd7707775f47b10857db7fd494362d7bdcdf627f96e620812d68c4cb0b4766290afccaaaf6565a3b26a723ad7ea6e0b82e8050fea608623824153c9498e40b47bbec2f2d99296b01099fe6a06281a798c0a6133aaca161fa2f70b465534b2dc333d7e7b8022d854af803c39eab9e6ff239672781cef0189d632012a77db8239439049e28859a4f3619a5cbd7c9802d56324a6ce35e9b2b21c1032705d4c702eeb2d98746aaa8d422b11316e24404981c17e293183520bd115b784be139636a7ae1e3afdc9e74b6135a28a9815dc3be3f858b7d6b6c82181dd78af2e13fc1e8870d811a73b3fe8a0d6e8ed484e3fe739593d9bbf0090333f633385c6c4d12ae1a3bc6121b5b6e1c6bc9dc18e83da20df4b6f577d98179388464bc338a9e69cc310028118e533765ddd8da8cea6261257e65e12f48a46d33056d442430ae2225a7d5de9b58834aab76bd0bd19122cfab69f032d9782911ea2596e86d9445926ff0c05534b87bc04a97d6db04dc48d630019bd4c5b95b0cf0b90021426afa5ac9b2bacd6e102853db27b959c2d6af165b9fc57000a9b1e8ea87871df5f6785e48d5561ea70b503023ac8df84a1357a7be1cd20571734abdda146a54101e34ec0779053d84d6674e2e0c20ba9b5979450311ef4e9179b4aa7ec8653aae793661e956950d1ccd8bf4b4f39b57f68a912c00589e1cbf55e3ee1f1c5aaa88f20905725e8b86ed70066c64f10c3bc4439d2535684a1c7a66b438865ad97e6144ad718894a4fafa5b8f71521cde150226d38e612b728b07d7dbec1b94dd18ca36ea2013e6a6cd33c2a94fd04b792d7b8c83ba3513ad965140c07daeee62eae7791c5d9c8aba","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
