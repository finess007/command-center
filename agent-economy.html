<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"96ec65294965d13b8547114467575e7b3b0cf6f5524a4f23c0e0e7bb89bda0c92815fd932c147e80bbfd195d45e64d3fa0f81dcd31fe99a6bee2fe1a9ab276e4c163cbe6b1791b82a384fe51c3039168e1537febf9ad5b0237e908e103b4eca32d4e5ac25f52a0c753d63ce56483c76dc917d1ca61af0455b21df64eceff99c28ab6ad932bab9af75dcb4eddbcde205af5bbbf658ff66df41a0a089fe912bfcbcc530e06d511dd27446136458d6d1874878cda60b44cea675dff35245e1ab812510251c0231e2dd057a9700dc536dab0d8d82cd9364ea25e323d1712fd3599dc3994b5c784bdd1c65ecd89f81ba6c83f7189d891ea7695285a94ed03e7806a7a5cb5b139875a37923c46df976fc9761d600a6fcd9bc9fdcd463578eaef071f4b16ce6d6f3a090cdcba01925af5a7dc8ee5cff391eb6f07f065f3730f8f6a3f03c6b074112ee8cc7b75039f2f10339e261c5a9eee44315b10d07b510b643cbfcb13a12d9438ee17934b99ab055f43f487920b3bd494dff05a92670bccb81acc20e5502aba181993b590efddde31855b6419a66927e5f9bc268982f01101c3267e6f0d0b7c7b108bdda7f2ab66bcc68a3609dff50fa3f4ccc176165ab5dc45db3ebc1bf0316c319e655c3209484ea06d0a30ed694086a3d35cbbe83212aee855ae65b024baf4e7902f7ec0c04b9b079e039120fbd97770dee521ca68124f6d881fd1de74980ecb830deb85aae2071bf5a392bd3de62a99421eafefa07dee92946d28e0e5115ce1610c466001e3120905bbfb2f5a9a5c846c8863c80b0122191bf4d80e47a3e3818994733b25ccbbbcee07fff155796fa890cf2a8baf57eaa5a4de6d5ca5978b37438c5dd5429b8c15a10cd75c30cb978af7163d326dbc10a32ee24269020b6a8b0f3db90dc877ec43e65ada06e0e0e0782027174adf8ed3e76eed09ec4cf53679eedf800def5bd0d2e4082675f1bcb654166b2659abf5632e708d664cd8a88cdbf1d106a920918a3b94e333b74aea62d7a063eb76e65cb32a3eafd4855b23318c55e2f94bfd89ee6c6cc5a7415566da3e7dd94a6b4d5e57b28d612a40072862c90d67fb9a311171999e01ccf8e3dd77989cdccf59b8ff1921c823e52eaf347cd417bc7e6262aea6af1dc072f1e5046bc8333a8469baa6f2f4ce183e7a77d1de70ec8c863bee3bcd9a08793b005f422c766436985835b16312fd93e55f1a64fea597ab3dcd43602454e0e57a931fd64f0cd5ea90d0a3c1e1a805e041a1ac6c0dc748c0310dfd71bc3894a853279265e83f47901fb3d8da813acd5df6b8d056d67a17fcd83ecb5d76eb04f74b14fef80d9a5e4e1457375ba8aec3126a1f1364df9076024711920014c31061eaf1204930407e648491bcddabd66c3a832f90c97b5372b8e9e75ef42ed070dfc1af3e57becd8de330a018b97dfd1390ef980d8435a56ed6cac31248761d00594fcaba95e7b5c2b10a2418cf5a672d2bc64cc80b44767f68249a3eed3c9876b6d45e8700a32cb0a3ca2fe94d9601d3ea11803b7bbc31ee843e9ca94d9ae9454cabbb986ac26f53c4cbf92a1b5a7083740d8c1508030af801522e1201f91de28c491292ad3daab6ed8e32674e8c007430bfe151e8bb23b8b27b9eed257d210900d00eb2b7827301a25bb7edadef50a02cb71de1cd827bb7aa6b2dae1f66323b604b25bde9f5dda81e03dea0c9e11bd0cc2083b4e2c42d82b07e7154f1d9c64647bdbdbbb45ed90b92461302541e93dedcaa828ad93677490adf33400dcf2e47a881aba92b8d27a65fcbfbc5f4beae28cc13f49670445337bb1d16fc5754e80befff868faec7be4690af2d8cb76a69f539710829fdb1c1b3f3c21bf1654d81c652a3b3b69db64a23151c18bb990cbd4eeec38df5825058f055d94275ac2fe327cf38afbd52c91ace51ace24fa20872c0609f57658d30b08f94455cb889646daabfe2e0590347c79945199bad7a82b2864c075da16d4ec2b2d1da6214c37b10e47a97e5fb29477921f9b38a082a2d40c3eb36d3f11609780332575b3c3885d2662f072f527bd0bb6bdddf12719a1af9e5cadbfab1504b31fb9c02e61e2723d37a9d3c44e5478f56e1bc7ed216de7e9c363e33152ed2920cabf31415273e534f9df22557705d6e891c717746f0895445fcf36ca3e90e0d5fe4c853c3c0c7623d498f5d02d2e63be53b7c5e9c573995bb60ee7cf32b4c837579ee6507716f4689757f81eb8ab1dfa882fd7f330f26c5cc49689d0b9b0cd7ee85bf700aedef0c601ac3bdfbf765288ca0d59ad2541af1afcc275a344d35259a76ba2ec343efe0ea64e0c8ce5d9b43f18f50e63c6a214d3925d5e32cceaa1da910d7f7cd518261b030f0de3f794ebbb7042670866febd8fc5ea36c47030ec467550b570b33952d67b942e89ad29f576f82b85d5100a8d29d1f071b0ac73a49aefe6fb072af205b831d2a28dc07e164e55f35e8c8bae75ad68f2460fb37571427148c075b64d0c701fd5c80288bbc6d976607ae3e81d47c250ce7ba04613a210cb61810bdbc9d3aa07971c6da595e01dc4121278e2e0366b574484aee394f83518243247ebdbc045d977013af1d090eb6cce79ad020f34180fcd8442d49774993ba454d7a5dbb7a2d9dd3f965c0a6eaf09428acc9b152978c6696532121d783f42a0f11a0797cff0e627c8381ab52c936f9a763facf73505d2ed2c8fd599541a46809d95bd40c6665653d09a5f0153107b8dc0f87b570d2421ebf5dcddc95037c5e7cf420e015cb010cadf7819da02ccb477905b8b21982177c037dba8556ce8cea11fb687f45718b64ae1cc7302e962f46101e912bf86ca1a76909515a0e46afc112d8595b17c9284f3a39cb1b2080c3993de7ed27ff77d562e932c31cd71553c7ffa0e5eb64fdd6f807fc4e5f2f940d0728064a91e9cda15f10250f03e28f1b872a6da3ac4a9928a1d5d2ec7470090897aaf75507d16da8ebee66abaf4cb345c336f85b0fe4b50d548f4e70dc4d791d6303d364bbecd47797b041a0a0b2a8f328d82864d8c34a7d43353af318b4aff7aec789d67b1bf36e88fd4ce3a2a5c4d9979cea9b9edffc55a738e414b7ffcf65efd07038712e77827e858fac9f2cfb0ce0049c7f26a778eeff4cedf882888429136c8d20b7f3032b1f918736f18302e6f9eb6850636797463ef9052d0eb59ad509a9776119a8a8a3d1920d044b2fb6a6cb76d20be5c36851d33ec92ba97d0746e2e24166ee04085348fb8d57b0e0830d4878bde375d10e0c0ac40546e22711240e2eb70aa6fa7b4a8d1d918a12a80c6c1ffa01ce257115b5a91a10b4d2f9b166a229f91382d8a383d1f8b8acf1fdc363e0eeb313decd36ec706d8fbdbb37b45448513fbbd144073383ce5e2aff61ff1517269a490d4b7c327226d6f3144ecd290c7d15c2cefaef32cc62bb8f11461b43ed09c25c0d4fd376e7d775ca15ca480611fd6413718ada28f5eb7f71ccc5f3847fdd4db089c24175fd3780abc75fbd978686f79817fdc9dc3a872882d073363095803b672539afe62c3ddacdc6eda14ccb0a9f7e498d4af93c545d23ae228cb31de1305a6e02191d575553a2879d102f9594a8093804e2af4f7535064fc4760f3063ba70aeb30eaaeaec6e0b2b2f95a306bee50eeb5b79ba0592a994f7bf241f5f7bc7cd79adc1cfc422834dad6ba6db55d48dc2685e58718f939df00e832f85fb133f25e5678018906d473735905bb4986dd4657a08eb3cf308a9264797474f5bcfe35c9b6e8fb8d235f29805797c7d3fe97af45bf79f5394282b40ab8745de5f5eb6b2dd94e5eb17e5f85604ab8ac46af0f89992815f8d508d3d996b557f8d631670399b5c3a3b8e0795e0e6b1be6bbf4594f636a86b2d319cd3eacffd1376504114c54317224ba8b57104e8fbe453d65b98a2f56fa2d36c68fe4356a7fd75014af9809f5705e7a483ccc361b5ccf9f1fa30361a417372677e97281f278bccef91f5e5951fd0eece2b4f04bea1678af9ab719d9dbd680130618ced95c4a6586fed265232dc51e2a1fde299e94aa66aac7d8257526e89b82bfcacda6b0d14f508ca25e7bc33f38e1bfcdceec8bc0f5f9b30d14196802178379b846f9131201448289bcdc3b464ee0b88d014a0b1f3fa76a5b91e75b7a19c3274fe441260ded6d43b72525ff2fd385983ffb681fa3f41c8a13c012f5d0a4c4b9dbd3350a5fc293b6cbb35f4768fa390192d4198beeee443133ccc8dfffebe321e79e6a24d821de9e9f931abf4904307a43619538e66b30c9d1fb3a8f42c8da3b5d664453043c753428efe8841c4f6cf9425bd665b045e617f84dfda949139b66571006a5bb310b6e20bcffe87cfa8b635a03708517f761cf0b0b5d3e6f83d22b09a5a1b544ea55a1240e6f6be7cdcfe01b763b1d884f9a429afdd70742793a041f5eb31ebb53bd9c07d0b08285d6aa5505aa9c440a149c19503c464419b34bf915c2aa1245a813148459450836489f808c7a239f2495e9fa2f496be156900e778320cbd953cab00db16829059201a68df365150f5400a582764d6486354b8897cafba6711a09135408297b3380e53b4f296d0a5a1bf374abf035294d210b7092ec3ecfe825867f58fccf999b26f6564a58057afa41cc80e09b1e6cf0dbfed8679c436511ec651b843797a1c4e42933cb2df45fa50dfca4fcf85a03bb760b866c30557dd49997594da7b00d8ee94d557ede82f5bac62e05254f87399df8468a7d46c3b28aeae901ebb766f6ecaf0cd7cd786dabbd604083f120171d78eed0ab80107750b52a9e52f4879a69219602427f8e3454ac1c1e2f1dbbefbd2260d758c7faba1a6d9945f6d19bb1c24a948d3f1ecc503f185f213f53b8995a7d6a25b39ba15a8c68930f8f7c70a09d38dd23c2832d823536101134c7ed143879087d5d1794d04433f53dc4889d0e1391451d8a0daaa804fc6471fcbc0ce8648325f5a3de6db7f05f2358f39e24f63808bb4188e58a695ae7f4840b31cf2793fc24b03a9385cd0653df8e65ffe31056c41abae6da55e72ae251ae9aac0690b71d7464b24f82f07ed01a5720aa981ec9c715792a4521ce9ff16f61dc6cd96d247c700b344af58b1a4de0e6d12d4c4bed5b9649fac26a7571e9d98e0133399953862a80fcafc7a56c5db04679930be411e36859aa0d507c9147660924cf4bef7646cb975073626c1683b0c5f0e8daca4fd89950765344d0ef9aea744e3b07ded925a4d79635160583fe074ddda1fbf69ce329141809b8cb5b380cc6953ff350f0e3ec6af426ebc14e1267a5b74701b3e8539a6ad8350611ef5720661a3671f38f5f92edb10cd69609405c5a659f72ce49603d7652cd7ecfd927cf7589d6fdf90f7b73db487f3e5b0853cc42e87563620235329675fb93b0d07132d86cae3376ce47cfc52bf96b89ccd4bf996f55f4537efafb15465840fa0cf69c7dccca77328d68799b98314bfe8e6308de2665662530418f3744099848d761588ef6e815795de9e6db8f1e81b229a499dce39422ae84c689402c0f244cc3c9ecc85fae8e18800770e79538dd1e19b0bc100d1082cba9ff0eade8c2d666deb0e61b365b080298f3fb0365809699d78140d54ad75620eb7e7e37fce8837591a1bcd738435d70c16cc6825c69bb5ab1d1432971b577165cda162b6db0850bff6166a5d822c531accf703b32a5316142ce56ee7c3710f81f45d660d600f1a27ba915b78f27fd07a16fc0eb4f5a09cd9ee0e87350b868025a4c11726461adc2c4653e72eb96be8f543365afe188c6604c77aa411851278f266b692e5b3d6f0373e5bc6b736291ca68eb9d55cb9c09453deb9f1e25ab754b3ed48c499dc223f65c1681ab558c5fc3d07dc473683a89d2a0116ad812a15ff0d8d86143fe00561d30dec69093733c6acc57e55eb43f11f34b651bc78bf922ceb3b60909f3a6a41d2f0cdbac879a12908e530bdfe975e0eeacb2201bd87e9775ccfe75d6df17240998dd7308a0a87377178e082faf34382b59d45093f0a96896ef4a77cebbf3cfea5c241b198308495d08564a72d7957cf113106399e3b1b500c08ec589dc3f4f2e05967f6954f967638fcc6a59ec4f8a7824c4eaa1fa0f1678944bd875bbc01f4544eab00497a9a1407ddfac89fd7f1e1a341e7df872ec18b3febe9c670ee7810bf9062944ee354502ceee6534033473abeb5739d2b931b628e4605dbfe3e8b31b4aa27427013754f837b9a9b9853725238aaff36bac847a7d9bd763156a3f3eb7f990fc3dc84515c54f8d31e22c2235977a18dce89831c53cbe4fdd499d27b02788f82aca53bc3e81e2ebf5cf502c37dc9b9843fa4b309118007148861f723970e1b89775a08dba0048d2e3d709d746d7d9318bdf08e29df3a2d469bc3131e59a725c2b90d4ab5bdc57740aa8085bad118cd0c14771f40436a285746d1276bf7447307bfeb0650fb3db8fb78d979470497e3aee2ede54d66647d0c24cb3cc16b8c6e23150d68f4cca8f065aa17add92846ddc872b5b89de96b40b6212ba8a52fc2cce1f41e4e42f10ffaf9dcf69948425ff3be2e82623c7eb5794183501577f5dcd47891685649db3fa4c0986e8877cfc58b362fc9341a3e8037a0ff5bd9ecd76d681b6f81906d13f818a6a0ed58fd98b7bfb6472d996a3b22bbebf7dc1fb48fa0b6572dca5f36894736f4cede5664091708f2337472196c3a7eb7c241df553faae91d451f759f42d3dd3d959c067057f0ec776440fc8cf3116919c34791f3d195f3fc6300db27523e1d6c3b5d24b1f6416ee15397e54200bc7eda65191c2c8a7cc4047dab1f8ed6ece8bd8268f26ab877a3128cbf9b9c620d0f90986ad626ba5978b4e3cbc6d6025557b137c36a4433b141623b6d7a54162841e075dd885f82db672dec0c7cafe225ffc9a47af08c4cd860398d9f39ebe75500e34c2d7d9b7bba077a5da645f71f7ce2e52659c9f03247dec6304a56a8aef795782f7f655c68b5ddc3b53e0af741135491331b874588968099d1c706881ca57443a2634718b6488a5b733a03ffd58b7d15cfd2ace47cd7423b3f2bec7aaa7729418b7a1dedc187af2d0a13448943020b28e6240df7aff3e659a069b9736cfdbc450c958e31a6b3c3111c0042e57da36c341871ff753def866f698c50a5c7f39bb2b1d9b95ad5ab734cc9e29aa042383be0f0062a84953c61213fef18895236979784d0669858669c2cf4c12ff2cfc373fe49134d53e68b8e95b00150dadd42f7879fa541abb9e0f660c9329bdce45c23ec460f371a01da5f4dfd3bae6176b137039407b1ef4da74c4427389aa566aadcd7637cb5079de235585c4033866105cbce8e8f4f9f41388e14ea141c15eb4e4ef5e7f3a22f1fddc945d7495dac966e50964435e4b3504c0fc0f803a59b633bac34595c7bb34adf05874ed4ecb499723410ae2ab53865db1e45a8625e311555ed575191876d0e831b8bd9905d7b5a034a4a5b0c8cf68d97548aece2fb515eb807d521b30416979c09364679622979e839a780407a9550d1ff43bf8f8973b3e4abddd11eace33054be78a51c6aaefb08dad387f2f1f554b658c5dfe98deb0418ce3e4d964708a022d27dbdb52fed9783f016237abe3a17c038b73ce87eb0ac74b44503a591c7db0a7515b2fb25c8b7ed7d1ec514dd0d69142bac36a012ba050347c013080f2488427d63ab94376c12f13cc9ac59b7310417316a653d09136371a7f908288644cd111dc745e8eabbb7381905088b66166da4bfbf73cd51c5755ed3af5b6456bdc37514897baf42f2f8801eed273bf7d434b43a66b5ca040814ecfe74d7eea2cf8f6ceefdb1dbeb716cf6d5aa78c9e2b59a1c183b531c94ecf69f8d73fec70f1fc4471f81e12bad1e0e4aca3ce595d0e6a57a41bdcae65d13579580392ee83abc5cf0ce06b3f5711781cf06e7df4117e42a11688e518bcd598a4a7dff84626efe5ca9621cc56beb7d42c030c07b7052fdbda02c9991f5393204ae9030f3099edd4300fb967a483cefaca683ef6988c4277c99f17c8acd8d8b6497870dd2cb29a1362a776a55f72a18fd8b05e29fe767fecd49fe80926a5c8f3041e8029c38891dcc82fc34addafe7f230aa338688021e2a9be7b151d1877ff7c752f1cec90ea3031997818aa956924c365bfe0cf311feaf090493ab6d9f51d90e796ce3afe3859b8abc4afeb89ca9f7813e3d6918b322e74d077122c70364177206537640900ec9bca2a57ff8b742052bd6ce2d77ecad9697cb869fc0b27cc8cef6893fbe56268943c76de97956a4044b3a2f70d5f9d976fc906052927718a082eb9b4ff9e0d25c9cdd61d35eeb7bdcb872fec4f9aa08be456b140c840f63e1d7dc7c22071971ec13956883fb190c35324598d0773a6dbed60a7d0f6314edc97b32de10ccf8f8a437eb50aa03c46fc63ea4924b841efd9e7700ea30ae9b7e85f734725244affa9e334340171d2f8cf27544dc879c2ab3435dae8dbb1462f4d807836f29895a11f6deca56ccd7bf0d4d4f9ce79d0480e6db991d4edcfe22b2c0bf83dbee8d47ac566fac79cd6c44b875be2adf881aa83707e66620bb6ab98d5ffa462d38de8122bcab36c76ec40b8d204fe41b4e97820822e1c7270c59002e612ff62fd8508f3c8cd4ecabe7c61630124e3ef63db2521411e517352fd73b27594f65ab0b22404427c102ece9b01d99300f746f5ca6a957ac5af00596bcd1571c71e8155fee63e9b2df6dca354b1d9546d266fbce96a4347c1325dc7d435489b9cd88aecdfeae7df835640857c489f9359b1f7a0e65d99b160125f0975b733b7734c74570276be95aefa6b65d9f56086f7bb18f1a533440a84590bd1c902aa7e732825549b036f2ba4a7ec69b3bb30887d53f76801de77544ff87d438dcf699a9e56b999fd75aa24715d7c78d7df2310c3a654bf9a454bf538e261d1648fda7051493da4c7428d023ad0367b647df69ed35ddd22753794882be141054a0bd77ab3adde0496c8c9f91f22fc195365e72baee2e7f8469b85c9d1599df235f3b8cfb767064536bb35b397ca736d6c92bd49b475ea2e28a9f2c22143e963ce7589dc7e49c5767b5c7a50c26401c0a27d90a30ac923076066fef3ef1a5430dbfab3d8bfd45a273a674e4c9d26382b833d987bb81df43e90856bf4fe1dea0f6c9a194b22501c59db6dd8ded889fbe334638a129e0095ac909310828979b793cdd87bd9766a38b4a1bd16a3e356f118ed3d331c2b150daa3913ebf68d70e063bad2396bb196d85a40f328e92263d9735fee575f479f4757d39db69434d55ae76d8f3b96956fb6078df6c20678d7e17e8bb7feb7f228be7c984aef28e73393e534574d43436759e2f5e657af5ddd4e7862a86aa900df0854b36e8ca28d70421ed3726798f7a96b50eb6067053c2f2a6ab702d9dd32c40370ec92b8b7e1fbcd1c1b56d3d4b05a46ad2a7b6685fb4758a6c6812ecf469f23ea7fc387f1619d83f3ddec76db6056e75408e1fd682dfe8b4b692606c9e9722f4edcfe46e3c561f6e774d66b188dff55646c0fa71a93b7c04e64caba2167a66909cad62b797276ed083a85283da29b8e89abbac4fcc5e8691b73b1e3e9c590b6ce9bf53116ed5e9d26b8fe06c4a863605cc69d7d88737dde79d9134b4e4ff4f76240d9f1be308d37cc0bea496955a594dc0e02ee602ecc61edbc2d6c8d1570bb548276fb1ef39f5177e76929d0e873c1216e140612cd7e9060b49dd1b55de120b18dd0252b8fd26e00aeb11fd15caa6584d62f42760b56f0bd676bfac3a905bd503796f22c9a2bf3aa7b6fd81b7c8d39305de727d159b35080bcf6191460d008acca233e057fca71440d4db33ab8de7673d4181943fe165a25d15222c3ce47fd42084733dcdfd813a042a207bbc7b861fe81943030867591169f35b62460c57c86cad0e938d652bc681f7f759f8af9e987dfe3588d59337e0e1ee54c2ca46ce1c4731801dbe2b52ff50721ea46d74b21068241a90159982d747ce7a7b84b944801cddbdd309f470f123d401921b94d47d56b6e4dfac09a11dc1c08beddc8cc75ee8522596b7d453f13140cee4e48d4345e6834fe1d48dd9587d2b39b79ad80749fb618b1cb397d38a932fa8398987bbc04382fd22c9bed99d9d4d6130970d9375ee6461d661f3da98c375a237efda085f724c33fb726b1d84415eb99861a0a3f7ed172a66bf73861c48362d7902909067526ebf18c8cfcc9505c8b65af94a57eac9762ea8ed143fefe6a1d025f6a8c20a13ecc7619b4fcdbeaec17a7cc9fd2a82f5cdebf05ec6ca5c276a0d3bdd79ede335715ab6065db1b93cd0440138338b8f2f2960fab232eaca0b0714e7a02cd0529b5c228c958314922f0949f037cc9f8fce42405844bccc387fbcf0990bd0cc0a65e779db286ebcd22ef2b71cb29f2cef93c54fb94a04f3319ba8fb1b350e11fb82a453c3169faa1ec8c54aa09de5ad1c4e428fccb12c5d8a4c18ed7e0d419eb9e901e515725c9f53cd12ada2e514828579e7687643b3e1aada78f1d3a83d885b312300cb0b2fa4be44a6fb9feaaf6dee51df86d6b617325a305489a2c6c2b5cf7a13ab7095d5978f01d57b0cdc30065339659a8f92ab661fc3c94c11639183bdaaddc9682761402aec57fbc279b507286c0e6538383f0b4749d0612119badb39eeffc8ceace112f097e458bed7f4fc62c4161f7beedca240fe7c7545aa0b045166c7d786ba59c9db04d38b8df6b5c08bb4cb3e40a32c672d7a8af51ebf92af0cb682ce9cb129b513bbdc9a93de268f68643c28597bf4c55be163997f42fb8370383d30f3d3d5dcf610579f073a3665a061d5c7b87acf569efc512511511431f6f1b6f91985c30cc39bd89e3ec45f24b945f0c8a010a6af5f2fdcccabdf61d5a29fe07b8364fe36198c6c1465176bb771361a9c436f2acb790f95c3be4cc9556b36bfebf6f5c9e6fe13e4a6c664063b6e980396f0f7a0712c67d54dd592cf5144e10f0694c14494501daa83f25423a901d72030e32f7edba7a7171a3cf8e4a10f019a9e058075c6bbd070720fe63ec3b61aa0f9a50c00d8750b65b05d3103ca47232587c3d5f2b727a3175925245339a23c2372bda98be9d50f5a2f8c1d834b23e52d40017d81316673a66ba7a2945d4ca31f52f0b0e3f4b78bf86880bcbfd1b11a44f029182520c633ce00e9ade0de3edef32c30b35d897a34d93df199a092835c83900ed6a985ae8b8ebb20a2f6ec166bcf45e661cbcfda68acd75c0a7d7fcb93355f1df67311638ed6b9ef8703042be617e139ca76cb4c36f2b05155180f862dbf14dc8478fc97df44d858bfff3f4215f02170817433a228e6c5dba38d8820bf94bf98adb01025ba1d65885bd8e67abfdaed13773f4078a11e2e1bc532b68e15d6ff0bfa2ef7e606d74e6ca95d0f5793e02034da749f215e0719d38614b5fa13caed572ceaeec2417a62777ca898ad837de5941dc3a2af6a95ee50d58ec85b9e183b826f0c158e781049c567aaccf0a5be014821292e60328c717d514db6d29b691b3e778c53734173ff7e1de3005141e30cf661b5e80fc983402536ba90f261cbb246314d10611964efa00d3e067a253c8c6db18eb2682827423f25e968776cff3e3c735f0b6b4a18755f64a7c48cf5d84fddd303ae32f20b937480a946038768d46cb7a930cee08a95ece007e91e09ef353c286b253be413f717e598a1054d44f7a37320bb68494ee2e2a26809d52c7bca83d770e4cb46ae0df9d22e01f78a552e1d6dccd0240374155b40522e5d8ef933412746f4e99d97c2793d2c9d66330fafc2d0047b3763c1822287c4ac0a9fccd473062caffbd7a448c77afd1ad7c6077d870528fb46622a59b5484a7c375b1054879c15cb7098e6a5882c23931fae6728fb2f5732a806907349c72b873c762fdf2f09fe3f4fd915562f823cd3214aff4f42fc502d1f418260f53b0048e117e4e7087e2178f9c1e4556774fbd1dafdda2d59e77d366e8f54689955c22605f553d5723c09c3e91354a7decee1439302dd21d14fb4c652221f89c66e699a03dc4c752f2351525d96a03ab52ff58de9d2844ead2682e3f58260a5742fef9e6a4af910d173fb85541f72350aacbaf58b04852a8b21a84586732722a1d765fadd62ca098c115c77add695efdabfc18e47ec3efb5475ea5c86e5e270c1683333783202b66d855eb50d8dcff5a977a3c61cd7013d20401fbdaa42d8da2c8f6aaccf67fd064808ae8a8030b693903530976bffbfb7659d1c6c451f6ed6c46fb765f5844bf4847e7e684cacf7a43156744c84d5a5adaec1dbdc34771f2ec4ec358c3ca8570076fca8a155ff535bc2af44844133ff0ab4c5c62d59ad7940466f38e1016bb077bbe72deb0d7a4bd7222e2e628daf23fba81a99d4a7fca2e2bf7405b2bb0ba7257bfa0d3fbcb61090888a2f90c168009ede063bd0e19ed3913aa779629ac3fdde7f61756cd5ec39ccfccd38bcb135b189ae715041853ced3afcdb0ffa4cc834104bbc79adb24c20e20a93037b8c39f0d1800345d8a7a2d24787dd6e7686da9d72905437b6bea694f4f3f42c75853d411dd3d4181843fdd35f71eaae12803dd1ba8edd03fe13efe8928e86a15af3f984411a5825204bd3626f29e130b6b68e221c55f25b04916e7b9da974e087780a0c8b7498b7a5a2bca45b504024ff88166afbd464d52a750ed82dc5080f0beda20990edb06a2af8539d09fda06b50c3bf5287152fc68a39d2f0de4459d0906f968232cd72d150a11dafd45e16de8a3924552316205d12a5f62b54cf68efb046bf388208253ecce548d5f480956a7d66f5bfbbf70b24eacea0b387d223a4de8577f427679d51e49863e77119a29714577af6a2a0b73de285a3ac4d43a865b80755e292afd01c62ce0d719940f961f7fb8b61b847d7b02811029c56de2a64ccfdfbf70da09c5ebf683892bfa9d1c59eb58653dd6ac154b808da4e627572fdd10c7e651af4261e06611329444bcd2776f262160849eb3a95dd815c53e20782f3040574008b0ae7812571b0541df9d3ffa42c15faaed30e8c10b71e238a02da7e9a7dd7b2c4a89c6ee304d78b862017809caaccacfe0db0258d95f4e8c4c8c36436422f214e8c54ffe9afcd665a77d69f06ae7b52afc0c4c0595a6cd59cfc13937927364ea8f2abed3ee0a60bf98553507c9c77c58f998a4e3d30a070a563948b596085310c56f53bd22037eab97dcf3c8ae13b9f48c22b2b46468758c35b57ef7950a9df91748bd6018d1c5832eaf57b60f500f367c5607555f4eff56eaba5e49ce642fa62664efa7a980a20d74e2aaf6ddf8d430e82507d23a1d84504a09ae51110daf93c71dcd340a1a98bf69b1ec23d827e10d830382a202a734b3b8b564477b054122f4a33e9b36f38df396c5aebc237887f92ee03542bf08976973a307d6530672591cfda5efb6c0f25de575eb775061b78da96fe08eb4a0f424a52d7c3db97d707dfece35697748ccc08878e6e4da2be34873eac14b3ba90005a7e9bed422914d09da3886a9c4cfc88d4023f912e43a32194cbe8dc3b413fc83c3432c43bc1e501a418b285d8a992ac1a549a2747b108dbd1342f328d8cf6da92bd7aed0ef5183fddf61c83cdff038f84c55562bf8c73b15704c26b07c2d140ca1ae46a91b7b7e69884ea3ae85a2b118692783c05f5f91968ab8a0b29d356618cc9a8c95702b50f2b9542e61b8ec3de8adabc29731bec3b1cc978886d4ad873a3548922a51e611b3dbf7bcdd2ea4b1ba9faea2105ad1b1b72efe37f8b4cf7c4a9b167b143eb942b0809c7b8ee27f61e3ff6996ec21f3bf12d757c178bb70dbacaf2d8a67d6ccd950ab22e2cef6e2d5725ec8d02100acb1f1cda960096d6bf4320f2952ba9a3bb1137d534b2d61cfb113717afa0f0254a09055f8012148c1b246d39efc75886a90b0d0736a97b212d4634799709cc5900cf61425093c2fee1343f318a43ca10bf9f0258f336d5042067e0790097a932d6e55258e8d325c81c21b04103888c27132d6d30fdb6772c37cb28ac4ceb877f0a4950f97f50f178b99139187b1b73e6778708afa2e560fb446a76319f603dc991910ef934164b36b0de09d674c3e9898d0a07ec76401dc8dc8309a6b1c60358579c36c033ccf9c71f00c42ddf52b57cb469a2060e214cc224e86fe8e8ecc8fef543536ec71b42520440199328f6c24727a0bfc12b0405b8eba4f9e7b10b9f56acbfbf528e7f87cb4f6ede259be91fd1d45303c66fbe2140102c465e4f9ac79813db299c0ecbac48f04c03397b18bb1b5077e5697ce973a7ba362f2af318fe029aa9b341a8d8d50d2f60c9c2167cea0db0397a2efc0bc050717f29378d29df11d77739bb30deb5e42ff7d06848afe601f148613602ab3d07ee32147e2ded04a50d9738b16ef4b11aef24619f12469396e40ba94ee6f317647a8c63a4767945568e842e6f0db14b16e1cf29f68f3eb007de0c8df12a1dd377ab681b64be9716b5094f2e47d925ef8b41138fd62639387edb15fcfcc72d0c735f7ca8007cb467d9e42a2a8b0fc9af872d1ffeafca464a1476c58c56dfd90b389af5646d541bea3ec243b1bc3f63c23e78ce747a419a5c085ab2ca1eae298962d93ce46ff4031f6ae6eb8e6603722d53a734926f390312269fa6aa1e4f1974a0c57ea8fcc66a144e6e1ae49845b639c65d98010571ab255226eb05dd27e35788ee3da166bc0b93c00b84d64e5ee3d3fcb7c6597154255e6e1d431dfd60eb8105cb5ce4ae6aad73c21509d62e41ec28887615e1b11e17752cdd3a537c88ebc0fff4db780967e51c16c7e3cebf57da27708fcc174109fc59b0a8e9babd6075ad1ddf7c4120832b033ad3e275b36f99b059bd6660eab3ce475444cf63e45693db26706da52e66341b418a0bb731479268dfbaf056e18eb35a15c710bd36a958144994ce44b65679910d0f1d6e6329de3dfa529eff8711fb487982e5c6501003da2c0352b61d907ea6f1e7101261658d0848256138cb8ef17e8cb56fadafb674df170718bde09e25f47a16ac84f6a9c7148dad2b952586aad36d961483d455b4d2cd84c226e66da789241a9f488e4fdf0ae2abab1a28033444397bc846dd1ca1796ec292855324c551c4b684c546396efe760d4c7ca97835e633dfe5521e478f18100f2edc74ef9585768ba60748f923f60556dc6c965d1a8ff26dfee24b76482595cf2db4482d7fc65e4b9100b3840b2c550efbf3b8ada9179e3e8ec237527c4bd48ec945df1ca93c64ad0dfe8a5ac99614cb7743aba420b8a5072f5e7f0edad1dc4aec0eb31de7fc9161f488b23f3341aeed1970924663b6fa84cf278b7310058c127859c2bcb8f4f24602bd727ecfa0c2d2256a62eed44eef0da7d5b8df0c2a01a73b6f9b1ed24ab7ae94c18044fd3390e377f23084c21337b03d22f17a6d9674810b17fb6d3f7de95add8d04305d9239918a5183e0d505b1f3574074fa1d21b41b4ab10ded868b58013d6b547dddd943d9e7ab2161412917ccb9247fbcaaf07bba80b1a0c480ac38893521b304c57afd9efb5e86894e5eabf70805b5540f4387965794beb929b436801c8f51e6dbaa4ed2403f3a956313902b6b0b443f06ec6aff908525cef036a9dcd7466d9bbd976b318ff5cc7ad97db19a9266c546948ec4ebb01aa58bff3d0f7355382c7a8fe9ca75d3eacfd46e1be0322b5f60868f91754c9447290e6341b5bd80a6ce0cfeefdd387845f32cb5ce67fd26bf1de0361fef06f66f18b7fd7ab86bcec3b7bb854942e497235a964802f338193592eecdb450dbe9ef47ccc579e8012c83dea595e599088a575cfa466122c1d1883fba5799dfaee1d49031db021ad55f163d9d998d550e615a711c7c5aabbe6ac8ae6b153944d121bf325d3ee9d1237542cec3bd2a428c0fcf124398269aba90018","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
