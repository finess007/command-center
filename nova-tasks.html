<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7aec0b6f80749412bd8163c2913a72fc44886f8580d83a6af5256b71c16d879518d53af571b0db3b4ee1a12f6777376c9b85426541f3127cfb6133339a584164d9261ffeed61e3e3a43be44ef567f4fe5ebae84c0423d5acd61b1ae8488acf884cf583d2d58a7a6bd3720d7b80a209de59113e0c30c91a66f56020bb352d2ea6a5188bba34f37eb115cc630237bd6eb8c788d3c48771c06991d8700b3290ec17e41c51e60b724b32f4bfc05e399417343eda7eb8a2252e350eeb315f3552bcd838ef14263ca8952539febd0b51449985e9f1ec7eef756a8b907f86525fd103c339fa77d035120eba53083972cdc513bae5b7438f32ebc4434be19c89b996c5c1cd4fa540d6ad81822a35daab38416752122ec992517484e10ba57e3e13b1af4fe0d179666b0f2b701496db5efb02f16ffd6a541f3e648c788929414ab88dbd7c7faacc829989f0f90b75fa3ab1bed948f263788c6fb91a09fff243161797aa4b3345f69e467d90e6390212c42aca450362681b5873ac29141b4798e1125f6f5c280d427a1e45d3785e4342ae7bebe7e13d0b5918269634266082ac9bbaf8c92fc4c293f534c327cd89b1ef8d65bac57b9b32e21c6995d30516b1dbb7332ca5d687748f1e4843e009bdefc60db9752b9587de411ac490327a39334e5430471b92fea0041b4961d285469c65179615a76244d240240694facf1e09bf0df12ae1d55dd483b2fc60d4af5147e0c99ef8b9d701bc995fa71ecca83939d2f085feaed29b467cfeabb77bebf2ef3aaccd60fc048a56f87f7562ecd15219bfcbe8131d8fdc5a7f62de270fe981d39eb33ac8b8d84bcb9f9f9806e410bbec1339468c102880ef1f39866b93a071a0b57e5d6d9428e61787f35ec55da951fca76ae0001ea264d7a213aadb945a0f4580529e14df88aa19a662c3caa966c8eedbacfa2ac1caa238f3ebd9f34b4eb79d9107fb2a3da88fdaf3b15edbac3510004ddf0f797e209a146f1563412abf407a892fa8e2a8fcfc7ecff82e23f5af9cbcb13ce06726768d31b6f3cb68576d0f64fe5f7b6575a31f5ca1f18d0d233fa9337832a6be9d4148fa4d3a896423739ee5353335b2d2975efe657fb1282de92cc765c24ecc5475b7203ee7d4c78cf98266159ac74eef29046cd6ff591bc7a329650ff4481e58e84c265a97b4089f60dacd312f45d754a236fea95256523a4a7dcac070f8fd49827e5b5e23350711878551c97cda39a415ab909367f1929259905b31d95b73acaa5667ca80c84b21734bf74ab2e77ffbc59c4e795a8e0b2348fef7c8b41661d445e1377d0ca3c82d4d5a3cc7bcca52bd649df867d3edbcaec0e3d7f4ec6d205a2e0fa4c4fffd378e76a35f28d2c5dd80d2669a69bef7531582b935446b4e49a199d3ddeb16f2a422b520047d733f3d940e55de069c7788f3434fa4ea0927acfbc069797ea3e4a24a5e6fcaf72c9a4edd5c30756f4d987efddf07ac9dbfa9c2015c63823bf9855c3aa895b723fe627ed8c278478e1d4c034ece529e4b46cf8132288af84d23e3e3711bf96fd449b817f086ec88a2a9ceb50ec9582ca66974d904bbd41e8503f994124be070d9c94a8b562fa111968c3e6fb6cd0838da46c19d3ef9cc33071103a366cb1d1393b9f1b0e739314f395b05b296d7421cad5746049518801622992b8964324b4cf5240b843bd4302e5906181e93d087ecf3b299c74e7f5d753a5a96b1b1208073874fb3ce4f2882723f5c1b2b9c31ad8d780e2a9b37d57822126369b1464bc562459211c78c1a44a2a9c008aef3a5636c1135fb0bf36d4c1ac2c93538630f370701331983a2a322f29a083b95b1dea36c3051c51252d67642cd9336cf883c8679702a4170d3225293117dca565a44ce2ee604782fd07a0d9958d81de53e4f57b8e3ae2e069d19fe5d64dbb603dd170a3e7c3c5fab610bcbcdcab0b3e2327f6d16cbb5cf13f3606ed09504ef629049976ccc80b9b488c1caf0e80f6e7ef1d444ab9fbbaeef9a0de3d2e7671d30c7ec903bca68e7c1fcbb897a1e29d62b3221a5362e7b0bb038a3aeb4454fe8fbc5b45da6736732ad860211ee0e672bae229d63497212327b15e83283f56370cdcc9b3a7acb41b649b29d181aad60824de8eaec3ca302b2ec81c3132987358c0b30dc22da1547cf9f2758d77ae16bba018f669073ea498f2e7a2041e65d3a28400928bc01083246da43f564006a4249d1c947332db83e2ce4eb43bed194805c6fb9b836b03203d011099ee2d662e50beb98095aa099cd2cf484463b1c266b69420289d031d0071a7d722de95d70edce239d43300f8a570906a4697d23c06de9d7dc6ed77c1b56dd25df9fb428ceb843e0f68a7cb7df6839542f4bc6499a532c7a3552d17f117e56c21730e64fd3ddf43874436645182eca5b28d4ffe21fd3977cdc02d12c6bf98ab8bab8d12f6587ba9b6019fa09d00c7959b959a291cfb7210ef481bce8890915a89dbd0984807cae4ef86236bfcadfefe7b20de47867a22bbe557c63c46808aaa64ce6ea13a6bbc1dec5377e96176227ab02c2a922be793941b533930605e3e4495c563437b703e4f42209cabaa3fe9d405078928955d3077021f88ef659ccbaae0f11c026045a2e4ebebdf60d14bb33726b0fafd225d5e03006105313036600bc078e7dfcfb2543de98b08bb6be7ad97a08f793b73d447288909d90bfcbcc0b953079728674443cd5eb58a5a66d211dcb63e198c470b74b929b573915a0b3bcf60c030560132b1616d9b0cced7ebd58ba4460a6323dbea608ea6255e84a51a836321824092281a235fc24d06d888cbecbd05170e9aad19ab6d4e7e3cfebd96a73a62f288e707619f5528f57295d848a0e5648ef9efd441a9e4c11e7da0e92818c0027c883f7dcfe1f5b14ca4c0bba8a05f9f4a85146711493687310214a2691dd7a6115c30f860bd3a2bc51754bb43b342266591b214f56abb9835b04e4d99780630a9f810b8c43051506efed8ce0842522861b3aa0e677040528800b63c9854c6f038a9d6fb25a5167a0a5d3b922b6f14d791bbe2b01b6fc32c27864ff9e3beb64299969ce39be8e039be93785b7d3232635a2524751f289f061e7a7f2bb3b1342ba22f072f213492eac17ab4ea40875e4dd4762050067f792956cad5a6c3296eda16a0c3a7a18c761e218b3bba389dd37836af50b580218451865680ebf4ce84cc777f10738eafe75da4e456d2a037a7c19450770215ce70e70d1d786bf0bf094e4c7f90d6fa6b3e5e31734ebf6c4e34d208cbe044a90ccf3044bf91fe3531332f219a47e0085e340a9e712a61c4a6f90a915467162de96e9230ac7cc1fad83658ee31316d703c8aa7050c78360ecc1ffbe134e154c1f49164a809e16a48a679ed16ca37cc51e77ec70797568f6424069e307f32f60ba71716a971547d2ccacfbcf6437bedf942d69610f95aea76265c511000db1a0fa002f8ee6d27f3b416ccac744e580d7a8892916b8de27cf509728331a60cdc6d25400a22053722d4b1673dc9248a5e08f7ae17eccd44df64c62e13fd6daa38ef2523f6c3da34d55ff071780c3433bd69d45d6bb82ec598745b00d26f0ef634c1ac2b27497c0823d21dcea84d69a991a047df3726137ed93688ed2abacc3e1c7989acfc3a8186ef47d83f87bc5e54f54988dd6aeddb09891518b2dea4585e9e2e69f05f7347127de8e63ae833fa51dd9c8a420c424d6065a3c7cadc423f4f4c8723961a51f43be6d96dc061c5f27197261ca58a3c046c1033bc53296100f6bce1ad8a3c90906db7868f162e1ec5627de2c7771bfdd0437fa3149290648c05a7e535e8bd463ccd6f5a9623d0a274105ffe0eb49a9b97c464f54676a573fce739ad4eb6d9281b2334e5acb95e351e96cb2e8e27d19869a02d9d74ae18e14bbe60aed94cefb6b00d6cc0066dc4717cf6dfa80559a89e728d6e8f0009be986261c32eb1e5f2f98ae3446671d27274b89267cae4be6bd183bc80334cd3579d5a8be0613a270baf6f85e3e2850798ecb5f06a5578c532c364715fe4c817b33bfe532b8462b4f78f5e11ae0a889ea02d4d1ddb9ba21795520579f82b63d861b7d45dae8a562d2fff8f8e7de9748075bada1f9b41a0c09a6b89f0c259e8f3143b4a01cdae9a447c2de573caddc4c64b0b36adbb6fedd6fe06e0231dd6bfac1250f9ccbae1e95a659eeaf7e354364a6fb273871dc69de7eefdc598431b8cb5de16ee11d49da83600bbdccf5dd1103d7e65ff08459228b64dfb4ffbc5749556474d62a775685b5f096d5dbac492afa17c322eb2fd42fc5fc2c46c9c0c6db7792b42ea2c8383c03eae403918358b2f3bfd8e93ba066dc5577d29a9ea47280924cf6854bf039e96c8f0c3ba0a6c4ab30d133f62995e5379790215971e8791e0773b1d91ffae4a5e7f056dcf0732d973f8d3676eea42e5101af975cb0889ba83bde081bf41e089972ae6e500d7bef2dca3cc9d22eaf71aa989b10baa3636e90df49c8b68496979ba5c589073c78d235f0dd6fb47cf46cf5b8de81a032b2f21d1ca61282770890966667d1bfc4d1c6f8646996b0205d034d9990fa17e20c4f39112510bf2403f12e241fa4ae5fefa2ace9336368808b214eaac852707cfa351d56b936d5d3f1940eebe16e5c2d50daca99d28ee7620fe338922901dc5b9939166eff59b0fb6a330d60e82b613643c6a98cae4bd282771f6bc3ab1549ed4637812e5ac8040bf7cd8936b7cd191cef88f22f5acacf1e246add213bfabf582b78f457dd7be831fef1d52aa18c92f7c43fd1c83fff7994f115842be6888a3a2209f9347c04995f107c8414cc3aab95893778c28a5728929a60f62fa8793ca73831d4dc528e6954a71dee26f10bcd8cff6cdfed080563de790ad8e6b5eebbd4382ac22a626a05d12ebec947167ccb272ebf40e85c4a5e4c72518c0cf672e77d440a3821e86546bc50ae5d4a3b1d6b715e1b7577d41bcd95ebf2c3cca2cc26d8fe8c483f50adb93708f3c91176b377ea98d64162a707e0b0e4ae600badff6b55844f7346719be05aeec4a8019a3a68d54e02ec67e254e78b469ea47ad55890d3e9bb45c690d4872923b33d26b352b6963b0c0071c5252dbb4115ea267d67e0ac92e212b283791aa8dfb764b4e3d5d4b8c7cf1066e80dcb1264dd0f36002f30b38f08f97ea4548a2492c9297adfd677959d2881cd6a1e777ebc1ce66a1c7c1b30514e82e7ee0c4e2b3b3fede59383be0f7b84ea5fc2937e08c863de31bbc5ae012dffb92ad628b70271c941cac5bb94c2597b948ebf0fcdf0488a7b80e157f4cda4232b6bfde687bbb4e89f5565674ac40dc652d65b975491c3af43e6370385caf2fbb05c83e02794b3fd1790b6a0d7bd3ea3900ac40a99c5082c3f7eb35f32d0e7765531d97da49d13aba4d8968dd687b3c04ee15f7fc62325fbdf01f805c3b59c2e484c6497b0ad00c31b25dfb700828e65f3384aa85f1462c383aadfa007961c5e6802de231fbcf8400ee1e56f1d5eadcedc5751fad6b6965fb86e4015a7bf25a1e4c6cd9bbfb6f65b9ef41e04c6d240454beea596a355f93e40214b38e956b7b2fa9a6da5efba25c300d5fd7431a7bfc602fccaa8680a4eeceedce83d82d2039407f0c3a2df049de656c5dbcf6b6e110e4a932e78fa2dd890f2531b47cd2142829ffb7f5e9e8867eefcdb48f9bc7e99b4f762f3bc8f893c2f5cb7db6ba072117340cfdc00be0529cd901e93ee9b51c01dc074800201d12456cbb11c8fecc0802731e829094fda9086ff2d8444ec2c15986dae6431e10a19621ddee3407c092c3f6f5e43ad7af9388b63d4c121f71a2b8ffa77440f66b65aaca15dd072097261c49e4c244234a99aeaf65edf5f52d52c9feae6bc6ccc101d2d9f277175f81a65a37d586aaa1057cca5b3a4a6dfffe0ccd65d858d9fa35e85bf163b8a9b8d1d646baa41149d69eefb0c8f02706074926662775c20230ba602e5532111e7577bafdf88b697dcb8bbb7e57b0bb8a993b49b5f6c1137a5f46dee882599be7a24ad483371257b922e8cb3dec99f8d8972cac39755a6565a69875af5aaeb662b83b540f33e562cc08e3f9fc10597296839821ff8125f48d2d41f715603c72cc3d9a83a5bfe93f80070aff83c75317e1a2f0bc091dc2834171afa15081a1479b5b40986e660c8446317938ec927c1e6e30b8290323a07990e5cacf873c419fb8a122b3209154d55af425cf2991585bec6cd4b1c99e6adfe1bbb6f69e8e3f78500d1a2fdec30720b5d0198ae7c84d8509d7a591885e7d5fc298880b7f694723cb8775ea18a204b11e3e6918d0c04c518c07a34bad911f8453204102aa0becb1d4a64f21e081f451a09fcb7a27f91051294667f0514dc53f323b4736c68e714dadfe95c4084da65d27d417df122fadb545308984023b84d972bd1860518c309320f1422f993bf1a0978020d98e4e343d41da537a95c7088ff478df8d8c7b1bbbf093f8ddf0cbd41bd1881e0444f8bd18f9d3abf44e932da2a05a7aec9c1a3a9283a464658063754465c5c45b23d5fd4a38d9d5dc36f7479133595f4efc1677120eef41cee4af14a4e45fe99482c96580312f0f2e3ac7adad58e8c311e347853cbf40fb37317a5a18da4862ecb57b44730204e1ba8e95b2c23d0c64e07a124cfb31bb7c2cb0038bf33641d1efd3a15b6d0742d6430c34c3e3694f8f186d379f556d6524223a7aa55de57b690a08b89bcb1abce9371cedff1ebae550403e5da950bdc5857710c4e5a19545a4561ceb3e005188ea4539666b27a65ed56e8b1b6eae2b8f60d199705978df633a317a0a321ca2f01bc5ff40bad6aab07f52cadb0c424a4afe807a60893cd26df07715dd145fd9efe46bbd3ce3df378b73ac3ce22d5acf657767ee27c562e8c61a4f38d14154d7d8d11f284d9e7440b7fc7f2127acf63283b2d7392bdf5e533eaf701b127d8e322c3962be9e0bdef41413ffe59cc5cc02e9bb0fcc2395f6507e8ef25145f8eb1d230054742c4836ccc0e6e36895dc4e88f97808b37e00cda49fcd9570327db991ab1650ed07e234747c4f08f10988e5a8ce9c2f64bfa72d8408e089dd71b0e267d814f74a5d5844daa9fe5e131a79f3761f9a94484acde8ae1d74f7751007f5e4f7ee11421ad9a53d14d4049e4b77add5f0a124a78884007d89d1e6df8642888f4154b3db27d493dbcdb948e51a4b33e64cf06bf8bd165f3f270006b425ce28c7b472e494ebe0877d1a7427fa813cc7754090e859f0662188737df4173bb4d68e09ad1c2df30141b44352c8b018d1dd31fb2b9a240353560bec3b7d930f36f85ba14641cd214096ba4ef99e0f7d862fcb002db1c563bd2975b7dcb991b8d8e486f7edf308bb2186ed431e5fd4ccabaef9d4f3fabaf17bb899242fcd53d17c01201808cf7b6bb513f414bb88d871232710d45e78efdea829380d43b0474ebbcb7220ac43bdf08cb15a213f8500aa3d699717bc18840bad8d027549ef4e20806224f52bb7ba7a018103e711c516307f397835e1f5ca74e9eaed63bbdd7d69b5182962c0d8e6e2f0263198664e8626e0691a92119af2e4beabe7c006f6f0ca19d40b1038540fe525de4fc36eb7fbad63d88feeb81fa3e7468e9b957ab7ff21a4f3955b9106fc1217c8dbe5cc716311d192c03d0248c7c8a62d4a3103fa95dbcef0eaff0e483823bbce2e275ccd90e0024ac3e9f723df46392b02c107e634163567114c3426d90b8e472f9cd2bf629ae96004aa4e66111d8aa719d0fd6cfe82e6694f272e4dc58d45be871e0b432afc06e4ebd32aa9dbab76a50d1bfe93f4f76bd00d858ab7d0b7667c2cba86cc0ee689e1ffcd1a1b9b40d464ca58c01a7ac9ca0fcf3bfaf4e411b7a91b13ce46853d027592cffbe1589edf7800b44000243e7d6f58fa00a363bd1cd85eb0145f0d7e0ee6f34eee30b4fd184f90e4d18dd7b26245c41d4ae50ba0bf5f272ddcfe43a7a0ba5c81a7de5090e01efcff95b93d47436891af0ac733767a05bc6d8a6e0d00657e075ef92d4715c74e1420bd62f1e2268551a388802332ba49e7dc87b962afe14b4655684984187cdeebd9c6e3386bc522858af89d3c7c284a50b83285521589fca638a07f37b3a062ca31bfaef2a0f565724099aeb3e896863125a6a356d4c1ea0c0a4a6ec7dbcfcfa15b9bed211e847e33885900a0bd9b91ab61f5173dcedba2ec44a9b3e8fcfb60c7ccbc94de8f2af0a9069aeb86a9befb92bbb13edd99e63631b865bac16488db4a2175de5d8f369ae960c2508b82295e5b93f0de25e47345b7ad74840d1268fcf3986e8ca85501ecf338979450841a5eed4fa6d89c1b2fb2c616151f1cdf2e31bf50143b050aa441efd9c60b58ee5c2bf3b8eda82c406f55779296415172e0dd4e6a40d464fc2c0ff15eb786c2d3c9ddc6b4664aa8ee75db91be3a45aa74dffee8871f5e91535bab41a2731becce49a7b02d123e8d2ef91967550a88ffdb0c0fbeffa54d1da6cb4d4e2a1755b90366b79329d17fc3764f94e0ad10803cb7c79c0776d3c0328bf6e03e0ad020c8d23b7447b101ed652b6aa6359e261eb9cb92f5929dc137c38732a2bdc525e5c9ca3253897599a6cb7e6d1e1199d67ac7bae4ea34da35b37e9e6aab3afe61d5b170acacb1808720f79102f4b48852d100b5e771e061a3fa85dd855bf5356a0c18a3a0bb1d12f72c2fdb60d6eb0d34a051c49ae9ac7cea9adf8d49226fd8129e1c1eaa9fa14b68481b8f39235d85377e58d873d3ad83da8fb29b7c272c24fb545ab64cbba17eec3dfa5e719f523c3287cfb1543af4c792d4df81b8c17f282845c1af789c361cdec253cfc07fbe3dcf130003cc3752f4ae5bbbe4c8a213fc60a4f488d29b9ecba4a0feb039a2208ae97725247572aec6ac8a8dd4d50065cff0dabc1587a7443ff2812092f6addd08d817219c47a5056a2eb657da444f9424f07ed0c9492628544801a5ff8096b3d1d332fcf2985ff3b959c92cc2c726f8d59601723a79ab66d94bfe9398b3658e9f8ecea07eff9a6138a63444a988ba70d19eb2502b36b97a5d59c5f605bbb59141bb5ab9cd00b640f81897c9aafd489d3ca2a310791e2d4d9d51446e08306d2e4e988cb6602cd9a27ed87790924b42b815a12ab654014683b110ad1f81a8f8290dbeb4b81e5332c012916bfe1871c8ed198193579cefdbc5760ae2fe1365014269aed6ab5b9559769bbb2ced8ee70d21924ddf3b0267f23edc31bece03cb99035632134c7913b1733f3b6b636ce3132e165f7c890e1e9029842eb3c37b4a7959c84d81a453efde17516372f08f6f32fb849a73b4b5397a1ffb00058ddbbbce541b34455092c3b09a5113e82e013e150956c129a32f550ae5a713f5c3e77336e294f274065ce3c95f52f30355dc9dac7478788a41d4557134373c4d1c66d1fffe11cd95f8e0250c19efc7dc85143698edb71638af7622b10f1fbd1749277769642bc73b48672afdc441dbeeb465edab98834a51ac7bfd4e4bddd7eac0e1af2e3dbf488e58d459c8b3bd9fa289e114c3afedffdf16dba404eaa855a90ef46c032346a7159f00692bb05013b83ca0455b0c038a24d91551aa41479f776025c7832d51bfd9baf4d619071d4a97fc8fe5f73cdb668e6f9382896d5976c01fe17cc842cc13c66fbb6234d37f9e95aa928ec131c5f76de888065cd1edaa3d20616f5b7cc5fa640848b5a965ab9d38da942d7419b044ce5a17869316d7d0dd9cc6758bc9c2efaaef4bf770e01443c122d53c3c98ff850f180d4c09764703d567ac0fb2770d4023016c427809839ec489641a2724e5cee92da62555b4dfe7be5f262a4f8b2d914027a88a0cfd7f7f7f84720a61b1e891876371efe010c80570edbbe30685c192bbbaad6e96aa04ef4d1071e42d3fb2f1bd35a936dc730f7a6f47c0458ef9cfe7166c495008979f84548f3b1883a1bc650646fb0e2137a12578d4cbfe5d236d520f2c7e94519fd2033ef6e8c62685d8b58d9e3a158ab34ee7dd812c75dbe2131ee95b0079803121f7c06d1675a2d4fb4fa470fe5395db5afd3122efbbd0fd25b02218e90f25eef28d5a0bfac31aa2f111751da50f9b5fac15f923325aa35cfa94f74fd5b8208324452085de05a461b50f49a74c9029cc0e4c5c6868f693a1e7d8500f42310a1eb6d5e891bce7dbfe6ef203891c54318e63d711d8ced5019c7e5bb12c7dcbb83e67b608ad0f9cd99350196ad0daa1515188927efe5d4cce42791aab4d9cd8b9afc34cc10b7b8b8a9d0ee6c807443697c53fc5c8524ec591b14ddf0c85c9a591fcf03c7f449a3391c59af4c8c9b1165eb63ee69ac9088fb282e3d49ff01c843e06005f42ec136fc71d3a034fa840ebb0e22589d2c34b6dc99d0fe90cb2c9a9a72a3ba2c648dece25053577875e855840a0ed9670a8e5de90ed020d831fef62592f97fe5b199fcee5033317fa7178102b051a203595e09b0fd703a8462cba8084039da727b2597bd19e4514e71c2b7e8a3636fc682d26aa74c85540209730c1266f0059586e1cf576192b31dd8e8779f36652e81f187a8b582d67983583ddb8e1a0c2dc7fcaec722e6b7f38c48542b2d914840751917499acdb830ec6f7be64908030e1fd88b6ebc72f5f83b8daa7c490ba2ed55e048a64fe6db573c1652ca120915e732d31bb006f00aa28222cd8fb793367aca2205d9ebbb60e57a2591df9738d3e90905009a3c340e3ace73d082ca50ffe979ce8c4a22bc950e6e8d3c5eb3e0e75fbf7616854834bf26acaa942cb05744a10ab22fc8e4e78c3575bcd85c373e49dc1bed7556d30c13e50265cb45bd84be38f0aedaffc314ea7dcc26e215209ac7ee5b42dc2bae58f31e1eabb2c1c0be2fc71337fea3acc3216ec393991716213e123eab27b2de1c55a9d635ec75dfc0ee40d2a0b5dbf8de19ffe916ee0fd1e1335120e397df8e56a1e7f4d5b9db13b75031f8fc35e3cc24177826baafa7c27588d97819d2097e395037af6054e608cf834985765c7d6a908152d3f538935fe6fefb49a616f616c6c0e78af6909087cbb819341bfbb1b9e6201f96735631fc43b3a654b0f71419f4e2935033ea84ef894e2df279ff9e9d4cdb3b1731b8e42b07298185963ab6292b9727f0ea3c4ecd19a852a704fbc68b3e9093ba45932f5e8ac788e3b3196ee1fe658d1764cb7669cf71f5a92a038a23db20cd24bd4af9d53d0b23407a058d156a7c73475c0402830b11b32fcedefe7b3beab0d7946c38e69db64885c539f0c4e40555e5bc9f28c6612dbbe49d33ba91ed8dd6c4ed235edc0da4f815a6f3000cbb73e01b594441c78f263135d57b87b4dd43a538c1d5444c778e36b746326da0b1b7618bee741f7cb5363ed81aa7cab8ec9cce23c524e98223b13c0b6859f5f8b53ddc9ae039f02173985c261ac7719cf07c0887099da9abef5435a5a0a2a7001c24cc5676d4a103c94d2590787bf216ce3e417392eba5d6cce88dee8dab43c4a33979ca21713c766c2b3d54ff7b4456f0ff55218fa97b2ce98cc515e943c51e1a594b9c01f8b0fd12bfad967b303e58aa6ac0dac5c5d2fc32b317c0ef7b61cfdf216a0e9e91003c0827dbb8363461c57e358f4a3ce5bfd8a41e1760f60c785f618744e8e1b9789d3261b4d4f551c2bd8bc5e6c517cbef690db6ecdf535d4fbb3ed963b1b6e2a19a3a5a1ec65e4b3b2ee28f935489d077e0089e4d578ae4004957db2c5096c4fd4554e55ae1d5b254eecd1893936764f804f3ae845a61b37646c357ccac8c66aff0cf0b011a10c0436fa716613754f8344fa8db746663822aae8bd43660d8f0067eb8b85ead1f8cc6e253f862a84519950a2470977e8c03ed9f7dad16bb08df8036f41ab02364e2a5f992efe0030719e867856300e29c5142d406a3db8b6685b030d215159fa4403a841946cc8c5735e61cf978b4c113cfde6751e0e087aa7755a3d82f4714c98f397b7713e4c2e8f9c25a74da5d13d3813a09f6bdf248aeb0100da444616bcebde6ac9d60d0cd126b94b1be7837ac3ba8f1ed26ae23bae6badd1f2690d35f70879835732237d495cb5c90aa84e53799a6979ee93c23af9ad1522e1b98f12abc69d6903bc23fac740a3a4657c48f7c114a9b95435b1603f96e01eac71fe5c0b44e2b58839818de90b68030c7de54c3e518c537192a422dd0278c4ac15b1e0c5174d32e9eb55e07a83ab9a365ec8a3ed1062265f0faa4dccadc6bc2ba3a0df1ddb85b19922e1674bccfbb0eef4ef9d093c5fe3d501603d27efed075053a2685c249fee5334689429db6503106a5a555dad48d16160eb6c13cb0de676830e1152edbaeee1e9c51bfb398c66d25a60690bac589b5bdba742ff304bef26729cd24a8051b6484617ff99b76a63bb331a6dcb74f0977e71b4b552d7e138ee1c6c3f18f9ff13c33dcdde17587b6169daab5820c82c7b8ed56156e0dcabc96bf97472bd43d0ef52417a3489175427b77c6fbc82b498d03b2aa946f8f39e41c91cd36bbd717ab08524c2266c04137f4ccc87e5f9a305224f1cdf9b1fe4693a24f37f7567c513a2edb6fab4513bc5f8c870d726ab523f17470d6b6abfd7521081d6a9c4215d7017b72c4db49a00d9bd54b07bea966eb6fc17a0ae18b19b7efd679319c5098605352692f113a7304bef0fd0787e9a3d8efafad1aad5f02f4793cc16c927025b02dcea7a8102d259798ab5ea66911903ace352e3ed699005759ab49df06131aca14bbe8f413e52176ca71b7485f29fe2aee7d08b783bc336452e129a5af04dcca8b2cac4583ee5baaccb2023a5c5f3925dd27c42c145f99feed1f097caa30f211332b0eb819739cd7a02172ded866667eeb610d2b5e417b1b07ac0448eaa177db10d4355bc919cb35851b4df8a9fed1c5a96a2d2aaed393b8b2017cece975b236e830e0e71592afe9169447361d3780afaa351ae9b960310d90cd23dde764d17a5c4f0bf5182160f0c0c71f9c1445d02e91fe7f9b7bc6a31709d6947a6595afe9be32ca1c77e70c13bcbb070e52d18e78880ffc6881ac3ae42dc98311627ca976d88a512236dcda6cb293d9cb1cf55e3c6d801bbed846616badd44a99607a1652a8a1179ef28813876ae42ac2194ca52abefde93ad3604e1c3ba22999abdc855d7f77e1e45e6763c84f2f68e31b0e7ad6f9fddb4533de86c1b9d2a49ba6ebd027c8fc1f107b056e6da583cff819aed98c355fa64f74d91152f2cc55f65207f94376c70978f2127ed8d06783b1a3d2cff56f30cf900d1bfb95423c5fb443c713c8ae916d0358cab714635dd538db494a757038137a6e68850df3865295548700e5f77ac17c1049d5ba6e8279bb1594295a24b10d413d14170c2e46892915c8f3d491f08eccfbc67b34c768b714d0bc37345d4484cbd6722c3f266c33eab31e0a546e34ff48d7aa02a8920b97e917825a9a9c6476c6e87bb63957fbc7ce63a257463704396968afd0cb077db457adeb8f07d2a559dc1cb35ecb93859a7ab3143f28628664473ec93971bf6a189175c630ccdcf9133b7e86400c2e236672c5280cef421647f9bce3d59597c14537f5502cb9959371cb4937e9b23616d06cf0b1e8177d57ea28cc09def0c7635213d1c493d57eeb9a8acb45e8c8cb3429f00bbab0989d6c637908fcc4ec7514a8929de067bd29ff2e7d74c37152b0a2b2dd7190a90a4a694e638bfcec2fc75014e02121054195413b1ef94f29d128bcaf2214f87cc0d9dc2debfe5235d95cc05e95e0559e9ef31397537b481b5c67d92312f4d53fde6f7321b2027357e87bd741d4443ae552434e1e13b0fe08237ff87f9bda82bb26ad2804c84511d02db3a2d33ed1cca43151cb0e53dcbc1d0538ff7d4df4636a03cd6488aff47df2484c467b9e0f15a707945e4ce2e159297ddfbda8549a2d9e4d080938547eae7bd0b829dd9d53e847e72a07df1a254170e4bf244f281e214841f15dc243c69a62437dcc30c5a5c9539e95751c5ba2e6e029df0c06f4d1edf9c788d3bc5cca4239ead7dc17226ea0ad8126d752064c94f11bd80ddaa69f8870803c0c7f9ceca929fe4f1240b6624d103acc2bfac836ab4712704d58285d9c83a70140d7ee2ed11803f7e35483305d2a0f4dc61127fa64bab5f7e5b00b08d667860cc22c2f34ecbd99b9bf6750086e52afcce719d5aabbe5ec70b20e385abe4f6167c7a3139d80126d9caed46b8dd2431152e7deb5990a1a30efce24c4ab030649b769e5f6324616668fa8ef95af55d0770c216e891b7e399e09aca5544b4e4cf608b2a4c7610ab1d34ca4815f3574bebf2656b1fbb476d60b0bf56c2419a5dbf02654552049cc5c5413fe0ee2c8bb31909f3cf3ac0e54a10ccbd6d8fca459c3c0e49327125c643f833b2f53689608581637b84dde7f6005aef1614a6daa6f7972fbf8701a7b9553bab91b721ab750979b4a7e4b1b073c3799b33a9ade","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
