<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"13a723f763eb672e4a637c7b88d5081b52246bc40f2038766b55f6cca50f4eda6158c6e3c1f5b30a9adaab527c1558428a8c4a8e4c93903fa2621b5c9ac872bd1236352fdf1605730c185221d290072ce05ced787c39057823a67b757caf206eac8173cb02ab8ec4fb32ace24e04061a551eb1157dfb429ef65d02353858896946aac506d2c96eed5a4c1dfc43e1f32c788f997e41e20d2e0b7a1d74a38ab5819d56801b996796f08cf1c3ca6f7dbefc79ed03c7af634141268c1296b347983c90a75db3dcb55605b155c10749ffc62f1205f8d5c385c745ea81c79c489b2ba9b2bc8b2658f57030e6077e48e7ee0115f0b90ea51f9f4738f935e0c3bb2e9e5f1f862951f3761b231290250e259a39a66f57a1c96eabe5c1ccfd88565d8eac8a4a71a04201c683a3d93c83812093493f7a16c7b3fec9233a97f18136c1d99416ff8380a5b7a9011dbe1dabd829c2743869b1c1d4149c945d7730d45b8b845a5d654374109952b7d6db3331bf11ebdc28e317ba924cb3aaef95bb61d5988159c556cc8674a8fff58f8b8ecf35ac7e10f5cc7bfee0a3f0c88644df041e8acb633f88537d5f284ad78d0ee80fffff83d0f78183833f23bd2707b2d9715ec418383edc887a7c593eeaee2ba4f54a8ce6ba7d2a36af4bad9dfac9e40fb62145b340a3011cc45a13802521a4003976b690b93883b31ecbd67d374a7c9a7d47ca1624601bd6c53f039ffa5522c3d692fc5722020a4df6be2e839ea7b58a99027676758a0b4b173eecb9e189aef416a4cb6c91b51317b214a1862adba50443fb7a589242b1858952facb4b238d0031210b3d5646c05e137937975f8fc29ad074c0b7a948b4987f42ffd6a13a4b54b737adff220e581a8cfc15283df111af412e85ce2b0664df9452f3c948b3c1eb7c61679642503170735838b4382d62c65c2b9df49bd25bc0a3139ada931e361e82df068590147a927035cb46fe94f22f9a8334818b38d533aef4433971ce3dc77efbfdbdfe08a810778856a241868a0e6be6f9949c6b529305bf29fcbe3b64dc3f3b02b1d1e26a338007347c16dd0f35c5d2e6120b94d253720a0030421dfa13c52628429d34583e8356df229607013792380a531c8bf703f39ee160a15724ac135d4a5954e43f2ceb129b8789a2e67b2522068a85b699365998df09df34f93256246c298312c2463455603242ff68523c4d4fe6765fbf78d04437afc071ed8a0552d27f23361cc025af77ae0831f80aeeaf5602e419c190c0fd09d5591b59018123fd7c2ab268b0004b19346773dcf837c7fb73f6cb744daf3a87c020531485898b198973597697d5da7432c0dd21d3d32ef48ff8b2d5fef8a6947d88c9983a91dbe264a7a3dc6eda2b91830930e4db50c22be3c3182326fda13e38cadf23126b2635f7df7d8f951445cf8136844de0ad18d6b802306643eb59eb08423bbb79d97f5e87fa8d5cbad51fe1345221d2cc58a9ee6776d57f7e0d4e5c9ebe68a4a685778bd7b6f8118ff7ca3f506276d8089239e4ecd997cf3b33832cc2b933d103213cadadd60f3b01102d34dddd6872d821f44accfa493266b54477a21941883b1edee37f3e59be6a4e541b0d14286b113d4e118f5997e91408c4127e257777071ee06d7793ec3e012251c551a7120a5d1458e15aff9977c7f90ae7d1b15e8bd67eea1c1d48a28cb93b54613e91f46311e6afd9e6b2add797120c73e315703e7c6f9aa5a139ba70df1c3ef19a421a8f97edca04be86a4dd8504560b843f3cd2bf4bf9fc783f7ffd03caed260cb71c1f714ca5ea72282df7507f2771851464d1df11dc517d1ae6bb638edc22ad29eb36be78f3bccb502a23a1b0d2c64121c93f9da4209c4c3b9b37d5e6e6c32d1ad3e67bbb3016c7b216116d0d33383e6496782a675653d0793f0402c4cc3c217e5e207be8d516d5741f889fc7f146e9166ec36093be9cab5fa3c6533fc6d331b918c52abc4e4241627635bc5f635fbe97a5e404a7c62596a5574f30ffacb98ef6e90debee286078a8e5f1ecfb533a844688752d78326b2101735e35e1804c5acab3a1cd9b32d4fbe3818ddd472c033e10515f4adb94cf5ca5b6354751ee720fe4425a6ff65216dbf9eaba69f72f1e595f11a280f6df9e6160e2c2c6c760a01d722c008c519fea7dce54486cf614755fadf9e843bbf643d83060aec43d533ed6cbd8e7c7ffe71d543a59d6718c91f5af496e46f6a48cf717a6904bda9f573d3b1c00151b1afffbc278ee01fbc01725b24d308d1f75aefab185a7c608ca889005b10ab9a275e355e62e4a5c5a1d53b319f6d132a804845226e899d5738150b610846b9204be628f8e97ce054bfb1a1cfe05718c8d1302d2a6615673426c74f40fc1203cafc6b89b3b3fc6a2f4da6c9bdbc5c20ebc1b3dc4aff4a59c10220063aa2af54bfd0e7ae9abc73eea940910ff4cf547119da1b8476d0771e38503a78aa7a0d260b60e677aec0238769050d7d46954b4fcd29b8bf99539b4fa6f5375a873712165673dfc4721d037e1fda3adb2bf9cb92409e4b5e1a452c79d808e66f9b8111ea92dc8743162182bb7f18bb83e700b55d81b3c96c703956b79616aec6aea1bf27b1e0b8a9433fb3398165dc68ed17472280f152adb5a8a3e64eb002f87a8d318a877772ddfb0059d0d062dabd823a12a018a2c0043f0b5be5127a3f14212a1afca95eabf304e58aa44bb72251e732f280b0cead961bb2d71d9de95e572fe651ca7099dd4c3544241158d9aeaf927653652bfa52295d89463305a73044352c17c450faa25f6a03928f493fb0e46a46ec2951f0f2092d6756011be981bb19cfc725f2e3082d759ae60841d28e3ffc425fb082bf843eaba79ce8a856e61bdc8d324664025eef7e01086d50792b08a0c1e53ab311b0e770bb7d09cb21cf6cdc2ea25387a7f1ea63c41b28204315b31ac081f48f9e04b4ca52da331dab4dd5ef73ec42c85df0bd13129ea8cffbdc3030b08c4a2c49ec498c25b6ca6346812e2c6e44c16613cd6bd177e2b284f93887e3edc3d818f29787752a5edef4b55db73be6c1988d9f2cf7b94396d82cb29fd235f6a1e2e589cc412c77355ca4ff27aa41925b1e3c2b3f476ba6d0597ca74e54ef6d3be870f2f2628435dce1d85cc1c29592d3b0d601b8937910ae8d2cc68563d85edc0483411c4674932c9d8c15f14905ff0a8268b956d90d24b6f1f5ffdadee54bb3c84b505ae3bb592fa6332570460b1dfbfb2b369add538d4ed3b0d287e17d6c8053dee94fd30663460365be0baf96df93c0663055e069cbebd9369f4328b43a5a93d5ad58da6991bd5fb6d797bcbc1c1f9fc07f100affd246ee2af44c03cdedf1594efc51c422882dcdb3f83cc56bf9b56536528b10b272672cdc49548350fd3ede90061d503126cd8a93b5b707f0addce9fb9091784259c2c9b6a99af5f44abb7facbb9a1a8b6578f719d05ac61eed4e9e3a3eb0ec2ccf659624363048799bde122d55f711a78f878ddafe1a887ce066394c06351f1b446f2db9619c634b37505ad459b737af5a55ed208f848fe5ed14038aa10a12ebddd207237578f52aa3173ca4bbf54befc5f610261b9c957bbddcc95a12f8a2ee9619ec2a6eb5967fc7bf527e01b1c0bf7b471c9fb92d27fed1b78b01758975aeb5ee18901d604bf3248acb70e19643d882e145fd4a3f5f384439d741eff61dbdf33bd2376f5e97867d0ef45650c30d0c5a1f5ffab9e1d92cc294d64ccd7a895b8a1dff7065ea0cec8404a4c13858551dcf10a834fea52b5bf96c6322900502cc1564383927ae8146678e209da7dfc6f65ef7b714669cadf3b82610e4eb40b99ab86d7d7f8f1f32ab70b9a013826e48a332566a04574c0d3c9520ac8669ef1806fa0e7d30c1e302b3d1cd64b08cd0ab4a5d79e87ca36fae09632bebed79f55a15ee56d9154c3ac88883cfcabc50c83a8f5590e8c9f4fb1aed07ba50951ea18c56bb7d927cdda90be4d459c8eb279f6192de6cbb82582f5b702ae0f12787b3783a96583ed2900eb1a3c62a6bfa8df323ef2abff538b822586a638d6b45b8f250d13811279bd2d15c8e5303ab822eb81fed1dc1bc54568f685c01f65bea7b4746fa64dcc5add23334fb94f34a8b369661112f01b3ac9a1560fb7b2e1c9e2a8275d0badefbc43c4418e9ae052cef551fb3ad143f4a5be402184b063f1911e23485366e8576bff664918c88071735a7b51633e6aa83a130ba655428853d6e26fc2ade2f6665f9ff8ac1bb782545f46ebe04dcd5269a34613ba27cb37d023477bef4a503d1a143eb0dbe3cb512906edb8ce930d7e6d7858a45fe4d87bf05aa250402c516abe89488aa4dd5839666ede13a2dd9c5edd1b1b8b1346c934d7714db664a57914b99bf74b8251b281dd1ef616aa0f28aba6fa1de46a1487c798dbc2f1355abf8cd3bdb80725948cc6177b5f05b08eff72379fe47f5d84cffd767ee6deb31a7aeee52dffbffab04ec75a8734efa51e6aa6b3597c2bca600485c82ddbc78d936b059adca5b4a01c2cc2c311b85404fc610d9233b0f61bb2dece1d197de792e61a2f02501488404b90844b8ccb0fbfe9d44f89926260c493fab76e322aff1ba8fad27c88c42b4cc21572abdd95698567fb611cd03e062de3324349d3c2ece5643ea7682f980a8db12f902ea18581a45ffb3a56a9081592152f2f3849ffa3f8d11cc935a6509b0180452d2b4f01dd800c1627623eb103d66414555994e4584458bfcb76c8cc0bcda373153af8797567b635f88d958a34b8f6be2d5e4197f295adf835feeafc1c1f5924a294c3ad736271a5689190a97ffe60289caa07f77ee6e3eadca749e80468d9e8037088157044a458af96d10d77529ac68ad805a155477b2381ed118d05c546e267b766c6d9c37373f2bd59b3c972f384a0b7762d2d642296d3c5872e041c75bb3b34bcc81cdd3b2c4b42570f3e8dbbc7927232db7b7ee1d718daeba4f228cddce9c82a219a002b7bb894e131f449df2afe4833a91f4dbd480b971691bd8576e03910e70c521be825f2caed517ac72524b77dd5d844f24bfa6f6891e001ba4d7f8a4445c9c3947ff939eb0981b9472767f18257b871d62d3a4bf0639b717e1b06c2e48bad989e17b7d591e3e53319f9dc42345534f9bbcaa28354aad665905b63a85a38452be5dc0fb24c1557cc2183ee12993aad67f01e647406aeb9e438708be52a4868f35e386f767e2f986807ce29b5787f26f56d6e35c70147a0bfa5dfb678e1c1587546c796638e3659dcd7d7962dd88696d871b536065ed6aa75e941bafefe08cfb757abdf6fe1a9c23b516ae6bab759e4ee38af1016f96fcc61588c96b061cc53767d86ba64fa454f590894cab3cfe3053ea9a5720ce0abbaba4044583d119e4f3493df9353f1374e82769568dc38a36864c9dd8510b1046650f13708b79b359184b95ed799e5c68350daee21eb9e426ac70e42389b899a09157fca92ffdbe4c1982c431117429d878d4bcae0c4735a3896cebf9791bd5d7167cda048fb190cee955217e0c4a3e58bfb372d417a404980009e93b726547e9a3d814cb63e36de25bc3d0550a37577cef20acc208c9f6ef8a1da640711a4720dcf5f7a5d8701a99ee8a6354743bcfb97d64fa2928f9debaf12537ac8bbe2dfba710126fbb0b2715ef07ada073f0ea61f34a4cb9beddd92c0d48b705ec5384b1bfda61f52dc8712f5ce6606908a6b079fa7ac338f46455042b042577a4d93521838ca21126c94b872f9f946d89f073715399a472710f45fdd8423d9459dae140e0d8b7dea6eca5100723d3a090abc25485324bd645bf9cbc2bb53c104c85018b47a9099bba37fdf3da32f5d2b9afe4d713ec7d86c2b3cb78ae19df48c15fbcc6434c098eb8d3ac02366cbdb46d33f9b35a08a08788e52a5a8f09c6fc4c5f4a0f4949e370544fdaae01955c7aa9de08b63ddebe75b5c5f7d056d81610240adf4cf9814a9f9aa611166a1a19e75ae2194afce75ac384d5895f1d9e1e152fed4f70c8b7a7258d23a396b62f94a058fc19abb9776c9878302af0fe10689e7be5dad4422b14471c1e73ed3e030389e9f789c9d16016e2d5e13102f4e10684655a8e8b20c172d8dbf8c60ad16988f7a1a1f8a66471a62e78496f9038b4a650744ca98d9144ebd4eeecf5df73b27864f183047284fc4dccb275d27d568a8cf8847044c2486a94067e3c0032d24181c7122b9f98f4d29082df1dd0e42703c78abf47e8374554d242304fc9ae5a35bf14b2f27587edf472e6f793731bedc8d38403dfad997f6337b669db36d58c746759dcb6dcd0f029d9dd775a4f4cff28c3dd05354f86d5f5845ed049700896c41abc015204083a3614bae39776c3b4cf45ed0a91524c82eacc848583f42f326b494f878d6108c336a253c2085916a1479b8aeb20705a6c1c7a08e16d9bd47cfb397182357131213fd02d0d24ac7887db4de5f3aa585271b605a66f7e903b1ae3f214bf95f94ca768901ebd9cd1d529ed2af15f593a99638cd71aed710b6e94b70ee74615eb0743541bcf3a247b9b5243169fd882dd4d230c2564ebe63442287e6f3eadda75a531ebc0753a0b64945110a6ece28d3dad679a3b1a258d1afad4da2df938c13ec84c564249a3bf02ba0407fced21c16ec36bab4631d87885f7c829c08965378200f685aa748ac4811d7c413e0e4cdbc6a4f5140ea1b30f6e5c259b8c55b72249f6c490b991de178325aa5993d91be4a6492c354ea30a0ef1dae6f0608ca265f399bfce277ceb0a40aae396d6aef369b14e049f11a9285afb9690f7b970b9442e21ba80ffa3a4bd0f565dc412741a8a0b0a35dd8b8544076dd426d392b4ebd3a8f4842c0dea5b1efc9f80ba72f4318dbef524c396b0549f03c470622b5d4517e6561a24f1c4bd21ba019c0ad258b6b176d2e5d3567aa652e921f9c2205f3df2333c691bd96254b77fa3a97b61dd91fc80fe9a3c48c622ac754e0889284c80923cc7fd41dea6852ec91de06935879c0c065bf0b21df4b9f4d165ecb3a465a3b6719650f835f25db7dbdb16e292931cc7757ec3049b467939bf64f1c9bb6933a16574f75e1eb55dd0b23070b928ed0a43030a0ea4254ae9747c115017988e26aaf77ec08789a9932b819980ecbca22d22f5671b165716c30d34c44b9f27e43f2da283d110c9a442622535db71a88c6db477e313137e282babd8d89ab9ee96fb81c7faddba7177dd4863c068aab969be42f76cbe44eff3ebf97df748221fcc8a478ec8893f12a64883ca46e31262056821bd40ea2f93d619d4fd988b914ac8daa9f944064a8e7789665c4ce4fa42d8c2ced6f49d111db4e1d5778102a442d1d57cbd23eaff7e388bb325bb85dcc31dc645569b7501da16c43a7dbe33c1c854cfc04d307342a6ee6c4d87a4f52088c9da84a0d6a3a244cef35c67967b7cf3cab5562042ca17042142d14d680a5f07ee0f4f9de711c06298efc35c20a0b790e2cc8a048f94c3e7a8c54fd33f96f71ae9d088b89d6f19179ffc46c1aa68f056de1000a463b4e6d34e5b4754039540dcbc2f27e68aacab00b72d91dcb1b2532e30e135ea28d0f2e62d6a55f67c58eef2b93d98103fb16a553c40c4bb36038fbbfdb24e189749a95742004f47cac597e7964e8fc64b2d1bc2cec5d5fa91183dbf89f1b3888f41d431dc244630d0b5af6bde0eb939a553abeb5d86cf61c9601048e1f2dc1375ad3b3d55276e6d5f3d1f3b46f791776d7219c49773467768c6f3ceb7f1ec403bfa4f64f4eebd0e904dea5144f7d1e3410f6bcaf19d101979bbf5e845c01e10c2241f2fb72f39ab9141b73167d6c862993b9b4fc2bbc8ed5a1f31eab832aa54edd1bc8c7f0534e5c50b4147b1a43c78db132411385a7e971e1ddfcfddb2c7667f210e566f75d458eafb3bac61ad101c1f9b3c95c53cc0f7939073a7a46913c9438a43b1df94ff2600879dc025764bbff1fb0bc1a7ec9724eb5ae81d417cdf9f8ab03c967bef498e36db9b54a94717c6190dedd631d943bb930eb24dbae6db9c1bb521eccd66ca4f3cd11427f56fd247debbcde46e309ca75f9fd4e923429069b59b54f51b8d5019de0c5de9151d6325e9303738b5f62009a79f93430c7030541d0db22a6ff51b862a104b7d7914400712f656036426fd412a4b841d9d2d350ee0b1e3e17728e3b1e579cf68d5b76c089034d317d8969a9ace4014d81a73174db025ba2c588b992f35d5f333235d633e5d30b4aed6a348a086c8fd56df247c5a6007e0e18d0ca4700ca968a0cca5e6e0ae8e6b9dbc9ae64d5c9ccbb52c88541ddc293044c4ee48f1b07661eef5be109770fd1011d21f9bb8b20e6d46adde9c67d0182c0f9bc01c0dc210a6edc36def8cbdee7aa031f22fe3f93e046d6b1dc2d5feff571bec289c499d3d29be1d6d945c1925deecab46d58fd05521659896ace6492de415c222662803848cd09988bf42f78218ad9e1edc93f976be59323ef040c0abdc08a27c37bbeab80534f561330202f86f3c8f74f7a4a3b6a3cbf735c2d34327b7491f07d0b98a89d6a522e962722aad8467274fee68941f852bee93c4fdd037f540e7ea15d4b034df569bd363a1da42d6252782e2a85ee4f626ae238ef811a335606c0fcca616449a94c29e8f1b2adfdf93bcccf7b612b4a71c1b2f276f9633fd37977033c63a66e3c7a0ca20163fd1c150143d91b1780cc7ae8a0b5523226e7642164551460156e36343779d71d6d4c5e676cc796545f3722b8647be2fb50346f48cace0686af27a0923659293f2b98acbb908ec61b8dabe039ff55395ce932f76012c4f19c44ae242ad0910c781d05e0fef45d57024ad0e16735e9aa1aeceb6298e1ac15cd5a584844d6ec4c37c6d2e6f234039fef6709535e542aebdd10b8eaadf59e2feee9b5b21bd938cf409ed97d804efb82cdd20b7a4b1452d017f0fdd4c03fd07148205fc5298a0a1d72dbb67d0726db28f967d1f7a84f4d5092e30044c14aa6f098d8beff5ac741e6ad8012b3eede0a2f7b061206b88be85ccdbace47fcb04ce8d725d7a5966a768ffdd7cdc19d57192ddd99e6f6efac3a90f1de0ab214c3bc1c7a389c91cf30f258a5ecd71c940df703d2f14e73309fbf7ba3e172d4e1b090d9d3d3c7964742ca612879cf95f8c97c6ad8b001a8271f423d0a97254c9a6921ff6a0ad0b003cceeab39eaad11cb1645390a359c03b3d4fe628418dede392c205c3c1333451609b78b3d87473243eb7e05c87abf199c35d5745babe816982bb8c34c89ee3566e075be5f089b939022c620d9e29826b211db7a77b8b8d83eaba66031f4f67b1ffdb1f3aab6f04c015c9dafcbbd16699433dd6ce3c2a830978c081d2e679cdd90cba6bab31ecac9c7bf08c62e2b3f5e4edb84d608cd892ae198f605f5fec1234310d5d0b5c68f5513c2410e4b1a6e89ad667e61b51964bb19752684d0e53b9f05ff2974485bf97bace199b92727fce492088653f148be79f34aa7e1d62002442e75e65b95c77a0a7c551051530d58935e89d8fb4b6dbe40dfb06688e54583893a20d77f41efe84f5a284409edccb7c56dafc29016f8366a7b981bb11532b4f5a7c984e18bbe108113131ad2cb3a798bc370cf7f5b1556013e6b550bda1dd7eb1fd3890c7087fa68d4cec89e1b7bae99ca2aed43086072724f1422d5bc70c54eb4e5082613db29e8a8dfb848120b66164f27d341f354b65a5b8b9c57fcd178c8a6596268f9e1e7037ab61fd9c8d92b03aa123e11c1c0c4b9cfcf591aed6eb75ab223ec7a7837f93fbd4bd55ec10e1b43caebeb874a6bd02abdec5735b0f7cda6457ce34348e3276d7aad502004b5ed54a0007764745a535395fba790d3be49d430fde924d1a5fdcd5504263c0391893008ccc97ddf4b8bae6a1fec00fd53c59152b666e6c2bdb7521f2a98232365fc5fa8427783c6f97057ff5bb1779b0a3caac7aa7d137da4f012776c99130599ed2da370a695bf008ba08c3edea13c54226d1323579140f273cf09c2434f76e95270efe0e50d1567eec5b11113bbfd43efe303ea76d1ad9c5a5dfee4e6f075f7ee2ccc7e61b56c1da1db0daa8dab8e65d4a4f2f78a91e2eba0d2ba8a2804de49421f72e6f6ff13d850b994b4e9a2ddf215a553ce47368f0a33f44234feb77fbdb3d9f81a29b544e28ee8275c7cd9d38568582467e900c00e3bd095271bbae7ec5a57b940fc869ab85bdc59dfe2976e622cd979ca1a9e89484a45a9a4ad3c863cdbb0d6225b72f52edc5b7ce641a6ca88bcc74599c1ad084ab02bb193a58385b713c576852abf940a7d68ca8a4c699ef61fa7ed32ab89b0dc8a17e1fac7b0d130d16f9b86bf55ed3262bc890cafb0bb0e27383b4001fba189dbf216e7bef8e1041141be1e2ecfefb54e577517791c26ee3bfc6ee28417dac36d8a6fd4a724b8b82f3cfd1864f1ee01eae84b6f101ac76bcf3b08a5ebc49e3df13811af606c1e9c2a26160277687cfa4416be6af3a9a6b6d096a10a775d677e106c2a8e15e917c6da199d9ccd58a3433365d7f93cfd769a4ed8dbd5a7a71d27b7fb852e93d74c3ecf961f7063be15dd68a377b7c91391638e3ce8f10fc2ba9b0d65fb7f7137daf075ee5e193fa58ca910797fd8ed6ff35354efae8d024085885f00b1e92b67902ac747ac5f9589eeb60487cca3b68fc47fc0adf383160fe2465850c7637a954d640a9988b87eaf1251f1ce95a6920d5fb9b2bda25165af82542b08d4213fef8d5eb769e631420db8f653ad326b533d30ff1099606c01451c5b77dc4f39fd60e71d1e8e87b5054844cf0f3a4fe61a7bc03282653a26a8449bdc722c94e9d9f559a9e15bed042808e80297509837c559804409cda4e2338e4dfeff2b422a05a34c06f8117866a59060f7dd1f2f63960eb1433d54c8b39f8401b9dac3a7b20f78aaebbbfb1421e27869389b3f04e1ef5a082e2674038acf189894ff70fcc63c4da97b9eb6e3fee94a6bf2a1bf9650649ab5094437044faef78a9d12cfd8e2307b2675ad14f9485adf5bc3a7afb86ab8590907479024d03e3894808a9faf8596d8104d509b5c4640099ece7be13cafb484d34ff7017e347b762bd06fe5b66d3b245c57d7a5021f81c649d762a5418938f925db9141d15b3f46e9467008bc2437eb5785bf4b430bc9227590ce834b3fbaec228e06734c10c2f58896fc88525cc824a24f3866d78f23a5e0891324306a638ed0462b87b755b08bed7e310a131e4b98609f48dc9e8e7d7b8b7ba73ecd77ca0a1b64216f2b895a5cdf906321f5244e7288f2369d37f02bc4e1d13a680012f698824a32a10d522644a41a614b7e9b7541447f2d634242c0de75a2a35acab75e8d1b8be04702501a7a28ab42244cfd6103a9144224bf3b6fa7c567e00ecebeedbb7dcc39f39b60aa57e04db9128bdeda92f8cf2ccabf29223e27c31c771b05da6235b5b2a929975c6c3135f974ede01d21f3fc01ad97374c588c9eb02db4eba2353b173bb2e1b6dc2c3581cec2c160e3f07c73b038c00ad9b865dde83adb9549387d00a9ac6e2a5c1bb5697ce50a4fd9ce33925cd565791ecb7a3dd8bb37008e747df61a9209bd641a4737990534293938bf94a7438fc01cd08783dd765b7fbe7817c86c854cf4f87413028d0521ebf4cff7e0a805a286e2a5774154ec26bc46ae00bfb3f9e398abef3254d425c663460b50d05c277c79860e41415297f428eec0b2c94f6450bb98b78d204431660db703f9f7ad1e16f4a78c02b3e925284b33f6fac44ea576d39a36de18f178aea4b8dda3b612cc34505ee3f89106a7ee828057f37c86c2515ddd73e8e3c8f00d416af5b8d0680136eb638ba5b3d859c9bbe9f0807799dbbf5c635b0c2f358f83175ecbb5294a5a3558e57708f427152408904e5529873c48b9f2aefbd2da866ba19017c55221a8a707fb6f94a11e90d0fbd62e275d67e6775df7ad8fa83c4b1d9050b3fb63aeed500bde5a6296ec07693a1a77340d020675e5ddb21bf039a625c69ef8c216b425b4809c463a64b3910d2fad4254d49ce5d309c2be338ee024abec43209a62fd6eda5c07394f7f3d532c808a9039b7fba2be7ea1ee700000eddedc2f17a36cfa467a0f52ec45fdb388d9c29c50592a5152ed43e932215cd0a6b2876778c3dacd7fb936fc29d6f0541dc0056f8e198dae38e4ab19ffd346d83c715a8e858a637db6e8b7e6403516eda8c3039135657e1d4354e18930722dcfb5f222b5aea6bf3e09955a523b48a32bc7d6bc386f794251b1a52e95c0c7dca37fb844656a94e852a99a06e99cbaffb64d38ae0c76e299f460ab50c9ae0c71640de27f1e109c369c24bbc967598140d30d97500bf35c19e4ff4e2821649cb22e31e46ce2169edf1dbc1231ff3fa0940643d149a5efc85040b4c13bd9f525dd955d0e6db276d5c53e712e514b6ed1b9df4e662a2c1a0c787886abf06d4165547d4d2f1432418e556f533eedc80b9ce149598128c455e2d1bbf13c85468714f0857940e5bb7d18dcb05dfd148b45a16b8ec1c52ad1098226029be8416971d6173e02d403f45d0154c338f4dcb02ac18737234e531780f7897ad7e4a54118043309f0089758c59e2682c20a274a3fb3d2b5031d6147cb9db571502f0a235fe00421827c0e2b606320abcd2e7004e0fef2fd3eb38ccd7b10a8e8f38115d1d1e41cf07044d1692671b9b755290a04d09e39ab6e664f5ae5787f2a736839b24cd5a924cdda76b9b321cab13315d668a55df295151379d41cb2a273567a8c02e6acfc8fe8caf7b4fcd91cda2a29b2cda49d4db434e8d53667567f491d4a468f50e784d1c4fcbe2b8f27b9cbe53d0485e95d8895ed086e6ebfad7a94dee5671e95028dde4aa58ca3c045accf192a20611189752f136a5dd2657f3b4a7ca67929a41210613c376a90a32a203f8e444b96724d2361ceef4f3fbcbc166cbd59f39feb4954abb0db3a2178984c4eb6e8452c7408816bd1214238c5bf47b535f668b87be6c6d99c8c5c330b273c6e5d757aded7740c266bb68bd4080057e73e0e665f71f3dd8c74871b8ebae4bf6e0e5d89f8ced3d2f64a4e1896fe787e772b9e3b8254aac45ea250f309f4f99114800d1c8ee88446fa4703ae0dd787edf77ff1a5399a922a682258fe7563b03288cd2be48ac4b42f4dd4dd6cb57a454a3c274293917278d51da4c4b55026d67898f0f04db0c9d406e603af50d9af76761c454cac5aa28396a96bd9b8d69c36c51572bb01629d3274d5dd50e19fa53188ed9debf32a026bf67bd56b755486d6ac09268ef4e4cd90e7357dc6e3d130b50cf68aeacb265f52144df982d047eab23169a8f036e68cd07be10533e152df56d170f7527102cec343267adedd9ccc5c2541e347d28efa74c8ed4c3d9c86c150bcab50e2f53abe2ef5ea45d67cf270ad8deedb30b6afb8c6bb0d3b950a2183288c8b2c0b56ade737ed8c5c7dc3080dc034a2d11701cd885d87b9fcc10cf0a179780c30b5f99ee5382f90831f9d5dd809f3120613cdbb79af1f49304b9bf56bd95128f68038a04857230d7ccf06904d66122c9a9d40f58ffd51170a835900340226ebd3f2dc389cafd57f7f4288526774636155d62ac24a89f88b44b2fb8f8781a18b7cf207a5970f452371c2f3668a1b5f47596ea5da8e30f9861955ec1de6b5a2b4bcef2927d41218e7fb762ed94dacea7ee820f9d920292f8d579e99a279d9dc0ad99d6d91d735fbc85141d96c3674740a161fc3196f7a0dcf520da32b4e9e37558fe949681229d907f5e828483640e6ac64658ac161be3e3f0b6dfc6945db16b9d127631e8eb129cb0a9b745b35f857dc7f04d778ab5dd112fe3d05f6c84be6473469583fc5c5646d7c6539e163919cd93acbad2c0f6b5341257fcd151aac1cbef20acb8ba99388e06d2d82bd36e684617d98020a1eb7ed9f4bf00257fb30bafa35ab0f95cd01d8683c6d5f4ebc086a1bc39c33064b127b7e276cbac35283c3bbae585a259459d4202c3e0b9f08a70eee66f745090c1b91a0b028dcf2a239ca2c80f43afabd83cf1254166337e217cd4fb486ac9a5a7a48cdb78713bec0a56fbebe70c797b39e3b22805c0aa0a66cab7ad66f6c12da69e2820673240a43ac52c5ad26f97ae191d9ae0d3794475d3a46f92e95183d105ed7d1b6ab07ad76ea88a42f796828383fc98a1bc173377757b0fc7ba4a9552cb61b62ab03eb76507713b8ddf38fe47008995dccfaf8e3b001c65628ac2f9bfdc1857b7fd1d9f78ec0a369aad4a6ecf5b9408a7befacd3930732d6afbe0d5b3ae083882cb6fd81f4ff4bf8b05ab343f420c82f98c7ef0d1fe0c7e120125dff69f025100a12159066a66ae715a7c836e3abf6afae98a25dc1f519f7943158159f2b9e4d747076a3c559a44fdb49d2a1d8384c9e1873279e0c4434e20321bf366a0f1bfaeea1e5ddec6f7c6580850c21ef","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
