<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ac346c7dfba9899e9725a41d30e685948a6ba2886b8354b1b4816fbf77bb859787dea89fe89063023346f1c5f79da058385ace1ced03c8d27c47195fb820bbb9ee95a1aaff411b06a4ed2680c103c82bbfe635e4bce75d8f460e124a4b99f4e598434bae5b2e689124b2a50c93d4b0442feea264fb908e7e1cec7782b8c9d7bf93087deb3160f159fbbd3cf9f19d2fc417894bedc282fc71dac0a53268d6f7769dbbfc365d230f03445d74556c4ca6fccc7b9703b998916049f117bf296ded4d2206a9a97d881f876fe0742ddaa218d6ffdab37b651b699bf6c59c314c5196349180432e16165643b0276989b4e63988a05cca76cc0fbf8eb8a17e2b1c6a030031cfb6a2ab22a65b4af3aace48d8324c2fd3bcf3634c592040f80c2bc0f7663c1c19fed6085ae2a739e0a64acfc3044d724080e3ea93a2e5da8d622bc891b6a4cd9d43829b00b7410df89a3338125245d2098605bfb37a990ae94022800046b847b2c394d1035dd785caeb1676fdbe75a3e7768a2f97c2d139157146e0c1843f438db2fe6a09201d3bea9adb2020f7a5777f9e603633ebbc5802d510570b4cb1e98cc73b4f0988523a4c28199abf319be46c199d1893fbe3d1e65dd1d90b5e0995e228074cd2594bca2c2eaf146e97c1388e087eb6fe2eee90477569cf964ae354c6c90406d93fd16802b2f66473dcd3521656c027f5ef47b36647ed25df97568decf2796638598c0e48ef641e3827bf05b1170d88551e832b9ac03e6a07d3d05f6240f0e2ca9e3e3aabf7f740cea2ab1a7704cd368573a33dc9f3e280da8cd8033e5beba25c14ba30ff85b25592d06e004e53d38ebb4304306ab965030364847cd5bee7b742160ca9f5547b63118197028d2c8502749340d467e54f8709819db95010c027bc5b024caba62f3e92d8fb8fece04dc570312a1085b6cafbe097707818464ca8bbf6ffe32ef5b9ec946a10dbc16b4f7cc49e13bf676d88dc42f2b51a94bc2e28f1cfa1143377ed25aba1dd9f0385f4aac9c82d0a933edab6377ae268c63bc10bcf130f3fb885bb62eba9881e192b0a9dfeb2abc6487f4a35b4426f3167a0504a0468c68a78a354d7239498186cb28695e72122f0caadc3bcaabbc0229fa20efee484e045c176ab40df72f04de0214dc447e89738fdbea4fd409b1fa249ace0b78e77683413172d1a5a48b83f41f198fa100933c9a83a52167458ac1065346af52854b7a3273f4f4da3fca93758cacadd5d1b7fad36c81f30613fe0be7c6a31fb831fe7d9e7b9c56481ead2c7dc1daa64ff07eeddafe4025c553f0e35e400f0832066e4accf8cdfddd86c0eed8b8035ac7a3254409768d6eb772e843fceda391fe950e5f46a3aa196160c8462fdb9b1bf3d1208da7308c3b6961abff6955c1296027616785e5ae1a81bad2c7caf6f86bbc20e4ee8866a1333759d89005937d0fd4a81bee80be5ac42f9dccbd926f79631d0baf4fbbe756e53ac839ffc97f2b0a8ec159085b02388bd3887b190fdd534c573df8e5e486eb75bef62d5788765d65745f6a7c16c2abf02563e19f3f2cdab4f0c144d7b7385caf1c43759b18612058104a536e3d81aaadbbb331766f5601015e8b0595fa61808aedb3776cf7c18cb525669fdf83a68b44afe99f6b51b85015e8ae90e6c74560a968a64c6d9e6452643a6be03798a4b628f26fe196f3696bd7013e49eed71f891b9044abde8588d66dc331d1345d9e70b823eb26dbc1502ea8f593e588203d7d9ff352b0c5282bd567b4d6a6af497bb041d931bb93f94f78a463e4a5f47cb7eb2a89f2d548871b3678351d184b72b3dc7e4b8db1efa371cad136b8c9699c3d412c9d192e14ee003836e4395fb55808e187154990616cde5768f2514ccc4fbae3f197d1bb17030a3413b97bf839aa093fe185f92eccb2c56a1a54cc0d60181ce99d43fc9306c0782cf774db9fec62f40a46e06f08d2cf01c5fabbe9966b7a16bac1a4b262ce71dba89fa062286efc92272ee4104ba936c876cae2dba2f330a8473ac4c47e6d8819b2eb9d8cedbdf58397bb5c5f3a0113f4d0ee649e83d7ed8c74511e0ddca930132e062c22e7775be59880ea4e243c4a7ddced47a55ac7708c0f2a5077ea40c3baf2e962e3f6abc0a6dc274880caa37216094d57a35ebacfcd3576077570c3163f00457ba616d457ede7319e56290423554f7b3ab69e73fe71f499fb1d978a49beca8f06757149884b38fafddec26d75b4594e073e1719e0fbe921603e06a03933178461ec58998aa2a012d4b1253af305542194622e1616ad06ef6195049a2908dd041f0581d780ee5a4b5383827d0d20d819a8b0861356cd9cba535510a34581c4fc2c090378d5efd83d3597a3ec193b3289e5e99bd3c8fe664e7da287b5cd27ac29aedb1c60de7eadb735103294c5e7be6f0a3ef9b3b4c4d7c5f04e55653fa5cef9bd0c63f2fbd03e18d025a8cbd4a60a134618d4fcf999511ee3739a349556646ff523b3b23f902df3c3dde914ec08d6db608fa4fd67ddf9fe53361b040ce2a2fb6db5d90d417c676d647ea7f8a6245d6f73b5350d927d5aa2339fd45b10fccd4228c81512901b8706573c4ee848e1c828e323ddd3cbd4bfa76d775baf7710561ffce5a1ae7a7d240a20a34024fe8071a28cb741b96869b03bac3084c7ee78beee9b987b03d9a8fb63074d42e750e0db2c58849b412d13e3491df2db5e900529d0f739c8e1f75d76a87d492f3b38e514754ed3960f6c96a5f0428a5230f5ed460960491722e9166baf0194d6ef4cc29d100966d00d7a2325ceed335bf46b1e8e543a147c9908c52676df1f0a4b1d40a01b354eb0637cf87dee5bad62ce707400bcf6a8a3c5878d72268ae4af34e46ff01ba5512e5eb45f3fbe557f8da4c26af7fb8cdaf7f2ba8033eb090e2d8aee5050002570262ba8e0f48fd78bc156de594d33763686b8f99ba9ec632ef7f41d75635bcf02d1b2287bf2ebae6b7341e6d3693f1c06a32ae7a34613b5ca60dfcc6e8d83f326738ef8cbe156991db3ea0d1a23695434abcd5855746123d3d4d124cbf4066c7e3ebc4ef783de3d011693c02bb94d378d8b1ef2a34e31d3ec41b75897de27d12c410f2bbbce6893d8205fd54b5a09e3f0340ebe2d04e7d5fadb0c1a13ba52cbf22da160062392ae616e67316ad003191a1b2af4e7a70f2fce7f8c9490035dc2090b3e49950e5c97b92da5726025446be74cf0206e96862dece6292001ba2a2818b019a1d4ed45a48f3fa1aeb33c31de2fe5cc86b164661251d0ebaae042898aebe29b922750b22e3e538606cfdcccc5ffcd9a599d91c51306d9785c51a4564f47b3521e91a1bfedc3c4e14266def8ac248b4266cd09d25b32e72ca32283d018529352916e254f51a7cb934447f411fe528ea92ad63b16cdce1c401e93f64f29c68b4801ec4c335109c2666e74e5e1d70fb8f0846afd8dd2ac4ac49d20b679803948104040db6a11cfbccb61b2cd207bcfab0943e2916842b2cc208a58c5ee747e25f0902a96a8ac0c1d64bc50cadc06faa289acf31387c1760d01cc9bf9c8713649c1beda33e30b60655c2512bacd8943a2221e81a2f2cbdf0f62f7277240a4336dd3bd95f6c4c2ca814655ac49df907f95e8246ab963709ec19b645e92f57fb07dbde7a5fe64959596d678c7329aa1161af51bba5dbb31766dea23309c55dd9cdc22244d805e2955b3645914898aef99afa413ae858d1524eeb5fd7d85c0ca60868bff8b2e06120a475dbb26371c6712bb5bc509267881301afd24afa44a4b7ccae6799c851a71bbcc6dbf7712e2727fe5809162bb51ed0662762d86c689a8da0b89cbc72306964e15bd8a9826ba7de9d3c4f4c9ead4d7e3e1dda72efd4cb413d381186ed78415f6c483064aae2bbb6cae44f3689930fde1ddc9d3ce73bdfe072ffebc047904ff179e7cc3f0008df3a65440c72fedf770532c43aa5d1708e298f6ce29c8f9abe9f77180d592e76482754bd057d79ca9703aef05e392c42bca2bdcfda750c606267b71fa198e691685a535d964ca0c510aa252bcccf907e224b3fc34c7a6aac4390095b24e9544d7b8a317e65e8b095141992c9de2ab7b19a94acd1317aa3c9db9c69aff74343d4312732b9c9a178eeb1a87ee10a17dc1aee50a423f963ae97975a789a30186519271d2eb01832cb8aa166994c49f34bad3d98e5907e9f3106a45f8c770524c9c80dfeb757185940adf6ce3b7fe95518952b3fb3feb202768d03e0b35205cbc2dcc5590f5d592753ab450d6a18e4daba672d27c4c740d910a41e35f03e725f562f60b5050c7ff156b5fef74ecbad21257312e0b98abdb7437d9d647869a1b9fc95369c2b760df88568537bfa62813c4e51105d24156986820b76016b6c3aa4539f55b6b57bfb17754abeccb04c150d5b6a763016d973169befba098b17b1a8aab8384259741ac80a68af3cf0df6f58dcb2172a6507bca2a1be35b4f81e25d1606d88ce1de19887741b0feeccfd9f5017136111b8b870e66178f0e3cd52010861ba2d03292d69cc01cf14b9b012023b0b5c7f40a473b6895afcd07cf9d43b4e00ca708d2cfe388bef7de5974955535b4451516fb008b41bcdc18b8b150959b297558b9baaaffd6ce816c414e33aea607355429ef495a95233e53e7f58780be34843c71f71250a8afcd00c2df5318db120397bbaa25f08fb12f62037a3f2860512655b76a27bd1182c89f566d4df7cef368fc5084fcad848803a8f74fa81036f1da50345ee73a53e21256fc85fa82d256ee0e29193daa54d45050379522b0795c809fe0dc6cf77ce4d95fc0ea70c7a7c80be71160f18bbae2c7ad9a84dd9bc02ad5eed98ea091c6092db80c4ad172cf58408419a5e33675103a4f44f5a227975c82bd28a2006869ec0c5c1a6a248b27b6883c0ecd9ca2c69d6872991f1ed8e0ceccb893cf2d0c9fb11ebca69bc6830a2c1d95ee4468395acc2f842dfc67a3d62531ed6b8501c18ba4b4f27cef7c11585550947db0ca49a793e5a8d03f7e3a98c0afb9b5ae9848bf70d87eec8e870e7aeb8076615064f34eb34c69f80a6cc56f21c7c131300f1f3168de82a1b6d4f4b3cf38e388510338551819ea521733ed04ade37e05758e13de34f85090d90c7b4d369b36759e205567f7a6910d019530e60dce4072120586858332b5af2b12a5ca534450e71798fe72db0d3e78ad60308b4696357a99d9020504c73b7b4ce2acafff0437f7cf41f2c609a86db0b1caaa2832671e11e3aec17df5c1bc117fb0cfe8fd3d49ca8aef1652825b95a76a7d9e2618cc37c68b32438725ef8751a87311b7c9227b422a200a7eae5de8942dafa58eeb4a9599930a66cbe83029fa747f72268bcc9ca4ffa62ab9554e0b43ccf729e59307564ee9449c2c5bb383c79b4d78171c5f3aa20cd7e3a0b5e182c80ac7dda4babad85a078bce95912327f4455e8938fde1151ecec177a468ad820ea3f9c9151c5dc04c1ababd06ca4f44e6a4b1c2eed2ecf5114bac85421ee918674e6929490b38065fc8e870e019805a8b35ae6d4829fc9c04043a3da3c81e0dc96071b8ac3d7fb97cda1594183b2a903230c81549242a058c810b1e85fa1fc08e04300ca213668a353a76a585b2d82fda2ed123983d882384f4b5e87a4c566a5742ca1424221ce532b9fc8d6e96166e95942e58e947a831fbf67175c834534ff189ad8934e4bcbb4e93b6f88fa1de09d62fc75257446e31b35830cc3a6b757f5a6289e4409382cb1ba54abe96f46939f3f6f4876cf58fb30e84b1c3da8670c5f7e161648824616ba0b9dd20c6ddba1978adbd5a6adcac444efc364cbc928d2405cb2a6403b4ac19c1cb39112a73c78859115b2ae82bf982a09ccaf99323482937a5fa9b10150dc9981e0567b5fa459166517bab06af2f6ca3beefa234507a3caef2d89b46ddd77e1738cadebaaa07f4a7ac9fbfc84e6fa8b0e95313f62da6f0bec4f33f51fee95fc8dc1fc60562b028bd317bf1ac6a0e00889d92265a61d2c95cc2444259a2f8be4eabc238ee0c334864cd22ccaf6d303657982f7c0f82e2acb9d0df9ebf4168defe601a24f85fe5df99916f084bcbabdef28d5a32d80fa2f0b2e600acab9d16645d73ef6cf9ca365ade7d93ce4c6d0537c561a073ead7fee55b4ecc989fc9f76c2ea3e605dd872a64844257e221630aec880c9bea6fa49be7091c5732b06d8ec42f3bdc24d6282f1554c85bd8b0e9dfba27ced64059f1eaa7081cfd9318cf6c7cfe844635b29c2374976782d06ff396b1099e5396c22b2aa28b80e7925e286b42a52f4fa65c3f7cf9d35857578d8c7c96b8116c824704676c119ec3d39934401a92c1b71fc261f9cdc27922b533870695eff7b33396347498e53082371654cbf36bb2fe369ab91d4f8ae347d739ea84f624730b94b23f32c9f5e7f1a124c8bb5ca3a8813563b5d4d714c3b763c0911caf3e4c114c29da28f6466547eeab9307b527af144c9c37975339d12a0eba6d6bd2d3bab04a8270961a530c70436869065b731bde61c82a38d3e55e587c5ea7d4f220a64e266b673da4ddd7bda43cc2d9c833709a1a7a24b44fd7c00b9590ea6425134a093decb8d8d73a5c802416beae1b2e26d72723272797639cee239b8d25b9c4b21dcb0d18457b7329a44ab3bc121afba6272a00094f7ab73b14f6d4f78a32febc3f467b8b4d9dc11d523796b42844c39e8682cdf971afc9a517e62fadb7f60428567a9bf488c1e54526721484c11d95d03d79140b4a93f1141218c12c96a2843c1dd3ac6c0c84e3e4d3d9354e2f9689ab796e5a851ca2ed4361d045369d1b57eb595b0466bb8f97498f584618e11d9712dec5cc797532b224c08e181e4c995f7b9ff852260b323c1ab43c8b3eed59bb1776bbcf3f967da01b320ea4f1851bef3de0ecd8078b725fab0d20b207adbb65e6baa8f34b65867fe3131e3a8dccaca228a69e578f61c5872d9197df6335852297f961b80d56c33415cbfa45eb65065d606a620182436ea232234f12ca98cac1c3ccb95febd2616e740a9393ff6b868137d3f502e3e83d3f98d6c9fbfb0190158d9bf7fd387b72cda26805e527eeee64845960281bd188d8bd3bb308523c0147ef94faa6844b3611e4846704d67878b31cd3bde0c8bc3670fe52855c2d9dcec79b353e183f0ca56b853f0b517582908b04d5b82a96ba59945d1fcfa007014f073b0ebdbad78129f8aba883105dd3f57a41c598db2bafd8dd3fb175d3dceb1fe1aac00b5588873eebeea66c032acdc3573b44e0a7cfa74cd7d319de580450741a9722367ea722da89285dc7af05bc4d923d683f6df1d3f68d2cdcadfa16e498b99485b4e2ce17d3de7750a1cf4c0037bdfa1f99b2d07f3c92dd9013eaea1f465a0417086da909bb107c6262f1bea41dc7adf7bc5d05937caa06fe97fa07cb8cf0a8106d37691739776578b4fd7650d7021716860ad0913341e8ce64203d9d1ca269d57b62f08b4bcd113eeec18ae2c453f9e46a7a22f1d29edcf1a36fe1f3b98967ad80f5ec2cd62705c0787676cfb9823468cc9b4d193f7a2693f9d4144183e4915bffce4e4afef1e3e72b927dd871cfddbe963e636e45e50ed2b2193e38820c99ea82bf61a0665571e35abe9f77242835d83ce9602e606e109aef07a1f03bd411e3edca5a74ad06bb6e07500f39442fbe24488b6da2850529743c772bb47eeed2cd9c3ea8588e45e9819920212f23f03cb95fa5b3863175d82bd74a85f0f09ddd5d587a851ace8fb59909053268144e53a84525b09e1e231e3d6a5150df7a626c4d50082b81a86d3240d0aba93d0d68c4d56b85c0b8de7aad919c66321c9d2d6d2d292f86aa7f114fe4561eaf06c670f5a656e70a4876a1bfee8fec53056a9832e56f46b38fd5a670f895b4547f81a543b73e31faa85a170146f7a660683473d2ae2d1fc6eee81f20990225776994feb02b37f48f1d1efbfe9ab69f588ed2e1c13ce5822d7dc566a3bc7d79d9327938efbc0cb288a66c22c818b387d50b0ed4c349f5d67f007a9a202fb4780af5b25084fa289b6a653bf2864c7a15898f33b655e6d562fa45c7de7ef237aa6d19ba5d9a87a0e2cfe0f11c553e86a30e21138d99666e9092342ac21ca011d3be4b5ec345ab8e818064d615c5bc72bf7a98b223e07f39c4abc16e12b04ee29a7a38459a126ce9c8647375e01d0594e74d09b8a99675052504a457a14d94b0f6656a3a223caf92ab233c2a0eff6c9832594cbaeff7d36c0b0c637c2708315547a6476f4746d47160f2c3915993effba7240321392bfe407fd9e9a97de9bc03bb5521acb913753c2d4fc7cbb6196818ba92fe472242aefdc2e703576ca94675492721676171520d92e5a676d70cbbc1089eaac5e6066818683345470e0542b5883a55d141a5b1b00baf39e30b2905ec34a0344204f084360306912ab1b9f8710384a920c58e371026cb9e7c8489350ba53e2ad1b147d7bfbf478be8fd5de60a4446a751ab9ffbd7c2a92f614b7634c7706801224e8d0a8ae3ebe63d4f43fb3fd1338e320f3908c19d633cb5ed9f347532dc4ea64b97c401f9598c2b085083171237785dd6edb20b0212e2dcce7c7b2a20f09da95a1aa3b11c0824831e31d8c813211c4d8e9464f4afa8ac1754e42cc01bd9e1e2b0dcbec2362746ec538f81649e0c93f433563adf969f4df818fd4bb7b7cab62813795ae5a7ef73c172aebfd12833e5d6d7249b59beed701690a80c668337998c40062f190e69e706f026805d3c64f535a83bf9ade8bb07bfed6045bd18a600268974c3118e9f8b24ab3ed9c28771b3ee38816698c5cdaf3dbc7502d02db9c912d1853fa05e308b06a3f5c32495a33e5594bcbca386575ea25eca1f9a1ceb8298af4456280e8af5f26a71f0b36a5e017f97fc477852b3a2411b2cb18e66efa467455647c0606954b2479a1e8c61c0958ec67535ace9937ae07a66e9d53b91c7cde37c713f64ae3e3a6607b9efc0f5dfc0e4623bc01c9f150b2773974f23afc7fe2a1d665a9e0291ddf32742e7bc6dbc61bf3bf78eddbb789fca4eadfacb3d59aaf11f4f5fe38985ad943225cfd8d17c65431f4d82a97153195e52c488e972953096acdf18b435793dd13d2fd70b426aeade4b1e890bfb36d7a67e9f1e2faf0e4aee1e66c911ac4e9206d55817670250f51fd52b5c4e7ca0561bcad89e0155e7305f05594d81a8a7a652a32d6f30b963ea40309af472dfad0bddd76c2be0c310fa1787af16d690fb544e96886f0de21c2c4c6c4d2d9a2f17a9ed974132539923bb9afdc9991ee7231063a2c04cc7f9e032727d5b6a38e4990e7fb2a1fb3c7328b5e038cf39f882d82c09ff5eb401cfb147c06c14110e3721f2a9bfffcedba3008451b3a61dce8bf3dad87780ea830417ce656205deb39893dc24cfc86c8cea3183e1aa66675df7e1c7bf59e7a855c833e2fd2e549eaac65aed4e00a7e9825d8869003522b6802a775bf62c2fdd5c8a926d4736df10cd4ae14c525347bbba39f78f98a8f87c77a92fc2cc8e13fe46d3adbe9e5bf7cd60a6f5fe01a65ab904d6ddfee4d0f3512e7b8e1f51fc4e5901b4d0b81499ecf213d2918eb629b46b1b30fe0b5a3b11d2e1bf10f9821d7cf41c263d353ed1227cf49a44be0052e49d11a747bbe542794c542cc295bd8fd7c4d140287ef3bf093579277b70aa29b7751b598b03cdc2685181159472f8fe50a0fce4c9cd640168f0b53677d75d361e21ba2188eebf7d2890f94b8e77da81204be75ca0579c9d85a85d40102db7cc0b1f89b6a478a479a0989e27c27ce3c55ebdee8000650a46b305e6027d99b073f9c9706e38491d16465e7331f866543cf9eff27506080f0527d6401c03df7589fba29d2c97b0e2c59434aa39e7143e3be0fa85cec8c6a9e226e55f840c9e36651c37a47957d29967bb0b8c2e7b876555efdaa767fbabef0380fa1c1fc4da2f516fb9599229b6209833235b281c6bced6d349b08b50d1113e74584f8639cc854243ca8ec01bf7cd0f5bd7b0835553c03c726b14764f2dd6b2462047a35bf6229f691984db048181f551739878eda8978a4b938a559b79faccc7f4093db3236bf3389714244a1cf99afdc53fa0640fe15ef30650a145b7f950b79b94f1808f7cdebe69357935c079fd6a0e829e8afe040a92e45df148237de710118931416394aaeef5f76df756b7d43fe954cc1b043bb7b5d6c91a596396603e105044ee81a13a04ac075cf724481959dcc3d80b045ef7387eea07b5c0d68724b1fc59f707bbd71de342801e5d5a3381f0049bffa0327cece9adafbdf8326b187566c60901546227e9cf6e14b5687f625508b743083a82f394316cbdfa83fa5d720136d3a60070ab02195c95dc318742e1d144438e6b4b440e03d24fb2bf92f561b2e321bb92c28bd877020669991768bf9432a51d24f814459e3ae016264c835a10762f0d54f167692c9703dc7d29aad36566fcf698451e7ce24cd28942982113e29e603d436e18be4cce3b4da4d9af2b6c16e4c8f7942d9caa22e38ff8e257b5b588bdb4b1bb092d2267c717f84455d8a2b6315845d6164d9794478ec4850aae6ce629296663b381a7af43d7752944f91214c2f7e78994082ac59e4779bc8dd3be18ac771a1a5acae01c2ea7af2bc07892d393654b2a17a3e8e090264ce7b5720ae5fe17b2c4892428f6141a13f6cf2d57cd1cfaeaa74790f26aef544ef24b453a99113bc347fff03a37828b9991efb5055e561442f73291e5436001942811d2fa2c5286a76e37ad308e81b5197940d5fc070fc9ed20b521c4a0db47bce36ee8f2c13d69ebd686d941f5ab9ad57821b0cdd4d971c7c2d5119e2d0beafa82345c7463ac7d2723ddf590c350bd42fa5a275e9844fbb8fb9fb57a476e4b4174e8a36fae2f0be79d73b694723fb8d61d2cb622d89a37c2286dad59e247ee4c97114bed7e7a671d1c5d895d56c929b0f22338d3bc517b4dbbf4bb9e7890b5b4c9fa7b5d0ed61a165d161646321c0f34073b696ffee40dc029a520df5d6fff1baee3019ad36f96cc7f6c0fa18240ad54d508fdfd6a0151233736ba9a89f8a876d6a7a212da56f61938c56b9f1e844a3ef4528a08080edf37f5c5baaca3dd4932a7e509ba6c472dc4ce0323fe2781d84ef0c7a353c4df147d46bc38e3def484ba5cc23d6330425c67aed545c9471d4ce3354b0507646868f9e3fec2ecc05e7e744852963527627fe527a472923b98d0b9afe6e4cec1dc3931d10793f4760917d330b83c929e86c78581b24bae9143e7908ff87316b48b4b2c4e45ee5dba797a9d80615c969cb2b4363a43d0a32af1139331a3d159fe525cc5b82d71e0f3fa46de8dfc5cc090c950b2b88565b9f3f91c87bfc5bb74a065cf00ce205f6c502e898490f2c6a914b7d5827d9160004415f5f17440a7f4359e28041fe4c04449fda8ebc6fb08cde86f92fea6e15db57c17e50d5c8bb1da7469120d2dbf495be13e1fb40dd22a3550fa8ad264e01c46520ef361e8a150b2523907c18c1cce8408dfb5d75c0a2139338ce62486d432d64c4799d85ee0844c7053378dbb376e1242362a24cd909e41c2c1c73a0dd1da6b3311c984d7b7c9477ef7b206e2941b9b0014f8ccb06b02bcfdf70e38e41f49ffedb1b836fbdfcba766a5ca23adcd2b9fe8be6c46ce177a25c193c3b5543836e985e266696f405df7cde48700fbda68e3dcc164a16b70cdedd57f7cb8e68cb615076c058a30d68d0c5498a0edbeb51671bc00083b0bcde80e259770f8e71e150c9600b07b2ed9006c3ab9ef11617be43db064305b354b472befa56ef08ba11c38a5bdf19c9f17bb520816ae7629c8ce86613d9a18edad1f324624db7219ab21cf651960f998d69d0f8c1a0384080c0421156a3607982bed3423b52546be14bd571b36198cee9e37e2a97f645ecdccec3ee361e722eb0c8ac31b5e350c2b94563cf7eeadb7a53cdb1cbb505ad8bcbf0755ad7d2b08a81894dfadd19960d2c54036d6305cb7ecdf14351436a77f80db5218067f3de96b0fbdd23e075977e831a20ca2151cd1c7fe49c5030cb97fdf3aa52ddffe2a26c16fb5c391a21c2fbcf7419f621124f765f7c2e1a794a4fdb87e835ac053635519664bf113225c1d7124fddcd35be8f832215c233c6b6ba7bd4b626086c5b81ef336ccd2bfb05eba92bde7319f82df974d9d64999f42d0bdccb2330dd99b1f23714da3c40572384bd0ac76ca223c86268d120ec32b44d60cce0fb7c9c0da63db73ae1a1249f8968b6bb9acdca1ab03cf222f0cc9f08045f62cc602374c33c0c96e18adc276f13f6dec7fb77052b64364e7ec049b2b5916aab72415cf504bed5b188d66ee8019bf4395390710b4e11273607cf792245cd872f3b29077da36b2b522f4a47c7fd9f1ef258b07f970f305c4549a36ee2b38b45aa051916b9df247d6a96a81b35700ae570c7c3fcc0c3c5ce09b1dc6edc0fd454a2c7f4352adcb6935bd0fadedf43036bd479e59fe1432e81b1fd6c1fc5a4b9ca4349aa89966a98da910e5896d5f020f29eaeaa9c908e9277c96462ecb83d8bb4aceb8bef6b669ddfaf3a5f077a105385be69724ed453baca3a5d7f5d7c7d48410daeae6782f47d91093a903c50bb9cdef5c557f7fdeec3a9dfd6d964c66d74673eea4b3b39d9205b47dc98887ed38cb33692a53d3b760bb0b93ff595730fd2458d697976c5ffcb38361bc3cc003d472436ffe0bee5c2ae3336f4bba43b882120bdff41d498565991bbfd0a88d266e8c09e95a0619066d0c6cb133498b435a81a3c4b83aa624f53d22b1fb4ca3da601cc4744d845b07f6d2d5cc4cf3a2fd9d2c75a3e26715a9fa49970eb172764c7503a4cd346836750e6b6eeb5db0d522b1d9023d85f6c72c63a9ab54bc8390cd76dc634e81a37bc2df5af87b48a8cd4a42c58ccea122ed281d7bd9b3a0cdeb4c5ec62955b948e2a92234680eea3bfe7a7209b23c4c2efb6cf05ae72d029e6efc7ac4381205557b35ab693500d4f463476ec7b0bbaa2960d67cbae97ea4c8ac6cebbafa636f26afbfb0c2fc6c4408840fff9a21e9c58fde55a942d971c2719a80b82c7edb0003ca48352085554f1fbd48133d2229562e8a37554e9854db81b62046e483fc09cf7607277ae6185e13a86ea0fb3371c77cab66e0efb90bdff1f4a0996b34337429cce1a3591d925df8a3875590eea645ec0455296e777c32e7940699f8f5fe68460b4bbd0765b53071490b893a8f81aef4f306cf63714cad7073998df86c32110fa64e47cb3173ecb495034f402103cd9cb0d4fdadd22278954ae768e61c51afd6303d8d62538006f7fedeffa2be9bd621832d5c6918a02f7240a7d99cf86fca0149e3206a2487e082d97a0f65330fb83f3a312d92e79ae66eb3e79c031e5fa54ab7b33756383b53a7f48a48b57c17df899509831560123e83ff48d4372f4987fb7a46ea098b4132bba608d2ad36ff2ba3c73b336d9296f6e47438aecf541b5120a492c3941f396960253f031699b9435a55e6c6d1cceb4bd60a757b2effc4a7e83dca1071df9c6e0316b130cd89b8332bc360ec313d01c46fe632a874c0cd1b592866da1e5a79b79f149610c46569e86a14728e54fe10494a3e179c6aab2047db2d626ab6653771dcdc1b4d1d4a9cc9395faf49de3fb22c8f2f7dc2953c3b9f95158eaf0cd62713f34b6d41afe08e570fb86f6b27f1594e0fbadf2994923242f077defe86014a96830e47d11ed9da056ae8e0b2c80c5feaceb5afa1ebf0390599e64ce1c42064fae628fbedd58cb4d1632152512f5947c4dd28dcad6ea1b1fa06fbda4f230c3cdc298e1c5fa24856b25b796e693fd9e6fecff9bc51557874df5e295de1b97e52e837c2583fc6413628c4b6d425351a7552eef9c2ffa3e0ba865a0ed3ec37638a240ab40f7d8d95ad5ed1bf58e705a3f5c4dd569cc6a2c2d27f2bbaf9b95fdc042393cdd29c9aa9fa16a72efad38a6dfc0059a61671399a0db24d283f01f2531beca6a8eb3e03ca3ed8a0d45d295384673e40d3ab046970efc8603f483292631db7e6b1d5773f9b3d5647013aeb5310f5ace735a6456193b7fb9eae746353b305ca297209f50dee70405a72971b350a366e82d7c7eb207355c81c4c9a9663c68bd62c502cff11c0be06bc457520ee60927aca5aec63a27f718907f5f08f3f5737bd19c0f88822934fa7bf2cd12f2f08f44410c0ca31a508054e92eaba7f4f2707790e223e77597f316079c1d0e4de0f858887cd72f8aad34dc58acaf130fbf551fd1e28daf02d856b2f57f7522f3d6aa0fa30875f656ae1235334c810fef71031b3945dab9cbd077c18a06592abcdc8494b83c63133f288e03419d71cd0377555d576b655e13dee3fb23fa4cfb649609c7e97af73ea8d753e2f0d4498eee8ad181fe4ae91811516d3a935f96103848a176037c53fba1231270e","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
