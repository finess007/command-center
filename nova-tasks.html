<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"05a14397c55fc3384ac1ba4b206c6be4a556ceee92f9f7d078c3078302b76cc734972afade05214d7a57563cf491d69b4f0d587af1cf260a4c14b561bd57d65df4716c1b719eeae276ae1c675e5daa93d096534f0bfa014a25082292a19355e31778c0245644789794f5ca51c27973709d9f7f57be34af1d41c1ae45600f0373fb095b34cd2e62c2a71e05ab19c62cea1538d6c500fc8e89347a11fb400bd1e767020bac643ce4cda01a948d04afed89a7d058f262c462a5565ba65602989267506661445575d7837b6348ec51724ed5d485b18c007f767237e4a1216b9daebc3071c0f968186e26c1ae688095ff123fd2c0787763a10901b5341a73546865bcf4402ca0afd962c6c14f11f9f7d72ee49660d931f3498f7d3a8c3fd4a76d3462121182f64b29e3cdde8f6c16a61e4fe20d18149b8b3c3706c9cd5b31a0c00564b0c338d49578c3f2b6f3a45c12262b62d5c2497e10fc8886b813ecc9102eec126f7bd14ef1ddf3167056117883b3ccb0a5fef4008c343333a6ff69275c2ead8a1605889845826cdb52575fa4f3790faa4fc2c95e4cbd8fdee5e307464fa13388eb3a79c2075a825f00005be5d91fcea4dd43bab16099556ee7e4f35815ab100e15b75e892cf93561fc5c3566df1d593cf5111349aa0f1a40f2c2b458f8ce1ad31f0c0658f738f3be00289b94c1fc6fa7c81071131936a33833aadd78cfb4149e0268a981803058355f97c3d35b561811d0f4442278f6bbbf4390fb1282b9217ab5ceaea6f5ada4a3f3920d52d897183377aad970da768ce4cc4fccf85e52b4463a986b14063d97de39dadaffb40d93d9a6eded1e29a703d90ed81ea8e1ad7206eb2ded8f4fed0df1689c8dbbbbccf54944d0947fb80de4530902ecfc5a2a55eeedd8dadd261e049d3c7d2abcfe90a279f0036d0dcd0c8e479d272088464a8e6be6c2ac8ed0447c382047076d4eb61c26e812617ad9a0f13b5ff81b3d9158c91187c7ca04257ced241181b102596ec82605365a4086d8179c462f06810f507ebdce8a45ab34b6a06e862ee8a80be7a641ba62f87292a89046445a3ccebf3a01be0400ae45374daf7b7b91900536aa380a2635695acf7c25e13a37959e5a56baf2d60a6263172f4c848d86d57963b0023daba0b299646e8dbbb2a2ff960a38fa949eeca48db2ef4a20f0b74851db9093ac734e83abc011a4c55aa0251cbb526c3cf401ac56677929681634c31c6eecc17df69259ee0ce3a8379f5c4f4e054799960e60eeb0a0790193979dc4f7e0f01894d47673bde7cc030aaaaa7af539476d2aa0dfd4e87cd72e507b878579f5591790de98021663650f87e782a108ff734dbf554519dfdb95ad6b9247343d15cd48be10221ba2c2b0a82941e671db919d658af869f89a269804dbd3059a09dd08f1b5ff6b647347a4ee5182207594ad141d1fc7fad8acdd8390ec86a371803d548f652c989d729a4f1b779ff25867068087b699bba6f8c92fac4da0de713436362bf005022dcde6313ec0023ba6f83fdafd75cb1b1f0f63490d77c8128cb6d7d007f8d2e308b86401cd1674758f12b343c8e621d5428bbc07adc525ef511763ed61941642283d5fb8252d3bf3454a987f8ec0269cf6586620cd0d584889ca834e5ba652767b6d17c10850f7a6e314c67629572186d30bdc15ebd906495845771d2d5c0c7ef27cc949d35742da3db73d4b31b1e9b6d9f2823a5c2d92309468e3922a363638e8e98e543323588231caba235bb96753ef7b11fb3c55e498410a82e44acf16c8943e7fa42bb38e4a34973bb81e4a832d9eeaf46ffd116e977f14626c8fe7e94754a0c63659fd3ee1f560e8306df69c184629994ade79418bf8d1e11b13626789954b48da63f9e6a599ae9c787e1a241bd1f6712af4f97e955fa2713095c6cd79b452178386623d0ddf00f5775593b98b8fc259fc8c37a7a0e4038385939f64226c1c520a66cb414ce3c361015775b0ef2283eabc461c99b70f1e7dec7a328bd61da5458bc665d8ab5a44b92d9e6a877a07cb3a18f192308721bdbad00698c689500faf862c380c8b2f9d43a81eef0b475b0d3dd6014656a340030617dbfc8419e99941a65e1efa1af1bfb071db9665ba13232dd37c8820031958b334ebac5aeb6d35c374dbc1b8a6613675d73ed37e1d579a44e241c6d7e6ff3cf62603171205eadaad899e57dce3c0903278a39a392ad1938c27b2301c9027298061eac9039a5cdb1dc42bd71dd2950c5f3cb0bbf4847b6de6ee12cf8c7bdf2cd387e66ccf45d04f6682a1ad379164d46dc502291f5fbb46805158d50d8bc74b29492dbc590707ef42bc1ec41ab28f200e02b58eb157c1fc7ae672e9580ad493d654d526812920d6559b00f0052bb38ad47c3443c062ccbfa1c1dedadec19768aad0734f9e1e5debbb50e127ac8c7a0f7c46d542d2054bc0c9e7df886eb6a61a2883b66066b9aecbc510e76ca93fd3f1a4c5864a4218edc487088630deff22d38b8d75f55ade112c8f5cb7239804a44318e5b92084b2ccf8acd58d87723170ed4f8e9891d53d7a4942d96de67d2c66e46ab3e4397d97ce4e469abcec66b86c2788fae26633dd919db2edcb772848669ff197e1638a5b2a55fe2d2d71c2ad8dc916aa7f5ec06f70e7385db684b31d7731d55c8147567fb41f98d179344a06da7ec269e97c7ea58fccc59aa9f5017e21550765ac1166a203b710406dd243b38d84372bf63993f733f24130b6b2a56e97dcea4c6f36d27778545cd606a4411e5cae9cafb12820ed9c41c79603f8dd615859e6d4e78671207cf9490dc25a7284af379305838c99af2e104223d93eeb9d7a2bf079c198aa110ceda9384a679b19fb6943c98436effaf50f8c4a58a9633fdf9f65e18fb5a841c9c5ae69dd0b51efaaf4ac9f922ef4a33e88a317bbd9c91ca6a771d36d458c4915dfbfd1df51b5fa7a4621d80ce2603fa24df5aca14fafc1b73158783770cb16bf9c5557103498d855c041404e4b53aa70eb12ecf41f15b65ae5c7d91a35dd3dfd915b83c49887f8984c4f0d678328e4e22d5e8cca8e4df9ae340d629ada1a71021b748a76aab71f23cce2d9f6e04ba28a9eea54de8e61e6c283ee6f5be1669ffc9c9d40911910dddad86483f6412b1149f8706bd4ee7ba779d59f6528625262ecc81356079f0e5fdd4d3727d806703af6466842c29fc59dd064fd6fdd16e42e9a94b97293effd61fb29ff662ee8a32c0ee5e84b8e3c8d068b0d9b73bbb32481165e81d924dfda20b9f3b53da55ecb4eaa32ae96e2d5505be506527e854aea318e184d15f2dfaa680b3915e28897478831445953bd394a6e4b53f23aaa90eb53e0a5272a30bf895edc0581f2b3e2802dceb6d2ed86f36420ea6ca9da45060ff58d364c9e4d4ad4310e2e874f3d1cdba8dea4f1dc1b8efc1fc2afe27b7ba3529c2b360483a877c5edc2be99146fd2065af63886ee06eeb12dc111ae6827f552e2405f28dffc376b71f290652476d57dbe71c8e45badab5635d0b12f3f1073d5dcbcac80cdbb9e9d476f33f323e4f51803156425b8c687805ca165d139a589b3b918d76d99b68985745c5c15fe013320730bc54be16db8404284a313b5a81b1c60eaa79da82660d5006526f7a7e3e565a1e6b5a8b038f5c587bda2fc6e4fe0ce88bd159f5c85f5cbc8a6c773c0882c38220677bc15f44f3e01e404bd9186708f3f7e9df6e8843de0a24dd7d0f613ed544848c5565335cbc25aaca58547481ce64ca000e0a9ab24be591daa3b4561b4cf8a26570ed0b02923204bd31f9038fadcb1f2cdadc04ab7c87dc5bb921f6501f641e1647d525a47d65b1b2ecad87df67f9867f2135f985282a8ca64a150fd8b74badae6b66441dbb8e05e9ec364532923342892856a9255148b8b5df88db5039a7050aed08f7fee980f5691eaff047cc937d08173a3388cdcdd49935304f4bc9c9f7ad85c6dbda919a02574551b36a21585d1eaca9d17241b5b2a8b5afed220fadb1c203fb7cd14936424416ca24995a341b30717bc9919f23ea0cdf4508e2f45600672ff9e0972adca480b275f7757d8bca7ed53320dccd99616c1e8c7d732c72690cd331e11b7cacc59afe87b8a887581cf710ec943e97baaeb81ba2c77cbced4975e2bf2f177b011d16fe0762f1a3bdbdbcfc1f79cb458409825845889045beb5791bd8f07d23071d4af4153bdcf6f432c7dbd6d638410506dea5845b19beceac6b96f771a63993c365cd136a0d9d73ac753fb173ebdba7c86006a2d15871765297026417d7701aba854f01d538cacb5bef1583da1ad563ae19c668fd4b1e0c875c7d61e2aae5a2cdaeb13c3ce5950e9bd754ac7207a52048a9f8c5ab3f85633fc8fdda8fa341a871ddad3fff8bed1e28b29296923507887d222cd49b0f02a96c49167cb424ab55c154acc5ddaaf13c3485c610c5d9c3a161325f33142f8dbeb278b801c37bfb8e9aecefd8f869bcce49fa04e4b147c8490c65737d4b68bae13aa81253ee93c76d7cbfe0ba039a8cf1e53466922834f0f52cf8d043953eab56cffbfca1f18c0bee29620067b814984340f2e0fb6f223e5ba1534d2d6192ccf03e022f78c93978282ebf6aa1e42e1ac33e83b77d2ec1d1ea197c79012be1775e657b1f04703bc80535dc5e03dbbc297d41066f83ba4b992e1d6426782ba85be9742a017d00161b6032f4b045d560987a23dba4abde9f92d5bbfcc1a71da64ee66966d4b17436f1a69ef7a75f88f4e43781107dfd83be3b55e8ee00422b5ce860132526769dfd40ab06f2559074e069c20cbd986ef60cf146c7056af4649b040b4b9cd0f21ea6f41741a3351e087477db14df454fa6cc2a4f860625c78dbb812cbef9434e2ceeec9ed03916a220c653192711f95505edea2acebd1aa6a6a95bd3eb6b0dfba9a8352e1653513a1833c10f71d15982157c36f06ef42049d4feb8b72ab359294e4893ede85bb8012bb01e155c02e379eb141eb7546adc50fe2897cc8ab11099ad6fd1956ecf3644ea8822079422dfcb7ac998cff73bf672338ca2e737b64d50baa53d419cc52513fdcf685b573a9110448a66a881a739648f43482fc3b8e7bddfb08912feca9014cca8d58616890fb0719d31d28f8f6ed07ca87945ac5e5860e9da20efb2c7719c4b1345ad5385e7a18af7c48f20961b0fd053da669c229f0d77f59fe48ade8be62387e6068e57348ba2b38815836ab35bf7567fa7411c0d049e95cf3e968165a7162d577492bed55040becfa5b4881c036742d07136c45911a7623c48a7f9973cc6eda70ab3f82de6844666d64c9ef92df9309746efc3e200f9e01382478c6e58629ff73075bb4c27d7d3aa6d2618ba0f25f8260fdca10d422f6f18e464e61b02dc792b9bfccec463b881e28ab95fec8f888a605e6d660e1249a72bebd528c0612099d445bc99847b59e1b5d867720f8dfe012b6e50823793251fc71aabaf832dbf7f48f291979aff3d6c55291a77e3cacaf37bec6c576d209a0f1a07f6b0130c2b34f9690f7de9cd95e8342fedb3b4bd9a30298d4fcf09b5412b8042cdb0c9775f4f40b7447265abd7953fb3838b1977f018f7429808fdc1d0d153721f220fb07fb56543a6b69bc8b8f01918f41a3a7b6c9a874d63f895bda6075e657fa78eb94396e368c523db8a49b0bc76c9f2dd0cd42c68011e5ab365748a32fa4c2c45bba32b51db65a26f9321bb2b70134c368572b52f40749b9795b0150d7794b3191f7fabcfcb3b9d3d68d77e8c285a11f51e9e265669a1e5b28e42a14d1ec24ad944cd3ab80c940f3c5490c05687c360c8f4f55d54b7eba0e7b26ef3dd25d88cffdd75539f0a7c227855207eb974cae6d921cabc385553131ae7f45ba407e676b8810b1918445ed32bc7f348257cc75c5cfd900bc6860e9b813dc54dffdc0c2c57446ecd21501244d56ba546083b5e2cd74a6791a436cb1f2f8a8c8bc99fadbe8c90fcbae16dee197d7756bc909cda720090eafd688837cd486168dc64dcdc91c8fe3b899cd8f24c5590d0950219791b5975625fc50434bd9ed7bd5f6ec8158b2eff460f9a505a48b2631a5ec8470dd154136697771e4b2752127aab3fcf44458b9e5e754ed4288bfcdf5329ec6455ea918e3d1222472139eb5cbc670c5e18c969f1272c4531009a605264713d7157d9dbf6609a748a2452ce17fe3a1e1230dcdc8f6ced0af5a9c5912f51ea73172a5c3e05f675097f936e42d7ecda3945d1788610d3429a079ed58e0050fb8fc3d9d6539907dd520a866560343358401981319efedb0c5b18bfb4f41a4d8bf6ab195d37d52b205a3bd4fdef1e1ebb242a6659a5937bfd3002c5f34c4a9a4afe6fbc377c8a78e13028316cc6a9564b26610e167432888af4d0dd4ec0c89b273cefa42470c662ee68a4c62471dcc591c2717eb9266d881fd13cf7a82e54535169b6dd2d602c120ae82c481b828fe5d2fad4302b7f9f33445833cf8d3c695eeea6e8572e2eaa7f61ff84e161b3da666f8e865c4a2d7ddf6f8e2436c85f440597c87a568b87e32794d67703c8a76b02aeab5d259f2f8874958686b406790a4efb55527493a542d2c189156dd418773e27619c3ab7995655ac4ed595bfb8c805e4e0c9e1c27895cb661ac942c1f3cf5559478a797ebfc78fc0a449cc285511aa81452574fe14e39f599f32bae2d47d2bcbbf037e8e247de6f01e982b406ecb18611503c67aa76f2045d3b1181c2d9328b03b31c0717725407c1ed6d9d399809a6dd1b25c531342ebe7cea311973318dc96d25da86996b59ef90c5fc99de981a1929b6833fb4dbe804319e2ae99cc4605e6921fe4b63ba55fd25fe728f3843e0774a22244c140fd0962ea0ccb6ed7131e6e448146e19b78749bc245256e85587173a9661ae7341cc7c0b6710fc3bdaa41113cf86a734a4657ab723ef26c9b5bc7c1fe1ad83550783dd923ccb7f5454692a2cbc69adcac4517e742a5e7fc5a9d51b531fe34fbe100d9072be5cb49df240c37c6f1a1712965098b1b8dc1d905e9425d0dce6e65932ab2c74ea271a4c0bc22a248fd173a58af15e7a7a45054c855bebde0748608bcfbb67745fdfabbecab2977f7c3e5c1ef73e3de654addddb6391bb74c688ffe807be0e8709bedba743ad05d8ae33b40abe405d0080cd4b1a5820becb2b4c79d945dfcfcf1e36a49b556bd86e7fd03ef051d04bf4cb69b83334eabcea2334b0cd6dc6d02f0cca7c9ef5461568597575155f4a87479ceea27fd54e278bd0c03ad5d7b69fd1b1dcc3ceca89a3f18d6febca0fa95e6a0653e80a2af630ce4534f9c4c5af716b6787ce7f8d58e3a6c0eb166bface06c07fde40a0584effd36b3fe29ff09010b68e7b10671b63e85e296827d307a61df89ac722153697aaae0bfcea961b71e4a104509ba410737e67bd59b718eb3be17962cd9c6d301c7afa18a7dd06d4cb3b595859228a1c24a0ae62ce9a60c5d3f4854bc8146eb73059ed32d848ab9082129b8bb31c276497be2cf3bafc626a86ceee44ca887e072cfecb96d325f2c248ae9ba88448392454d23d1420750347a7ce3b207e0a32697d0fcfe365642b1ab6400bb9104980d3574ee986accc752438cf59577233f066f316d1738ad326638b395f89bb363a995560b87588e52122e444e6ad4569eabbaf4c1341376f72c5dee4783a3c6dea8019abab11cf421e4249a7212dbb83024b141d48205bed172872e7e5f7758738481af428e42e675eb33e7ac8cee6c7e58da8a319d905b7e4abb90dcdd70dfc382b42bc0e8e359a2250156485d787ab0a702097bae5d19a31f395aaf0d78ef5e9ce0fa47b28f090787e73b968db2d8db62636168c3eef1cf696f8af3fa02725e4db68848ea305c454181989dc7a0f56467ed36951febfd1edcf47e9fd9a5f354ec3ecbbe0c4caac5d314d9a25cd8a9fcc2cf38601cf7aca14376fac26676f293ce6361296fc28e19704f7984963281e7373a2544741e654f16ff298b7a094bed611b734b4a7b6a7a5bd927da82d59cf5cf16bfe9d42876b9d353277b73c2449b2aaebb5d3c40fa6f3a1379c7bdbb68e547e190414eeb2c15ee8dc6e028a553ab6983e66d07bc5d549595ec7c6760c5174b5db522e1034d4488d4d5e2e42caceb15bcfb10372b47ef75a7495959509f5b1573080999a8f5156dbed6d9d03d37de635c9a2010a9c042868d1da8018b113af3c7aef9383273d8eceffe4d3c21ccfe604f81c36e929175756668a8d7ee7e7c0bed0699ba6c3ed4f721e96080e7890029a88035c433eb1eb837ae739ab59147a3a31f9e6acf1153599254e74a517700e36ab6b23928b6825918a26f6ef02c3bbf84b4364f90175dc5284f54cd98bd5abcf3a803c5095a01c833668860ea99739b2dcaae63834e8200cea83df861a8f59d21baaadc2454be3dc4f4702959be87bbf2cf71dd2fd8ce5bddfac499cfd3c6e1f5152b22deaf4ca34129be387dcebf99cf5e5c05a8c8c965e6fe78b867ef37feabbad072e57a675b88e4aac2df7c8a2c185766c6a9cc7cb1adc8a0bed2831e14a1388a51a2875ad5f3c71e255ba516a8315a55eeb78f7f5635980d34ffb1ef76deedf44745fe003c075bf97b962f6c56554de5f650c9ca196dcb73e669ae5c417b90d20297f6f0293cacfac3c4b75c71975431dc0c5321f7ecf3bf616152516022a0b250fa8207c31b3da964959be6c85f2cd781f520f596b97868b66a26ceb47c317b41f25757f6c0498011ba04cfa76e7f527e54a5b7d6941914cde4717bb47014ea9c58da5fff35ed1573f2babb8b0fbf49a4bcd346299ab02cf1cef2ffc820ab70a33289e16ddf0d6d289677996791207a78dfbc1757ebd42eacc4abeff211ea45fc1ebb005a13ec84291be20d11492016921ff687df8979f5bd60d4fbecc77f8ab55cc94d215254f73de4749d1f90e06b12ca2a485ed2e7614429397bd8dce8a0be5238a9b8c986e0c9eed69c840517485b5928df76877e67589888eb512b4a096108899bc2221409c4b1be1972e781a84a087254c870607dbe71600496b6c34aa1d8e78809af7017393ac898dca9c710f1d42b36f2d6877a5b8fca926b1af1f21199ddf8d3d0c659eea1765c02d54bf6803e71d9f1154fe2bd9e786462a75d4f213a8c8ceaf8861cb8b3a752639b6267a2c5df376fe978494bf02c0cdfb17de1fa4dec7913ab2e97006dea58f5e91aa45c7fb75cf59edd83466949e34b6e7f5ff8ebf56362ea5e644ee3888e0d6b394a668bb43a9b6695883adabc9b1b0a22095983ff36e0006cd4110e8f9a4ac9650e5a73636aaa7087e6947e09c3f6b9a12d10392fa5850228861e30cef7ddfee06d1fb20a7c3792209e10965747bd1cf10c6332185a7fe87132cc9fbd5f1cf9b329dd3c7736edb9263b0b73924d40b4bd5896023685ad02743650b7e14b729aae215cc97300e047adadcf42e9c122d079aa8f05f5e66a7a32802635926f684c137d2210777213a0d2e7634683cc6e1a50de593454601a558fa9e72d633f7932a937a8278e6f962b18a6fa59fa8309f606c29bd16e8f2373d98c4742dc51f2e455729c055297bffdbebe19b8b60ec40f7b79f8cfd613b425389108483c830201a52da9249d2c647fba2a9bc49f059379e82a4b96064d1fab3e6594030d6a6382b776588509a0c67a8021214239c1f1e8ac1a5fdb53c73ac53b7da384d14615895f7ecdf5b78a97f59c6e6be21e01d471a8e03d0748f5f8546325af2e0724d0dcb9adc665bbea3ca76f4e2c90e16a384c938996222293d0e3bfe6423c9fa4ccb5d87c7dee0f5eea49b6f101f60cb527cd3305839687e67979b36ae8939975d47e0140fd52c861277cbef87b2a33cbf8879914a38886bd7e5bb2b2a3008291e692e502130459085dc3920396f71fd7f9fe2043a53f5c73980e9a84123b82415f76dc1d377c1165f84c01d8e8473f588b9a9fca2afa1e607665914804e0d2f949f364945809aef7fff47fa4961eddcfa837cc1774e7f28f21486eb7e9dd81faeafca11d2e26f6cfceeb8e2809eed5f5714f5d6bcd41878de056c9dff1d6026ce70bbe9c3595dc9503b849c24af4b6239537970e1eda03e58d48208bb9ce6554478523038905f308addebac589887d3a46e040fa7f61451e4a517ca60e4364492c20d5936dbfe52e49d3e69b8906131a94d142a91c7ef6364b50a351154ac49db2aebcf9dedf67f91e2ecaaef2bfb68c87b1da20007be14f3070f2e1d095755b68d01cbe2805bf9fa48977d1484ad27cea6c659bcab71bbd6badad107447351059b331a5ffcb30ad0d3678a4bbabaf8c88f839a9435a873565b7b08c289e612d106acba6c038d4602ec867664e70b5e33de8465d01eaaeed23ca940cd35fa4abe43ca1ca22e8bbcba7f0a0d436cab104a881a9e8e643af7bab73a10e22f3bdf2b6c1ddd851447469e0acb979aece62ad986acc1e3485211060f61af7adb8824ae7237b2959e466c5fd9d2ef7916269195b75c38ee92f141edbe36075ac0eaeafd02229c5655db9a4678cc660a43365da437512cace62ce7f68d572646e5c725b0a1d54b95f55fa14b306be443d929e413b71cc31ca18b361e944b9955b6cc47091eefb7e6f9d60c658312e700c3e049d92bd1a3419c6738854761a7a32bf58782b6ccb84fc4f19e8922ea88fcd95b2c8f4811ed2d72c76b47a4e24a2bce4f70a343e7aa2e6f12133a3a585b5227ac40f12a1d4a07ce7030acebf21e8cd2d96cf87c3f8873e73d05de0583051c3ec389eb89a162abe20f9f5fab7fdc039ecd9ec74b97056ab55cb3c16c8f57761b94360632d3586d3362b8e172fa3042cd20789a1bcb675602a62efc3bf0d7779ea2fa0503d7c0d42a0b4778d58b4f77549071c4eaa2a377ab614f6f3e59c1914564d8e028ebc599da89dacf0fd00b050ceb96122d904f2fa7d0243075df36d6d87a862510c9a69cd01245d3455bf07d8a85ed8ff6b53215dfaff600b756fbb33a65f058ce6b0f3903d27a3166eaa4d60317084d60278f3e66875a6838f43afc41eb48f68910f23ea06c2a2daf074b999bd94e3273506d1a8ba2b4de12c7aefba758776f7a5becd6aac74db4bc94b9e6b5a6b3169a7bc984ea88959e1e6c1e7e39cd2e569942351ca5fdc18857883288cbeeeaf0c66581af5fda7b43274d75940668ca58d5e3eea0cde7cd288784404454d82160a9882c9797775d83cff2a923c8dc87c366b5a49c1ae73c4a9c6f0db456989fdd1aa023f35a739995214fffb55d50c10cde0f66aeb3bd12171ac079c5e107493ae05f043ee33aa6878c207a314360ed576dad758dcc35481cafcf6acaa1185282deef1510a03cccc1717c13cf68555139c879abf578bca6afc1fca32d42ab25ad8e55ef22f09b61835659bdbdb575b9b88163ed191835b3e5f1f0b496ed068365cf69cab3036590a5e2d4d5a58135d88f1504c4869deba3ee0dd92e95f2d3393a45afbdb8abe9c197acc0c0378374d5e1f24e7cb8e22f4620739161d9fb216391b4dee1b1b97071ceb1b0cea95ff268f31831c9cfb835d1f56f1d775bfe62bfbbdd4964e76c2e83100ed8b5eba343ea815359b75daca6fab15d75acdba9b37c4566c5b969298b24e987db8e645ed87097ddc91f139f967fc5ea350d566398c111159c9b5384287c1c01b426367bbb2b5a2d8e903de6c1e3f465c83ade8b96be3f8129b27e8036068fd704d866e8cb422b30a9100ef5b66b82442f8b757af012693e01e80f972573d9f0344d9a34e9a132cd028d24dfd21bf5785bd1c157f27a5fbd170f05f0d8ab0b60bd25a42407c9502f2f555b40004357f897f3bc32277ce02bc0045e3e3d2554464a5720b4011e1015a9ccb703dec4820789a9df3eba2effec846962de72681a04ba2228fef2ba40861a9168e6f30a4d801d350ef1a720004c4ae0f711e8ee4c50526725e6892cc3b58cc1334ead9d127279d280ffe119463585b655fc1ea2fc436bc0ba24c9a3c7b66335c85cd735b11038e92daaad9b497a29a30f5c0af367259fbe29ff72650eed1686b4206d9d49e1cd44153b65c32d97f18747d203f9cf99d0ae6a0f1dc544c6027b6869890b5a12c8260b8d111d911699b18ffbb99f0458cec65cbcbb6b49fef0fbbe807d55b0ffbc6789646a07816e1d3766cd245f9c859c24f1783751cad01fcd8135769204c184b106a4ce80b8403d543cac9d3adee3f47d6441a16ff94a086723f1624c06d3ee9ecee3971b761dde3a4ca3ba453aa889051af5487ce684c795508f28d2b367f90a88d6de5064cbeb8f25fe948fdf7fc298dea268e3da9bdfe7d32a7dda56de4bc59cd5b122d41cdfbf5ce77bb3d23a7e10a47298f463454d135dfb731e5fcf03a9231c043d891cc9c36e739c15254774782b9f79629d08825b67733eab9bc5107a4b87b11ec9bf10f3967acf5a4a84c97114f1bb164344e4dcfe6b2a9d3f09afa40c4b8c8f7d081bf151c227e469e996a8cfc3af91bdb60f526579f31913c895b6b3a27c825a606e018607cc51c4e3bfd9b20fee682f7251f38d5a5c8a42b10f2dc336230c31a6ee01a8220994b4bcf11ff8603edab7a68387dc004ac2e01d513a94fdd935b790dfafe5607e13ba9e8baccf19fd41a7f9016f07a977a676e7b4f3be597a99975a3c566c3fb6a573030bb2f44662b4e48c1d372b31ab21f99dfc4c8a5e413eb3878dde2bda338322bb492386852b5fa6fb07e7ae60f8356e2b35fba6389e6c830fd526f4bfda96dfd96f1960243522cc4c9333c4c53928f1e981c1596198cf0d4216b1287562230ab47a7fa597efc540764e2f99a5d194f986895f54573a6f0b65236564a043f77be5432c385466871196eb856c226e4522808c5472955ae7152b7e3983bf53888ea00fcb0fba501dcb90caadb5cfdcbe1ce9952157103cabf7c7dcbb535c84b8c7b1302633f399eb7a2e84f69312337e81a881ffcaa7aba2e584b7522c04e8d74b59f269572e9d2c33e699530c112cbda0f28e52de28f7fb7168a683d79e767d738a0dee73a59589fa4fda69f29cb30b81df6f3d40901e2f05f587c86f70b44c34c6632b1216ace46ea18a5ea47c5d0806bea2df19ab1a96a742ca1136e2944711c5f385f1a2fb7d35e5f541d6133e6fc0eeb87c0a14028ec96f290c3c0b96f31f1365abbbfc56df37911a8abfbfeff66d7944e91741806345c484568b0cf48ebb46cd482c69022621bf88019b3a1bb263dd810a6610860fe9df5f9ba0b66cc0594981fb629086b4eb0e91cef41d3349184d13ff67558a8c6cc965adb67d0c83a685131b5fcc570869cbdb68d35e49a4e4880598f64560f22384f5e6a3d71f40fb38203376f4a4c18e4fbc2e8f4019b4887cfe3979b7e591356914e3ab6e59a73bd16575067edde7b0124cf7c086cd0bc3df4feb764b7ed39185cb9563e351edc1ae851fcefb475764fb0c8247a8620b93f198f632104d8b952d7ed69d66c2e19a13296dbd7c7c5d94aba98f524d2b0bf385a7ddb9803f76d805f0c50bf0e98bc77268bbef68abf4b881da90f7969a76f8410e889e410818a8ca4de1e0e81e3601975304590b18053957f28f806ee5ef13f367b9f21dbd0e6d8907e979352effe734666dcab3a68868075ba8f942fcd1d93ccabe202be8f4eabfef8e12252818147f7e89d7ec818151170fb0c1fc1035a37e99d5cb514dc263a660971f658d79de5b2a451c6d04af838e6fca5c4c304c5caf256be1867a79af996adfcfc037092d1c6b144618dbbe03b37f0dd5e39a9533efb009d9bbc59931d28e6712fe00cb06a9d3113a448729eecfb60aebee40936f985475398dfe9b7009165a4c1ee00e2bc701b05ca604d65292a09d991ed6d302d1fb6b94529e926550d8e188227b23e9c7ceea782d43119d22f1dd45049ef039317e8375ad01e9b477d4c1e5bbee59f3c40ef7ff446148316afeaf6dd600792b8d204790c3e3e63ef2d6dab1930c871b24de72eb3992392c738ab464f1b6f88c2e47ee9e9854e6c87fbcd67d4d90b523f5d9739a7e815f575e641b8390f712834bf556db256781976b1b3c123e26b08755059f63d6fa9fc223af4871232e6ed4302ac3d66aa141779f0c01d25eb6360117d745e9dd70d59877500c19d6dd43f60e9118f1f6f2480767d1131a55535ba5d62f58ace4c4db96b84dfb0c49470b8170a924114a10cda1899f551fb16ac82fa5093a4ba99a1b82ee69f927afc15e8519942d661fbe6068dcaa7dafb177dc747822661c3e6744c878292a6732b39552041a0ee67f7305e75a4e23e5034b40d5edf5769f3888330698302fb96395f9fa5c61b2fd9d2c0fcfe7672d9d42a93ab4a57896acae5294452a3795ae4ba9ea34964be24691c5852906eed3c8e2b85cd6ef8f29ae4647a1450ab553143929fa6c00829c44c988fd03855c113ada9e6182de3e347aaa750d39bbcaad7c80a1b8390c4ab8f0","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
