<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"71251e67dce48f44e5a492a04e50b820e51aabe1f5589b566f4956767daf0fa01c82e9d50a6767518f69bcdea20700382ddb0e3ea7b25ae2865c2fe46b99cc25176c2253bd87f19207491ed506a9f7f9127a7971472e901a1bff9115c99ae4f73aad15d4050c4305797d9ff4159a8969c80b042ebb8fe70d0b5f643e806f267ecaf85a7beebdaa510ab6d18cb56de6ce4fc44f5d745e14b1bcd06809cb3a82e6205cca1166615a9b1246a99f834632f80258a1b9f1f62b51ef2aca54badc4556d8e17d528ebfde566438f01a2366503b414b65a77ea528aa95227e09acf5106d022ed408145238ccc52311d01d1631931ebd3878379bb1ffa5e3c27ffb38d00975785e7b559e4a4c7f1465b2a3f02351b59ae9eea4c398adf6a655ca28b1bf111b68ebc1f0df910fc724e261987a23111c62cfdc9c67de8741796fb027f2c208dc790438bda47be8365449c7811cc35deff58cc1eb8ab174d0329fc36063926da42f80fac275a18424a108597e668acc7326b840901659c26621df12e97f8457e01c43d8954ff035e2373f63636cb52791d6e3cefe1502e08033c2c6cc877645b567ce9ecf6137ef882f49d11d3132fa4a7b3c3b3a9b4fc19fcad4d7d485f9684c1a6666dcae17e4fbfcab45ccfe403af22aeebfadbaea98bbe3b7168be5c0eecaa4b1dddf31ae9e0bc4c4bcff144eb373a9ee5e0f7cf422103e35c4efc9be56f95ac5277ef8f24e1771c95e0e5f07cb41366af2b661c2dcb871ece6a6c4e253abce709967e60643601fa05fc3a7bfbd0dd980a74720167d02076b276019d96490da999b2feb3434102efbf0e6b5cceba12e1957d4715c09aa3103436b29960945f6518a074352add6593b7513f9a6bd1306902912fdd37d44db7f974ae2a4104dcb900608d90efbef688b7a007ab005d62dafed9f71ef92ad072b0e4d9a426a18369f056408cd346bacad86fed1010e4486f5650f1f411576548d9bbbf65f907fab889ea83a2db8f6d315cc5a404ac4e4b837ce7ab7afd5ea2b885e6ae3e22fb4554ce373ce3069b155daf13bd46e4cb10f8bf10b929729b5dcd6bee6a35963417cbd517eb9b0ca14eb45a09249cdef340e4071509e4765a0e583f967d8b07b6bf76c2687461912290b8134793eb3be64d3aa29cf08bfde0e80cbe7dfeaf39a7e9c5298545f7f8ec21d2a7a2ec16b44758b1738fadcf3aecc77acde1c08f1962b555403bef079f1d452c627b6dd58b2fc208af44dcf8b853f02d794674b568dd5b6522ecfee2bb1c8f6c9a6e701857a1b90938b3c7596b939df6f1c57bb36d0725e0ed91017ae79263257c9161168075f5938ca9cd66b17ebd441ba9c81485a3663d4eeff0d860f8cfd66609d385cca3d07380ed826731aeb9cb26c18c51f84478a1c65ce0ae32c43de87da325444fddb2add530b96783f70b83a20f30a0ec0cbc645c74dea8ec5f575206a15a557fcf7569f4abdadfd4d13cb78b1f72d223f5b4c818053e42dd603c297a88c168b4286a162abff50d259f7527364afbd65b8e39f79f2d6f0c5e9a37c76b0dc4b56df553b4d30e8daaabf0c7636cdfc2e3ef51df531cd8178a385c98dd4f5d177099ab9035176b6fd6bca156929c4c2378967b68d87ede79206d9e3e90e99e4ee9f5697e9d5eb1cb29a2c04546b123b2e9f466701ace1462b88b23eae6e068be16d5aff67ca4f661b559b106585785a9aca751d59dd87397733f84cbb5f349a2e0e3a6b88123096f55dbb23d761f683c4b6517b39d2775c5f6f7a52376c51402fe7497cf383b5a82732fa89a32388ac3f7531cc1474d9162645e9ec4b88286ce31ccddb269e915e4406822096c81ef62606d3a7610e77baafdd04a52cfe1c46647fe5afaad99b756097b32fe890faf241cb01203d2874fae542bc28ce85966dad1486e18cb29c33ce24c01c268e23ab4c4c92e88c0de12111313f2efd38afad183a10ea68ccd4e69f85437c9c9fe046d2a186cd91980068a8a4afb39948780a41cd5a058d4efa950409faff5557a6f080e7d3013288658720cd26a4d3f4bcc16e8e0f907c367c4534850d73d1c267f23e2589d9f76043cceddced1a2b2429de8e644a2ec8a490da136aa4e67873df76faece256ae66a1e15b6c9f9d0677797aabe1da68bc5d6edf5ddd7efc0a4e712afe5508f2a3f3b1aa55161ecc9f616dd93a8f48e127312027b1494bc2338ffb1e54625bfb9777300cbe2af80b17fc17c70b0687b3e0ca622aa29ef81b946559f253c631510b10c1dd1b208170c182efda52b56611fb8bfacd7f7a1acc823b86353c985e4a458a38516ad830621a59fac871f42eb7360d3da8a31c9a8b24c276392ca769008d75c5106af987a8175df0b8f3abc991d182244941a4f8ddf70bb4ac4f2160440d65a909bf6e843f8281d4959038966cc868597d7467ea9157df3e71cec2c0275d9ff2a06debfb22de990ba22eab31fa1a00f63bf849a8e56bd7a006a3a6d345d64f52d39ae3c6add33829122bc34ca1872122dd60d2e173d1a6a1fa75164ffd19051a21f43b5d6b41f0304eec5670030a17cef9ed16d456ab6b8dec06ec52b8ba9fad56b4a00db0afdf8ee04f1c07ad441c863a7cd346b47d10ae54cb6eb611d3f15defadcd135d985976991eb79f6de6f302475d2d34632cb3dbd283658bb1a91af98774dcff2eed117c55dc9b4b1436cdb3eaf745b0156682bbb262db5217f21fb875458c89d8e11cdb82980a17986889e954bdc24b9f3ab8219755cfa1144e65abceabfe1075483d2fb565f183ef2e8bb18deafb105ead2de75356a6a892bd8eb26b8b1740e8ef349cb491af71490f2c7a917d75feb889c7e5d75de85856aae92e761d77baaa72697f209247ab5892d2784db9e5e2365e5653f49f7cf80b5302c39b112f43a7c767172e0ee7d53f9c8a5b72ad99caaed69515d8090f2f16dd55821e1e384516465450a29505df74ff5b73639c7f0974cf46dd32796c8471cd8af78580b183b317b6b1f8fd57c941d3ccd82e2ecbae75402777d1cc9eaaf6472257202b9f4a33f9deeb5dd59bd0031c505ed9d092b2d5f886261aa8ba13112760bd474273c254b0fc60bce8270eaa73f874ac3213533b464f92fe30db4a492f710dbda96785d15ff7216000bd6e00f24d72458793679ba196c955f68fd3aca8202d55e1e9549e4acf6c7142c64174e9776699e3a55c0811d4a73ccf55448d050853d377f369d1aaaa75dae6d2b1bb4d6165b6dacdfe357a314cae3a97811bd684340b0742a153e20202ee1891f73e8307fb645f82c80710ae46b3ed405068b5ee6d71f32c2b8f8691acd1166c6ff658536728c46be73c192baab0e04a1fd64400bb0e27eade5979d29c2c9071ffd447231b3eeb013f195915b94a4ad6c977f615237f501b7f634a11b136efa1513909d88fba7d6a3d737258a9d2cbb8bb59a86a5f10f3c036211c166dcb07f3874417a6c0bc66116e82cc93737de84d25b038991369f486a18296909fb4a57a8a8f861fa0c5877233d3abd318aacb2ce645b9a714699e69ba0f173d393685b5c67758d99dac6f3aedc585a3efd866cb46b019968621470fdb59879994880d67aaf37e94068afd7785dd5b1b458d26d07a02a336bedccdb399ed2b229964995a4a1a44eec838e27c641a95fbc578d35738e0eabcfc0e4b53fca165eff97d9e9464871135269422faed4423e68b6507a781e09f254eabc9472c938f09c2356a331e4c1c39cc7373af8fb3413321e8ae51b6bbc0999e8bad2646ecb3e2309d8ff05cebe56f7669bd01659c8629383e4408065cea37115498022318b5149ce6e9c5bf6decdf271f5cbc64d6faaedebb58e81b0423e8ceb8045169b78e54b2a81092e2451f11a548742aee1a7462261552b555779d05668fcc6345586f9c037db4abc3667904953b11f7564b49fb456e63a34246cf5f2f32285ad77ff8474684b520367704b6a90a658a49d98ee35ac7755ad147ea5f95e9e719ad77af4b98b1fe1e384f55d949c3df68babde18ac0a94f6e69f87dd5dbbb1cbe6b70d4320f2372812827ab0680c70d52e2da60c9e24f670a3bbb12d68587e04deae07f937bd34944a86a4bd1a4360eb888de9934e7d2dbfd3ce65225c39817a4aab382b8d8d425dc4dd38777036ecffb93b6bbf26798b8b2adc6d6f7fb72fc4423dbe149db49f25f4dc450138083ee7269213684bcf135812f431ec3e85ffa9dc3113ac6b3fca6e2a0dba4ded69739983809ae47a17bb028911c76733c782cd5e968ebc75a917415a800446ea6f25db69bc25e20ad3d61fa3e24edef6e18b8e077783c44245104b23ec8739222d98bf8e5bbc37753b0007906706a179a36e5858e3cad90805db34b309f9f37a856006d84db1ea83847117077b44cbc5b1d163ec893c093fb4063c1e5b0a434a692be5cd34eefabf5cdc9782d12dc5b00897cb26ead0e2a6d9212edef6159278a38d73e927015b03819271b1a5e3acb80cc6732b6e1e8a68602d7181f71c38f4bc654b97636181fe1aed7249b2e63899a7225e3cddc353802ec8eb1c677a30cc7ed70ea30a760ea2f1142f39682f8be1c4608ddb6aae89bba19208fd39decb8de415ad87be8a41941560012884dce05b7e1566b5fc494e85cdff6849b24863c2483e3a6d3b1136c12bcd11935c1cf847d33ce34b47a3b7e88ef8eef67009eab8fe4aa1a7b4f65f6cae2b58410fec845988b19940d5a206d66dd6d4c6005c9976ce7afd55a2d31eaf991e9972acd383f0742a85e862c90aa97584366822c1e0949ed81258564e57e3d59c7be5d895135dcdbdd65c18f7b7c691c8799715728eb74ac3c4841bb4847a98a3821e6c13befc03bf2950e78ab1bf7bb3b4ec85e53535b346baf14b819f58dd2e55879ef5b33127a8afe27379d3423a28ed34286160ae1459dae69955b631e0340f5de9a42b9e4fd57edbb1d2833b87290e93c4343584f6bb6324cadb440081dd34d8f279f9ed969d05321d5edb464c8ad12963fad41e2e8e551a8388d0fd969ad8a6b1d5c47a77c776b9e14e3f7b2a93301fa00a5a514126f10dec36bf579364f744adbc34deae49eff15ab6cc23d6515d8bef42434869c581296145e31a47ab66cb6154d6a0424c6706d2d6167da59286788c4534f2180a01a2dc52a05cbaa3105d2311fbd627d1f6930a863329b62fe27830fbffecded2f48f4cd4a9f8bf3cbf38d513e3dce03597cb4e969fffb172a40d577c23d2a01d0ecdeee30af312b878094085183452037829de9802af318c4493d74553e068f63fad822a21e31fe69cb5f699653fcaec39b229235ecefa5a5543d0313360912f5e0abb1d27ca58b6ee95147255332af5f09bc6e13684e93d5dc30215ad456a1221e11318c17768951c1c208e6689f1596f871e62c66a7b9dff916fbad7478a6abf2de6eb6effb0a2b094c8008e29345acf7c026cfe24ed4c067fae090bac3ff9193cc5dc4365e4dcbb6127e8477875009dff1a90398639fbb874e7dc8038fd6ce20d85912f7284c8cd2734fe2fcd780877fa25ffa971f32d4db7fdd47e173debd048cd83c4bc1e603ed84b91d1dc47d9f78014029f5e0eecf717e40517ab526b8dad67881ed31a30f519164b1ee8053d60419b93f95e787ce420736646f11426e60677a8d23028d27ed8dc3bd2a55c4ca9dda604b62c1afc9a15bfca586c83705afd60e9a0af8e4712e4c87297f7c178a90011c3dfb44ab7173411dac3b3fa25ba9b9c8d8716fbd146abb23c45712bfa2939129849132d62d225ef8ddec424a7b3826ea576017fa19125478e50f75b69c4673f10e6b0111e374ce0c49b803fa32d6252e74421b4051fca5c3a33f3ce2b34e35acaac6fc93e3fdbffb65ba97172d62e52a2b8a640522f019e560e19b5585d31646b0020ea975b49b38bbdcccc30aad8306a52a1d299b4c334294e1653e3952f04b12c4e0ebdd6bb7e89df928faf81479cb3b78fb51afc5ba6c08d6383517710aa94513a21a2bc0a1e8a0040c888255100db6f4f20797739d1316a51e132710ff2361e099f0d30102ea6e9f5d72bc2ee02d076ece723159a09a5f4d38ec47ddbcf12981e5c230f1e19e482846bfad4accce616e5697daddbc1eaa4df2c7d5e80af41cdce8354cceec7b4702cfc253b62fa0b5f2735a59cb97e43d1e67eb521f62f15489ed701eb83a9d7593b5c0ed8b4f20131eb2c6450e3d71c52414bb0e590cfead1999c2933edf1327a37e50bebeec87d72e141322a4f46cc80a45df1fd7addf937b5b73a7dcece1961c05f71d47dc905a88c3d5c86e8971ce6a739c12705e2a3ba06ce659e0272cec032e32e98accea8b735c54ceab607c3dd0dcdcecf51c66f5ec4666f5379a46e94c6ce43de3a43bd01a89819eba88e9c902ccebf9c2da88ca6a535c6df42c2521ee496ed4c0ddf18707257fbe6816c46de1618bebeb1fd764e2cc98356d341d5a2ea0fb69f577db736952229d58b93b374aef3f319f83c843833f5a15846fce203709b81eb36067cfd1bdb27d17984a52d5cb767373861f393aa34538edc9ee46a49a68a52fc7b7272e48ea87db5833eb20965293aaed033eaae352c6241222a7c9b3e2db64824b76066fd827ebbd3847748821280a3056fef1648f41ce7e5bf6f24a1dcd83d5f3defe51bff1bbe74fcd2ef40fdb34350866234b7d0e6034cbc64ccfbe5af3b7b85cdcc7f14820953177ea86062a8a01965f387dc9cf9e94fa660c35a8a285af8ce8d6c76427e001228d1c37c0b7f1cef9c1de4cb66b07c238979dc7432b3a159150eb5be811120b70081e6f5131504bd344e40676bc1bd0d4611006372d8626a8190ab327f70e5f3d26c8c84e950cb756698e1ba9938fc421a49283c54ee3c23f273e660296e446597a3aed3b611118e019cfcf554fcee0c15fea26657e50b2e3071f6ffaed48f002c34072f428357ddd0c2897fde70efe67e335f6a2eecf6f3cacad14758220c5d98215162604f6916fa9301846ff1a3a5ada4134e8765a29cb9d66b55eae90cc9d72318febf1f4cc1af0edebeed9754fe2f2417c5052e95b99f3a0e31c57bbb97051304e9886c554c8b2249a266de675e14103a72d3fd34a68e8c0f52a0ce663c1a09d3b17d9251d8e1854fce8f13dbefc907c9e20be5602fbc8bcd92ecc4c7bada4499305532169656c0cc1384ef60902b35df2254c0123453e61bf9fcc1329feadada8a1c0a9905af72ad51ae5aa10a423b7f3e06ea715a8b27c604e1ba8c98cb98accc27d9ef4c3260027a6442010dba3522ce60271b358e04dac7e70b187ae31e29aa9e82e18292ca7bc5c74184adc9eb276a09d8fa56a99655b511219881706d1ebeff62d58f4c685ebd636e1af481f638353e83ee71b0a9f991dbd713077f701925d73dc5f30ec1805750663662003c9ab24b15a5ee9193de24d7b031d5ebfaeb3e59d4ec83ccd2c9bb8485cb679cc98c2ae44fb574111161e74841cc922021115a883112afe6edac9acfd33a12d0c1c877ad0ba3f6f20dc9519c51b5b7d72c0622f390827591d95afb1da43daf4d75e6fad233c25e254d2a21e757de4cec34f401809b6a1c4266390df143950dc2103459fff53e00418e3e069c7dd87472b4e3054608bf087aa38350bbbcc5b562bb6fd79b1bd0f087556213e0840b318326474d7365d557d3b4383d699ad0846a227f36e21879e7da437b9f7e639e6263a48b3772dd71ac012232a3033f397f20f28a5b6e4e8dad112634d43ac710115d1e4fa00895560a8bc797b8103fceeaf4ffab74c2f70a715f3d56024da1f2281d959c5e0d2182eba48810ef208b3b1121b073cffdc2c1c9c4492122e60a08faa4cb08f229514cc6400188116405a6a4c75e7530604d41ff7580abd96b3c0e7ef204137775e20abf487732e0a8cc15bc7429f1f5d0cd9d47b9e3ba2e2c9e6c712d5675a10d4cf98df8e58f9292539c6df93333631908fbb3bd905851fe6410826f4a6efd13d797de2f7364c5bc2b0582bd9944f20f7bf539950def3b60404588eb1d0cd275452e77bc8bcfa2199a4b3f6b980e4b26259bee8cba9d2bdc25d46f3d92f1c49322755ab897cfce25eac21a4d7d4fa352d5c0e192833cee256b61211ca528e67ebc63513af57cb2c35805780cc8efe67fa8fab6040b45c44a48325994eb9c9c3b42531bbcee040ba8f2e828f8e7e167a6c1951a9ef00472e81042c108788c741645c233e1a112d27fc1a969286cde4bc5c776846062a1a47266f1d5c4e256149059f4b362ab62b1413182e58995efe760dd45e75f0d638051a2b55f5fa91f8d36a05d05391573dc06e2c15706c578811b0d507b70a5930314bc8cb88769741dc50c1afa5ce5d01ae570f4367dadac9414a9e47a69c09048db8160ef6522cff3f5aeb7e147d95901c74e4a7743601800daf1710b0c06346497fba0ed6bca023ea69ce85cdaae8aa2582bf2ab21bcdc462b5f1a2492a2da1aeac86e18f7a19b7ea437d1f3ad0f57cda85f2ed9032d8bae554710bc866b4e0502a463118de5ae6c99ff51373b84fc14a7ac8e83b65f97e72651896ce2eaa4e2df399b698dfd2a90110153db81f1afac363c07789595efc3d38c74dff344b2f212f1ad892e1e91c62e5f7b7a25f88387dc7ad0cec63d3b4df7e718a745711436df438bbe325f75ea4dc4cc52c3421004e402dd83ff18008c3e041be7d1ab69506e44559759e0a408fc9822d99b1aa9c6ea4a59ea7925f6a5318eda8c3ca24728a3b50e2ce694592115777abc96380891257372195d248c96d184625455443e61700e673af14c3b4660971d57d0f5a6b88eed04917e29dc72f618e335c04ea8ebb9bce81e19f1ae40d1b998e57d169905feb9982fee724099b2d807d14b6f143564f878e4853f1e213a36f0155e18cac461dbf3ad87ecd951894c608c1be925d76acf195c65506b8662cedccbb4fea28635489d2df4cdaa8a924788eb128f00bcd4ea0f3a4ecde8b92b365f07c5c119455dc04b05ce579b43cadcc66187e40264b4139177340a8a6a1defbcb163b28e4a343cd7c63cc4612a4174c9c97ce1684c1a436433aa7ad85d81cc612a7e172f8deae9c1eb6d8344d286430cee26a618f24664d7de47a23525b10cbff7b7ef7d14ed0880f7ca39abfed7745cbc0035848cfaacb67f6b3a4856d59af322459e8488f54c75db696d6b25a68cb36628faa265d8029c936dbf968d822d17e2a4c65704f91bc83500b7f3282e252f4bf7e0cf6a51484b24a977732cbc755162940c851d1a70390d5441c02eabe23b2021abbdcca3363cf24b5aa78aa1f1c261c73dac5e5a0f72c5a582f950222f73e87448fb4862f6937f9026f6363785962bb49e0eab64d9633043b9663be91b041ad6e5aa1101b454ae5fb760f171bdb0662c5f228a025e7ca9f646dcf65b19ffa215b8b2f91508e9b1e38cd03f55650ae069ae17afec7d5bac7c289442844dbc0d6f4d62ec78689dabed85cba11c22d4a9d83adf29967b83f327835e7a16472a16d2730a92e691bd0507bf1aa1ea908c7e5aedde3937516a60c35ff6c211197f2da6d831f51edc2666e24d8501e589cd817a2c372c2577f0e0fad509bf1c34d71e5cd6afbff21d814c7ec794305b0f372d341fe6d05beca19bd3eafb4b3db868b951597820484edbe9938dfe49cf4396a8f43131e5001859d4cf6fb4e2052b77e9093efed1ff6703d57bd72cfbedaaacb85237710132e627c5bc936e25bb0984f59aeb40c2bb8f4d26ab777a7f52cdc1cb1b27cd760583634d75ef482a818335b818bb7b5abb962422c884ea88184a132a2c90e87de23053cc5a88ec8896d42e82d2fa8c1773ec3eed686a2da4431f5d63abe9e8e3686b24f99e5047f8f04d8d7441d51c8f47ebfe9142dcde9bf8965e92defefdf5afda836410d9db82def453a2c949c629c007539aff8de5e20dcb4b5dd617482c61f1ef152889e9cd5aa405c33ee4c6955624c9163c8f55b5aab06d92a31d5b72cc7ccdfc16badfa7ed2c80ffe63abba83dff4388c2dd05149cbe2ecb6ddcd40be825102abee22b8d63e3bd99203a9e0974a6d43092d86e4cf7707152d7ca1b86c98ebfc88cd39f721112a33dffb82d8465775e193e579ae394a32f91cc70b98fe5d408270d1b3b74178d188e08127f399b548073e19f5276f72f878f8e5ab76033b3f5a2eedc141f9848fe781fba761f79cbf7e9c05309d12e5205b1d2f5f437aec09f76a77149c0fc0aebd5c4f98a70941adc4acc14f11bdf297e61ef0c79351d7f9545572f90cce94ee8c440c81c0cbfa6f0e1f1923116b333fa941589e7584b7460c22d5be9b57fa3ff496ddf7e5da01e62d7c825cc7437a095fc3c7ac7c4f445f1ba8422e46cf8e9d331eb5902c9e26798581b8d6fb08df6286f6baca7f7586a6a85da4d811190aad25fe8231ebdb89efdadda058391e7c6dc3ad5e010036b862e2d8f466c12012502e2f310d944521e9c6a04044bea90842c90ca143ab57053bf1ba008727858895fdd37eabfdbe78a90f38cf5cceb28475ad16261166e1d07aa9d033b1480a16944fb239c4a0a952f8bf50e103c38d4e3f5af962babd3722615a193c9fad516dd20102299c86de33fc87d75732c4ab733a9ab65439e665b9f7cbf0df085dfb00fd2ede61fddd0bb8d302f39845df1779f94f4ba71a35cd12bc97112450d60d22599f4aa49a348bad389ae4cba386fe2c7c9b0ef88b18fcbc2f547ffdea20a2c5bf02d7992d04c9c7cbf6bba56da2650e2b69d84005ab72ec3adb7afbe4770301ccb5309af011f7418d37aecf60f0e301bc5ed5336ccb4e00c379029cefd569f2e0e846f37b6aa3e002789333bdde79e63bc0f953936f3de067d8057806b2843b5d6cf3f77d1ec96e2ec52ecf18d3b03451068e1edcae60c0a1cd3252df19297312fb931489ff71460447453530e9402bc407bedf44aceebbb759f9940cc484a75aed494b7d903ce3b3283b4de079201edf8276e9b0a0e3dbff05bf8bf70a6e0cce6af27022cb6f691dc83e8f46dac5d96bfb1df859da6cda3b2a400877c682d98454d2cef9959cece1ca045945c7a989d99d11f7b986cfde4e48ac0a77bad7662c2b2508815c4c0e578fbed230e6c1135790cfd6f467daf0c9a69152019bf54d8db8ceee8b50132645c069fe3454436b1888af95f781efc371f1e51770e34c6d180065be071c6f22418338c5cfc14aff7d45d5740f7a5d43008a562f74e95640fc085d06166acc5215edca23613493d93d2489961e59d0e837bdba73d69e78269a1bbd5dd41da2560dd26d7218e197a74682b8af63f64d8bbae52fce9bcaf4f551e2285d11c603aa422ab52d9ca1a4f058381bcbbe272d9274aa939cbc44d05a5e91b32aaafb6e3f31ab6938d522f97072c32d58bccad8822f46f004dbac982a705b481473982b2c474920c852085f029653ef8caf472ad6f52ba694bd674794eb0e46b7da351a3357df4065c54565b1f9ae6d2f3be00d8b9303dbfde7e4dcf8cd01b9f167d64f66c30b3b6a56a8c762d6a548bc1bbc1dbfbbd7a0d7bb703664c5d226e07ff5da7ce35522fc587e7f75c762f00b68e1625ede7cda4f0497b8e8fe36e55252d01e9b19d0ef46179f8e499c96b0fff8d2cf0d228f434d7340e2ac1028ba959e7339dc74b57ece39962e2afc19e8ab007ff61b4c5237e50c98078b1c5d28ab4e391dafa952289f8d034bfa2faf77c595c756c61d0e989bacdec449f81b4d92a757156bd17040337e5408b6b6674e1b37274d470d296fe6db3ccc04e0658697156d1d0cbf8fdb2e788252b2d4ef50bbcc4e6ee8781376332e5204612319479efd74bd689d11ba9c8862b5ac4e91ff89c6e8002e8e9c4544a2d9e6042476b67561da3227d8dd6c8e75f7ba2108ca54ccb47f4191f9c02d054408dcf3dcc7dc6511095a0125c7b034eac9ae3821b19be03f3b164e4f5dff18e5ddc8234b91bdf9fd17cde471f5151a21db5e362aadc73f7838cfdcac9011e09bfddcab7b314e827bf80404ea432028fe1de9666df2781c80000843a39ba2195d3f0d3ca1cd6c88572e87e3c93353b3b2e944ed9e7e60a204aaebc595d51a0663c5c1342b77d812b16942ea221b1b5e428697f00c786c4a0678cfadd9e69cb2dc1f1cd9fb6c361fe425f01a882a5f167b64a040a42dc2686067db1a07b26c49db70d276f9e06d17e742ad09717ac6505473aa7dc0d4dffe4822745dcdb799199618b1f15ab25a25f5689e5625b56c1db3e6af599ad1dd2b0979fb257ac85c2a6d63b2de745c00b851b2093d04ad359d447b9d06676ad0ac1d9710f84a82c99b4c5c69c0b09eca3fb36cff7bb26cf9649fcbc78ecbabd9f6286ae74b80ac3ae5cdeffea7490fbf2e4d0cd6adc8fa4eb9d51418ad6fc9969ef41d52591309fbad944199ef9365f681a077289a564e74f5950d1e16fd383f80bdb22e9710b5c3906ff765c0ab94f5ef7cef5c647c6bc01354ed6086b7cd63042fa8e2aa8b1111b0bce7a7f906bdedffb70f263740845a6d8b81bcb45e9de89fce665bb7a399483ffe1419540adcda3440cd784237a27da9e0e0216788baf76821a035bd0c31cc59194188a0261a245f5eac9de6b0c148a56144bafbf7652ef76c9e50b84f8e91d8430d78dff3c8f30cb40079e11b08ab09ade157d1de85d5670e8ccdaf0c9a191ce023db46c9c80caee584fb973e2c9b2281f426c2258ed20e243b51b98315eb339de38b85d17cf4cfdc9dbf3f97627d6a8d5a0b1c66314da6f46cd23acb1cc53ae397301b5b8f2b8f1b5c4d0185bcf6e14f4ae2b51ed80faa2a0223d5eb4ec5b1e5cfeb8fd2738fc271246af07eefe7c2d07e75f2ac06e7d1977208e8214c115502de638d362288089aecce8720527a802b0800e814c0c6d6c71ddcd061b20e106772fd5b796fee271da66a225960673067b159232e385f79a335aab6a12e8af1fefc1c038fddd7d6df976e9c422f4f5c138fbddf7564cf2ada6532f152aa30edef2004cfde1cc35a4418c5042fc3be1ebce09701d105d039aa38e6af669ca47749464f0256dae22f412e4201ab4ac5d4f945b38fb18f6ed620ffa46d082ab0f4756af037b14eafc4fcdc2373375a56e5090d46ccd6a8403d1af64b45f3cc8de878ff8eb15b0b80ffc6c3d4cd99b0f80b1676137e063cb123d81513e37cecd00b5275cd6ec204f2da47f22ed9ab5af71fa9d51764eaa5f33dfece165ac31fa1ffdda9f606e8f06005a18ad3d0fd1a47ee1aae50f14b44af403776c3662ae3c2183be1daf9da85319ef7d66d12b73fc43a92e1bdad82a412d6cf093d702f87e8ad1c31a752ef5e92fe74d8eeec23e8040cc1c8995134a1eedb6fb07301be5a5e3dd3330031054e39a957e325bbb7901936a26d5fee7f8aa11e4d79080c2be808dbffc810d9ae8a30893ed21caf15bf54e84bb0ef24b5cdf6e71b64e9fe90184d1d6f4da20e5b021d416bd646d6bed1206eb5101bc5a30cdf38b3b3c2ac8a88d91803f398f13c4368ac42ba91312695dd818ad74df4a13d34bf51830df580aea006237ae1aac56af02d36d98e837ed981d3923e445521118d243a358044905c98527667a189714b3d319a8f2cf955b4322cc703f4b415453abc7913bfccb4d5af525b5664f9b9c33c110a689bc8be46f470b9f3db6c2d7b6c085e71f0c247e4deefecbe9bc42160ee402252f7e69031e1491cb6c045a4a94c9ca26ce9ab8d9ea9a73923baa5b99828e35b4a4351c9070a03da727f25a805426380cdf740726eedc7768c2f7cd93f51d65667d001e903440d41b076a2004690ecca26e17d0feaaea3a6a84ee878fc8d06ec68c9483e1de989b23a009f9a84d16e691ada45de0ef9af570015efb95e555b60c7f3c533ebfd84a1dcd0df2bee3e146b06651693dfa1b7ec74bdadbb9fa018237d741ab79144a4f65fc14296319e683bb2c6da830dbb544632ea5e40710177fe901db2a59d985e00b28c47565433f5dc12f163b1f7da45c2fbd176d132f1d9f78cdaf643cf9f817bb487f6f01bbbc24ce6a440245731f587aa4d4bcc295ce38db6a7330694ee2e2752bfba7e7a58271f6fb8855900d42be3e3842d0334edf7ca20cf393f6f34973e3c7754f34c5aab04c931ab3cf53763dc497c5df88c70fb292afdc3ccad65f3c6524d78f6572184803c5c6bc15ad59a61b230209d214b23ef03a65f9e1f7a1a6df4f4d60e0d3a361d9fa9a196e82a111e925335fe9973d315340d6ef508d8263541e2de556dcac786caab0545acd977399f79faf92e3b619c407a931c8aef5acac7b8ceb843effb526e6b81fa54f872d69e6dd709fb8c2344def07f6f45b8e86cce2b9f9769e37fb5d73455b2abdde3b9695ea1a8ed15658ab3b4dda2a2fcb4bcac8b6652ef7e5a3e7fe042e2db3ad3f8e02d3094f22cd799811c4d7f65013a799e231fa0615e17b9d711ad8e6c927bf3dc466229019decf1d23dcbf685","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
