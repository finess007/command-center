<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"8de7b2b950eb1443adbd668a5bfc0a9c7af762b5d715c6086c6f2266c117af835bccff2fab7a36e3b82653fd75aa392af04821d46acb589a0603fc48ed6255307679271e89c0052de67993dea8fa3482f9e6d607f12c97a3f708c88ef3e02abdadf4ff303390a801edd32a106111eb5c3015eff561f3031a324c0a01379881e2d506ca146156d9afc6933423952bc131cfac92336a3816bf01d93c2a5e2026575e380a2fe63b989660b6e9f6e1a7e99d4b0bc015bcbe7fa687dd257f57a7f2cbaf334c35e75dc3896cac39ef94fe16407c495005f4f9ac1437b0389d5c624a2b2deff1b1a1c19e32cbf0c51f1351db26d6c2985857010a85a161f8a6a664cfd2cd8a36862cc0aac2e391b2db4885c8f44c0cda66279cd956dcdad97f7e4b75beb2f9f0b49370f59b9076d51cc6798b3508a5ef9c8204fdafa0af770f42de392c9d22bef0fe86d05c169661641562726df29c4417b199119ca14eb0d5f992391162081ee152ffa590944b4f2d2821eb450735edcc25263b80621b259fd928a7b94a24a7f9f102cbb46e84a18cc02b7503fb6de807f4e01067652b91440c5db0848bd6fcf771b8f639b4328b2ccf1cda76e08d6cf40752eab8b09d51eb4e7ef171ad5f536218b959ec7824df8c50e118593a1308495d86ce892ba4167a8f35866717fed4066ae6bebde68418737fc72e10f08d62eccc2e43b9469c01865c7f424f389b36b0689e70d17314f92a5b5ce567aa2c3b920b6d44c28a9c49b9dad2ef6fa4b7077639dbbd7d3c0ae283d3cc75705affd44dd49fc6e21bc7f98683bad41d8d07aa70f8bacdd32e45b8df7a633b71bec721cd11f86199d2abbfc7cb51755b313ef40b76df82735c1d93fc6fa6f8f777998e86bae4ced8e2fd96da844ece2b5f5d842030ebd0777749072e36803f359dd7f6903c970348047ee383177d321d9e82683b151b3a40df3a0fdf2c9a271656baba48b22c2789a7e7aa8a3692db598704c4d959275beb9d4e5510e798426854556c75fecdf1217b65e09a235ac6041256482daffe16fe17ba66267fd563315611b65f91c0b3e904237d50ed16e8adba037c5acc2e8d0d7b26f4d790535f4dcc5217cdfb9332e784e66eedb0f6d7c2d1328261f4cc7f9667df7669b4f09b59d3d8015b2b6ec4520240138e13a9ec0af683ca0b6980abef26d069f0161457c76c037ff2375477d7173e4d9fa240096fd91ecccecbd664f1fc3c69c1c266206a75a465e9b89a311895ac96062c924acd85b1866ff2d5a833b180c510499b9a39c4e907011e944815affd6731213eac1d2922280d03896c904ba6b3f426a911e2b71ee3b13e2aab177e1f5b122d8a0a14c926d7caabb3abbe409de334deda006955d795569e72803ae79aa261c603be015993277f61be515948d76e4a3c4ef7af44f71257114e27114457ebe70344329e214ea82ae2c03e63ffbd5a90acdb7cd11021b8cb598e695202768ac448c4fe717961ea75870b408b7313272f1752ad971ff35b8e60f3bbfc03b82398dad860da71e0ae2d6b48ebe543fa5551ce604ef5e08659c93863c1e51eb5066b97364ceb29f0ef61ebc190c8baa74579384203a99419898fd46ccc9a4de125d30361faf4deaf8ee29f5fa67325083d8965f2579df1a5a69378537b1a1e9a054bd321271b2259a1e028ea339c392d799694bf0dc342d6524714a39f94f5a467684973f15f0e8288fdc1a5269fe3e4ab39a2923e118424f26ad17aa1787f40370a10914dc335cd3c92c031aaea7015f177bcd901af5f99d80dcf2dc3244974da5cf04af84d5ae3a9c99b333e84de9936f812821211fd6839d7931bab5ad29ddaa2176122e47ed303a4c1e17f9815016113f3a8edbc3b2a57ca38945946b78bfa86ecfce394342af9ec8243581d575bcbae626472421311f49e6e256ac2f394e5694491ea91a3d7ee9b69ea882f652d094bfbd86df65eb4f2d09b9e790811fd65407e9bacadb9dc5169a0958b0d93850bd5aff6d8302c5a413d469b29e7f1f8c3ddf6fd0167cedd9801f1f638965ece1d7cba127394a9cde6cf54073a6553daa47b624147e93585ca49d9ce226419db876f1713db15340364c790840ea28dce1c2a4a3b030a299ca638a2bb88dc238752e6991f4e59b479165e6bcc24fa26b7239bf90168ee8167b6b1d527fa8f42bcce44beed0230552598214fabde6fb9a733bb9b8eb62cbf5a85d9cd9254b05b0362188adf823b8ff7fa4dca66d1bef30d9ff6e7b7acfc58d941e579d8c672676c2c7e89a9101ef2cc87536c9c93c75146d38252a54ce71128ed11c05aa4321c9c5d459142505ecb559f9f12184dc8810686683e1fca2a81bea72f15eaaddcecd98277c3ab8b5719c51b7c78e10c434e157edad57d40bf7324b68ee8e05d2557377aac56e3c7be7599df27a4194c4e8aff22aa3013cdc592e1c32cab0c944a2c9fa95a8d66024914b6b8b49c5b739d2a8f2c964b71435c8f377f7646f0b90e8554017a4a2453b368e44215b12a0a64ee00064ec358ba1b0b36ed229fd7e6e0caaebcd4e726262e1698a76d4fe3524689e9ccc3ddbc45b93067e8b20847e0fa7f9c364e8b30837b8f87ca4321b36215eeeeee9bb2b30e19a43380468cedbc86f36d0a4f3e83540228e78c3610d29e33a869ee2fde2a8dfc5216f987181d138b7bf959f254ea404fb8d8d7b26c6202f36ed92aacb5ff24b7006d7fc8ba2848d0b954a5281af9fbff937355b2fff77661b7cbc73efea2b2904cc9df986b7665239d5f666d4384c2f7453d7e6d2f92812ca334afbf749e995b0110f9540f22dafc17fd739c73bd217039661c9b5fc266ed955e083ebbf2fdee1925203f3b1d6a1da041d741fbeb2cfdc43738eb51fc7fe2ebd453fdf662a074dcaa24143f7295b3d1746d7fbfcc8fe4fe2bc2e519785c3278046c2d17a0632198889c46beb4affc3f13c10c6732d812ba6f6abd52715d33249e33ad52132750ea10b6b80ed163bc5b319dd956151c4b2f795bf9be68059a782829d97fafff9108164ae9da4909041eca2bf2140fa0533bfac6e7d2fb3322cd5d1b832838f861a2f7f8d2739a14bf44077ee056dfe59f5352dd7f879a972ced2e3358d3cd027937955bbde5db7ebc5a2f6853950804433f7905a42deb95bace27750f30b0f3d826284e5fa36f0ed5e63cdbbb8f2546d70a4478d1250b0ca23c7b00bba8bed952dd4ac5bf7e7f6a8f36b897c71b867f454eec8e62086334a80b45bdf6e4c4f5b866914e11cf3d486be9168496f20e02a1320c1edf8362cbe125df6a7c608e0d19eaf209cbae04ef919da69d9ac86cc2172b0d87c51aa9e331b10659c2cc043ac01a4de52f712915fdd690f9235e59f78825a41983436cde3fb6402815f9ceffb751e84e11cddf2379ec3400565d35436681ab1da5cca8cab5d74ace9c0dafc6ff753a356e0d9f250cee3fe1ebe108e70aefc282b64b96c19b4b1c0eed270dcb16e17db975f0b983a7c7dccd88d61ccf2e6dfa4ade4ff542f46995406a744f99889005cba6fd4aa319792debac6533bfc072f3a413d10f3fa6ced8b97fe6ac773ee19657623511a294fe2dd1baafc845e9eb46a2d2d47246e0ad2e3d426149842003ef91822050a70e114874497e3fd9f0ddcf6ad3e50855560c41afa76c5275b11a286f61feb91e29504912dc0ef3b052ed62f75f9122c6d50559efb60b4fbf90b6e15d1d26c3b041419ba667c4e898f901cca2882fa724c0cfcf080534bcd9c32f61f641cdcb0cb958606968839735f5fb08bf5592deb45c97d6ed37476eeaae13ab4dec8c88794809474950058f5fdc9f119ef7e6d20543a6b590752ba86e4df4e7eb1fa1ebc53cb1013d18c0e82a503f7269bce28564a79da10f996d413132e175af7f5b8b63261dc2c72fc5fd238a9e755c8c348f23c05856a8f2caae375b8d4b990d3972cf70d46e02cb95eb1b34c8c540ea4ec954aec7a43b75821576b221cf17cc81fbfba97ef48f02764c3dbe01a577ec571cdb7f6a76333b18f1a7d8f0332021312e8b3c06dd5dd722e0c3b85aea61e521d0e9be068468135944db255b9f069ddd30d3f6672e1f8bb655d74ea785b09064affdb9ccc31850824c12772532ea80703a68f05fb5eda760a24d6b3e9aeb5bb91c5813f4a616b051daa07d39467dabdc67b9bcb50b08f15852eccc5ab3239b81253aa86ac12971e00668184a9399d7ce63df577744acd26c0ea81b352b87300b4eb3c5a16e39040c097fcad9fa9252ccc2bc11ad8d054f3f45f4ff324639f81faf09983813f0176133607bdd8d1e2e37635ff4dc1956236968eded12da68bc989b9decf8c6d067a0d90f408338ca142d3324bc9d9882cd51e20a8e71538b4c65cff1bcadf24250a4615cb972ea4c900352e9f12057ea42df4043d3d8cdd914a9a5f3f27041f18788b1dd2c2a956f96da630a55bfcc80f466c643a58ae5137a302228b267e67563c52186e76f48bc31410e08f2dde7722cedab2edea804e0af79ced8541d384413a93ece34c4944d9826bd7594f930776c990e2639a496800ca0c56fac22565739d70a3d815be0d7cc37d8cce85e2b81e60ea90fb9693fe1d227026cddd237e4d88a75cb304f2f73768ddea4f5e3562540b66425852995af1a9ef66fb84e217224e69230fd0fd710d9e05fb0224662f3cbf810b4a92772c8ff8b64ac30010e1aed8cc242e607da6a45d9a31b9180d2347aa1b45521aa3dbd21a43e1055ba72bb556f9206a411c81ae3e3602d9da7886687589e078735bbf75624e050f3184a733ec64a4cea7b19ee433d57ed6fc5c8dc9bf2d0eee029e7cf07c78471f4559a5b9d6db9e2c44ccf1c7028bffcc35d9f7db38f638b7c950fe5a77456f044ba78fbdd2c5ac34bb82a604b827a68805d1ade9b1c256a3d42788b3696684c5713d19c9fc919ba1c91a97bcb756d25277ff451f6b7ad5a45f193e4174b758eccdbbb978b638b5839149e9fd7c341e5f26669c20d4767b7bd850ad7072cf0c21ad0be77b7709309e0225bf441b71192cc5873edc21bf7d7abf3fe3f832a99f603f032d407e54ec73f0fdf58a39e0c6b7b2b4ad2412bed7e2be6f438a6a9a9424e80e1b90d07d198875903786cbfd32e75dab57e1c77ae40635697973e63a0a33ada086e3b6f64275f0a18ae041ace34d70a7b036578c14d388e70f2aef0a978cb6a6c5ae67477b6e683b25fd4d7ffd9bff9bbe047b4a149a2cc7ef0c1efc5d73628fe0c99bc6b90e1b2679f286402a34126f930b8a863c0dbe5b596de22a9738426dffaf9b63b2a46c8eb1337a23b5a9b8b32e2ae4b138caf2fa17baa2abcdde0ec9d040ceecbf2945b6fb6fc93f328615491c01d326a61656a4d32a6dd6fd27105307260ea7a67582c884b36b838801dfcb9dd30c0ba86441f3b4d34116a7835973f33bcc6d84dd50aee85cf6893663bd1733d65901e7fb20d59f7125bbc48ac84e0fbdc905303c0a4c1f34bbe5a86ca0b1064218d7d187c0c41839781bf660654e99520ebe410bb03b65ed8555a9045c64e75c2cd5446b1c5d73b465e1bfd4596dbbe7de5aa3913fb5571e4bd56fa727388ac633f7a6a1900698985af93113015c08b4a2de441f9b159f50269fd71969ea50f7b51198f2daa97b14b6da8c1608f5c53cde79d2e4df1af44db50ccbfe485c2bec82052f3dbf6c903b2e9598400bc1ddaaaa325dd01de6ec062738fe19145ab242321da5f19462128fd9f8620ca7c6a227a267eb0366bf8b2da1330fc278d1ed0975d020e3a0246060e6285b1f05bb00e8f738250b1dae6d5bcb148fda7f3aed30786f58bc239db28a5e3b22bf565182dfd7a9412127c8a888bcf67cce3fbe688f81f2d163391f0fbc720ea1d960287ee7adf03d831128da623cf37922d6a9bcc1d0f90641b2106fcde36a41453aa4b71d214e91a3d17ed0851a51f82e64c7fdd143ca9ab036f216853dcba347dab924f7088645ae9d1ef7f85ac3f92696ef066f4d8b932b8e5c4ab4ef3f7a7ef16860a72d2aec7d18b6806a620097dd91ef057231f54cab506284b27f5360d800d5780c38e011c60a9eb8fad1447c85ff0166d7f90be98788747c46cde83054021013e9bcf554351120441222a661eaf7cd19c47866005f32eea9c325fc79d12c5e7d10bd28428ce578575a8e09d2d40896305b2c1e4275f70215da03cc662d3c28a4eac546dec889efe53037418cb8925bdfb9d946928837f9edd221196c8cc4f2d342424f12d575fd8feada13fc0ddd7d94a10b68f0d719133b3f23f3cfc054c1006d71d6215978cff6acc19d1c813757259c480a110856710181bc2b428358595792c972bc7dd06a8585f91284e4f8e0ed650f60f70a053f9eb11cce176de2db4f4286fa43530e62036794ebeba94b6eaaadf93910d7de48ac7157e0d7e62bc8172c303b9171ca7c737fcf86f92472d7a562c3da411c1ca875ed9b31dd0a23c99d66c837f2fba7d0bf53c51816563e1b6f9e998e72d6bafab67513ab59b3ccd258a8015efb811c2e10499d9b084da35f888f0669a6da81f2407a5f88c2ec6d05b7e767d85a842b0de323f29890788f02b5beb2a1184922ea5da42719323574e9659c883ac19be5150a24062793c55465b7119661b2f1ebb96d51a0c5d62326f7845dd33de3fa3a37458f5fdee34ddb42fadad50112dc87e1f922cc2e90035c752438867deeb766af095978b0b423fcdbf2ad303bddc0a453f63b2e6b48191542f2bac357082ba2772767ae1edb72981c4e24f6249fa1f30f868bc37ce466ff19f8307fe0d0a94deb9b81b5d530f6fb46aa92c8918acc3f0f408ead87d10cbd32dbe1c592b29df0b45de83d549f840eb0558404a8d5ecc47d72aad02ea7e822607462805f7d85dab0e32bdab1b1861b73ba505c9aa2083f24358c1006618b914bde9d9eefed0330e9c603498a30252d2d045f6db7811dd1d95c1cf9bc47bec6ffe054f69b5cddf9f5b900bcb107df95fa27226e2f9c1afb3b35d1f577bff4d306c2980b2f11b7e05af2210db921f9e29210ca2f003f7506e6204ac022ef01f6ccbadd260a83c85ae9da3b6c010d5dbcb164fec94d6e788267e94f2bb959302326c4af4473ae62fa793c8fd6d2cdda71b7255d695e75a8c32fbc01aa1a92d7014fe28a97cd307c707b01f11a7f6a5d1ebcbb211ddfd4a6b8eef424a9d1776fe4b11e7b84ec59de69e4ade854b39018546a2b02c29ec1aa3eaf15b72ef9e2025039f053a1c65a010eb2fbd0f4828279234d45fae2c9ea3b6bb767c64daf3edcb450df00dbb523d893f4f9352cb99c6d7bb2893ceea7565b27178992acfdbd72cd71442ed15cc119daee249722cfa563faa229ae560500059d98ea1ec9e40d44bad550c9c0f3d2f0916d5fa414bcf9b35aabac84636b6901436574e694639f922fa030e04b51559b98296906cecd33e42943ff017b19b90504d501a5021f25f8e49c2e559ea86350d1361df56f2c529c2ad670113fd8f01ee31a947a02ff56709e5c81133120327b7a6c0e93b22b13d6ee25cb74da31dce09406a2c7ea87437ee0fc93a1b76c3f255d75d8d43bc00922211b75b77812bb67d5b601bf1b0c85b9f5c1b84e33ed03bbe035666a6531d0f72a92da2bf993b124fca30c5b4840b6d0c4826c9668584685e9a6f8fd5b61779e538aea19c49ba5e26e86bd437278a3adfc5671bd955f8fbcea841a4c22a7788ba5ab2202409f0cd86621043f7768bad5dc5c3f398deaaa6df51513085d775415b49691ebee601f0c103d803b374cd81056d8ffdd53cd9c85f01c4c4e6eb2d5699cbb501a475cf1c7a5f24c9c8160755eaaf715b0b33cdcc94cb94c139e1273fc313202f5d9094658001bfeadf4bc8960cda55828f046a51edf4afd4ada2c332f152ddbc1149a486f25afb71a55f3f11b25ab9215e5312b67fbe5fd7a0b1790374d34d84eb0472c55c668abdc247b322a45c3da4114fcb59c386b862939e0c2d0b612a43a3ea3c7e6506fac329bf908b49b85299c2d5b895a84295a869076bcc27598817ca302f830cc6fbe7642a4d060c98d52ef50707f6ff9fb3d4ae87e1595ef789312b9f0a7563a2147307d91c11999dcb4cabf7815895efe9df30d65aaeb8d5600d51f4b183a55118c417aafb9b7ba81acce0b4d8c0a35f63be544e24f2b09b95dee64b4cbf390ce568766b9fc923fa5dbbc78ef12c1cf22a60e8f568aba8fd3345ad1c1e6466e9759dc8fe1efab966239345ad5697a1b182c41a201fa0fc570de548df96e9fbf774b667bd1d3bc083d6bf60877669fc50685cbb36d60e6ef245dcaf9bb6d74c4b0f4972c54739c2543baf057e1760d8cb84cb2c733b09bc64dd57d936c77fff95e82675d8f9c65bda1d2ee403b779174081881c77fa38b2a2157babe0cbf746ae0d28c3c58c68cbcaf80a9c817c26103a0cddae6cede0a5f536e8fa11cca9a42481688320413e5cb5ba40dc678ca0760ec920f4191a283835f884e543b468fccfe83f4f9b8f450258e061eadfd1547d14085acb9e90436d7b2a57e800664eec2be3018caf872947ec408e2afca80d6eb6c9ab9e4b198f368808c857eb154c3dc7ac7b373d2bb13f0c620703a9c7e17b63112789ffb02a66df2c119045deb4788488874d9def5f9c88df5b6967aa1b2412da2b1ad5ed42238823b9a8adc719bb2f2fb9878b089af519755de11393db209910ad9ba079036bb81c8779e5e27b229aa8b75c0ad20581624bac5cd624b4d48aeb352652e0d041c0a1dd60a62cbf61ea851be7089393a42b051061ea9ac4908795bd1a343459161836558b625b3f6d3ddd1a406cf022e23200be21209f886f3e1360d7c1c5e54d25b89fb3670ed9f6bb044d55b6d9100f23377b40863f100b3c487a84e134346ad5f178cd6039e347e1c62c91f8b24bab14dfe373f2a8adbd1460388c7dd634272e29667cc8bacad6f3be6c577a7e8b2f0e9fd1f48a6049ce1c38de580ac9eaabd487ad7cde3e4ad337b9d90f4f381fd6b847385891e4206e5453fe134a26a24b5549c76baeeb9f8488632eeda63e1874fb3152a982515a854b6ef3fa183d0a4d4ccfe4b36de1b6f06dc279887d4d81d77dc2409248d66f1c727a1a0140c084d038ee43891bf3d9fb7519e3a0da8aa0066a984f154cf1e0ca74ec245b338a30f686593f8111f48215d74d5394b655b817b96a22077fb22160e4a898f984b6329edb30fcecfa7c06cf767b27596ec8687796bd4b643c4e5be1f298036df9e35e6a28534d9b9ba0d157fc642dc85d91e2811471f2671b55d224d5a94f7c42ca284f491622ae33fd12170ad2c51504d128609e47e3c27cc36e270446e2ebc9497054b3292ddf2032454aa6f7bfd6d2070b33220d1251fb9e8572838d5fb8305a2ccadb6d67d362d5c99542ecce565d7ee316615e79f65b1fd8e133c07cc49366535968fad5203f551c0a7bc8784a6707c6a3dd1c2ec0a661d225e0bd8d6dcd366b39ebebfac35eed08cab82b25f1e19b2a93f89f159cfb4dd4051f555c7d1b103e39e81c7974d1db002f61bcae58169e191f53d7c321c4bf3ef0d820c0e19632e3952a18bdfd1d31b2c827c40c25c82c382042da8085e00270aa62e0e22433f07308a06ec312d52cc74069dbd96e6a3f94f6a746fd6f018ef8969b10632dc0151f748b8f8fcc0012cf46ef2ce1e3297ee571d41952a5e2488885edcf4c236a4e5299fd4ba7f6d75c3cf7624ba88be1d455bdd73d7e5f2299a488b46cb492d84119983e640b7bbd57efd2612bc084506dd37061df3c8cc98c7874d67f6076f16ecc0157f6e65055ec06ebf604ded220212949721facbcb52defbaa1f1c49e8ea724c5c7693b7e0e75dda1b9014f65d1a684bdb917202a5c66dcfd7e396d6d0eadfde77467bc8a9ba15dca0a8b5fd4def450a887e44931804aced92d036670263cdd55040c489d41036c9ce7a7ac2ae0ef4e13c025b043a7ee5201bdc47c1c44b76ec5815d73f956c9c1a58b93dadb324db7f24c78fbdfda8d4155b5db95204a6093233a45fcd39c2a99a034b76d5060fed51082be0bd015e36a23f4f77664d9e2dd784feef317d4bd7491f8bd365a235bad428bc41304de37663e97be9f4496228ec0b86f5f5b4c1f088cf419ecf10c26ebcd0770cc58be24a9a332699043f810bb57f2d0d26651442ec3a38bdbc4a98272882607e9d1f5a23de3a777b6ec8c91601f99bb86caf2678d155575f5ab83eb37cba66d5996c284c7325be785fa5d18c6e576f7ef5a17a6cfdfcbdadbae48c132b7c5dfe36edfdaf3b64b8f33d95c09b33b0dd2d98c49d46782ae7566d381af1348b006b863e21d45ff42304e671d758ba3662e1fa4af0657174872e5824e66f402d64333d216455e06b2c75bf6bdc81337e05e4f5b3c333dcdeaf583e502c53ebbe332ea174e5d62108e0491e08a2a9bfe12fcba974375d2af27486b529eed655f6a5ce435e3a5841556b382a4d5525d05d0944009b7a94f5a692209e7050cdcffbae6d0fc53d627ab6b1bfaef866e0b0b66dd9b995ff0e31370cfc077e2f79f40a22653da0ba2d8c629c0d6442c7e4ae1164721c59819f86aa1f8a08add558b6361001c819ae9817a81e5ab08b40cd5aadee5cfbaaabc85772770c454dcfe81b7c6821114c455bcffca6ec94bcc01238fcc8c6bff812b52cbd29bb18318680a73c8bcbeb283079aedaf9e0db4f24a6233b677f221e2b50d4250e2daea8f84a0f7dfffa19e5a85bf06ef528d61616c49d9f3d790e4086e32890ea5a25e84948cf10f5af1ac8c1b5811424658143d8348016d2cd581f9215ca9b3f84925d337c8996760ff4006b46d50cb3f6eb85498879597465e720d9c6313bd75fcc1cb401f047d2d26917b99e51e355b82435c04bb1c644f9600cca41972c3d1801c173af3592ff7f1bc4b12205b0c5220e7f7f9b63a963e455a134453bab29128f32f4500947621453341ab160198ec5c333a1a91f85a50f1b9082e70138c80c2d531f0cbf0cce4e32b31c284de79496e25ef5fc9d44d76d5621bee2300aff01fab5d76b9bf6117c7c5c571b861daec90e5e96cc2eb150411f1418ce3fa1326d910bdb76de329916070e60ec37c08df7ce186d43b1da31c415801ee6bcebe975ac953b0c1bf10e0eda0381664c374644f1e99c77d46f644e5ef6d8ac1511dcc468ccff8e9977c0ee1fa033518186f3e3c522190c67671f6ca8dc71ec80197d757a92c9237f5fe4a26eb293bec18b0ca3884a39cf8b402bd3718aa7a8421f4bcac23d03e72ea00d7bae10c463a05ae280aedaea0eeb53f88907e94970a23affdbfe4c03cfb7ea8c189cd273323b8a6bbbd75ec36cbf04340eb3b16c36b665b0900a79ceb32b20062a6149e063f2d6b9d58d34c70b02fa24145017e1f03b077c12928e9b061b0eeced92b01f2945d6ae9387aeb046869884f115c82f11adf308a20ac9e8ad0bdfb6bb69fe304d3f87695b9e324ba3c22162164c42823a028a72901c66ab1c5b1cf26cf7ddda03e60cb824236d3741ea842e73561379f78520f4e2b8dda9450448696cdd1a3ec8a67eec3b0bf01a3e3a29ee208210412e6256168ed9abe3d9ed9eda72d35a740ad15d46720b98accd7aededf06bef3fa20cacab45796ed6fee1e3ab2eab9e282370e3d3ede0507ffeef0afe66ef3ffa06428eefc8a8bd77e6c0731d2c39816650e43941689cf3646f0b879839b3d65294360081cca38ccf6cd2a39652b6fff49a10074afcb603a3165f3a76d7c0d2209e5726bb28e71ab7791457d46cab6f09ddb0eb2f2a845aa80a2550445af6da2ff6dd4903aad2d3d62e00610717e1c6cf0ea14ab95be28137fffb1a3c1fabb04acb09ea6a8a5d3cf6873cdb06812368c30333834587bfe91fb39bdca9e3e080def356b4846281e51a4d5cfbfa405f1e4cc8122e25f1a131844a7f5f9afde1d2b5d0ee098b04943bdafb0add24bdcb5f81010d983b93c6033f7d084d695fa1c6d142e6e85d45028beef78422b20dbf612b6146d7ce01d35699718b8ae7cbcb102fc9f902c220ceeaa08ef771931bd1987fb2b893ee536d6453cc090ee2bcbf420f8878fc36bdb8422f1b821291975d4b3c0b05c4c060756043d959a2331e55f4d8999ddc56f804c063504331c2a3df36f8c5fd4afe32a589db8bc822155d890139f671509340eef7114d8d08b330985959f2d0386ec32588a1fde209f741950c9a072d628c7d8742df0d6ec5c1c9cabfa3fcae973cadd48b9c043deda6e8c2e9104baa87d245c0086d0191ec5ba56346a89df0df23432282a24d0b74609325cc8743261ba7a2ac19d25aef67363a1318d8ac53cb343f171c48ebfd36fd1de6dfd4be29978a7e57ef770392a7534809ad5ff55974e8d3bce8e3c7c8def5e8462ad3eb943d3aae9b799f820933170354e97f5042877957e6bc93a9f4367e14d3e58a6c1491bc02529d19bb326f0c8c293cf4cbe53f02be53ca1086ce5bdc078ab87cc9a504d10d2c6f63686c083d32b44efef8d24b719c7879c3be8b1ac46c8227c14eaa50831b5ade25754990c33e733a9d908c9eae46fc6ee07773c9cc3bee736d16fe34b8a58bea08ce6c26a48f558ea354eda7b87226a7ecc8135cffbc837d4afbf2e0bf655de037828d3e5632d2cec2a7d874acc788b5eebdc732d3c81509ba9d70fcae49c20d2c1822d406b2647229c16d10c468806f9667e1b9e98b36e5168ec0162d7bc14474455ac7f8d668e2114ea9a6c8fedba3890808f6c3535aee54abe7bdebbfcc8fa2baf7365da20cb4065d6f2dd91fdc1d7ddcb7b2a8e8a5a28534697d02a239c247d80f6e083484610263a1c0ad6dd3048e26ddf15268126eed272544299a823f1a7d7be7876605fd06d379fb2127891a41443fd96759751419590f81841c63d85faf957ca6ee235aebe4197c724fe73a4cce7d9134b30ee506a157be9fe8ff7c2daeb525c219f10ca1fa299d66200341a6e600b0a7bac76146380c7dffa67d436324c7ea3c5ddeceb3c683028aba57dbf7e35d1be23406671b472af4b25339a4d47e6d37aa03eaf7be9558ee29376dab84c4b858d6cb4a05b6054a7580918abf1a24aedc0ba07093b9f1f023868e338ed7db9c86f5591088bd9b43c37c6fa40777767e24216110f43f6aebb5d7fe92e2a7b328e64a4822d2a49f2054da82fc74d9778cda67508fd9fe545b0e8957ea391511eb0bd3b9999e5ec009637943794c0aea9fcf86741a022fc24e088bf21a790dd9227e06092826799c66841d0332d391ba77a5aa0abcbaff757c9cf96074cf94b286e566030641a4fffa5d24f7ad3d70cd4897d9319923a5eceef923403c798f6b01e70bddcc7561cb067df852c13ca12e2f7116dc7862bd45129abaa2d72f797e577d09f84c3e205254cb1a591efc96309d25bd03f7a962c62e0c5dc5604779989c90793224c0b3ee88666c30145a0d2508f332ff7dab29bafa65b4dc570d25e388bc679d123d97664ab267dc0a210d02de8f00f3ee3ba74d5e3e0fd9a88a43d442ea88eb0c4e8e4eb0f99aa1da8e949124b2401d52d991f8134009c71c9d503e34355479ab1b94e001286988985d513a8db577d83005910162d7cf8a013dbf37990a25ba413af375ae6493ef0de9ebaf27a6171a2c7d227bcecef74edea357f8be6041b69bd07844d36b1f0d62e126f3c799b10538c526cf23764fa5e66a0612c9864be8012caada1f996311d23c1410174b33f3bc833e491079821382d805a87638e2c9a5d50fb07ff085842d0898ed00943d4dfc556bf26b0c55213a41a930f8408f317f3027688cc46ce105d566fc156172f520d39bafc0d7eba5ce0fa3593623b584ca04a56b01edb1372d068a97a064b670813d15f0cee518e4df7eff20860ebdd8e66326cb83b4096d52d70f22f9dcc243d5e2135cfcd63c2496a3db07832fba4de7c9301a71309b6572acac17538531fb23e1f0249aa29b3850f06f8c30c775725f3f4ef03a51b3dad734131d7b690205a17fb15c0520896daef59efd1f0047469e50f864be8832dbb36be3cbd391f5585545334b8029919c5affcc587bd69641a77eae7b4ff62bbd416b87bbb601360d52e48f45d6f4910804bc51e305eda02028d93f9a5d7aac4e7c1c26b872740cf94271b0743e1bdaee9541ac48ef12159170e8cf4eb3aa710620f9b8b1e29bd96b94ebd62bfc2378338a1aec5db0ad88ab03beca35e2fb0af450cb511891abbc1052efc35b4b45f53fd8a00b8a85d5e81fa95535a4b020706c0ffaf715a8f794c4b0121d897c7d4dac36dddbfa81f3766ddf2930b729d14266c5518077d46e39982ca7e05a2c17ce4ce2e412c3df9f659a967ed897df5f52ec0a0b5d1b2e25f0d3765c54ff032909f2a81a9dc49274f7df04cb88877874cd7b183893099cc7964deb39e6d4e59b84adb356401a404b1222003bd729a3b7b281f2d7531d859117ae71719d88830","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
