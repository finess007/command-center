<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5b6a37152a9a1fa0fc5eaf1b78dd266ce13e2091b9c71e5b73b5717e3574444942fffa1917f5b49c28b9d1dbc835fc6aa804fc4b90b8342a3fda0079dd232e36a16ff6907a5da830dfd0844567a26c407afd9bb5cd1e395d6b20117a2e846df708353a47b772d583e8a244aec696106d3f18d247537357b947a6576a1b3460da653c55dbd88abcda7f707d55fa3adac7ae75518238a9f0b1399e114293258508758476be7aa5eea357f906a216e49da3eee9975e14c7e0229020992adf6c7834402f9a50f23fa26c359e5ad2d1c50c6156cdd38e35599d817d2784bdb4b0427ddf08e8fc16786f6f87f485a9615c08417ad775cdd783893b68e1418a489e0b23db7e0229ff186fb92bf016b44904d36944be9cbfb0bc5c64391b4aff12d41750411d951e87534521dd443d3a778275c72ddacc6f9fc7ac8251edf7720366ebbc381c7359ebcfb550b917ff6196374eabc52a6a5dec742c0d39397ad9339e6f2d58597aad1c9b1ad5aac1ec617972b7cfc48d848fee0169d10002cd320d8771e67d30b87bd4f620f4daf7c6aa89cc8bad5e8246e3b1be13e8123504b776287579df89678d285a549ca2799fbc9dcb206091e5c2ff10ceaf4cf83815b8c07f721e15f0be5abc3ed61cc45d8079021b009467693d231e7076fce9da3fbfebfd9f04cd157356ea3c3ff14964dba6a9586cc07a160bfb22a7a8b7172ab145a8d85435245c1fa4c57acbb0a02b928f21ca42b9745767c1b0b49342b4d3f8ee11223ae35bce9c3c6f5ae6c1e748b85082a622cec2e30757d62e9104deb447c8af1bbb1394db1cc9355f2c9b9ad24437e10cf6170b72a128d395c00bde7cacecea0ad9186d741a52257136b91f285f825cd6bf35343965735efec4f82e9d251d218bd525aa3bd6ecac694df9ee00cab9b3c83504eef8d0be05bf2643bf217bdabf7be13c706d69f838ee43283678c0fa4354c4596ff14391fc388277616fde4e34bcd2c6816bd6c6927e12620aaedbc0f0e241bf2ec743e428b9bcccdc88891e3e99c0a7d4a677d3aefd322d86fd2880d3919f8b5d0d834e020dbde23ce6dcf44df203b60729ab39c10ee7aa29530a21420ef21264df5ac09def03e011b65e978fabf7fe4d7bfc750aa572399b50c8c90db273dbefd249ad2637be6c039a79dfc6538917b1f7cf19cbf439e2f08c3fe7a8226bdec392dee977b98c62e4ad27d0efcbb61233087873af7a3adf7685421a40338c6ca1519d0e06cc3396eea4c105618f817629e7bd791fb52e5a5769bd5142f9288f8ae0f2491bf500aa7a0bbef18303d77e76ae71ea64196b75289c1b113c056d7cd4d5e3e6356cb17ec26c3ba3441fba1f8a0e3b38f62be4fde6fde75f9596744cb29726bb7d498b20468c887d93a9db14952d08655987121e27c85e389611e694facfe218e7865c534d38359a5ff77bd4cebc97674c22b7ffa39aeb9fc095ca15e0ad1d4d742d550cb73a3dfe0521553070d6506b352e31e35b86f07ddc4931666410c24e97f62df97505c4ca66e6b7f54dfdc2615419f68acfcbfca405aa34cdcf8ea437a2eb7f44c54f77e456fc5c16ddcfec76dab4ccac860b67371e116c84ed407d70cf80339a2400786df4c2b7f4ab391195ae1cc038808aa2b9cc87791ab4d6d62198bb200383c6e2dcca1dd33454f2ec805a6de9b2353a841be3107b651092e9afa7edeadb37680c0860f43223d9b9f0d352b21cb271ed6fcf6fb263d56ea71420ed9d0de26f8ead06d4a99bc4c01d1f0d92c28847e5fa619551574ff2f982179c361206d1f3f9a845a826fbd32236b4e2a8f3a59cf1d83101e62a7409aff4fa34509b11438b57eea6508348aa59026bc47aaaf2108bcb73c704442be5fa7b195720aa9e6944868fc0f4e753554f0d69a4909cb4257452ec6dba8f59e514d64f65875540de8db84f88562d2fe0c500a999e099d0db8e40712896167ddf1649b8bd421d2087e873865182de9fdf22368399f8b0724c19b7f81111da56cbab36e72c0f6f7adfa20899f2b005fdea544b07e03beb430cb7e6d3bf8b4887ed967f9ea68d65d686ed8fbfbc1ebaf1e3b57b58726ab4cb88fab05a747d19b1b022cb050f709df8312ef485c19442154bb3922952dc84b4e1758fdbdd9fe60b18d7033e8ac971e84383a407d8d20176de3939896b297d67bb351bb16e041d2b088bfea26a2b690de5af1753d14d7eb68b4657e7d3deadb4fdd6ae23762a8fd1c9e1a9273882ffae59190b646b734dc62ad9c4ce65786679488bc11ed3a0e6f291899afb0d51d00994cfccd8107130d137dd054c423e4adfc6a5a298f5dec4a8a997b9153b11dd0ef0fd2bff98f487b33c844f68f0a78fcf326d74f519d054db303047cf2dcf4ec5a0bf32864cbc0d078330365ceed331fd8a64e60c7b91f2d2e51a9a866f762347f9ccd955c34f99b14a21fb9ee256c8a2ff3a650cb1f54d392c096f40529b71ebc9e42cdf3ac4b84af777de37e041674d0152cc5a5de7e577d113666ac4b054a76280fcb4717b36d70ff94cf26defac0d23f41c07ba29ad2624d825a97dfd603a35b009e9ea675e92d32280317ce160c3b5ab406388e2b80272ab623788a216ed221ef87135847a585e1d4cbce5662dbc48b39b47ec0aa16b44b89b42c113233c0ed018ce57e292dfe74caf25ad7ad54766d6cee9004e5d75d7b06dc1fcdccbe6d86ceda760c28d65f299e438eaad71bfb879bdb7e935cfd6d86a6075f2f038d06a3bd2b1d3d9f57c76666b60e5a328c2d7402d675166096a9517ae162e9fd39d03b6cf296b0b749f5d2f0171eed9a64396fd1dd4e4d9a514a211623d9a5454dfca91c172527efb22e112f71bf2be541893e3e10209ceca8e3fb9557e62f5e8a64166cb8dca231d69a1b4893b262a64bee6dc0d8f55fc01c341256efeea186a46d240cd5c5da8b2c5077d435d52d6802f04f54194c211b9bb736ab720da950dba8cdc2fba874a4cd5ba14c918ac45c54b0fd12ab4bfb6fa309b6b9aa3c4fb2e021ef9c89b78b6e447d60cfc6c8e880446224db2af9873da687f130504c9804f8710f2801fa704fe246add56eb0b8077a1705664a0de04ff8065c61dd29ab0e7de2041f780ad131ae6575bc5f63d940104a8178585269c6ebc107b86c2709bc8a17c1bc2e64865ba71cdee66239ec2fc3ed05a5e37564b525e14df304dda99cf3effb91d319e57bab39a2ccf33b3633eb4f32d069c5939a9486af02f877adceea8f1c59febd015dc1b3531614ea150a24db64b545aea72236373d124b47a22de0dc0f59558f49c511ec742b9e242e58e4c0ee8635bdf82ed541cedb99105a6f7620b7e3ec34ff427f814b3ce0a5795ffee8e2372ba5f7830f483db31d074ed0260688c1267abab265ace791c677fbf42c05b627bce994d52eaefb5f366bc46480a9dcf4bef3049c3aa219eee3aebaa7cbb0e1db0d61b19f4d280539ce506389f3d2610a83b45a42e5c091cf34c6bae7503864c518f0958c0bd093af275985cc1f63cd13e46a1551b223a09390cb6ba383ab8c2e3afc837e3be98781f4411fe2786b640c4c33675096bef98fe603245b65ce6ccc406abe025ca92646e80da3a1c82558ff2299ccae908dfd9d9d2d98f4f6842f2084e06a9c2f2bec4fc43481f5acfc3ca28953e31ba780edec56579ce544374faff5602ce018a2e17757d80a17ae01cb1ad2b5753db621f2359682bf479bc684821d1daa9e4d42bef9cabfc67ebbff54893bc966ac6b4f3035cd49d2141f707121b2efdfdc46ae8298c8311858058ad8f26a89a94f10f2ef745652a4da9baafee9d6c63499ec8757de7266f17b4fc353477bdfcef386af0beeb00c739987c6e8c52e20e968864d0503d28df163a0d6293675015b05f76e4aaac980063d944a93efccfa62067bf9afca0df9a26b6c879f189c3719ae048ea56826bcfe7c72ed662cf9481c3f2d4a53fadc537aa7a9464974ed2afb2772408ac609e5450cfb498fb04fb047b748c37498b6fa1c559164bb92c72e8a8bed9fbd717dee0c9cd5da7c553f08f8ac9f379b14c673ac37dd185f73df7f65a0d490a51468da7e1a03f251e2cb45d69ec6ab9201055ec34f2a5f088daeb8e8d04480541deac1ac989a10a82e594ee79512d071f56aa4b40214cf90c3f81f3dcb8fd93c3d0587a6e444799f28158698822880fabc69c9b9c13fb78c39e2de9a0681bfdf89390e8f1a5f17483ac18141eaec72218c35d5b138004249b0ec2303d8a59082b0df9dcc1bb90d1c38d0fad869350159dec958e219f9d872dce2cc240b2f9f732ca241c5794affc01cd35e37fbeab40a392e26e1599daacdf772562eb72a04701d074312cdabba4b23e021541f4c48f745f50d0f0e3bedc2e9c72be52366fc28d73c60f39548d78cd8cfe0f00a103154e8fa01b21f6b8c52037b935f46bd0a943cc7797a4c3afa7ef948257ae7aa1ae4bfe46e62d4f44672aebfe118dd2eee6ac9238e4fed26fa1c71619af40441f6ec4dc7e9b3b3cd60f2a71c04bd538badd7af1af9fe7ebd63ab9888201ecbb9bea7c58c2961617afef7d9762b5ff74184f3dfb93c697901498248e1c0e5907a7cd8b809522ede18069d7f1085871af90e2d08fcd2270e91ff636c0d611924a8ba9abfb2dd81aed6d0ae008ccb509d27e9f6085dfdbab3e7aa9028efc3b52ef2e99211e14f610554ce4636523b2448ee828670c69a097909c92d1c772d8e7d253cae75b5aeab631f9f08f808365913d35b2b8388bc7f843b2dbc21ea70f13c28624dcc0a4c81bfbab455b433c734bac38c865a7a16d21a85ffd34f7e05a99ae8fb4249690801ac6fea74b81917693f45cd6b9c21936f6f35323a3f874a047719b74ecf9fa1dde723c2164f32af7de8078cd62caf8f6b8169d013bf7a4f37e88bf52c1f4b9f2fe97dd028e3c9a341000e7552ffabf7b2c6901eb0969fd1de80292d0f151267e346a97a9f849133613b412b6dddf06917d9a224854f396ffd583698054c4821a68b88c2c962d6f59f0a73b03c57587cc6cf69b8439f4977bba8da67c4403abb96a8f69ac7e2e7964aac7a820521ca4d2194107b6f05da78399c8514863c0b1d2ea828700e8bec99735ccdc03f49b4c6df59c0f3890c6bbf23a94b057ef3c088e661030cb134b5c1426234735b266481254c7e30c377437e8ab15a1525365d21a465c2e8c0dd5e8246d6ff54a95a57065ac6c2ff523741a092d56e9e83201f68268b27347b7a306f9c4bb1cbcd1080e25155b7403a87142db6ad5775a431f4dfa8729e258db2cbda90e65e4adef0d85ae7bb43ed263a7f89d136cb28c9a06c659e3a6030abf03294aa4ac10a69cf6200c5ba83b5a10419219572f4420de39aa33d38223cbdde4020110f53a8318b552594593c39ef73b655a0ef93e1ea2f88f48f8afaa4637e626285e9be4ccc2521f05ccf07b33da10b94e207b1dcaeccc4671103b98e9050abf0175348e24529966a32a9f94ee7faff5ad716eb66d02867f0ca3bee80b1206243b0e5c22f6da5d7624a2066b471b3934d9e8c0affc37830a6ab2d93e7b6043e0bfaa83ef2329a68d39f2c13d399dbb70d7e1e2532ba246b0e2389aff71f3ec683e4170e18bad26e730076395b7710a958be326716ae2b30642e0341925adb72c33f7c6cc3fd3d1b8079cf07775a712d82cffae6b73407a82508b3969b7c7a821a7438c244969138d754b95857e422d13fece3aab15b0e873964abc22afce4b1591949b7c313969cc98027d3dab3a9be0a2310a7d39b55de403bd23b7dc6ee793e6ff0ed7ecb32c7e77ef5a40b9b64444b3fc826340f9f41793d909dac4565d5de8b20ff325e8fc1c20877333fe9d1d7c78c776724c56dc6ccb575f49530d960d77c1919449b19efab91ceee3eab0d8a7a868f671281bd72b200dc52e6c45692abaad7da22bcdd7e2f6a6f50ecb3d5768682220387efc99f857b1cda5a4953824f2030f6c0f88f0f0a69f163468501619e002c0e424075a41f2da4dd16aef595e8c1bfe473177874d804570263b16fc08631461354256b2ca71413c1215dfbb7d2b4d03c6a73bb36800ef964ce174b20e63367b917f3c139fa957ab20f2d28ad4e0372c67ff328757e21a754d09e36bd97237115f57ce7fbbd64a6844bb5bd9f87ae2ba051ba06ef62c3793ab001198faf4b80b0d0f39bd75ba785921f4c27bfeaba3df2302af5b5a384458e3fd9ca17ff57c8bb75eefb4be51d5009cd1726a0d1ebd33ab0dc096fba99b584d81f3a4c3223e1c4341b108f527e94779f72d769e824f3ca7ac8c96d51cb733bd7a1f09c6366c002539f6877802a69855ab2020eff3e3666557055a521fd42e8b3de1d1fcf66f8aefa56c259e17232e883d78cbfa2bc5de8fc6693b5991cacb840f71525770e6a39dffb6cffa69142664c5398e57a84f444240b7b28cb018e9d8a2aedf0c778b3ba57e48ed76b7d0e93a657834406ebbbde680bd3f8a2b8ad855a04dd16bf4d01761c84003e48a473465bcd9b3d1d1dc8d4203959b8a78bdddbac127b32a7f02031f01a7c7163f5f20ab595acd03e0530588cb74e5f388dfb244569120652f41a3b30baca4934ccaf9c200ef6d0f95f28583905a7b1abab48db56203f1f2902e6695649f1411c9900a4405b98b5e1e961fe0522af553b2204f2e9ee70dd6de224242acde5b3cb3ead0cc9606bd56eebbf5ac0f5c2a3efa456dbec724baea9687326236c4740a3eaeee987683b61288dd4f70a6d26f5614dcfa5569dca164d196016d0fdf6d721b0c6e76b52fb5ff64d489992680e067f030cfbee662c17b9516ae9f2a08586c79fd53e71744e50e4416ea429fde54a48ab84e1ba79542e419c47e01cfe0e6f415ef00764c5ad4370e3219dc1c5e38f0bac74be8ab66a135b360d2dfd71c5b6dac3999b8f70b121c9ab0d13bad89d3d71e3332dce21c45b2e2acc712e0ffc6c3fabd47198fa5e3675964cfb1737d2999709b7b1f76608762ddafb308b4ed1386073833ef91d2115ed65eb6c1513b2e1e0354039bd095f2b12333b3ecb2568e9acb344acbc31aea18aa64db0b93f8a9e56a404b0eb1ed4b19ea5e969557b66d552fbb8d7dd21a625c940843c91f4c62bdfc5cf14308e860bb9523203ffb6f940e116629cab9722e5e5544e68a4b5ecbcca09b58bdecf952641aa8c7c4d5436a3befb63f7d1f72d69784dfeeac4f9a90dc08a5a204a6bc48e8e918162058030c36e8e1fc161a19c9ead38d1547cb778ef633226c5de055b14472f2281093df697fa58a55da2c4f31a4dbf6f9de9004942d68be1450cf572f0d0c6d30259cee3feacf16b0e84fd1bf582b0a66760c5224b3b8fa7f6d930afe8f196031dc08ba7f760a103b8d8602b515d31159d59daafebff7de81bbfe49674bc043295e9ea8be71c78ec5cb6ef33a9e0f6f9982bfb9082388ceb3daab5bc7da9d33a1876efe509bcf62f14a2397acf8dc30bb4cb36fb13b178b12bbeee158904ee8ba07f89dc7bab3801adb41f8b2d29f29a6b94612159033c13f2a581fce66b0e4642d20550560126d419d3b9b7825f7e8aa7ac2d228f1767f6bd15aa59fd559f56c5cae5c462ce0435247fba9c6860723756065a309cf00146eafa39199903b6b51686686f4aa28d4f4f439e76a4ded7058da82e9896715178ee8ef144a4b3a7579a9c14d23c16cd0886993f01125d46e9a8274a2a958c5d4a88af0b59b51ed9af611b7e87b0e9018e0a97a74ea88248222e7546db5a2f38b81cb0f6db701882b0ebeb2f0bbbbfe6c6430c0968b9750be0e7f2a3726d9319f568740ac270e008257a2d20e61cc74cdb5b83ef67ac46092ce1fba8fe33f4edb2613c45e5537169e780aec962339b194159b44c24997b3e773a4e138aa90a0e27ce0645f9bbcf9ccacb786648baa9dacd6b6dcf9e49a80dfadc8afa9c029ea1ccb02f099e51c5f935657ee5686d9db24e41fb54074ae26b7dd0ea341bd8a49de041a58d985d6da88914ba820edc5324c6a99c7335ff54748c61ceeb9c902a2b26fcc8dfc0212d86b194893ccfef7a09688a0e2a3ba1349a70880e9bd3a16c48766a68ac966b3e3b611c6854978653fd3e3c069e046e57727d6e5dec538ca764566433d3d306dff03e874f94d84324364e2a5d5bb0032c20904ac9d3306b07acf49572e39b4ced50073053b2b10188a6c5e51b52651dd46111cbadb3b3d50ad0601940087c0a2a110a87e15fc05d5c5fa8081abc6a40c244bf01ea8540fcd8fd3d315f75bf1acc759934a100bb9fefa659eeba31686d5ad01e07142dd4f5b2339e02846b77d6c0ca5284aed78ff6acee57b57947864c536c63da1af4f7119d120f02f8e1cc7cade1816d898f8adca543d1bdc197bb7ef7bc999fcceba4aff9fe0197eaeadad27c0e1794bde3f53263921dd7beb9d9b428263787cfc7b3c49a3b78dfc59926e713db9cabe1aa29e75ec2489af925a0815e78d8944f91ca31344ffacfce038972f36b21f362bbca2d44f7df8dcf94b81c45783c5e1f02d5bc21f461d8f5620680972903f49d5a2cbc8011e81335e7e7fc3df2b4cbeaae8169d482d309ae78db58263bc86c54c6057ae1824f1fd797285591fbb7624ee818557bd4f88183334cb4267effa537d58c6ce48aacd30fc072f6c34813beb0e94a8f4e2b8cb4d94c8f008434edcf5b10130e63a0ad6f8162bf81c9de900003b843e4f2981c1e193939474069cfff27e3a20e669590d90aa0b7092b0ebdfee72e791aa64253b668eac867a63337d960438c3a2a141f6c87b1b1b5570a51521c210a27f2899a9baae1f45f364664d2d344d3aaf6579f420cfb8dbc6a0bf6871fe3faa89d0e2cee25d20271ab4c42f9aab57cc014476ec50ecbac74e51728e42352283b28512ae29c44de0934413c25f701e2b82e94720b52a96cc36b3f416dfadf32b145fad3fc000b59712a9b48425197fc84f1fdf45fffa4af60a00b71157197640bf6b7b1a2d74c9328c2fcec730a5a43c624e1d51f605e31bf6326534aeb9897ef6d79da7a497c21bcafb4256f76a72a68ae7de0853ec0a791aafa962fac88ed5fc2459fb57b0f17fd464f20b7dba7070dbf8e1e86403d726f7be3b43b4d2dd257f7fe9d95deb9a67066fb68dd398ee18fc93be566d27fa6b1c3199377d31bf7e75c8d2c39b10857fc8450cdad507b0ca6e3842cf365358fc923277354af0b33b7cf4c9220c22c36cf4e8088ae9d2303a00cb9ed834e4b6f8a68767ca4ece490dfebcfaad167cd6bb4b2e7ba0a6075bc8725de1af1bad5119bc2691b093ccb44a474a3decfa2de4e42813bf81e59ccf7fc2b99600b30df91602301eb43eff02e74266c6afa8d02ca85fd1c7c56259f3fafa0bfed62c3d7c9bb3385086f6bb573dde9a01fc16b52ecee459849ae0ee89a5ef77b6742f6a6f00dfb6fe59efed93971c0323442d31a07b9b6a3ae324463b1ce5392cd912e300ff484d842d2113865189fa728cdf5d13a7531afd04bd3689391b7e1fb567cec13cf6647ee2f8dd45352933cc381c8bade2236467a7082e68542ef0726a9b9d94ec9e3d69c75bc9d321f6524ab757ea2570b0567adbb83509b5eb75f510b8ef55c679e8f36975115b2ec55d568f6519b93c2e879f0e0309e07041b7462b1b4547591a7ff0b99c004db20266a0b2a69f8eedabfb9c5ffbd7e46e1a20126fb070789e947cbfd4901cd3a0c7a84a7d08e57f9f55daf64f3b9102567900b01c12fed1b36eac99b298dccda30b737be64547effa4897f7724e694235b781f797303a8a9392ee79f30bab9317100990bfda031d8b5a08a49b7f88f0767c66fc7ae44b8a2e277a0095205f35ff8ddf1856b86bab71e46de8c7372630d0ae6965e1834fbda23a4ff4e858447dd7fccd9cd98faa9c73cf5258d2aacbe94cbf0972785a678d9ad95a254c2bd063cd9fde9fedd7d7d9fcf5857c015cadc453385fbf789daeb951481eaa557cca581a1d06a594af154e3069d08695b4b560ea090059976e16276c0e521010df1aea01f3273713ab170585550e7268a284d4ea2e491fa76fca81ebfafad2ae982c4ef1007a240efb5b59f4c525cf91dc852c69636ccc6f8348c8124514ebebf9fbcab8bcbfc63f73f45d353929a39ccfc12f0ed624227d17965226363e24649ae973927afdfff89662a7147edb055d3c001dbc852491ed15e355c15ffa805b85ae62c229e03ff68e231363e2c7a355864dffb82880c25aad3f930e1af9a281b3bc9b02717cfeb9ba624912ec03a45a3cceeb37b4409e40ae37ba2108ee3d3a34932353a5d75d97202781d340ad64072a1dfb7b61a425722da47474bd359813a25b1e328f9e90137d556e686602a32b81ef23490371270acd42fe44f540354171f6ede730960addfd84f56fe643e822770020ae44e602b6e66f8c23be79f2f9864be9e0808cac3634f809d2ea6d17744103b6d6bdb66786f611ee0504cec8d47a60057602790a493bc1792cecd7793572e8b83c148f8bcfa7999f0654f936555f4f38cc29811a5823848a492bc766f3f66468436f06d6764bcb2c461cdbc59e39ac1c64d4989a8d1c768121633448c54b041943eb1a6b0e14e3ac3090a42ebe5cb3cda55dd13b7fcccf80b968646c63d8bdac407789eb43e6fad3466cdea76e88507ade03bf8fbd1036d175c775b0d9a33a49e47600c731972a2948c336b912ac515940c492bea6612d3343ff3c8da7659a3a67ddb449eed4d122a8e9f61d1214524082fbebf38b8bf91845ccf1a1035e42857c1fa3eb5d302889522fedb6777c5be98130445adbde2a114e3138a0a9755f73c96a6f67011e3a3d6e9ffa90ca5ac538d8eb00ac9917056c71aa8060596d587182bf74d116e0cb5fa77109e44971902ea65b1f9b6380095394a992e07942a52903fef46493f2ddc5595a6a054e200ee9a2df48593cc0720142f31595150689d333f2bd506fba3e93148d27edc0e4239445b72da550e579e5611f83e2089d36dfdd59bee42e4ab1047456cfa6e50a0928220373af218efa2620aec8f2d1a3578ef133d009f05b9f7ad9336f702cba5fe5547883092823df3b38f950a2cb1b0b64603e21d046cd88595a1973e2dba64c178813ef111cd5d83c06cac91b7e2b3ce918ff1157ba06526b3cdef17370829fa26fbd2670a2c7ccc3332a16aef8a7e2c1619b1cd4b0c63a251953ff91e5d410ca0c000c698d16177a0435f2889fd7e9cca6d58a019ee7ca5ec6d6abcf2f8323003c800a8378d770568224122b2e20ed358fcb99e88bc3a9856335cf9e2e401f3b28706b09a5845ceb8b43ffa659cd0744425de4859f9fc00a7845234f3a2cd4157b0e3f2136f303f3f024db5695eabcf33b77db372597b00fd8f25291175d61b8b63dd61d93541cac2fd9b8d3c4b675bb8a4ce06afea5c1a211910071ab82e27b64bcf1cf4699aab8a7a402c5e2a4ebe21ed378b4918d8fe091d7b3c07e9017df56547c8f4d1eb713e466ec9321cb5635b050600342ddda90e6eba622be64e99e5558b8ec6a6c6ef2a65d12f44294d417ee25c09daafd80f2f634ff03b0b8b95784fa71101f405c953837d563e67e23c40a155b79c4a1995912fcf588b8b8745f20c0839cbabaf63eee4d4781049e238ec34355e94a7c98a161d4597f76d5de45a7f52f6a4f837c8325bcb0a32e580aedfd88ffbab46abd0d3fba19b20bfdf4d519328909202c3fe15c151301748cdafbb5cd75f0a8786cb6e0b9d394e49b5ef0d1018f4bf20a2dc24ae6127affaefdea567f634ee4670e824672ee091a89c47f3de6f5e4fc9b1a43be1557fbeb201102f3895f8309e485ddef5eae03ee997163ea3f5612741c3d76ffdd45d6ab76c54a7f26aabfe3b3f4ba81d01b167f53edf60f0aafa1b75523b746c13c19dae2e921eaf7c88b32b9445bd467d26381eb2dcec50f91a5d5a2d541a9e5366ea30c420594704de38042bfdd896216bdc2051f960aef7aeef81ce5b0ee232cd2892a410169c5399078082cb30b9480db52838486b37c6b3fe4a68fca8df10a4d590264cb4057d008558174bc342189c36d0e060b9664fd8e184393e40ea923ed9f687fcbb70a87955335e6aed996f920305d5071aff22731fa2aecf70696a15084d340b5a65bbb0bf3e8eaa829d96d13ca2cd71cd1501190dd6d0b38a782d5f46833f0b90506b269955d762081f811b8ae3758b02ee6026fc4645a3bc8e3d2f903dade704579cff755d4fcd3b4ab4ffcc837a2aa99e7a60a1c80ef7bc0f1d3f17973f8345121ad3533dae91f5c535a7515dc06ea7e70becb6325f60f6695fde5aee70fa1da4f754d949ed031bf415011743347d24d87c3583cb8505702ae29e9b737f9e295226ed73ebe87567c1048330d9eacf6fe59107703091f9e982db590a7da4d180b7ba200d5fa13a07a45a314883c67f3a46ac163e7eae56fd1117f4c28f301f55e52a092580f5111908343c7f1e4e1e421e9af2fd0c14f5788b019b07678924244a27d826ff1df3a4e7fc46d98fefac27e9734b83e4f22a6736e0e8e949ad3618e264658d338d9b152fa08761aa98e1075bbc7c9c8ea4eb47f9b3e0c71525cb9abd2c992dbdf477873e4f251ab8e3d4b9371b1f42d0a9bf603d1d1532b661ed4cc8b96504748daf174042486a08daf1309e8f7c7027f208e6f2b3f4d601381d9b8a2652678318eb31b48bef33b3d492f22650aaff0ebaab959366318a8a15783ded4910e86493bdc7a3238ad855ca1d4661b818ca9114894ecff34a952a38adfaebed28883993f89fef65e5251bf938b928cae5be20c847404da1cefda54c5afa45ee05369234c240592cc22ef2039a53298ae6d19302107175c23bf8a02e10b0f4e6a36e3b60c5bab05cd5f472d9a44d92852737a2aea3dd68c7a5af55f3e167017ef24f52f1c55eab9bab94e15a8ed46953b0428185d41e35a1c95dd718634e52cb8f5c14ce512ff8d2c446b051bd508b4c728a895cf5c337088ccf03193d6eec6284499704e1a6aa64e55cc54d1b62f4d29f9a0dec954e5d744b7b21de5bf2cd4814957f5ee98be4e27ba19ae358339219c6491f95ace2944f2e0686ebd97873d18f4fe0c4e4bf57e4ebfd72f52c775efd75290bacbfe6791f9b3a749d59a01e88fe7867c57de5965c909b60bdb7e2bb7180512de91d7a1ed6b4b91a4f39edd1746fdc6d20f6991d0a447072ec6666913df98ee8a2c245186e46cc53ce631d91154490140dff2423ece9b0bc4e4a406aa58fe785bfa17f9c9743e96fd514a59dfc82c649681b7250ec4410e90dd301916503891d28f17f9bc41a0ab68b3bdc0a11c2fe08c4e2a9ff7c6f89e6e29b9077be7e445cca63ca04e4dd3d34cc132483490908a0a3a4e0ec35b70791d6f7d5459336fb8886b945a1961c8565a1d2bb11edd9e16faaf5d25279bd1201b95b635316a64381cffbb72cd1126ac2b500b1a61c9bfee75371e01523385e2be5c222cd7128223408dc1e56b379f093a0ca4bb827ff7bd82f8cbea7f1f6e70ef52fec46a20ec7413f3d03ccb8133a7e86815bec5e7081b3d51a3532ab0cbf78c044bc75caed9040e3ffbbbe7e01e10a5c401424236984f13e13108121ec1726cb58d59ffe599219df8a3abd84e7e5e79a523eae60966b33d10eb7984bed11abc59b4e31653756419f13fa5d951a888d5edb17f4bb93ea91b8641a2e0a58e4d9bb2b1cdeac03ffb6b9eaa14c8005fbf5b56f9795e3b9764eb55f0d931f7aa003075b4564b4a0090afc158b793d51972490a7cd6873c1e9256c1e490452fc8d5f70713f47c7170210ac320b3ffa1a92065b55877ead3afe98355289e4467fa7e56000689bf2c64d22d3258365a3eeba94e58395a29ff63ca1d81e81c1613df424cdb5abc65a513318190c34b6479d42acbfc821f133c45b1e0d9683ef1af9b0e1f314e4f50f8e36932a04aa5f93244574551e176e485069ca1da48d394da80ffcdbd76ec52f6b705d47a06eb07e3d69b9700bc7d99ce1656b966b4332636018a0c1bba5bac0d14395ecf0514ea7a78559ca11f725d852e1749d046cc4dbea1e79bd2bdc928cab5bf3d40a5e2a1c56013a5af7845fba901be9cb8283d0510e501ae879a414c6e4e4a3bcd80bfd3b8a5a7abc951104631f550beac0bdf14d44dc7a863579422f5d2a6476806082dcbdc2b679701877cc84698c31ff181f32dbd2d4e00e283a927726a063e9f8271ce0f1e40f2150bfdb9b1f1373a8282118154eb001e3b3ef45844f6ecb410f7ef537ab48ea63ea0d8b792afee325132c9a7ad720f536f95d86998f72120ded241f6ea13dfadd2f1dfd31fe20525126777aaf18af85af98bd898f2c0e308047303a8430a7b61b66ada13fceaf64b7aa6092efdc13e6347218c54fb2700432b3343469ba014f8298b3f9051e85dabe7819da80df11dc2c73e8bf38be4f851fec954c949af2b02cc7f51ae4cda729f95b45e19a9fcddfed5e635deb0ddf164d37548772e34d7aff4024f61228b3cca8af5023c67b44a60adade0c9ae74fe67862d8a71872c2b1b4556a4c63640d6d6e06950b4b2578bde15e892061c75b8ff603d37807f95136aea2a5239ae2334881ec7632d4adc4234d5cc2915af0acc9371c1dd34d502c324944010e4dc90b653ce96d920b1353d70f318da19085d10672579a571ae07c0883e632eef8da20f2610d988c50f13a139492eb8948136d4891fc42019e5322a321445587288ff788a22361eec4aca18f6d5a351d816215ca7cdd402d688042ad8c84f2ade84cf30d0e555354b6088be0d250f9d09f89ea1c03fc83f8ae696a19f6e1f5f0fc4b3f1b91bcf1640cb07827b0e91da62c2532f5013161624215b742d64d1435149e9f42e70ca9fa4cf5bda3b9374d4e8bd7a2030ed09966740f10b739ba1f9ff687321d3352e375560ab88b91c2cd1ac6240f5bb927717966d3d4b6e02b26efe7feed3634356010331d2a310d176c0dff432444ba918af246382e232d8dca8d92c87fcd5d1e4ff9b64215ff11178099cd70c76459a3166efe8a46260e849ab42aa3f6f88eb349ea930278429201ec16f356faf80d86c539091e6d24032991fd831f53f0f1198aebc578c411cb63bc4d47f38b40b4abdd8fef8b3d42c924bb2ee964d6e998f50ed0457d5cbc58ed47f36d2ead5a1c5cdc99546045d12e0688292cbafc1b68e0bac2614e9c956629d9ee75f43824e3458c04569d89d3b8e0c5f452119c10317d167a594756825266d73221056460afa242e062858f7c52be48f05ef8761e2ad6cc7c4edb8a43cc03d235612636518727472b0538ae5889e094094d927f2b7551d23b9ab56136e30b082933d22a2a9bae00c93868b82f8c2e12429ddb64ce41f1e95facc52db998c3db88751dd58ee9acbdc1556234b01d04085f6209eef15c33f4972d49adbdcb47329c9a528a9242cb327de89c048553e6301303ef5735f0122ea98261af52e280fbb0ed74cfdf59c35c9e70eb18901e8f5360ecb3c6e1e84e4131063c778c42334ce26a5a39fa0f546f33b149037d8876a2d36030cd80ecaaaa8169d1c275b8f2050cfeae334f23e07025aff64457b4c11b8015ddd990ac3669cda0c9dfeee988ccd9698e83017ad11a2890069e79b8e3f86763d3a5820fd214b409778a5d44b9cc0a9f030fdf327457cffec3d2d4c76b093481bb1ee8d6ff13d0e45ab23dd614a6cd5b532424ab67bd62fff7417d0781530cd9af81cafb31958b8e87d6d986700972ccb0fa8480510e28429974e701a3202a9000fe6b11ac113dbf3e4c453685c7bcbfa43cde6ae483a2509dd45cb5f13ef1d21450efb9500a3317b402aa8e45bdbded1b43eef6885a85868cf790a9c5bb6a3087244d64a380f97df47a807e9eb5b50017f7e40ad2545f69a3c9c9a5e001940e11134af735545a52be048b278858f20152fe915a135d171f209c67af336c0f804b05b5db5c266b2bdb23782","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
