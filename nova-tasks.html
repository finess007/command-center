<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f60c7b42e357e0e29ce2b18cf9be59dfc154a313213939a0edbcee0ac88724ae355b5f89bd1ca2706e6f6a1631474c33255bcc3cb177ba105e8443608b6c252f2295c5564f23fd58385452fe844500d1816d179be318bc34913be936054478ab08957e3a120604312eed85bb04cf2de5914c325ff9008e7d22dbca639c96a92f1c5de685942e9b86748433f4887e41eae673d130a9d46709171c8e817ecda014062761ff6db62ec1736da594a880cfab780add69494c4b69ed058c4221ff0e94db486cc884b8f3ed0885da2ed032e2a879dbdb6e943d0403cd0f6862af626d9f741cebc77b8ab699cdc60f4f95763454f4f655d7bc6e14d922b8fac757eb457d2363dd048c503076d95be9115662fabaa69485802a20e3a3703965e831037f88b3013a2d66f0d51f74b7c1f9057a8cd0e2b5e22a167f21e048d227fa09bfbac69e07ebdddfc457cbad3e24da082847428dcc507d66c2e0ab125fac05f6aec4c7fdc5ae4843fc6fa204e0c3ecc8a95d8b5e8a229f789e85786f3046809327a57fc98efbe32a9c69fbb96db803358408c1c86718ad18ee041d4b3f523caa3df0b988a45cc3c850cd95eb6faddc0bbd540c807d3209ed4be33b0a5e06f3024e154bd264bfca4f301069cb15c3d89190f09767c67ca99050c60a6dc8e1d72352a7838d1e1497d10c0f85252825aba0bbda9a773dad090ddadbe497b8196f5c2a2654a2061e18eb37887b8e7824ee1da3a7268afa1d9b6640037487258b6f0ac8616ff321e0790381e3ebfb502a029db87aeacec78a3177200575af5e2ccd40d982680d46990c1e79161ffb03d8f6f45eeb0b44de14dd7e55e7d37a10af94397109edcab60e3c3f4c8e2b61447f596db7fdeeb2acda5a90141240d2c0cb8e79ed89c89f167bfb5b61475ba33e6d1c1a0ff0a16cf206640ef27db18dcd57dabc20bdeea51acd639df9abf1268bb15998d028abf6ad0ec0a70f01efef54b9ba7b1133d7862b2bd83fe57f5350cd9e561f9fbbacd7f99999276b031779825b312f6c5dc284ea02a7c567e1be6a86111e6dd0ed050188d66e620e50dc7940e34a151d63c1676d512f50d8dd129c9a40f9cc7480b1ca35033242b5d201a1bc8df76a1bcdf9083457530e0788c79ce15fabf270b890de352ba66a1640291051a93e396b3f00f1034d432dbca5c20efa3afcf3239736dfb8db8eea1d5285170d3b2e36f49f655c9ec2c02ba075339960336a8525945b491bf018b773f2a9730df627cfa542922ada4cbc513078fa402fea1ee0ad812878749816161304a51f2b8647c17cb30de4d5cb42aa05a28863e894857c6c8141050ad1163139af73ff227265bf40ae1666ee648267002654d82d7fcb916ada0d228edd71c8e4de210b0fd5b1b98fda475a7e6c3bdfa4473eb04d5ebf5f7b0933b3e209fc70d5bdd5ac26086e651af6e537ec27ba7f487bb3544202e6dd0772b7923d28ff8409f03ad0fd398f071c6ea10eedc3a9a647f4ea9e562ac61ac233c400d77167600efe47e8f8993983dc4536bf5efe7f8fc2b3605025998af117c5c5bf3e1a7042530fe32c1a8cdc17c9662359504654746a718940aa55c2cb84e35334bc6ce611a66e7711a2605d1a0cb46bbfbfce83cb21022b448b456ef7a3de930f7d0494114938bc855b495253711df2baea8fe9e7b6871484e9287518b3443d19125a9f7850a6dd2d512adc42b4de714dd1e9d4cd8fc4756b7c1a061e161764e28084b9dcbfd9559bd2f00a2372db81b7a868b68a1e5218fa8a351dc7d2357d6970200fb27fabcf5d4c63129ef54cef8dc9f123802c441f11e54fe9608a43aabebf8947721de6ede7b3077d59ab7d2c31ee9f5f05206d9fbd21a219913df01c36ecbe2cf26e4ad42b7283cd298321fbcafdfd70f92ee902f9276b273a5397684882c16f1d67bff7d555a42c6e1b9c85761994c11fcac6c5732618595a9a8f3e8b034d5b9ea0666dbe7806979b085ec96f1f12dfabff8ef3cf70fa7ba0d0fd2cd07031d2516eca3b7d2622c4ba9dbd2f6a8b71d876c1eadf23483ef45d9ecdc7d77d6d73d214290e9c86838682fe5ebc1a022a15ba55ae4ac9b65b71620fe1a01778887d98c9a967c72eb79b5237c67de475a59fcd63215c934995212a1afbf8ef96f202e6828bca180b0bd460edc44bdadb479bd20de6e7f9829336c8cb5ccb7e9c948aa8237fec7187a0b3296c8441dab39c88823c10fa15a55b5dd90b492a227706964b3dd33f23be4d22fd4850851780cce4d3a40a3beba84f24e765c41beedf870ec8d12a26a1d4f16457d777f25fdaad1ee99bbfb9ec34a7ae08cfd11b7e75a3b3aabf5bf69f33367259c8b8163f714a45207f7ea36b78e12f29a4da1c2b45be90b0b0863644786b309e712faeb2dd555a7068f536c7d3546c7e708062c70b9a3301cd4fafbb8717aadc4ce7409f965ade1c4ddb2ff6693466d5689ba8747721bdb118cf7e7ea542f5f9c38528ef770a90547f6291f7265146d65a445c5bbcd11eaa2ac8994eca85b292d2ac05f2446ff1b4c442d2e687a2df061308a37af33d4a5e0137ee30557526373428fa50140478d08f6f63e8c1585f15683d681b798363018fd8a504e1c87c34c6fed2b363184ee8a7d115e820da2bf755c4d9725622db0909a72b8686708fa56f408186d3a0ca5c1e22aa7b70c87ad3b1fcba1d42138d477e36a3d16fb1b4361ade5f99261ae892c6a3ec54446bcecf49470f8e5aee3b2078e2b677f7bed8786452cc9469939cfce6f5df353f29f05cadfae6abc3cb03f034db3d58dd74d11e744189c8adb17a7929d95db364c1a6d5fa88a6fa79685254c5a13746e221c426a65e9c6a08a59514c4eb6dcd5cabc146835bb5ee2a577192f626b0addb6865f35acaa6cb415ffc5043f6787395c64c70cdb444127ce5b7909378f0b0b600183ea9bd70903d94f448cc4aebb52ed03b6d10d0a7698a4766d605c799a8f8f7bbd93e1a71f2858d8aa4c3dc8fe022dc9f0828bee54cbe5a868c638b5b1bc17fa489e135bb5095f87af617c0f797d59ac0b49bdb540c5d6b2f8c597f7437c9f97f162620aa6395c1a765c74c502ca2e35c77482fb423d748a27c6f0446b9fce8e38117de4a785a49c7aa985c11159039cb8d91b446634365284244d3986083bd062c8e0d174aceda1a6d24f48d0f5a2030e5681169b5f20dec6996b111b51b3800cf569693b4b484d2de0c160acf6be6f7b194c65e5b3cac29847db51f53680bd1619d63abe0c0a8501a0aaaed4190f5d6afe353507db91b074f1219816e9780af5b42363d5c96a64632e8d260e4978efe753b4a5c2dc62500086cf964f9745eab5a817ed404b0dfbbc45c7b1a51c3bac5218ff2a6530b7ed541282007b1eb6d08468ed2108437d00f4d2b499f21f0f941c877e3a2fa55a7feba1364ef722419f13773db13f5c226330329ea451af421635a024364086273c5bd551d6dd727830d8deea609fe0f949dd53932562fa8b281acbc62f8f53105799352089477c716c8646529ad45c655292a24f7fe1daba1bdd575e4b49f4647f7790607b7a58b71aaccf3fbc658b01cf5dee5fb02bc9b3c3fe95ffaeac56f18417b79793341f5e06ae6536722e8a5fcbfe674b072fe633312fdb47556ba568c70b5ca8387c95e5ec031f74b4f8adf05ec40d482f77c144edbb825df8936461ddba8a281ab3103e8ae7a86696483529ed3115e841a89251be62988b1aca9c719e6b60075b0da28da8df268af21bdaabe0e1b99a4efe30290aaeefdf10035ad411e49396d239a1a9cf15427cc70425817f190df9f7cb41cb4c38a4fa8699084f614891e040f721dc40bd1f0254dd5de56d7c43183dba01e41e5a68e2a2830cb317bc57e205a6ee5069b02c060c0cc31ed9e7932413f90adad06d6652379dd28406f618d2abd3204a68da1998a1ef861c4e26af6bb4a5e341351bd156bdf6a4e7d5c6b7d8dd92be6e6dbda277e744065fdbf9c77a318d4a114844be9466baaa1257cc74767dc43dca57ec8f444aa039f2ca1f5da74a2bd4427bcaba3f3d4a86f5dfb96c61572f3bb16143dd735633775adc51483f47c9d008b86097fc69bde492fdc0f6e6dadfa362a20494531128935735bd3e45023877ada73a1b98d4ba95d98f97a658515f46ee1bf79c01f7ba04b616aea3f901336804c3b5bbc3118be142e86b1fc3045575121c417a10a91631953fbb649353d76af5ac4f837bade62ee7fe91898ab530188acf2de5b5201c2b0ce71e0507fb2d7c913d74d147884391b69c1cc054443843e59c29f1602790c55bdd3c69250e388415b85bab9407af2edc2623d5bf413f5e01ea3576eb842dacb0f3f4debe2ddf952158b80fabe3c87b2221fcaa04d611e23654541b0034f40370b26f53e3fef6ee760b6afffec8a9268f4d13d59812e180561e4d581a0d40bb517b31a001b4439b1841393cccc17cf171818e3f811a45ebd38c0733c1e6ee734ac79ac8f17cb3f463f8aed5f1771d2dac5bd042828a5a7d11db54feb56624e7064119fe547e17f07f0edeb10cd71fd64ffcca4ccabcd3197e117c24d7d37f2ab3b9a3d33af98f70d47b5080dec351d8a5d0313a43329f8fa2123aa7c762951686166e6772a83b5c80716afd32f0ea649c809da80f6768df909becfe16bda087ce7c98e78becd440eb75777c91aac7126f101d94413abdeba4af91b69a95eac99b2dbf307d5b671ae28d17b9108bf3e702c5af88152c168c7e631215cf21c29c623e0010f1c64dfc4ed4d25a08c59953622de46ed57c2ab7693764b1f1b32a50a1ed854bb10e38e2f68e0df7277279b6d25cdd1599ab06fc626c3eadb1119d66203c78e180a5ed1cbc0f0bad7dfeafc61a58a58ff121daf1a30da9b185d4d38b072f920a037b0979500bda4dc13f543c56f0379b7377b37841613c06074d9780c060e2ce6aa150f8746c020a30b6c0282b092f1910686909c1d71230c086f3bf2af9efee051f0c762e5c5301e55889cff64e646df44e4f6681bc778cdbc71d24d18025b763db4def964ac16f2e951cc275e90c54a58738a75274094f719fd59cf48f040d000cb7bbb8b08d005aa2d095e0866d27aa93ffbe194782b465c14b9a39d1254da910b39fdecae7d6cde0523737a939e07d6391835fc966cd976a8b307c294f68d84dd740265d59e337f3266776e888762bad6d6b06bb22482cb27cb67db61bb5c02d279a40c7baf8a774c37c455fe3c217174437e92ba1625a3e3c5a03fe767587dfb1abef88a8005ed20d89f084ee43dc61132229cd5e03a0712df2092b03832b84b6d682de98d0c18efc9853a3c9fc1f158b8d40cf9e68f33e11e72f6a038cdf929bbae6ed035b2185d2e61a8db0fc8f5ea0b6c0f22c6b61d831083fc49e050999c7412569f3a6a393696b3f5dcdc1647c88481a1f7e6bfc5deeedbd15da2329f8e165ca3593ab04c8bfeff36c3b32a2b0b1fb3fe4769748c0c397b343b42694c87cc2fb8acbdf1d93f28389d0d07f550c04d86c576f561d7cb0f21d636f6f34e08f039cbc35d23e32692bb022b45148e6c331070ea49d480887a041fade68711817cb40226551def04f531888929e52e40510ba5e514890deb2906f99d4b6707f9e5d2115613546dab18a3fed68c09526b23c1818e4ce444855d6395cab08b96b103e2b1ae98575c9775900cbb9e8c5e3f1536f4db33823341c628381e71d4a4145fc008799a78edc3375e412408daca04d8fa77de9a9ed5e50d8c1b1c2f0f6dedd6ad052998d73e18e52c65d8aaa2784239fd5da6824bb1babe3e16cdfe2640dd99158e1958e361a4c5323efe0fd382ba4e90bb6c267855aa1d8b264176c4a2b12039f6954b7b805a5fb0090497f51508e10a316ab2cfdca9faa45c25e9d7760b7b57c526f34eb157f070ca467dcaaaef46f0bb75cf913ea7a8aff22e1c421dd6e1dfd9c57d3eda1a19519999652ba3b575cc39024b9cf145936253ef567b36bdf8ee610badfacbee75c1d60fe0f6510429a2586d88ac82e8513df62081b6c99034623820963dc0ec2728ec567630fa232bb3055d8ddab8e8dfb7f2450527738800c651e526f144e6aabc7ad446a86963c51a5eb3bac1d6fbd2bdcfe085233c98ab2d9bc38a1530ffc6ccd2d9ed38cf08208182f86bd8fae53f1e015f263bb680c37a87904642be41c76b55d64e6920cad704c78709c785561fc84c636d79d488af7f1239c75088c6577cc33b8473a7d38af9d3d10ce2ff07b6b463527b0d060d14b597aeeb75d571ede7809fdd969d0385f65976c855a10b37cf4ce505a1689015436aafd99a9ec18bc747c27073efbc4ae789233018362476c2254a5f0785771ade1ec2b35422b2e1b181b32e059e63b6e9b6005f89f2a4c5aa3a55a44610684040f08646e040ad4d2c81438eaa96ac40c3bbe2c3cd8f35a523605888d59d5acf2a514556c32e05811e9e17b3e1473e0e59b2bf9e6e566026756e66aeeba7a1f938d7c5e04ec8d4a29149588919905846141e2d01397a344dd5f802c3f376e36dade3a4819d4e1b27423a231512b20b5432525f6e889f1e31eff9f5e7937eafc411009b4b14af919753278592c2060e0ba46eb4b5a4b8864aa5c509b07fe9eed4dce51c406baf5cbc17abe1b83f121533f40aee7a0a64807c598134c04825f6b3114e9c7af5b5edc676763cd96f1839320ce071a6213e08de1194b23d6fc544641d600854a537f23ea5aaa4a2bab2947b73460b1372cbfc6b5feead4dd320dba9ddcf025cd2abf961be91933246d9a0c91516705664d871af726bb68ae1ee8683db6301a893a9e79e9768265a1b1525c1a0eadf26939bc859afc1a2122c1718512fee7f6d37eab4abb914be7f15c804e004646dd0237cca86c3eb11102b7636e0f3828aa38ffda9111fe1d2f98e16c3c774bd16504b69a37ff3de7c5324075d87f33f26ece998eb4d99c498c60a2943337af78ac40cb007b1655a8e3d7a98f01b1a6a37df6457803f305b54028e5fe8974c85aa009ff0dfbbf766c89dfb801a6df4cb7ee2c75f02aa7c6dd20c9b9899ba218d746f3c6c5bb7008f668db0ed47a14fbb7a1215dc8f5f865faa0f44372f879ae53a5aa2400e012c07bdb70a4e803ae46e3dba34c0e4960bc3694806d858ac37da0fa676b481b7f2bf726c052c2a77b5368febff96b63d824ea0ebcf6642370ae60de4e17e9279c1a6b85886853b9bc05028d6389f49f9e891698665c4a141d61bf2e5e04435aac7d1edd8f8ea05753c6dd7e24031d1b26b9b7e2e2d8c409370d68e0fe2682eedce3a263e369dd616fa391ad54a0b6b01d4310c9d5f464b2a61f7a52ba907202c690279672b0be8ab5be28ac19348d76d4ff1ba412498358a20f57a6df9dd16bb01d4b91fc8152e058e89c3e5938aaeae796db5802c91ed2885ad268c552987138d0d968e7ab21231ff20f9b9be8aa227bb2a4c6bb366e3c0496134cd1c33ff66daced9ae26ba7ffc0cf922017256718dc332a27a02c31d9a1a7f7d6e83ff015e0e72a66da482d063b488d1eabaaf324c691c50ac91162d9e9e739ce09f61c53c12dbef5977e155a45c9feff370eea2fc429c05b62545dc5ad8b4d7d36825c21408ee9350af68919df6ee1f1bdf0dc42725e205228dc0ff43fbd7b48f9406c14b108fb0ca481ff70788f9a6cbda23733e8547c8fad0e244d92335df77aca6f7ad139d87f8c99d00e2a1dc861271e7d6c668e9a9ccd74bd1d0572b058a4d18f3a5cce31d73d7726da31b7f356624995c2998598781ea9976ed00b570fae7a15e3b4ce7b86b97218ed0330751c178e537afa73331c9801a20d10dc4979abbeb78c79a9a72bc96c335f0a90f3bcc045b18660e62b3ef5a91675e1f4d256202efab221e4fcc1f1f2810297fabc564a91b24f895553c69abf44cdbd0794537cea0494418ee63033773036446695cd1ac5c54443944c68f1e60bb6b3dba58edd0298cab1a6b7fd8dedeb0e69a80e22d575db225e33851a34a36df1139e572981cc8aa2d866368d511b887d720982f92a4f67b740bb9db5db91f8967832a66d96dc0afb885d86a3edc9e5251266ade32869e19ded2391f28ea0072f0318ee146ede4bed412ed187f8b1fe7b7d793bc271c61b7c035a604f9876f02c0e43d9a5f1279eb49da46d77ea926dd01214ce3ccce3723ec6a16b333f921e92da1ae05fabb560cfe79d7cfd7d31e1e54d55afb6c51135a95a0222f17d1ed27c9997f1d0ef7e903de5852897a3b7437296eb8107a10d782f8331814e742761473ba009d8cf7e7aa464fa7fb84f83109c031e6e060d9e8e550ab01e1a08d760791a76c05cdd7e8fa91ad2a2c1f2552ee89b6501082f69715a048ba892d57903619d62c3be81d134fc5b18f48114a27e96856f9e31dab761919d7859a2f3c8e4562a5be3d588d568ebd6f257e32acf426e43f9b1f2a795c1e57a1c7af6899493b6a28af7d1d24ffcbddef8d6663c0433ab722baeff95c5a46e6a081ff1d84b72f2fd4ce687a20cef2312b063ea7d4dea8f4f78a51b9d08e2acb81f506d5cb31707edfc78142bb2ac99ed2d18df0885e768031a2fe3df91cb7e2d79f576b0fe451d71af186ed85345ca5856053bcaaa1054321648c73aa9100c6a945698f34491b943797c212a60ac02ae9f20110aeee1a051d56b1bc06f08c53f62291ed1eb0d8b40ca94978a25f6c6facacdf5e647dcf0b5fb006345d615c88b2857905032b74b4d39221d5b39b151b4adb092073ea3ba3f36fa8c4e92664634d1d0fabe7699d766df448dab9585259d32c96511bddb2e2bd19ab493f96a796873ceaa90be83ba614e58d4113977db7b9028abf6331aac74e190b40085d6da0477666e51261ed6347b8fd8e161e97e9b53475d66b77b42c6472c8fa18990a78cafe00df48647df30fe17fe326972e51979d8a18278a155017dbfd86747f327397973e80cf34c47e9cc00f622b9c58c8bd02a8a36be00566ab86e1a52d283d981f882afda8de69b379b8993e58228e199f2c975388710a074a193fc7f5e0d9c91931eb5eeafdac6668e32b6737f1cfc1771fe32675b147881f54e2f2086867dd40c00cd3a084aacef8592a769fb776b439721a9ce628c16d6bfecb63fcc0166cd9e3b4ca830db3be2630757540c9d02c3ca8e9eaa2bf1ef7bbf4186d223bf1941bc7888b0e2b64bd78f74bb2a9abc0342025ad734ea1b5cfc631f4dbedc1ddecfa3515dd24e49acfffab6b300200900d367f53ee721f1b5992120a43f6d7dba550f38fd5e5529b5f4f01a143effd5d830f20d12b415552bc5bd8201bbb8948c7c9bed664c7919e6807a6bed80526e69f7b1d3ef29ef0bd038b19cf4da61e436b41f077f565559a400ef1a8fddd8a0b08bf8f94e3badc97131c6d5ee3128666ce3322634721400954d7b40c3305177d9230aeb7168b6e1bb6ea9e8e515544639d205ccae1eca19c16341b031e949371f41d99bc1db90042cea28d9c6334918d7526f0aa0f1a7d5aa58194cc033d421a12b55f72f460d86095c78f6ba3647e4e28e17ffc5754859f7e8bf11270535e6852c8e95054d6648839df6907fc037b8c4c6a136e9e14c25d51cecaedac8034b256eb215c454a517712656291416c9f793fbbbc6fb7127e0f101298f3d86601af7a1adb3292bcfd818bf45a19c722e18ef25892bbb7e725371a0cfab7b161e636ed071a14bc2ce6560561d36be3c259eb56af0814832824ff353907fa548dbb7a1b8115eb75aacc2f46a478948c695a5662117b2ee6707bca933d69587c70e03459b82bff39f14ae165ec6bc5660651991dec628967426961388fc398b55758162f1757b5bb2411575b50856c32d618d21d39d80ee18b5b45dd5b7b5c1fbf535e0566945a9415d8d84c8d64c077eca4993bb19dd152135cc0a126bcb6c4e3e5a42c438c621aa90c569868478ca3cbb41e244564f088ff19af0b7fc0d693a0518a5d1466d5fe22de9b20e03013bd11dc64459c145eca9a3bc26a47042114f047aecc3944d7be316f1e3b0bb985c443415a7b1bf3a97282687a1aab437a13c4c2fc6ade08be9811b2a7d8f245963f8f0fcbec7886dae46f0fd0d3b8b40891dfa75cc53e75a38f3da90f4984dc096bf65b065e495662bd8f976ba4a3f6d6dfa789c77c5e26e3d3420a030926fe5a49f024a7f604d8d06ebeb69ce8008c855b95d709998017ebcb114b4dd0a33b4b38e308aaae18989713e4ef817b526165d5c437707a34c694f9352aabe8bbf8a6df8cf3511c4c8fa280b85ee3ab42d30f713acb428ee45170ec862e13a753a00f207c2119fa11451d941899e77bc5dca4f705006877e5ffb9f886659494b22117f673f1e4ccd9efeb732e293b56fc7c74e500465e2d00be0800b16d4e09dff84ed324db63848ca2f538f1638701fe41e757300104df0440b93b646b04056cb64b710b34408b4df7c02bf01d2ad773ccf4a45fa77553377c4bebeea5b9aab27f001b291821bc3d985dcbf30fd4bc797705aafb602f5ece5c50536d1e47bafad69328629af3cf2ccbf43dea1d9cc442aff6365d88addae972ef4442a74d1357d32e582a1f9a06e4dfb5f2ca3c1d8100a66c64c8f9ec7b4d13b2ae15eb58f09c3b52c56131a755705cd10360c04acfb771447b3b77f34af37e793e416ba9677cdf7ed210c444f6b74cc97060381835c1a7cf7b8b9d7840047799682d0796df03df98792583dc0f482008f84b745ba304c2bff1b4c5ecef5eafc7886ddb35511a82a92184864f2e913a19bcb7799e1a84a6e4c809e76fab58bb5f349ed05f885469317913fbe673b6cea153fdc652af92a0bd1904358d57c57f30983282fae4babb2a05cfcc5b975fa113d3102430e62000489a011afe7f0b59505184e298e0fbe50627e0c0f0985e521ec62090c0b53f787c9164bcf1a48579059616dd87db7a8011e525dd8905159e76022d51d03aa1fda8458587117da930cf24133913c45f464ba6168c1fbbb2c29625b03cac50f0311451c28f75a007f87023ad4ca57d242d32d1f425541ed0f4651a3e1000613de753b07e1690814efda3a1558a38f53b5549b175b92e6e705bce37120ad8882e2327b447f875167f1c498d5fe9874190e7d75e3169ef9f028dea02b6623ff038f3a572619f5e4f79b81f702c578308891c507bb0700f27b8775c9821e807915f02c838ad089f6b5a5373d037b0e9cc63091451b786b6133f03f7bfbe54b69e9d70eb5c11c514a285963f1416ffc85104143d98e2c21f20f2d9d7704fa48e608790d370f6e5199fd87226a8766258444ef8a0e9c42a98f1cb6d5101df77310540026921be2ebcfb71134fb2f41c16318e2585a211f6cc78b1168e257a0d91cf5368f7b64f9411e47e7017507f499fa39ccc739e858112e175b8191945a8f75c7d191144ede32545638561aaefb436a57de94fb3c8fef6414a5db42538b1c5aae8bec37c7cc0b50e5bddda9b1f5c99c314fd68ef02032184a8b73f4c96c947af014bacd656f1bb0faf7dbef517df7784db077938ff297d49c1568d6251cf7696b3e9d7b167c0de6c6a6a9cfbc053869a30342aa73df4a7b455c6feeb1751a941d14e915b3a7e7ac3df783a4607e3b560eaf57c1fd5c1ef4e86e0dff480834c55be38afa7c94528696370e25550602b326c09402b4479cfd093ef9fea1005e83582cf1beb0f679b99102dab6192d7645d357cdb219133cc72d2034ad896a4a9378da03dde87db4ddb335a36e7e718766be8fb8686465fe967d71b5f232a79799150ab9d68a0627109bff82647c3ce6a91abe335d9dc4d7f370e355ba48948207083882a1805f5c1bcc5b8e64fa7fe965b6105aeddf7e9974bea91cc5d080563cf9c1fc1e808b2f7f14c6a7098e42ed9777fe8ea9058b81a21806f28d212163f77acb644797b0ae410f2fa9b4871ca280b708d662cb8e30ed58364851e0959694c7ae04fda58d9a6af9bf1384800b0e50c657d51b676d744b754b9126890b18a9bda25bee9fcf56c60694e1328ba32e1eaa396042af27f618449dc553e7327dd470798b645a58d05564df8f234f1c4d1eb72f80d7a0e5d6a4fb0f3279f5b3e77906f926c55e1e49b42b2d0e1d79d5418fe9463588723b9cac17fb03f9981a65e11f3b37eddac5732c621fcacf6507426726430e9dcffc1d3ce3dfd44595c8648c59b1d7e4bd179580ca21f11c2930d3e882938fa30a2f167e652594a3c24a4a9a97731bcb1d0f6540fe0dc88db510e881d7d3539c6d0c679fa35daafb6c25d4fd43a3742859a60ddbf11dd20601b1def6c4112e0d297c7dfb7bd030aff6b1bcca4047aeea334420aa83d4e95371e462c5ec7018f3db241473412eaf43f0314939986fa2d037b8c9e38525b3ad5aeed1daae44f3e36995d4ca5997e8e33cfe348e1b8f1c675b025e207d7cdae3744d723a1efbab44f3e65872a0145708328e30af7ea09a8a26463b4bd795da415e6783d658b9deb12fe0ef7983c1da7e1a20914b72b794ff6d7a5a7734acb8ce1870fb8377d1221a04668fbd1a3163a33c7467c33d1f68dbca3035030538c0b9c61eedc6dc018d5323a96995813fe4e3661daa57308b7620ca7f02743e7f3537db311a6856e4b15ab9556de59a9e38a2055a5a1ce5d0058ae1f962c59a95d9a623872ecc2ebe877d36e7ac925a79f86b3d9faaa05a3b1f27933831a48c5c0a6f8fc0bc673fa4e5d85b5f1395af69b042bb48e52ca1e08c1a1e26179a4834a72f66ad40c2c3067be697f1e127298129585cd8bdb020b1297bb784b8abb2dbbae1b2c4aad1dd3514e8ce4fa8d62b5fa9b31a1f0fa16964e9e0d240350801408db55db6a1edc589b1b4e38167374485c2a1a7970ae8ca10a486d4ae959b2ec8fa307479e9d82b027c2c76633ecd145eb0fdd759666af273d5b188d2fb327accef53777b86d390c6c7a42919567ee6f616f108df221efc2ffbb154e5ee63d818dd14c9db85da3df77c75580bb02a9640d7f3f965d5af8913760ff75c8862e5439d21c19a839a71aa95f89f68abf883b3a299f43223628c033e511d63b501781844d7c16ac61b8b27467a5c2e9b3c981f873a05734afc027865e7c568ef407425d41dad8e2791ede3f12086f0e953cc0a1e2aeab076eb5930e487c8b460239c5fcac6622695a5407bd9389aa258e0bdf562f14fb75944f525d59b3e489fd9827770d7db865fd985f529d674381316268de549bb5c887c86e8b4f5d5fcdd32accd231ab785ad9bcb24e008415a9b1160013d33b44ea25ad793a2ac30aa2846eeba44ec5e9c54481413e55657453bebc71d005a268dcc4485fbb3509cdd75e80e80688caca28d1cbfe57e01ccebd16cfdde5472eb9fa2a60cd783c137025a1ffa2ae05e15d3ecde6c1a0d47fdb272708417748d9d8773d688bae382ef6f05dc8e1772a73585e83a99f15aac337496773b1de164e82167f108a5b6543823dcd065e134b8491de785557d106690169f4a98db893b2bd241b5d6313df51218f8200447bde20ea1270fda79dd1e5ea8d7485c8d923b59ccb5144b489197e77d5be6c83b4c87df0e149f94b6a26e3c4d12b879428a0aed1f2f49c71a066e8105665aec57953a7be0d1f56af4f8aac82238d7e78fd9c231973dee28b8403e4c93f66382a90c96e2f23d353c5cd3e8eb6bdc077daaadd1d0dc9984180747d2c6d155715d0912c91d42c2b1aaaf8b47958c9973da1e82c51be1004dfcf7fab79746c9c623a532147a2cf4534c262882d7a12c584b4d9363902241d8ed64c800ae8a680676903c303a987f66da4b337d2161aa3952c2d1b2d6b40511416ded7ed6f809c83ab105cf24816c19edc5d03bda060fc44a6f6603da78c6d33e95229085a8887c9f6fbe08eb75482b1db621bcfe9d6533884a1a3d327e6c862649ced7c6fcad8e36acfb645510dce812d02d485ff534e9d0fb6ba4b3018a8e30f399960c95a114f3930055847fc7711fbf2782adceb41d0269d4f9ca739329d2ce2c6219eac9b988ad56b4056b3bd031f014a2c1f3f30f53eeb5cadc750a3531cf9c8aeef8b5c36f1b0ff4baf35a37b774ba7de8fea3b1976ab210e88426e49a3249497d8988364e47195da18924f492d223030203db73e345726f46f134cd58d1860da928ec4a46a709157bbb573ee22f41775436513276055a0343454b14aaef6454852b315f756be0d12218a1850af6f98e054952ee2e2bb574fae1df5bf4fe4157bd8ae05ea2f57bfbebda8f64726be01c3432d19e67f3cb5a6f8d95fc8c0251a3a511b5271afd93910ad6c3056d471f0090145284398641b39108cc0b76a1d2869285998a4dc13874b21a33379d4f8dc5611b58ccfab32a79fc17a5d31bca4d3662394c2d34e4cbd95db7fef8d33c62d5f2ab7060b823db940fb1e89c918ec7f244e097c2229797d188a86204dece12642400e573c8a468a4fd33a5358e0b6149543e1d","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
