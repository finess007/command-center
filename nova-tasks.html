<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"cf4c7722f4f1faea98bf78f3fb03335146079049706fcbac390bbcf985b64710a0bab76f6d89ef7adfff50750735bb09ebddff7987543644514d37f1fd99f0211a6a53c77f51f7e3a791ec9786e3470b9382ab4a6d8072da05ffd2b7f9e99203a634de4dcdab271bcf5762caee1e0660ec140af6e2ff3f2a843c2a0d4a2ab7b071fc76784f155d0be2f8b5a5b10815fd763d3a30b5577e17f707e258098b90bbe611dbd3176a58b88cbe16112c42d6dfebbff0d0fbe6de7726d0a215ef9884e5c394086e7537798d09b1a1e3085e7937ea74eabcece01dedbdec6f0894ff6df9a1062e88b3e15eae073b5006edab134feb29c3155427d09cf12d7efc6c47b78298d1a144d45d151a324ef737f6cebf398ee162877cd3fffd69123c3166d5b4e9ba2e3e657057352cd9b673744b1ffc547f3f457b5383f962a0e20b613b27cb82ecef4cbc64dd41c8d904bdf212326d18dbd795314265c410c4ec8c2ef270e60f8b3f325807558a6a4a1af56ed11f2ddebf70c8bf0855c0ac39231cf22d93e2632566cafdc5a07b72d64b28f6ea9906162ed86ebe6f69953b6d9354fbd8b8d478b8a2a22bf12762f9f8b7c744c4a540472444f26e7957c266e2dd3321bdfd6ea3874ead2329ecc5a2dd47028f2d296812da537f8ea45ccd9cd6c87e9f2506ebc99bccfca78dad4692c54867eb48cae1b9d1644d58282de7aa8a7381392115b249ab2e4a626483546bafca3236897a60c2f3d094b1c01707818fb37106933cc6db89472f31ae26320c644889fa60939e5cb8bbdc4e2930a9c55fb6825322ae48b62126e093450f2e2b4e26592e643232ae5e565129951b0183bd8f4a17174913dda11cbb477f596d848b60d515f9963fa9456a14a7d15c0441c634e32a38235734dbf6247066976529983830760812ba2cf25e645582b4cdd42678bc988fc80c352978388c6eeb21725a9c203762f8505591b6752f45dad6840bf94001e24fc062d3d261db22f828b750e77e4f0243756d43ed14ed714e7afce1228a806de1b6c54380ff83eb06048df92be48e92380028b50c8bd0b792511e36bfa8983f9fb612b9926e8b9b1c62d22c93621d50a71ab27851bed17a3ea94d591bc5d6d67c99848dd2ad96e3b0ae16e2ea77bb10c1a40d41c6afb5aa19a0620258c14ef83aceac5dbfb22b586f2f31019cb6b8abe198a270ea8964a4d5ca7c39b8f61d74a5f52bb2718d34dc4340fd82c876af8c5a31862f711ab61247cd17eb8d4c1d9d3436e77cf372ca4aa4ea3f94630ca80bf79acd03e6040a361a882cf25ce0c609b7735968c914a5297cad3800aa66f15c057eecd3a1e2ecf4b8fdc41c3d007882908e3703285a5a3fb9bad3dd5b86050c2290174735198d6ed7eaf632d48fa81b46c83211bc5c552b810a6c230c66b68bf6568448e1e495761cabebc51a0095094dfe27acaa1c5e5fcefdd5692359655872f3c2b299b045bf9c781f742c10ca9d436f1f4d47f26b8ee4fd5017747c57692707898879eff16573c626a88b53d85dabaf9952a5665bfeb121a00508f7f65ecdd314883e6ada1537e9cecc1713d7e6101a1c00e40ff2896d06f79ac1222a3d872695500d6069d269a401bdc3fa684bf733d7f71c1e3832fdd5d91406c3504e12d573cbbd97ba7d4cc05436dc1565f2add3d2d4525eb93efec3c8c1669cf407957a9fdf8ec3fa4a48bcf2afd874c688e3e538dda90ec172678466cd454aabccf0a1a4b4fa6dc284b647ad8eb4596d14ad7cb904cdcb47e40567627978d166bd4a6e2998cdb881480ce54fd1a43ab8762b5b304df8fbed3d6bf5e452317928f349469468eff5ede80043854bb21548a23962ad018c7353fec68b26a8abe3a9091e1bf30cebc48c7bc0ec886e28fbb3eea06e2a4fea7a5b7b8502a01b15c6f8eb5e4fe225cb5d116d3701a43460dea0ff5eca3961ea7bd6c9f05f2ed48674cb4a29771389d1ae84a04f413fcba58cb0214ca4f66d2703daa06fc2ab82dd83d55e182c157a20c66b8a09a6c5a273d5a1b43e24328ae18f95042cd8f7aee53e3071f1a3f00e0402655b415c827f2355cb0793b90e139c72f961825494cca93b3adae1ce4622eec8d0e20d2d553b6d2d6496ac9952a9fc78a0ce829edb1b55a978ca93ca42e07bf078a3007924d775e97932af6d8dc912a09d9ec6c2ef379b266f6c79c067c00ca2eb2b8d41a7768e5502776303906cefadd8a124507a7477484fc6258ffe4280fab96081b2bab2c0df99f3a0ee99db166472eb122389bbf10ea8f1fd771dc0458e987693537f12582e320b23ac1b227ae2de6f35042aaee2827ca4c9776c3853492f2cb4946c26c99a6e3c95f245dade1ddefe3f7fa04d051a98672230d7142d00e147e93033668dbd5d5a6668da9b71a5c92c5c287bcedb25f785a9136a31acf6d0b913f64b082e1d5a7afae4855f8929320d6fcb3a646bc8d8176af512b44f8426ab21fc4398ca98d7bf1d3da2a7ab84426f91c8204951ecb1bc70a02a1e3f358b357ea91559a6646d67055a1d0d7cc003da579671ab52bc4f2b5a904a5c3dbf97b5f1506db3f0678644458c3cbab7622e7a54b4cf88954aaea7210e453855ce6118609d15829e46a7fa57cbbbf8b5ecb634495fc8ce8a2555a13395d1606599782a4bbc1dc141c806e3def4322e068870e458b231a3a589ac538d54d5edbaf37ab3936472b399e184f6ef3e62bb1c60d4a6490b5e871621bbe43e0b784ae4ff05b0627746ad2c092f03935635dd9026cf88db434219fb0abf70fec382c749e0ffcf36aa4ca47caa0cd0f393b81d2a99aab536483c16c825f3c8bbdea5dc943a713d4a5239165dbd67df3944d37b521caa5bddfb53861e0e8eeaf738e34384356adc154f5b5ef5e16d8ef83a1cf9c3d7cb52852495be20b60b754214c87c19eed938b689c4472c75e2ddd6b23e9b480daaf2e7f05d5f56ec04f2ef676b0f326d6c4d776e4ab276d53ba9564a708da6edf83009a1fafa58cf00f51c9608779b996ce43bf27c0ec5f606074d42a91288cb46807b0b45a9f015e487ef04068b8c50fffb218bbda46e01b27990b0dbc983a5f9c0e4e3bbe4b7157a739d5b7ed17bcf888685806bc50510ba197ac9ebc037df235b7170c7cf21824bea7945e9b41e55731bd4e4662fb0e65547cacaa75a3d9895ab01d67d39d3a9c9a9a27fa9f80856d326f24a7d840d127df98cafe1826c6b81e1859be7ee3b9e094be25fd19f47d67210d2bd6cd8bc45731de9216bea6028af7198c2a948d479116f4b0591993d418b199a21ffaf84c1f6aaa23da1221d73bc061661810096fc22ac7fd6ab53e40ab64cb46668fe2987528b5e8a49cb485de594b2e661bcfbfa067f49a17fd8ed0e9b290d3d80172a8ab2d3b9465fba987c9d1bc0744ac9079c84406370a1f7fde55b1660ab0888b0b1842631164ceb44431d6dbdc589afd213651f3b533f82d05ba92e895a1c967cf6c2c461a7cfd758150c5f394faa96e57d85caa939bd3f920081fe4f87ef9078c846ed3f63d945d68a5cb383d03fa8dae1228dec9a08f22a3eadc9fa6cba56a9bb78dfa680682bfa30f2df53ad396f3a23a7dacaa6118bd667a95d3c509522a99dec508133a716d9ae45e8a9148669792342660fb04d13f964efeac41900eac86cf6a7dc4c22b450342442342f542a23adc51f1406a137891533b80addea46178e5ebcfc5b52bdcd2f44fcb0732cfdf709e40242bd72e117f9d8cfd299cd55246f5ec4f27492a4f0eb9d031063074cbfd1980b7ccf4a65bf66296e8049585deffcc2574a186e1ce0238125bf09c288b2cf68b378e0ea910a015c52aa3cf92d2499cc63b8c27042aa3ea02e58794aeaacaac5c8e21724e1c215619e93f6341082a1bf3f24da1fa3f6f9dbe1ca8613328df119425e7041f476b522f3032a0c48544674d67e3f01c07d33c3604323bb98a346820cb5833e383250466ad851a9c09e7e4d816a75367cecb975d91fe2245d367aec37f25c8d24a8ac748f77d789d48a60c7184fbebfabdf3224f921853ceb1a95f13241e9e2522c31cbcd222e2b412a8492e357e06a354c28032882f0718bb704c5a0c5453258305682ed0b14197743e5fb26af783434427b9a65ff9d0fdeef4a47ee98ab30b5e2c094bbe362a8c776c8ef2f9f10b2c4dbfeaefecc2f0b10e70d46b9a87a42c8fac36448d96062e9fe4c06e4c7156d247967c40a04b32c4646a7abba6fffd64c2b61ccf678bc1c96185b4d2290fe027cc839bf5e154795bcd99cc46b7c3a78e2719d0d2da02d65abe1fef789cc513a396b905ac3df95edf951edd47aff5c9604c9ef04e4ece177e1c98bef02d73f9efe5f01947b9715ecb31adbf7637de99d69c5b4e52021fe0da075517da61ddb83ac186375afec046b3527c1aac86475d47ff0c6b20761def3a2c96b0a4f7f7b94ccc8e75c6fcf901906308317ef93ba1c0ed2d93422003f8983cde63d9d1202c16c093e105ed305eaa3d37968ec7c6dafb6df0d4629d77390f19e1c8547827b11889b07c010028cd5977f1329f4f7b6d775f72a2c88683800e662606bf59edead10adfa35ac6bb9a795e7cde6e8609d9803a0e6b89e55dbcdb889331fd938542d36c740c2f819519c7fa129c12f5b089fc5090a906429204e5cf57c4c93f51246cd40084846a69791ba1948929fcf0e8373cd606376f9488561f40c1b4780b2ebb4766eb961fe51fb6e27a21e79b1d776e8c33b3dc175e2a1add78cc76dd9887ceb5972d252fb5dec61265007e77f7789450ce9dcf5276ac95960354e6038c41c3354cdaaf6d9226c14baf58a9f952064580d09bd4a665372f8b803a59b205893f90041380f626f6cc2c89d4816ebb384d2f282bc62b636a1e7539d6eb389580122ca2750a9e4fd49faa0c6dd7165ca8e8ec26732f3cf042e4122c8b0d708b0443ef352ea21c388e93f1024aa43b946f39d63890e9d320d8dbed7f15b9bf453561f90c7f602b66ccb3a25015bc04138addefb3ab8e934b5819d90342d86188dc707d587075b5a8a29f56fcde2f2bab1e56cfb1323f69da47b149dd4bce4296e0fa70287450a9b603903aa6babaab144003cda381e0fdf237b46a82a7ca4e524f9f3bbd675259fe2dc99b504bc69755249bf051a0b71d95e6f1c6edd1e78bbaa6c3faace54f11c702640bb120b881594a3fa0853ece21a46cba3506e9803543b3e05a25f1324ee365deae8cdc80661340ed97f98c94aabd7302eacf4fb2db8fcf570b967e2cedc0279a3262501ef69ed45a1bb0b859c0dfbf0c4c91829d90dd9287b79a1dc90f2a1d0337416608482c02e1d41fc0dab3875da2b0ee6a3f8d422ba99433a82e8b3b9f02be4ed492cdc97d4519ea2cc291c76d3cbdd8161c09115a63e05affab178272acd9e88be7bacf3452eeea0cf2441435a0d811842b3f23d89ecd2b2a80fcbed0511066bda69d3f589b9ae7fa4e758310cbf3909eb18debe46157bf800c4fcca793c44c6b1feca9a806f430b5afe1c6dcf53ec65ff94e5e99ccb945cbb85819acf441036fc76dea9f168fb50d8455ef633af187c6a2dc638b7865ca0c4fed67eb1843687f59318ec08486b4a1d504ff6b80e1bf8a77c3a75c00d5faf17c672309039a78804d5a412d1f78399999641fcb7720547ef8336417f23816cfe65e2cd83ccf7126bbe7119ede2f9541002df9b3d670ec597dd6ee6f6ba467b04d4d00149674ee87f01a489bf87331678fbb97296a854c9cfcf8fcfd04bbedcba2c780e8785b49f6c5992b0a8b111eab58c9b6fd9d69bdb3ca5dc2057cb3839fc11faab5e767fc73faf72ae099a44c007c18f2dee2423f1358d12acdb19ed4e4810be19056f938f4b730008848ade551ac912fa7df4f038e904916b7ad666db0a5d95e8d09e47fbcbb5523ffd56b0a86388cc35567de0515caa4df814e4f6d87cae0453d0211f770b8fbfaeef5e38fa3cedfeb502a874810ae647a9b37ce4dd70ac2debaf5681b36fdc018fe3d2a980081bec6804f489b81e586b223cbdfdf958dec0a3c96f456c28d70fa385e52f1df0bdcec4ce8aadd73817cac01f15ad954c2c50ae907c651c85d47b0ff7cf74f54c7d27d7b429375c6ecf709d97f21eb5ca0ba99524dcd3b848b8fbb116292e2d752f3a21f7c7a7740e5257741668ed568e0744ddc3094ffcadf38ac785dce0724940f064f502adeefdd02bd8328c2bdd72e727ab3def476f6cfa94bccf934db3103e0df60cf43e4514c98ef08c90c6a75389588440cf99c7126b8d6a3c2e3e73c8cd908fbe18b03bd8abfb6dd109544bf415b4e86b5d614a4f49fc58341e394f0609eea9cb4d83ce5d580818520d61c34d8549c79bce2042a94d43a03aafb5c4f4e06e60e9a0efbf2edfc39728f4e7c0f286369d65cf9b71813b877073a456941d4a57469548f40aa96f63ee12f03fef9c666805a04195427abb3f45e6b717bcb0bff5aa3833cad411a15ed8266803527abc2d132a60874f186d1c620621e91a7e38970f2654f65890487468524c1a1ac486daaa50276aec5c48095ef611a594be1427a04c367a0e0a7019cebe32f3b4aed20d2a043dd39f6bf2da44246252fd8863bdbb3513895dbf51755b4960ebe4d128db6bedf1968cf4d0dfc7813d8bf7f8db9c7d702830775afaa06722a39afa772ff71d8a6945a8b4c6eb46e92b51367e3328d8ba1303d5831ee976833d7e8e8446c0c1ef3251f2295004578fc46a9c43b693f76dad909c39b6f6aa7b112891661a66591d96bc73107149e99dbd836433ffd798133684152f7d172c929133afecb7346bbbba39961fea940dd515917d6942822568ada179718ef193d4b3221eaf42fdbe7a3d3d838cd9a5a45fe51026fb2980568aecbbd8276b75271aa299cbcc31d765d3c123ecdc7d542db6339eb30a03970862daa8cdc930131c5094b30973c896c8e9640656cbca12821e7ca6b54167a1d29712b13f25cce95bcd9bff173b68d71e7dd976c404c94e7034b70db7cfe40ad5173cda5fbade351eb1e4635cb9f6a416a7a275d25f3d79f3fc52dce0e6fea2cd4debbac8f9fc095045952c04e297608d050aa98797ca387faca4707cfb3b056923607d715740c40f883d4ba46bd477c7cc3ce41fe070b831036ad36fad178cd20f50945377ff7d39f18b3119b95b666698fd268e5db60b1db60232c83b9e12b784852dd22e95b8b8d783f82ccc8bca325d6d33a8e251d638a3cb730525baa522506628adb31a40967917b3ce565b9eaae957e6306aa3ee7f34b0363e1f8a9bf172763aa448e83a399af964d8a88d5f773d04804885b606ceb355170c1bb7d5d8258fa2e28631362e397540d32a0ccb03e4983a49fd136a59dcc0fa6441c75bff8ec6194b95a5eea603610cff412c122cd13c34d0d1f4202715daf827784e51e2807ae0c4a38c9ca091bfa7b570b223a6584a99a8257cb450f4766ad1cee91965be287dc400cd7f57a923dc5c295e397d3660e7626922498d73e3724b3418a37ac224448d8a6c784c23b2428233e7bc4023f242b827963b4fffc8d5f0ff988f701d9e047154e6700e3ea56263c4ee9006b3b65041bff69e47e37bf4a62ae91fe8d20e77bda0af128a3cf8b7ca6da294bb094f3a7ac95f33c3812e57263a27504e15eb29952183ab0df7d1be3108fa61bb7eb59575ed95c51b9ca63f5793aa0164ce6cbee4a412dd5d6c26981b920f7792631eaa1c016876858225d4da2d1feebfdac95f0f83068ab79e8ff64309f3de2ffad45e7df906d3d354e00548d2afcf97b7fe8068554c205d9b988db675b2d3cd25b956f338f8e264fb36db63584e4647b9dbf6a8b5dfb72611c9226de086633f2d122a68c8aea77b8cf7099368fc849e5bbabda63b0a557c8d8d49f01e9a88bdb8138dba6def15ed2491acabe264b0b033090f2ad3a3811c0dd1aef8ffb094ec5690c77ef6c42fcd982c2e2f5d217eac33e842e5af0b43a039ab5bbf3c4a197a3aba547d6382180c69690f2863181501b4e0c3dd313743aa03e8c8b01578946dae6909a2eae2b7ecb57b1310b020c60464e7087924e7a58460eb1b66e606af438219eba47cae7739837568d7f448e1d786bd24194fc33fb79f21cbb581fce36d4a77e325aacc5c612112f2957d1015a41e14f221c53fc1b55c1f8852a1257d3a66edda94c95c259a601f67dcecc06b46e31b0b70d270093bae9d70f6b55ad34b23c5f1af7fb1fb73bd3dc9c60978985374fbc1f0cb5baabd113006a8120a9bbfda83f3d39eccea8bf055bdaad21ff4a4f0ed87ca02de907d2e07993b4a47d69f2f1b74c9d2531ec27a4ecea2140eaf0c80d90464c47fe09b77ed53d13b4819dca63260a7fc02d24b3f957e05ad8e80c5bac3f66ebec73fd51f362de15033b7d23e3625b777cfa08898c8e90961c67f098899a9c5dfd5d10ba0465524ce7d21419989f487ef1c67e47ba035e6ec70781db59aa84494da0df5ae234fc9dced255121c30372c737cffcff8becd051971f98a3a027ed55068d6d03998d161469ae032f3b5ab4beeac89237384339b94076caa8b50b8ff2ad9f5333315b386015e6ed910ab9787d4fce8f6a1b8a57b2ff4253c6ec6cbc6cf115acdf7ef05a8351732df3b82e89afc750e1c2815a4de8eb4deea0bae39d7284e9aea7d382e8c8e04fe177bf05dde3428674b0a338ad1898b38e5f037b5abc940a210e92bd74d023402dc0835c897380abe5e362f37b954eef2055c2d68d171f5f2460f21eefcac5212a2bfb982c0ff0efc9a328d78f6bc9dcb274778ee3efcba76f13ad4f220ae4d02b038b1a452748ae583973975fa323dc1c575b57320f8e2b00b2e21a7111b7b259205e023f0b95c3eb1be1f271f53b69d9402ea038253aa306c779a63b29798a8cbf84d26badba16d82ba5403baf7c551989a46197b4a198b4109d84173dfb815a3df3683be1d5180b5d71214f2a67a6f5068568306deb7c784e428e320012d43dbc63a74838c66a8fe3627a7846404aab3605e1769036189eb5fd5006c3c9bbdb3a49305cfc9948b9771ae5a1767cd6f8a8ffe40021728474f613986bd8de548163ed4232374a5ece0cf134478bc955dbf5bef7385b114e65b87f94484c5425151fca0f678c004d04ce0fe0c509fae447781a8a7f9eaa825eb8526422a69d3dbb253132f2f7f903fda739dc0c604956c268d4e670e3ef9b2a85de956a29061843d027e6d3bbf991327ff7ae167335a842b8c791fadd7d5a9f97bc71e00450e6473c7eae0871b89c51bed00029548b499ec35eaefe5cf240671325ecc62253609607daed27cc04aef9026ec5f8f637d09b31979152782aae3cff4faa0df728caa5b1afee12072c5b6aafc4d85cb8a39f91c51e9b03ccdafaff3c444b7f9e53e816fb49e8bfb3445d7bc09d4732fcd0767b9a41efdb32edb7118481213f1bbfa1e4f0983074c18340fea498cc29a626d2132a09303a14e99e65f46197f151d4885c84fce314b949202837df05255377aed64a327a38c016e65202513ffe557b960d6ce8256d950d7661a2587cfb2547b36c2c8ab2fa8bf643365b816893118cd35a5fcba862294362da0dbf951e5ba434c90ad4adb1ba83d9c4076fd35fe2129b84322182ab469577b5311702a1207b1aaa9687fef8d5af8b1a950fb336fad7c28ce17ac63ed1346154ab5a9eb4cf20c844e7701cf04497d3316588433439f4ec1589af7573c7b5c79a12dbbd244967cbe5f84427c7d8fce5b7cf2defe92885f8f24aa4a2e4caf2d67f02891fd819ff71b5168a725bfebe6c11fb69f934d72266ead714cc61c3fa84c5e83e2a3949d4e9883764a60579b9c25b1321d3da2bde8b11b892b39ddaf36ab71266f21700c928fa6a7b137f846bdc75075b0c1046fb710188cec9c76fa2b078ab2a825a4841686081118de09128a6a16f5abff023425833ec9cd89791bac40cfefd7fe953bc6137ee4771736e4d0554d8c833202bdb8143055e6fc72b8758d193476a618474aca277f0e481f7a239cec93ca7dca52aee0d11b37e9a2309782f5d9fd09ad4fb225c5bfe1ce5ea302645433bbe4d89017a063fbad710cf34e63089ff014d5790a03263b306dcf056855af73620acd19bf93a351b221aa44fbc084aa870dd90f0e8441914791e15d786a3a5ff96bece2dd0a9a25b5302c90a03d89879ae932f3c73f2196a5416fe1e4c31fe3e841454e5c573599892cb891a63ba43df1edd4f60e688c2586849c1d669347e3411ba3de28b1963379435aceec1a690df02b4eea08103075600f7204d5948148ec6bbf7e26311d0022397dfdb3726645bb19defd6427f14f6215a71b2b97f87a49cbba1f74d7592115843dd4f79cd84fb3232dd04806be3c1fa3207496033ae3541fc39c480c0f03bc56df8c07adeb970587cb329830062723ca9233908772b24ea3dfcf09b0c1165dbb68c762aa16fa11af77b076247b97330dda8ab87cac47b7b0fabef3a49ccd937a5deebbfe7a6f55c4c81e3f8826695b9ef9ac800077f5eee4387eb5931a29679cef8d74b2aac90b2fb0043783bab978581f5c04a982add75f618964873df2f74830400abb8de44e6084cbfeb4f320c0f97d0d5c5178676d7f30e72680d092146d90f12659be73a42b4c5acccd73130634e95dfbbcfe6e60134aabead84541437e42c1c4309352694f60180b87055a8235583bb1de7e980462534f3896fb4820f48c7935d79456e9cb8e53b4db259c1ea3f6ceb112430a529ab1a14db087486cbd45bc68ad2230989e8fae215056962379ebf6aeacc194cb188d7157a4f210b60b9c0e0495c768551eacf9ae8f87ead4243e5c041ddf36cabb44820865a22e8f28cbed2a3b3e9974aa4e4ba7fc527ee49646e849a7a6061dba6dbbb93067a1f6a2d33dc9af15e51a370a799439d05ced7e5c6d8c10b88dda94b4c678499a23264fd39698de188da940716ed8edd835353abe65a3fb53c1a381595d7aac172250b95e53a8f7a5335df0cc46faca077bdbc5173ae16e2d7f4ba3065bceb6327c7d0c3513c4b4b5682c0dbc2bb8b6b45b21ed17f29baa59085cd64554eaecc895d7b2a4efba5a7ddbff18bfa7418a0468be676874cee7e427b2aa5467b6b571c123c785f776ae6f399fec22b01035b0067caaaf9d004bb4784d9b5033b1d14aaf87c610033a7e3684d3a9328c294feb79c26fdb35bae35ba21a5ac24b60f1afc6e855dd56e2f50f8456825bd2c4eea231319e67b7fadacaa176bd7332c378f52edeec371e94e7826cfde05006380c430b90f0d2ebc8540746debc9d2a2463a6f08038b42c4fcc832f1515a4a1d165535695e83e750d07e81a3511838becb0dc4444d9db1a6f15ef467d573b08b06b23f323ae4bed165a07d5dc679b6d0389e0d0a29635f0f5af3fcb1e409eae6c9b834154037aff760b848390aae670c1aec0c68ef4206ab85c4072961b782a793e93f4ba722a84ad4a16065cac0ab9a0fab5af57b0026fe65fa920beaaf020ffa47fe62ad90715e505460fc1c423a2c30dac034678d18ab6c4238ecd7ea7179e5921a6307d749d35e613168e7561dbfec061124ca87bf30853fa01738c642901042ce3defe6ad22e2084264abbede47f7425cf4a2c1fb8355f958ae783304ab2bf468a7662be4e8f557c51b15d6ffd057d180f0e720bdcbfce819be7a1c0ea445c4e1c51eb11dc53a68c825d527ce4e7cba6920d9fa2c05ad0cdcd03ec26d5c8546cc1eeb3aebc54ea74a36ad142d8298fcc4184d61f5dfbba0b9ccf54b441296ad24bee2fd3185275eadb2c0099e05c6c66cc91775487e73ec37ec60b595b401ec8feb8dd48b51448eede71b88a4043c2fa4c0637eb9145442fcdced289b419512d301db5a98aa685eb2f011dae1dc732e4c48a798a0b09a0bb7323b80fb79bf35b0765e4691c9cf1d3e2c04f7a56475fe96417dcc26f104ed80f6e03fe48a0c9a2afb189c906141315690173771b7f3c6ce85934ef541bc3ba3c44714fdc6e8ff350306c60dc0cfe9983d180b6386e13c32bd119d199a017968a1302fb500ae5871f43e99cb194fb859568ff24feb9e733b61b11dfbf8a9c2a59c56d41a35896a2e9793a18948ad36c2b944625be3573d1a7f3fda4c875b23478d21a7cf0e10d884a377288d7b0607052908156005d66559544cf856503a1561263dcaad6ac5a374bf367eba26c3ef7e76881b0b08c87d8de668044c548aa95838e72d705e40418edd6939294f3a7f45cd1d929c7bf2137ae1b28b5eff798b9e16faf2e9882031b7507f9d9d7a5c506e12c99269684c3e4b8108b0e448e6b7a4ef53a39ca98923705421bc5992291d79633e86ebe64da5ab337f9ba0cfb169278476a130e9a32f244c73582b55d8e9083f7310d03e2be8b5412bcf71ce31640d35582de64ced231e5948ea6a44ea5ae7ac5fba20459d432e8a3a620310075fb529bfd51582598aebba4bce8bbfd46e165f765b385bdcd9e1743bb8715f67042aba1fe354b508d29aea69b63fe275c6b82ef19b849bb01c6cee910547ec7cc31f1d724c7be4181401f7a6ee7f03945250bb5b86c1acc2b54bbe1566c0138bbc1e08550076abd6b39e60c8b8bb503bc25cfb755e228575e6549397e0b9bae8fa82fb516fca4999ce26fb98e874f984e38e3ea3f02977933d45169f288a4b94198a85d08931318c4dea865fb179cf07c0f95722c5910c527c4ea1da3e99338dcf2dc1ca5bcf9c4c921b579e8a476c83fc907376350cd80f9030e09d55a7203301bfd7864d818da14e1d103879453a55b4cd6c88ed31ed59389a0fa57a9573bc150ab2d7b0287384653fdcea49fb368a8cac5377206871b85e0dc693647a536f2869bf752b52582628d7f0caffec811526619365f42ea7dc5029a23c34487a8a643836e2853aaaa03bc60ad577b57e2195e302fc67c243848b351f6dfa94c388e92528d193c21e7ed2285fe7a7a13b0fdd68b4af84b396cdbdf9052cc1de0b46d9933497827d9f995ccb005f99a982e1028774cb38accb57c82c3e50419a006c3570b73e0d98c6f5563f09ba537f281d58e866b18148472d5f88182d2c00150bdfc22508e7810b0613f03c5799670f29ee1bafbd2d52d1fcc5d6a13012323e96bc3c914fef8816888f1054a8258e2dc997dd654ada80bdb8801f515a9c4bcd0b0d258364c702cc1948f28415fc96c805389be04fa19cc249141c101305c05ce010120dd55f2d5607999be7dd4af46fb39da459f8fc7991854337e0c11417f4d1f1b75f14204de3a5470d23accb6b40b194c5682b3af62931fbb90d88d9b8b8135898e2cdc32470652d2d39c302a553aee69b6cbdf0583cd8a6cddc80cd0275f12105e9ee7f918ccea1580335ac3320d2e641b9febf20b9c2bfff14ae4fe746f196d1d6ac4efa82d926ededad55d3b7b2fc39266d063e1fbc2acdc471909eb3e399c2446062b9cb894ef0b70fabc6ddfbf8a1eb9b3ba0e532e2ccb750ec2caba3ae3a8ab858c4f36f230f57a62cb9211c9eaa2ce4a373c771c00c193bf1f64cdc1d5574f755da4eba8fd5d005290d01330c122cec058745d2191474ccf7f75eeaa3f2d5f73bb679c98ecea82fea979ba8752f138343e83bdf0e7d6fd6676b7af5b8e9e54f24abcb98e803299f5bfa711e9924b911723b2c5e7ff73b2f84b54ee8ba4309739ed88a4ea35bbb2f7a0aa181dabe18a3a274046818f00aedec057ebc00406441d482c7a54f093401e6305ab519aed493f6abc10d783635fc9632dcd684ca05fd1f87dc6eaac0b09722b212f0e415788ef93a67bac186abc299f1dde383726c97141854eb59bb0294523f63c15b0cd28409bfd30a0e14405e701f08dc47c1aee0b2d1be06197dc71a9e4523fab36e3a29a7acfdb8856c4461a9c183d847946cc15228214b1d444ce11cfccbcc5e39f35769d5715f1f752ebd39fd4eab1fe8207ba704d7963467cc86b201b8e0baa69f17743201ba81d177d84adcc94b815c3efd28e0e4e2c0f5d6c2bfdcb60a8a1e221bc5b6761c33120a4a10460af925b20463f9a784be048dfe5ed5f7a3bb3342bbf8a8faaa37d424c79d1da723407913f426c8edb92376eff1498ed2b749f2704799f851d31f34f248a0bf797e45ea63414c2e2167c999dcf0e6c63715f58c3991c537b985af630efb21c999859078f4947a19d10f977dac51bd926e329dae4da78e48834c346989e1745fb1c379536cbd8d6a8fa68363a1cf1cd1b7ff72e343f74eaf2490688d43e502f9d4af1f7d392a461a2437d7c9fac5eb12ccae3a986e072e5ed39fd285a06ef50ce6510ff3b73f47b4d248b5b13711454309e53f5a23d25d0e0ca23b0f069ad6c80e3f1a4b8031f732d72161ceab1a697564708701d73bca618d8b6c016571b565031726a0217bb61aa59849dba0138134e0634db3e3831ced702081d6d68680a0ea9e5954afb9d1f0d2ce2ff64df8d3b74239c32939","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
