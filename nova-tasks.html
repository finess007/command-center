<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"996cf967f846a5a655a2768efe64eabb6a12dca0461610891860ea07aa85bcac837ba51c61c56dc7b07b1dc40b0c95f5a6e99dfa7b47cef19b06df630ffb78f1002edbcdb7322a93d786f4c7459396be31932c4e99ab5cfbad210c6c6ae87c48af784c409bba2f1abc8c3c5271f95c0aee2b9e585a0b577661bd3aa5930fc5188ee91b27673940257b793c02c7364a68e0bd2528f871c29867d91c5f8507bc118166f5679135d18000c306d850832982cdfad9dca25d96d0a03cd12b5c93df666e67790dbacf1d6373c50eea494b853f6db03e425a97448cc9cc04bed6f398ea25ac5cacc28c817507fb3b8aeb0fb40336e54e25756c73ce8812bac688597da6817454937a6734d2c5654eadf98828e625cbe45b2b36e8f66fdf3a8d4bb75932c54ccaa8b2702b1e588cf7608ab1ae3dcfcae5800a00bb4be4792fc1382c83b7c6478aed38ef63ac67f1a7721ca0335fef82c81b58b0848ad13f87255084abf3acd7aa791f8d4a1f4924e5e0420c2ca009537fe6bbc1e67e02a3da737eb7bc2f7ddf321a387cc9c6dd36c279e063ecbc8ec204176eaf8215e080e832be6b1834d1ed84d79813c59829fd7adf708d60ea5e11c82e9c11161c6725d49c546055f844746ad19352231f603d9dd20f448b8bf70fc157f415c987030eaa9c24df039e92b8c821d3bf46422bb90002e5621a697c488dd3567c38f4d090e244e4385d0b5faace4e159815a4edcb2614559596c36e4bb4647e60fe4ac015c272f7a753f78d8c332b28395ed41792daf9527769899afde90161b0d3792605c8ceb4aad9fa1edd92f4512e9c65e6d5e44170c4c6fa6fb7c601c1b1691e90bab3c7d22109c38078cd598373f03f0289c8c1ae9b962ef8d5972f0b65d0d7099c02a58a0c30a9232db168e29a7f9c3ce1da99864072eec186cd73324b8a77d2165f777f318258f243db09ed6482c9ffc5bd0e5d3316a27e352b1f746c0a77b0e5db31102c5551664c8887a93482ad573d540b68f4aa5412764b4abb7d014d201d1fa05c28b227fffdfd705f1f55f686166c0d05fbc9bf578b89853e00703331a9dc70f309304f8226bb0eedbc99e00c55ef37760a16492d3eb0f5dccc2dc3b9c20cab30c77648b033798c862d8eadcd056305f60b0b5d0dc57b60305c689b292bbbd2a51faab7c31b81f3ed4db7953a86105443195dceae2ee4c71aa23088ccab64e1dda0e6a497d5cc0cf1bcdbcffeb95221896433d7e2fd469f0d9f99827b3204be03f3b87bf6f05f9ad1cb14216eaef4de633a96304aa9a204d2cd76e41cf2b5aea25642dbda0c135908de4645bc55f27dfef3d72f954f71cf04ef169e6803fc5bc9bea61540aefd635de542586094475d582f9e071371f66497f923566ad24d472604302a442c4b747735186861683316ac26356ed6df5d8a43803049be8062e9df391f9e869bf3fccfef744b358c13fbdf74c240712691412d4bd2acd11255ab340eda6d70932ebf1b81dc9d237895cdd31596cc41c287ff562a5901a5438051096d30054a5e29e373f91d3079d32f5ee820ec274282d5d558168cab91a7f08985fb108965fd686d739af2ce50aaeba9446392d13c31a618ec8131646da87024eff0e3bd92e603a73b728e64366e2227bbcc7128a3282bc4d3ca79418548e93afadfd668dfc6ca9ef6aea8f427e7c1b093968423606bfa480bebd8b5c13f3710287c6c6e945257430e020b42d9de72d1010e81e5da1be49103adb60a6fb0ae63cb0d23bfd874b54a3eb42d9be9a8e59c22c86a7e972cf5988caef807a41e2324815b089845d65c349ba2f1b0759a24968310c05e49bdb12988e377f30c03949d1baa6589b0788feb318766d092a48e82d68a86c7da41e2ec565cb2689b1349a8bad03015934c2ff4f8a2922ba150a6b46127db881346b41be129af68ad8b4d69023981ebf2cff7f41fa8a489f7987c91bbbe211cdf06613def142c6d6130052e02c9e48280df995836ae629b3c08b2db96499d774cb17fa4807cf4fb282b70dee82667b1806862c444ec08079b574f195baceb11cae37ea8f80b3d24117a971019663cfe0b7fd83d736390364aaf92714f549989b04135e0ceecc17264b9f99365c719447453e2882964361bcb5ec1a64563a2560380d68c7295091411554deab07fecd4d1591c97c7432e36a8925edc705c7c443ba61f6a178863f37ec468275ab05531703784353af4dbd1c92b04173c557b1a8cff34b6e98a97d3fa16a4d4787af154c718fc7b6e1ac3465ffa6a7ebd57e70d7b369785d929f04ba89d6b47ca38f726a25d760932fd7e92219324709a01c4b513ff3ba82cef7a471867a7cce9d1f233a70b18b3d3a367b6bf812f6767fbe667bc3fa1cecf46208439ed5eda5a19a7f245c40d51c63307cb148521be72a6cc863a353e59491ef9ff6f2f7182e567895b9ca01e9d1dc8a7fc762a35d2d6192fe44859d3de642a3abc6f0ec4aee57a14dd21064838eb62cceaaf87a9f8104ed0ebd4e1a85fdd77cd8edd4b89534c5a5343ab47c4316e781e7b34bb8e50dc0a22ed30eb744eaee35394e3a0d25361b1ace81d66d23d6920fdab2c9cdd563379b2cc4d31283c82fda295e4f81d845854a3d1958b7efd91426801791d6aac2007e6d5e820c0850803c9ab08c1871803034df5c11f7612ee711b48add56999d999ad022a69863babaee25f2c79c4cb14b3b7cd609401d4d34acffd09a3bf4347b437ce1abdc3583dd54da5db1f71a91f5acfa793e4107f269cadda2436ab033a80f36f345ba39744a1d65ecaa78a907150586bca75ccc14593f9d97080f731c0473c348a07b848e380e4d2f2e26f54872c0812976a34989369c4272c08e69c1fb48db387c4864641defdbe6b254de30192dc109ff89b5e60d130949f03b1076e7449946f9dfc366acfb24d811c2dcb609cd6aea9ac393e5028cdf076588475a121f224bba27656da8742b202dd0c47c5d8e078a047eaedc6fb39350e9823a9ba512077076b0c795994e87e0075c0b415160dd6730d47db95a93c63aef35dfd8cdef53d4a40e79e0c3bee3da69c9782e82a2a8c83a2a129769240a7813937c8668fbb619ac3a6c80348afa079b6ec81cea686a36c9b70c337c03f0a0af211a48a42a9da0a65689fec843a2c066a7d33d6f9a38da450259f1efd017c2efc70c44e546eac314c521e64700d191a8283f0c3407235a9cd2cecf5fe5e8050d3255a4e9f206a40f61d3158047cd79523ce3dcbc552af7d1b4b64fbb8e811721542e046b8c7de498edf699acc6ae9e660f713d0ab2835215846d16deb207011461667a00874539fcc960a2a26b00aa710f8833616bd7a6f8c706b6348fe8588d80d20c758547266552f2377a5bdde8f5793123a192c8529c6abf0128f82334cc8e6e98fff5835351479128835566b5e5988a9304c68b062891e8c325232d39e03927cf6d254bc1506c758aecddb95807103f015aabdeb847ae6898a681f25f2c3afb26704e6b965933fde35539174a95b12c3dc53bbcb13f745950e0330d250cc78de07819266fed476878445256cedb348fabfd061b2852e678d677b69f2b3a934667f64a2ad4c8ff236713a10d51447e1449c9ffc77ac5f7b07a9545f74d8f1d75125ee426dce0f48b1b6d0b89c2de304c1fe98e20da9d5ab14b9c40e734869ecf7e4f53e35030d8c5e12802e5bc9c6da64321fe04b3b2c3120cd64b73b2e24ab916fc6f37a61752d46e40f5702ca3e0590c6cfac9f52b807ab76a6c06086562c785a3be65a90858ae9729527f67e364a08dd2a198897695a488cad69b9e47523fb1aa298ebc521ee386e99d694f45bfacee29672809aa1a741346822900891e67f490ebb7aeec4288067d0146cf7735d3a3f4b0b891aa1d7216cd50e551095fc9558e67b6838f6fc01d6d3771df871dbd273136a7a60d3b252d218f76fc2d6f5e7e3f926af1b81c35d8afbfb057a9d32c19cae2ef27a4fbeff8156490413a833935c5256d36d7a533bbb3f239fe2fad3b8e33945b7ed527b5f4bf68c189c6067c53c8782f0620b82d16b0aa7d246fff7837cb3969770b9580249219ff2d5937d402b79b4c2e11738272c16bb3c738ea62f7738b5d9b97c646f42c16b0f4bf7d27bca848c06bb0bb975d0a337ac172f53e3a9dec105e397b00c07f57c77fdcda0810edf472abc73accb253ae594360a4ce5e6127778b4e5a23816b2a340863ab0116ef5e3627fd91b4f40b9aa0ad8431c15c78a592209fe7e28afd7c5582bb390d094dc25b42c18a331b23ad6d64ab4aa115bd6b5b73ed9c4b6c00694c4a01b1c1e960669f626c0e4f473b3792f64ffb6ca74717690e76dbf7f8fdb0ee90be179c70ddbed77a1862e7473c19ad176e3dbac0e02b05445a42b495d92107b9e43b2f66ed827f1b05c57a07686360e194451637ef151322c0b3b40ca0bd5c98a01a2b499acf00ebef5c3b77a71ebd030c9625e5fa82c6fb246bbb9d54788f2d7dd000c39bd187397f91fc6f2f070e1ccaddc999348c624d1ff612fcdcc8659a59ae81383557b91755a6ee9776f03484ce7c67be74e1ae67295b9069e8c6cf767c4a65bd04359dbf1aad4fe4e5bf61ab93bc7e39b38dae87b1d3c4b866638fa61474a2d3f4892a189fa2b51c07b032184d8fc3c5e69a3159812d6d9d4373c682c81f8c9f2fed2bb737061f74ec743362a2aee0dcff010b89124bbd6b6c0846fcbc3a812c3276a2fa273b07ec413caa9b62734f92ef2e26e62fb98f5ea6935adf58be7da9a0426f913317faf4a026b22f17b1848c9655ebd4650dba2878dd6b3bdb27c83f6ea1ca512c0ce8b2d9eeef9436f7794befed16c811ea284d2105793f0e1f007b6ff2f60581cd1bd9f5b9b57c9a9f3cafdef1d6083f2869b9806a0001972564524f2d41151eb3670cf9b31336cde822190844e10390cb0977e5d8bca45ac36dc6fe190f30a04d13e29d63e3854d41dba09f4e55808b1d67cb9810cc2d367192371a703c367ed0d5cdc7477056a8117c44b74d420bede70062df90ed65758cf67b828112d682457345078c0569cdc59f9a89202f2944d0cb4af0827211c2862f602d43f7c5e20ff8cdf1f4b74ca58a8f624bbd7734ec9da8590ec1e5a91bd0b1c52f6319d20ac31945185dac4e43c963b76f2d92c5f0f10a519ea2e81f94b8f38041e90d7487d72ee6574a0fac877417af79f4bcd92ecbd730fe662c4cc599028c1b17592170093985e7ace77d1a34645c04ff645cff0a036bcd803950103eb15561cc5fc5a569c2494c01c84ebb91fb49ff18a8ef5ea39debd6588c3aecce1490e338a50ad98753a5fc8caa74690ba7d98c3e43f8f64c9d8732d027ebca56a7827a417d0cbe459fe0cd93fbbfde034b36f4b301309f4e685b62da7dfdbe4da44c494fe267914c8f80028956cfb106bfdd74dfdfcb1aa0cee6f4dd49cf6bf1800394bad8f8fbe8c7ed4f99371f98be759a6deb665eabd69ecce53339d0f36bbf495733a6ffef69e0eed19eae29795dca6f5624efacb67819025323eb28c7bded1db0017a16ce561d303fafafaf2df279b9f88125db0b64d686d1c156d21be3ff1b83b92d8e6d654a1009a0b55f71491dfaf52bb8b077eec097cbdf6ff831b02b0eaf1ca343b73a49e6e8e46902a5cc98e762813dc6d402077f4cf63fb787a5447a1023bdbc3dcfbf4a38c9a74f17dfd6a4feb391d9baf1ae2d242009da717b6d52f7681b8e1fb5ba2b6d60401a4acbc436085a925f0961bd883c8bff3bc3513a04b0b78f577feb700a23f0d086543b6bb181484df9775369af6d68f00d11647e5720a2c985ad1369f2a22585de4affe284b6a5cb9c748bb981a27388f11fbe03776e29c235529ab97cb38ac04239631759374ff7da1d69c8867c48ca3ab15a2ba25fe4868d85b49cc9be3179260660fc18b8a25c7d0dec4d0d8d746357d55f708ac2cae83f425891d1f73b442582a332c25779ad95bf902f6864432a46fafcbc6c9341b387350da56bc1552f51b515ca9478ae7f5699785a3cfc312c980b28ea5f72570d447f53d74234c472c358186cf648bd1411f6d05e82ad1c341c304c170ca80d905f669c3e00c05091bc6bb34ed7a9fb297a61582b4ca951f26d16bc2320cf35f254d59657dfe16b301ede0871170e5ec02a769327d085660fea8a49513221fa2d873b712f5cfe6208fb22b2577fce48ca671376d6c12feb218847cc4aab3b9f0165a098cbb76820205ba0d2ead3f621a4d0a8d02f83a9e52b3e05cb80b4d3b8a06facbfa1875cb9a7b08f68851545fe2df48765683a6ba4c33c975ae47026bd49eec7b47e7d5d38d6520c9f9d54deea83dee1f27ef17c5aa0d2c47b4f19fcb3bcff8c8d6e0757205786191762dcdafef3be030845cbfb836dd15bdc3738a73428e678a0ab65b1e83d01a7d2da984e7afef1db0a72c686904c66434db4c9a14991601598d48292338cf3042ce3b1befa471ef7a16236da7f015830699d4a73b4c809ec3e12458edb980e26550150f9024d75d0d33c81b2a92a229bd5a1d971f04d1d8cbfdd4a213026df47f7f5378c59d1594a190f33b1b07d1673aa84a9799b8aaa3f81e636df8b0ffc4a9157a63f986d24017efa8b27c1b42a416646859f1bcd1fe52b7b9ff9bc1563caa453d8387a880f8cf4b15e7d587cb82d170d907d8e1837a7586af6000fd5c5c2ea35684d9cc5e5318bdd0e3c30f51567675ffaa4779d271a5ca644f86587bc64c0682d744db486e5563b7c26de0334cec0302ef2788f1a5bb81c2ba0b325344e4e2e1ec407d2e909984fd94c943fd76548b6da60d3af4602274dcdc997743f42a3141d56a1867791efe2c7cc690e5ab51a1261f11b5fc58f4b0e94d3ed5f026e2a5ba0d8e193b8da9c6408de984cbfb647bc1ee5c209f2a82ab676c6331a6bdfde7a8e6131d97ae65e8b94fac54f0d93038686f14f661a47ac516cc1515080d3f2a28f930b53129bfd5df3017860ef196f31e19bdd0689db565f9fb0acb0dacbc49a6b499f32f51f806a4d139fb94e319afc99f0b77fd6014a0715fe1946f2cee284733ee02015ef7dc670bd2bb86de2690f1f4f33a97b78fb1da92f1bef8d07252d2479dbe628261df27c3adafb01ebfb3f5e942a9c5c3788fac6d447d9412ba4a94c3413e88ae7efd58739bb99833811d4aec963218a8363b6a6a693f760920d7479a2e87eb7bc3a22ea053c2707830ba49d7db325433d0470234cb9597c2c3f3a79ccb73ff1d838eac6fac4ea9c7fca1e9eea5b7a2af9c12723d13d0f1825f6ea80dd974b33107e76754b6d459706b5b9fb081736a7d4b382e22a75f6adb57fc71604e0e8b105fed0fb7c3e1c73ac926c05cbb2b7610e1b96c0485f89a44afddab36846fcfba02973b83552bb0a2be3222a3531543c0e9b334f8ef21099b5c7e1db3f767d65677b7eaf334613b21ba0ad7582915616d9fa033b2e731c0910717f4241664919eaf2a49cc5db59109e7e1feccab9f62c9a45c8abb8b82cab9b4744ec5f784d801c2116432b62e8920df3cecfe3effdc4368355720295c8919e87bae60e69c9c7bc73d467c126917e9b0d4b0542f78d291b69983da43e7fab054d98f930fb9e01166d173844ab0db8b13b24d24b66b8feb68995c19e2c325e4eef40467553a94472a9f105ba631a751341efba4370bdb89c58e695cee9829aa438c8799b383efce8a8ddc799a4e9475ef87a83de967871433540cc7c5d21fd6024d19765585acd827abfbfbbfa9aa7c1b63741443ea1a77edaa0a91eba8cdb155f1720fd3718020f219f8260898e9f29bc16d58dd1869cd03e0da4fbb9a34c41cfb9f9375622c00b570edc417f69226f834b7ceda16f55b4d74c5e45163d849fb36f3382d0136a08c6425b8fdf89feb718b751b35730d0eb5974e0eb53ae0a9a4ca0e56477531c8436270aa7804b64403d0fce9e11e863667415dc838ec8680b739a7e8f319f3b672295d57c61e7851f621a1dd0df29d263051a175db701c7948dd827dd36a0b12c7ebb5179053691f0246a73d4d86e7b510a1d9bad2b02f46decef69876a8aa976c2829c288cb37ef66763cf014df2c7bff0413dcc30bdcbc1a06b22a7800719231a7fcf5feeb9456e1302aa2513d487bc3e05bb666c5816eee12f9a9bae3fa7f76dbe5a848e91af0a89aec312a2e23e2415036f2b6a52b897310cf69c5d18bdaebaa55e817af91a06cc0beaa1749b6b38da315e0a313d910da5d2ace88e423030893824332a3de6a81f0abc9895f84c7988800810b2ebb3635a9df2d5b1041d3cd536b66e1084e6d279bc4531536643f4f0ed4995e0c56eef6e6df859645e45bcf52e38d6c6f35284fd3063ffc2f3a18e8f2ec5714581f749050cd33c7ff5fb73dbce36bd653fcc9dc8f2748a77b43827dd0af88ab2fc6b466fdae3609753db5fa8f45f23d919acc9c9fdefdabfd207333ea3b22a4c48bab2e326decca150cde0ff56ba731febb24f80fff3b2c1137a60f7861b777331a5216c8c8d38bb11c9b002e710f5fcb7528028de5732e581de57cac38d63a93b444a22c814e9b9d5c2cde7e91a407ad820bf06013b03919ab2fa729721786f3226c1127a9e90240de61126656b906410b04412e30a9ed89c85251dbd480046f9b27ba486af118fdf0d790e96314b5ab2244e2cc8dcc2d51f1d0a672fb9aa912db1609d6ad207321b5aaaa85cc34613b071e71c5164a0b49982acbaec9b25b743429f62370fab21246db46a8b55e16c7738c92bb6ab6f5cabdf01f5af5f88de2f10909394a6be11373213baae0fe7c8422d9e8628670bd66e039ecf91fdd1d55b208b932d16a5eb236a9e2823b4e2fb71bdd79f72102bca9e54700038330aed31f44f4452becf6e070474c65942146916f9762a4a4b55b055027803e0fd396af390ec5bd99f8e4b2ecb41886e3d282ebc5aaa2f901c86cd2689ed55892cc3bf154d5b2e27ac9289b31c10fbf9662acf1f6c177957b6280d1c5efc9c3fc9d01441e2da65561c7c4f4624a0cc7fa832418ed7f205c19b4a388392b81c8a8c2d0bf41679ab9ff41b012ea88cfa8972d0fa90b52973d418054d38330d17080bf25e6a181fea1efa638115cbf11c6f889dc69734bdd92730060ff7d0a2e7fd6329ee7f361417967338ea9e70bc0221ef84cb2272e09fcd5e3c03e54eeec0df36d458d102689a9646ec8b8057add02bd39f4b228d9cbc82d2f23781b714e14c47aec5e881e58dab01505cc0468a2a3b51426c55ff8ec11ee10533408d8a59fbc6348a226696bf3b57421772f072425684b6f3889e277e2c609a81f59420660221665ea29c3097c2f5d636903e101b9642e9095912e40ea40a31678aa4a0f2395861f29268d6394737e63e5845e24d1d599e40eb9a6cc1e1d10eeb0231503585107f29deea0df96d974c0a168171bf62c2fec1540c5e7c67e610f2f7907eeb497f00b9ac31e16a3e65262a13baab58b29e761f71c3118d613647a5fab4207f24720e1f617e875f8f6a345a8c43fab2c6952bb1432d8fa268a10cf23ed76a8e284db6d9bb0507a8009d49e6389dcecd266855c640d93792fae907c2f16e11265126fd34d166afce388ec19cd31de2f2f8cf7f1881a5af0f86fb04453a1bfa22bd875a938fb6a0f894f92d38808faab7af686edb98c621b54aec0ad309be441d41de5584e70c761bb868a5b7eb8f5cb6aab31325f5fa1af43e8ebe98be87cac5d8fd3e0ca4e9bedbc946a2da9da80fa27b9d5cd65c40b20c360a57885551bcb7b650c646d27f9603f9af4f87aae37fa1e38e45de1c0cefd77739471f9bd27dfbbb0d679d2574969f2fb2e4301c3b510b98f72464de51b27d74f782ea9b8512f7ced5e19741e33b0d550de1a2cda15d7c66a7a3b5f5da87e55e7b83da3f22be970e64754a1a981df983c3fd39bbed8bf2acc8b3cf07893bd2370c4548c5ad6017e94821b0a7b68d0fd46e206fffdc218eaf0480e937fee4117816068d0fd2009bd3897475804ae606f496b3936473f937af5bcaa3e093daebad515bd8ea7b3ddf6962d58d822def5c60ecb463c3ff18bff1fe4fc0bc35bf286a6b08e3a143be0aeeb7f1e6aeda24876d5a62ab62ef287f36e71ccdc0f9cee8893fa079f1b35bc0accaef9eb4957d626808890abb6f1a0cd4fed35c399119f8d2e3d06be4292fbd53a876df19de8b22f92979ad3c37e30651e08dead11f28019e80a5c4e412f8cb67e15800e25aa4f1022a6b55cfaf856fd17f989c098ed4f3507af90733c93027eaf46d406d5ddefef26a6b8ea1be1c2cbf49f9d1e19eb39abe8979f5fc83e07eff5b8d197c1805b72bcfa5962755d3643dd4de30dff8da027ed915a79ca59bd17b0dbd6f0b331dac12548cf2346d667e30c12fb4dc9982ce9f897cc7566c837d77029d80486047f83e3691a00c7f4029ec984725bd8b869a7ee5acd09afafb0c1246de2a5a220cbf47799bccac26a59ad991ae0af2d931fc285a449491ec1837d0d125ba1ee6893b384042d6101b03c44ac516ac472c206db5db5cb9204ff5b9f45461e3a57d4408556689ac800d411a045e8f71bec3c252cb5ea8b9a794741f0faf5f1aed2fa03fcf1bcafd572924d1d3c71ca109eadddcc3742469b0dcbb0cd2e4cc1d73afe83dc19887477a8635e57198f5a60b0b9ac9fe022d511df5ee9509247dcfd4a6307ac3e156f040b8bd045634ad2faa9337689c8793f069aeb8efc006b2f8158dd82a94ff00c4717075248e7a6ba053227ba2b591aa86900f74859f8e1221dbf008511a69eac25f2de656eada59add35a05d793044fedcde9fd8de34dbe2a7f9bea226537f5c2571c1eaba6cc7bc06d649d4830cab2da043f83ad875ae7996d6734a9cea1e7795f7d2ed69b4b0444e5a6c5619597d5134e96ccc7932e7b37c72fa043f29718f3982653555438cdf4ab8b0ac862efc74fb4c7d3c153e99b1cdb8f77a4a41b4fd981f252d1dec83d23f52c2376b23bddb82f7dbfb8bee994ee415187eef19ae0581ec9300cba5ead0ab9ffc810855601e1ae68f8db7f08c12ed8631172eace9e108d61c0e040f15353c7f080075a7c3172e2b0ab8d7cf98aae5c0290453f50a3bf62874a5aa7d416454038b697d99deaae39634aca45fafe0d13b60ef2dd29b065503219e8504767730972cb1373c25f7bcd8e98d188ecac40ff5646044ca52c9604e8db5d97e561859c66b62e0be69403a84d8bf10a958c5355ebe2cddc27f26d4565c2b2c941302954a93af207bf9d7541b4412e8022bb29a91de452fff321d5fe806f18b7991bb395b148ce1c39155b2cf1c45068c41c678bc7e896c86282e8cd055ee57ca9da2e4e8bb4095fafd74ce5a3ef34aa0f38b282c62e066ecb017af975ddb861154b77da1c491309d29d09b25180dbf3544a21c077f6f86cc6e6a6aaec7468d056b8025000ca4f4a7a71509f0b8b0e8ff5509402b432c40aad70b89dd7d619b6af436dc6185772d3f4203b3d0e03fa5584eb93dabbfdea273e107f0a8a6bbf0e5aae235bac8d710b792ac67a8a4555b0eff155a77dcbc356f1595bc05e91ca54bb76c2cc0659b59873d23f8a20a440aeef650314ddc238178d773f12b0fcbfe97d5a63049e86f8fb003dea6ed095b02713a7d30f08303326b518028c133c66360a093c02c4e2de93d4e86035a12480582bb9cc7afd07dec9ceb65729bd57ca3c151ad35e29ee4c660dda7058afce51ee03ab3da1a2aa34ebe1bd3d9f5a49b90935823b4433c37ad7b7d5440b6c548d7cd110cd40d93b9060be8f314be0cb90901a2a0ccfd63ba5f0b28ff9b2c8ac6dc1bbab86f0ea7da5323b0c19c1df8c4c459dbeb4c9a68abea0e1aaf02b16fb9ac5c47344955174fb02e1a43ee014097b42252a530498d2d73d64d3472bf821ee3f4f78df5e719be7bfda77013691ae7b496400d19cba469d2e5c574b0819afeb4ac2ae719573f6ded71bb76cc24b3a6b5aed1863be7c1f1d3acaf9320a41d4b151c8936ed59dd052ced7f0caf1f6757f12958adfb03ceab4798f58c85546869cadac714584953d5077b77e68401f565c7b85d5879259d994cffb16a64aa02a9cf5b86f3c3515c90b41dc5185d9413f936052aaf93a898966c49050a6c9fb6471f3cfba9186946b9c6fb5bae2bd5dfeb81f156a2f503cf2e1d95f7b1a53bc17aa3145e77142eb070e19b1de474f83741b19e56d837bc766ae4d792eab8e75ae41cb7fa65cd75de46cc3d611afe544c9c1ac4596b3e2b21992f644ea0103eaf3e271ffb83428babbf928e64e42369aa861c1b3911ea8d2cd39ade3b22bc7d097ddf9635579df571dc9fcf3717ad46542091eb726f3398eadee5f27bd3762fae1c23e582c6b3e0a89e23f55ccbf2d4ce07c87d0c8520eff04614f3a23f3d00f760bbee89fc8d59279bf28d461c3ebaa2014b8b147ccc9b9d5410a577dcb10eec91f91bb33712d705bff316428804a84a3e6924da91ddc6ead42d2240749883ef74f0d29b4dc9bee89e727b36af22a9751819de6578b6214b243606f8e363ccf6ef490591bae88113f316c788f70db5e3e32189b118b73edade564316d77e77a0b557f6c501e3d887b65a65b36a160241d6e59f29459c909ba8847fa36b86a4becfd871b5170c935cd49c35aed8db1463005993e0686001dba9b4045d78000b2ead7f0c4319aacb32bc147964b39bb7d2baa360e685db847369f562f6bfd2ffc9cb5f638c174f1ce5e97833c6448bfd4cc074a70d47579ed993ba0c822d8efc2208dde8f9a979d457d840e12c03c849cbf15f7565b69ea964d3bbeef946c147536a0ab833dae5e1f1f5c050831f80b8882e476e717839e856b0298f0038d1a4b77dabca245c75e91dfcd85068f3dc2cebf3afedaea3c6c4f6b63ae07e29805fe34a9c223f6bae9e59a148a88c4026e629b65a9812a5e0de28356b061d6bb19f85a9c6d5f8b203662e2ad0348a2dad453be053c3f1f2d804b31c20683c5fd9578c3156360fb7f0d2b6bf10761b307b30de77da98a3da4fccb9fae4d5c046a8e53369d0dd2abdb6e744566b7caf6a0dcc31dba594bca62a1b524f10feb2313d45252c4fb70e0114473210c5506a2c3cb95d7cb24f2960c5a74392581844b320768e2e8b01b0fc546ef3ac1164870d2e5b79de19f0dd833d3b18060cf418a22d7f8e49aa4ae94c79d5f427eaca34b733d4d301f644947a197ddc91b6522b85baf60a09dd2eaa952721acfc6f6989ff734b90259b39e7b420e58cb2b0b0e56f5d50f0f9a7616119a0c84ffd8b7b62dacedc612861e93adfb00648b690856facf1ff27adcf3f805c50b6325544f2c009701fe8170975dc60c72cce77638b7c679cbdef93d817a3ce24942da2d9b2c3bfed810626d75acf22bfd18cfd127e4e1eb74e0a4326d5e0be06db26c9c3077392365794d560fe5913d314f2d028c6b54ebf53ca56c7e5134ab238909c8e986dab4ff5f96351fc81b4c11891e4e2760f528ba9672b3586712ad6be0cfc3ac403a3591f650dca5970d0a87d404818905aadebc66dc7e604eb31b8ef433b55457864854c965f485ae7da52b538b98db2ed2d6b30e1f17b53be77d8be4ab775607fafd907f2fdeee8783a924d9a0e20a0770ccd6d1513eefc6c91b3cee75ae9cd8685aca8f7992a048b98ec00b6348685fcba3487efba4d17c9b9c375352c2ecca28c8d284d19284d3e8261cc9311af52baf6cc3ddab9e67209945362f307c068a453166b53120fea75dc0deb530f44bd2e5b79b6f4e328484f03b87ed07e2fa216d9f2e8c9627dfa092b93edb738bd97236e7ba348e8ba2d2258208e9d8a3e84fb5f0e4ec92c03f2b9eec515bc0e90839ef33381382010bd69029cfb50b6f47156dd702d66a66be93c0773bdba36181d1ef9d4857a897a6c39b9b60b2f89a8c5577d3b15919bba7cafc287f97301f9bb423a5e9d75cc68ca151933b2c9527367835685c56093a78ff2f435884b12008eee138c4f2b7c789b7573bf42d44c9da003a3283c5b213fe00d1913b9cf9ba73b8d684eb55db24a6d034729912b08bcdbe6c7d01bc21b14c25eb86478acc6e3887253db9489a195dff9f5c5393dd306ed6b331ca20aad5d591a522528bc2e6f64e50c7f8fe41dd1e322d71ae92b0e807db581aa6e2a3761645233b7c143cf80335d2bd7e370c0ea01471babf60107611958348669287b20adf85c29356a4e41f7e588cbc7e75739a01d2a486d7de5a6aaf502ea18e3585d44c675ea2733b4ccdfcc2cd2f738773c351db82dd89bee29d72275038c4bd66e7c5587b2b8af8eeac3ed13a92b784563f47edecfdd2d10d91e566804ff1c54fa9a45a89e154acd783b8e805e0eddb0bebefd268e49710fb7091dc09438d89f8f5170d8c68f2be6d528ea12afcb74609a27263dbcfe8145b86ef3109bf94a87bfce2c5d76bebb20066b5582857c38f628f6935a27c4ba5183dbbda295b8","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
