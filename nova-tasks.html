<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0ebe660e518d61d3043302f43ed40a024fa4f38e21090153a20309a185acb886ae1df65f60ecd1c8647149a08551743978b54a17a9a9e5d1c4e6a258db525d71a2b207cfa5f2f4428136cd923bf67d31cfa42f6e24965ed0dd0017ecd74be7a63279ac823d788eafe2e38e4255a23dd14a03b84119bf9eef7192e7601196e642c8729b04c7904ca809a54cc61b56f27ce85f7fc7bd13887775f4c31566cf40863903c0bf95101cad35102fbc3dcd05f039be0f51dcd6362779ae05e126756c5b4fc82d2a30169fef02e55f48b9c66445c6d6bc5e3344563b483432d7d86f99ac34b135a48889a37ae459b0e598c3e4685cf7c47e2a71f3c8f00f12553db6f7f3c596f361848817e8daafcf7d5ed2f845b12755c901096918782a6d1b7d35de18a2761f2d32964fd7f33fff4405acfb0999ddfa5e29c542a48c5de0c10fd9bf5bf586d9e0c26af9c1926e5a9c40fee3afc369c36f1e5f6eee2d2fa1eb5e71dc166b6f6c43d5b2d8b2fa2736246082288e1eabf6fbb0605a10e71e3dd22fb775e7a00a232cabb86218afa602f2d4da8ac1dd38da8eb6677e8399a527573df7a0cbdf25aca50606cd6e6b4deac8cafd390089af1796ba383e6590c59558e5eb494be7fb8963056aefc013c12b20a7568654f31645c31c59ded02a47b86bee5097c2debfca423ec24eedb1897e1cdb69ea494faf828d45293613d1a5330844a5a3bf693381717a5e9b170ba2ddaaddb9c098416baa6283ae68a7c97fc6c6aa0c66f0abbcc4ee333bd71f1c354a386b4861e789ebbaaf0fd06a10d11ff38f8cbed749c6a96f92b11983df92c1f36bda8478513366d071f01db26d3a01e813901b22b82e97b88229e67340dd2bb15832c26ca5438a6561056b66de2609590699fef0cf33dcab7f862dd273003cffa66cce839a15c4251be22e60ff294768bae4a066657b729501d679ec86eac972b36af905a9de5b948d15ed0568a6b3c67c86e1ea2986367a0bcaa6d1a9a902bf84315ca03273bba80e43406ea62934359edfe8a05d5048ecae2c06266352680eea5adec95608be502a83c21b947292313634c755ce7c6d1c218b229d9dc06d1907a662e1d8dde334ab80f3a2886b2f10270edab52a305f2414a24c4a94ed01ae076d507172c4992c7154c0d976cd063a25fdfc5b5eba86759279be5e9596bde9d771fb9c38c631f6585491672f58424f601d186e6fc8f58a598402d0a1b0da3152e7443343e676407c0dda3663f825d8afb1a6190ed98be30fb34fc1b54f64092af9ea2e979d700012d497818fc2fece9614a1734b49b6dc559cac375b490322afed23edeb82fed989195a42300432217c5c55e16bd6426023cf3e88c6dbada988db6fbe004daaf728e6f60e6afa9542b0307f3d1208aa512048b891a37a73fb323fcec0642f6498a4038c8cc92bd74d4be385fa43f6d554b68e21401dc732c9bea8f29c6b9959325da0cdd521fbd279a02de90db1cdb8eb5e8967c6c61e3ead8feb2ebe9b30f2814441ee530c718a9464feca70ac02c462da34ca159b30a727c9a1d52ddd7ec455844d1d9af93aa2dda747619592554fa6f0221fd268ca1bba8398b45868d5c11513354ce9a7b626e2a57ae8a4a379fbcf46206b685efcaa9a2434f372b6cf8b47bdb53b2215f591c46cf2e4bc8c9158afeb86d5fbd4ba19aa56faad709eec1f62795160ef069231c40918a3e5d93a9e241252055ff5229d7f6c3676029680bc7d149b1d6f1601b052fa659a7bcffe0ce89a7717389e888cd29d70c519b8b9673ab658ffa6baf9dd4679e53ce283eb04d5a9076602e2eec7f184d0b88fffaf8ad7b423f0cf44648abab06828da5428965d38770d67682f1c466dc02375c2ae5cf4ee5d1ac7f4a61dfea38703c9f8b8ea20ac2475764dfaab5d0bc4d24e4e5f929e00860531a44db2a52c733a2af7b3b5524cd45e12d10f7d2f73af7283d47a7be799209f62036b4592fab6505f1ae55a71be9bd5f55c5db9497bfbd0b27255c2f1e60946ed9f92a29baffe4f14f0b5c26a7562293ee3a74dba06cec7167139ce66f02be866301d21f5c77195094704b677cfaac3e4cefdb41b58d823bfac7d33f59b180dff51ff6ac3edb5ff7cb9d05432be806ccc9e1ae2f464d71584acad85e902959247afd969e1b120cfd2706db76c9f9e56257e4a7a0690e34b0aaea379773194f6ec6e23d15c42b7998652d168b76e7a8535f02815ef1e21610e98aed01d40f9d6537b43a4fe97cd1ddb2a2a19e1d1d8c6b4a3bc65055271feba3588aee45b75b4ccaec41023795e57d304a6aed04bf0c2f311f85befbb821c0fe49aef2c53c7c9a3c51325e6b74a4200eaec8cdff20b6bd7d5411214b0f5951193e78eed9601c4b1d98e18e94825df1662bdd11d238ddd498551c47749bf996e2e3bf5295a1a083750c967e6bffd0005cdfa61ae891f7178b043de904a7cc20b1dfbbe237d37c137ba057c2198a675333a4a299cbbe0627ba8f3b4930321a045c21de94c7f9e6a6bf27a241f5c2a51313fee5c783b6b0dc62cfbba19f5134e5d15af7082d6449225facbe1b165529e21dd668800c7ef0d5c8e4f62fb7daf50ba8ccd04ee4a0362e18e3df0b7ccc181daf98207a33ed11b8462bf500cfe555e6c171fccf2eb404c485563b72b639658cc9f73f69cb6791978878ba85c49ac1a221cb821e62b9aa3fb606b8250cf3792d8286e19fcdf8df4fea9c1b53ed9de71061b2a7fa3db85ec38ec977b658481b1532da5b1913850e8443512790a7ee579c8f119100ed06a0a778df7bd38bf72e09df1f9e2600998ea6f0650926a6071f9ffdabd7a475b0cd475ebf74689f08740144521e4fd288bee5bc701ed900034dda6009a292ef842050e0aebae71988900b6785c51c4ef1d00bdce8326aa6bebe0c1757b8a9ed4c12f5a14d45e1f1e9aee736cf7f96034faa5ccf6b484c14396218cbc9ec66901738310ea790ad8e3ee212aaf1427a477898bec22938b60d243fa1846a8714ed7aa6820093dc97136d008e9db7c662576e7ca0e146ae82b390e30c3b53db355e8a593017c56b27e4455e6de8f9597d9ab125fab405524f4500b2d4c839021ca637ba8a12cb19021c8d67e5295191dc1f197e9b78f5044ddb4b7dbe5b9c29743d51a9d9a07b27a4f7d1e17d23b7b6188d8b8c50379d2665324973a66303f8d07a70b322fe3d9df47f44f0fab4890279e882b291bb8aa5312a6ee7e114d3206cbac5d76767bf0e00606daa9a738a3902f32456f5baa4d2f84e0057374cde056a5274f2efb596d5909a824638927a4889427a48e99fc49f27137575145b6a66e981505d0901fb41e532f8cdf54b8757890df7403d57d36d5de7f701621d16b76896a5aa8eaaad0545bd0a1a0a2ba6ca0dafc4a7726d0cc52205b2cac3d5ac11ce686716180fb9a22d90c8349728b7d2f9858d9e0b6bcc819bb924e6e5f2bc5f54f4c5767db150d95a35e71ae34c80e6d7a9b52e0782e73b72dd023970cb0f1d4f1a92a8a21b100fe0c348a8b15e74291f4f9837fab8c5e68c891538d7c1677ec0eb862bb55d2bd7b1ad0f53291adc1e16941b22feae5f45f7755d6778f5897c99dd747587c57e3ec5aa45da62d4933f783cd3fd0f7fef74e4fb82e25472a518446eafab95a8258d82de95aedca05cb9f75ac287c5ebcde2f3b5bbeeb69333b73e82b207dd410dc157e53de444bf3aaa5dfe0fa42bbe2bcd499bfcb388759ec11dda8929613bb57da4aa90499fcd753e57320d58245b83cd05bbcb78b694bd96bb3fd7b79da2b5cb41285ae7309805eac1cc1f91db6ca8d2a2a32ac41c985763708b30ef9cbb89e8e6f7ec6b74565692ce69c45def28a5a18f247699ecc7fd196b94369786a337a0573aea5fdfb4591f1bfb17ccc865ac1a36e4d405039697720c6cd94fcf30823d90ff4514e0ea573d9c8e7b415ac0e449a0cc95c8883aa5e9a90b6796b9004d771993d2adec37b34726f2678ff11c56327f5d7f28c9c95caa070f9568608abbc4c31b00c6f7631627b28ca2adbacc63ba0ce1e12038772bd2688bed997b69a71c66468219b123d80681f4675ccc247d9207bf64538405b662e00a01dd00c4f9be4e60484407c3d5b8fe13318847d9710bc44226c942d78a6c0219397f763ca12aff6241384829cf168937cfc50d7d4ea259545ccf1096749a6f88e42dc52ce5b61283a8141fc4d10c8b03c8c9a09c3114ee40d2fbc47dab2b7473b8176b35de999983201bc654973485bac1ab423c734d642fbec374a3d1cb56ac7c6995bd343a04b8b51cecc194c89c4c7e0675fa66ff1f1c3341eed74994c834afa3d48d960b1e0c6aae3e5ec528acb8e69a54e95da553dc0e466cb917043d0648b893e8a26759a8f06a266e6c2011d3b240e0bebafca1f3bc988d409596ecaef4f14c4a681291749287e9d0d1797e3232f00bd2e9962afef3c13777a3c782c09ce244ddf24bd62314445044405c046c46024a56c9d8211e4989e802bd36bb99797014604b33645f19a9884eecbffbd873440b45e9632e1d46f9b8e94168c8e7740aa8680bd79e47a7d0ec5b24a756b07886672760128628de35a7147cbc7496ecea1c5b93fd1d4914e3a6a425908c57cd299441b88afb1547851bd94ff6c3004e1781999b61d857e9ef358e74449205c6c173230d6deea88f68751c9f1e7aa38a2e5bac064cc83d423a7c2776023d112d6a670830e7145241af96841fc2df9784681207831d430b012f3e658ed29629b1e9dcb24ea60f294f9ab316953ecf4494d1d1771f23cb44cd0a0c24990a5df74d9df11e2825e53c6c6700f4cce6c2b2577729def299792370e1315765f043c5ca209263d83fe469c0aaea4af4602aa49115529f38a8e5824e4faaa66dfb61aef9d7083353963cd80bc136e824e9814e61fe4222da6014e050693e954778471235075ab9cd33eec29ba8fdacfab200ddebe5dd1cf14e7b1a46ef8aab958d1d2107c0dfd55e070f90c775336c1e661aa275709763dcd1b852feb230bba233773260a9232d35e6d18846851aba375ad728a7318303fed8d169b9cf9c213e981fe4d34670fd8ff7cae498545545c18ee9f0760c3af09239a4ba3a6404011c69000f3ebea1c4a43285fa69391c0e8c425b564c5e70889e4eebac200e8db62434afbd0f2511aa9538354043469b0fb03273b009774061e7889c2e1dab7fa3e698af7972bbd7003b9b4a273f0f1775b5864f6937d55f286b6f4f498be7e604704c63b010b44a07457daa8892ce40cc53278cb969c25b43830b253ace4486db8e52e9bc4d530a387e2f3365bed0956f9d4552bfab95ab8c246b11f6ea11727c90ebe94df853e53043b018c7665ee56d781f79501851e1dcab3c0669b01a6ab137ae7eb7c105a5addec5a7e274b41cf589f2c755b715f3c569514a311cd768e3e631d358d0ec59f94d3e5031f1c385f2a128d3f8cabcb85dc28560718eb8677544b654c59d5ad51c610a60f4c4a708019b18aeaecd141b02bac8b40bb2ed13a67f151963b8285a11ff83eed8de14290f56e6a5abde29fb825f167d760b8eb160eb9978c3f57b1c7a07a288ad029a542ca6d79537dde78abb222a3c5bb8007d8ed61866d4f3e26c765ea23f7f79015aaf137bc6124dc1b541317a5cff1dc29d83d54a249130a6bd7ad20959d46149bbfb594c3375155c7ec7568812219ad4bbca4590e81995562996c37af4903f8ccaeedad536b8859b580208b6f161a18c19ce1ade80a7b38a1276cb2a019ecde059902587d327f01b7aa9665e8cdd558226d458ff779b7968a1df0ffa5b38ceef988ebdc950eb4293f2c625478885dbff53755dfd844619400262cfa7bc62e3565eaa4f8bf15bd84805a0f131b3d72a46ed4b6035f658c58c426408008fd6f36c8dd71bc0520f2deecb3bdc140a71e4c351ded74f02d305624bb70d85b2ed2f96e05ebff7a80be9c59029d756eb2377bfa92d0d910dbdb14a83edcb259570e6ec5069c02e39455c1be912a1c9697f639f709c3bb5d8d71bd05f60a27580cd7cdd13bd5bca44c12d5836cd71ed8b698b593715add7fa85dad57f69d5b56f7f9d1dfad33daa871798aeb8459f58dffe701a1e6aae23c95c7e76a3f373778c421e341b1e9a133dacfc53dbdc5f9c2ad5c3e191af0b88043cd37a6aba43a97ad6e9d99bc4f2c43c36048edd8767e03b8b540df182a3a737a88a81209fc978e7b7588dc734f3331f18c380ae38568690304f28574afdee4bd3e3536eff2f2a5c236ce1be9fab04a43b9bd3faf01954f5463b3ba34b67db405f5f2a76ce369e0234c1dc4b6b6eb8ac5c9923eb11c3dbcebb730c012a6459e0860f059102b22f83cdbcff1641d3baef7fb44b083ab7e571347419271356e95818d409b7b6e266edf6f2eec7c42d3f9de7be75850d6a8fae4150e83cb2bd0a61fa8483e6ab2b49d97c0958ac049f739ce21c69fc64e6e418ac49118f516afb8d46f113493d389e1b68d0be913114d239af4d6baf023b784185a54ba23f0fa2fab967bedfc5ccc9dbea6a5c107c7b35f83b5ed66dd3110afaf89422a7f4cac265ac533102ea593d9b51cf7d9c7aa145c9aad0c7d5e5abee59be1352cfd143c73a9f2579b628173655eefba863d8dbb1f24370f2aa53dc670bf579f9f145e9aeafb0b73eb9d31a9cdeb3affdae4b50ea37c05d85cdc07143cefa8c9ac92b19af0deacef5e808c070c29d8bce7ec29250068cbc0ad816a5fed4119d6d193432409e8674aff917eb890b5d74292512a2860d055f4d1ce26d0c32fde9f615cf32f571056628a7f66fee78cfc913b4c382d3ec0d45ff94c1a32aff1d959a1445d2a9b420cc47cfda7f351c26526a73d26b08b4267a2135b92ca5e80ec6a962f9c7fe656c04d3250404618789b7fdb0c221a6d5d6be2b8aad36abd304ce8eda65dcf9923221a24cb1dd5c8f8d09cc0ccf3c715a1f8ed2933e7af0ef60a4505ac43f23dbfaafa5c37f030ab3c01ae46a13b7d97628319bb30c5bff9401337978f494648c6ae73a7ba16ba5f9083b792167c4d1c1438c51ca19b3b4bc612d33b10b9bf0df51ed4d4edaa723aa1e720571a09cccfe254d0dc7986a53c09d16ade37dd386649da8c8301261dbc01390389bafb31905c00079fd8cf2a691a56d8574ab1a68bfae169292b74007b0cccc9c52f1b3e8e4f4e2f9eebcc93764e7331bab806e395821900352dea3570a69a978f87bce9bec7306167ff09aaccb1acb3067d54c9ab79024e65bd0b367f27942513f458004a133c4353b340d25f1244466e5e587219ec0c96c5dd6ac57e2d4bb93c2a8b79bf113d98ab981f97a8ae8859deb5ff0292e5360757e7aaa9a2b0a8fd902e7a30c3fe8959be6e1f467fdae7659d7bfd38070ad29954c35184008bec3e790b14e6838974b155425e37541689accadfa32b4d9596902b9668e1182e7b31b0a4140018e3466a44b14d77a79ccdbe0943df2e2a4a89ba3a00912cc0c441dfd311d610dd806a933f406acc147d8a7471657e79aa1115deb0b57446a0b9b3ed7c6e26834c9ee685b2bbf4152044d366d5f5d83a9c81262d6fcefd2543077d84cb494ee869cea62aa25601365e58b322cd57dee986bc49698ae2576b01832141e4feec80a567bb38d6e7d06014f5adde9abdfb18e6c6dcd3c8eec29cc40c2439b4f27843d80f7077fe59cf574d7c9a9a04f58f31d53c510d18b342071f116872596e9fac1db6523e4a82461cc7d34b2b8d0cef67332f8e7076b15bd5aea31f3920a493f3abd24f018a0c0d78a74eead2a8b42d8cf89428ce712e68553952eea97b76d6cf7739227da3f24c6d7576477f0c257b6b34975734ebc3996e0cebb09569b01e0f1523caa0a8ac25f53de72ebee43eb1363c0610705ac5cf2b73c0237d410ce3ec58ce04f2961038fad03d0fd5e6a95d19575076f53dd49ed0e1a8bdfa4e356440d56c3160fb76577648871b93a1b04f5be9a2e0da9df681a55020e29626c541b92fcb5f61c6f3f58b7289dede1247199ee86f142b8d8dfb9e29ccd0da198813b3a2b656851c19c3614166eb3cf61e350393dfd1378c3a5a4d870c75708328b507c985ea06d94b594d4b3a872d7fe99a6505ee9b590a72ce182f54947e95e74c92d9ed66cfcfee9ab550a71c9a29c5518ce5ec242973a9578eaac6c397b8ba41620ce8cd249048b17bd1bafb9d76f9baf1a0b410f367007588c6eda1a87341c22e546b4804258ba224dd60914af2bb10f3afa06aff3e4eed6f533e70a8222b2bb0e343c7453b2a2252dcfe0cfeed4dd1582b84c748e779380c0569e78180568363f6241e207c3aca627897ebd8ccfb445d61af2ca7d6920e7bad333e467845db6419cd29b4bb96314ee870d3c58b6847d75481d220e002b717d2ab2816362d021dfca488ab10c9abf6a812ccb9a09b1e9452e92d6e5f87d2b0e8511179be14b6307aa24cc03f5760a34e01871bc0ec39a2666e56b9323044d17240f03149f1d6d15e7df5857e27eed6c404319539175b908e6fb8bec0a7d61d1d89059e4fc91d9ab1dd40c170ac9550f9ef1517826249721a4cbf6e50720d95df6a7f11615bb2ea2b950ef625809c963f619b8e267a4443c5a8fdc315d5e70b7961511d70f973b9375ef58ae2f8239cd52388a0143fca0e5696651ab7fb3d035bff041ebc9d235dd1142ab3b142d08c3e425db2865f265d0d5d9184c24d91788b90aebafdf22a3454e8570325b86a82ac4c0c52745d14d7d41560ab5162415b0a1a07f9ba24b045210f5bae22de2466119309538a2bd8f87804b6357085b7a8475c13164036a3fedc149b901bbbff43802b4aef0cd6c7cecad841f694ca5380af95ce1ba55fa79d942696d21ce7e1c2f7414fa8c613902670b7e26f940f1713b89fcfcf66abbb6f674972e33ec6007e6fc59b2993033de34dd3416895dbbf4b6ab550b14c17ba4f35659dcb7dee43d2314e202cbed3824a63ae3241b3f46c2f2a329b3204d862d66a59e22deabee91e833b4a73898caaa3ec01258e14f5b30ad520f2362bdfe05f5955095b5d41d3cdffb9150851d884c383b72350284e506ce9f35c111a0eefb3020381dddd852c7a9966721cf0010512ebc2a8129e06cf8642201eb0401797a09ea68922129a16bd830806c26d0d65c4ec125fc5c98ee81d2a25857de905dff46e63a1d4a9f4ab0036e736889239a8f4f783517636ccaa52463e7692f9dae583194bf58bb0ef74de4426d00ec3eeb0e2ff1e7ae75a4a61fa31eb1d3101f80a79716cd600cbc0cf12c5404af39a2e192236b4c4571afe1e5cc78f92e2ff4381c966aa44ee1ca5cb189cdcbb5c50de933ccdd067f235a66ee37fdec673f9046dab3a77d25f3877d5de900a19ee49323719f42aab5fefe36c7e73ba6dc290848b1871e350f739accd6f4ecdfebedb3e41b3be898df59d32de22dba45c9752f40f7bde45725645dc294912a5a9239b22a0301e0d6ce775f1d65b8ca9e8db835ab938165db46f59dae026dec80e6fff6f4758f796d568a91387759c54f246c215f2702fd06cadbc636217e06a7389c075caee4714054a324043756c231a969ade3eea9cc7529ba83b589fb912787f31f06aa174f9b558a9ae6d224216097fa671cc540903c9987270b71d17001166ff00564fc557680507af3a82727c48c237326744ecd0388888a6b98bf13d136448a87601fe156d38e7fa70bad4ed81879b8275242f23b6bc009fcdfd217d81c1a433bd883ae6f44952749a01b29dcf76dfd076da3ce492b16b3aab23a988aeb6f0c593460f7f8ad886b328798fb73725c92b8df71e3efe286b4cb75251a8db4cfabc7f00e52172ae64bfd33d88effddf2f0ae378c7d43dfbc2ae030f31ae41aeff9ffdc0c3374a31d114604b8c63774323248ffb6739582a70c37a7e8d6458b7d902acabf68778278f598e775589fb6d39e7abd1375ea6610a87fe49c533207712e52c5caa87fcf5b8dd2f47ddd0b79558d4b1517ec28a9c36de43296bc5932ce96df660afc5666c4318dfcd7e1900153e16c2a561cbb420661b314bf574357927f6c1e7076931e35de8c121500ccc95c2234603e680a085175e3319b6018786ed7ed8006754432914d506955e7d7ad11d018ff70cfc194e572e9fe12db5f048de4de9df9b6dc6620647d7dee1812884518cd23caccb5a62c6bf02f1a9f326933d9ab66876794ae8c152b36b2d4dfd680f04f67694fcb08890f390f801760c5fae17814142de9107358111533ba941e8954698a66737fefd8223a3628b1222295086600ab5b50bba48a791d2385a3ddf427973a5968cacb28aa74198029aea272383da41f541fc4f046dc3b8a180bc3eb4a28aa48658e0f7f1ffb5d2d9348886fcc0383035ef71972730752c91411d2cfbf3507aa1ff44b22148a1ea73d0141c568f4f9475c85b8d97db9848cd66f12b8343a1c94d15cf21ed00735385fa2915399b4c3e3835025b0a74749663417c1b7086902dbe552fc44b3d8052e086962cebe9c723351f2c081cb11497c35dbdbce13a6ebcfc6aae8e0ec60ca8298a456e8108d5ef5e60cf80d45519553460b794afc495fb4fee3e37d10449aa679dbc8ebe0f7be5c1be29f659c563bdddc74034327046dc334327796702e37e98859fa8bcbb979411f97b4bec0d36dd28f862a2aafa405f1a85cea38b7350233fc11a27aed80f8a6285136bb9bdb63821cdd8f7668d6dca3e322a45504588bd05aacdcb635f26a2927e1e7e140b8d0d34956a2c27fca674ecac6509f0f58f5f3a263950cf5af1e8f1375d86f503ff650d1c1f88165b221b609c509588de1d4782252caa1870840f3f5524bfd54761e3b6245c40c7eb174b7df61ebbb7c73545685024033b640f6e7bc02b78d216252cb805e659b08fdf6e4da0ad0ec365443bd6beabb89825e25672b7c1b4b74d9d354ee182620bfd6a766f41eb8d005c4b1b253238a9785bd575535a30f3caba61c5661157058edbbe56ed0533c10742fe7615101cb2382d0866f50ec4f1040223db3046d0f2e56b8e78d4f1b932920e1e2400866fcea1ad034b517a9a4cec5aa0a2d9eac4e7c3c49336262014a85ac5feede13068481a8fbfc0bec24633d539da1ee28588032a706a34d9b01cca372a78495b4f51723f57dd44cc81710ebfdcda3058c5a938d56420c67e47397698adb9419a393db370ff70af95a368402fb5647f74c40cf3065c2bad53bf7f3eb13a37bef9a5917150d8576e183f2f52fcfd4fcdf5d266f4c247037227a3c3dd4cceca5af35abd2e40c617c1acc095eee1646915f40215d9d9452b9d8fc971cc136427a41f82077c620af480cd657b9e1865b43b11cc2a64fa1636750acbf3b95a1809d00441f88b1285eb9b22e49ec421ceb30b0739315e4f307155b34a3dce3aafcff275633c74850c511ce18da60c0623c3526a629648bd8b9f3fd19b03abe1b72f5a63b8c26995958775f121192941164980686d84ac29b2ad80db4295ff08145e6bfdf3b013b9ce6d99dfd8f3805199af374fe8bd10a2d580690891a506b77a9cb860ed01ecb2686574e69e6116dbecc33ee3e79c0b68c1bffbdd0ce5ae6edf1fd506aed6aff535ec70c40eae2ec966324e106ddd2c8a855a8366f35720d9741d1adaa083e1b37c0d596bb27a5864bb621241b102a7e18fab872559ea3239c10cfc4efbdf1709a674261482b6e7759c35e1afe5326985dcd68f77a0c16602d1c54f5d585ef2b1ee3287f9584f1253ba6561fc5ef0aeeea5894be8c5954f361b3166204849bcb3ce59f0c92d6a5b5cac648eb165f9c76dbc43115a431173fd02667a7f36b7e74bc4e75b82bb28c41add61ec25cb82f255bbbd606fa4efde0f7b76515a0121413253878bd1df1bec69ee7ab90df3c7cb976a58fabf8edd401bdeafb5e75e247202d7a57bd4aca9cdaed6ebfce0e4db614e3f361215f8781fe1258fc5cb7286de4d8b658509490ef9b8f71bf40ab3e6b0f100bc953f6a3d5eb381d6d9b6b1b36fc1a8d38667b66fccd08eb3e35d614620735877a2eb920b491ef2f363f11008fdadfd1b4e140e23eeb4e83e352a6def01513c8ef3011aea14db16284a278d0c9b2ede0591484ac647dbc2d9ab9d84fab9382a6aec370f6c97e54947e8be5451e7182d7a7655a436db446db164525ce84860e1e05261340b7c52af0ec60c3b08be658ff84e175dabc281b42066e489fbd6106f63009b8ad13f913eae730726e74e58bf843c9b7ef9f6a251cd225e91f4d07b993a936f40910c63f8d095d2211e88022ece010414641c69156c069da1242666672c90241aed8feea8657a356223fd9e2ba5a2b846ec3ca3f45b395b281de882830eae17e7af4a500c6c47aef3e139a3e5ec05d01ba32df2445cad2a2bbd388d0daea95f1e58d48882510d2f2c84213f8f340bfc1300032f592b803c562f31a36013ca09f92ca05575c53b830342535db2498b3b50beeb6657e63aa3d58e1c6b7d315a4db1927ef34861a0895dee8e120829ae1f65933f5243584f9bc842a87049743edc9cd40e5ab2968961b3eb6327e86fcf62a7362cc9dce3bfb101fb97f32d9a4a9614e648c19bdf4e63a655d1f93c8548ea1a14b4de9f8a06f6c39dbada02de0d87d9da5e4e7d89ffdc2e8d5269adb5982cd8ddd64667ea2e7339ce2d3b420efa8cd16628abd773c8070437cc70d569dacee0349ff4592c09c25d0289252a454b3a57846ee452106c1b603de9a3d15ac7d9862a3bdf49d99b59a17f7db29005859ecd0491b9c752f424913d37ce9fb2e342ab7b08a4dca8871124174110978c6d3bcf2908c84771ac34cd6ca87ad20fbcd55166fc2224e42ef043a47d8739cb591215f54f775ae04f1ca52eafb19745c0b8055f59d058bf65f7d40b235edcc62af95b71ed2c3063bed1163e2a7dc16c3f85e158b6f59951dbc3094dded7b5e689a511e5dcf756c167076c5545a14c542565b651f2e52d8f0bae5023b6b379a9c39f540daa305682bba1ff9b20e9f349adf33e4b40ac7b89fa4dc02fde54a7c323ceef0ae828df6dd7d410d218829da9c4b6c0e3baf736403cb733753a4ca479213f6508aeff904147cba514a8bf547ca6f1f6e49c3d302f29c58635b8c409be26ddcce0fc602000df90c9afe8e75c3e987ac4557193898bed44e60e539f6f436e0ce496f407f32230a835fe1dcdc4937ba1743fa4096f7320d82055e688235c7ad756fdae09e2e700bcac86ed7fe6d0188ff783a20bf2938aae6b5a68b63605818d3092bb8c2980f0b86e4220c19cd6854af2250d900fc6c34cbec8d1697a552faf923c7ffc3c6115e1acc40db54c9f0481cba7c905f0c6d97fa46d2a4e020314011b67a19dcfefbca33403758106d553cc3ccad820e34d6eed05e0d2235ce2c9c15ac1e62964b5bad6c992161a3bde8b664bdf1c4310dddfa47b95da6c5aa4ae1fac1a210ec08d06ace3e49ffcb68ab48fc89add495393d1ab5e635dea0570342bab9e8e226c7fc4172840b8d90b9ea27b7f1dc20c6bd3d95b194056c429b6444eca25a8079a0768c5c08b1a39d33ba7ce18ca0f58750c8459ee6c886f09724b5db447a60f97d27a98a1a43ebbb7094463507dbbab7f7116b8296c4c19e3b720df84ece8dffc9682765934b827fd5ce57ddecaa249e9722965f7259a00551dc527cf7b42695e7f73882898fbde658b37072c574f89a7a863fd8a1cef82468930758cc45820949df34104a7846a7a221967d581c2dd6af84a3200a1312a7f3bf8a756097b4e18c7d8500d57b1972ce07ee27daa1d6250691854338c4f0148ff08719e1d63fab52a2cd13e392bf1b91b3ecb988e61922e5102674f9093ee78223785d38e792531dacce0884af03827a55cbcef216c12f561c5f67e14cc7e66e4e6dbbb4b7130e9b8fde76446fd3e6c82ee61725f75bb358cc9a8b2e355bc8ad4976f0fc51635097ee30399c493b36819108c39cbd2cb797c0139156e54dc322ca8d47e268652de6275a06c88bc38f28e76ea77d60d3f34defa339ca23fff2721ce26d46fec535c1d1e532ffcbbebaec6a3fd8cfe9b1d4579d87affb63d34bbcc4cd60c626470c8abb2a4046e9ce12376085c251a7502d643038c83ae08315b4c52901a0a7c7159605213205c642a86e8a019204432234c22478638e738d228630ddd7c91226cf1d0fc662a54ba76fa10f3f4a8d3f3b1df574eefb25f664d3eb61fb3a3ca5e6fab4591ede8e8fc3ee0f8e82c93a0104b31ad700a06b72564784fc65f9f0feb035404d5b05d6b312a135d0adfea84fc663c921d0b8754f677adff8496f3d466af6cf5985fa8f8364ff6912ce480d68333ec41547279042b652a730d1518a91d7032a08594be8086e0f2e719a87d3a80c0d4cfc78c3b7b2fd895854987b8dda2b1dd6875c694748f957fbec6d82461e73d88a28070ef171eba23e13633287ca71320a5ac8a6019cac95611","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
