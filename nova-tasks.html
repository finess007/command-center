<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4a2952ed96720f0ca385366300c8ba0ea98b1141538739797634cb71d346cdf1ccaeb6c6fcd8f6750826131777301a59bab3a84b97c9a959e9171c7edc52a6e2b81b78f3181919f3067169b189334cec18e116a537988bd918a9d90eced3a039a8f78a7849ce95c1fa3433d2412e90e5da615314e5b80200467808b3e0c02ee21be7dbdec49f6360a8e19decd6942a2b2c6b78375dedeebbe1dc5fb8815839830aebf88993a57d40497bc05ab09dd493a3e2a73abfe63e7ebf499883a5f69a8b5cc62e62af8b35c840874fd87459ce1be728ce4162c8f5668732d53e32452319277123771b61fb7de8e8de1292f386abc7718e8dd0ca689291f346af56059f5bd6a0b82388859c05cf7348633a5f567c4562eaf5e9e8b6d853b9a875d4beac5a02dbb05f0ce054be41e8a2b8099d1497c4bc35c2e5d924a116c1a94db687b28d5fd5cdaf85c8a264b3cb7ec61d5671214bd6816e6e7c6bf379f8df356008533caba1ae7e9bd52085fd348df1cdd0fceacee9f4ac8bf84465fe2efc3127cbd2d68664b9a197d2f02508b65977a590031f2d1832c7c751d371c7b6cdcd92d4afd03c6eb87ad7b927ab1f451ef6507942788da7b754594605473391275c0e10c96cc8612347abea263c32041ee74f55133cfdace4e26634032b3d6732aa0695089f33b68f7167ce35a8deccfe10d9498971f39e1157f9278c2641b4e9f146fecaef8dde67b2cbc6cb7437499d68797f7be5aea4ac1f3a00e86ed72a7abe6350bd33c995169d8ec1247e3133302d23caa66738c029f12d57b9bd96d7703090a6737245d369671667284a408d524c641a2eb65afb7b63dd174ffe52240a52d8af294af06f39cee3c18e84f2470be1f32c8c2edade4c2a9177441ea507ae96b98c530b4645bfc4460783fb951ea41a47ea5df1b5a3e1393e4d3aa999dc538663b02d9be2ca69462d2c928aacca310856dc5f203d18513c9bc27cdbbd128003b8d4d933b22f5ef0eafbb7a7273988210224b7d42dfd51a0b95432f4d2574d759a47c764b11be9bd48c0b7d7729344055b1e4388b26498dff458932a1dba22b8232fb769b77a4ebab79b35213105d068ba915450acef386a688ee9c5d73b1bce717f850cd0608a96ee733f843b95444dc097b81cd806f0c955032a17e7ffc1bd620f77c722c147cd08336a96430174e1a1f9728c62535d6aca03f582186f3c694a8934c0aecd0bb781a1b959bba80adc51bc4d214b1420529bbb33b3da08b54938e1ae744b65ec8426645bfd0f3fa6f2f2b3d9766cbde7eb37b46a5f461f2c7af71450f130c6ca541718c4876159bb7d132e807aea2edbd0fae3dfaa338142b579c0fb79f30ab1628d22ba478d394226012483613cd5386e2e2fe12d30833dcfa78fd52af36ff6a1024b193bb30f472d80f942ff79463bd4dd53a523e0788319664b9c63ec9aa6bdd8129f4326c59624818f853f3342cff6f17a7dd159032e4430846dac1c4233d3890e1d247cbe4e0b74d77dc3acb298e1c741a31f46c3c72caeceed947b9e763237796c4bcc47339ccc7cac9e6519e9f10a405b6504da8a3d1eceacfb839540e1614b3f3c9911bc0b2318e96b844d1b8c4f0215725a35eecc4ad164c1d18cddd34e5a5941f742b418e055268efa9df89fa6223091cb5f253ad40c87cfba1700879174361e60a0f0865414754632d77a87748d0f93ce017de8b1fccc0ad479455951530abe04458f80e2f8076f7673bc8ca674f8e20e45378e882154779be577758177d32abef9b8a587eb05917f3299206b2571d372ac21f2b900ebe1e34a4b3bebbac70a7bdb645abb586fa8f0889d388f5e4feba16cbb76c09264e9c49146bb073a3246e3e64788e7f6cc2bef7deae81c5c122d3bca3dbfbdc3ee5c5e3769613547579e1d8086dd5b775b392fb5e61d60502c410958ec5c31f6eff8be0603d0d2adf28fb68c9a834e0a51371c77b64bb6a06fa1264a3251f9cbfd0a594bd6930f7091edf7483f96af96d765929e779a37dba111ecf18d9bbd9282c137f3354ec280c14ab9116418e44b95a19cf7d75ee6403906192df303b719512e6775a2133c7274e9fd571495adbb918fb3fcca207e7b208e747f5f491da244fe035c046cd15338315f53c3d42855adf46049e933157796148ed8f1feb7d20200a6e18e7693bdf71a5e8fa17c151edb5fafc3090eee080936ce916df08b6cfffeb8fe127d62bc37f5802aab4ecc084dd27f24f64b321179a2519118ea378a6b962b37512553e45f9520d7a10d2588e04e1b7203c7641ca9d876e027370de46d626aaaaaabc5391eb763a512c18c8a8eb2daede8e93a65c1cec4f324ef72c7c1663ed925e4fb15911df3868c84f2081ddeaeed2ca5956493feac23f792391f14745586bcaacf19902c3097d81376574bdf3644c61e81e7de38f02b34b64dbe6eba89c5afd05430bf626020eb73a555393e7dd330c569f8dde681242bb894053853ee94b1f2b4667366dc37be0ba236f8849fe04777aab054e762bfa837a86798589b57476559e9e258083e64a9ee5f5a2875d97e0a96a72acaf2a504ad70072865cc2fd2492a4abe24449d8b0788696c9fadd2bf3dfad184bf6175d80f9b7f52d7e4f192ee6c4aeb27e7ab743dce46f5c503c5e3a1de405539839ba240c43d6c14d2832930d5d5c339f9fcd237ac528ebd157256e2e5f61c7af4898471a71ec06a7ea298c71c390c4a5397164d4c0184542fb112a33e19dec97001831b5b49119385d1bf3845006d57a8a4088b7f59fe42796c8cbb462074faf365c1a98e498905453534cac1ade0fccefacfad04b5343df16b4db8991a019558af0953845a2039d4aba3fcfff39cc46d348cb0dcc258776f3513276f759e111104475fabc761b420056013573b7b5023fbc5de70c84e32350d0df1da98fd707868527ca8f8bad4d948c0fa243c5c217a812e69d75f3f843b3fb23bc9ed111539a0c3cdc8d62954005f39e859dd3cf2c9737a326c46784e975adcc2610685156b664b6d4bd8161afdc1ab3a72f9a341907e98e5d91804e9a8948a97f0d30ecb666ca091b00bf76fc3b88a2a7a3d2c679d822ba64243ec76ba8fd4ded8df3e52e603923437eaae684288c3bb9f424b6d87ce80c144f0d8fc53c3964d52ed5690fab47a0b129dfcad6169225bad0d1676f98010063bddb9487fd2da5bfb1b35755bd913c07422b76bcadd526526861e5d2c41a63f7e8e73fe8a49e8f72343023a861a5622b8bfd808c030dcafcd07c3ed2045a35913b29da75fcd4572501523608414cc78538375300d348d21f6e849f3abc476cd8f13dfb04f0c297d15a12a029b72d894fe42111e27dc906b4d9a90db5925784f43f24a65389ec6e48c7cf3606d37b7f8847503a34b302c52afd8c652fde2ca8283bd4fbf2e832990066571a8b0d1774f7c429603c905dc49d2cb67362e1b15e9422cceaf3629229dc905de679703d4049e9211e69c0f797874923859cf918b053ef7880b2012a625911b84d2086ebfa16945a06e3f0b0d9d791018db4776871724aec9b0084c15d38c99b4496e0af4ef3e03dd280fd1eee2c3da9077bb1516fd7b4067a6f7113db8080c9b4657bd35748883a117fbf95935281f893cec7cf5e4760501cbb0f90799c963134e8a114c3107ee95b109c9d5bca35bad15cf1bb832dc3e43a2e6b3ae432800ee2a83b27f1061600af052e04a91b47d7a5132f0143a55572bdeaf7fdf6cab859a5b20f68bdacecfd237205e35656806374f06e1d8b211ca340bb805c2d3134979a43f18e0eca626feca5f99d54359aa6a09676eefc82a64821682081535c91875c9d5582d2cc7d89b7b03e6b36c08d631ad030f516a86e53e24e39afa2cb66057df3194f26ad91d0480312a25c73336cff7c6200ef7d0ff0a1057888e764a6f660e89380b936e426317c6654fc416776fd715fc11aab3d7a31b567491c095aa2db15bbdba9511969f93a8753e65a8aed50232c8a71deeb7650a7de44eced646fc8592a6248a3f3b82959fa85557c2436e729cf755f4efe7d7706ff2902fdf28a9f72276f8c15531d8565cd5afe87b6298f672589cf5faae2f89dcb41cf7d473de49abe90eca88b46ccefcd22c21b8a127c88bd11061949c870696fd997daa61ace0889f20de49177f0c080cf010ec50f5a52533d7efbb68f8545c4120a02de9fa2d3535a260aab9be9313894c5d2270ab2a305131ad4381c6333dbcbb5c7be833393478f1e2627a26cc82f39d638afac3d798112ea5a4baf599e555c041f8216bc158c1b67ceb9f945f5bce8ccd1bb999e3c0f2bc6ad17300d8d64f24224bfdd7a8bce3755fca2bbd9a94a9e1079e22f85b9b9e26077551c7db34bb2db836d3bc67226dea1627f8435dae4854693636298e978835a04d63d07fe379bc88f39a724a3aed82d5cffb5752680244eb541a89e3c6abafd1d8deb3ff810c3a665649175bd06313b1528cb85b2dbc499175b12d19c6008323b727b4977373f4b17ea89a931cc0e27d214bffd1bcdb845289842718be65a16ea7be4ecc8baf3639eb74c56351525b03e17d1ac2315a68943a6f6acb8a280c2ede612dacc5d9c5b8827981e6fe0ba33f67c9a7b016e796b93a55363bafbeba61b0d05c736228190fcfce2938251de277b6ba931f654dcc345ef10cac597dfbbe774166312ea17080f75b5338c3930f4a9527a68700f076beb17f578c8a2a2ae1bc3d70ae27b3081d33fcf748d783ed88bdfd1a73254099a84089905a2f40bb64fb10536a1ab6340e280efd1c0920eb25042271b4a7f3415bc8a8a7276e6e061cb86b128583c17e4f31044fd9507c82eeaccb744e5cccd17825dc6f217797be7be7a6bfdc807048c2f1e12324c8779ce89b380822b4b2bd5d569704a1a5e0011ec6b8e1e894563c49274d256669735d25806c59f3b3a87610230e39a32b5b6fd84fb9b2dc52f36db2f903ee5d16e67c4101d52dbe47dfd5ca057fd390d99416c5dea312ea5ecc247e3840e9250ce036d8322451a419133866c602ffb6c4ce8d1cf950ff7c9298e89f49b81b9d49c7663aebe7722fef96a5d7c349534f7a018079b6c336024f95366c11ecd7a05d37db6d6ee97bcab1fab1c64c6294117582fa45b5a3c663975410fb7eb94a79738f3d83aedcd3cd69b01b0f863e50582793a3b126207524190a23b50b83536206d05a0f4aa575ae8437be30a81600a8cf9cfe2f45bc0117077ba7a831afe256001ca1ca90809ffa481f03ab84b342831fcab353a7b519a9c5cb233784ee0155003d84d34c9bfd44a00e6cd4fd0661dd2e2e403d353ad4765fa7eb2746a4bfa857483ea84425e713bc573878460b75ee701907c32317ace459ed745d849fce34893c8cda35606463c82b7e3a7adf0aa8a5bb033f26442c8171f03b63b81722e700b4d70d7b14facdb11fbcee9e4903dfd1abf6b1806ab44ec5238517b9bcf4886383f2158accc37ff5bd5b735a49379d2080fee115d95f3dd5ce97abc204a3c040c3c535c6738962a6468bcfc9bd38bb0eeb83f55cd8a99d4532274d59ab43acd2ecd3dd2689e5d231638a9331bb8c88bc86310279ae47c07241e502fd592cc472dc04aff6f30794ec5b0fe5246c47040823af3a271202fbf51becac01f161f30ea1a6ea533bdc2188d497036127e80a610313bb191ffa90760673d27c096b93c059b11e040ea9255953553f21de2034d1bdbc099d154a333988f9820c1671913146a0e0aac4f031c0ecba420977adc8d0c0f755dd94fa16a979cecc97b7dc74cebf45d66902fa77fa866e2c99ed09596e1134972716577ad6405d302198a1c0d2f75f72abb1768893f41abc1e4853d6ffdcc362088f6a3c5cafbe75f744e914e33330c8a49bebc6dbbe1c92452f55b5a400402570fd200304b531751dee58c5418a391022d3689c26064fa1dd534792c17f8448821252cb3d85442e1d877d4ab4baf738e4884c1a51601f1c2cb376ef0f5d9cb4dae6c656efce16fe0fdffe43577aa8dec90bbba9989ea948a338a052bfd5e0c4a309acffb0a57f71ba7bea524696d1043b83d7065581e1c93fe5915956fb27c1b326367494332d47c97bdd05c0dffdf21d8eec66ac95512c6307cde43586ab76b5493d372c436b08b48c94bd778e7f5e771357ab2060cb89d81d3ff45f218e01965e6667e93c1687a6bbd1414e8dc32f7e518d854b5be4e670c3e307cab38fefaded49554a725e936d5daab4ed69772dd0e41bcfb73e211b520d6843601924aba352b42520c7b6767a8605ffc2fd00b0c816ca5441c3797032eedecf464c5741b20335e37a1e473dd2c348b41811098208ce447012c7f88eecf75c2649864343311c761460bdb75f9998a14712c58e3585523584470669bd3a8729fb2fb652a89427f303fbd0197970a523653d878fbb002e9a968c5fa9ffe40feca9d8077c98a62c7b2796ae5d7c49882b8be3dfc2500b45008e441f0abf873cef90feb98ae5f6834058eb79e0f636f01ecd6c3ae5a5444cf1e21d420a2a2796c1918afac734b9ab9a88731a3de7123417034c77cbf5c0ec741619f2095acdd0da6e30d84136678d23936e56e2304d2f2d6970c1d3a7d67ff68f6223addef8f89c357e4330baee279f40fbc6f6137303cc874c73490985a3f75d165ec499c8d8fda5fa8fd91d54f9f12f2ad6704b093480adf0358b627d18f8cd4b5da5d43659970b538208b9444efdf46da6d3b9ad8edbe377c20b8422e2592c29db74b4a3c3b9bd6a36adca6af7f3d4d22176c0a9eb52663b11ecfb82f48055674f83c77639d514347ac89b94f71cfb20a6ea4cce15a4bb9dce0ce2243116328927e82fced3db0e686bec66c8b891f3dc5bcbc6d356d52c5d85ba5d92b48da9cdcb2bafe3db3db53a53ef043b1a51ae078d88e702f6169f8f9cd9683ce8185a544891ea51e615940883cdcb8bd915d3b4568da612cfc2c078b7cb349c639f114c5c26f6ff8114f8a098e914d647b9b3a61e83cfa9489c8424ab51d833dd4cb48834ba0e0f128122c5de276027b3d4633439284b70de52719031ee2a04129ff8186d43cb0530ed80a4bce0ba3c11072eecc5fd9a2d0dee9eda7d1c0e6aeeeab5217440bb71f6375c456c6116d0c0b0ba518452666582484b4f57f975e467024de09aead58bb399918f8af54caa8735ca4dd4bea21cf673c69e1dbcd2ee4fe7bba02d30837d7f70114ba12c7e909768265b425ea240d6a458349f51312107610002c77ac7465eaa1215a917dd6f06a3aa0be0d7445cd1d2337957c154bf38972e85a29fe9ae2c3d84cf13a650d0d1b73016b51e413bc4edb35fc7832330889e083d9d5da6e8250d78a8f23aa8b7736c2b1281291433ade3e88413a712f771ab24b6b2e7d8cf843f878d807c45c67ba801c34e41a07d472a9e5dfc028415edac30841c6e77fff9b35c947883c1253ea28d553c942cc42f1ff91c2214b41f11bbc46347867bf00a61df64c770e5b8802690593f6b49f8aab937e4f4a092a2784c6da6b1bc8848fb6f7ddc99fbb8103a82f0a7cb3df7b3b342dbb10c6dcdd2ca4d9c1fa36f1e98286255621d2e6fdff4900176a44d06f84e8260e4450400c7165c5dd7c79ad934520a253845a1a093fdc8ac728952066a01112988fa52d0962c458e7f53fda5d104fc84da45a2633590868f5275413b04dcec8ba828eba64cad9f92f163be4b0ae15ce3ed1de2ab3b9e2452b4ae953bc0e591e2281184a948f7451e36966e1d81b8a349a6af387b3d7a12b765d1551bd161ec14c1a8dc272411c639bf075191083698656aee8e833ff4cf605a754130b9de55039509dae876700bd4ac674c3cbc3ac0722583feb81ef3847d19596338f5892eb32ed87ddcfbe22aa33ca2b76e3bebc7c20c3333530dfb69f3a2e46a1b43787c309af8f63f1f31202b70687a2f5bd77c9bde84ec130ec226999c2c5ed9e093255db7e81bba41b28588baaa8dd241a77969d652cdb4ed2838db130c34202f5450fcc0913d1226401c14bb1bc4886a50232fcf8d4e05b136f329dee34cbe529a19dfe17ec05cfea67c834e51946c9219743463d4deef6643650c393f43d08806472ad5a3ce3d97ea511826fe55118d669fc3c5e9cc1485a369127f7860aec6f85ee8e4d215d9ed2b56253b6fa9f13d777348608f7208105f97cad7bdc673700bcad459660113ff78e5edbf2fad39163f44040b8aec7ee559ac6d9e1f46c8992d5007e9c2936beb2acef770c7d1c60d6cca7a7f83d292246ab1dfc96b21553e362e2f2f33fa21940742d0572473d7f1f8b5f5530f465d0e025c522661252cefad9acc14df9c65dd1e116986a0d421bbff4e42c8da48d20705b54369e7164ba1c30e19faea7eee79d5d277e1c9946379cfdbcec75ee1249d5f0753ab59f1adee2052d071e3b24ffc33538bd3fa4a58f6b93095ebd293c3d47324cf8fa2207f0ac16423af1dde1e8df1c9e35ead6fc0af6f4d738b97bef8ac73d1b72e415f1caae04a8d18cc02be6f22d19707ab7cc173b648025dee3d15e4032bb1f1ee42164d58d271d776667fc71d360d0494d89dc7aaa000c80f5a15bab75916568151f319324dafec798819cfa63c57b21f2e2fd335796ea46a00d0490e545e4001a83f219d55f02e45c2a6204ddc04554efdb5103a60232fdcfb9e28da5939ad25e7baf7e2d1215bb89f664a9a359683976893237b562f6f540b8306bb86a285cedc7f5a54b586057b42cc6e9272ca250452a23c126cfa60ddfb881b064e37877301ad1037df3003e3a78eaa06219d405c388661ec2c0c0c36e487c93ad37d0ad8a2a06deb78e30dc327c512df8464c81322a2328d42c7723bc0aa5e787bd7c98f09e5de1218c4fff150d796f2875b0f8852f11cd7f100dba9c6a3b558f68c3fe6c00387653fdec38f5dae14dcb8c7adab7bcc87a89c015db6a6bb07d57dc3e19b51f31d6787f10a745fa4158c711b10270754499906a92e42dbe3da634991c4475978afe782ff83e1792b87d7c01cdbcb05d12fbef1b6f62181ced94c36def72e1120727044f097adf007063ded99c8fde1390c920ba6fa324b9be15c892be0dbba52ba8cb5dd7be33db11b18dd7786aaa5ceecff9aa200fb22ab8ab7e2a6e5e6909302bc12934ecda63ac9422dc470df36eb80c1da3f06940c3d36dd3844f3434f13ca1fb9f668e91ff030b43d185546b864cb1cc985c30e806bc4f4ea1cca4965d5ad7effa1a95cba3f66e518c71cb658f2394095e3fee4f0892de9906ca4d30c4142a63ac76d7cac6f5bb9e089751a3f2cf0c021018669c80fb9100584a90a58e7cecf676e20750011eab6702a1766ca18561c5546f82e53294fb35cc74bd79a51bb3aae77051411f7d58a209d6e98047cf57c931d076535eba4eb725d68da8304ab93764c6b410b6fbe3dea5740f6b976627b89790514c83838c55bc7dce09651fe9560584fde72c65472109ed6592540d1721e3d2f4b84b67435fca2f2f4196ddcff056ba4408e5cbaac428e5b7f2fdb6ee15bf1c4613cbd3eca523cbc145da6901a94500afd009dc1706d9c61a32a80bc9070f2305db21c469f8f048176a28ddcbe5636126644d232e054481c5e051b5a7dd7b88905f432e1ffd6e6131cf0950f076606c719dec99debf14e7f12fc5554fb12ae2170f09769b944e21610e4248aed1bc38a1b73b7c7fd8f66d378b8505e618103685af62517995e53aab12d67036fa43a05d8db3335778328e9438b0ac29784cccb048b44d86aef812de0f18d1ddc8f70b768670180b27396ebe7d31356925e532085cdad70b2b7586591c062f2d2bf6134c33c14358956c2673561aaaa55da1eb29fcc193448e2db468f00c5bcb2ef042dd936061a53b57f567a8d90152239129603732647f0510e2d05f2256a29258c4a34d1d633b94c32d906f75edaecade8e3938b81716d10505776a3853faadc783dec079b1bcc3b5a8dda0ea066101d027cb69dbe6a077edb966ba48c010494d8452e260e1c59fc3a5e76c136cf172522949f4b4af19c8b86582ccf465e030b4fa2eeb4cc65466dcff62609c33855e0f52b9f1c0f6f5a0bb982401cb33a5091fd6e5b42f74c83535d8dd7edc69f3c714d67b60af720530fd8ec06b4b7174baa18b122f563bba9bd7720c0ca932df26501f54a7659ca1b52914f9f19ea58d0f700d7f8099f8795b48f2baad2a7d126272621f0c42749447479dbeb363b055b9a14148ceaf526bde13fa8d001aedbb26e8680faa9b8cffb450ff8dcd3d28bc711c1ef5f347429e3d596fcccdbcbb38476443be24ad44306e75d611c0704e50e673442a3176255eaffa7d091524654a619204a76a49aef79486b23211a261ece227b11133548ae1c3d29b34d6a0c1b5ef9d202ee87f9c2cfa5babf2d9fefe68cce057c12f4ed3031a91dae407928320cfaf8cce4cbee3c98eaeac0c8d350be496c5fac65a73a6dbd88ea3004377322c38745a6af3ad5255bd5e3881b53f96b4fa3ad874da4ea70b4b62a29ff78da7f4439814c859baa3a905757f0b1301f7cfd20dab5a7bf31cea5adccef3e6d1d3fdfb1f3bb0ed7203ebe2c4c41607633d3939b24856d4bd3f880caa48c0f08413987c423b523a632e26af4546c0a31aaf06f7b3304cfcc5ee1e30eb59b08890e884ff4c6755761bce9e430625f517275a21b9180dde627212bcf343597a18a284584bbe1871f89368255489e632f2b5e6fc547e11e4df945b5f96a64b71fe938ce9998b4e3d8dab334ebb5c01465ea8cae1715c922130d5201bf423147016c0a09e3cd67611100dec79f683d13315dd7e8a779210fd4cb300aa21cc48b678c65cbd21963c0ac00901867b63ca5defcd2f52921f4ccfd680876ebbb8706e5a69e22ec255d95ad5e5517a4bca58ac7b8c316eca3c19ef6e0744ba185848d20a8e39d98dc1ccab7e524eafccc2224a37573d8cf03f9200d7c4ae8e852100bb04c0b9acd0c9f80bd325e27dea7b16be6e4d84254a15170ebaccbbd455a055a0e7b02ebae99b9f8ab48fda2fabf70cc55870a5f1b477a534849b7929181982b3f1caede0e9cc42070f5b2f205410d0360add3f253b4ed3ff21d7f9d4f634947aac9acab4fd870d719bdb138c6eba25fbb2376884d472b6acda79cdb32c5c3b7cab1dc2bf440f87c8508bd7c73e9536087648390dcd82a08a9d125a30d9989fb26c513efb5043b27dda461ceb56ada9900d6c2c2d69d5782ff3b7bc9e9fe2ae0ab5e9205e83e8b4007c9d8a54d928b461c64bde08c093e5ce3ba7103fb8736d2887119933056629908cfe937ffe92eea2902a10f7a49fe4687aafc564f8545fdb1201769d4d25f99358ff3555a74680ad81b52ed3ee2ac1a2a6592d9189990d7989ecfb1d456e5b4743ba41972022e99aa68e64a76d1385944cfcda636a417f9d161dea08f3ade8d360bae81b8446b3a76459caa07fcbaa15e7d8296284c7d28bf629d09a84fbcfd6c2e47fd2e016b37989dfbc11e2b92cb2165263570c84d8ca6442ee60965b94c2e105dfe105e2ade35f1bd1e64e5419dc9fd2bf17874f1d3abd85c48453bdf405b61709762f62104f3aee5cfe78854973f82a16ea73efcec14e61bba59e43e896113de6c074f5d1cfdcb9173d89ae543bb5daf8e108e97d29e178bdaca3e482789719151e129b2ef13f85dfbe68db816d276f51a64b4981206c816f47403536cd576e07eed352e90d4d11f35438259cbd269154a0b1756e3c87013b021a11f5f17edbd618c046f9e40b25bad24e671d6afecd13e273215c05adb37da26c010f3cc5200c8c16be5099ad1b95ddfb2a4a4af948630d718fa74d9aca83257921f5cd14ab2139eae466cd3e99d26685c847863270e69d87ce1386af3a006344c6b435744226e0890026e91b41b9616348a0c242e749f3ed4a2c2aba26e201ea9c9d4bcf895f2924febf17a94a5df571f3e46e68dba4f03698d709fa0813504f715c3af606ff6a3a27ebe9199a9984c62cbae392b615840c5c616e2962c51b2853e3a9896d9a3acabd7efed4052f9552d2e8fe7f5bb2b5ff80b346e2140b08ba810d7f814684fadb036464173a9908e8452b1bfe6549a7fe188d15a529ed18c4095cbe74a2dd794fb9fd48c129f844ba8af6dbec313e8088e4e2235ff43fa6d07d9bcaef97b8b3c4e77f1a9bbd3daab03d2597e51def70229ed43f1d09692a39e03a5a5f4bfc163c82fc654d1173f285932995a070675814763dc32b963a2027d66bde196b53b18e8409ec9eccbdafb586ba1fa71a0cb9231b5b57c12ac6f0448ea99b899221d505340a109a12bcd8399d7d4f63dba074569dcca01af8134f2396b0e7fc0094f400eb9e9fdc6dc96e2dda7cb30bdb127ac3d163b676fec2f304fc5e9800db1146d0cebb640aacbbf481f6f04844d4c3b5bfd0bf4a0cae3baa5e3684b930164eb3e91bb536b800c4d2c5d825fd04219381ca95a06efafd9fc8250e1124c7503954dd33655f1789ef53191dc43c5f5a8237135af4f86fd33d05acc92f963b92d08e6c743b02574d026522aa560bda1fd23e8c344b5869b6be5c2daf8d587b6afed9367553b8a47fae5713da646ff04bfe203d3493c4e26382d7010e640e038483143eda1bfe78300bcb590c64718cf0401b32bf50174613dcbe602a4278db3f88b524ef6642a86801e2770d14b23bb09e71d931ce27b5d3eeffb4c9706f472fef457ab6689d4b0f909463e043a998c46109054697432d15c4744bd9e58d64d32712a8e8b1ede6a09e581b8c6e5ef12238b3674874ad46f01415687af939e468b114c4a883ba39d16c8f12357516bde7ff96c6aecb3363b054a2658e942aba7b3045d51d5dfc7e4302980d21e00973f4916f23170f51663e9b51f8fcd82fbbcc3e6970ee76273641de69615fd8a483ccc2b03d9b54d011268d18c573e54250aa8cdb0f1367cf6e0628cc801fb237cd5778b09317f944136207f10d0037177d0133b6e3130d606090be2ea6e0d8523818c029d5e539570f523b176e5d0625422a41397686d1d0983b7e5f4820a832913b0c40f8c2e5ff5d72c546bb507d93b196f825957ddfa17fd44570363f135ad97227b36095caade0c8db49a00665413bb4a29b1ff52c7c91da352f993f644b7d6b14b74ff171a3aebca95999363178784bdfbfe306713a8120111eeb29b6ee5deaaf53979f2ecc7d928fab49687d8e97ced343d17e10f1a96d2bb29cf8a8387f7a0caec1424ba7145a4a030459ce31be3822a51d78baae5b49ef74924ac4fd3591b1fc361ee2dd581aa666049996486d7181b3406111085685d0d5397275ebb6fc19119f9f28571983158a30d5f6e8d501db6ddb52d0d84d057d585ba53d37b68e243152a2d0b34b9f56b2cc100ca879ec49d9a86f86bf5c02d4979409c16eb0d675c2bcacb0f0713d4546475187d7db10a4cce874418af8bc3c25d78d21f5a908ce93dfe327e180ca04ec390e531dbf7d6e06d9fa17e797abc9bf46f9da32153856e5049057fcc7d316d295ac0224109c3e763a1c94705dbf080ebe539c045748875f21502c0aae81ce76eb514fe57482afb42d8c043ff69e41947a9976a2212069d7d1202ead20d03361d9da0d8b5e65e82dec3f0972ed2b54e7a6b12a3f1bd706147cf05dfc19cf0133ba1981cee523f6d1cc77f25df473cc24a262d4155946f80f5a26ade22e8de59327ea46e2a6ddfbb02fabfe0b409bfbbe5907ef91ffd2c3b4a59267305baa744d0003240376af3ef95682aa0fc6f811b99dc23053936753d663cb8452f01877464293897e0b8dde23415ac723d7d2f77d4aef7291809b9f96a1e5e627432c1f845888edbd2051412b2537f3e6e82af9a0024081418048e94fc73392bc95b43edb98c1f0e9d95a9999a35793674abf4969facaa9e343495f09769d7cbbc80cdf3fc5a8470e543054c18a08f0d50108a7fe0453622f72cf6dd7bf3b796d82843452559afd3ecc7e373a74539596efbcc71aa05bbda46b859322f220db8c51c585312487881791c4ed4a78de7ce1128983a9f19ce1f905e166c462f5f6f487571a929ffb2a6962eed2d15cc07f55f5343e317597923ba339fd3395e6175b4144c17d616eca65633756cf936c2d1670a5386559f75549b34f0a72ef5479280b79d8161d4ca2631d148799f5100d3b5ace739b06cb6f39bedb353740acb4b419bbca92f595eb56189fd5520e56ec47169b829cb9781d11a70d86290706b4b66a3ac9e6d04ae2d12911d5b6874b1c85c0026807e5f76196864385a7f922fe65538dd1f598c6b1e6add4570a3dfccda4c7fe7fac5430d0a9f2fe64771bddeedc81d303a64e7143f37a946c6442bfd5dcdd94879173db54c4aa3c1e854307cdc25731736642341a12ddd47d1d1f7606b3e97b4c040bf0a67692ed2ea8f3613e582b7a863ffe625c672431551acbb419eef2a7f97179ca99a28bf0f3e3adfdd","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
