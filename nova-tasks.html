<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d1a58768b008e2ec90e604f25cd50ad4223a0c16c440757d3599ef36a30829750d458df7dbb89f42e615cfa6bd762ee1ebee91351c630ec522fda4b7ffaebb6062155d2ac2db8ce9e19f7cb72d12aad7b94d1d350df134271bf93efccc781511f1086950fbcb3cefe1a219048d0d2283beaa0a0f785965e4442ecece9bdf73329487e328570782693f1111670560d41182edecb43627c4ae546397e3903db5ec8e75fa9b88b3673abc6347446d6331da31cd389042198faf419922bed58df2096556e1270ef9410f1ec63a979285eab17ed863d2c5cb9673ed42dd2ad806a480290d7842ec80408e7c291098724ac8cea8a21b6334aad3ddb959654fd41ea9b63180a5c224571f0cbbe25668016216b27b09c39386ba35eed74281afe9193d074dbcad1f56715e5b690acbe8cf7f1d942b2f83b295165a4a83158d8479d8d472669e0ce3c44acf473e820c228f8dd8f51c7560dd965cf3da326a6256e4597100a191a20421832f908bc37282ecd8d261ff08fc6378d23e7d7fbbf01937572978ba34a4dce74a6d489194f5ea42e0d5c5d9051bbff8f4fafd51230b173ea73233c0cb243829e0e578571e9c2f93f889878b279301eb4e422b9aaed65a516a1f52ce3659079c45b6135d19db4c421ee3a64c3607fca72c7011acd787003e89536f60f21ddeb4193ec3890b2188b0ef2e69b806ec5ef406a6c6c73ef5537141606cb358e911ebc72417050ccb7e9d6f7975198a3aaf022bed608b5ceb4ad3d77c35cf9095cd9af960922c6d242811e7f378daa438162d3672ec7ac30cded06e0addeecf2dd5a3b67f001c686d8a8525f3cff9e46972460ba271aa61647a252723ae0522f9cf2c60ec6ee7064d5c3fa33b8a977ea7d8c690e59c2d56fab2ab85e9544060b0a1c6d1608cf9becbaa994e31cbe6c968bdbcd79825cb89061b1076c4e87a18ea087e18ce00f6872e6c2ee56c3f6eaf08616696a89b630f1e88030b04bc8e59780a55ea6391f33137d1f174cba425b628b49bd4b570b2718de492f0f82332960e169d03c817e6abe9c4cc4cd96320dfc6b12960a689f69131cce930d4c157b29ee0d87b21785922bb57b92528c1ec06f404550ce78139fb9f54d47bf7d618f05509f126808648fe2d779aaaf847a50d14ef0888be54093f680acd66bdd1a0461c4691198e86ad6271c59c7e59f68826bfc138a1b4c1d9ac9032782b4268c7c43c0fbfd25ddf80bc5cda59cfc8072c86a8ebf26fa91caf8596f5a50fdf28056a1d0848526dcf31638c24431ecd4c0854828278e64b9db87e8dbb82bfa80a2efd88f5cba0bb4830d475cc88bb73ab1039bade8c443173646b1f05e07a17c745029111cbb8746534c6d0edd0cfdfa963215487f25a433906f97d6a3fc4bd1cedba361d9da17ea0757eab6307679d57a3ccc2a8af7c2bddceeeb938df48fca71dc31a74338d19064487572c4f8132ea8c39ab52f86d27525ab15d63ab85153b151f3be0c58161c02061887b7b04816bb479f5ec059ac2c167b83c5a0b45dc5f910b296a84a7fac375ff5a24925644013cf92c218f3c03e926610e4340e96cd80e3e73d5bef8fc3ad2a349f370877c020b4f470ff0dad1dad9e6827a872ee07467bae0d1a7065eb07cfe3bd68be34953fdb457b387124d301bb29023e39c446d4b0991c19f22cf1b1422f8261ba2d18c5d754af2dc980374112ab8cd2e499c117c581b2df2ca2f2102ecccefbf9438eb5a61028ba2903ee1690f61a287f5bc85d737a80708059c572b7bbd95575d712eb8715cfac4084f47617e9b88273d2676f0c1f0b414564c18a26e5f05fc558df63048a7a62a52dae964af382fcb48e6ac642af33f7a858cbe76bc4a4053a3067e163f2b7e111cc2afb409e4fc8a234fb6e1a35175df8454e8e97d26d760de15e705bb90b80ef5ab106e048ddc09767df0eab849214302c5616252aaccaf9f9e6c9a9ea5fce826c4c14d812dc017ec5567ccaaf05ada53854eceb7fe47e52f450044bd68877a2b73a80e8993a80256dbde24404b6f74ed7b11a9270ecef421b5d014616d225b1c681420ab7f00706a8af3db92300556457fde6da2db5f648e67e70efbcd09670bac663173d65e6a8077e88c03dfb4d450e06fc9a7aac7d6c4fcc6e4b78eda718d555d1e64587354704b2787cb2166d9d455e3e139ceae271a5dbed6d9028134da504a3bda0e1bf0efac8b2037df235e2bfc107933e4ad38375c7cc45ff953e370dc40fc8d9cf6dd40e007f79d608f3cbf9c2dafd91b20b258a63059f545876a33157a28a4e1ed8f07ddebd8d28b7886f628d01c5fd6e180a6a40f8ca894f9525e787a0cd7e2f473d10c1df97da99d33a0c14fd15c5866c9c14431d926d221ecb559462330ad4313364d59b0458c2ac3db5b6b240555d89a2e826db1484385c9ce381cbeb93ee8ff44ed7e9b885a296350659ba37dfd8a74b94469fbe10afdd812a486140d9187e67a9c5c9085edf38ab7787a9e310b1b00f1a261a6db6161d212c830dc5d486bd99dfc1c05f48bb7ba3813a08dccacb3d9054104ac71968702961f3e02c09c0e07a5d1bfbcb27615a77f07cf5ded725b386e1cb1374cbf34b9eace724581eca842247074bedf9ba87d159f45e8b41bd1d8ddeec9d418d558a08394f7b1dcd2c594ba6f667ec6e36eb017724adb4c03c6b837cebe961d3431ea9544933124a8972094fd7f2c41f964748f6cd5d3661b4fc4ddbecf35221d097af2fba9ed4bebc59d379844a0d8acb492094958c8c121778df912f69ff91723ccea0b29ea04c91dd504962921a4a5ed7111f07a23f5aa38afe52ac7aab481a0641858c3938731cfcb5581f5ed88b7e214dc24e7fc299e4021353a7b08c0dec6663d673285b77a0bc044ee261de2885b7065b0b95e639579222ed2da4e783429c201d227630b6af41540921295b1505f985725f6532e10df15c9e6845cc1abaeed168f9871a7e8180f8a0c0b4d4abd81c8f42fa1322ce22f04615e57253a0c0053f1c171abffc97a2119c67b67fade006d3f51b5dc012abc0d264ed0cdaa4a2b9190efa459cc3d74cd6ffbabf35deee0213e6f2aad0bebec6f4deccfaf7bfb64d6b1ac110550a7c400f7404860fe50497bf7bb2aaef9175d954ac3ca79167e66997c573bbe9fb407f5697de74e2e2e93cd107b401a03fe1561302886c874d008714c3e11190a008fae91f2dcde624148280801515880e9cac158f9ca3819bcebf4492b386f57181483faf592bafed1a68ad45c1a847ff0d7c2ba5c22f5b0d0f49dfcef733d83aa756c4d8173a557a766328d85b11680333e61278e2fdb7912043919c41559fbc15d3b0c25eb2091610da512f3e249434830dfe5da39b69bcd4117dc2ad2bfcb5e2fdf0fd1d21d63207c7f1843cbf8243f7f2c4a52eacfa6ba376b9a7fd1e8bf99258f55c8d81a8a988e265f39b7d90497f507b1fbb128446d153e6d0c3ad414b4cc4447daa600a19f4b8359a0143604751fd27ecba91fe2f5699b4aa2db5cab11088512d7d92bdd813821fa39de26c9d6dae1c9c2d132ddf1b66eea92936dd0046fa670804b50a8ce31324f4b9c75c7a495f10272733f924707d8f4d629f36d2d46a3fb3129ee7a9692734e65c2661d9c52a6fc6abe55e88521f4095d0b731b7cf138b848565072629ba05664890df199ba6b43187bb30208a4159c35966889f79af8e2475dc6bdf7fb0cdb264fb40bb99ffa3cd990a1017654171a2fe1630272e4f0f880c5c0446344656b0d1c243442ea58b5bf7cfd502a3618b34d14d626c298e0c1991e2c9582e0c8f0aa5bc095a91d33c6f1c16f1a6d85117d923dc7d4699972e39f2e9bc8cdf20324fadcff1a85948505a49c9f885915799fac1c70c211e3532d42fb562ef79348cbd9cb07ac3c7f73acbb9fa8dc878f5d02321a0adc18e089831b5ab5086edce2eb5e67ba0c27bb93b04c55b12e7dd1808b9dc20a1c0245f9b6b074e83f827e8faebf1d7fb43ce97ff738edb7fabcfe7761348c2aece5e729dc53edb036f6b6563e756080679d6fea00bd6996615e8ef04ab45777ede798a2ff65ee8b3f2dcb3bb3c63fa9ad04c5112302eb65e1feaf43fd641ee352567801745b164d11268dd3937474d1ceb852c98a78dbad2dce8ba926fc95962c9bc48b4adb5bcf7d961a07b8b4034ebd607b81e35639a53389444adc04f707d97c32a22dc2ad8a8af3f5a5294a4100256caa05dbbbce8e6e259582da216642f7c5eb67d8bf616adfe152b0d7b645ee57010027e461077681847be7abe2bd52e62abd23115a471f30dd793c44f8a64c6f0f068c3f34631e69c4ab2e4f97aa3df980c27a46315a9ff5da7760a2f355b3e5595e175ae27901dbd320f90b729d47de666e33e712dcecce4194a1a15cd2940f146918d310c6fb5ac17851d1bbd0e5f30fc441b560e330f068c6437d2107eec6a4f87c32e3ab669ece4393c4ea84515550463b1bc1f3c2c889798f503b23e303c41442d8e4192928e8602da7d676fe08b050c256210d35328f663e8a1dcb5bc92281e709c0e5dd2ff9bf58833de4158c1bdbd19e6481462c9a4c2f3851045784311b90e09e09e96b61af6844ff489e9dc26c9fc46fbbab73015ca5784de406f9087ec4982f3f27f4aee38058421251852deffa5f92d3a5041e325460b28db02b01cee6b54ed98368a7dfab9ee1562d633b308f05d59a2218e5a36b7bbc72118760cda111acef7578adc8c9309113c8993df81a1b39fc3b7a6c99fbf8a25f0fe81e6c71d02b0ba9ac1e644738206c5fd138566917e7a87eacd6a3228d1609f4124c4c7a0b70f1622b378df5fc898959b72cbf3acc1fc820f6ce54f887ebe276f02fcda4bf85adffd3f76c78de6044adfaf75e835701f0a377222e52b0c8381aed84ee00ec5d270113ccb517b99a9453c1b8c92f40b08cc6649ba91ad4f65df36abf1fa25ef9937999461be00a52e122d5b5d17fb402b8f299d89f5fee37152957ea6f873b7b06cc69204ce2733aa8c1467adbf7b98cc503767dd5e4852a849fcb7327ca326144885004deaf1b13f7d3617162678915406c30c1063f1fe7ae091b39fce6341862f3160402d8b322c4d003acf6e2aae759f3001eb9ae4b426c75a117dc732af7fe810d4c936691aab9b26f6b0fd31ec66e396557bba5689cea26cf067584f66ff48156e1dd08e21838b32a6c4c9732064f779cbaf4c69828c0c00bdaa5d950853ea1d39f7f2fdb00a90ee664e5e825b6ab5ed402cd7e2266116be9ee1847c8fa9cacfc4e277ad28f4b2fd41fe9791d8b1445975f5ae4aca2ac25fb64aa919cf018c922a20637640dc2d9c8ee4ef6b3863b54b1a1bebc0eeabd192b0006e1afeb2904ce2a261267c5f132fc90bf07d2b0df41d4fb4c9ba665e5c789bd552bf22a7971eb2f9da2ad412f1f8e3cf1252d401b6997802c8bdbb4c2486c655535a52c265cefeecaddc522c8566fa23d5227076b207653ce1f99eaeab87dbd366bb15ae5216acc8d1844f89e3b1f138420bbc3af0e2f3fc8cd283e69862524078f997a1211782997eec99e8ce207fcc92edc97520076c94566604f4efa4b9815cbb6689a569f1d87d407bf97dd0325f86694bc9e1ca6006b0523a6c47c7b4f3d35d66209438b7a6fac842952266d015f8384077769f94920f8464a8ab8ba6ae4eea510e22f631722be2c4a77a5622ca1ac2c7987aeb59657b514dee6c6bb928620da66ad2d6aa11bbdb8c8abfe61df64aadaea137081484db3ffa037827d2bcb2627a1cd2870f5d2bd86539929bd8e18cba58f7776eefc961c8566e22d3668d294cc592e9d620a3a123d300d025c529b831b8625128292a439889ee97b851bace46bd7db7a7c88a02b68244eb18fdddfe40ad934dd5cd66b459843f79b5c4867dfd0925bc78bcda95efa452305b2b29ced14fe0189e3961e0e1e031b1a19d24acc68c49b43b618a5a48a79d09fcb3598597a62f51b5ba7844a4ee8dc05dc9b5adb9ead0e45db9343f088c61b609f6892b815b747dc79ab0792a88edaf392b08438384c779ddd38ad54511dc2475d3a882ee9af21fe75f3670c69d32fe4ec8946062a9c3e71c9f808325f8d33c5b87f00bd479ecb8bba28d3bcd3669faffb0a646390c4a856ce2dfcb2e50d3b0d807aeecb7ca88a21a74f5fe97a6702eb034ccd0532e4d0676c27379aa8b3343e2ad0ea4e46d0fa77d180b17df1584152b2fa82a6f411b16905bfa1974e17db8d1e157eaab617e38ab69786cca9392b673bbfed1c55cad3c7a88e62991da4fd713b105bf997b9046498df61a374164ea803d78f723496d7ad3fda0a0b186e8f8c9309301ba2590f4a9e3762dbb04a81c25ca9fc0cb38dba51c2a32e7c20d5626a029c458d09ca1cab3f99b78ece195ab3d55fdb5ca16e46b6075bc33bebdebe3c1c4fc66b8ca6dba137723a28c288424962650083a9b0b389a1acb7a5e1d45a2c940b538ea50a60f2e83a1cdaaf5a0967e1f643435fd8e27ed3798be321dfd849b7a77e976b8053ff0b2756da9a0f2e0acfd614288e8c58a1775ce1c1405eb652eeacf4ea38c784ad4b5c0d73c7546aeabcdd06c809e31b6b775a6f1d4613ff7a4e1e6b7922c257d8c840c22ebd76d6ede56bc302269edc2f735d10257547a87f6ee39abec062e2d75d4ea80070c3c64425b7fcbc04d199e5070f10330ebde45bb4ff7ebc5448b92ef2d0398f2a4a261208cffb01343fe0ef9f0c9f9fcbeaabb6cedeb5cdef963ba84c21ac601878b9106d276e6f2bb3a72af3394e1713fbce300d3278915f068a679b20c75a2730e1f8a77f2f7cb4f00876aecc19a9eddb809ccc78e3b231b0b07031749119f502c138dc5eda66e5975a6066dafbadcadcce69fa80705f1327207c86b054ae21f5326b23929e43a946cb7868e35926e96b19ca13e3296e09438e44d9735f7fbcdd1c6410d8c23c3e19ad03b40cc5774fd5738af92d3556e6d9e72328af5c4006e0f3d4b8605476f9e1f66896aecf11afbd41ac217685e921c73d106f69df2641ec9c1da252471f440d0dda067a409e7b0127851a91bcf8741a39f3470b3ed9753743b973273224742ec2f18eed5d953028996b5f86e33de8a274564267a0e4d234b90273f61fa5711724e53104dad8e67891f2bfaa4350e6c3101e468d812588e770a107b050ab5875cf70b39e392d21f81b41d1093e905113db4b48c0ba5295835c9536c635270b4c3256fe3a064fa74a047cc8d45a25dfa39f5594f87eb8ccab3e9c02f3c756fdb3cff4afb4ca7a427bece2c4ab8ffa4ceb40c9072538e340cfee45171789deef10b2d7ae2cedb7c382af2936d4bf20a5823a2157624e52bc64008ac91c4a1eb383c8148c56e31dd0331b805deb2c8eb9383ef7a1880b8fda8ed0e1934ce55683dc545c132e75e44598df6561005ce369a5ce48886f667f81f0bd1ed1a53927636a0c3ea7e6b8e2d07dbb232890d0499576771dcaeb1ec7a64c46a1d95a37472768bf43bb39365f652e42729fb50106902bd79594b3206b3d13c9879a3bbcba924c70593fd54943adc489f1b06f35f996fb229ce8d61d9fb18237df1828f572896c63b6af10961e5930abc031dcaded4eeb7ec1768b170c370f11b77cb7492113da46e39c7cc22443f4994c74895e731ff62b8560f2910d6c2bfa0e1855eee4d16dc6c4f9859ceb54679521a4abc952912cdb78745185eb9bb25c4aa7882b64eab87399bc9bf69fb92fef0a5abac39e932c72eb7c691ff64ba010468729efa64f1409a480e13d719cf230345946d9870f963a0600efed32de326143cf765611f3c2f88b251deeb09956a6c21c933032720726d173495f4c44266299137808b1f3527d8bc46fd98702c8727c3648af1d07b915fdecdaa00f816feb38c1ec4fbc8b9ade0a63ad288e51c058b5ab25bb0a2508975429590cdb8dc8f238ae5aff7a76377b132fd2c8332d64e132c5cd1f8fd05f92732ab6dc8615f6f09334e21683439fd58872ad48e837c3997810dbdfde4f1a2f05c15b2652681b5b52f6b853176a0391fa7df8248a0e58932556d46f8ceda52ab72dd5186234bc3deddf4264370bfe754dfaa8974dab3dbf3c5a3451211805ceb7e6c08d4994c991735b10402b77e607d2e0dc41d2e46dd37c225ca033f9b76ad2dbefaed86d139d6ff92cd4a417b2a23d3b63fc89c562573139fbcbf3bac37a9c4818a3b5a7b5a1ba7ec9ca98ee5a3995e774a5743cb44c1f69087c1f62e84fc1b00f52127dbc4f201aea1d5fe20eb9090bda88cd05328249ddd4c386dd921c530dec90e8ef64b4299bf68c2984aff4107c412dd3bb4e9a70f45341bc1fc5efeec4ea508f1f1e8dd7e3956af3104aa0f21a739ab037fd4ebae5ae2b72b5123f9893e9fc969439ae026bd7ca496ad2031dcd9e3befcfcab9b510d8eaf85bfa56460b0add3d83c519a443017cf17c99b9f471f1473501a584a2e666217bc0ee45ea579fa4960035ecdd9ff9331276a07207c1f08d3195db9192b57bc845f17a6df740785e8f089d08ac439c2919f3ac6c6d392a1e46a1e6602d12fea5b824019d3c00e12896b1177dbd79696e581779bb18ad1c681be5a73a300ec8a61f2e787bb53c0bb29101caa372ef2ac5b2a289e0ddc0318c24234fb9d5a2324b22c49f421097488ebbeb2aad1be1e49538d5dcace2569d4465e600a24c6ab7d5fd57d3c12da807102cfeb115e0bde1254a0e1b3b23379dae047add30d2fe5318492d5c359e7fa1a69ff2671614f5bcf943192befba9d7cde4f2a968f3d782936588087a078c905961e5b5dca1d541cb1fc9fda958b5eb202b9ad9f714197543045609d5ab18aecadebafb9b80f1910682fe38001c37a916688558ae89dde5bba7d3a5d5329d18dfadc81628e329df093d9eafab02b1c601c1cb9ea0622f3da65ea4dda7691496f513a63c5e9d8543d8de375ae338c3bc653c333d54ad655af8815908000beaa6b506c9a4cc411b4e9a6fe53214b9d432faddbc410f45b07e7f080fdbbe5a0bf6413d169397745330f5f4736c99d705ef6858a499cdd82552b276e62fdec0706044ea52586bb83ec3d576bd55bb070cba0217077d7e9c2e5024d45401890d0c2778b24d63a17bbab3d4bdda8859509a57cd2e0173b8183614e125de6ddf69fdcae13d0173b02ed15c942bd1dce448baa1fd6332b6e0670eb5333e1dba80ba7f8146f45ecf55f1c395b289544be9e8def3850d57cf466f5a6823b43b04bc141c1273a7b4e3571a98fd34df366a571c880e18dc970aa8392021d70e89bda73b43648c8b55d9928e0d51b8e41ab0ac5741a638bf40420468005c196da87e1e70624e27136ed309b5c1cad533ed02dc1d1e1d895fc9ecf60037a8993751136a4b2a33fb09ebc407544ef63f654816f230ef7960bdc62864cf6ca38696f5e97d0db2b98a6f33c8e9acd4226d408f3f45c9b83b1031d001b2b95fa631d0d06c10869908b95e82578562b4742eba846b9f03fe5ca2b4cc98c0655d63cd3afef04c29f57759585eededd7a06dbe791dadf422e6f7696f830770934835b3db7f900100dc2d1de2195430ee28db9e4af3cf3516d4e09bf443ecbfe615461773e2d1be85d43b906ba2e09a9f3a878b758f4eb2117e95bc6f3e4f2fe6ddf3e88a3fa3f1a3994b295cbfeb9fc63856e2105cda0ef4ce3b35bff2a640bf0c42ef145f5130e4316852b613807bec33a19c6a65967ac8a412643777e82deaaf04ec815e28a726ae6599b944bb21deb172874478656d1450e0d9f340eb002bb48233eddb970e03fecb441d0f8431f2292daf3376c7933efa77caffcc3b794d80d77f7fb1ee7a54f4d19e651f58e546098aa4e21a7a9af6524f74704a565ec6b94220868859649a0ce8d6af95e8ef33d4469a6cb4ee956fbc3efe48a97bfcf67879f10952d8834f3de6877bf5a9b0783a4fb8b9035ac8ef5b9a53241351f27f5c98f8303c1e2775739b0cc50c3cf1facbfb1b344b6680119236d54754c095b37429c72aaffa9764f589d14ec215ad9a9292be14b2ad653d34d90137d0bb1d63049563225395749ffced46387c59dba1a0ac33775709f22be342069d23c7a3dcba9c45fc56a7e2984a8e33bc3c388e0fb8781a908e5b7e2dd07b980b99d84c55ddcaabf5dbd25856d05c14cb6d965764106edd0698ed423b8e3d44911440d3876f42c0206559dea13f309fcb6989d304ca42bd8b77b077db0bd2d447d39ac7a7d04f7ca45e8abe97b8981a2046bb5a9026e9d7adec4a7b2fdebb4b035663a85848ffd18c7eee188d2a65426781abf3088c6b13d85e82d97a61436c3935da451ab7f4e1ab602e850e6b86c70c328f929f479faf625d5df9df864faaaafa5ee2b2e5c3ba07074912c9343fe6077b14c2edb47fa48d6f10d8263d8bd4194279ae1900fb453c5279d94f5818ac951e09f8e29d3b4c3a18f8e8d75508c64ec720aa6d3aac84ef1124d7131698d3938abe0297c3794372cb2707cc1ce135361bb3546ef52c4dada857a1ab761bc118a63b171676bca9035bb4e00eb026ce4b8de1dbc86f29cb464221b6bc972450761b778de454b8c58b0bfdfe8983083a0d59eaf016537b187a7076098034d88a496af7accb799c43c644fb88770facc7cf170c40713bf832306a66c69520e4e0099fcb7617ecc3ac0ca35f6a2f0d430a56f84cce1adb4aa85233dbae6e5a1e71ff5e929f5c4ed9a02d066db4481bfe6ef41b070a5d3a52b934a291a8e1a42c180f756593d7975d85282d80b796554e8dfe1bb051e25b11dab8ccf308adcdce5458a302279591ebbcbaa0736e980d94af202e030cb25515444c859cba9bcee9c39cdfdefa986ea04385c14382579e38d5d611c5b0fb422d5e50163128214e7950431cf1d763d3436f5d3fda5b5989fef9e2813865e577a5cb76a830c4812fb2ebae3bec7da43b5460dbf938a8e9ba27cfeb0fd4e27332ac6d6091792f469682a26db74653dbbd0e2ffa8107fb3ec4bfb30a6ce673d7abd7d623f211073e88ae7ebd9b3bf7e1497c7455be6b1622e7f2707eb66ae709df8025e6828cb8313eb39513cfe07ca016d6051f15249e6d368be0aeace16620a339e97453f9efcf3f930a8ee9648675d01c0bc9d1d67bc8d55b820165834b5556eade7c7feaeb925f9355e3cf24b037f039c115a54bf21457513b726c59af41bb46179f50f44407d36525576fe592b247a71560989d3a5982d885ebe503ab035f11c50295e1926f8cc460a1dbf67983bc208f5a3a300228b987c33098818aaf582972208bdc11d199508f7241b4796d52b54d5d217f3222a3ebdc9e72e732863d554f24bad7a7838ee8f8290db3d2f7cbd08c7aa17a4740a38b93931179d196efc8785dc5496809386319f5955d41bf7b38b8fcda611e986d02bf776ff6cddcbf7c63744b4d20140fdefea9d6cbbdce0361721262116facd5d652e2a3849aee65355d1116deee6cc047bfda36976fa2b26c2211c1bef18f9d7ce3d98824cd9801d0c43facdb63f958be3319ad0063d311b07168e71a681c77f47f64fef99dfbdda0399eb72932d05a89af7b4401f7b2a7eca9951f0a76d91cc1507f7c000feb09032aa10da0187d9a6a0516488ea7d3428475f862f816256a7b3c122f8d2c1b6676c6290404d34cfdf8c5e5a8582481854f8f2fdd5f7ee23fe06ceedad8c902619bcb12a222a3119b3ee71934ef65e1b3de8d4150efaf73c2f1fbd05fece7ec4593cf9ba18a7afdbf9a8d92ba22b8431591708e78d4750015edb36828b6cccd1add4ca24e2c7ec75b72c1d19e5a9d3d77ac8320235f821bdda8cbea9019c1d6585be0448c498dae4d5e7f86b42335f59b3893f72a06607bc4ace4feab70f7c418eeeaf237f2cb672bbd0d39fffa59849dbc4d04732e13d692d00db2cb8a3a33fd1c56064374b083f77aa5f763daf03ec92beedf64ab6c3da8af3a4e4c869d4f54302b11d157e339524f1a98afd59f11edd408550e3be94d3d401c8f7a8feebc82a92f8cf14f476e3c3f53053219578e0759b56785f824e5b8354bceee9fe4647e6a2a5b9773a01922913591e814906d635dc1ca7ce10efeb62359940618af920a34c2a48390adfafeea4a74a0341a242276925c38b9645a179bb0dfd2a7ebb0cc97d0aca345724036032659892c2ea5b3a5b05b0aacb93feb10fbf57fe2d774de131651d0d59269274b03a92198559bd9c413d77444ef2db178819f19676b10cf9970e702f5b165cdd102ba03c95207d6d6944472957b2601dc232fc5c1bd2ebc536f6dc3cb4f44fd0af415c51c7d2082138a96e3bdef1aeb98a9bb61645d0ca81915ab562eca86e4b5a7f75febf6f2157af33be581b88e38e19097b5d904a11e567a4d77fdb8de618d59e770cec1e43c68adb996ee76e98284bc64f8cbfd9a3ced4beda49e2411198be985b2d578b5b8d8c0cb09cef41f22ed31678add27619592fa40a0cfe18fffe85c10d4260964541ef652436278c0106d0b0f533565edb70c4fac9f58d2207b4ad2fdd0af4537f56f719febd056db11992106f316d7a5a87db93fb8bf390e4b20074eb13591a88d251b044e96ff9bb656aac5ff03d5756c7c9e306ce6493510f7683c70734961229c38c0b614f7e545043d093d05e43c4fef444a8c566590f1209f03ef5ce7d656914edf171b3bb4625add85f2e3c3fe7940df3a12169f1e20d45cb692e55d4e4797e8b804969d980bfda51298b2a2e708a18662dc32c9afc9b5143751ee388af46a5da4ee03ac4d7993a00b189ad5c0e151a54b01fdf13b0c3b624f22b1234448abdd27e7046c17967bb0bcab5e13bfbb4b6050bf35a01212644114c885a04c7407e4f13f8a505a43ae98a75036a643f4a8e798ce1d20280d788aff247f3fc4619e0368484c98fa2abfee5afbb234a44f2f32eedefa442dcd3a28189af5748d99c1daed96c8f7af226d106d327ca42d0e2be4628c72370b097b4be7ceef7d887babdbaa97f795cceda5b9565b8173b71574725a24819d15f799bbb8e75de3b1c6278d8ce095fd314529063abad5268b071a99eef796d71ed7bf4bacfaaf850fc0d99769792801cb0a43d8d0f63dae846553d2b681f6ded58a6cf116872a5d0e5bb6100a504b883a78f9db29104b09f4006f797b5c112419d4292dee04c29182d5261bd06a29993411f2a4ae76732a169ad8cf124bde42dc50fee67f1ffc372fe67a9983f319df81161d0e3211a981482c46fd34c15251e526ca27c578d9601f02b328470ce9dcb922f273d7e15ebf4d7909bf70f98f9f592e627d19f3d9924060028d3da4e64fa7d58fdfee27420c51209a2dc75b2c5daeac9af380e181dae7674690378bb1fba6d2d8ec84ace8b6dd58281cfd9f0cb4a004a110a0dff9f85d8dffe0741b77cb49cd071305bbb35b685b09139b2863c6633448d5be6b0a17c0dae08918cd90cffba77e317ba7307c6d5ca5ee7f988913b86dede3ddd6791fc8b672dc3dda18525072890f21b1722b829095ea54b885a83738066f9c8197ec9e2f1c3dace30193d5019d5e6a5c5467a0bca0a52c610e4094d5855b634e160c64b20629b6256eae1434d1d9beabcba6fdd55bd22c2e079df772228490479c6c06f3ffd415f123ed21a8f22364c98e792d08a58b245584d8b435f99351111a286c7f4bb76f65db38dae51559312a9511e63a46e1af4ecfa9d4d1f3e027f3aafbece8fd49d123c68444bb394173b033eeb345600d4ad5b36d24be137da0e8818dde39d5eeee8c55fcaa07354d06db28dc03163c0c677c312598c750964989291a7859d19922302d8046d81b6e75b6713ed88df34f16792a1dff525fe6a56efe1b505499248999022665ef63ef6a9f07fdc28bb7865c716bf65f456f6d97d25977eaefe982a3c11ab4cbf2067a487d0d4ba7d24dd315e32be8224192ab2edda1d144fd802b945c8f6acb0e3ff1cea0dcae0bd8de002e70fa6f512e0d7f8796e71839ac547b4c8e7ccd34aa1fa94bd8439dc333a0b171a4f7f6f6764cd3498e08f1e4adba03360057b787a960131c07709527585901ab3bd495190983b16963b9b5da37caa721a047cc17447db5684563c1dffbaeede7deb3ecdd4cf919d42764c720b1e564080c327745171fe1e84e258e57b7957646adab44c916bb173d375498fbbee4cf16baf9ddf11656099242663ce11f826080319161a7548daa481d0245cc6d45c80acea0980a785f696a72eba3164a3ab99b85b34fa4adcd383dc5a049cd17c501b363791b8bd6975faccdb0bd44e207c67e2291f27e8f6530beb84b33ca842d685382e4ddca9beb73377ddc56a07af2e3d8b3e62c47c7bfad1f976bbc8bb3fcc71018b29ea7b6a92e7359c48e436b1fa644b69fc7c5d5e257a5a0e5f903ab65fb83b078686845d914dfbf2e9cef2434e7abd131df3db2178738219979fdc30c84cf55c7f81e2a5cb49b2785de2883e0de4e91c05b9","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
