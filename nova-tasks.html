<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5f42eaf1373a8be497e1db716e93e427acf974c6f840aff76bf7d8bd1ede2e7450a618c57fff3226b447273309d3dbafc5e1b9e6332811003a0e83913623197647110977931926bb5fe9b4fa9b6ae78c94d228e0af3739b466f60e596cd48f160bf23bd13d11a95240da1a76b0f91d0d54558370d8ac7b350fe3a046ab5a3e4c14109085e3480dca8936d77736a70aed55a9dbe88e859ec854c9358cb67133a328c492911bbf9f38741bf4b1a95b8da0832feb3360b36c48bf8097958513cce8345f16c2cbe2e892efdd168a40e7f36249ec306fb18d5e65d9a81a2aa552267cc45ca18f9a2458c0d2c23e379278f824264ff73d7ca6094965f68b072de79ecdbb555035e8d2f1d620a07bc1f68b8a1c8e57c3177255baf627cc4950d3effb7e31d488d45e46a52df1f5ef3a72376d2e1dcbecac9704b2bf49adddfdab07a4be90dff042ff7b4d700c7fa1e573a476c508da43126d60cea93c1dc91592ed1a18f8dfceb0e5eabcfc20def881e635bdbe7dd6a8ba9dc78793ee5ce5f28b737e4847aae4ebbe63b0a0c99216eecd031226605d17d6e100012c4558c3212f8ca919a5d5c569ef2b002f754e53b5d2046cbc974a2bd3f610d7a0ab46558229f37ad87a804f798b834353b1924ea7a07a04db98588200cbd05802e9784d25a1aa5becd4204b00c31cff3f1112ec03d511dfffe34fd32ed9a6d2eb5a6d9e266fa9227ad070968ce0975a913a810c72e7689ca2538f30906d0d8e4efcdc485653233fa4005632d49f8fe25cdb6fdeb46f6b8521531578791cb1e3d1f588c446fa21b69e723074a9d7ba9c73dec050c031effbabde155b9e42e4426e97bd42e6e39dc78e4390faa90a65804017025170262767f746f32cf968062e33282f9a3dbf8005cf45d16d48f1b5e44f045d86a50ef23e39a8d035ce5cc57805632e3ee62852ae9d43bed178e8e57175352d96703736186ebfcb6867b005e335c11f8cddf1ddb602ec3fc907a38291c0873ed79e7dcdc6598f3ee067c62fe62c1b577eafa2150f713d37847818b5652ed04801df8bdb471f3abcd1f96d5959e9ab50b41e4060feda816834a44dd0dc037639a63e6354f9659b5ed76b81ad0671a4a7d52a9c72496797d5c6fcc42c2d1c7f9a5796109bcb25da4cb4acff1a11020b433dbff548e75ca576a3b08dee88102510c9addb8edf881b182180fefbf096735ab84a0b975ade3df37dfa338306ea9fa5199e1609e0357b4caf5bbffc389e635d8e9339b84d73c83048705a5c13f2ef9fcbd1808edb72edf2f9bf217bd51eddc96505bf9d9e325d7758e4c08b348660f391078d5d29d219851b64076a4de7288c2619169762daeaf38008168cd1485d4982bba293ebaa2e5f5ed119a9d78159d9b71263977017c2462160ec038d5e851f7f4913a2fab218d97d07799e3dbfcb1c28ca2e720fdd3b245ccb45baa3e3dd94d068cf2f9f1c931a8abc78fd9496a4609805335ffafe12e4bf6c5c775f657424f4aa603ebe3dd5438e1582b7d9af544c293008a8022f8b9ca8c5503301d64d412a49712e1756e91d4cfa83ffb45e45b8121a8871d69e9d9d9b0b4df2959391e799b0b05585ef326c97736d6ceaf722ace5492277b7667bdc1d611ca29e49c541d51df5f719b7a03520875cb92e1a7117b42bfa18467506f9e6b4f027c6a44430b035e70b187fcdc1a7f922c711b1f1e09fe8dd6c8717f867105045f4bcf813ab4463a241943e85ae3a4b7cad99b4e6bba608683bb6d408f7a8688581db60f31ed29244b0a9c31be48c987f2d0b6bd5c348067b42adbf20c90eec06ae23e50a4ca07ae773f7dd002eec338c80fae50dadf84306379dc63ff2171361c0b6edf03c588e953ef8e5ce6e64616bc098b14c78f95d1e30aff8f43a1c992e042aef44034d51ae89c3e777f9f505595fb691f4225eba026032df7c9108c2104a5cea2fabbb9627248ae021ff6f6d9cd639c8f929635b81397bbb6bf3638c7a1b29a16d9c7dcb12b4329e8d997be594277213713dd6b709dc41368876ee41a3d3b52c98d581a1ed47bb1c042ef28b16a1b7d5ca98ea205606ad7b729306e51e5105270a1deeab35a7363ab227179db34f9768d79b049317901e38a003786fbc5b829e4fdb0b37671145da9da541b7e191439c47ea0e961e07dd9081d0d0e16eba867408840f4d5b9bf2c176830d7ac2db70034f28790b9d7961d0d9029463ad2573862dd31b005b1c2a43fbf6d5f6f3cc38f515cc12c4cc1f2dd28d43b68c42f203e167d5c11ff1547991f8a57bdc40cc0d11d63c958fb38803d65a0f3311ab86c7e9c5f58d05a1beb9a2b7905186f604d0fbcff33873c7a6908fe22547d139bd64a620d4fcaf4117e6294b7d18b153ba240212228cd3f1e16739facff5610dd26c4569314c2e3313eaa204cc4375a2b6688e228594a7c923e80415388b020003b6135b809ffc940e5f376389c7ad31c0b266701448d42c59482cf07e404488a65e46a80bc32e48c4885ac40c85c9e6912d36391399bf34e013a2fa321dcdea4083bbe436f5a2b672c4ae7bab480cc28b32d55ca3ec481624e6fffbc004b75d9eebc49b9dedb3612f1f871f71f2698691d918565b643a563996b1a082cab7c85f3a02f21c9affe72b4ce01aa3f9bd3abc876b95906f49fd9fc6b520cf20982f5b512961e8e8eaf6b4b5a98ab129b2437ce65b7df59c464efabf547996fb71d958a52fc5b41b5bde1f95ebe323590690282d2045ab9519df31b259b34137e1eb0bb0a89005ed174d0035cfe953263145e38f5d7c4aa45ddd482c566af8def6ac64efadc4c22c1cfa5b6a3656776411aea8b971774cf4e7c9411668837cc16ea4da9c5143d075f30be5537cc976638e3f5fdce100dcdaa2b044736cf50787159ccf3c43940b718da18bc88bc9250bf6f60602ebce15dce843938964f783850b3d670793aa7e309fa4a060e387a202a422235c0999a497ace8e638deabe1595794a039e91bbbd70cb3a4644b7558b5cbc6b8ad501f330a6f17ddcb671c1ffc8031e7bafa37a53f5d3c7fe1b1231f2779a8db14aa434a04507cfae8db495c90207d87036e38ed2706f0b987d5ca0cf91dd335a77236369c999c949ab0e0dfe9de60b4083c53b25416e48041b45bad5c562e673af9858b1ca86dddb9bc5755eeb8c5f6a41f3906a884ed9ff57a048eb8138bb2c3bd8101db273aad8654387f25f46cc5a4ff6588687691ad08811b1a0c33b44e602ec1a56e37709aaeeae8d4df2d8422454399266e1e47032246a6f273bcef5bd1ac3e0db1449639a22da3c48f947ff39007c1e4bbaaf2aa7ac4055e7aae3ac8d6810ee0c9ddf6ba722c6794659ac9ec59c960e5f7196888d71f8d0218065bd08160a891858ef159083d5b24a57c99532651e73b0d25e629a6eee95c3b6346322aad58f7c4397afc0f9b61cffd1dc226d7c00c43b9895767617d05ffe3b672b7741c41792d438b7ed3e064b838eee6677b5ecfadc328088bbf9752370f965b99e865244b361ae3bfe695452a4eef110bdfd7e0620a9d4b15ffc5a865a8d557714a979cd2f8b0a431a4a0586df8e97ba915be68118ad83a5e66da716d45b04dacc986784f705fa7badf07e2c5c920ed56d21dbb7e673f8d8c1ad3e44c40170978567d0092565aa0c09e46dc06aa4fdfd901c3e90af131ee403d6582cfc42d70ba1a245702189db3d8e167de3abad72efab341fd77f744950e336c1105496affa85bf7b7f0130474a57d20b77770ab1cc715dfe3c70a898f8c949a96904b53909ec05bc01ce1d65d0a88148502ac0e66a90fab317b5d17dcc3a97f18178158e083e5d0cee7afdce85b5a12b157aac4b33c86fd5d1d35311d36cf01bf12740bc8dd6ca5658ccebc98e6af6017db22945c62ed88929bb498871e7bfbb10b665ec161af41e186f6be90dc1b6ad7958f0645e77e586107694f6f653b2de6120cf15b37349111b49d89e024aafaa3b67cd75c6f5893b379963bb0b5d2af6c28d324f683c6a9efcd57c799db05582d68b26fd91e5d5b3f081d54607d8ea1ef726587e8f56efab512c6612f71d2570d4ad71434a0f4eb02e4e8d6d3d0ac3107374935c76b4ed17b22027ee3a6dd63a33dec3774cc9570f1f4a92aa42ea656327b7b478b3604d99c06b2a9b635817f9e1a964e6090144c0850ec10135ad01cd3885131f4a957398139dbde7eff917dfe7363507dce3142a8b7a5220496638a9586c0715cf5e006691bc0b8e53d5d8408d4399415fa385d1ce6e7cc023c50d4795b0a311b14e631ae84675b1316a3fc599f9e965d93a2d7c8c9c928bb1b8139677a0f2eeb66ef33e174f89bbf278f5586478a45e673a1e23895719a21c1c0cd21c6a23aa0143376a185ecf84917927c33a32b02289426e5cac3521d366cacbd9093250f1c208f8bce88431945385dac9c14296d1630d1340be07eb5562ee122eeb14b878ba8f80d330a46d303ff92ee26ecf487336251ff67de0bc02c0b65e80cab1a7f631848cf7fa9be72ab18aa97b12fc219dd694564498c08712342fac9affc53ee8329997bffffafaf2059a8e250e7fa10a2fb3865c2be17edd8f09d7e42aae5886a06c504fe414d617d4719c5d3636a303a74ad84df56b2d53abb633257608793a1d9a5cd4198b2256e65f438f44a28f508d52af5838952144bb3e7749c5d9ddb497fac5477c30de36d01d5ed9ecf70f19e4dc57bd9c3ec120016cfcdfa152acd818b625f6c97512a04d54c41172feb8c8607c7e6847b32076ee09f237910871b06039e5546fc999dc6d48e5ffe04892143c939ac47eabe4002a4adb1a7fe3eecb208390964387ca696e057f2faa1e5bec10ebd7d29b244ff40ab2ffe67e4297d95297a4316b0ad40c8c76c4768008538e9019ef80e9a3464f3fa28a6bf30c823774e1bd0980a537999cc3e726aa5524581e218e2b03c761e126cdeccbfc6434d58714dd43ddb72a066829058641b76723da3615619c66da1ca754a3869ba9a6821fe12f8f5e7d08ee37c0c958eb6e63560292635d390d7ff63ddee76329d1b7db5bdfc0560743d19949be3073260e17dddb0aa323da1922fcae1c8597c096addc0405556d55448d5932940b6b6b6393ad0c3f47b4a1f22c5ac4566ec6e4d1b4d361851fa8fbb0616b2a4f4717cd83ec747917a25e27364b2df0d447a73dfc24259f38689bbd720d192abc417bc1315bd2f0843565ac7291907f4bdb04c6285364494c68ee25ada634f328eb0ae84f3667fc909ff2edecfe6cb81db6a0f8a73615381687539a7d60b216e3ee53a1893df3afb5b6c0da8a6fd253c40c985695e3359e262ffe0270309d7873145cb1a3f0749db15ce2fddc5418656d8a5c43cfa37de7a7e532e023fa71e4bc8d0287e2eb905a210a25088d4195a2fae0a829ac3ed3dcac165f72e4e0f3c37da98e7b5a69a6ec18794fb17d6e1a6e888adfe2e01c8f8912357016c74af422c5c0d1ba3f00edc93b1b122a40d6bd98ef16655ed2d119d35e0802f30bf138fdf808313e90d02a08a433bf89ac07a033fbb3587f99edf88f40e78ab0e51c110f7cdcb88403324ba9ff91a2d12d9682ca04b2b67df6576bdf66bf8948527de387f1e1d6a6fdaf65afb46ff0323a5fe91caeccddd0904cc765bac382c0d387675158532ed0232c56c060f1f3fe091a8f34e1d50b73fe2d3a92faf80f371fb8da11528a6ddb55090cbda5dfa8685f69c98a35c0a668f834926ff552a9641ae523af8bbaacea80e71065ace6a817b04a62bb400457596c80604cce87583e7e0b4b12f6b4dc45bd8fc9898611e6127f1bafc6b1e0dc9b1f10659b0b3ed921cf542a033a8c6117ada8ff091a6ac29ae4ef9af5647d19bb9b94c2c1a89d876c5fb7f73993fdf2218ab81e7b02598f41e88eef029168a8abf8b9ab94cd0bb4dda1fdc8b5642aed7b1f94ad06b057d16c24b558d91f5b8348b30435ea625c1efb3881ef56e31821c8e78972a3f2e6347cc96653a29dc121f5b348c4a5333b52bfb5e1e8282269a504b3327731f877f69cad91ce0fb41a755231531d97304eb9b73fe7453a52164340a5693e6e86674951379e2e765f54a4eed7a0a1752e50bcadfa59cf9d5330c1fa48cc0588405e0eb28d54e982d25af3db8a12259b8ad7c7af9ff1ce71f2a5fce353906e8b29d6196b511f364cb1afd18c28d9b309c0fbcc3f98e5f0fb19dae24a7618ef10770902e57651d581946c92f8950a28fba6fdd17dd6b6fdc09bc4578743bdeb246e2cf982f693cfbe7ae8809fcdf74163e32e8187cc206eb22c057fb38e9ecdadec9f14f70f28fc3a65494963b4d8fdf4f4e16f73a98f0838f2938b6b3265df34a8a0302fd9fda3b9445088a9e4aa6fa050ff2450bea193d6c25e0e678c133415f52e9387e727f12375a1620cbdbe60e3d89bb4eac37e77fcac29d2ded5c35d661fdb3d7ca539e3f230d33d17bfe190590b8da17ece8a5ba5ffd7206399771963e78eb01bc708a58b3c97c81081b00d15a9473282bc5503be0a08afbc0680d16110a3eaa7bf2f06a97530709c373944d30831c46c3dc546f170d03574ccd431629232bd1b4b84528d9fae750642e9abd33718f60174ad230e0dda20f745b2d2be60b5eaea321dee4f0cf8138bd197b60fbadba01feb467409a851c5cf3212726c7b1214d70d936fada59f2b5250ea625caeaefa2ff3cdeb7a4980a5f02e24f56b24f53d51fb0fdffbc3d164cc97238e9aba9d392ffcd9c061adc63284bd1ef151fa873679947817cf586d2be8cd6946c42bcf011ed6b992a3a2c9760259bac6048282271302e5d819dcf54e5f11786fcb97fdfee5362d1c38d801fc7acff5347c400a0028b9a45266620dfd19fc629a9639e008fc27f03971309a3c8286aea89b2e53168b40570ee11f7be34b0e6a0a9aa3d07a2fb1215355746851edaee838d4080652bb4fea825d2e3d975bd284c95feac0cdbbcf3747470d87ad3566dfda1cb68fc89bbec158281778479a356c58723fe647f46ec25ec66969b973bd479885e6c8aaee1e37981e6cf641f13e021716daa59b62cae8180afc0d9a178c710d68f8693ee8a1cf9fcf423d9309c0a42fef8ec81e756bff8883914bf2308a9819423d971fbdb02e9679e5abc6b4563fd3e31d2a677399a8d5048f403260fc282c37652ad2c7fc214336b91e322848e41a5a1a027d84c0f9df3ae6823055e1a9545a4a005d305326cf5569921d454e1a1feaa14d43537337aad9841591238c60ffb4422cfbf58e0f084c64a01ff4222c6c3f0e6cf36ab8e9ca0a08fbb85d117533121377e3d1ce5255bb36db45e2526cd4fbc5d1333930d369b1b57dd68a8abe0a2a070882527b82fbdae8843b4ef5634299e58a151b9fc085e0b139e8865644fa3403dd6fd7c4b952148073896f34d0e3b32d9ae3a5e52ba8c0f4a753b0623992a63c5927fba2126d609ae128095f9c87b12d9f1084967ec5c15f297807e9b6cc76b2bd2b3008a1326226c0164cf70992cb591263fa6290e6173a338c519bb4fc46a783c99c1c8b6d010d989c6f02fe30495e073925d187d81b6381056d37e1e7d2887c83392e4f460e1d733823af9b2cb888bd26b7384f4618b34c2d5e0010f07ee2f7b567bf6456385bc5fb6d2c185ccc5c52f5857e8f589a70f259857fe3d6ad98b78a83dcb240994f17b862d6e12ab7f0f2f0e2e02c853ef210d4bf44f0e6dd06a2416d7e55968cfb469f2754c65c8f41e423c4566496968bdb3c2ef737437c91fec76e60cfaf27f297abc7b67affbab0f27b170fb5db1bc0849eb20a3ab216a2c4a628bebccdbc8e67755e7f6949ddf93017b73a2ac93c7ba938f0d79b3e9ce387e3ff1099234a3c0f583da61ec27b30b5a9205c46e5008dd9a280be0ff45e372b84f89356d4c69dfb437c6bbe5cfe584a4a7a758eb6c0ab87f0d8c1506ca2d91e33a64e48e3e6aa78ffe75a660e0a953e84083b8b18474c6f1830ecac31a38ff55559dcbc81a69cc696f7d70d240cb4dc10d5e8a5c6469603ce66ed2ad5daa7ccab2ebdb13773cecbe7d83c9ca6104df90038b719daf53a234d445f52dc0cb443b98d394ef57990218a0b2aa5331339e01a1bc4164ad122733c0b4b29af6532913cbad53b07f26f4ad907e56d74073d3cac80e2f26244dab1cf1d90e27b615b2cd0199247d29cf931cd7695c693195a3d525b0e5c774310ac319962549faebaf04a19831edb9a5ced0f335673c59b2f2bd316dc661574ca12431b6894beb9727068da9198f7d4da8e4e22915c9df1fd938775d174fa94b63d56d1a5f213ec4c65a08baeb85dce7f2265ac84a2a6130169cf2354da2153d4ed9b80114af0c813d8f5abe548b2e4ef23fc7bff4af9a5574c3f9a9ec9320331c4e11a037baec978eee50e5445880c22b83190dd82dd0f3d7bf5872986dcc4ec08b788a2d4d5b69f60879545db1e4e470ec4b80eb6d37952976df7b84b53af22f41b1f739779c6efe308e1de0e16ecb49740b3946e27b79912a1c6a0c7e03ae589328dfcc34506b3fbe460ab07debfe760e715ee0ba0bb4b0cb029fb2d93b420bb8a35aa413b73700b61a9da2f22819cc8e8adab88c6dd2f93255899c1abb6232cce8096687918396b5e3efee48fe346ff1cc8bd3a607939e637ef581fe5723e2ab130b3bbec48cd5a4df85c354f4d048a4da265a096f10f95780bb8a9cd5a3d2f9e665ae0b0cd4ba040f407d8fd81dba3421f38a44c54de6e32c77f7dbad324dbdea07d8e1db4303047a07fa0a8c48f7de313a8eca62b8147e4643c3f740cf3715a9dfa7ebce9d9afd2c93ce88e47e767ece54997b29823db14005de127366a5a94f24053b35c015360a59bd5dca25accebe9a471b8e0d5b30503df75f73f21b90c78699841aacbc9465f2e10667f28409ef8afa5d0a7c90d880c57ee7727ade22de45ab9b2e66e2785651bb211bf1c7a5a55a8f3cb66d334f91efc0a0cab98d0ec231a5926db8dd2c8e75b36e5a7bbf5f508a7eaf00dbdc56a1658f670bad8fbfa573f11a9309d6a41ae48d9baefe76c8d1c35148d334dc6db985e2090a0b11ca36f491de2d50a8ef5eada23321eadd61d1c157d9098637f29081e1aad63e071d3cac7959a41dd614d0cff643511134db59f47835159d9baac019213918f988c7a2c245fbdcd6cd38cd0b57d5d007dada503be415b33842f2cdf54a4e35a0285863853aa362cf8206da559c89651650c48933b216bda7d1666e8cd826689a8e9952bca000056eddc82b560497d585074a452b2c515c2da0cc968d3ede685b00dc0cfbf07c6e153ec278489cbec14b0a28f937c36b0282f439b64a72929dd0a3dfef8498ba42c6fd954ae576701a3f4a3ee768399e7cb09ab58e73b6987688079ea8693df72bf9be62f354b1341f3c1062c156087e0f99fc21bc53edcbfec5ae1446f2f6db82c4c78abc1aa5133cd73be4b278aff377d8e574fde15b51c2e9a9c546b348ac4d537c7a57a811666b4f8f42f2f20d8f8e4e6968aba06add273a1bff50be417ec8438c64d3d3ace97c101d872225e9c9ef10bc2a6342f95aeb39f45cb0baae34546c090f573b18b933d8c450367913b10954accffb27afbe73f69b47a1141e6bc88d1091510e7bcf766d46d27fa8fc78f632375bdf95f17aab409225d14a061883b587717f525d2d244176cb6ef2b25c85842eba763825a938f10245c1eacfc7968c13793907ad844c7d7db7eae67de4058256b55b2831f9617119f0ddbc5d07033629ee555128894638ef6f8d39b39a2d482daa0a468acd0278dec0857f94cdc58f06f3556eb099abbb2fbb140243b2c43d892d070e7694884f80eeb4f5850ce4b4e97806bbdbc2bafa8541e7d8e4c356cd36c969f80d62ba38274c5cc242819321932da514eaaf7050bd58f7be2daaaab09cfe8b465bbd40c1dcfd329fb01c487c849c5dbfd3733d388414dd9127a1cf2ea28223d42702d6c98f411acf5ab94d07947c7578af164519d688be230dda170e46bf30eeb7ec651b4f34e814632012e73c5f21020f73505ad56837526eb22d7272d0242522a7dc68a169a48664b889133db364cb8f128d8b1e66a331417a08f007e53f04eb834d2720879005d9f475935c225f0f1b34fe46f264c0bf5f588af6e8fab60f3f7e5f0b7e07f15ad2c494b4099c9f96a2e7a51fac2b5e815940bf5c6a26d2fb77c2e3d1b2601d8ed3c964fa189950575036d5c27d725021f5cc56173aef684c6e05c371e3f76658aa4c1b55e78a19fff194cbef30775b19f17f2f384d08d432dfe0f33eaea9e4446721c716a77e18ff655bb552714be7305faa9fb6c6529bdfe352a408b5a88103a6485d2eced85af6b79933364dd786c98e171740fe9c08b940c72b8e01f150127ce86868605d965d3259deda86db515efb422cf1bf5146b872d05b1c0ef22771e78c9355809c64315abe9265d607c7beeda0178a8eefd13f9a6cba65902374df85d3e1cbffb918b49fca5ee8d08f494fe1b007c0c0244b401ec71c766a338678604bc78f5e139b3be38a941f3e63f566f28ca761556ff8009430d853d648e37b780f618eb3837e8cef2ba60990bf8be6c719aa797462bf4dcd4c1360f69805a4d1d20762be21f1ba834a3d89c02484dabd0cf04aefd40e4b100d56dd65af0ca22eceece62db4bc2082f05ce943e51efe4d109a1babf1fb2cdefc6f6a6cf936dd9ae59d761fff23e2b2ec6445dfa58eda36b8c730742850ecc015d913959d2bc3da666ec80f0efa2eb04daae88623ae14f275faca56d3e8b9b6cafb3d2edf13b0895b466603e78a25d42bdc56b69aa43c8b941b335c6a00dff817953ec7e94b88fa4b2a4fde53e3f264e52b32bc169e5171a4d8389e1aea02c0b19fc11b57ae0c0afff32a36c441303d2dc103ab36359e3704f74e62386a10115679bdac948cc44b7648b00c3ed791e80715295e47cb4222b4995892f1d03944c82edeb077bc9cb9d3066d7b0151ba0a3c09259ac0a2ae96c840ab74af323db32abf01316f966a609046615afd29aa6509551dcc230fce41ee5d9381e2b40cc09009c075a0b4006a886c39201167790362c8fcb722c752f4cf3b5edf083bc462aaaa164506c19492ba7b404fc93e27571d635e716cc5c6ed7d68e466b83be0053f1d1deeda52e8106dc1fc48a794d0355d9da65e4ec5963c569d634955f9c77b0664a80ed3be535b5a3cdc308685190837f5f6c63b86482dd5fc6bdd1b1d814a0810548a7832e16cffbec7d49f54eab7c235fe0418337aa0786c1fda5fd93fc084b9ebf309b68f43d634c652f03a63357008857557c19def5002a96cf781f5e195f04cfb662f5bb28bce34a3958f1a592fd429064d35f89fa99b14e8e363aa2228865fffe4b9cff1f09425c9baf7894adf91e29ae2eec218758d56adc090c0bf065d7792dc070681eb7311ba3d2c7d1c4a353e29b4ea9ae9bd306e08ec497ee2f9a909fc73e6617904ac1541572f68f9098b03bb080af8b4addeb16465e98d309c009bc8ccf1b97a963a83e0543bd6b3c00c90f5aaf04689e25315dce5ce456807e26cbe13fb2cfeda529d5443e4217fa14b89eb038b3f321a990e3e0403b69ad0b19ff11d0dc58458be2d10abe4896049ed8418b512fbcac03cce107e94883b45c45efc92229e60786a1ac603033b2115f20c012cdff90042c66fedf4893c80aeb5ae59a77975eafd5e8d9e52a3509d2dd97b611223bb2fe2de083e1b63707b7fe2f99a7b105579ff9503b5177c9e08f656526cbd7f27666f37cf7d65ca02bc9b40c3607613aafae227a5a1da6e00033b6c6a9a86efdd93556c4882f26a9ddbd897ecc110132b80d4cbf0d481cecb5d7e64e0a49ee9a4d837bd93678399cac00aace51fb77a685a2717783f57e78bc4a6b8a74c56a6067c869b05955bdaa13cad67960b3ddeb70ede175f879dec9bd4cf51ecec398f9f06835d6d60684cc1a94c5eaf443cced5a42402d36a7649b878aa829d466a5e41e6af314516db85271787438dfb4ecad89fa327d7ed480ad6f09678174d5fcca49c15e6ddebae954eb64dc50ee8749fe33e8243853cbd28c188696dd96439b1ba19d521381def905b016afadd1d1abee08033a3bc1c8ddc14a099612d3ddcf20c53da12941623e8fa1fb7e4fdeaa8bb6d0fecc31d44c81e28cbd49b8053bdf4ffef439f64a0719c2b7cad0597b7071e60239d87edfa09b8462b07a637452be705513d0fae84616c098e63bd7459dcd1e34a500c2613f9ef636a5fbaee2e847b974077af4f880cae8560b62bcb98f72677e2ff7e55e8e85a6c0c6b9fbf355ac453c9a71a7493974b78d3aee8a14442247a27f461e7c7d51f2e384f5f1bc02aaf86b2d61423267cd9f37e73b61174673ba45c51b4da7e53eb9b1522beed8a0e1a451d7fd2f57823cbffd5c11f5f201247df462a7f04a82eeb47144f192339ae0f5cf3c1f292326a23cbe0746353db8a44a0d72fd4ec63cb74b17a94751d8fffef8f630b8ac5f93b85304c0aa5d309360d146b35d932342ff2459be8105a4843001e32aed93e600f19f94c091033f1c68071d1f63ea6a8bbb2b82bf421f59aee7419ae1eb328e872a21ca1ecf637f724540ead1508b63c7c550d246d27b5fdf90211f4a28059b88407b35d5ebff3b07af0b3ed566fccab6544d46845fae2ec6cd6ac80cf0b1682a6d5c0e2e207df6efb69a1fb621eabade017703f08eff0b157328c179f5b23e9174f2b0916e9f119629429b7ef76e8b9262aec05d0ad317f871b6f10f47c1e88d2a9cb0df3f8fae27279c66aca3b4b3bed95dccda33e6f53b755aad0a9ff8f6ab5d8585f2531c8e0b3ab581215d66ba6dd284328f772c0d750cb4ebe58370b2ac86944bbcbfcb2e5c2e9f547748ecdca4b486acbe1ecfdd8790a2656fbb54e445ee1f23510dde3af3ed02ec9af89c3b2166903513f196914dcf61d4e6e59721ad61fee0007ec279a3a0175b7be89c8d560b617da907e3472900889248b811fa6c8598a39ebb3091deff6bccbd2b5a65f5d0bed1af6024abcd4ce7f893dc8bbdf09b8d1647a4edf857a13dd9763f0db850eb9961b0161390f98f9ed7993a9053552833aabbf0b429eb8068fb8c09c6b45a5531909555f6be38af9bf00b3c8008ef4b4bd5454e5ada7043a17b01d6976655e52e790ec5a462f1ed6ceb2a43b0aac105b74099e121b943db1906acab8148d019b9b54d0f8f3fe1a8a553eb4f57428d50d889cebeff84456a3c4686b99f1b300d8243439cdec87ea664a19a14e9a973963577c496b4274a1d97aed047e24a53a96eb398c551053b389de46ec0d8092a672d1c61ca5bad73dfae65ad07341c5aeba59bb0a3551de1e10af1d9ae20da6de965db61b73cad2033c70bda113e97becb9f9dcbf05e726f6096599ef922bb9c165484496a9988ecc7f75d3211df8f8f27c6abd7fa640b34ed8429a199ad3035bb4bbac3b85a10d13dfa75f889cec1c9d86a5c8e7e99c2d38a674929ac22ae91fb9b797cc4a65185cb5298b5e9ce2ff47eda608c4eadc9f0be0be9eb0bb04409454ecaef7f7d9f39a667ebf6d68b5ef29b75aa8177be6f2c3e8aab60002775e5c8a4f0cd84311ec97602bcf2db19afc5343ae7f1b55b28ae9058396011da0460fb391a7ae0fc70ebca4fe32f30d66c193e04a7e0d0435c3f8e08a1184b20d04f4554d38ecd4a5e4fe8b20a2569ec37ff3e0dc22f1b5715e52c8e92b3139242037f8dcbc16574760dee11f2fd75f12da72d2cba57a0cb5044caeb3f94f478eaac8e735b66b84e7df1af63aa02ece627c4d9e6056996cd7fa30d4ab7a1fd0352b5a6be73c9813a2470d661313efa61f717a5c77cd591be8fdd4981e5978b25fd03a02fdfdd932b8c8b486d790798866fac098f725556c03f10972998672ea9a8a1f13713e6a02c652fdec1eb37fd78f572170c056093bb9f4cb01b0dbd50cc92b772539747cd25897d9cd1ae180162b0f3d1c3d9be2ec38840eff16e228009ffc3fd83fa82ff21a2d98ab92f6fd7841536c2c29b2cb00e3529d5c721fde4c1db091c4a1bd56b9b3984cf8865f18a04f06588844247f8b3dc89a57003239d1350119fd539b7e58d50f39f3bbc556b7651c9b87b88c7ecc19e36fdcdb6453ea83bf0dc5cb1a6b57fafbacb75b9524c11de2c347a51467f9bcecc62fe95ad7fde5dd943ac9e13d50e841edbf35ed39ac29fc21ddb893c097fc4d69493c4731fb6b86d3f3dea70ba5da1cc6342ce760ff7ab4738e41fd1cb38d6f7f351da0a7c8417d09d246013db6b1b4727ecfc22f54d31190e73726032cea04784d3b6f68db2ccd3392d6171b07efd4a3268eab5cc0ae23470e1c9d631408fe19e2a0c6b5192f3722b97182a99f8f04b2abba1ce25e3c04efbfcb3644a404ce289879843efa4b83dedabf885a96023871882c4a4be0aca60ecb48de4b044e68bd51bd0fe7ec2cea3e3257b6a24105fb9e","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
