<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c4277592bf53ad99173eb7f3a5c51e406f5a487d89e98f23135ce7db6e5b463de43849e66b03e4fadfe1671e5d3a29dd1b16b0f381fc639d503708773bffa37b9b9eab1a1b85364f7710e11455ffde8b77cb2c9576116f5238329434d714658d5a15d65ccf5e84de7122da6dcf824a22699f806228053ceebead272a9c1df080dc21c85bc849924e47c91b8bef491812c259da17ccdfa8966b28696ddaa283b1ec1e4a19d8a87dc1c906e257dc5c112e54c7808edc12416ca9a43c93a91e6b50a3f0ec38a529a0c5df03161d007c92a61b71cec3891d533e7b34e6e4785476bd3efb4b9d446596da27c51dff219e614c9d51e06741a7f6ab938694fe9adddcfb57e13607f4a8212ecb038dfdf59db7a03f89e98f86cde283d1dfc4faffa4c4490a6425c58c5cdf461300aad71d318ee74670c12d72c888b6296896c9c92a20d5c70866c17bec87c426f6ee287a0d934fe2b96ac64bc829a1792e3e755dd6eb85cddc3021385f005a8803042ba2e4d3f287f42a5cf4196b3190d0d75be82b67aae647c255cbc03ce4759c84e3d176a9e9424d4b69865f7a4276ed2c447e5ff28f774114e582fafaeb01b3a1977823b00a1b234cf92d29ec48ec72a44cfe3131990abc7c6359d527de3692b784ef1d97ed6de3d5bbaddb72b5d0fbc8dc5c30fd47a6378c52cd27f02267aef86539877ffd8098a418f82cadbef7217c8889441bd8c5f010ccd0efa032f093a78cfbbee76b9cbc55a62717878d28a2de15f2c90d431f98639082b849a62d716d8b653c24ad55e36e2bade85a1ee8e9950a980a04ebadccf796008e7710c26b3d5eb64f78167f87f6ca7b8a92b0d16d97dec839891fac96bad1b6640f6c2ca77ae76458347d604a6d7130179577e37415fccd6fe7d8b4f1d204a16c3fd25c5bfa575b2a5e6ef98324dd855ced89d18d57780c5afbda206fc3c2f432a49557fa581d9dc7fd84d566243a18280e608edcc9e40cce025ca385cb9d1347646222632637c0e13a985c1ac092ae7b024e0a7c998a6df88db77b06a8d8a34a1b3bf09ca304f980e17df5123c2ad2606271469b40b58315757d6b30f4559a534d9abd06a1e09ff4b5cc983b4d6540d05258a2213fc207484d5ef8e6cf20b4f18b21981d87cdae9ebd6b6855dab085b53fe4cf5d870643a1f2efd9000122869921ece882e526e2121680a743dc6444dae07456851ec178d6f16591995df50c7c3263c57718772603536d7dac1d16dae3f92b08d0262945a53db8a081da9a83d006de1130b71c1276354c7bebe7aee3dfd7018576f768fc19c4c34c53773109ca9544b5cf80c533d3477b7a69de1033ba138af40cdf83da1e4ba32a9da59545dc96c01d490b77ef9fc5992535e41381032b7518ce08ab43a4065f2fe5572e3535b17977ec3ff1d9aa80f1e91670a8c46a45e0de8d3811b96a3e37f8a7d56ebfa0cf6782f36a2fa9e47290ab47286d31d2f51d77adb58d28ea36eb296cbd0963dc37a291bf28872b7fd21d30a918372155e903ce65cd8b7a7e7cc8718a729575c033b974aabd6333a9d9d145fdb59e9475c09b80936927ac3161f2b2cc93deb89d4810e83c55ac0b9bb2ca995c3d018ca573f55e8a8d104b3da3839ec1afd660dff0cb72b14e0c8d9d462b32f681ba6ae641cd2ad25aaf2491e821edbd11e7ae35f2fa4114176da1a75ce6f0fb140212928ef92fd59a2eecfe5073860827bf2d126a6760b13d09cefc51c52e3622e79ec5fc476b28cc461e0747f25d5ff69028c009a90e9c52c0e5a9e47c967db09d0e1a0ef149e19bb0bec90ed8e9a5cf8adb9b3f711f76d65853102c924c93886c79d3a0476804dffbefcda989b6ba65f1658ed6660cb81278e018533c5f9fbecc290716a9402291a2750af7aff8ea9a29ec2ee7793347d447c2818e30aec0c1c0ff4fad6a0fe16645664b574f79a537e08f0f3a5ddfc8b36d18cc14546efc8b1d6b5b180c23deef4e57b29f7ba33c217655de943a3876f6294a7ec93ba121200a36c059b8b12f10348ae8a0e1098110b065ee1638635084aa7fd4167e38f74544c247234c77b9b97b288ece2d4cfc73bbfe260e96b9d8175f72e957caf8621d62a3431d2729e5f244a5822b29fa7c13c9590faed4a13f9962606eb67dc073b44b69907195d910c035b314575f97be52c30ada58c13a94e332025b50e807cefe8f336400fd65983e5313f210731e21904da025a3ef5f58c4fb1748123c00cd5e1c28d06b76fe3a24445d9f65a2067b4137a72092214bbb4be91bec27b8a05ce893417d9009d214ea62a5b3a59fe0475256549e0820e1b4972f9a36f803cbd344374c4bf5644c4e16a6f688d4ca5accc2b699b38fe6c007728cfec5930bbd29988b376fe6ebdfe01cf838ac2adddbdba78eb6c1bef1ca82a2afb8d7070bb0556f97abeea95d63059b871ba43991ae090203281409d47dac437b636caeb81e235e7b65591cd87194d3c31f615244e89c96e10bea1c2e963f40adf308bbe10ef0b39b6f8a84ed3127a6198467aeb911a5b5b1218e0d46b71c69179c410a0ed13f5eaa6f5992b54153acea7765e20a7be90cc0811a5063994bf310dc4297d1d55afc125dd173a3739d7a7ce1ada82f4a978f0ec386215c50059c1b82bf3c4fe4e1adfd73bff05674251632c22be813694b353e4f300bb0ad6fdacc10546e626aa4a4d66aa924eb11df98b5e261078ff82b7cf4a085482011b97d391d6a07c00f6e451d8bb1bee278d0588bd3933498c9cf266a1cd67855855de40a87a6eeab78b10f731245b857964931997869132ce5eb50857b4cb0c74760988b3921037e37d20a5d196f0d1f9c7ed8da26c054ca5d8e04ae7aa52c825a63a6116266040ee5a7cfaeddd434ca01a21f979ecf04df5c6958b1c03998895b27319328b16a56a8e765a7530a0270c6a18114ef744b61a36564a928b0158d8fc83ac7d814bcd1f5900bd38187029a424c66cdc5742bbf17602567928ce4dd48a95eb1782b8eff6bf2649f2aa4c3c1ee09a8781711a51b73f4d7d45ffe411095072eeedcd463fab64d11bd845f4cba1f0961759bd4c2e4a66123cbb8d50c92cfdaf2eb257bbe8c74bc85be1889ba8eb3363f2184e2f652783cb30f94f66f31a09dcb556db1b1e9bb8079f22da673406786cce6bd60e79a6b95497780b6972a6d813fa9bfcd09b6afbde872fed886dc35d47622d94e6473f9de0c2ab2f6e905eb8d719c4cf7503107bc6359b02ee917b4e881637abd5ac2ddaeb2db85d8e48a4c576eda29338857c136268a47f6e976d8cc1826b7fbfc100f34bdfe1a4c0e424c391108b45e02f7b6a91e7b3011ec38b9000f8c74c8e9c2dc67123bf13abab1f05303af25eda443ce589538b36fdba687b5eb583d59b263e01de1b7bb2650c2d9b111895ec0619fad5c04c2272fef8f17a15bcf4ec9fd83c8c5981c6715e399f8d440dc04f2a35660a7b52772563e14b23ae144114393c0b243e5eba83339e8726c2e85960d106c58f269568240e468a0e53c847173ac4f9b01bb5a14e5f1c78956b4a3c94b5aec9401aa60170a7f4e9da7f6349d7b38b802da439cd1ba0dde3a22023f68834bc8dfe36e3aa2b4896b3c036d202cf260264c150e201a73328f6c6c8daa9417b6e275744e4f9eb7724a124ee4f6bd94273c68ea20bedd076db189211d63447ffb88a8d3473664e1d436f0422e27ed4c10f0278aafe95ce2280904b30169052d25f6151c2fb574ff8db5c6b9fa1f80328f97eadff635a2ddca79db0873da53a41a0dad4315e86ade00e05f138df3a34395117325e479dec3f00ff1c401c28d4e266d98173bdb4e3e46919a735121a691d477318f7e92326f7f1120e87ef2c41675fb5cf25ce60df1ec20c1b0206818ee3b5bfc29714a5eca1ca6d0900883c9935afa07dc7f5be017fd81c2eae35f1d8a345d52ad4535b19ab1ff53eb49afd23efeff6fe1360fee7f08fb7d77ca12937effdfe105a8a498ed3691953991d460ee86af3c617052c4e68a2ad0646832fb890b7cd450a5c85b3039b34e475de3dbdd50ea018b256502db8256bd467c8a7577a1151890100771b7f6ee753811d12e8cd1c27faf200d221e4dd2e75b481819f81618f1be8124b2360c9078fa29a46e7c0d1fba19902bccc9f3decb4b076e0e60805e8b8816e4c47fcc3a8896fea1c3db4f1491fa5066191bfe01fe3266ca9240e4f648703483f51df9fbe1792a36a7cfa2ff3666b35b974640ada8205459450814398620393d88013af86da565fb77ed9be524252d1a7030c13ef8fea9345cd279e041e67fe90d9d9c409758479ec9a425e98fa0004f140baf50abcdb8daefa7aa8542c1eb73d8eab2b613cebe2021c4a01e88254528b87bef86168ef3905c2aa5e4079ad6c90c1e49a5a64e042c9870b0a819db019ef8d26f352ec48b237ede84abc7c38698fc1ed3c5fa092382e35de6263582b9df57a71b282eb3fe4789e6fb1be318ccf78b4c5b13b99abfef00d7d684aa4e1642cea28822b2df7a7912ca8e170c1e2052920b6ab4f71cda13b2f740c28d30185801495421513c6887a18c23bc2c14d1fe32cf24eb8799e2070ea8d17c0e800e364aa5fc288165419a3c57c45ecb17b34abe627febe1976ddd41ca2a60c8872bd1cf8467b29b424b802b11e0718bb265c9e48a876802b835d2769f0a4b41e2f24ffc155d0aad6f41fc33a268423ce629442dc203342c4f7916266ae717eac8a17dad5df6dc788ac569019a512a599c044e7ef7ca3bcd0bd6cb47d964325c770da129a67695068eb472c46cd86b587d51f387c12a1f8f8a932564cd17e138d9353cb1ab76d4af149dbacb2298fbf670c4b1bfb1168fc41531b5f8d6fdd2af24475be9be7b34bf04a1f13ef9d802562a77582840c21cd6e22ab3d2cc13f7ca2ae4508d960b05f912147a7341163f32b6ad229d277680977e160516fea8e0b7ea03d94a919e0cd911bd667b89470b46ec2a3a6c67f73dd77a8364d84ca1fbcb9edaec90a506458c37ffcc54109b2fa02fc041ff0185eb19974e984a0ebd69e31cd82b6a1dcf155d0fa146fe7fa9c410f9bb0d0e88964acc5d90d5608b4c303232903dd89040fb4ebea78e2ca3ced2a88299ad9f09253305e45c5d63efc718f3d569372fd143ec724ae1b2057ef4d8dad6626b14175b36b25a672c08394fbd611a967e3918dfd21a477aef52541fd756c80a7ad0d1b2519210fb6486df3a831d2a9875cb65bcff7b861870738c6e32bb97caceb83028a2cabbeaaa0586cf10e8c01ea691507961622813c2ab937475cab3dcead45c55ad6c03c944e9da0818a68ef0f44c8d8d59827e4737ff2a20399500655074f4f822be9cfa1a63ac2e67d29ffc11e293dbe0d07b776dd3d0b1f702a36d075c39627894bf8325c8e67add88a049664bf413754a39e705aaa1d18060ca0ccbc0342484ecfb8778641b4c386b229cb3f9323853348a9153c5d0900cf398a52358892964d27426347d79c82e0f316681a24fb7f3518ac32c50276d63a7f0c8ddbc2fc7de2e03eca55c463aaed05801ba08d90c3f8b32025c055f53cc3b1a68b03885d0710f8c2d648b3ebd4847beddd6da04672bb0c8d3a4abfb4745ed0d0369166672ca339a73149bf8880758b155f2177a19ada2a47090ede795b2559a28a591210ca3afbc5466d37ef322a184c8e9c33b97fdf9244773ecadfba0fe5510af12b885d0bc4551a03ae824abaa6fc68e456a9539e540a7ccc1ea32d1f948c867b2d17fd6a820fafa2addec7a6e03cdcfa5897760574ff0c58f94b5361b1db9d2f832ee47b8946326e3746a3f7aaf8ed767acb44ad7fba3d55b0fd3523004d49228272609e1163a99a14036ce19e0f5d1525705950bc8cbf89d54ecdd9ff35dc3f3c6bda7ec24863bfe6bf5a4bf7e779451ae40836d07465974df864d92160b5380581a22d489ff9f6f09ed8116dae763983eab0e7a4bd24e7943aa4ca6869fd697fa5e5eca8237e31c7b5c665189492acbd78d60507dfbb2bb0c7f7524d4dd8dc07c70c5e26a8882262b6b7cfa8ec6240bb0b3e7f71ee88f09978096d29cb8bea9dbb5c965d4506306dbc046991f12142cd364613eb39f720946f0417f3560a255877d71feb3d58e33ca39afcbd02f14117e2941077f403ad3766e207f3a4b31c6e4215e3dd1bc3dfeb287d9bf86af992517d21c4f9f279123e5a71a30816e8d29316e7d64e599b4f5bb76baefef5f3affd58bb3f45f3166ddbec27ceac9ed7d5d83cf1fa12c9d1878fe2a49a12ae2b94e1e42900797a294430aa965569e4ec884970dd3c443ad4ea2f5e1290a27765ed0d35638c0c0a34cadf8123b4c76ef40c4e9180bff59c4cf16336612c2ab7dbd9659cb865efd2d1dbd3faf99bcccde05de0a763981b8b30bd011cfb04505016581e9f896c3c7fccd13375232f11d562ea943cb514f14b495c18bd5e0743d723731d126556ae86dab2679ae8c4b8fd2674188481441a302a71d07fc447052c78397cc9692ace0aa468ccc811644284f454639c117e32f3b9d26573e08ca73ca25e5df721f7ad232e2080936a143986871a71b0e483fdc1acb8bb4bc014e8d4cbe2ae0517f8ffda267fdcdf078ff387937e83403ff3ff82d73e89c778a594186624f9e7de09e7212afa329f55f1fb912b2d9e023e4dbe0ea27bf1074746cd45df32514561094aefc66c571516195ef36bf906ad53298b9a01cffa1bded65269afa8f134a263a176b0631ed41733685c4cbdf0df560dcf496385d63c2d899ffcd05d70283a106e9c9f7e9ef321b374715bf8c7adf2f18e4f28d2b05586cb91f9911254149175ce1ea014f4659cb3da36afad95c44f6eedb584a31a39d1942dbec105483403743b2ab2b25fc5834cf8de311c8b211e211db01b956de0428a7988d3b691b630b3e03fc98a885792d5ae38f080c48edae4c7cab97eb808d3e873d24c81c3f183eb02875764a75b04dcb824d5d5a988bd67a084b47c1b2dc3073c003fef77884407aa2f28b0b85638be0eacac086bd4a83e75aa8d9480630fef1171611e4edf9cca2a4a8a2481fb1ca902765b5178eb089644dff7c3ec0b29d3f1a8a67a5993013cc9d4e5ce1e64246d4533b2046f211c0cd5a85699b8d8da8f568fe68b873447ff44fc024145f8ac84283027b1d24ca6690bd5a5c610efb132327ab66e827e693a5f2ecc8f843da116c0ebbdf01d0279d4b477edc17e7231419930eb9aca69ba862c5d975b91ff98c0c62613160fbbdfafb35208108edc1dde2ec97791e28eb0ce025e090c5d215f692aaf6ea34e64fcb9991cfdaff99b0bd26627b2c5d37b66971d08a7eab18bcf1e1af3c8d96a3471f51d72f137a65f068b5bd26fde774e76e4d2970ee2404fc8676926bc0850b603646b5ada99fd918a4bb6fe06c0055bdf89805af20956e970df817a1364298e1beb4fbc919d17d2d64289cc15bdc31224470173080aee48e4bb153f81a60bd625701bc6854de175e77494afec1339cc2b28553aa0a6a1acd0dfc0e33b1635be1c0d272cf09198c1baee9853e38251aa3c5a043cc4f0602f47937b77414987adb934184d7990accc6d23249c6b5c3af3835dd78598121cd0565fc530008c33379809cc325c50eadbcffabd4e7aeabb90dad35c8daa6f8d8d952a3508a31cbecd57e89a379d108bf2072b7df63126addc38cc688730f3e108df2330f2109a7851eac311cf86760767d691bfe54dd3adb69d1ae038889b2c602370f453210ef412b9434c30b9722cb2cf41eba047894dd22298e702c9ff35f75e6b90df4f1b58b8ee184ab2b8359f807a046456018b080c48b6831213fd61dca7e01e4ab5421a7df8f3614a9c10b215cb5d6cbf4e37af2a2dd75f3a5da0e751f61e7395c3031523a5ac9fae6819d51c71c4e989e830bfa49bbcc234fc4245be878cb69ebd2da8cbbd22522711d79c35b791f70cb671df7cbd95e3755b9f60935cb487f3e30012740d5794b26e74809db20942b039733f4abd70f9b9a36ff89ba4b7bc2a7b745d760b1f9babb984d644f267ad2e48678025b2164d6b366f68c2188ed10abab61990cc803b5d3cdfd6d452993e36c3d93f11fa537671e52e632169cd011736fb74e67dacc8dfd3f133c09bd4f2667ed8ce7bea11f0577ba5a5bc1e213a6a9ffad1a5a518ba3f7078cac7327e1e84c8a9404e8be1fb04895a13ad29a0c2087f83aba83914b670e1d7fa2f955dcc0b739410e00907bfc357086744d9140e906dcb430e1c299bd61b0b550765b66ffcc877450f6749f696303b9bbd98e6b447885f614eebc2838366467d620e75a310839ea65a88fb1f1ee41899ed7de310f96cdb2c7f546a4d44d654ec2cf2444176fd66c820a62280b26e64ba90ff4ded500a32aa12d62777995b9dfe4c7a5bc2646f586fe65e848fdd8f9f69c8049efbed6e79e802d0445e4b682cc7f0c62cc3eefe6985a3c67a03d4460033cb40b41f2bc2d8315425357a923a92b119ce708fdd01cc911ee786631489e9e2ed889a6ddb869586f800472daa83d3143f5f9ab320da6eaa2eaac9e05f237d561e4f9b202787b3fd4df7d9d3869f529a6cb9f01634aab58e3546c3624fce6ddb4da66cf21a49f83f71fb4ea52707fa9f0b248933cd60bffa2a7b2ddf30570ae45c2532918d3c095c48e7c4781b41aeeb76dd70dd5160f878530e10864d8ca0438d3f2cbcfd04f285b872059522475e193070feb8dd0bc416c39f2eb6f9d420d49c3062fe69933f4ea0d8c91a7299af5c86b254fd0c2421f000f0de4cf444165fe3d30abac8219cda91daf2688435bc0efc1a955c8b215e4322522a000d468931ba5880f59f22547028d3ea306d93602885f057dd15f984cffa7b4b720896feec9aa642bb1939e8da4def605a7bb8b9cc1156a3734921c986cdaecf0728add75d9050be331bfddad26a3d7a26223ea88656b5bb550c0d5225400824aafc6fffa6f1a546ef0f29bbad12ea2e927283485cb9bdfdd369700bd8944495147ac5f01e6000aea89b52eae11d7e4ea888ad769d38eed47cef58c55ee8ee3a7cbabcc211b3696f9e9b0fa62b090bfa5e2f2f6796f6a43527b452ad246538035b4dfcdd7585330c18538720d7fde99641b0bad27b8b303caf067ad8f06aff065b054bac2fb05472b7d29a058e0ad4a3a6b7592561c25190ef2aadfaaa614747fec0e393a07ddae6b841b3673b69a6851011a4af538c5e15f20f53316334284a79c9ff793fe870b9e3a2efeb8f6ee5b1ab4c953216c15d9c423fcf4dbfaaa94f856450d7663f44d5adf0d98cfe363b389c6942e61d9d05e4516f797ca907755e27b030c0bf9b5bc0c8023474adf7045883b504aa55322342b85caa171f437f34aedb7cfa5aa0142f711eba04a3b573bfb8ffe8d7c61447c1fe7f1ed144d3931fafbd0a61084b86e22421e376c853a07b286b28e33cab4fe8b1ba94d73a68fb4f6ca65044410c9e106c1b2043263208592712e702a62ba3ef34f402362f5ad0957c7927157a8c766537ba1cf17201715b335570a0f8e4035df40b31f95d58f748e1948ef9c46ecca5d5bd0fd507748d684f96a739cd3ec5aa7ed8aa392c22d3cf5c3dff5bb27deaa0b7de2d6f8f5749e1a2c1f1c93619a769e22b71127630792b7f37f38119acb62090896d87eeca02ee7caaf897e8ab1c9f93055a8a9bc8bed1f8fb3a99508bb17163091e7c39bf5beaa68e1fc6ad0dde1a0f2027294de3bae540b8af61a5df0b44991649f49309e77a92fc5490ca0f949ff14ae7a580cf604c4eedfad2ab98de521b687c8ac113374d6c16aec7b6c7dfa5a480ed35d089577289a58ab60f0a7725c042dd1fe69a8ee33149c7c9137b9c603a98405c6bc7c555c812bae71b21742221748012f08374713d36914d245c8f8ee489ea3275bc8879eb23c6e6eecb603acc6186482a0fa589e9a1fc55eded410a3116f255d95131a6577348c7907d0f3b0e9d31dd8dd0a9c028e6b9984baef7ecc767e9e6e3dd9394669a98663a57107f0e18d80f7345171d6c49766d5213ff0e5cbc8d3f209eb80a98f24a933f11683d63ae8036c9b4b482571d0cd6de501de58f4992bb97d675dc317a28c19124721d99d00287c21d752b681a36a651c0ea11362b5b22da0d92eef51aff05f805d1f6c1ca1e4daec2dc92eff09c8f8f391b7366cfc3830689fc4d505fd24876ac193037eb38ac944f7f8dcbe02e4287856d99b08affbc8584362cd6af2898950800550f5fdf4cb326c15f67b55d0e28b8f5ec0adc7cb670c0f2c12582cc6d561f0d25bdf09d55cf3f6c887e396bb98c79db92b95a2eeb2d92eac940e7b75c7be54f0ee575b9d276afaf3f4777683dce3c1cb116acf1a690281379d9ddd950560c281ea698e2d09c3c2a4a774cf8cb8fd8cdfa4832c06d28f58cc9ddcdb7faadef3a38163e5927db96a4d658138ddd4221cd5e4e1f05a84787a66adcfc2a549689fb8547f31977f9cace28e27472ef8c43e16d2c37ea7782bdb53f0aafd4ad99c6d593940a5c154128db1c1cc9753afc34ba3aa9f2149798a9af45cd8e212d0f1833918fa88acca7728c4bc10488bfbd6a7cc7b2caf28e197c48b656dd8642a12a67aa0bbcce3aafecfb41b08a71c5ae2aad49c3be68606f78ae307834fbc1c4393c1be693a7429b3b2cbd2b4b0bbf4e09456b582fac1564c4c9ea56f89a4360ef65ecb9c8d7306eb7161f0a391f6d4f37546ed7f80644c420f9275ccc581a3bd639d3c9cc7fd05459bdda734e2ce234794b2b8984aa57883662c5ad638f707f6c81f7519996052b4bd69cb15a9a864c44002330a835be848c8b21647fcaa81d2b9532f41e97c307b362197a2df36cad1688b4a68eb433376d2d4d3ad489f0b0cba9b142c7ea6fcfac4309ed51cd9d5773fe8d51e3ff7799954bd1dbbcda151ef4a3df3fda4a482c0cd6753c0bfaccd5995f95b5c05ba46a4cd2c65907fc4d337ce018668e0fe79aef8ee46281b90ab3d4798f1b2a760c63ffd51b46bb12fe16e10f1bc348f92c3c29d22bfcfcee1d8e2c0eb7becfac682ea0c2a424bb099f8248a010081f5c69c1290ce83019bf6d3c0b0e7475b1a28f3a313f8cc0ae0f2e07d6c1eb92ef982f5d5ec392e9c2cace8b187089fde3dfe0ed610bd9551a090ba47c7c68cb312785dab91b71b7be9e2495bf374d5f7e02c69fee969666335cf49dce4f5c6365588c30db3f37c0f399f5fce0067023390c281b8cb33ba611d109750d922d2f7c1e7420532dfb2ffdac30908c17d9a596a8fbf18c23f3dccef49e4e4b1f98ee0a7af0dc7a6b0fb86ad538d0ddc15979c7c67af3c789b65b3a4a06f3b7715eb30b087cf2016459297b2bc5f716694c7aec9cdc698ca5c46f6c9125f97fbafd2cdfa5c7f50afa13ab4561874ac89da56dfdf4b032f6caf0c9ee8ce66aa923504e3d7368155fd3455bcf4ee91f813013ff8024cf683b2c736a9aaa9132bc6b0538a790efb7c6f22f9a6f51b94d00d392d2f950e2a3819758adb86daeab087e3fc2fea4a8a23bd9dca94d9386fe430e52ce2d4ff0a2f97fdaafa6cacb7f591ca8f27eb2a1ae17d638c460b1e0aadb2dfad9e778a916f12ff8fe850a751a0c0c09b1f02a7e77885d396e1b5368f053a3da6633d5d99c6b3e19af022c1aa999c1a1ffa2fcae315c9b3347fa131b7f2c057405d43b2df77502079624664b35b062cd599748b850417aac244850e395fc3c5857a433f304719fc282dbfba50e1b2fd8772ceb3822bd854a53ab5cc63791608bd54957a8d00d5c969e3e0ab1a64361c5c86dbc5301c41a2ed7ef7727120be296c3e7f1bdd23380caa3d2aacb65bf3c424921fc8af316c2efd53697e282f8884b214fca118cf0f0dad2fe9f8cdf539c1a38aae3d4dd0b0b05bc8d0ae7987eba4cee63f345dc56efbb16fa59f23db1ece5873f4fe2c6cdb09977ba54bc5f8243f79ac0ee567d96eb98ecc2ad0f14ea804569f263f8c2704d21484624e5683fd40684ad40a367c6d348acc053df5e1494c61c55ed4c85e781fd0545b998b3d0fba510564b2192a88867f7f22b38b26297a548083662fd9a7a7cc5b529dd7cb090b51beb6237862ce3bb92f0b790b49c731a640baa88a954f08d2bf1816e1251f41091b3454493f2d3ff1b0c95c38cf7825fe92e9dc294797d1d3f0dc5c13deb0e2c356d690a2e060f6b8b089ba453efc027dfe75fe4659580d993b833d69bf8077eb927d82fb36b57a503077216e12ef30be9afc00d0c2d8d91c33b20a5b89d0a52d44cd48afbf7c827ad8ad0d118ca4494d1959fa96cd14bc8f061460aba29ef4bcc9324aee2436e6dfcf9e9bf1de29db7f2fb9a66913dd89dc18a079e0bbc4275634154ca59dd26b62950333ff67dd7ac4e1d1e93ef1c094b5903682693cb41b4e9c8e20917818b6e1afa4a0cce7921e1af83e446c99026130ae7b4f2e5b075f32c68634ba84a9bcf85aff5511ac38d96f44fcc99c730aa38b91a05d30fe6bce0764496eac0e2103c79721f5bd40a0935c9d8480391cbd524b31dbf21af0b0581905f64d63bc17eb5a8e20404991c3a9b36ecbfe4cc5bf908b2dd24b4a64beb2ee218042323d4d83fc683730f8d326b0882447252f1246111873c583c21c1cc7ea9912a3ec1db09daa1b7685632d2cd860be4a73652427054cb8c15daabfdb529fa315547fde69e3dba7f5f84934538ab90f10a602686c26da7aefe3da26f4813b60dbb836fff814f731a690aff319b473ef159b0e8566ad2bf78d4c9ade1f99628b55c2fb0a94c1767dc32a1a99e74268940c53e66fa1fccb985e42bfdab222cc4eb3f251604c718410a600887ccec2e2a3a94ef29229e7da27511eb447b9ab06dee0b3f30156f52036015714a97917408c4a6da745761d4640c9df34651fc020b31787106d30e07d7b70b9c74568ee0b8a2063b980d0a7a6f8452c1b527746861fe02287de312089479f540157bd9c6cc16db03bc03827b7019a209a82ddaf036293d96afd7d933a1d194bee45b737358599513522e3ff36f7b5676359ecfae6e7c97beb2c8dcc7a7e617375a9b76e7d508411da22dcf67696920ba7af45b62cc69b4861da412f49fef29dfec7af6e3183fd1485b031e1fda300e2815e67efb5749b2bfc7856056b61dbf7c6035c1f90e0dce56d849418e3e836bc1790b883d47ef99189ff312594567826d033c41e19a4202aa794a387a02db3cb0d44e3e2fd775cefc5428efa6ba112cad7c962a53a2f011954f74e624b99e65094b647b98387d7514e32cf88f4ce6a716646a2ad6df3d24b249bf7f4ec69a55e8d5b71668c191c57ce9a86bfdfdae5a4860f76159b93f0d598b3cfdb94e0c0436113b6b95f29ee6082c5fd2be2ee8750581d72640710e1591c0e47c12a2e9344ce21b77d426e75774a24930b978cb65b3f3bdd06f71154b38ed0472d109f72f707f8a49dfba7d2f527c0add11641074ed681e9e6aa5e2b1e1e4cbe9b956494d9ad779a508150fe1b5ff3885889c5751a3c07ba4a2b1601cac4dfa599b1d42fffd3aa78ad11067ee300994017a74ccd647de6024de1def3316f4480bbb332ca54d0b0303119d4a3b54f76842adb95f491b0ed7ba4316d97e0156c4c8432fcccefcbe5305aa96a0ceb7b43bc46f5f8b179b09362889090d4b1c053bfad49d024135e849e6ad23c71eb2bb58c225150d685c9e4fffd9ded76249818cd291f035a8f87444cfc55c14fa1cb23901c21452d5c742e465b511b9c53c52dfb195c1916a0d955ced5b87d80b6abb9a5f9af258b654879aae18a28dd341cfa402c186a60cad2f4a0e82fc2364b63c28f83f41d43bd674c941b21da2c91afa0708c2804106b4dfa67c42a126fb0310d0f9ab9a5b9b0b006b1ed6b97a6832c85c4d0e375a934670a0cbc463a2917a15fcf8579fd1819a3d99a840e727cd40abc903c0652cd55d2607a0d55ff8df90929864b41531d434a7868bea01535b8700378eab9e4788000dbe6be7395f990dd305cfbde7d6c0bdd1f70e2e28d86ef4307822e88821c22b2865dd878054dc4afd80eb11cfed16320ee529f7651b7a988f4eb8be64b2611f01295ae1a2250dcfbfcc8c6107f1248d153687f578005fc2419f56b8e2a7e093d0db529ca68caa61a8847202ed913d806d8a0cb29cbaaf570881d4cae0b6c650934eb86f77fe18fa9728ee0927327dfb16bbccc2a5635b4ce0ff15ff3267f81759d0b28297167f218e5d627d2bd49a28ad9d81b304d45fb2d12b2317d17d8a88ab9ad8540494e6f31a377e8a65c44bacb13a7f5bf0843ba656e2a38055ebd615d8a6ce974f9734342c671d1e59972bf417b93cdc403d812a4b19c63997c81b874b791776005ec82622291de9f787e0e4643986493d946048be200564b4f7b3642659e08721e93f9741ff14642f1b868db19e50d5da42cbdcd11d14968ac0e42002dcfe39dd67a72d721008166c1b9d99981f8ff","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
