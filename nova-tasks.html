<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"16c33c95054c0c7c57e90015ca6a76ba4b06365f739fea3fe2b166094b373ccad35ea50c4409547b1bae2533103b6aef228f83db84a55b19c40b96fc5fb739df7d69caa6f33979199b17ca0e31e8069b881f5c74d462c3ba81b86b75cd0f448d4d58c9ea94d21d4e3ac868a395cfd54259af3ee12d8f7ccab2e63195e997bac4c52033d55e319a898fd9ec5772eb497d23bd835a50993db37b906cd3606809e2e7ef51c103c2aaba71fce187744dff41a2b10bb1d651d39e3bfdd03ae51d2ac7f34a20c0c53837e91aa50e58be872e256faa359eb06a6b8814447f38a3385a4328ad9d6b4e1c095539ae86f432b7a1cccf77399594b523dbd9c839a06945a7e56dd5b7cab7cb671fea7724a0b45446260d1cc559f8f3b06f46490193cf4e74a33d94b0ee2f0c4ff861a48822333c58e41d448095d69fa4691b4bafdc20cd5f3bece14c15a87ba67c7ea5d4f8804bf6c71c91bad00c5bb5df32efc9a4fa2811db323ba86bc0e3685c94049df75011ff4c10c32e6bc320eae43a855875269bef2e015a7f9c0507574f541274fe1015e7de72f028fe8ef71acf0d1343ba3ecfe050d8b7352a9c92b3256437d004352f28907b5467c23ca1eb94d77884bc53fbac53fccb69de9888ebb1a41673bfffa1a0967fe2733074d24b62ab4e7373b8d9f8e442f3180b5c25003ed682c8e62577c44f56640d1b7964743d5efecb3d7600abda732e74cd25971335fb224662f0e868ec0ab29bcd11ef4cc2f9fd78b49d644c6f1e6facf7b30f4dace8ff86caadc497ceaa072c10d5450d0964e00eb555d042e14c52c881a5003201c916b18f7981e52d5b0c3ee4d903dd08b93a9955a7778ba20fe45b157c66857e51bd55f53de5c2cc773b145aa2278fd7cc27db637b0c88546109df3fb5c8dc8338714e5b1609385e88a2d401674e3a2a9e505c1a516a23ad404c05d3d8f9296acb92057250719de76dcde21af2a7ac130df23c7f3950f73b36d69a50d2010217b594064bbdd0951dba705758dc962bd6d3e822c4e5cd0664832bacc13b0446884a690d8c8442f0fc85dd6579af4932574164069b6fbd968d0fdb89647e28b64e3531a42f3c043c7fdbd7608ad060c8d7b31c8cc9752b302df52a5ea19707b95f02eda6df077c71908b55a4e555a30fc55cf1b5ba2c1ac051fae3ce18d4853045ee2ce5eb2cb051557429a7cbe4a3c9a4b503d05cb7fe394427b31565b84efefaee86849fba50c8894ec3f714a382223b27ea9acfdd145549e1e4723d048181568eb26a631dd3a846e46be72888af06b8f33fd3846325c2472564dead65b4c82a51c60912f736687031d8a910bffb33582d137aa30cef2db12f631ad8542fb6ee129be36f2cee50ec2cd37cb2eac6e62bfd13766428b38613fb8cab35d9e71e2ab9649e56199629aeb680011da3110cd2867eff6b54ad39f9f38cad44c1d42dc8df4ad8c3089ea77125a16235d1f83f1cba97caf11d836ede88a433befd3128710fb5d4f7d082bbef802f51ccd343c1f05714b131de18106bf92d26dfb46106d615dfce76ce11eae93c9faa9d0968b094ba564abe929d7ad9e6573be1c49432d210f436101cef76b882b5339b0776925ccaa0571cbb63ac43faf93c6beaec32d167ce8e2f81983583c2db44f942ec758b374d6d6d221f8710e0707c08b3d0a8bd15382d82542ee1f2a7cd1b7a419487a57bd029291e7c27f782f0b153285aa16805f1614c6d706b54ab7070c44d451a4730f1e871ab435f4be459231afb368c225f562bfffcc54acd71b8ceaa267984ca960a7c7bc9127a4536de3d97ac43b093113868d69e6ff395f94075f5ff6976f0fab1399b4c1dc1b49def5f84d976778d42cd35d79dfa9f85941f56842bd244978365d85ca64b45bd3f5f746771cff9d6acaf012248f15c98ae9413ed45d9144d7ee5080739a2b3b9de94a7c0a8935b2343f255bb1a6f523ec235e4c8bfca05d81d1063caedf46da15cafb46aa53ead5484d787a986168a26a42a3d1ff1f5a34cde377f122da5bbd29cdb71e012f662a1bcb499cabaa897602ba999aac77ab1fa4a4ce41ec2a38b2283d8a4b94c216521fddb8c3d9aa609a5b052a9b05b6bd5d5541a4b7f7f0e9f970f2fb05a9bba1190897e3bf589a906832c191c5d7184cc274608c5a2997a02fe2a3aec95fc6ec698779e7219e73b4be231afd12a63c122ce1421c34d5248a4a7d1c64897d9f730a4e3b705aaa6737c75aabe1dab99246b82b9ce3978dbf380a4fdd934d3570bcd9c08a33ddbc846b28ed4d81a102c4b0d4101a5a0de3522c57fa5b17955ad49b54ca41fbdf98309c79986c8596b72888441079f6750bfb4625f83565f56b3fd276966367cb69b1a97d3ba44c79ec20d73b102e9aaa862aeb93fa70655a81be32134bd824c0d89196fcc3939d02ad71c08315af1c689c8d378aa2ec05591e297e1001d101f17504ca9822e9bb56acc6c56ae0cc128bba59c91af387fbb06a1daa2f1648a63dbd7690dee60a5d347d2a8c708705602596f89c67df5098c06fba160323a5047df8a97c5a742fafe6351cec05712d06377794554501f706fc4ceb172d3f2d26282cd48327f913f8b30b0a2925d27370f84a52ea4e5dc13174a0d2a1eeac8328e6c76fff5e02f68a91b2c6567acb25517394ec0237fb001b62dbd0d53340af66c015a4b380da6f20bf0bae91326e0e9886d34926b90ebd4f1d81286c1df1b50955ca71ba1321060188514668950e79ad98cea6abfb033965b97a2016cc434a33e7ee8fc5b7e9a83f128990d8be50c6eea2742d5652ff200eb1ed8b5cf81ac2ba04f21fbe709f9b2478922a9e9579d652bcae446c0a414e105b2d2b4c0a11fe056ec54299406b9e043f23da49f52c15ed4fd135238316b42d1e5887706aefe28131b8501890970e6db4d94e867e30ddffd2f1580321e0ade09e66836bb6a28f2ba72f479f5f4bcdbe8d33bef2cafc6743dde0cbd9f5236af2685ef3f346dc2df71be11a415beb3d7248b8bf887c38061ffb07020609b506f0521b9058852eb55beb716060ce9e4fa1a02b527ca5f9b89cafb95e002ed1708a8fe3b70461a490d2d104d14fb5c32be206e0ec5bfbdb89c053f025839f5245b22dd0bdf300db3e0a053fc0945271bd1d21f0ed772ca6012e35b8d6fe180c7f9995e0355b13571c8b242a138f6321a872d4915e7a67368ef28ddfc3dd1c2836d43e3206bf378372e134f8e0cfb3442dce44b04d7c9671d4be4cb9c37e5f0f23d5bd5e7dd25338d86e617a2b18a6f8fe675d724ad14be459b8d2749ab97c9ee9b817b9df1b0639fcfa8d13d7ea36ed64d2d8e44af34b686e9eebb41bab60c9086f4583d557dcbf6216303e14314794ec409f5a606064cc610ff00dadff172e766f1a76e8c94dae710b8f8903b143798ca3bbc1fee52613125ff16eab7cbcb58a913c1db51abc437c3e6f8293d887b6460c559646a69272f90f5e3731a7a06653cbe57390a9e603b373e5e6709361834999431da6919d9926b47e09477f0b4eed239dfec47c6873a80fca01cf942a2c4d959009d8db5b094a67add5a25e79322c554c61756baecb536f6f03084704c7baf038ae0dff2a41249a88570fc1ef5673218773da6af339baadba15c97d25bb9cca912a66281d170ef093b32d74d0493bea07bc99ccc9a6503831d64f5930b118037239497ef835ff954ea18cfd7296e7eafde053d7d9f143a226dd0841bd8143eb2e9944da6b8737a044c59582100a5ea53193c664b4591960ae8413abb67ee2a66068f6c46bed07076368be212df89f0f33284c431dbe4a5237c47eda3beaf77fee415378f211de8d6b982b61ce9351e970471a5c8b12daf4bc1ed01ae4638bb71a57b73ee7aadb0a0e8a1004ca6a8e5c8d38158ed43d2722ff5978afd4d2366491d42ce66afae022310e8a5da9bb18c2d79c41c0dafa7f050a3930c9d52245d3ef377151b66b5b90697ddc7e4a8afeef239b206e67317198af95fb59dbd34c769fd7db8ef6993b4443cf7023bb8597c3283dec8f273b36b17c7e1f31720ad03c961b6cb10ceed08b2da49d8d03def5ea53a7eb224be65a9c249ae57a72f65798ab1f03587176d4a38358d069c4a4542f4f86bf3a5f11d3b5fdd9f1d01d0123ed0c66d025a46e0f83cd24536db39b06f843c23ff67aaf59e97511b940276f901e266b6ef5e0f7f8fa9739e67f9833e5e42b1a669a57e6c5b7e325c465a28fb563c39787b92a39edae3db12de46f8308f60011cba331fa8fefe5ffa5bd13180a0e20962f93a335099f16419d050dc027dde57c9f094969c00ce125fdda7c26cc656d30fb1b7b990c4915bb9afce13859fc19fcff2a5a053dd86c8c1baf039c249839d4fbf9afc920532dd08ad62666354b0778696f0c75f530efdabac08f61280d944618dc6a80494749cf707163a7e0cabe821b05575daec6f50d71a705376ef58501657388f353d9db075dd95beb3a87e7dde89c0dd1f8d721aac5ae3c077e3a15627af4fadd7ca38115f2a3d12b298261621729d085204360d9ef39e691c0461559131ad8bce0de73dfe287b818c10b03944c83a705a151a960fc5827b6ea90fa407096c0e1125ac14ddda88777db3e5aee8a0cfb437e5233723764986e0fc3dcbb7f50b62dd2c63f199d20e751999473e61cd527e13f20abfd5ae82379841754d78c9f17ba202a6b5a9f580a0836c4b50df08e84d1f77c4b7040ff813425c5220b77b71fb936aef893f76ee2967982c16684049343939df0f1cdda0d44975111e4394c6240b835713f8c232a7ec6ed8f849876f1012f3823100e61960a0dad3ac755131654dd99e34689d793a2dabed8ddaadb826a645c8be4b40faf2a5872fd4947ee50ceb9eb4611d6c5a010f8b9fe37ba18e534feeb8162b4260093639bd0afe877329777a4e82a246326e8692fe12ec5562c2b19b90378a62bd16e8e14f312c4c331ddb7744271ba18ee6a9caff72630dd5c5f10794cc2bcebfde90334d66611c82a331a737efe688988c18ba4b6739d731be71fe76ae108aa718a5cbdffe8a6774d0edb5c7d50b4adc080dee689821123aab4d2a1f99eebc535e5b21fabaf3bee375ea195667759e9b8a827b82aa7391c93ab4e8d1c6ed9c54889d6171fbe06634e298a2d3fb13f93df9a89ca1fef14b842fd6f46fa4f176505e692fb9fb0a2d84101ef0188870efbdc55fae39466be61be7ed24355f7fce8275b55c758afc01c0f125a1cf3c3d4a847c8ba58622b7712b1099d56adb9749c0084fae07a5f6ae2ed4ad992bda95e9d9770c21f8a20d3faa2536fc406d1e9990cd4ff80662c7b1d169da34cd484870c1aca9fd620c76b9edc8feb57aa534ff612b49c62599c7d7fb29e47fa1c1b34c9719a822dd70f3d592f4255cc62f62dafae334156aaa195953465bbc5d9990d0bd16542d67c4f96ab058d52649890b3727d3bd8119e7ee3bc851c9ad6296812baceddd107376ef53da05056b69506845485c7591de49b783dd39a39b8a6619344972d9a3d8730614a040f4fb8f9be64824368baf77e9165eaf2075d46a345ffd4dec9999f0c8252167eb232e3d7c7e0dfa12f9c837d55a75fed1a063ad41c84e781b469b92e0897913afc6b93cb53a0bc9428ecabf121425827f1779128345d42ae5efefc4dd130948b4b386e1909242ca9009bae604dcfcf289fb41aa0dd878d4e38382415c74a70a33f1d15dc8c0312921add47949c154254d50e78dda0503a81ad919f3eea8e2221fcb11f8e57fb86298c5537167b6952164f4b285f725e1390edd9399396441a2ff4438d19e7762613a84495e34cd026fcc106324a1331277cccc34af1f6e2ec5120e0dcc0147e3dc22dfb86cc81edfc13b724bef818a1482c74d9b47795689262c908107eb0ee4888165422aa63a2326853e50e0eeb31b95a65e5dd5b9d658ff988929f585d33b26c5ad3fcf19e00bf5254703fa8922b458c095bc136c1f94c3e1e5d3407399c021278a89acacb4c7224be034b06e46fe09b642bf9f2612ff8698e087e12058f21935fed0f3436ccb76511e02f2fefd87a42ddb55a408e47ff51ab192359a8d5d3dc34f4f19279f7b49ad07383caf4bdec26df63b6a7e8881c133bd2bb1c504e5cc7945279fcb0e47adff21c2191d16227153fbba29a2868b592d702fd9551f8612e06b11811ec340f712734a6cfc4180b2881cbdd7e9d7c12501201df14b519b60ed455fd98a089cb171cfa9858932a04077a02b03ce4995c8e4a1121ee4e60c120aef35751d6cfb68fb4a52d93475f8ac2d2c6347732df77e11e1e0637ee6935df8b7a6b13414249620144826478f95ff37d43fec5999b6c035351c5b0fd532f5052184e945d4324ad7cf6dc2c7e9bbb6796ffab070b8a94be20e7dbb7d0d251e43e6fb2c0f5c5e93f8fde84d6f3da9033fd946b113f61e363f6957044a1f31eb7e644f2a1a916fbeb460878b1d5baeb4e790a2de8b6067d5f83c0f4bbaddc6f2408779d38e9ddac95508cf5b8151a27dd464d377e12cb8a0f8ce8dc7ee05b4949a5fd30fcd4bcea5226e73d8f91dd3271b1d5d3b8b7ac06a9042545846d32567400d20d55e21f42cb27eb3cc33e48064bd8db29e2e6869109a7bb17d951e1c14a9458a3986a85ba2976f76b82a014e9c96092c146133d35dc1fd34f5c7f212facee91af35d9e48a6d926ff557034746e1b07ee4cc32abca2f86142a01f1d6e7397d7299ffa633605b319d19be9f28408c7ad20c98fb1fad7ca701f65a510a561f7e72e081610ed2907d202719d36cf5e5b875758a6a567164d10a854c524a9f00e22bf6ece0f6402824187a36f5abac76c0753f56a67687f709481a57a64a46b960e074ba9bd843328d36daf5a7622f6f7e8fdb1914d1cd5d2aacaeb2b9ca9d1f816ea87fa84b145238c1f85769639e02d4f4cce08709749dfdef92f7b429b2d6f73e8b77a8358585314d4269bb3736b613520a6d578e16055d9ad8c97b36e6c6018f872c1dd558ddd493029ef69b098e45e5ebac739b2c357a67597fbc8e5e57d1100510e9df31ac1387df13c8b4e22dc7f66189e473d2aea9ca47d1fe73dd8e93afab69c96ab273bffa31aa0202b4a7164920d16203455354341dd116743d02af0217c3683192a8bdd79079990194688531575c5311c275ab009ed08857d3d62f005098df2a6a8f8bbed3944338a3d73368cd2ea91e84dbd8badd7ce965d3c777b1783a1956045751404813d33343633f7974a97b3e5cdbaf162d9cc7cbfe50d70e6326cbfd67d90bb1bf53edb9190b5e10dea11a11a78769a7d5bfa75c8fe7162fa7bc975df688be4cbc7993c1c1e92ff8387396742dec57df2b5ba7dee8b9319dbf8662907a6c26a5835f8eef04c04bd7aa73bd0b0505c4d5d0bce9a88479063021f77cc96ae321fd0794fb101049e54b6aa91637cc621e9bd5414e7088311f6f6ff653263a7fbe9b5daeed42e114ba32e0251a1caf54433c11b18d73b7b99ecb6e0f287c18ec5b604283f2ac904f9579737a8194fcd320f79d5695c8ef09d37e5819c79a82ea7ac1444a7a52276336d7f8ed580e201e3292c8ae3d2535733e3a92ccfc5f495f6f92da23652c48747e6570e19d9089f297ed6eabe68cfeeb5857c8e6b5d9382fdcced65b91bb1d5c2402ded6bd3e07a7798accb40a312d7b9cafe6afe9a0743003142c953c730a652367677424ea1739c6d91f13ec7a0ed95fcfc930c45b66cdba9e64eebd890f815af833ceae490e82060f89f361603063f37370be46b3d3ffef7c4037be42be2382295489e02dfec8047edddde78a940615716ecc3bef6f82f0ae2a09d82178cf13fb7e46ad2890ad410c488a64abccbc200931db3a5eefd801b8ed44d824c8f36b078b346292edd6c5b6097f95c056a2cb8a48b1382f80e070b4aacc6b01513a6c39eb7ce573c060b0f6aa05d5dc5a4a52d39d06c46802e85225a6354d53454cc2a1c42668faffdfff45c01e9f40ac2b1b35897e7799bfbe80d006382f17f1c8d72160c26ad49763cff055fde2e56c1a3c72e2c59bd6886b86deb1b49cecc4f573cde3e4485772e68d2156102b8cb2b7b4e50fc88e43117d6a7e7c1ceec97c1b6a7de7f862e5ff5db0afd5ef00ed30f38c25925da450b0b369bf4671fa254901c3957d92684900e4b1b6bf72367b033f4fcdf62e2badf9ed90af378c769b74b728709d0fbee12ce35d5886092a0939ba20ad7c04c8107fe32eb30ce22a585188cdfb4c2d6ecc2cab1bfb3ff9ce3ac2208f3386917a721c61516de0842108b9ed8d884c5b95888689a08063495dfb75a56cae6a676b6aae42912ddc915b07f79e4443db68327be8c965eb39a28ab53b04dfbfcedc78ac4065f23bbdc8b3d08096261c116ec6c96e7bf8a9ce03903615607938ed8fcd11153d19e0eaeb4cd9c5bab5b02a8e85a4575347cc8b4c26ccedc101b36de076ef18fcf16062fc871ad2c93f3f74ff89a7dbed93b207a6db74ce14c53bcb5ed422714aac9e781019b68148378b4bbf2279a5f454508ccbf04742e0fe5920d81fba8367797c3744d4ccf108edd71e7e8b48485133879fa2a7e0b5d5ed96e108bbcdebbf20bf2e1586856f3a737f55f14bb64a739482e8f4ec99dc0df03564b041b6b2edf02116efbd4715bc76d853ccd20af657f0fdeee2acad1ce16c0bfd10c37309d8f5edc083eb5ef0956f3b5dc0efbb2d1890a72afa7c10c486813285ee09a6a689a8788ab4c980fe1854fc1427621de1913b3e6ba7e398210d28d29e324b107b310d55c86ecebe31143ff557e4971ee70f2c942b30a40249468b51c6a7f00c8b6dd6a8dba505f0ce910d33a5c95a62eb7ed9d760dd566c3f8f4bb372fe1c2210ed54a4a340436685a8991df8326ed870ab7b0beedb07eef757291628def2bd5d9c4da2073d19a92f8765087eb4ed7d97f74cefb263fee96524b87ab722bf13b73b55de44a7ad1c8e88a838842af6920f99118e85437874c2c76dfbe2a0651c81896596a02a6562a86b8e4230e9c3483c8948eac9e6c97ea001f330ffdb518e3a550ea6dc861b96f981373470e54dc19130dc828d3805eb041240731e4d894d8f607ee73d2032f9411fab43eb09bcb8fa347bc4a55435aa98b6e9e9433b4bcef7a4c7a93cdd0e079bc2d659864384ecdff3b12a888c0d30a3346558279ba3e49e6ed50fe95bdf9ce93656c0096e1507b36f6e461ae0c7cc2ef4ad5522e6314646dfc04923d2981f5ee6ea0c17e36770a48618cdb9cc66e274ec299e24b7c07434adf42c0c45af5c2d32c242566d1236e77c20f53858b453bd25234f8a119ffd6390a6280660cf31872f113321bffb1e58461face07e6b95b88c14b5edb128e6250660d6782e88cff99d521b15c7eb6e0bd269004e2862fc5471ff4b90910528fb09f2dca001728b86bdb3ddf6ee3609c425d96066ef7098bbe0cd9c72cc694fe6769dfe528c65df7dff4d3cb56d825c1f515c55d64e87a5790161c9f7a3cd831c246899f8842238080cf0b69ba9b996ce045b11a3ca5eead89d7275aeae2cdc66c98020ed89e761e41b08fbd3ef9bb15e1b8e512cc5c62d7f1330e3a6137cbddaf905f1060ecd4e013654197b00728c6612683aa77daabf22f1247827a6797d706581c2295872c9e59fa234e7b6ae541abc02d9989e1b6d6409fd3030007466848ac13dbc0131734918bb15480ec4aa65331608d0404aaa1130ca8e4e143cf71899b1a01c99d68b6fb9b2ed2893a203131d98f3c820af5d2b2c81cd49a376406462b0858cb660106bb5d441ee0a27011e745ba6d9b18920a1bc3dce6e9dae3fa53c399e37c96c0129348c60b17b86c42153085d9a1223e3da7f94f2dc5dbb14d44b59b43715ed179fbdc5b7997db19857bd5bd92498a6771ab0f71d0cfd0009b2a24160f2cba82d7aafcb6220bb2a0c61ccabb9e8ee9db652bc42acf88aea0fce7f3a1b4fea9b4199d239a0c5986b7094bdbb4fd34c4ec781b5ee0ea3c4eba51c205e7a6da12a72f18cf158142eadecfb14db7772d458bc56168d708a4ea04efa73b1822516381dddfaec588b2e33efb325c72206fedb104f11867e82d1fbe9c7b1d36f75ab9d5daf4f0f6c8c59c803a35a059c57fa377a89886558f427e4a17c7084addc6ceeab8643d650bff7f852ed0190734044a53badc6ac8a6573d26f3118a8865674ba80e82b144942c539cc020bb9153ff7ece6f3494fb3107b7c42d45d1225d2f1c5579c93d41cf16e0e682dbf6f34a52caf041738e6a4282009757c46e260fbd11201649c21a9e1f80a7e587220c3b3ee3f361e3030eb0f1d71c78e0d149204fbda539e0e163b209edb57bbce1a907fc5cfba83472a994220d471dcac8c09770e65fbb7dbd3ac1824b58c9e6fbc0059128c076ce7ec614ba1c7d12b1cc0bac88b3706a276bf41531e719729657c66d3a456e3a030ea492fac2b001783ad6b25f690c705a2b5b14ba763cdfefe2408176c85514b726fe4eb3a1f697329edd0e7321796f39d700fdd2b985116714ffd40e9b9c809f22bb9e1e608c8872de791564235b46b4886db347fa8b5fe27141cc9058e2baa2fa26903d62797b93f65be4879f3502b7152527b88345425c6caab4bf68af03c72999237bb7ba6e3ebbb930bf55ea04075396705eaed224d63086f46f7b1c6a0e495cd7abb23501703b3c529fe4c5237f3e85edfdae8359d3b9711124dc06c9952a935fde66d6a9e716d068ec69394e910e693c00e304628d86be352f7987bb29b6550f4f60c4b58105e051e9807e69aabed08abe870efa84d9207ee10411355009315a5fc8fdc67f8da75db4ec17cc589188a74faf90b11c42bffe852c041c5b547c2a5f65f01ea877a0626be9ee0a7714506d6ac8e03eced49961dfbd0cc69d57c17059a7d07edf8a2c87182a5d8baa1dc0caa9fb078f2ffc3d54d464378ad0c87baa43e5602eb90147521c84a2f0e1460edf39939bf5fe53ee052f916f1873796d9942bd8074f8ade4e24944f372440b0ac4f5f374a85d324cc140d0c36df942f52f50e66c0da60aeea3ce91b2c1451280c7f9b0aa2da9f77976854f6d5c5ea32469d140343f602b36179c1b6acc64b21c5770ad70f3097534c6f862e0d4f87e31f533cc5477d3e2cdf630c19780320309278c9bc4e4c0a9efef8805044b1a3fff18d343cc6a4841485102d0bb5f876b55ac4eb10bbaff8cd3fb1e4f011c3bed98b36dba9a2fca04e3b03be340ce2092a7eeb9b25895bfccc076b4cc9a938fb3f0b876b454798444f1f3dc816a10a7fdfe668b890f016e542ea68aa9c8d09d739f3294c4fcc63db891df4549d4764a9198be32665619a383063fdb90242b1b8c1a2aae91cf7a6fb187351f85ec5a681c1d030859f64fbeaafbdb93b222e408f971d9085c8583fbafcc5170b0e3f65009105467c7771600690ae772e534c9eaacb8155294c5508b126a727c8bd578d9f3a2650382779e4543044938d6650c39354ff323f31780849f519484cd67d524c875c3854ae30f69328a8f05cd43df39e83678da4f531c57d0491acbe8549b02c5ce635f2a52182095caa0c8aa0305c0a0ccd81f2974260a14a06727485b1276a0159d1080059be0d419c7b3dbfc08d906864a035f0c06573ae130afd3d60f0692b0dc236781c9273f4a49b19f3f611f5e10183e5717b19491263e5021ded6b3cdd077ade04fbbffd95a66b68e978ea8647102325460fdeaf7559b28c03e4746f89bae732e27138057480c9461cfea9bcd1a756b27cdc61f7374c7e8f54eb23a814984d572988f0b7b67b677b5797de1f6e8de13333d16a73f603c55ccb16085d5eaa2ed45b593442b7cc9f59eb791be74954992ec086556702f6826d0415705c81cdf1759eba0a7d9d48322879b5ff88406805fcabb853d9a6cde414288d52c0582fb862aba0a3c74150c89a7db5afee94d22cc6f178f8eef9af04e68ec4b68dcdf3317f0d8034b425c10ea45c21c1ede0db0a2dd97a91ec13861f034844b8fc780b3f80b4b811b559a04c653153c4f6a47414b6994a1d03259fa11fee19be19b3d921456a21ae0773e7847266950c819e6c28a612865304a5736a5762cb6f86e0b84e79b59db985a20f8a6d546b1efa941df455dc54be5c057db716d66be593e047159b9dbaff65ae0671e3a35bf4e5ffa5df2dce37e23e59351ef52948be17d6827f0c5b9dc196b0edace56747be646a7e9d953346921943f5a7d95d0fc7bf51b60561c9d4c20697643ff3f14091c2372a6e95342a52d79c110e1c776bef3bf8e59541e092b7d54abade619b7887dd08f601a2f7e4f731e608a1aa031d331f9f982f81aeba99c19389680ae850c00ef86f30f4ed1eb53af3282dc1ed3f4270d83a29bb2df6b079f4a4fee157bc7e28bafc2f23b876bac9e3479baf77584e5160ca16de983a81019d71af8ba9c1f8138824460da9213029e433a837069433e0a8b77d85609fde9ff5a3a71f8e341cb4fdb95ee83a76ad8d4d865549220ee932c53339ed4d49d5bf64a8329d0759902af655dcb86b58119f38c7305f718ecdbbf4118eee212262ee48ab9187032c6b0c639ea43ad47daf7372e6d69cfdc6efebf51905edffe8e6005aaede0e9b9ed95225c7e0dae2809ab898ba1b1cd0369b5a6f1c0aee297288cf88e65a806060c302919c1854f1ee7e1857aa17468c558bc571456c0192743c9f6bce2279295a5fe3bb2816b6760b301033ebdff3dd0b103717e219fb96c02878819944aa4374550752d9f5cb431c3dca36bd7068dd564e788fccdf90b4e5763cb50b55f7d8c25242c235878892054c04171eeb18e5f5a24f69ae20e83532472b178cac76c981384f246c596026316690b24c8d1498c9cf00262affb386c8c2a72711e1eccbc4f527bc45b854b5d3fb7c39c00ea2910800a0cde84b207e05abbdd57a3acc995206bface84cef7760eee43325cb4903aecdd552630a09030e825a4ee641f86b1ecafbf454d82863b262559ea49b867fab9fe8d22832e80a69bdc16d92de8bc098ac8ecbd572ea4acdb409a916a3d8b71a34492e1d22fb50804231ccbbc72c289fe628f445436c5a4500497c8b2c4812831220f7a58ca18b852e9eef3c160af232a3ed59d9812065120a06689f6bd7785171f5a6ea504d59874684eba937f194b74ada25df356c9ac8fca4794023cbdbf0b1e31ea4129d2a360262cf87b509849f3b600a8db5dea16e05bb1b7fc8ee31935065641ff5522ace84cce28d8dc792527aaa7a972201823ef0d867f9da1b267464e96848be0eb478883df77509e91cc23c64a0d418738157963ffc2303829cbe019e7260009804c0bb005d6298a34d57d02d2f487ceaa4c31c5623d5730e180cdc6bd4b3c50fad1c40ffa7ba5a461b7fca945754ae8c0a7066d633600c880b72fd7e4341332f124f67a549ea60815f7d56df1b57f25639872e6d4ea744147898ca615841dd6dd43a5c78c6e4a04e26391e0839cfacc1b86e8513bba1ea54a7f824a2362a365aa356cfe245dcc46eef9428ff89c207a139637214e49650e56e9ebd417cb4d1be9e7ad5aea141761335d433dadc3b34c510fd0e7bf68277c0bb4af33fa611f0a0439d902849652cfde412d61b65b40b993005bdb8da838cc04b8cd10c1658f9535a8897ccd18c5f2129f2df383220d3be24108b11f7e6afe74d0df03800db7b10cc5abfe6efa96f42e0156c57137dfd21806d79588ae2f226e112b55503a425151b17d0439bb8eb9cc808f811f6634b1660889aa0ffba5e47f1205c9f2225503cf503153f2bcac1e5b04cc41614ccbda356ab39eb27f44889a7ee60f4cd9bfa9f4de763b9d2d3bbcd66fecef8ce8186698780408e3d80f145f3e1cbd0fa822ace7088ee613f66f53f44e84e6e6f6ca2894b67570b0a947179558d44c7d22e30515b44b03f4793edbf02465608ab3c781c2acd6486aaa4c897d127a8905849016d7aeadceba5e9762823a532ecbd519a4835393a2dd0be2cb62f66b30421ee1e4bf52557171350a0297f5defdd7d00bf47ca8a48c8b7d30ea399ce5d17b9c9b8b4f82d91b8460fafb4bd8f658e3a79b2bbe71c59586c1ee8d386281a0ea41be66f7ae3b8653a03b6211842dae3da61e56215c45233b6835e1b85730327e8b6dce8e928388a12fe39ce2caaf10d2","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
