<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a15f5e3d821e7246791da9c2b5a69f43a822c6f53a46e7d7117f2b2d148202dd5156bb829f4c8588540788109c635b596287fdbd4f48104f7e808f86d52b36f38c3a5754b48d9f132d8180074ee35f62951c45ddef1ba7762fdc47b7961ce484419226c1d75fabb9be16d423c595bd227caafe4c25fc18b051d00bbd74eccb33b5b38df730e39880435f0d17aa8283f0d69b31828dcc7875fe786384a64eaeb843749876ecb20b43565abb1b7c81e456687bbc4db1c1cdd202ffce8f331d09c93c38782e6319ebf514307fe087f6f8919cb164e41cee8ed62f1d98465645ae64571d2a0600f40aa2ac66366f53f782b6ca0ed347162ecc1647574e0e9575f10df7fb02dcfa2b4f5cf1a739943d029a57d87ce87be8b7e5509c966a8f3e952725cf2a671a58268c332ad0e691256398444c63c3255ccaaa21eabb2d8b7986e2df552ba20c1064d2d304f94ceeeefe61a835fd89017a9106012ac06f154db4697e340f77079a6c8f77139f977ece043ebc9af4d50863883ba57cc7087e77afbb8a00b849e3594d2d905fab7719e83e96acc4d28e62a4ac201fe5a36cadf9a4ce74f4453975a80fabcce2cd3de1cb55590be1126f913e817046f3e8ec03e16991fc46f0d20c866d11f5ef9554d408b39c52a449ac4a7f6362495ce27fecd90db3ab557b486a72316a4363d4b38d9778436070c3160c0f024928b3a9e05d99e03b577d0746b19a93b67e33c8ac22855d2088ed491b6d46300e119cd2c6c9707f0215fd5b9afad2f18178ac80b7d21ac76d5429aab0da20e1e256f3d0118891b138257569ce090c5a171193db648d7d5c895d15d06b6c8f023229c3c1985a1e29d1149614d6401bb5af3b504d61b59cfd2be4aaa72951cc9b3d27b4d384a88dc50ac39ef35b2ca7af1fd746b0aded497b655ca0e4a195ef68d450a806957973703719500f3b54cddcb863c8269db517fd8e50b74ca4c760f6bd47a2c964018b0e5fd74a8d9b31262c65fc5c7d3f4e25114b291a32db3f8ba0f1829db4cf2ffa8d9609da7029e0da614daa828d8d595e668b4b8a84297293e0939c6bcac360181f7fa4f3fbfdadf51165749c6870d8cf66abbbeec87549fad3c61ceb3723581569a371d222b0a6a2703b8c488bc5651766ea0f5eb77ed41e034ada9bd26f9d7a62996bd1d833e89e1465bed9615cba09847d2bf3f62342337b13e4fb52e18be8de0eaff934f49aecece543ec30f75590d8ac579a9bc2f88bab93c5f69b20a8e605787779b925df7669553704f477e7aed258f67a8d5f07c4e31882adc122889c867d241f7cec868875f3e2afcccb6ca1903f248bdd3357355fe63738f956e1624f1a0acefefbe78552b8b2372ab53df339cea5a241bf973fd1c4305e5b722b0c378dc05ed53d09f20d18810389a0628cf785fcffdd47ffd558472cdce82f299eda9597ce0b1cc1b424e06f8394904bc3b1847e7974be98029891f802c4c65c2b56fac80d63d973e378b6b0a1b2924834797cde3a0f8be9c3c76113b86a3e2af7da78040b4e7cb267a9ca208a59f3f7ae2a39d23af6ca4e33e620dddf062d8ae7cc0dd1c6134324c4c2dfb811944bd2eb63a994413e526b463435f65751dca3b52c74ea33afa41407b6af42cf7d84797926947df68b97ecc3806ec1e19ddda30809f6add171780716db6943ae291d118e175e37fca6d0a223e8d222a5284e388deb0277fd75437c384ccb181a7279f7e87f81eedf28ad748c82fd642f610148af99c06b3a1bad92ee005b99581cbe5e8992c8b1de4a7f89da8ce889ce35902c49aed6127088bf60109ec606e2a7b0b16095adb5cde348e293047c7ebac0dd12998a3de9e85b38dbc372b86d6ad565b69517019cb4fcbf4db19d4c9e502285ef4deb623e2aa78449cbff7b59330c1871c2ba4895431ebc5773f553962afda582462702f741b1579f7d98c049291fd44ae4d93aca81ee39488764d3b73208c9103fe8144e82cee4342c53ccee6c562d6f395b6812388cabf1e62bb215b7de31d5a6aeb1890d0e2f1792abe99ed9f1de82a774c6b535cc453ebaa983cf8141c30e58eb64b73885e05f505b21c5a96fa42bc180f2a487ed249012bb480c5e6252c507d1b91daa7eebb32fea4b9234906d2d5139fd66af0b4a274b9b22e0b905803585f4a6b5d0d315e677a9307716c9cb51979279a1f8be274fc918e3fd1754e5420fbc6ee3a02d31fa2225b7da51f4c48980fa40b72032d0f4e2225932c59acf385765674cc438f0fe0e244f1a1ac38bf5c96c03c6fb95bf2466b650fb8dc1e114ad8965bd2a9b32b5e675db62b49b5cddde9814f3d972d9c0b95d3aa68cabddbbc96088d24e5ba52cf3e56d2ed9a028bda0a256c1025d8829a4f75056896a9093da0be27cd1f0399995cd0cb5b3ecb04eec361695382acf99269bbdf30713aea6462f2e643ec6d94ddf002d2e544aa48f05c39104961988206fbd1c472b4acc0d3ca725de95481459796abac7394c0d88014faf8a1bd68d6ef154fd9fe88ded5af6d0fe35d823e4114190720c8a8321c56495677ca7ca07a330382ddf0d45e42e609fb26614a9cd8bd8ba8f89adcbf74239ec85bd3b267aabccc06645c3206b6d245d84b445307837134a6f7aba07e755db4f4c04486bc91d0a24bf2664fc34ee2307cccbad75fcbd60ef5d88ed03d8fa852a37feb0201a708c6624847d3b6d5c2a17ad23e248561b8cf7dc6f7d1716e81e01f6dfa103f8506a8ec532e18b5a2b640c00f9f8c6902401be92284bd57746d27057dc754221f5a042577e513f212cf69fda302bf1fa8e02d10b48865f2f5df999641a32b9e8499af060a9bb31c847af28a54e224b8610db3d107700fcb9b80f4cb35156aeaae929b8a24fce98f2af17dcd8a67eae520f0576bb02165ac741c034740f2106d368117835bfa835f55d9fa8e4fc1bf0df40773a0561cfb47442b47b3d9c396adb99c5c2cae79e365923ffa6f21a69b49ce627c7cf290185a71983d572a13a1e503f556179dcb2df4c804a5c286af1526bf8f9f959c106377c2fde63bf618865838256cbe32ac6884dc6b74b04ca9151a1f41b17e3d162db0c7d0a600f8e416f699ddf46dd851da6a1628dc40ece2f76945d12cc2afeb1b48b0f1e919d475831acef87838e56dbb2792208bff4cd3596e7a64816ff47c7c01250a4f6e984945c1aafdcf9105b7fbb819ed420fd38cda7f7c3887f33553ea9f0a9f11ecd6dfa544165b9002de8c4a6970a588777e1edf9c56acbcf3c44b86b7151d2866a044e7d67c4127eda97b939b08607a3d7ed2b4778f31b3c5642e27afa16a4da66bdcda4cecd01d8be9c128df8358f7927b328cb068147cc794f797a35a7d813e53e39eaf4825dd86aeb930b3057bae468225049ecd47d4f8ac8d5abb2ab139dff999aacf15304a85ae13408efe8cb99e3df4097de0225f0c8da4b6e35107173cc48b89717f56e4e06d1cd9d99734901f8aa4ec7164b135ec59b1416fc48856dfb1261db07f42422ae7c0563e25f16bc4b07b8ef015e5c685b0a15881acc625b99d8395d68f9552e032e2da6b6a2caf5a6b339bbef88b39656979cd07c369af45ab802ca93fe87532d94e0cad8613bb4c07ee270311c0d4475622a20ede4123a5f6d6f735614138b1e577c1581c21214f9422c5a458e53f73f21a267e3bd4eb16fb8328c698c5754812f2769e4797b0d2134e010731bdb35618b41d3d19ada14160860422ce7c1230d96c54a46d422595012b5c456e36ed3e7ade02eb2ca283bcf8a54845059040b4739ac5f6118cb56f1a96804e15a8fb293252696aae9e0183d8e43032f737caf9b09b4ab75961932f21cbb0e16a97afd3a69e801285d9580e724ae1b181cb1b3672976808cb4adce3e6986cb6b311cfb21c90f155fe736fb9baa7d1bc7f16477ce88c0430b887b0365864355c5678e3166776625fddb59f47d9f9d22ff9abad2e8d3897744d5748e859a014b3e16c4b49271ba295256ae77b52e5224d39cf0c9bfac55b034f3824f425be4230a5e74b9a36fa68817d53b4d0fd08516b6f2e48a19ab61bb35d243d3c9131f6bfbc9a125a328d2deb18b0bfc8a92766f347086f6e2b9140ff163b2986ce781c6d26a6e836ca009cd59a0bf408efc72ac3bacabfac047f2c0b4dc44294b233e7c2e8fcf0c131ca9f9f24e61288b8a78adfb58ef2f7ceeb84342283704c39fb4259e1c3f6140feddcaa6c980c2bf795cd702c865e4687c489eaa80a79aad94209e77b177e62b292b3a9008f5d0fd2360d24bc578489e3cc61558c04d89463eb9d74a23c0d245d555223fb405fb5121a6d7147fa9615e8134633526a7d77592e63170f1fc997b29d929dfa0c7093385fd052b1d3ac7d3e0787a24f573840b2492b25dac6e8e5465bad424053357ab0fc8947dc93e9f5a3614f642345f89caad5927b29dd97ff8f263822a5cfe23b4c1aab84986e0e236bba8fb3307bfe21b04abf21c67d7743033fed92082a46829d0aad9579c13cbd47cb3c91de58b9ecf927a5adbb5af1300886fd646c47f6d13d7526386b9131ff75462185d47797de2680d5ad45e1cd45a0cd49c236fe82905c2ac1f2fd45d2a4174dd3a59bb0bdd49548c326b108d8553d6a159ce5f0eae546c25efa49d42aebe1695fd43ab52d416bc6ce774c5c98af671f5087bbf3ade520cd5cfbebdc32627ee5c4931417425fe00df5bb145acce7f48b4dc96e20c49f6a9dd581804761206f8ee927fa581d7da0bb1427fc665e055198379aebad13df674e42c191b967a5cb0f1415b464e14cbf9285b7ccfc4871d05df2d2e240e32386fe8a824c6ffed84de8116d28303aa8193157c03e704f82f6f9a78150fb3e2145ceb82d6bee25b6db9248da07fccace559a2a238d91b08ce19847a61720e43b3447d2a8918c7f517ce2bb2d71e49293df6c19fbbbff73512428786e91886d320ef769e805d1f5a4c4690742d51e6225414e933b5308f7866821ae8a0453657659e5cdf0f9acec4eb388e011888fd1654657d57d4d62c4f776f39ea7c566577697a50e356d3189de9369e4d74224b63f59fee8d39d69deff9addadd24f174119fd8f0df3175c2868f45d47c3ba8e3b5813bb0c6ce4b22f66d00068e1d7755814effb0fd1e7cb1066e006591daa3910405a22cce9d938f6c42f28fcf78ebd9918941353e143922ed402f44dcd715c54e9945c4ea666ab911ff96e6695d96aafbfd79a3b259b302d428f6f0c675dce4aa192af02d06eff2bd1c78d2e1619053d450ef9cbd151e3a84bfbc45de7512fcd4175a22d34515b36494023accbb0783c0eb9e8ebd9748d8d94fddd798d0358dae1bc7b6561d6f99f6d9874a6dd8c0b42dbec7cfa8137dbed50be9056b6a5d8ba4a127b7402480d7ea35f365cacfb81b2c4879975ec7159e12fbf0ae7aced88cfb6b39f6d1e45cc30a5c1cbdb2a7d11e9e6516aea8b692e448f2a59e6aa9818615f7fb51fa988a01c0fc7d2fd3415b5e982be444e12c55e0f2b50da41b741c5598242b0ce870a7dbf3a06e454c38eaba7388287359ad47b7cbc8e5b2d7d0f07469a91a3ef0223d5ef5d2c1a1f363348d2aa2f50e91bbd9d3b7a226a28cefc7e3d75a727f3e1324171bf4acfb215484c9b3fcc6596d629437dd57fb1122d61ae7792b6918edd4365db020d912bcb38ff6b9199ff2f43c1fa0c3e9c7aa59063abd2fbc45e35b896b28613b1328e6e5b75961d11401c772d97a50f0bbc2e98ae785430d69204c9485b5a98784a680a043a9645d3a84a211f10edbf548883ddb23d1a276af53d081f980b241d3aff99c0d765e80187d0f6c30df8e7fe883eeea9e83aab798ec37d5331eca8131bcbf0f7f943d1c52d7e7ff35d5019f73f36131aea056e2c866a90c519255ed2c60da2f24fa6cf815e4ba31863d82c7e3fb4993994c2a2e5a56d9f7250ce741cb8f1d501a20469de25bbceff2808c0f1890ec91ede2bcaa45805a1890e634292946996ea21be5b5a057283f1c782ea9e72714106c423f205f544132b46dfe608a8283bafb51b055d03c52bd925166e015b8da68aa87292f09c68d545e6d42c7dcfa4f89cc7f139e7be5d20a3aae0dc054f70f174ab60fdf482d939ae3fef293ff584dc6063e193f91b5975b9a099a51230b0d19bb4a51a91583ea310fcb8cb804e0e64dce65ed9c0bdf441456c9f0228ed4ea6591a9041c7825b8af2f1670eb3535501ef366f2a8a12b0e0e0a39caf200a2f72eb9b7c72c8f495e7978289cf4cc1001a9134c90b1dc8876db8db7d25519c0c4a487af76bded76a12d9cec886f895961a5dd0d12ab7078e6ccbcfb5b469f1577849695a5c5f06eb5ddfbf6fb2f9b200ef9e69d753d3abe0e91340b896e4b58fff8ddb02047d7b929787e76b73223d2982b4879d64ea90ff841022821f642c150bcf8e626b1add1505fa6185f4faa44c90275ea05acff0cc34d168f0ed93e1e998558edd4e84e2440efb5409ec26efa9d326d88e83af96b6e04da4721320047a9dcadd150b2d6579dc93ca781ae2ffb637621756940c4ca0a53a3b23f40c47d1aa7614dcdb26d076a184b7633024fb0f2397370ba66448a4f2d30624bb57912673122db905bfd6537617b5a4029aa76558f8618f002bd4925460ddf46bf546676abda48f504c3c2e4eaec40f1a8587fd36c2fa7fb32be8e08e3ced57138523a81ee6a8cf0ac04f63e5c0ebaee93e38f050a157e12cf45a0d336001997c74804d6d28cd5921bd47de632f8be6aef6f47015d50f1d61c58e5dc995a8e532f3c4f70381b2a04c648e950df4f8b574e7fc98a2aa400ab67b322e8b1b0b4e3224da60f5120a277f4e8ab3b77adf9ca563839d23dbb9e61fbc986d35370e53f8faff2e3efd8db9b55cb0469c2207895510ce11dca8bc52ed6ccdd7e7827ea88f56ce2c6ffbf422df6bb3c57d7ae05496428a79e4533b702293c7008d5127b1c1df3fcae4730018f14f6cf8b04146b9da37586441f2ced5c18158723ec828a921bac9fdcafebd695f4074260655d10625a86973aaf1f2a7fb098b88c2f7067429efd764ee4ce3d2762d823ac909b6d73059b690ad06d09887eff2818fdfdfc53c6c13aa9fb0bcd57b4ef01c640304163d77eaee4c51026c4b947c680a64c02ef12878304f9b6a7eb362c25406c53b5ab84d942fa29c15dad075ac1968c4a5bcd3a53f0a97f285fbaceaa9d4fa0f7c7274c389c342266b091948b98d27aee10b1cd391609572bb87837da19da9e4e4ad660f4033983076a154ee50ef1c274be99fc65f03649ab8d91a0212d3e92e62d350d34068a714510dd68e7c3107199773a2f137599d36ac4d5350ded5f2be7984c2af3a047a76c78d12bfb0a38aeca173c7ca9054b28acb39a2cc8a9a10540b2d66f581898105548f754e8868460b669529edc9daf8b4625b25e38b84d96dca1d710c0e3c3df59514e0e1f79429014e4ac9a9ace03f2fcb7d7ab8fb13b71c2772d58a1fa4746ad5dd35d7d0eb80b023bad04d722443f302cc15cecf6e076a0f74a47738c6021d073722c3e2a5fbde10d3206524cc2fdab33611695d53d34995a32bd831b6e7c0199f416cee86e62fdae812d3fb401dde48ea5fe4e5557780a7279007c1c4c38a7053c505b5f4bfb94e941c3cfbd9ab6543a37b44d61d2d4ac4a4486104b6780ce0887d0ea14e294dd1cc6a9796b7f235bde07a0fac6485fc7bc5ec2c2d321ec505424821a1cb0c9c26772f579c3a2d9119111deee8970e4c89f0f7594668435b877857b678447a5089ec03448f590e9080fc24bcfd0c3bf66612e71a8a68629b2c2f304810f3a32ff37dbde0d425a5b17a00fe0c459aa4008fe5a49efdc979d9761458c863d7ee2715614f391fa34ebaa68d4c6ed4d1e4e666d19a61c69c33ed7bf2a589643840d5dba301f6e48c373f31a6cfa1f47088371d0312d6db4a09441c8bd9dc2da3f44ab2b0439cd51d7f043123fc8552b551ef976fbd2611a8539a62f12fa56a3fc2976521b7e53f69417ab7de52dfd660128f3bf5e7861a3fc7e71e18fde08ed13c37e0b184310a0f8d98f091ba571792be38c1cf27214a76df9a7f5707cb9c531392289d5224b76bffba34ad771936911f360ad38f8b9050fd1d1989e9592fe0c91d4f7bf14c8a7f2c327de14ac1e3156a3e92f40b3bf5ed82b8a83998a7cb97007c593a0eda03bb0eb275d798c16f68d9918b478eda0fd1c20e87b6ad3479b29cacd2255ee0c90421c00764b82d40c2da638965828e61af6120b3606f31c248f13a2f0632caf21ec8746985453b8107eb1fdfc793ab75a5e630a163e39136147b4cc382b551d7273e86be30941d3eb2c833babe7dba04ea05af2d2c20d3d832124668f8837037911435ef902db31015245b63549b2d84aa181ecbad8ecb9b161646c937feebf09b45cc79de59f931346f553aaac3effc06c8f8d52b9007d668645e4cfbb9e4e3149f48c6e9661afd452a1a3a8b7ed362795f508511d4d1beb1d7cb67f8c6b68bd48024050e9956965f3b6c561a2bfedffab06859bd5c1b2b9479b35f833428366acbe730f1619b78e10884edd006762d98142f8d70c8d3cad6de10ca3cb980aa85fa02afd373669c48e7d61452ac5f9bb81d3e7e56f4484f5a1a452c928073f5ea6acceb38e334ea01e20d229adb4a1f7b51394d4a03b5c2ae802ddda8db73270a999dd4a70d539448192c7289cf5b1c8fc61756a9dbf55bae05d923e2b9ff571d1daca6d32e7000fb758911a34949967bd7bf17aa28c8b136d184ce6e0a39ee229da34d20c7a950174f5ad64751fea78d460d49aad727984a8c11d47909fb31f8a6419db41f0f7d280c40a26d50385bc2a20a23d80d80147864d126f9a6bfdb16008147cafa165da9ef22678b9ac23990be55cd1f415e5d38ac9ce76bfa43ba9d515b8fa428739768444722e2fa276b1efe4171de3b01e1a14dd16b3fe0c9a0ff151b1a0692963c19c22a21ddf1733e06dba241b08da0d371543be471ffe86c68a2c71af0acccf273792298ccdbd3aa3c228bb42b68d3f0c4602aa0ed7298bfc1ca7c6eb6a5029ed6f788b88e497556ecee44e244f25fbf6be02421872801dca14719fe49dc31195ae546dcbbe2002215b281113130e8905c75bc58391c83ae23ad64e5b5f35101768a3eea9c25f606200a61fb33a53f6ca8bc66dca79e4d673dce00a0922fb3415072398a8d2bc1a70ab65bc78bc7756cf5de48be1270397a0ee3705ed997afc0e62d130f4fdcb72fe5a404695bb6cb151053ac731703e909ce279a68a32b2c4fca82ca7e68d2ac648acc78bf084bb7ac660c8f5dd6e2e3d9982c9df555c144168f7a94793b7e6a350d65b1b1d4433991ad05287259ed465be62898e49c4a736ebc2ab943bd4803bfa6d21a84517fa08c95f8c595ddcfa28aaa087491261ebaced0a0a3a173f5e4ad96fcfb07a3bd4119ba18a1f24c255bcf8b5b7ef1bee35961309219763f563486e0dbbccc3ba4421e953b54da107fad1c93e6a306bec757d3d1ca373bb712319904121265df8b68a2d0c6de3d43e2cc306a803363c74439d86fa016a57757a280858aff2407bec4754a4af29d31f3f16a4255fcb424768bb6ff2aab07702308a04e8e40f917c464d9b87b8739cc55869c01dab444ea41d75e0bfac06ff4d2f8a506bbd69b6f458916dec39ab0ed19b945670a7dd740669fea740a6f03949ae66badc15ad84c3b5212e4221d448318df8b1344a47e18ff0264a87df0ce9b1561076fe66c4c7b53a0ad340732db53116d3225093c3e0eb9b4216d0edc50dc863bb22dbe1d8bbe3c2eca3a214b502fa19a3d62f2feb7581b64f1720f31bd063ee7c39ea2ddcc913b4e4a4dcb4d191bf335ff2836ca323de2a8a0062440698f18d70e7ec166f07116856ff2389cf0af947937b587f02f5f44012e4671713805bcb088f196a067800fddef9b7cac34a3ed2d7c5a5412f3c0cdfc8620be137b087b8478382868cd5121566c977411892d8177081c927dabf5c6730f64f01fbe2b9d5e5efe14b30a1eeef5b42b7a500bb0ce37167187662965d9a2e9951e896b45b54dd8c0f58eb5b39b5a17ff7ebadd3949c53faec8edd8aca2477f14b5cb12092f5a0181fd7bd8a1a1f6c0b92308b45de808f37e3a106101cc685723b7a99404a98ea9c4acf70b1c1608af62aa9316b7c3a831deec24bf22257424f80f3ac8366a64720695c15dc1553ab47487168be8cf5c3b6ef92e8fa6eca9239916faeaa142114f30c957014824a5ee4e8d0ab8f43cc37c8c28c3fe00b5b8e8effd92655a5973cfaf0d130906367afb67e31e38a4800b51cd674295947c64532be9c5fda5ee43ad917503a754c7df7cb4c0e97dc222a5c1adbf0f25d7e4a83ee4b10a8e29bc4fdb705d92d15dfa7d5a385a43a06cf898fd42616ecaecb7b83f800c3436632c71154c3e1c0320b85aa2d4b5cf51bd69eb497817697c795fc8824c9d9fffdeeba9755c36019d38c737b412e7ecb4a8c7d81953f48b63d01b2badae18953d2c21572f4912b54b15c1b26ca7c8229c5cfe3a8a705d4cd95092e73bf777a95d0670f23a3a6c62d85458a98c2782f9457b9e1949cbc895ed7c63648eaf566ae52958b35df0418b9e683387b542b886421f1641440fd049d88d454177d5be7d8eeb3a69748ab48642856a6cfa94c68f571493882f86e88bc1017628e16f1cd483364d6c2956f6f835251795106503b2ac77b00496a2d20e3fc033130116962dfa3c94f760f2c60ead51824be3af525aabcea757d2d6f3c2aa21b226bced8021243408888fc56f48a0d3cc967098cd942a5ac5d7f6c4f909e07e29d4d2632051fadea79228b42d4b68708b772ac3c210ac05a07097ef080ebaeab380a451f4e3693d7de4326819310b0800c77480d85bce78d736a61ff21b4ba1ff03d3c3631f0b8f121c2f904a03b422733d9a6c1f360336a1735b797b0c0b9e6babc5e9e23acc53d016ac04231df5e78a7d146908cfc2e7b061c65403767b74ec8ed0d5f399b7399758f01c2ea3f1dad62e35ce04677ef407866b58a6a45de489e42399e592a23d8282cb0e744efb4d4ff022eedc629fdcfeb37ec9eedae55156c40f71ea75e0fa048105ef2f6ee2767767d0ff225df2048ff7a6d619082667713766999a3a7d1a5624ef00e93b91040e0eb9ae60455dc21cdb2129a65c79466eda6a581c7780b95ce315e5baf1bc5ae5372b0ab55a7ff2d4778de3ac775d08edf0fd2ae3911ce84f8407ce850ba3eeeb60c6a0d112a29291af32cd73a6a793e6236c16ee53652c292de784f86f860cffd6d9e07dd11a019bedd242ff529e49efc270d024e46197bfbd20ac066aa93de648f8f536382d3a566172a9e57556e57f73a13b539b7a6b55752cdaeade4062746cc5e184a6266d2dff5af66bd0cb6316ee71e300c56ec97400ac3ebf632c727285d6ff674ed0f2f5367346721bcbb7a9fcc22fe9acf6682115fa6d2046414f3b7f10b1fe69862dc8ef38fbf5c9a85c63a34098c5fe024795bca0e211d4441a21b4a19b4231d90586fb2e9da6a68e1332e43989926937b9676bda339b9892004a952bb5de620e4ede7f7f804ca95e0b8fb8cec84b86475775d9dbb708b553a8ac228bd1be409883ca4dc92c59d13031700dce1a37684f4277f2123d5e49154ab6ddaf57c86c1d5774609be0d83d62a59567064fa883dbbf061fe8d973814d8432293e73dd156a03a966fe305974dca484c54b4985c815368fb28390707a1a7cb49e23e751c0087ad66770fb0d2bc0e6b8f870277338fe549d088876f3c17870319a885913e15843dab556b58217120232d6170ad68e95eb170575b5ecfd0c5770c11f0420a5665025f2e4a09c74f700421a25812f55b77de5e7c6a2f671042eb9aa969cf4e7d623dcd14ab3bcb55a2c4179c073cf06e2fa83239580d5bed3d2d3898a40ec3ab6be6ee4be05d151bbfaa9f8badec21b2c75006f36776aa8abca08e7c445d2c2e55f3178383e47caf94e8705d27ddb08554c4850403002118497213db9f63e5da67afc35e25ead45ca53419d95fe1ddbc7acf456741ca0666338034952a9841f7ed6af26b1e1d49a057daf9a52969329e910a1df8f487dbc04d867634fed0785e961940f7e2bcf2f55e6e24518ee1a4a7338030625686e232152e4203d95fbe62ff6767251dcc77f05cd05f6bf8bb45fc1eba5471f4030c80383d27e193ff73229d1a1847a1db931b2281184dee9fccecaba83c4b295e085ba57ae98f3037e60cc084177c8e24da866f85e8dd25e5ac8d78fbc230a05705a1ea07dfdfefdd80828594efeec3e9d6b53485af64d49dc09366be0c7c9dd15fab511ecbe62391c2da28e6ca30d639fdfc57b95613e2699af87221fea0da714daded5957c566725225b37e22274c6ad6f9e4983509907f0473113538d928e036f2afaa79b6e8e4ed1a50dd8b322215b198eb3d61dadb57ed9ffb655a42013eeec122bc755e1d2b628b6c15be24206c29eb61aa8543de49d2e0419a420090ab91e3f83659102a6a0902c35d44d645ba1a0acfa5ca25b70d157bc79e7628199395022d757826a4d3d837d9542e950bd329bafd71656a69b2ad46a7033621cbea72396b22f23f453ecd971b6d53d5ef669c185e6c02f3fe189d36fc702a5da6502ba70187cad6ad8ec2b20dbe28a995166d23d9d88e90f9f74b7b61036dd92ba41628a8f8cb2388bb3841a013a2fcdbb2f9ec20329c52c4e6d4d53303f178971289166d6d4ae3aac7cead9d157712e2fc539ab033a0d1774fcf0db702bb0288f78edb9d8752cc72b27b98259970a33dd034630f8205965eabc23fdc1b3700f7ffdd6f21e1b473fe0d2d6d679a6bf3a900f0118d8ecfeb2ec1c48849b220bc337a75978535df1847262fbf0a468bc932155b3453b1dcc1f8875054bbbecb4ebf0502e265f4c72881a81f756df1add8a9db278bf8ae135a47c6b8f5d70c8e636db06c0633d229891e53170a4e47497d3aa57f8d0da8aef1e9b97147ab8313b9062e831e68d60acb25a42a02b591a07f39f1dfe48dc173ea849ff895352f590e7bdad937c06c211179890d9e6c980561849fe2697145e1182d3bad575fbbe0ca4bc76c161960eaff48216d2537e26a59293479002b6b713532c4a65d23c6cfdf5b5761badb85e363af3cec1d4a0d14c764b713ea5d718f6a8c28be62fd496c11276ee9b6b9bcadd5c21e2072f22f971094962144c1c835f2a415adc04aa717100948cf809be5c7968194decb8aeab52e177fdf2528521f8a3debdc66011404abfdf163a95101358b61bbfa9c95bb6eca1d443d576d8b41c6831683d68dd5e068e5797fd19d49b8c752f0b16331e570819f3df01de5274f4aad49d066959df5e86f7f2759e977b3c4195e138bae4abd7e8714cc477770e3176b234ab46580d6cd773655a3337629ffbd87cf6ae8c4e564b10255c35e9dfb14b16526f38d60627acf08c9996cd953d2dc1c460478f18e3122ce28d9e07ddb4038cc68716b98203fb9c1e3b94aecffc3d562b751cce67dcb80924837d8b942824fbcf9d94ada53d1790b454043f426d50b73c220db9e18a11674dc931f5c809896ccbaf27ef03fb088edf28cffcca5273c55151b20025d345245f6580e3c687332edbc16c458f8fb467ea0c55cc2e94f83c53c83308997d023cad28a3a80163517110ccc93075da10865161d0e15c1dcf7fe9053a0f82df74dafa0e42c64965872b09856322065376130141e8b5a9a6d244a1ae0f557aff755b5d49e5938470b90d8c25ab932f9ac1872ccd9c6160120066b06f4ce59c31c16d42611a674e140f85effc5ac10882115e372b6c88a809587087cc5636689ea4d62b1ca640f1d630ab419db98fc6f50175361a5da0c342b3d6a3c3d49650c065bcdd56f33a1e8cce0f0ee283b24c02efa7bb34894031a5e5f0e4c02bd37ba9392b2ed20367092b84e9e5fd0e719a9d5c36929b44beea4d1953a031479723d5755ddc0ef634f0c54bf7199817319a7e40010b5cfec0f98486a5fd07e1c1de08b09faac83c840b93c201eba26cd77a0c6008e09aa7136c34917a5f92121dd79886a01cfcd3aebc99a597a1bb0a97d68da471a510502d34f3bdf1ffade3d2023522f0be058cc5c3de0c64992ead62a6f8ff5f21191a3805d2f12671e7ea581cb58e6163734613525010d3a25a8593c946871a0536614608b58fcf88d8d01cd92501c8fabd45b5547565c54e6a373b0b11b9be4a5dfe29a44b2b1e547b59e26a123d9fcc2f6b863183cf2a4902e786481791f5a88d36d8bb317490b44012d8f897c232d72123aae780da8ab73cf7e03e2f0bc44677e2378f184269662d1b3c10b393d16f0ecb90ddae8956abfc5d93134c9fa16107c1a28d5f897187d429472e76f2dbd19f7a9190dc56496e895695ba8bc3eff0ecdef7a3ab440f75958a7b7acd81d2235b6ff1f76e9","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
