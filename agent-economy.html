<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"efe371b344698227e7dcaa8fff4d5555584fb5e122e6fde0cabc297a46044af2082ae09d1476d52eff8eea5dc9386bb8d30c9c29b12832aed3bdce6b001811a174c8be6aeabe90b5b68623ce81117aa76a0d7fa63d7fcee357ffeb2456cfdde3a46e0e9bd35b12368ee36f5f8dd7dcfc106447fb19a618bc56d367992017690bfc4bca770ba24ea169dd168db823c408217a947e48a73fbb65ca8d6e810fc7614938c7f5e7ed538b42ab36f025b665ec4c10bd02df0f823a60a0571d4bdf636c6e9d5de6e10ec522875b809ba00fde65c5c69ada27835fb19b0c186730cd9c4e4fe69060e63e42ceea656ee4988c6e8effb91958cbbee79949ccffdb695a2dd6c37cd13286fd7eba7b00480b19a57093013560b6c5a79eebae4801ee55bb4746f9149081bfad1bf3be15825097be097cb41138480b49f87006d3ea183c1819a73696623222d1e423d7828f1139f6e357f553cac24154d68853de14d56eb5c71a52a5afc81ba36a21dacebe8bd2ecffab184eecd84539f51bfcbd007eda9b7b0b6fb748410bcedcb66edcd642cfd6e5c5a88a28077d68f91b1027f8e3fe9cee9078bc982a6b0199202e089a5b4a2ffeaeef4344520b9ff88460a20975624f838481f489050a1b8a958a1648cbac27b95ecc6a8f51a1659260499b4b967c1993d4598ef6aa5801350fca3695e48fc84800687c8f51f17cdfe17d5bf75527f618b6765f3d641bed2cabf6310694566aba7dee33d63d0b2f010f848209841b5efe6408c249e4fc1604de38121488f52aac07566b2004a488c60849fa2af50e8deb616ad0fc36d5bed7275fe264544f920a6b7f7c74a67393b64089af7cfcc4ac84fdba355c177d0bcc5abd434251361bfd878b2f4172bcb4669ee037b2d1b52077d7bef04a1a28feb2614b8d704d1db55be6a9c43ada1240d696435c8eff9888fc5822afeadea55865276b59d311b1d701c4b368ab1ec5efea5635557c17812d634bba2fb9eb9393a21b1d7f344875a212835e77377ca7fb70f24fd6c4f4bdeb56305b0d7d551993597a8c7d13c441e597bb25db3599536f6612a3d4ec31007cf202bf50ad2a3cea5863b9aa92b9c1951390a985490d955e0166026303642c22658f79112aedff931ac0d5d47e875bb5fee0756982690f91ee99fd79acaff6eb79f2c713edc9512f737dbf581516f8c019d19744f7e4670f3fa85a54ceed9752745075e4e455bb175894a24d7763e5cfb9d38846f40be34bd015f8a3378baa01203bbe3258052b5e9485f1c854ee28d68197cc9f7342fa8e7afe88a45fa58ab95829814e1d632d43fe43c196adb17637003403ed099c4924b09d3e52aca7d4d220d788fec7221a09f2d67d55080ea5db589b147d0c3ecc72ff16ec8bee25a5c1e7e26fb90f7804a3f61d381c4477f38c54be22f22cdc31dddb408bd16a9ff074bec4d3076b2a6b4ca2c8509b6a97616fa64ee6f8bb62d1992549cb0ec0356200fffa1b94de98328a460197fa4814fc8fd591f8631aadb1adab11548e79c264fa9f3f7fd45dcb14f59fa62db2c1a3760af8e1261ba0adb33427c0fc1d8808d79d86216c551f9cc1fba82132b6235a669e1395e4162fff45fe8cbca03f2302555980d8d36bd2839a6bae4ae0ca107428fb105a6a3fb8dda33d0bdfa50eb7c8064b712e0ad54d02e0c0330a31514b028de22f79080a8b62cd3a92099bc745f5f1e11f8ed9a81797fe4300690ea401b3ae76478918fd1ae12eed01bfd560db0b6433909fa9627f56a1231ce82b545b203d7ba916d79c573c1d0c69de17c0899dc940b2a230a5e46407ede70b74c7371563aa3198c5c97417d630ab1442b8cfb465096e206f55522681062ee87f8e367345440eadfc16a41d774ffc5a4abf7038b39c29d9a78d470ca515ac41a8ac8c47a354028227980c310f3b6f587a2300fc578194143ed60f29a3a22ceaa11983cd94b4161ad22f6968874883a782aae37c55e81d3a415d8632ecd4619b9de24739a372168feed599f47eef3f25d23aa64ead730aa0bf803f42e80b4d213534158bd728b657e836e5d96767ec7f82aad6b19d95728a423b727aa59ef586fd04d667b67697db931745b5656633dab83ccb53105c93e0f8fedbec8a3cf649d0d16a591849cde78079928bf40509f6ed3b77cbe252eb10434681c74bfdfff909791e0a16b666f457642dcbe23cd9fccb98b5eab4e233c9b821ac6b726b770ead457ee31d1b64032d906150d7c58de97c4edc7764e19b9869bf4f81a84ab98239485aeeb820e2bb540d153f2c0c1645673c49816b5df9f5ed064566dad97faca6d0d4645c3d6adf61a257847f81a8501188e205a65b8906167e7af2d19db0f91943303b9ecef9f65a9436e8ffc493f4bd2ff323bfb2ce113ba4488bd6fdacf0b7a1884a88d8f02e231828146541f949eac7a9e5edef6a2a260a75823fe40c6625426725975bab53143f58cae372213e0845e8245ee3415dd1c40ca580bc35d52d715a37e397b668e1a8e27b20b4e83796c4c139e8d51bf8a9f6bbf847289fe510e7b914a5c8f886ddf913cb491764140fa6ca7b2fd3b40cd994187108861e9d636f9e13b53e0c306b39ea38ac5e316dd2456729a384398fe49292940d59f69adbc10c8e391b6a1972e2038dbce48309159bf16475b1cdbcb0af888a331ac6e7a2b99099ae4edfe3035f1a8a940f0e18fc08f965b754042c44c17173e845e13cea12ec1a92d07da8986b6ce968e4ee62c836b9faf1b007b1306b7a82ad80b0c791715d150ad0ee89a9d4ac27ea136229c482cc5d9d074a6630fbe1cab1a133fc7d1054ec7db8d64f737374056b0348e8a982566c393d8fef704d751f1e528543ca02c654b6516039ffd8dd08d528e614a2240b78d37dc97acb0bb7fec532a25309810139a5e6c3a8e2d8c0779f0fc5229ed3df5f0c6fb8430027fbe68327cf50c7546d523ac509875673690fb87e537f7e6727708e8eb7f7fed50fe3a2771f94023fdbc82c84cea28fa430cfde1557f2756d096b2a1ffc7457c2a9ec00284d05ac3af55d0e5442f7fe5275eb6ab02b5f674894054ed2ab46f6e5b9af7c11f711a53a14e2a33db3f94e071d46bb845842051e27986e72c2a3ccd2b027a0389c4a680991db3cbf4c76203476906ff6048d585a63d2c837d07c1c2a4566e56fb598c78a0b29726dfda769df8ed289a2a5c84fa6084d650e2b31755d6e3d658954a90d5379afd790afcd4ad240d9be97ca98b1d0cf47d7531e53c0fc43d0a1c4f58dc424c2e569cf05945999a99889ae11913da375c5ab488ec4cf790550640adf597befeebafc78e144aa1f756dd34b6c67302eaa341881d7a02e80d0734e8f7cde7f262d5181dba96430e7eed86e9d17e0397a867dbf737cf9abf0e99d56e8f5b31736698c0a277b01f7feeb380717892f83f063c252eb627593db4fc32a016c17138a0f7a14bfc3f8707b3b99e1676657acdbc983e38ef32b8715233193d40debcefa9a9f14d7e2d012a067d55cc0e8e90a8b79e172ec0c289da926ddf320694331305cef060240d0e0b25132b8eb51a1372ea77bf87ebae4064be02b7915694cb2b90dddd2878fbb5dd481012e746f7159706e8570aff6b121610d308584086b8542e03dbb3fc7f70d3c08a2a38ebcc9765fc58853675c6fbc9d5c04fb6d3f122e6f79d8c024a45726396f93509a0f35f9b0f5372dd41676a6474ccb2ae163723a168bd430a98ba887226eb853bd6b5372ffa0909a3443292009a9c37056a639d0f77197bab6c9b875e352b12f25ec93296f7433d6945d3cb394520fb8fc49d9edf403483cabeded57bc59da45ab602ea77226c65d0684779cf84ab99b31c853e1b87eb6262018b9a351abe222559adc8c99acf7073bc9c416727ce964eea81ed3aa7f3e00d08cb0827c63fb3fb51c8d50872b10b9d7f5cfcf7943628dc57f2825484f40bbf1ba2dcd7dfd6e55b27dff72e658ec4eed84e437c587630e31a429d750246d9c063ba2d043f59cb01496bdc443f3dde0b616494986ae737aa0cd60a69eb17cba3c6ee442089c2a4d2ca8c40baf0610ede8cc72d121296f84412ce61aaeb61e697022b2c177dc3452c83bbc5a3cdfbfc8a81c85d12f8699f674bc858cc288d2caf826aaa4e5e98debb4e7bbf2d7b443632b59196bd639dc6373e26d4ae899ab347f6cec89974d25806b21caffe9e2297b547c810b49885ab03ac1a4b250706beef1b5b27c56c0e80ebc4620ce32eaddf5f7423000a9515a9fdce063e996bf8fec4625ad03551c0b73107d88b7412402562e7fc3522279bc08f291d1a76b1fdf9de3e0450bbe429cf6bea75ae3db63a04049f54d1c55ccacf830bee201219ad23042bce3da245fd75b693a4549d9367675848ab402f3000e1a96688105d0e6d5d8abf1697c63c4f2a59f302042ac33c1560cc2765a0ffee269864935ddd484977e508b2bf107fb01cdd7cba855991d872f57fcb2f7ced512a55c82de4984b42797b889ee527622fbc97b64c44d5644ec72f2e1c387e31b4337f00281dd69f1c4afc24c2a5e2492a33dba9590c354bdf07738cef4c1e5eb269f7b27ea93b44a50fd2bfb556ed3f805dd5faa2b5270ea6286b8baac3e77abaab977b5cb1afc4282439e3bd99e94ca550a6eb083013539664777fd27f5f87d96c530adc7c42800779e477b6c8db8f025236d6a49c08cbce350fbb0fa998896c6a3b052de605b53f54ca2e2dd68fcc298bf9029db415d8bcea33265b0ed7bd07990536f0b7603843ca46c2ac7cba96e8a9ebf0c4011b0bb5610e1c47f734d3de7593e33d63761340851b2fdda0a77a369c2cdc562440358d38bce375cb82e0331d3a37e91b0deb16df8bfba660e5c860a2b0e7f988341cece9834072c8ba2f161096f7fdc097b812fba2b6258b8acc227eb275f3cc73ddf796180235983b20b62cbae7ff9c3d2311fdc66d7c74597b133ad8bbe2bf5e81661ca76030853900d8f1223fa391ed5df5219d17e247ce352c3d29b4cd4ff45ff65ef7ceeec1efe1fa00373edcd469c071d762e2017d96e42f5b10d77440a3f4c5cdf05ecdb923a71b4cfe57f887d06eafc772a44a76759a9a83dade9b804500a081d86c062a0e23c152d7f5cc64d0a75ebffd7f171890608ae4d7b341f5d112ac0c79ff969519f119ba3c394f4325ed6d99b3fb2219689786fce6bdedee54fbbc41ab2ec48cecb5478a56d6c6c6c275f1046b314f1ccc5c84d83d70498f3e18c091c9db76ef16b8577099fabf3bd80724902fb8f075466dc118d9f8e37052358f0d278e7c2f542fe44adc097160876f5443e234ad41be2f59c60eff67f9542c148775816e6ddc8e253a4a0a1055b22218b30fbe4a3697c5f1889dfeb5cbc139f623b6f4d8e20c8e486944eb877259d956a718d9f9d17d5b6b0694a5e0b41077ccf9ea20379657864e41175c456133663d93b6e268bf94e20df03b09450cb3139880f812424b33623d375600d3105c4f2166eebc6e190698e4a76c66a35980fd81ce025545a84a9af1234c19408a9b3dd5f29eadda9dc6189ee298ca3537d5534012612ff720b703f826af77abf052f40a28592cd7ffe97d30d0b5fa5498160082a06876853d138a7e539c75d91fed50975b2865a67e5f50ade81a798946661b2a31a734a6e22abf012446d0c5f30bbed0b8d86980d93f5b0adb187be331a604261266addf04ca936a9f50ae2e89baa9aa5a0d2c1a5bb324b5f29f4a5996f00525e675ce3465421aafca916d3be81ec67e34a7f794cfbda389bd2df4d235179b657db6790f5c22df5693273cc75d725f368e93eb04fb69fcf8fa36f745c8e68061d8527a2c497b8134788e5e20199389cd0c0e3b494e6efab017747b04d6d861098be7d3a471f116bd9ba238d5488c489c1066ffd45878233d063f6d07ab7800057b59646537c5677132996e615ec510cae9a76a44f1597ebbc0bfa2050f794d63c3782b3d7edb9d9db6692f0761255b83e8382044e8c71d345a047a53121c377b7e668d4f7e3053dcd603f0c022fdc9c4b5cb49da614f4f7c7da7b2251adfa968478ecceeee833a038d2ed2c660aeeafc3265eed00d372d2f35fdcdf31fb31b985e7f66480c489a1c81dca8c66fa0444099964c5d1c75b7b44388019d7104346d1d349de682d516ec85525022b8535c34a7761677f8971dbe0ec6c2332fde39627c497c62c25e5144b21c3aaf7101bb9acf8d6326be4156bf7a1a820145be8405884437f4b2e11af8d8b75dfe06a56256b765ee1697d44c6431277bd3d6270e62d87b55e720c652cd75727577f2dc24cf095c856a8d6e6d526717c957b69bbb6473d3865f1c4e5b0bb66d8fa20f493fc6e77f2705f6ecdd684cf742ef01ec52885a5136f04b785650b2628fea980fb825d2799ceef7f96976328e223a9d357cbdc9dae33583833ba4b9262e5053bd609bc198b66ce328ea10e0fc96ae0a658dd3cf115fd77ac3d45cd984be0dad459d3f7028f7e7174412ed81e21e2d701b1e92a7bc80030c6b96195ea81d02a7810fde8d9d6d6d99078f8fd7f6cbffc3051006f55786e71851d32b1504b350b7546d797eef5257654d0a5a5f3c1007f1879392bd3ce4b7f21d9863b43cf6bed5e9fdfbb92eaba89c753bb72dd9d38278140df2576bb266175b5ecba1c849059daef30faf082ca45359e62e9e320924102fcadeb2b09933076aa9f35b4a58dfaa141f9e9ad1d24cb606dd3095f450dfd0d534e1337983363845c1d49e9b61b5c65ca3aafe6d553c59a920b2d64738b9b35a49eb471979b8ea97a14cc3239681edf43e3de0cc28109795c018b17bc186e60f4ef1b79e3107d285bf17efa7c26b049073cb1a2905f147098dd57c1e2f366f0e99829f519fcd39a0f4ea921fd895570332b24317f1068587fe8eb09b3eead025dadd131f5836034c2d6a87dec301404b39662e0753e2eb842c17aca927c5f8edd4c3fe81f679c281b099f1e322881bfc64b4ea3b30e3326da1c7b969233019342738f91e834e78ef0e7d570181d1e25747670c2857548857eb382c2ce314a605c5a8be6ca67e96da05588d2f82f5ee5642ba6795958ad7db4b60fa233dcf7d509465e6db5ca1ce3077ef33c6f1403e50d437a3c761acd8156a8631a49651746e7aa1201bca718de39921840e3676efc4d085fc6c8c22c774b523a13efa70b2a4217b36367c84ff56250257d2b90bd9975e8de4c4f04be3524a54215941f825bbd74c3d1fbfd669273c47cc5a46203f8e6ee8591ea3e2b505d07906abe61bae5b43f8cb01b0cd26fdec6b5503e2a0396a6c72340e0f40ab1f92c2c592be98355ed5773cc9eb45bdf3283d9b46ed6a6307227ddf817b08326773f1729211c1fb298b59ceb9edd6417af8511995b6d2c2cc68064f8a0ca3fe979e261fe50e6c229572dd8192b5cf667d5066f568107de4d88cc29161267b3b231c688093f75c484db19ae7f45417b2c5e7bd12fefeba78526bd7cb7ac0e1ce1b16ba6b9f6f2bc05f1aa12b6d65ebc5bdf70fcbb098d4a81a3bbf6a060045fffec5219b340043404e3ed294102f505f112ecfab236532b0ec15d73041ee1839cbc1e74971023078bd926c2f78a49664090e21e9ce9668b55f61efb997ddb25509b4d06677b3df227163834f8817ba3ece08cccbe684d34a805a806dcc80486be721283c56a22493167d8a7a8423905825bda757c476f139f5df719ea935c74b35baf674c306a51ba1b74370a86f72ad7703a4f2822493474e47a7289add6da19bd66b2518ec2eb188f314bef3e7e65538d53df6732c2cdcd963f6151b90cce88f8124b036d30d66d1fdfc6ea7ebe712f4371ed981264583d75ac7597732649e443a98cc43ec709141dc2d939af586b2fee81cfda16282decb91a8ef311d6086ed041a7b0c2618a24b07d489c54dd68346977cdfc85fbaee3ff87e8c0626098eadc10458895503794907e1eede66d3a40496a55dd9d6710fef092b90ee579d2dc88b1997da49de1a8ae00c9809fd018d1639910d9ee287cd4804293ff7e5f14d5ecd105c9ba2eb631e202296193eb2b99ac307d2a0237f3f0297d36e620e320854508c196cf9714aad27cd9c23bb8c50b4bb8ec4f24703cc7c63cf03779e430696aa7dafedfada1990a698f41996170f7089b15b568c51d9c4fb132d5fa706da34e16fa5c4de245243d2b5d5fa1d828b01086a9326d34b8276d7cc5ed365b32df6066bfbcdfa57df09752c794c70fee5991f842fc5375c6b0c474e64c277da76557634615bfc77194ebd0879aaf78baad8cd1b71cae1d8f4b129e54d1ec0afded3cc2f7c306a51de9492f87b53079c069e155f7770fcf92867da30174caeff6e216ad4475bbbb22e4bd71a90409428864e7b562a7641c5c9bc7172421b2ba4753925890a892eb058823c8638f1ce506a791453072f3c0a23bd0764e40a429368b960e25d4fbb595114bcb672c476e51a295d8a83548bd3a6875ad5071a532caa63514cc3ee04d7201ee3262bd15eeeb988667872120b54a5b1775ecb8bf0dc0b02e064f1ac1f269333f12d0668e9112816ad6f7cb153844ae92030edf710c7dc773c6374f011d53eb115c49aa002e9e2a9fca58e5de49c9658b33632d1a30a72221cb092ee83765b79f207426aa5d9d90866bd135cf06ea8b46a925b11a04e7c3af7c4abc728bfe250b01538300370308219575669cd128056cd6a2a97765d4d0bbced5ed6d5d88e5079760f6487bd5fdbc4cbf68ff9ebde5dbd1c1d5a188a1bd74bd1f248377a1935815d919fc2b67f06dec80251956ee12dd93329469511a2406d75099877dc1bbe56b9df10d804696c3ea32cc821cbbbac26d9a56b5e323a6a59763b2e4fb220a4a1cc7179296d1373b49570a6728946a6027fa952ef2b1fb3dfa522af6776d02ec1da3ca0ab31bc02c135206bc5f1bd7e4c5850df80222951624569d2d8dc7e4f344262507820ee145d5ed9a514bfeefa63757b8dc811be51e6b500b53b4dd49b38c4025dad1b6aa5c7b04a3e9b69bc0426176c1fbf71ae98e95976b324addd1faa181cfc83dc7fa85c0e30d9beeb3fb31cf0ddea850f493eade6eca301909c2d5256e49ed536e6c6a7b5c4935ccb3ebc72ff207b8fb90f0dd904f621050d6239479add14c8e48ad77598f73ab799f6c4350b7a6699d5a76a8c5a1b3d8a265c82d3750cd335308beb4ef4701e8b5f0090cc21ea82f2fe27f5795b8cc6a71d13fabdea98dc8283369454ca01770cc7b90a7e96b0ae94d95179a681e150b01fe5c63820842d0d4fc79fca82827c9bd4b722f13398a080e2f1a55ee5e069d79a4b6234961cbcb524bbde1a6e07224b3d2a566b0ceefea00d82e62e715214aa6cd4c1cfdccbda4eab4ed17c98f670657cb25f2fb69df204e94bdb4f6410fe4c52bd0523db1931ccabe4e5e00bb01481c2fbd743adda9fc3cac599d160a4da74013c5deed11da3ab2c8e20c6537aa0eb5152ea51262a691fe8f7a71fe54510e5da79662b1fe90c81c9be06acc0520be6e8d168b3f0a197e0c60daeb46eeefd314276d9f73f141efb01181547dbb04e84e04d34e76bde12c2ae20922e032ae4b28f73f0387740a327af53adc24ae16bcaec10c68e8b43e34d8d2e97578c332e88a0c5f0f1d4eb5c4d260bfedf1c9e962ca7c3b8cb8f7622c4989a5035d3746d92fd2c2d1fec47a2a0bb3e8874e89527c3d8b1ec7aeafe3d13a18ae7cd274408dea93ee8e062c591373205ea43d5a6daf39a7c9ff506b0095bc8385887b8d83f1b8a703dcfcd00580b5fd8d7b394701dd7374a03c7b867cbfb285034451e712a388870dd17bf878c3ceade99f39b2aa9247e790b8e0137e4c3b3af8ca28f931312a23d094c77ef56e7435e65895695b8485ed3f67b4f5fc1f1d5e9142564f707202c811958cbc3610df99e8885e29dde8e419c9ab1fe0b1d78f406348943f7d1a720665e2833a6c9609027767b279dd005fd2b9bb9e7336282c563b0da95aedbafd51ac42219743364c7f60654e5b4a793228ee37811f15d708b3206f2f1547775e684ef0fd818b196554c580034e7527fe3aca269b781d457affb1e45e491fbcf0fe4925f79edf7ee34cd87ee96d88d247b37e1657b5ab3b3223c64c8afcc64a57005584688c0536463a4c7e15e40e9e03c99ecf0e81149b571c7920f6281dc1b212482bf0fbd2db3d52b3d241b23d8b8440c5f692f19a98b36e7437c34feb3d119213412a30df126cecf883287cf7a2aeee5e56616758555f218f60724fb84d909aca6e12d56d2ba60ec92e6278a3331a4b554ba9008e4273ea37f5f451e4707d17c413768155438b18a6f37bb3c2ddf13eac384af981845a7aa8ff515839cad00d2f502a2af91594d946362d7a9ba1b3f2eed29ee7fdf8e8f67c661091a6ba30ddbd87fc4bfcbad82eee4318af9903865b7b70570aa9d8b6b44e9aaa2021bddf1767c8040877b42633aebb44ba6e28a3f5964eeab17433d7b288ce3a606960f7d4d96cbbf52c75e286a0b2b3627ab155f5121e121511353fc6b27364977f8325151aa827e923f8b998aa384fffb1a489917ec83fe9af801d2770b7b71e27c9f6f497f7ef7ee0854ea00213fe2ab061c5397c97604ddfb7a1bf367a935765631a2877acae27da98a28a738a5173ff8c37284dcd74ed8fa2ca710b8a8e9890d643df637256fea16ccbc9153aeebfe65c6b92f641548b74df3c9a72625ce291bb90008bad72a01a3ae1207d706005dbde67ffc7e68164125498a6146e0924537d09f67f46864545176ec877ad3e38684bcab8d756985d2fb67c88db658adc0937966af87ffca243307b500f08fd126d88036f1c37b931eaa3703bb25fa5868a61df0ce6b7e766f5c939c417fd6757c0f1597ebf82d6660eb7989186851a007084624bae2ed73c17a0df2e79d4c1289a22413cc3351f7a3681e0cce8b57759d0dcdd76ecee38056c04587189b97c2c2781f07cf96f483ca221beb1014890316a7ef556da2076b56c1076146af05cbae690884be0c01021bfd02e3cf9692347cf65366b7d59115c8bb273fffae87846f2b104e022f3be76eda139c6b26e99e0479582672c3dc7cc2d1a854d6b6fc63ca23376ef6d1132815a180cce63653c8e6bb27d088611b85040932a186d2022bd825634ac53230106b33bfd170124f8c26c600fffcc0168ba6f79f49d833782b5a8ee8202353d4f96afac222fc7b4b9d3bcfddff0812c2ed32cbed6a4a42f51c402419ed2ec26655fc636a07dfe7dafc651ef13f3fec5c5ec6f5b58934f22808ceb0e845b0ff7aa6d27fad4a311895838a76b12192b9e977ce663e1bca410cd2e6287c586a7eb1cf4e888a8bd9198b0821745bb65f207d0750af0d20925ce77997899a1a82ea1db92d10efb0586d10c6dfe8a5e2acad9910fdf364d73e360277a5fc0a6b9e37d9416e12e8007d0c8c730925e8b5c9b9c32b408c9a16b9122ec24ee1cb0047759c3155a90d1065fdd0ab5460ac5da21e9c7a117d6b671ea9bb5ec366a389de0bc2d6c168405b205f3dac8d7fbd5d976c56b6d3ec5c6170f3f5f2b36fd90eda4363f2ace41e2e664a9554d05ab2de1980dc1015d54e8027876544a176ad7cbaf129603f395d39a26c867dd6a6ee84b3f91df3f8cc230c6ccda765d307f205f206981d36aad52caae4b67272fb70e33b3ae68bd320ded3a9db39adf4e82d6cc7e884616d3347b168f98abec787fd224a48d6a75771301e7ab2c0aa9fb682e4e657a40098c4825fd9dbf94582dc3eecbb5e80d9f7078413c08d6980b8e4c45655f3efa19a8669f3781309dd20fce3576819c96881fac831b7b1bc0f57410d15050b220c4cab993e68fcf5f7000379ee6ad5b9c6cc66fa01f862d9b60a09b1b07773118ecb543da87169af472e9ba24bd5ea88974f0c2157682a73e0bcfd252df3f3646722b87f8c17dc6961a4faefe42508bccde170b736f943250d2d3468be95253520e06c2f198f2df3d1c3528388b428d5dbedc7dd7b2e4cea28bf6d06a97b46eeec658c858ae434ef5bed412a3b980979ba7a79573642822794d0058ab3cb86a7d21166258e35e688bd1ddab327f32b9850b4058a6dbb8ff78580a397a911e178cfb60a323c81ddb4a2310407100208edbc29526dbe6d78de1caf4b964bb4f402ac3fd2e8630f83144445ff5f1320d0f1ed63788554a9e6ecbf1ce01cb1640e8872d5419369bd4196a556b4243c9d7a9654090e1929f4cf2617978e3ae2121e3c021bc48d490b0a4680e12f589af13cfb0ce7128ee8b924f4e8425be8e61330f89cd2b4ba300dcf32bbb6e001593792259d270fda09eea5dbbc7d9382a43e4b22e802657a4b00ab561e5b613346ff9e0d8b11631a2585285745ad727df41fbec0a52207e388ba0290d58f69f64fe325e30181e804e4c9c60b22afe629a23ebf992c98ce3b839e58f85cdc1fb19bf76f49efe5307252002a635c4c75889d5baefefe98712992ce33cf1074c76b049e8cca49b30f0dfedb9975b8be06bb742904fc3a61125389cfad76ba20dc62395be7b4498b2691f804ff240035c447c742c124af2a4ee390c8e63c6051be4bb87d49b2f837528e6ad36333a303574ecfe83d7c8b217a07fcb72c7b25c7451fd842fda3d8f6637655d3b01afe8e48a859b676d9f7baeea60b677f215b815ff2c947ff70f7e56f121cc46141cf845d61ed9922e5b772dc4966c5b717e45b25e4dad5a8989301902428e2f5589d6cab166fda984c793d0762962a37a8e39307a45ce7e88566ad49eae1012b710f8db3f055b071fdc5cbca253a208817332c053243f166a41e9a23f302e07ca92501845cce598fbdfbf10fabcba1ab1f893dc839a426d8221164038ee7a3bb24495fc34fc7fe78b7f194b9545e1cd8c1c7a8a1a24f97b9bef7503d1d63e8d9c3a34ee44c786b9801c3433bad95061bc43c5a377c92da5ae6acac3612c0e9a14283fff5a35d4ea61afa6ab6bb3599cff1057651cc2ccd4927179a6b0400b2c04d7f02eba64e7801b8fe3344eff41727efba3ff531927242eb7d16bf1ed45d4e5d59348145a56302ea2985f5c617c9347c7c1e21ea49421ba8ce3b3cf0d52e37a81eea884aa652c232162a355824da53afabc86cb07b8c9466f66bd9d653fd9542f6af8b16dfb5bbd9fdf0644d62f1799ca491b844f0f82285ec12547fe065ab8b44c5bd469c2fbd8e5bb7701d3da803ffa8414e4a2506dfb245e554e5beac1f5028fd8a1ee41c802015ecc85a525bfeb4b21fae210ac5b64dbecd9c03f47218d2cc64c8e7f1b70f051400403396b0fb2daa5a387810317993804b1ec9ed69d995511ec727ed267690337e350c35f2ee2b57732ab9334045f21797bd5f61ee3b01f439c6696af2c8bc3dfabd22c275b5b923a8d9329cb1a95fc032834a5fee93052b4a1e1f7cf4f7054bcbf244760e2c666e2e1a2cf334735ca52a3eabac241b26f907dff111b56c59f45fe0d9a78ccfe04d76584ffdf1e3140e85574413b9964491ea9f8a84068d89bc46d5f20fc7fd04358d03ccf26477faac736ebc5d700e8aed2806cda7e464291084fa719eb67b92e473f07d4c0af118da815c82241bf32603a50242c074a68e17920461e9c2335fccbc78136a2d3ab7d396baa7a73eaee0cc7dcb2bc603e9876f71b835a3a58c42b38ba965e61fe66ac6741f80de259e72193ef27002ca32c939530fd426228cc65b492c9e677795e5c780a354b6b033acb1ec98fae083f61b954eddbb0023cada6468a3ba0c95363abf7132ef61678d0f3f6c49b1c25355e9d80895ba0d2fde3f16f4685a26434a62aac1a09189297526bc6d5128887adb05b27fedf0f037ddda072005ee1bc888d2654adaf5dedc5f777790def26481a4644a23842ef20e4e8726e683fa7018afe0a51077c0bccb87189e7c712b40aab7952e1623d0af6297d6c6a9b5e6baec441ee5e024e3cd450786d23a6959a9ab7ae04c612b32d96eea65068779e1fe33b9514410464f97c3772017b0ad1c61023a5e42202abe740f06fc5592d13fe7294eb2d073cdaab3d1ec7b0caa199b74b1bdf3c0a205d44a5c296091515b2d1bf2b0e7e89e87b40dcdabfdb8aad7d072238266bbce5ad8ad74722bd83dabd8f73873e52905453393ddba33ce9c0957affa09952207271206280308aa787b508f244a2aef78c1e96b8fefdf93c3d80f46dd938b3938fb7d61243c04a5e4bf4d3594f0cbb9a927a27089474baec6f761b4c488d89f4f74cebeac4d713b34175f969132e7889e84a56a3c30f5d9b7caf57b71b025051fa9b42907c61903e3da43eb653729254546a83e15fd451f6c0dcb2598566afb45b15285d34c4b7805ef1fddb698e3f488b137471f168fcafe92cbdfd92c5736db67b439334178228931b7ec1e08a5098342609af136193f8b53227a3d09aa0322f60eb215e4ad4b90fd31cf15bc5ae4c577fdd72a8c198c741481c77245d4507af6d0a4ad3a52455bcf8291ec5cdb230a4e9f02ff1b9e984a5f572a4a15fd3e8efd15e54d4c3fe004703b3078da54280f299b6863789f2cf7d568429d6044ba88cadec9db3b8edc3d94b762eb20e6609070a921c515ef52b52be5913c08bd56b0632f337a2f45fd6f411c4635d26df363b5eb14b43859654bc7eb5cf6a53d354fda01b9f6dd7d84b31a31c05601eccc057ac02ca138efdc7b928cc5f65063c75a03cd3dab35fa0cba4c0f3571e67a7c0dcf09135fae067b50367534dde0fc448bc5619c23cb62cc4fae2823d75a19ce1e84763b3f88721a519c2312a762f6915c0c67188e27783eacd4f5fef6d79e74f23e12c6f7c9a149d013a37b34dff19bb0f7605c778ac2ebeaec2cb11b55e65ea370cceaa8a470d0c374862cb981a90984799bbde7338f7b29e54083e367acea784fbd5541c48fe100e8d097acb39e15b49a9a95c3fcb586bb0a01c6c5786588c2a6c606c0838350a1fc6f1abb31f87d981cdcec8dbf68e8634ddafe4678522f4674cb738844254c9b6e2c74a7a11ab9ec2e7228ca7f68d2ba00ffd9ca78d1d76036d65d82bc39209e444e477ab72fb3f863491253378b023232ca7ba7ed5dffa0ec41b43a22cc53b1f9c74e08f255159ddc50962d885cc106b1b13960c5b298c5e68b5fc6eac8ec45f97677faf9b1c5dde66f97ec9e326f8a4a064abb5db2bc7f3b64ae54c66178c6ae7fc262eee415b520bc27a0f443d5937a8767d7e4783412b70a9bab9de7258581c7f59242e880c718c9f146c0b556fa5e9f6e93eb1786f2fb2cf5ab2eddac9b1d1004997414f43101fa20555bb0bced5c31c32afc45d8e9c0b3fb4513223dff464ce4cee14c3d97e1f88eb824f27b101ba8d5abf41cb495fcec24509e7f361f06360f401a945fdf74706ea6bcaa418f0962185737d236b12f5a35cb832dc708d747345b26c243731f41698c92464c8c16646e0f86140fe06df7f6463bf136b8e86fc0b1bc4d7237dc0ecf74a4ae5dec5d0b05faef5982d79484a4f6c8a9349754ba1449fdd45fd6734961af8e3a3165b79ef5f111159759575821bde5f7beb8d3b41f0a7a4998e371cc4ac772fded1528c040435c0208986c455d67f50a70dd3e0547f4e9058c3207f08e610dd7c7dfb91bb25ac6573505326a7b79bfacc9ca2535ce32dee9b9b597177c7f4ab85d7899d58f0dd4711b3b4eba02381bea3cfc793e49bf75ab4753e86e243cbe0bae01a0d2aa1e8d0a608a2ba7df367893942064209a5ba00a4180fb8b1b1042957399a82cc56f592811aa36ee82096dc6e0d82ffbc3788b14c645021b56e889761ae21fdaa5f4b4a0415813fb12261f70f661d91680a41fd64856fc3af760dcb5423f5f212ab0a7f8f67f44c2b040b8101f9dbd497f49e8e49c8eee3a7337fb4b56f00716afda7404cd66c4dc7769c8c0c58b80206c65c7355213b0e150003c9cef7440d4bf09756ef41453b55b6","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
