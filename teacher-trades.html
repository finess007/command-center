<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"27567abc1a55148bdbd213b1efc416378a9569104e3b7af141db614d374dd7d43b2a0611442e45039b88564cef8797a095a235a51df83ef1e859453b91c32766e69154762df3070d18294e66648a5a7f6ca9415d2d8c40f57bc236b5983b5f38c82200d6fcb6629c8d948ea68e5ca1bd7e64161d5678eab4f4dfa3cafc5e3b1b58e97beddc8451b6919c00e3a1347f090a0b6061759585b81891ad51091fbd8ccee2e1a0d4449fbcc5d68d0abfc6026b949af5a3d357b277e3674a8945413fe1f38ae3d8bb5a5c6b35bc6f6847c69e709874fdf0a3cc6fc0595dc4f995ce711168cf65b2cffe09a7788f0910ebb3096b096012ba4fcbf4498aebd931c699ebe8f05b6c5c9a2bad49239bcf2075affba09499cde1a671cc1db1efbd89cc6d4c3c8e03b6dc8bbab29dc42ca5d8e0898976755b47a34b230d94243ead79a3e220785cb85ea342d4de9bced3d002480c6bd1692d1e6633df5aa46eead0fe218c41832e900fb10e38406190c92fc535ccb51ac6bd0668f6e6946f95762c5abee9a34b2d804044bb5a8ac94d501e33cc0a91bb2cc5344430b83ddb9eeeaae1bbf9d76f27934cd111836dcddad0459e6485f9f4a64b464eefbd874d79302a4327aaba5aab969b8c495c56b08f4e98af08ebec3bf46db28a6d8ff03d7381ac6f8142c7d30b0a7c4d887944670c113d10312158dc3b5eb32aff3bef2042cbeb20a01ac2c6235618a394faaf752bfd99df3bd946ba71fd2e680fd12af3ea4cf66267f11bd9ce1271a31f856182af3b5d3e697809bcb8d0a1959efbc538effafa7bc93d2e21d9d371435ed4216d2f4ac67e88289edd533bd3824a6fc99186fd962d4af2fdf3a989f024b6b8026ab91f1f915db7d2b58398fab02e390c6297645470498f554c12fd64f0e25c2be6864005e303656a29201c1f9250f1b330f8a2cd01fdc421c7e3012eeb5838ae446d7e8fc3dd0261f7f2c7dbd26542dc6257545ee5862e7102f79daed9aa75d8ee34e60420155baea5afbd0449d4f74dac8aad8b0134c016a7922c6f93d83a23310b79c5b1feb077b7982c1905a6af59ab46316a7c423d33b4a47eca3413cef00f525b6a84ca219a0fcc795b4722dd5e17b9861d4f2f4c9d2b1e6819572c2e90885683ed2a86eba3f8621dfe5ebd4e2f1a276da615cc8e2e559a6fc81419209a56b1744e79a651cd71545420a0b6f71e8dfb889a98eb61f55e66dbd8de28ca3caf8042012e1c900f4d70a28c79e2da469882248963d3a449a8107c07ebd966ad8b2b99432a5e93b424341be7a3f6c83216df9a12026f24834d0af8091f81af29f0ab2ca834e8ac6a9e19fec635e22dd03bd58f968d1f91f23b5e2690509d49590d25db27f07e2373efac7e4a0b8ba8168dfde5dbdf53d943a659642343e522dbdb738652454527b4efc980e79948ad095e454e9161943cb5e82220c51e6b260e4329b8ef1f68d623c8bc87805838cb4ad6f68c78ba13dc6f8b331ea21b831e9bf73c317e02d52db618e2abb32790bba7d17bf94da7a3df41c663c19b0979c2849fee0d2da4b8414aa36437655e64fbad4c3fa42bedaed142cda62c67dc5e325bfce5ef13cac006850e7a62d773f797343931a98a66564107327970e311e4bb1ccd9a17db416a7a1a3e04247fea8b55eac02571b87b484a83f43d6b5bb3c5ee37f4dcbc58c2eab385079de807c40fbc0afe8a786714ed441b823cf17288798c923bbe69867a02d35c8fbc54bb8a2531fb3d543e3733528374aa5b6fd90f5fd6eebf5642d90f1d7ec1f00762b15aaefb37b9d3ce8e09a15d24cc9cbec545b68bafaf92f056ea5e9073d2432bc4ace72aed1e8625d05db01f33ed77a2ce5aebe0c1932675ee348624ce0fb9efd910e244816eab67e8f4e6eadf169dab2aeda74f0ad563e1eac945715f4772f63bd832b71858823ac6fc129477f930c8f2293eeeda6872d94ca22a189a97b967768fcbd3de312d281b39af11b3253e674b46aa4753227d7d11c10f7e6925e40c896bb8e892f3f37309d3b28f85b757b902c577454e520f5bc4c65d3f6d62cf60dc3aa3e00ce158bc76f9ce5325fdbd75c3941b873600f3f97762b82859ffe2f1c59ab82e04c8ca9cbdd309e2e49738de7f56937157d48c3ca164e26a8bf19fda283d216486349040644bb88070b4230566d5ca927b98a4b3c0886089440a694bad7b0119c1f93199c760a880d6f731281a8ef46fc6939d753ebfcb1b6990d1cfa69d51252954f3be4d25ea73b62050fa7c19769c5506f9d67cddd73145a19d7a606983e826c8cb161548fcc805fc17177aab945a8d9075bccb6630ce6ee18e385de809bea8cabaeb8ba9a134dc5c25c6f0532a0dbd173ca272c0b4ee783da3c5ebeb4bcd6b89a1d33da28532dac15043816372d0da075ccb444fa8143923a71c56cd3e6bd6d0c09446340b927cc9e2111bd95420a0b2764d72b393fff8d0a4246fe2d8779c358acbe03101bae463c8ad446ecb5666edb5825f265370dc26062de496817dca4a3a09a2be39a6ca9ea547d63f9ef2caebd8f16773273fc7f81c3d2fa6c8a7195344df122e35fb22a62c3194a33235d00a2b7431473969b0d98b42908c7b003b04739fea4db3607570ad65f14b61ffa1fc78fc527bfd40b602db4c7c05b92082eb5c6dbf43df08b47baca675a45b56987b25092ba6d0834eed53c250c9792c56c4af2da5441cb6d761502d7f3381201bced3750f36ed260c699a2b836e193dee385e1b270933bba10e3e4fcd7c105b4159bfb8218249d3f67cd369ba86060b730b44b74385c08febfe6606dd30658babb554e133959038297968221463abd02836b27b894919907e769bc5e4d873f9e62972e4af7f8f76fb205c07c0322e4408997c48a401f27d244d91439c5923986a635894916ebe0fdf148a80f1ab32e6610a00191b5fc09c167cd3e62ae65b23d2197065724d43490a428941ccb122bd85cadbb1940d6c31cbf84852dd6b377cf808663f1d7a9fa1fc27346f97abb9a6d675dc3fd40a9aa72e72e64f75dca7b8dc2bee3275db175b7d6f313cffd506029e293364876be161f616f2ee33f17832a1f78fd5c01f0af1704aaf815e8425bd37e75ec466c01151d7f126568ec84e4a384b0864902a7b6d3f248ba1998e735d9065362a76325a41b6ab9072776b9b392a058452882bfa5dd33154e44b2e64d6ea8b6fca5838436014f57fc6c23c7b4a4bf74937fff9e9357437af79cbb136ec4bba54e5accd8e4c66bfb34e00c0c29b5c14101958696e3a052ea16075e7b1d60eddfada4d71750f397103dad4047a8180ac60619d7f5dc275f00fca4c961cdff99c8ccba611040bdfb121d9ee6fb29fc0e6be9a57a55e67835bb5c1fa55fd4b4b9e13c105ed6531923b1406dd0f6b9bc23919a80f9bd1cdf39714b8987ed92dd61d21387b4453b03ae989106f652361439b04711c2d4270e8d1b4832769a5c5d856715561b10d6cb4c276adc62c241bb628e12b8640f31718d9a617badc8a080e3ac07eb7f924c29939278134b066a88349edf35d2c7826f122661f91a8033dbcf8d6bf8e23c4d0d8b7e2adfaba68c9de778b727d74461d2612124f07eaca8058231fb14fe11a5e7ab6a445d6a3ac4b11249a6135f1cb1a336ef7c58e56490e8ba1136ed53a7c6649e0b1c2a383df2ec756853f3d8fdbbdcdbc2ff8eae535736d14fd6f3e547cf647a0d3011cd8e09a046fdaf3d9600536fdad9a76b2114bd1f07c771e9a124e0ee0e8a16d20fff53c92565590cbe052b8abf14e9c34b15111b79b57061efebbfbf1399b1327c99b474a131c5bbe88ac53dc14238dbd233335bdea2c9ef5076d019750bb87a72741f64d7f8a6f1f20d8e09d0ab19742a1feeb68275ab4b124ffe5c8d81234078425c80ce29c0184d5b4decd9f392361d910c734aa103f6f1a8653ee963d81d1970c348eb8ca02ff24fa9f0127e7b67c0c3d7b8a198c37ff927bd6ccaa70b090f1f1c7e0b0155217a4e780a289b0fcb81a25ec8417043cca6f3eddb2163c078b01565c9100afda1e1eae7c2e1fba168431caa0a6e6d643952b0bd2302634c5a6bff9850e55c6530fe655a111c55a42b93be8561b68a66e2f77c0ba5859bf5b7d96a30b0279a18b2343db5613ec4173d76be55c404b1d622b3cbeb8df93fa01ebce313f9915a40b7dd528b4e70af7f4fb12f88735e52c75ce83ace4ac2d3eb8a33e58348c3a6bd021c6b9db72a44a49dfd05e982df0f221f0418eea13fb175bedbfe139dca9585a9751e1519a83c618e79cd08e924ba77ec87b4465c55e771cca2e7f45b2359729f1178a42384365428c83d750472dfa526ff1e33006c99cb57b6737d8d413c8c690a801563719eaede506872061af858da307a69a5900069c4665aae1286a3d1addc3f5d4090851e9cc420d782312f9f55b6eb162e95030535db25de3952b82a644ce4a7e1acf3c4b451c6fbbd2e538535025dad6b5223bba2bac9a9cce58a0ec9418d640d2624bdc848b92f2f57f7b5631f58e3d4d281732950c5ac42979eeab244f9093c7e3aac4d8fcefeb05b58b5ff4bb52c95c1552fa9db5948db2b68ca4b2880ec19c208b2b064700ac2d4c514febc38b706e6c950c82dc5d5ac9650c5df339b201af85ee996dfe187696d43f5a619210b1a0fa4356bd33ebb4a346792bf29ef7bd6969e7c3d4374713619635949ff06f013a0df397e06ca6b4e12898d13003b8c01e092b6137b6e76faac9e0939d63d330554b1fb270e1454e521c2237ce203249fa269fe3bca74353f148ef2e29378d8b19ed3330c2bb106b782c467b49d1712cae71de3e9f2c84b7b4d5c58fc44e85afa74f908425fe6f5bb548f4e60dc836762fa0f36a9af33dc0dc635a6f114e6db21071ddcba0ac31ed4615ff5b2444be5ae920c38dfd8006d5c1e468ee5813ed66c2be04175856e03529d70cff1cf413d2042404a968078d0024cd401f243356baa3b675d1f07ceebbe3873eb04412968e857881ff13b0b05666c7645fb5b3491cb4cf662962db55213ac6af5e58dd911310baeca3716ea4febe813d351b8e294c21a5d8920e9d83f7e4f8eec39440627d446559b6817e9e2ce06027ded2ef121c1e2a86dc08a16dd18e165de586cb2fa045ff9d49250aa78f15e86f648ab5566ff14f136adb95aa9fc9b00823efc75e636a3ebafd818abcb2ebf65fa2ea57232a7df4cd81933f05505dabf9340edcafc54086e5c44bd0ed4ebed626de9d0e55d7e1b1df4e52cb201cea254038604d643b32561cd2331c517c9b1fc6fbc6ae920ed2f0e15c4179ef82ccda7de58241c237e7477ac6708c3800a2af0b259d2bff857c1d0399c7f4295d5579e6949a95c8650cf5b34540867d5e0a0cfa1b0da38e617014f2e452b5707f4219c446163cc4c5c85e0fdc30257d4e698bdfb414d46a745b8ae4230834abb17f96ce13127ce65feea6d8a8b837045be0134b15bfc628ba4f71e11977387decaed8723f62b50a3722068621e46d97d1096acdd7ad9ee429bb2e960d99e55d2eaca527aaa1b2fa82696c5a42b65e5531e4d5bc4dc8d27402223e0746e59f0a2462e66144c4873530cd5e5fb592e78e1e101e7a7f201bf9e2ffaf6bbb3a49304b4e9814303f595776cc8e985ed6b86254814167ed7bad1a6c3a9a392111a8a4afc59e1ae4d9cce7540f28592f9cb8e9d9a26b015b9774899c214ef99d23ce20c0a03d86c75be9d7bb1f661aff9e247272ab11c6e975efc3624eb7a4d8a4142dfd1caf7b208080009625cafad51dc68ff29d05eb7deb75997144897aa54859d9a8344df6fa40a7ca96ad83542dea2bc3587363e25936d8622d96d02bc33303a0891e434f71645e3d949d16bcf1c8a4975f720de6697d4b3ba744a69848c0fb0cfc63c3542bf9f242d70c092e4e75817e0e574b552e1f98037fd76c1154e68a71dc4eb2cd1942a7abb3907ac20c61b010d07959efaa819db2139bd7ddce24f2257b4242a84ca60d6c7033741bfd77c87fdf42507157c732912ca0e1c571f1ba7513bc953a6c66298c182c177ad1132bfa7c2d9e1cfad9e8ee3915fbbace68699cdc0b6849e4a7fa0717267296d9dff72b00807b81b7e05278fc465a5f850b02834ba1d820030430616ec27f0a3792bcbe119709a56c980f78bd14e8f03eaa93bbfea61beb8756fbe3eb023f78a77b198b1373a2db09338871dfcb32429f3153dc5fe26263d7724715f13328bffcad893686ef31dcab4ade2f38dcd95650ad2a3ccca7bc15dc70c4b95eb3e3adfe9aaf22bb6caaf5c9b968f3aac222069150d3fc384d17a2a16e6cc91105c417898bab6265719f9c0ef7763a3ca7723bef88ae634c1b149c577dc156e76b9794108f6e23c26512aaaa16058f4d5dfc8fad7dae3aab0fdb9d0fd18dae1f08b2931fab2922d10114c6e87bc3e8d45700bd6b352d3458f68b258af1932bd35494fa55d90ac1f7b1eaae3a1292e540592ebf4ff1b8de904e10dbc563a6bfbebea1ebfc8a4583bbbbfb5bd6bd4226dcc5ae29c05c518d19ee9549a303f5ed708b17fbaa377f33d0f99ddb8eda35c03a3358fa3e5391052f4928ad1458b201c7aae6b8306253234445de47160bda77064a462e768d82024af1f66abc7a83aa182f261ab8c39e8e2f87777e6a733e847cc9466bc0ebb5fb968e624428ea6c6467ad2b994b9443cce8647e086769b1a9fed17f9588932a21f888c346532a9f01dcf5a542510e3e9fd48fa341f9283bbad0aa1e6eb8dc6a595470993f663126879e7ad3db1e32708487d61cbae5ea09535f3c87e36aef03859e6f76504a9d0feb1a4bf9e5b044719a653fa5f4028577a5ef3066ceac77a12e7a2b82ef685090c51f4084cff6992f2b07d48dbfd68c55562865a117adecae537280cdbd2c80dc55b374a2f465cede7b7f75b91ada6bafbf2e0dad0853b8798b47ac98aa0f774aa2958510bea707bad24ce169b35543331f3c64cafa3257def72b8d41253bf6c98f69e16f80f6bf57e4a436f3d51888dd03ace85dd65f16d0457c10d65ba25495d76f3d16e1ed24f736e119790028cbb5df1a0f35c3c7360510209cd2cf291562d7b5be5e26abef27ca5c0d6f5592ada5884d89ef018a96c8aa8657e1a04e73450999be0b2c8a249b1070c2bbfe9373dbc91fe4a07bda9a2ff5f095a32349e07c145caed7b0c4aedde6f66ea3da253e48a4bdf64918de95b08e8b23dd3580c43131f3b06b2cd314edc847dae5e2c7ea020fc637a6445b3a210ddd34a72f07f12298d173d335557c2c5264aae6ad852ef1f33d201c90e5e1fae27f81a4728fa1651dd06d89fbbcd30852fcef39d17179ad7d6174e80ed3b53a55d2c127e4032bc50069a92e3c3f03ff21268f4b20ec1f978111e7ef83856c442b31fe9deeae3654e3d09e3520878cb3db8c25630639d279bbbd24c327dd71c911a16f8e79a87a95247ce001bf4fa22537c03ee5b26aa90ef9288d79cefb2c080fc2346d372ceb382530d64f31a726107d9e5bba53480b93efedb4344d59659468439b21f6e665904ea96bcb91826e07dc0cc246589f858d15df37b8ee98b6457db9c473e24b7d8594f22b18edee9557e90304f9e5eea9bdf5f6c9431b26aae506b80edac8092af83faec67bddfcf1acf172f86926cdd1f8e5cf7e83ed812e83b7d7183cade2d3d75eddaa3c452e848cbe9290d90ef503692a2fb69e3c54ff98dc6fba2ec47c7c222059d04261efaa082b85844a98bb7dab459ddb6f405c18db3f6cf1272dbffbb8f86a37445226958d9bee6a489c1c82aa3ea1a9157fd4a73b936d4f9a6a99762f818f5058b5b9ff84e763444f3a85cd9a9df86981b271230ccd024f2a124738a3dbd9333dec779933afb2426152374f87d2390d905cc80560e3f412b898a3d8a67e8683ae42f4939611c75108f89b728789035f1373f2b63e7acbef81d3ab1f970c359b48430cc5bfbdb395534f5c3aba857177296a63142f5755568775ceb4cac2e1f2a1874b9d3d5f1b009eca6a80c52c754fab446a53f50d20f4872710950ab36e63bff39d142bbd9323d4477bcdabf3f026b196ba3803e3102b3f5f5204e6b36ebe4f535401b823628e0f582fd1e48352f97106df20143c8696b0cc464f3bfafa7361d6f0951bb0c2cf33c07654ebfa3ace6101f29a3d753c87245e739bc775a04d016b49ef216f32ed42877f4255af2344fbee3ca6afbdda5b194318e95a9e5a634c2c655e9605a38ac6997d4b6e63bb6315a2cd247afa7b77a5be8faf03eeb6647e6dc83983bcd23eef4a2fe7a58b88c969b12170f5aefba0ce471ddff30f96feea679be43c3454ad23857bce64162515956c85ae85151dea3da1352eb2e1e43ca4448fadf4ac53e97916df6875107e21df4381df6e5a7b74bae93f111bd98d30d64e8afe4b3ef5bfdb7eb4b5eca389604413e008b135a59601e2bd102f3ec6d4b8c355980bdb2544dd6ba6e1415d0e7bb66fc766a908802cb55d2490c89a4652a5508870452df2cb8d5717e4ace3c98f0780f1ab5059f35b66db082dcdbb393c36a9c1cf59e940d1686813e3904ff6ca815b5535ff05773dd61e980930dac988d2f9cec201b57475847fec73670d9e21f8f22d5f9cad3d4e66159308d7ce14446dc342c7ec3b73bf747b4011fcc4e225700d09b42feb8732805b26bf9d29a87d7980a078787e4d759477a47347f3485ca15b7c10fc7faa97b1326a7b9964e6ac851340670c52d57190638f8936db833d8324c2580a22d95ad3a7ad641e2bc3395b1b7d4709e9371194833cf38aa4b741fc9920fc0f1a140b32f2699ec5aef99f0f0636d434d6161445c38c58e9ea3a03363922cab6eaaf46e162646ba87ec0fefad77995d1bfbebdd056b9511db800677044425a90e2eb49857b1d8fcf76e361cb76b3e7ce62ec1b2c174809c9eceaf73bc1a2b5fe78cdf8200861ba5dd0e48ca693d8330a43e8ce543e5184495eda744dbd57bd7d24da1a0d9f9d6350c16c0c9166fbc093622affcb767e0cac7eaf254d897f06ee139cafc95d5efb27f5fc128592b2d4e342b3f2167ea9bae9dbfc8ebb55e4fdbe93ee838bdb9323eb8799e60a1b18fb982928838a10ec0bdf571971889c079599fdf23e82b6e03d117c34f5cd2a041084685d74326001c7f0d15d2edb9a494e98ed47c23bd83833ef35d8ee59e5b312e647041d2b4e430c0f741ab4c79359a93e1c70292c886a9f366d663627895816bb5412ca4fa880d789e03a9fd0b849808cc8685a98e7bed9c5c492f1eccb6d38ca1f2796f81373e00e40ec166a7fd261de80ccede15f141347a1e418f5ddd2c426bcbc908dc96ce5481f72ef4d710b7eb92da55b876c08b5898e12b8fbc5fee331f1880262215a15226bfee29ef43e71ade65a2575c541341734d3d8dae00b923b50e440834309bd49a8e2aeaccfc7add6f2886606972bb6b31e639a816d6675bcfed48fbf3002c85cdb37e700374fb1453fd4e0b16dc918ca4f04f465eced53979dc050e283a5dd37f955cb0872e505005ec3ad003b8d6a105de99283974ff978597b3cb781de1f8a625c98ab6ed5f9a2b8b6c2fec959d2de1eef0b1c1749e213abdc30e2dff245db6b97f912ff194abd9c2033af12fb42b40393b9ec32a270f133ff66db4f8d993011270676203e3f45897506584618566f1c36f315434a56a80a4683256a382942ffe6f6b4b6a2f29a10e7f580e83aca4b286148041ccc15ae00af896c2f5f50a5f3c2168062da0c0d2c9ac6c42320c3c433bf480f6799ec128a41c38ea93eb343c64706d70af9799b7f9584d10f7c196743b4a6fbbce6f983741e12f3903a1c1ab1232628e200797d8ebda4a175abd17ba13d8040bddc17aeae6646f3c97ff285a57344270851b436c81edaa00b623318e5f3eda9db2cf8e772f6248ec1ffe2a603fe28a6d4aa01a4723f114cbb269b2591ae627c2d27a9ea6ca9affc5775919dd67c4d9d6934517d66b6f4a56b786c4a00ce6c9035a8be19b44391cf4a68a0603cbbe9fee68c6c1af2e50e4b114d71e579c9a64c8e6ef2284a0ce008db6093490a1af22cc9022ec936559c4edd3d26bf587d66478c1d8d1860a6075fbd2ee597024128044828be64c29d2d1408896ed9e3427b0f6d847d216402f47886359fde80b4faabbe561dc3f14ba68c4b3bd7007a25ab94613bbef4b6d84a48603f6ba99e7000954bef5b4bd46468c58d8d6eeb33f26cf1e1c94dbb1781524e048313d92298d5f4f132a1e8b8eed30c2a02162a4971030ef4387c85cd9db762e1afb9cf61673f8bbaa858fce49a8eef69e7ff5f00227fb2a684e12392e229462ffff45763c83abb05b19a410e4540cfa5aaae467d32c5cb79897f4865f50e6f65be8e4a14cd4ddf0a2d4d159f7ed7e455e8778b61cb54da2518dd4e712a74f8380356d67ab30eaa007234fc6344d498f88172634179b601ea489bed31ea0782da110979ac6592745ced282c637f816a68684776690081986d2ca0cab4027c6305ae93683f22ed75d15dc3470aa628a599efd69a406029c637e7c60c5781d6fb02503a57c47d4129fc86f8b40c5fc4b69316ff7b421a0e7e8a11ade214085be364a0877973e81960d0b5a861356a62d7b96f590ef4461f15b7e3059ce2b07e954194401685558949e4d542257daf0a3f668cdd7a5d959e9f71e1bf7186eda6eec406080070c1ca3e9e770dcb768a7bfe2599c93bbd405451864aa4c587a9fc7b102b001ae7fbcae26fc5729a28e69247e374eb21f03e9bd893a998a2ef58e33d713b075dd02aa3f71cb7ecce91139420bfa49f25ccd9f82a543bcd77982535d8eaa5d48f90ff151ecdf0afd6cfe90d7f3a477b860f00fd88615cc3ea2ea5e933b7c96f890ae549777550853da9465051203ae07e64e7d6408b930832a9300baf1a347188b19e5c50d5c477141c3188b3a01e439748b248bcbd67a5435e1043c62b0c9c97e048667e11ebdd3b24386b34b1a4b7eb0614047458d4960c9e138416f595f291de2cec9139ced3d9c2b20f9effd4373bd0d3cee667e8cc716cc1f987308676df3f34af9d2789c5837588db2a7c0785efed0af260900c739b76d9fffe9bdb584b9ef9bc8efd2ccfee21209c4bbfb902f93ee2c2b41675f64ac6dcb9a24cf03b92a1b2219e3b122c06188d6205d803d46ecad3ef9de53f9a42cff0954504656a70a4900c6fe0a41518bc04590fae14d82829a3d8c4a1c2232292ef0ac390c8a4898cba92be81566a65cc5484777b56c59d5663eceb4aa4bd5ecd80fc6829d4df3db219b3e55b069df4930b0c063054f362891fbbb2c2fa9d78a1a7ba4f588b8921a43350c91192f8bfe84a4d9a6f3d1ef2f0248ddb784a93874a23351efdc274aba2e49fd16dd68f5d263de043ddac70b936193a3cb310ff87c8869c43d6a04ad4ea20a92695e6821cbe7503eaac87925e5ed635be76495843f4c201f9ce591ed315e957183a29f8efbd1f76647bd317b072aeb9809271bc6cff10f3acb4de77716da66a1163912e0b01530a03f2e12c7c14009189e66ee7c40119c188c2fee32e8e3db858d369014b590561c659d43a36565793b276413143efdb9c42f721873e93acc690a8694a8cc68ab7f510da57e98ae2b81fddd9d94a9ad59d91bbba3ce941d9d1d2d0f8d9a561c62f09fe6a1b4080a753cb466dc0934e3fc687af0994ccbb48c6cb1563ea24167d4aba5e447146c66d0540fc7eecf91fe5ea2399ac46bc6a40bff171c834a5c17f05f0f04ea527ea324fd8bddc43e2485c73719a26ed24b14575b32ca242f7354a83f1b5e46fd862a2c9fdd157daca490c69ff32c35e1adae6d549acd7be0a47ab91d12a4608bc8cd8e3e1bcb3e2fca7d38b97a61cebd5e25566657816834bd856f969d912fa5fbc615d2320134fb3ac716ac74d8d4c9780f68eaf6b860356144b9c74cedd7848ce527ad3e5b2dd9e8bd360079ed5c80c5f0b422577feb5e7cf64f79187adef0ec156a52cc76e9d2680e1f4c58f848ffbc899778f49d513ad204b4dfedc29e4700b029d6ca19f6fe4a08c6039712462f70ef9482a46cc91a833e5c01b97c2fe05ccff6a5f963272d1f2b9a18423dcc36366e06590c79608ac824ad586d3e78e6104b09630442bd78a381ce2790b80226a0c4b9876d6fa0ff51195342683ab0efd73c0ae97cb6ee325b92a7ffaf42fa3b418f78a87ec27b312395d8a9ac91bf08446d52363db50b009b10dffe1c9f10164b50e3e958854f1d7147d847697ebd52e30da6c0bf1823d67787607c631c7b6872d7235ac1b401ad3008eb8bcbb8999398011283c8f08ebda40eeae4b56baa2e3e834412f608489fe8159612556aea2f79075b4c6415670f6ddab57af164d7d0c962f6357a1fd98efa940916ab7709d43f7a72add8dc54dd6636860206018eb680e1acd0d9d05d04f0e7b3ee9bd1da3d5747af628ba0cefdfb7a508c4539d9255680f3b92f9a3caffc6d1e64baca26ca9e181bf72bc707cb34691bb798d3d670bbee7848b1bb4cf2df4bd3f169de06311a54bf60e7fd1a5b193fdf97735fd07e304bf1a74cf0a8a4f0f68926d3b8c1b3c4ae9b9561e083e386517ffc948d2837c282bb5dbf6cce8c4f81e5e1ca7dfe7de5a0f2d3c94172422a748ddb23368ac8b2f22fb85c7fe3cd8f37263ea6486650e5d4a7b68bf5f5ed498faa3406d29e6245a8a4cc13badf2440cb681885ee7b9b660e2987023d66fb5f54d2dda81d044fa40b26c0626de783b35ad7e52157e43d81bafb74d29c88971719022d6c2c92b4b4bb1e30b88192d345b80e81c1241754449d80484d6ba3c7f5ccdd0d33040a8f0a246836b8ce7cdaaa0b7a250c0794d3a6aafd459c1806d5978779b88ca5b7ad3d6dbacce1c5d211afd67c2bf2107ac41fb6d764f17718eb40c162053936021bdeeec67ff675c38eb167e27b751e9da6d7932d194cc400a2f17825cd1c12e69ac1306a6e479a1f08c5fd1882d507a3b18d8858609ee526e8c1b1e8ba6fd97fa16b41e83304864d7d8e2df8b804d60dab54dffe14022f3a55647845fd8980eeec7bb97692b7ad4cb050c5577df23fa14d51d87301e2299be1b15f6b48a5a1a067b83766b12e032d20bd45b5ad55df154e77df7da97838f987645d42951907b65b51afb17198f0547fce3a81346431bb0cfd378295cafef7f8184dfaf493e9d2fad2215b4c00d9f5306a3a2c25975444d9b8ed8c4238144af3eca9ad37da6b9152490e15a2669649e97e5216bcc6248edc4186325ece14940a3cacfcedbeb681376114cc28903a5a2d757358c8c4a7da482a89722b5372fb553a65af725ebb85cd3a57765f563984e2223c1da96e95fd071abb151e01f68d8117ba61c5f07f8cd26cac0097b588080c870fe580c27e3813728e7536c1ce9edcc7d47813c89c05e8e80ca8c5db92a297417b3f0debc57d56888603585d94d30135af76d10a8a76d59d9970107404486248b6df6930e7f0137287e8dcbde09ea71763a57bd0eda0cfd74a307c20e5d61e256a337c5ae90f721a8e4132028f244e580eef11df0695e2f6a7791d4b755b9e7ab567426751181ed41459b9f1c4e8cb25fa9f4f522b341573a777d62f8afb0505fbe82963e6a5e4ee58d95137e54d157f42dd1b2769bd01f94f66d697ec96002d9edda4ae35b8c9c23114d81727e4610f32512a40285871fcd33f9988d7943ca2a07a8bda991410c34ac013ea9ba1b46e54d45307e68dc1420eff2290e9b8ff140a55aeac4199c4a6057187535c9d7d5ef76cfe55df3c166df125baf951995237465ca9b6cc1c57c29a82c83dd82d30893c1f392ef3e0c8e7b474cf0c22c36e20b99799fa848ed09f605bcaee58b804bc2cd3024417ce429c14755b1c39a3929b007d014cef85a0fb28d5eb7f26ebd303c71dcd450e0267f9dd899ce828cd455067cbda86f172f54a775a5845226ff6ae029f8bb7f13db010271bf2855dd12a711a380c5d3fc4f6010ca452cb7515e087b90324f90457d21aeb8a18b6ddefc96097f9aa81b8d1aa15b6bced7aedb7c8f4479b9a3340893ea0fa1af3452537d7c2ae270aec6ef80ddd3379d941b55b9f418f06ba979a49b93020cd8ce1e7dd5a868de3108cd76713c9e144079a657af5ebfc820cd99db2571291e0767","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
