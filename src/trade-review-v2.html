<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>V2 Trade Review ‚Äî Market Maker Method</title>
<script src="https://unpkg.com/lightweight-charts@4.1.0/dist/lightweight-charts.standalone.production.js"></script>
<style>
:root {
  --bg: #0a0a0f;
  --surface: #12121a;
  --surface2: #1a1a28;
  --border: #2a2a3a;
  --text: #e0e0e0;
  --text-dim: #888;
  --accent: #00bcd4;
  --green: #00c853;
  --red: #ff1744;
  --gold: #ffd700;
  --blue: #448aff;
  --purple: #b388ff;
}
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
  background: var(--bg);
  color: var(--text);
  min-height: 100vh;
}
.header {
  padding: 16px 20px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: space-between;
  flex-wrap: wrap;
  gap: 10px;
}
.header h1 {
  font-size: 1.3rem;
  font-weight: 700;
  color: var(--accent);
}
.header .home-link {
  color: var(--text-dim);
  text-decoration: none;
  font-size: 0.85rem;
}
.header .home-link:hover { color: var(--accent); }
.header-links { display: flex; gap: 16px; align-items: center; }

/* Filters */
.filters {
  padding: 12px 20px;
  border-bottom: 1px solid var(--border);
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  align-items: center;
}
.filter-group {
  display: flex;
  gap: 4px;
  align-items: center;
}
.filter-group label {
  font-size: 0.75rem;
  color: var(--text-dim);
  margin-right: 4px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.filter-btn {
  padding: 4px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--surface);
  color: var(--text-dim);
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.15s;
}
.filter-btn:hover { border-color: var(--accent); color: var(--text); }
.filter-btn.active {
  background: var(--accent);
  color: #000;
  border-color: var(--accent);
  font-weight: 600;
}
.filter-btn.long.active { background: var(--green); border-color: var(--green); }
.filter-btn.short.active { background: var(--red); border-color: var(--red); }
.filter-sep {
  width: 1px;
  height: 24px;
  background: var(--border);
  margin: 0 8px;
}

/* Stats bar */
.stats-bar {
  padding: 10px 20px;
  border-bottom: 1px solid var(--border);
  display: flex;
  gap: 24px;
  flex-wrap: wrap;
  font-size: 0.85rem;
}
.stat {
  display: flex;
  align-items: center;
  gap: 6px;
}
.stat-label { color: var(--text-dim); }
.stat-value { font-weight: 700; }
.stat-value.positive { color: var(--green); }
.stat-value.negative { color: var(--red); }

/* Summary panel */
.summary-panel {
  padding: 12px 20px;
  border-bottom: 1px solid var(--border);
  display: none;
}
.summary-panel.visible { display: block; }
.summary-toggle {
  padding: 4px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--surface);
  color: var(--text-dim);
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.15s;
}
.summary-toggle:hover { border-color: var(--accent); color: var(--text); }
.summary-toggle.active { background: var(--accent); color: #000; border-color: var(--accent); }
.summary-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
  gap: 12px;
  margin-top: 10px;
}
.summary-card {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 8px;
  padding: 12px 16px;
}
.summary-card h3 {
  font-size: 0.8rem;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 8px;
}
.summary-card .summary-stat {
  display: flex;
  justify-content: space-between;
  font-size: 0.8rem;
  padding: 2px 0;
}
.summary-card .summary-stat .label { color: var(--text-dim); }
.summary-card .summary-stat .val { font-weight: 600; }
.summary-card .summary-stat .val.pos { color: var(--green); }
.summary-card .summary-stat .val.neg { color: var(--red); }

/* Equity curve mini */
.equity-row {
  padding: 0 20px 12px 20px;
  border-bottom: 1px solid var(--border);
}
#equity-container {
  height: 120px;
  width: 100%;
}

/* Main content */
.main {
  display: flex;
  height: calc(100vh - 230px);
  min-height: 500px;
}

/* Trade list panel */
.trade-list-panel {
  width: 320px;
  min-width: 280px;
  border-right: 1px solid var(--border);
  display: flex;
  flex-direction: column;
}
.trade-list-header {
  padding: 10px 12px;
  border-bottom: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.8rem;
  color: var(--text-dim);
}
.trade-list {
  flex: 1;
  overflow-y: auto;
  scrollbar-width: thin;
  scrollbar-color: var(--border) transparent;
}
.trade-item {
  padding: 8px 12px;
  border-bottom: 1px solid var(--border);
  cursor: pointer;
  display: flex;
  justify-content: space-between;
  align-items: center;
  font-size: 0.8rem;
  transition: background 0.1s;
}
.trade-item:hover { background: var(--surface2); }
.trade-item.active { background: var(--surface2); border-left: 3px solid var(--accent); }
.trade-item .left {
  display: flex;
  gap: 8px;
  align-items: center;
}
.trade-item .pair-badge {
  font-weight: 700;
  font-size: 0.7rem;
  padding: 2px 6px;
  border-radius: 3px;
  min-width: 36px;
  text-align: center;
}
.trade-item .pair-badge.BTC { background: #f7931a22; color: #f7931a; }
.trade-item .pair-badge.ETH { background: #627eea22; color: #627eea; }
.trade-item .pair-badge.SOL { background: #9945ff22; color: #9945ff; }
.trade-item .tf-badge {
  color: var(--text-dim);
  font-size: 0.7rem;
  min-width: 24px;
}
.trade-item .dir-badge {
  font-weight: 700;
  font-size: 0.7rem;
}
.trade-item .dir-badge.L { color: var(--green); }
.trade-item .dir-badge.S { color: var(--red); }
.trade-item .r-value {
  font-weight: 700;
  font-size: 0.85rem;
  min-width: 50px;
  text-align: right;
}
.trade-item .r-value.positive { color: var(--green); }
.trade-item .r-value.negative { color: var(--red); }
.trade-item .date-text {
  color: var(--text-dim);
  font-size: 0.7rem;
}

/* Chart panel */
.chart-panel {
  flex: 1;
  display: flex;
  flex-direction: column;
  position: relative;
}
.chart-info {
  padding: 10px 16px;
  border-bottom: 1px solid var(--border);
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 8px;
}
.chart-info .trade-detail {
  display: flex;
  gap: 16px;
  align-items: center;
  font-size: 0.85rem;
}
.chart-info .nav-btns {
  display: flex;
  gap: 8px;
}
.nav-btn {
  padding: 4px 16px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--surface);
  color: var(--text);
  cursor: pointer;
  font-size: 0.85rem;
}
.nav-btn:hover { border-color: var(--accent); }
#chart-container {
  flex: 1;
  position: relative;
}
.chart-loading {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  color: var(--text-dim);
  font-size: 1rem;
}

/* Sort buttons */
.sort-btns {
  display: flex;
  gap: 4px;
}
.sort-btn {
  padding: 2px 8px;
  border: 1px solid var(--border);
  border-radius: 3px;
  background: transparent;
  color: var(--text-dim);
  font-size: 0.7rem;
  cursor: pointer;
}
.sort-btn.active { color: var(--accent); border-color: var(--accent); }

/* Load more bar */
.load-more-bar {
  padding: 8px 20px;
  border-bottom: 1px solid var(--border);
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 12px;
  font-size: 0.85rem;
  color: var(--text-dim);
}
.load-more-btn {
  padding: 6px 16px;
  border: 1px solid var(--accent);
  border-radius: 4px;
  background: transparent;
  color: var(--accent);
  font-size: 0.8rem;
  cursor: pointer;
  transition: all 0.15s;
  font-weight: 600;
}
.load-more-btn:hover {
  background: var(--accent);
  color: #000;
}
.load-more-btn:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}
.initial-loading {
  display: flex;
  align-items: center;
  justify-content: center;
  padding: 40px;
  color: var(--text-dim);
  font-size: 1rem;
}

/* Mobile */
@media (max-width: 768px) {
  .main { flex-direction: column; height: auto; }
  .trade-list-panel { width: 100%; min-width: 0; max-height: 250px; border-right: none; border-bottom: 1px solid var(--border); }
  #chart-container { min-height: 400px; }
}

/* 3-Box Tool */
.three-box-btn {
  padding: 4px 12px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--surface);
  color: var(--text);
  cursor: pointer;
  font-size: 0.8rem;
  transition: all 0.15s;
}
.three-box-btn:hover { border-color: var(--accent); color: var(--text); }
.three-box-btn.active { background: var(--accent); color: #000; border-color: var(--accent); }
.three-box-btn.drawing { background: #ff9800; color: #000; border-color: #ff9800; animation: tbPulse 1.2s ease-in-out infinite; }
@keyframes tbPulse { 0%,100%{opacity:1} 50%{opacity:0.6} }
#three-box-overlay { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 10; }
.three-box-status { font-size: 0.75rem; color: #ff9800; font-weight: 600; white-space: nowrap; }

/* Levels Tool */
#levels-overlay { position: absolute; top: 0; left: 0; pointer-events: none; z-index: 9; }
.levels-status { font-size: 0.75rem; color: #b388ff; font-weight: 600; white-space: nowrap; }

/* Date range inputs */
.date-input {
  padding: 4px 8px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--surface);
  color: var(--text);
  font-size: 0.8rem;
  font-family: inherit;
  outline: none;
  transition: border-color 0.15s;
}
.date-input:focus { border-color: var(--accent); }
.date-input::-webkit-calendar-picker-indicator { filter: invert(0.7); cursor: pointer; }

/* Equity header row */
.equity-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 6px 0 4px 0;
}
.equity-header .equity-label {
  font-size: 0.75rem;
  color: var(--text-dim);
  text-transform: uppercase;
  letter-spacing: 0.5px;
}
.compound-toggle {
  display: flex;
  gap: 4px;
  align-items: center;
}
.compound-btn {
  padding: 3px 10px;
  border: 1px solid var(--border);
  border-radius: 4px;
  background: var(--surface);
  color: var(--text-dim);
  font-size: 0.75rem;
  cursor: pointer;
  transition: all 0.15s;
}
.compound-btn:hover { border-color: var(--accent); color: var(--text); }
.compound-btn.active {
  background: var(--accent);
  color: #000;
  border-color: var(--accent);
  font-weight: 600;
}
</style>
</head>
<body>

<div class="header">
  <h1>üìä V11c Trade Review ‚Äî <span id="trade-count">5,245</span> Trades</h1>
  <div class="header-links">
    <a href="trade-review.html" class="home-link">V5.2 Legacy ‚Üí</a>
    <a href="index.html" class="home-link">‚Üê Dashboard</a>
  </div>
</div>

<div class="filters">
  <div class="filter-group">
    <label>Pair:</label>
    <button class="filter-btn active" data-filter="pair" data-value="ALL">ALL</button>
    <button class="filter-btn" data-filter="pair" data-value="BTC">BTC</button>
    <button class="filter-btn" data-filter="pair" data-value="ETH">ETH</button>
    <button class="filter-btn" data-filter="pair" data-value="SOL">SOL</button>
  </div>
  <div class="filter-sep"></div>
  <div class="filter-group">
    <label>TF:</label>
    <button class="filter-btn active" data-filter="tf" data-value="ALL">ALL</button>
    <button class="filter-btn" data-filter="tf" data-value="1m">1m</button>
    <button class="filter-btn" data-filter="tf" data-value="15m">15m</button>
    <button class="filter-btn" data-filter="tf" data-value="1H">1H</button>
  </div>
  <div class="filter-sep"></div>
  <div class="filter-group">
    <label>Dir:</label>
    <button class="filter-btn active" data-filter="dir" data-value="ALL">ALL</button>
    <button class="filter-btn long" data-filter="dir" data-value="L">LONG</button>
    <button class="filter-btn short" data-filter="dir" data-value="S">SHORT</button>
  </div>
  <div class="filter-sep"></div>
  <div class="filter-group">
    <label>Exit:</label>
    <button class="filter-btn active" data-filter="exit" data-value="ALL">ALL</button>
    <button class="filter-btn" data-filter="exit" data-value="stop">Stop</button>
    <button class="filter-btn" data-filter="exit" data-value="vector_exit">Vector</button>
    <button class="filter-btn" data-filter="exit" data-value="timeout">Timeout</button>
  </div>
  <div class="filter-sep"></div>
  <div class="filter-group">
    <label>Result:</label>
    <button class="filter-btn active" data-filter="result" data-value="ALL">ALL</button>
    <button class="filter-btn" data-filter="result" data-value="win">Winners</button>
    <button class="filter-btn" data-filter="result" data-value="loss">Losers</button>
  </div>
  <div class="filter-sep"></div>
  <div class="filter-group">
    <label>From:</label>
    <input type="date" class="date-input" id="date-from" value="2017-01-01">
  </div>
  <div class="filter-group">
    <label>To:</label>
    <input type="date" class="date-input" id="date-to">
  </div>
  <div class="filter-group">
    <button class="filter-btn" id="apply-dates-btn" onclick="applyFilters()" style="background:var(--accent);color:#000;font-weight:600;">Apply</button>
  </div>
  <div class="filter-sep"></div>
  <button class="summary-toggle" id="summary-btn" onclick="toggleSummary()">üìã Summary</button>
</div>

<div class="stats-bar">
  <div class="stat"><span class="stat-label">Trades:</span><span class="stat-value" id="stat-trades">5,245</span></div>
  <div class="stat"><span class="stat-label">Win Rate:</span><span class="stat-value" id="stat-wr">63%</span></div>
  <div class="stat"><span class="stat-label">Total R:</span><span class="stat-value" id="stat-total-r">+7,434.57</span></div>
  <div class="stat"><span class="stat-label">Compound $:</span><span class="stat-value" id="stat-compound">‚Äî</span></div>
  <div class="stat"><span class="stat-label">Avg R:</span><span class="stat-value" id="stat-avg-r">1.42</span></div>
  <div class="stat"><span class="stat-label">Best:</span><span class="stat-value positive" id="stat-best">+45.15</span></div>
  <div class="stat"><span class="stat-label">Worst:</span><span class="stat-value negative" id="stat-worst">-1.00</span></div>
  <div class="stat"><span class="stat-label">Max Consec Loss:</span><span class="stat-value" id="stat-streak">0</span></div>
  <div class="stat"><span class="stat-label">Profit Factor:</span><span class="stat-value" id="stat-pf">0</span></div>
  <div class="stat"><span class="stat-label">Expectancy:</span><span class="stat-value" id="stat-expect">0</span></div>
</div>

<div class="summary-panel" id="summary-panel">
  <div id="summary-content"></div>
</div>

<div class="main">
  <div class="trade-list-panel">
    <div class="trade-list-header">
      <span id="filtered-count">5,245 trades</span>
      <div class="sort-btns">
        <button class="sort-btn active" data-sort="date">Date</button>
        <button class="sort-btn" data-sort="r-desc">R ‚Üì</button>
        <button class="sort-btn" data-sort="r-asc">R ‚Üë</button>
      </div>
    </div>
    <div class="trade-list" id="trade-list"></div>
  </div>

  <div class="chart-panel">
    <div class="chart-info">
      <div class="trade-detail" id="trade-detail">
        <span>Select a trade to view chart</span>
      </div>
      <div class="nav-btns">
        <button class="nav-btn" id="btn-prev">‚óÄ Prev</button>
        <button class="nav-btn" id="btn-next">Next ‚ñ∂</button>
        <button class="nav-btn" id="btn-random">üé≤</button>
        <span style="width:1px;height:20px;background:var(--border);margin:0 6px;display:inline-block"></span>
        <button class="three-box-btn" id="btn-three-box" onclick="toggleThreeBox()">üìê 3-Box</button>
        <button class="three-box-btn" id="btn-clear-boxes" onclick="clearThreeBoxes()" style="display:none">üóëÔ∏è Clear</button>
        <span class="three-box-status" id="three-box-status"></span>
        <span style="width:1px;height:20px;background:var(--border);margin:0 6px;display:inline-block"></span>
        <button class="three-box-btn" id="btn-levels" onclick="toggleLevels()">üîç Levels</button>
        <span class="levels-status" id="levels-status"></span>
      </div>
    </div>
    <div id="chart-container">
      <div class="chart-loading" id="chart-loading">‚Üê Select a trade from the list</div>
    </div>
  </div>
</div>

<div class="equity-row">
  <div class="equity-header">
    <span class="equity-label">üìà Equity Curve</span>
    <div class="compound-toggle">
      <button class="compound-btn active" id="btn-flat-r" onclick="setEquityMode('flat')">Flat R</button>
      <button class="compound-btn" id="btn-compound" onclick="setEquityMode('compound')">Compound $</button>
    </div>
  </div>
  <div id="equity-container"></div>
</div>

<div class="load-more-bar" id="load-more-bar">
  <span id="load-status">‚è≥ Loading recent trades...</span>
  <button class="load-more-btn" id="load-more-btn" style="display:none" onclick="loadOlderYears()">
    üì• Load 2017‚Äì2022
  </button>
</div>

<script>
// ============= TRADE DATA (lazy-loaded) =============
let TRADE_DATA = [];


// ============= CONSTANTS =============
const SYMBOL_MAP = { BTC: 'BTCUSDT', ETH: 'ETHUSDT', SOL: 'SOLUSDT' };
const INTERVAL_MAP = { '1m': '1m', '15m': '15m', '1H': '1h' };
const TF_MINUTES = { '1m': 1, '15m': 15, '1H': 60 };
const CANDLE_PADDING = { '1m': 120, '15m': 80, '1H': 80 };
const LEVELS_PADDING = { '1m': 400, '15m': 300, '1H': 200 };
const BINANCE_API = 'https://api.binance.com/api/v3/klines';

// Fix timezone: backtest dates were UTC but Python .timestamp() on Sofia machine
// interpreted them as local time, subtracting 2h (winter EET) or 3h (summer EEST).
function getSofiaOffset(ts) {
  const d = new Date(ts * 1000);
  const utc = new Date(d.toLocaleString('en-US', {timeZone: 'UTC'}));
  const sofia = new Date(d.toLocaleString('en-US', {timeZone: 'Europe/Sofia'}));
  return (sofia - utc) / 1000;
}
// V11c data timestamps are already correct UTC - no timezone fix needed
// (V5.2 legacy data needed fixing because Python .timestamp() on Sofia machine shifted them)
function fixTimezones(trades) {
  // no-op for v11c data
}

// ============= STATE =============
let state = {
  filters: { pair: 'ALL', tf: 'ALL', dir: 'ALL', exit: 'ALL', result: 'ALL' },
  sort: 'date',
  dateAsc: true,
  filtered: [],
  selectedIndex: -1,
  chart: null,
  candleSeries: null,
  volumeSeries: null,
  candleCache: {},
  equityChart: null,
  showSummary: false,
  equityMode: 'flat' // 'flat' or 'compound'
};

// ============= FILTER & SORT =============
async function applyFilters() {
  const f = state.filters;
  // Date range filter
  const fromEl = document.getElementById('date-from');
  const toEl = document.getElementById('date-to');
  const fromTs = fromEl && fromEl.value ? new Date(fromEl.value + 'T00:00:00Z').getTime() / 1000 : 0;
  const toTs = toEl && toEl.value ? new Date(toEl.value + 'T23:59:59Z').getTime() / 1000 : Infinity;

  // V2: no year-based loading needed

  state.filtered = TRADE_DATA.filter(t => {
    if (t.et < fromTs || t.et > toTs) return false;
    if (f.pair !== 'ALL' && t.pair !== f.pair) return false;
    if (f.tf !== 'ALL' && t.tf !== f.tf) return false;
    if (f.dir !== 'ALL' && t.dir !== f.dir) return false;
    if (f.exit !== 'ALL' && t.exit_type !== f.exit) return false;
    if (f.result === 'win' && t.r <= 0) return false;
    if (f.result === 'loss' && t.r >= 0) return false;
    return true;
  });
  applySort();
}

function applySort() {
  const s = state.sort;
  state.filtered.sort((a, b) => {
    if (s === 'date') return state.dateAsc ? a.et - b.et : b.et - a.et;
    if (s === 'r-desc') return b.r - a.r;
    if (s === 'r-asc') return a.r - b.r;
    return 0;
  });
  state.selectedIndex = -1;
  updateUI();
}

// ============= STATS =============
function calcStats(trades) {
  if (!trades.length) return { count: 0, wr: 0, totalR: 0, avgR: 0, best: 0, worst: 0, maxConsecLoss: 0, pf: 0, expectancy: 0, compoundDollar: 1000 };
  const wins = trades.filter(t => t.r > 0).length;
  const totalR = trades.reduce((s, t) => s + t.r, 0);
  const best = Math.max(...trades.map(t => t.r));
  const worst = Math.min(...trades.map(t => t.r));
  
  // Profit Factor
  const grossProfit = trades.filter(t => t.r > 0).reduce((s, t) => s + t.r, 0);
  const grossLoss = Math.abs(trades.filter(t => t.r < 0).reduce((s, t) => s + t.r, 0));
  const pf = grossLoss > 0 ? grossProfit / grossLoss : Infinity;
  
  // Expectancy
  const wr = wins / trades.length;
  const avgWin = wins > 0 ? grossProfit / wins : 0;
  const losers = trades.length - wins;
  const avgLoss = losers > 0 ? grossLoss / losers : 0;
  const expectancy = (wr * avgWin) - ((1 - wr) * avgLoss);
  
  // Max consecutive losses (by date order)
  const byDate = [...trades].sort((a, b) => a.et - b.et);
  let maxLoss = 0, curLoss = 0;
  for (const t of byDate) {
    if (t.r < 0) { curLoss++; maxLoss = Math.max(maxLoss, curLoss); }
    else curLoss = 0;
  }
  
  // Compound $ (2% risk, $1000 start)
  const byDateForCompound = [...trades].sort((a, b) => a.et - b.et);
  let compoundBal = 1000;
  for (const t of byDateForCompound) compoundBal = compoundBal * (1 + t.r * 0.02);

  return {
    count: trades.length,
    wr: Math.round(wins / trades.length * 100),
    totalR: totalR.toFixed(2),
    avgR: (totalR / trades.length).toFixed(2),
    best: best.toFixed(2),
    worst: worst.toFixed(2),
    maxConsecLoss: maxLoss,
    pf: pf === Infinity ? '‚àû' : pf.toFixed(2),
    expectancy: expectancy.toFixed(2),
    compoundDollar: compoundBal
  };
}

// ============= SUMMARY =============
function toggleSummary() {
  state.showSummary = !state.showSummary;
  const panel = document.getElementById('summary-panel');
  const btn = document.getElementById('summary-btn');
  if (state.showSummary) {
    panel.classList.add('visible');
    btn.classList.add('active');
    renderSummary();
  } else {
    panel.classList.remove('visible');
    btn.classList.remove('active');
  }
}

function renderSummary() {
  const trades = state.filtered;
  
  // Per-pair breakdown
  const pairs = ['BTC', 'ETH', 'SOL'];
  const tfs = ['1m', '15m', '1H'];
  const dirs = ['L', 'S'];
  
  function makeCard(title, subsets) {
    let html = `<div class="summary-card"><h3>${title}</h3>`;
    for (const [label, subset] of subsets) {
      if (!subset.length) continue;
      const wins = subset.filter(t => t.r > 0).length;
      const wr = Math.round(wins / subset.length * 100);
      const totalR = subset.reduce((s, t) => s + t.r, 0);
      const avgR = (totalR / subset.length).toFixed(2);
      const rClass = totalR >= 0 ? 'pos' : 'neg';
      html += `<div class="summary-stat">
        <span class="label">${label}</span>
        <span class="val">${subset.length} trades</span>
        <span class="val ${rClass}">${wr}% WR</span>
        <span class="val ${rClass}">${totalR >= 0 ? '+' : ''}${totalR.toFixed(1)}R</span>
        <span class="val">${avgR} avg</span>
      </div>`;
    }
    html += '</div>';
    return html;
  }
  
  let html = '<div class="summary-grid">';
  
  // Per pair
  html += makeCard('By Pair', pairs.map(p => [p, trades.filter(t => t.pair === p)]));
  
  // Per TF
  html += makeCard('By Timeframe', tfs.map(tf => [tf, trades.filter(t => t.tf === tf)]));
  
  // Per direction
  html += makeCard('By Direction', dirs.map(d => [d === 'L' ? 'LONG' : 'SHORT', trades.filter(t => t.dir === d)]));
  
  // Per exit type
  html += makeCard('By Exit Type', [
    ['Stop', trades.filter(t => t.exit_type === 'stop')],
    ['Vector', trades.filter(t => t.exit_type === 'vector_exit')],
    ['Timeout', trades.filter(t => t.exit_type === 'timeout')],
  ]);
  
  // Per pair+TF combo
  const combos = [];
  for (const p of pairs) {
    for (const tf of tfs) {
      const sub = trades.filter(t => t.pair === p && t.tf === tf);
      if (sub.length) combos.push([`${p} ${tf}`, sub]);
    }
  }
  html += makeCard('By Pair √ó TF', combos);
  
  // Yearly breakdown
  const years = [...new Set(trades.map(t => new Date(t.et * 1000).getFullYear()))].sort();
  html += makeCard('By Year', years.map(y => [String(y), trades.filter(t => new Date(t.et * 1000).getFullYear() === y)]));
  
  html += '</div>';
  document.getElementById('summary-content').innerHTML = html;
}

// ============= EQUITY CURVE =============
function renderEquityCurve() {
  const container = document.getElementById('equity-container');
  if (state.equityChart) {
    state.equityChart.remove();
    state.equityChart = null;
  }
  
  const byDate = [...state.filtered].sort((a, b) => a.et - b.et);
  if (!byDate.length) {
    container.innerHTML = '<div style="text-align:center;color:#666;padding:20px;">No trades in selected range</div>';
    return;
  }
  
  let data;
  if (state.equityMode === 'compound') {
    let balance = 1000;
    data = byDate.map(t => {
      balance = balance * (1 + t.r * 0.02);
      return { time: t.et, value: parseFloat(balance.toFixed(2)) };
    });
  } else {
    let cumR = 0;
    data = byDate.map(t => {
      cumR += t.r;
      return { time: t.et, value: parseFloat(cumR.toFixed(2)) };
    });
  }
  
  // Deduplicate by time (keep last value for same timestamp)
  const dedupMap = new Map();
  data.forEach(d => dedupMap.set(d.time, d.value));
  const dedupData = [...dedupMap.entries()].sort((a,b) => a[0] - b[0]).map(([time, value]) => ({time, value}));
  
  state.equityChart = LightweightCharts.createChart(container, {
    layout: { background: { color: '#0a0a0f' }, textColor: '#888' },
    grid: { vertLines: { visible: false }, horzLines: { color: '#1e1e2e' } },
    rightPriceScale: { borderColor: '#2a2a3a' },
    timeScale: { borderColor: '#2a2a3a', timeVisible: false },
    width: container.clientWidth,
    height: 120,
    crosshair: { mode: LightweightCharts.CrosshairMode.Magnet },
  });
  
  const seriesOpts = {
    topColor: 'rgba(0, 188, 212, 0.4)',
    bottomColor: 'rgba(0, 188, 212, 0.0)',
    lineColor: '#00bcd4',
    lineWidth: 2,
  };
  if (state.equityMode === 'compound') {
    seriesOpts.priceFormat = { type: 'custom', formatter: p => '$' + p.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0}) };
  }
  const series = state.equityChart.addAreaSeries(seriesOpts);
  series.setData(dedupData);
  state.equityChart.timeScale().fitContent();
  
  const ro = new ResizeObserver(() => {
    if (state.equityChart) {
      state.equityChart.applyOptions({ width: container.clientWidth });
    }
  });
  ro.observe(container);
}

// ============= UI UPDATE =============
function updateUI() {
  const stats = calcStats(state.filtered);
  
  document.getElementById('stat-trades').textContent = stats.count.toLocaleString();
  document.getElementById('trade-count').textContent = stats.count.toLocaleString();
  const wrEl = document.getElementById('stat-wr');
  wrEl.textContent = stats.wr + '%';
  wrEl.className = 'stat-value ' + (stats.wr >= 50 ? 'positive' : 'negative');
  const trEl = document.getElementById('stat-total-r');
  trEl.textContent = (stats.totalR >= 0 ? '+' : '') + parseFloat(stats.totalR).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
  trEl.className = 'stat-value ' + (stats.totalR >= 0 ? 'positive' : 'negative');
  const arEl = document.getElementById('stat-avg-r');
  arEl.textContent = stats.avgR;
  arEl.className = 'stat-value ' + (stats.avgR >= 0 ? 'positive' : 'negative');
  document.getElementById('stat-best').textContent = '+' + stats.best;
  document.getElementById('stat-worst').textContent = stats.worst;
  document.getElementById('stat-streak').textContent = stats.maxConsecLoss;
  const pfEl = document.getElementById('stat-pf');
  pfEl.textContent = stats.pf;
  pfEl.className = 'stat-value ' + (parseFloat(stats.pf) >= 1.5 ? 'positive' : parseFloat(stats.pf) < 1 ? 'negative' : '');
  const exEl = document.getElementById('stat-expect');
  exEl.textContent = stats.expectancy;
  exEl.className = 'stat-value ' + (stats.expectancy >= 0 ? 'positive' : 'negative');
  const compEl = document.getElementById('stat-compound');
  const compVal = stats.compoundDollar;
  compEl.textContent = '$' + compVal.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0});
  compEl.className = 'stat-value ' + (compVal >= 1000 ? 'positive' : 'negative');
  
  document.getElementById('filtered-count').textContent = stats.count.toLocaleString() + ' trades';
  
  renderTradeList();
  renderEquityCurve();
  
  if (state.showSummary) renderSummary();
}

function renderTradeList() {
  const list = document.getElementById('trade-list');
  // Virtual scrolling for 5K+ trades - show first 500, load more on scroll
  const maxShow = Math.min(state.filtered.length, 500);
  const html = [];
  for (let i = 0; i < maxShow; i++) {
    const t = state.filtered[i];
    const date = new Date(t.et * 1000);
    const dateStr = date.toISOString().slice(0, 10);
    const rStr = (t.r >= 0 ? '+' : '') + t.r.toFixed(2) + 'R';
    const rClass = t.r >= 0 ? 'positive' : 'negative';
    const active = i === state.selectedIndex ? 'active' : '';
    html.push(`<div class="trade-item ${active}" data-idx="${i}" onclick="selectTrade(${i})">
      <div class="left">
        <span class="pair-badge ${t.pair}">${t.pair}</span>
        <span class="tf-badge">${t.tf}</span>
        <span class="dir-badge ${t.dir}">${t.dir === 'L' ? 'LONG' : 'SHORT'}</span>
        <span class="date-text">${dateStr}</span>
      </div>
      <span class="r-value ${rClass}">${rStr}</span>
    </div>`);
  }
  if (state.filtered.length > maxShow) {
    html.push(`<div class="trade-item" style="justify-content:center;color:var(--text-dim);cursor:default">... ${state.filtered.length - maxShow} more trades (use filters to narrow)</div>`);
  }
  list.innerHTML = html.join('');
  
  if (state.selectedIndex >= 0 && state.selectedIndex < maxShow) {
    const active = list.querySelector('.trade-item.active');
    if (active) active.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  }
}

// ============= CHART =============
function initChart() {
  const container = document.getElementById('chart-container');
  state.chart = LightweightCharts.createChart(container, {
    layout: {
      background: { color: '#0a0a0f' },
      textColor: '#888',
    },
    grid: {
      vertLines: { color: '#1e1e2e' },
      horzLines: { color: '#1e1e2e' },
    },
    crosshair: { mode: LightweightCharts.CrosshairMode.Normal },
    rightPriceScale: { borderColor: '#2a2a3a' },
    timeScale: { borderColor: '#2a2a3a', timeVisible: true, secondsVisible: false },
    width: container.clientWidth,
    height: container.clientHeight,
  });
  
  state.candleSeries = state.chart.addCandlestickSeries({
    upColor: '#00c853',
    downColor: '#ff1744',
    borderUpColor: '#00c853',
    borderDownColor: '#ff1744',
    wickUpColor: '#00c853',
    wickDownColor: '#ff1744',
    priceScaleId: 'right',
  });
  state.chart.priceScale('right').applyOptions({
    scaleMargins: { top: 0.02, bottom: 0.06 },
  });
  
  state.volumeSeries = state.chart.addHistogramSeries({
    priceFormat: { type: 'volume' },
    priceScaleId: 'vol',
  });
  state.chart.priceScale('vol').applyOptions({
    scaleMargins: { top: 0.93, bottom: 0 },
  });
  
  state.markerSeries = state.chart.addLineSeries({
    color: 'transparent',
    lineWidth: 0,
    crosshairMarkerVisible: false,
    lastValueVisible: false,
    priceLineVisible: false,
    priceScaleId: 'right',
  });
  
  const ro = new ResizeObserver(() => {
    state.chart.applyOptions({
      width: container.clientWidth,
      height: container.clientHeight,
    });
    scheduleThreeBoxRedraw();
    scheduleLevelsRedraw();
  });
  ro.observe(container);

  // 3-Box tool: subscribe to chart clicks and scale changes
  state.chart.subscribeClick(handleThreeBoxClick);
  state.chart.timeScale().subscribeVisibleLogicalRangeChange(() => { scheduleThreeBoxRedraw(); scheduleLevelsRedraw(); });
  state.chart.subscribeCrosshairMove(() => { scheduleThreeBoxRedraw(); scheduleLevelsRedraw(); });
}

async function fetchCandles(trade) {
  const cacheKey = `${trade.pair}_${trade.tf}_${trade.et}`;
  if (state.candleCache[cacheKey]) return state.candleCache[cacheKey];
  
  const symbol = SYMBOL_MAP[trade.pair];
  const interval = INTERVAL_MAP[trade.tf];
  const pad = CANDLE_PADDING[trade.tf];
  const tfMs = TF_MINUTES[trade.tf] * 60 * 1000;
  
  const startTime = (trade.et * 1000) - (pad * tfMs);
  const endTime = Math.max(trade.xt * 1000, trade.et * 1000) + (pad * tfMs);
  
  let allCandles = [];
  let cursor = startTime;
  
  while (cursor < endTime) {
    const url = `${BINANCE_API}?symbol=${symbol}&interval=${interval}&startTime=${cursor}&endTime=${endTime}&limit=1000`;
    try {
      const resp = await fetch(url);
      const data = await resp.json();
      if (!data || !data.length) break;
      allCandles = allCandles.concat(data);
      cursor = data[data.length - 1][0] + 1;
      if (data.length < 1000) break;
    } catch (e) {
      console.error('Fetch error:', e);
      break;
    }
  }
  
  const candles = allCandles.map(c => ({
    time: Math.floor(c[0] / 1000),
    open: parseFloat(c[1]),
    high: parseFloat(c[2]),
    low: parseFloat(c[3]),
    close: parseFloat(c[4]),
    volume: parseFloat(c[5]),
  }));
  
  state.candleCache[cacheKey] = candles;
  return candles;
}

async function selectTrade(idx) {
  if (idx < 0 || idx >= state.filtered.length) return;
  state.selectedIndex = idx;
  const trade = state.filtered[idx];
  
  // Persist to URL hash so refresh keeps the same trade
  try { history.replaceState(null, '', '#' + trade.pair + '_' + trade.tf + '_' + trade.et); } catch(e) {}
  
  const dir = trade.dir === 'L' ? 'üü¢ LONG' : 'üî¥ SHORT';
  const rStr = (trade.r >= 0 ? '+' : '') + trade.r.toFixed(2) + 'R';
  const rColor = trade.r >= 0 ? 'var(--green)' : 'var(--red)';
  const date = new Date(trade.et * 1000).toISOString().slice(0, 16).replace('T', ' ');
  const pColor = trade.pair === 'BTC' ? '#f7931a' : trade.pair === 'ETH' ? '#627eea' : '#9945ff';
  document.getElementById('trade-detail').innerHTML = `
    <span style="font-weight:700;color:${pColor}">${trade.pair}</span>
    <span>${trade.tf}</span>
    <span>${dir}</span>
    <span style="font-weight:700;color:${rColor}">${rStr}</span>
    <span style="color:var(--text-dim)">${trade.exit_type}</span>
    <span style="color:var(--text-dim)">${date}</span>
    <span style="color:var(--text-dim)">Entry: ${trade.entry.toLocaleString()}</span>
    <span style="color:var(--text-dim)">Stop: ${trade.stop.toLocaleString()}</span>
    <span style="color:var(--text-dim)">Exit: ${trade.exit.toLocaleString()}</span>
    <span style="color:var(--text-dim)">Trade ${idx + 1}/${state.filtered.length.toLocaleString()}</span>
  `;
  
  renderTradeList();
  
  document.getElementById('chart-loading').style.display = 'block';
  document.getElementById('chart-loading').textContent = 'Loading candles...';
  
  try {
    const candles = await fetchCandles(trade);
    if (state.selectedIndex !== idx) return;
    
    if (!candles.length) {
      document.getElementById('chart-loading').textContent = 'No candle data available (pre-listing?)';
      return;
    }
    
    document.getElementById('chart-loading').style.display = 'none';
    
    state.candleSeries.setData(candles);
    
    state.volumeSeries.setData(candles.map(c => ({
      time: c.time,
      value: c.volume,
      color: c.close >= c.open ? 'rgba(0,200,83,0.8)' : 'rgba(255,23,68,0.8)',
    })));
    
    const entryMarkerTime = trade.et;
    const markerData = [
      { time: entryMarkerTime, value: trade.entry },
      { time: trade.xt, value: trade.exit },
    ].sort((a, b) => a.time - b.time);
    state.markerSeries.setData(markerData);
    
    // Compute levels if active, then set all markers together
    if (levels.active) {
      computeLevels();
    } else {
      refreshCandleMarkers();
    }
    state.markerSeries.setMarkers([]);
    
    if (state.priceLines) {
      state.priceLines.forEach(pl => state.candleSeries.removePriceLine(pl));
    }
    state.priceLines = [];
    
    state.priceLines.push(state.candleSeries.createPriceLine({
      price: trade.entry,
      color: '#00bcd4',
      lineWidth: 2,
      lineStyle: 0,
      axisLabelVisible: true,
      title: 'Entry ' + trade.entry.toLocaleString(),
    }));
    
    state.priceLines.push(state.candleSeries.createPriceLine({
      price: trade.stop,
      color: '#ff1744',
      lineWidth: 1,
      lineStyle: 2,
      axisLabelVisible: true,
      title: 'Stop ' + trade.stop.toLocaleString(),
    }));
    
    state.priceLines.push(state.candleSeries.createPriceLine({
      price: trade.exit,
      color: '#ffd700',
      lineWidth: 2,
      lineStyle: 0,
      axisLabelVisible: true,
      title: 'Exit ' + trade.exit.toLocaleString(),
    }));
    
    const tradeDuration = Math.max(trade.xt - trade.et, TF_MINUTES[trade.tf] * 60 * 10);
    const viewPad = Math.max(tradeDuration * 0.5, TF_MINUTES[trade.tf] * 60 * 15);
    const viewFrom = trade.et - viewPad;
    const viewTo = trade.xt + viewPad;
    state.chart.timeScale().setVisibleRange({ from: viewFrom, to: viewTo });
    
  } catch (e) {
    console.error('Error loading trade:', e);
    document.getElementById('chart-loading').textContent = 'Error loading candles';
    document.getElementById('chart-loading').style.display = 'block';
  }
}

// ============= EVENT HANDLERS =============
document.querySelectorAll('.filter-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const filter = btn.dataset.filter;
    const value = btn.dataset.value;
    state.filters[filter] = value;
    document.querySelectorAll(`.filter-btn[data-filter="${filter}"]`).forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    applyFilters();
  });
});

document.querySelectorAll('.sort-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    const newSort = btn.dataset.sort;
    if (newSort === 'date' && state.sort === 'date') {
      state.dateAsc = !state.dateAsc;
      btn.textContent = state.dateAsc ? 'Date ‚Üë' : 'Date ‚Üì';
    } else if (newSort === 'date') {
      btn.textContent = state.dateAsc ? 'Date ‚Üë' : 'Date ‚Üì';
    }
    state.sort = newSort;
    document.querySelectorAll('.sort-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    applySort();
  });
});

document.getElementById('btn-prev').addEventListener('click', () => {
  if (state.selectedIndex > 0) selectTrade(state.selectedIndex - 1);
});
document.getElementById('btn-next').addEventListener('click', () => {
  if (state.selectedIndex < state.filtered.length - 1) selectTrade(state.selectedIndex + 1);
  else if (state.selectedIndex === -1 && state.filtered.length > 0) selectTrade(0);
});
document.getElementById('btn-random').addEventListener('click', () => {
  if (state.filtered.length > 0) {
    selectTrade(Math.floor(Math.random() * state.filtered.length));
  }
});

document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && threeBox.drawing) { cancelThreeBoxDrawing(); return; }
  if (e.key === 'ArrowUp' || e.key === 'ArrowLeft') {
    e.preventDefault();
    if (state.selectedIndex > 0) selectTrade(state.selectedIndex - 1);
  } else if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
    e.preventDefault();
    if (state.selectedIndex < state.filtered.length - 1) selectTrade(state.selectedIndex + 1);
  }
});

// ============= 3-BOX TOOL (Market Maker Method Rule 5) =============
const threeBox = { drawing: false, clickCount: 0, price1: null, price2: null, tempLine: null, boxData: null, overlay: null };
let threeBoxRedrawPending = false;

function createThreeBoxOverlay() {
  if (threeBox.overlay) return;
  const container = document.getElementById('chart-container');
  const canvas = document.createElement('canvas');
  canvas.id = 'three-box-overlay';
  container.appendChild(canvas);
  threeBox.overlay = canvas;
  sizeThreeBoxCanvas();
}

function sizeThreeBoxCanvas() {
  if (!threeBox.overlay) return;
  const container = document.getElementById('chart-container');
  const dpr = window.devicePixelRatio || 1;
  const w = container.clientWidth * dpr;
  const h = container.clientHeight * dpr;
  if (threeBox.overlay.width !== w || threeBox.overlay.height !== h) {
    threeBox.overlay.width = w;
    threeBox.overlay.height = h;
    threeBox.overlay.style.width = container.clientWidth + 'px';
    threeBox.overlay.style.height = container.clientHeight + 'px';
  }
}

function toggleThreeBox() {
  if (!state.candleSeries) return;
  if (threeBox.drawing) { cancelThreeBoxDrawing(); return; }
  // Enter drawing mode
  threeBox.drawing = true;
  threeBox.clickCount = 0;
  threeBox.price1 = null;
  threeBox.price2 = null;
  document.getElementById('btn-three-box').classList.add('drawing');
  document.getElementById('btn-three-box').textContent = '‚úã Cancel';
  document.getElementById('three-box-status').textContent = '‚ë† Click start of range';
  createThreeBoxOverlay();
}

function cancelThreeBoxDrawing() {
  threeBox.drawing = false;
  threeBox.clickCount = 0;
  if (threeBox.tempLine) {
    try { state.candleSeries.removePriceLine(threeBox.tempLine); } catch(e) {}
    threeBox.tempLine = null;
  }
  const btn = document.getElementById('btn-three-box');
  btn.classList.remove('drawing');
  btn.textContent = 'üìê 3-Box';
  document.getElementById('three-box-status').textContent = '';
}

function clearThreeBoxes() {
  cancelThreeBoxDrawing();
  threeBox.boxData = null;
  if (threeBox.overlay) {
    const ctx = threeBox.overlay.getContext('2d');
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, threeBox.overlay.width, threeBox.overlay.height);
  }
  document.getElementById('btn-three-box').classList.remove('active');
  document.getElementById('btn-three-box').textContent = 'üìê 3-Box';
  document.getElementById('btn-clear-boxes').style.display = 'none';
  document.getElementById('three-box-status').textContent = '';
}

function handleThreeBoxClick(param) {
  if (!threeBox.drawing || !param.point) return;
  const price = state.candleSeries.coordinateToPrice(param.point.y);
  if (price == null || isNaN(price)) return;

  if (threeBox.clickCount === 0) {
    threeBox.price1 = price;
    threeBox.clickCount = 1;
    threeBox.tempLine = state.candleSeries.createPriceLine({
      price: price, color: '#ff9800', lineWidth: 1, lineStyle: 2,
      axisLabelVisible: true, title: '‚ë† ' + price.toFixed(2),
    });
    document.getElementById('three-box-status').textContent =
      '‚ë† ' + price.toFixed(2) + ' ‚Äî ‚ë° Click end of range';
  } else if (threeBox.clickCount === 1) {
    threeBox.price2 = price;
    threeBox.drawing = false;
    if (threeBox.tempLine) {
      try { state.candleSeries.removePriceLine(threeBox.tempLine); } catch(e) {}
      threeBox.tempLine = null;
    }
    computeAndDrawBoxes();
  }
}

function computeAndDrawBoxes() {
  const p1 = threeBox.price1, p2 = threeBox.price2;
  const range = Math.abs(p1 - p2);
  if (range === 0) { cancelThreeBoxDrawing(); return; }
  const bearish = p1 > p2;
  // 5 boundaries: 0 (start), 1 (end of measured range), 2, 3, 4 (end of box 3)
  const boundaries = [];
  for (let i = 0; i <= 4; i++) boundaries.push(bearish ? p1 - i * range : p1 + i * range);
  threeBox.boxData = { boundaries, bearish, range };

  const btn = document.getElementById('btn-three-box');
  btn.classList.remove('drawing');
  btn.classList.add('active');
  btn.textContent = 'üìê 3-Box';
  document.getElementById('btn-clear-boxes').style.display = 'inline-block';
  const dir = bearish ? 'üî¥ Bear' : 'üü¢ Bull';
  document.getElementById('three-box-status').textContent =
    dir + ' | Range: ' + range.toFixed(2) + ' | Reversal: ' + boundaries[4].toFixed(2);
  renderThreeBoxOverlay();
}

function renderThreeBoxOverlay() {
  if (!threeBox.overlay || !threeBox.boxData || !state.candleSeries) return;
  sizeThreeBoxCanvas();
  const canvas = threeBox.overlay;
  const dpr = window.devicePixelRatio || 1;
  const w = canvas.width / dpr, h = canvas.height / dpr;
  const ctx = canvas.getContext('2d');
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  const { boundaries, bearish } = threeBox.boxData;
  let chartW = w - 55;
  try { chartW = state.chart.timeScale().width(); } catch(e) {}

  // Convert prices to Y with off-screen clamping
  const yCoords = boundaries.map(p => {
    const y = state.candleSeries.priceToCoordinate(p);
    if (y !== null && y !== undefined) return y;
    const topP = state.candleSeries.coordinateToPrice(0);
    const botP = state.candleSeries.coordinateToPrice(h);
    if (topP != null && p > topP) return -20;
    if (botP != null && p < botP) return h + 20;
    return null;
  });
  if (yCoords.every(y => y === null)) return;

  const fills  = ['rgba(150,150,180,0.10)','rgba(68,138,255,0.10)','rgba(68,138,255,0.10)','rgba(0,230,118,0.16)'];
  const strokes = ['rgba(150,150,180,0.50)','rgba(68,138,255,0.50)','rgba(68,138,255,0.50)','rgba(0,230,118,0.70)'];
  const lblBg   = ['rgba(100,100,130,0.85)','rgba(55,120,230,0.85)','rgba(55,120,230,0.85)','rgba(0,180,80,0.85)'];

  // Draw 4 boxes
  for (let i = 0; i < 4; i++) {
    const y1 = yCoords[i], y2 = yCoords[i + 1];
    if (y1 === null || y2 === null) continue;
    const top = Math.min(y1, y2), boxH = Math.abs(y2 - y1);
    ctx.fillStyle = fills[i];
    ctx.fillRect(0, top, chartW, boxH);
    // Top border line
    ctx.strokeStyle = strokes[i];
    ctx.lineWidth = i === 3 ? 1.5 : 1;
    ctx.setLineDash([]);
    ctx.beginPath(); ctx.moveTo(0, y1); ctx.lineTo(chartW, y1); ctx.stroke();
  }
  // Bottom border of box 3
  if (yCoords[4] !== null) {
    ctx.strokeStyle = strokes[3]; ctx.lineWidth = 2; ctx.setLineDash([6, 3]);
    ctx.beginPath(); ctx.moveTo(0, yCoords[4]); ctx.lineTo(chartW, yCoords[4]); ctx.stroke();
    ctx.setLineDash([]);
  }

  // Boundary labels (0‚Äì4)
  ctx.textBaseline = 'middle';
  for (let i = 0; i < 5; i++) {
    const y = yCoords[i];
    if (y === null || y < -15 || y > h + 15) continue;
    const bg = i < 4 ? lblBg[i] : lblBg[3];
    const pw = 20, ph = 16, px = 6, py = y - ph / 2, r = 3;
    // Rounded rect pill
    ctx.fillStyle = bg;
    ctx.beginPath();
    ctx.moveTo(px + r, py); ctx.lineTo(px + pw - r, py);
    ctx.quadraticCurveTo(px + pw, py, px + pw, py + r);
    ctx.lineTo(px + pw, py + ph - r);
    ctx.quadraticCurveTo(px + pw, py + ph, px + pw - r, py + ph);
    ctx.lineTo(px + r, py + ph);
    ctx.quadraticCurveTo(px, py + ph, px, py + ph - r);
    ctx.lineTo(px, py + r);
    ctx.quadraticCurveTo(px, py, px + r, py);
    ctx.closePath(); ctx.fill();
    // Number
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 11px -apple-system, BlinkMacSystemFont, sans-serif';
    ctx.textAlign = 'center';
    ctx.fillText(String(i), px + pw / 2, y);
    // Price
    ctx.fillStyle = 'rgba(255,255,255,0.55)';
    ctx.font = '10px -apple-system, BlinkMacSystemFont, sans-serif';
    ctx.textAlign = 'left';
    ctx.fillText(boundaries[i].toFixed(2), px + pw + 5, y);
    ctx.textAlign = 'center';
  }

  // "REVERSAL ZONE" label in box 3
  if (yCoords[3] !== null && yCoords[4] !== null && Math.abs(yCoords[4] - yCoords[3]) > 24) {
    const midY = (yCoords[3] + yCoords[4]) / 2;
    ctx.fillStyle = 'rgba(0,230,118,0.85)';
    ctx.font = 'bold 11px -apple-system, BlinkMacSystemFont, sans-serif';
    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
    ctx.fillText('‚ö° REVERSAL ZONE', chartW / 2, midY);
  }
}

function scheduleThreeBoxRedraw() {
  if (threeBoxRedrawPending || !threeBox.boxData) return;
  threeBoxRedrawPending = true;
  requestAnimationFrame(() => { renderThreeBoxOverlay(); threeBoxRedrawPending = false; });
}

// ============= LEVELS TOOL =============
const levels = { active: false, overlay: null, data: null };
let levelsRedrawPending = false;

// Swing point lookback per TF (matches backtest_v11c_surpass.py)
const SWING_LOOKBACK = { '1m': 10, '15m': 5, '1H': 5 };
// Min move % per pair per TF (min_pct * 3)
const MIN_MOVE_PCT = {
  BTC: { '1m': 1.5, '15m': 3.0, '1H': 4.5 },
  ETH: { '1m': 2.4, '15m': 4.5, '1H': 6.0 },
  SOL: { '1m': 3.0, '15m': 6.0, '1H': 9.0 },
};

function findSwingPoints(candles, lookback) {
  const highs = [], lows = [];
  for (let i = lookback; i < candles.length - lookback; i++) {
    let isHigh = true, isLow = true;
    for (let j = i - lookback; j <= i + lookback; j++) {
      if (candles[j].high > candles[i].high) isHigh = false;
      if (candles[j].low < candles[i].low) isLow = false;
    }
    if (isHigh) highs.push({ idx: i, time: candles[i].time, price: candles[i].high });
    if (isLow) lows.push({ idx: i, time: candles[i].time, price: candles[i].low });
  }
  return { highs, lows };
}

function findTradeLevels(candles, trade, skipVolCheck) {
  const lookback = SWING_LOOKBACK[trade.tf] || 5;
  const { highs, lows } = findSwingPoints(candles, lookback);
  const minPct = MIN_MOVE_PCT[trade.pair]?.[trade.tf] || 1.5;
  const entryTime = trade.et;

  if (trade.dir === 'S') {
    // SHORT = UP move (3 higher highs)
    // Find 3 ascending swing highs before entry
    const beforeEntry = highs.filter(h => h.time <= entryTime);
    for (let i = beforeEntry.length - 3; i >= 0; i--) {
      const h1 = beforeEntry[i], h2 = beforeEntry[i+1], h3 = beforeEntry[i+2];
      if (h2.price <= h1.price || h3.price <= h2.price) continue;
      // Proportional spacing: each level must be at least 15% of the L1‚ÜíL3 range
      const levelRange = h3.price - h1.price;
      const step1 = h2.price - h1.price;
      const step2 = h3.price - h2.price;
      if (levelRange > 0 && (step1 / levelRange < 0.25 || step2 / levelRange < 0.25)) continue;
      // Find bottom before h1: the absolute LOWEST candle before h1
      const searchCandles = candles.filter(c => c.time < h1.time);
      if (!searchCandles.length) continue;
      const bottomCandle = searchCandles.reduce((min, c) => c.low < min.low ? c : min);
      const bottom = { time: bottomCandle.time, price: bottomCandle.low };
      const totalMove = h3.price - bottom.price;
      const movePct = (totalMove / bottom.price) * 100;
      if (movePct < minPct) continue;
      // Check volume spike in L2‚ÜíL3 segment
      const seg = candles.filter(c => c.time >= h2.time && c.time <= h3.time);
      const fullSeg = candles.filter(c => c.time >= bottom.time && c.time <= h3.time);
      if (seg.length && fullSeg.length) {
        const maxVol = Math.max(...seg.map(c => c.volume));
        const avgVol = fullSeg.reduce((s,c) => s + c.volume, 0) / fullSeg.length;
        if (!skipVolCheck && maxVol < avgVol * 1.3) continue;
      }
      return {
        type: 'UP',
        bottom: bottom,
        levels: [h1, h2, h3],
        movePct: movePct.toFixed(2),
      };
    }
  } else {
    // LONG = DOWN move (3 lower lows)
    const beforeEntry = lows.filter(l => l.time <= entryTime);
    for (let i = beforeEntry.length - 3; i >= 0; i--) {
      const l1 = beforeEntry[i], l2 = beforeEntry[i+1], l3 = beforeEntry[i+2];
      if (l2.price >= l1.price || l3.price >= l2.price) continue;
      // Proportional spacing: each level must be at least 15% of the L1‚ÜíL3 range
      const levelRange = l1.price - l3.price;
      const step1 = l1.price - l2.price;
      const step2 = l2.price - l3.price;
      if (levelRange > 0 && (step1 / levelRange < 0.25 || step2 / levelRange < 0.25)) continue;
      // Find top before l1: the absolute HIGHEST candle before l1
      const searchCandlesTop = candles.filter(c => c.time < l1.time);
      if (!searchCandlesTop.length) continue;
      const topCandle = searchCandlesTop.reduce((max, c) => c.high > max.high ? c : max);
      const top = { time: topCandle.time, price: topCandle.high };
      const totalMove = top.price - l3.price;
      const movePct = (totalMove / top.price) * 100;
      if (movePct < minPct) continue;
      // Volume check
      const seg = candles.filter(c => c.time >= l2.time && c.time <= l3.time);
      const fullSeg = candles.filter(c => c.time >= top.time && c.time <= l3.time);
      if (seg.length && fullSeg.length) {
        const maxVol = Math.max(...seg.map(c => c.volume));
        const avgVol = fullSeg.reduce((s,c) => s + c.volume, 0) / fullSeg.length;
        if (!skipVolCheck && maxVol < avgVol * 1.3) continue;
      }
      return {
        type: 'DOWN',
        top: top,
        levels: [l1, l2, l3],
        movePct: movePct.toFixed(2),
      };
    }
  }
  return null;
}

function createLevelsOverlay() {
  if (levels.overlay) return;
  const container = document.getElementById('chart-container');
  const canvas = document.createElement('canvas');
  canvas.id = 'levels-overlay';
  container.appendChild(canvas);
  levels.overlay = canvas;
  sizeLevelsCanvas();
}

function sizeLevelsCanvas() {
  if (!levels.overlay) return;
  const container = document.getElementById('chart-container');
  const dpr = window.devicePixelRatio || 1;
  const w = container.clientWidth * dpr;
  const h = container.clientHeight * dpr;
  if (levels.overlay.width !== w || levels.overlay.height !== h) {
    levels.overlay.width = w;
    levels.overlay.height = h;
    levels.overlay.style.width = container.clientWidth + 'px';
    levels.overlay.style.height = container.clientHeight + 'px';
  }
}

function toggleLevels() {
  if (!state.candleSeries) return;
  const btn = document.getElementById('btn-levels');
  if (levels.active) {
    // Turn off
    levels.active = false;
    levels.data = null;
    btn.classList.remove('active');
    document.getElementById('levels-status').textContent = '';
    if (levels.overlay) {
      const ctx = levels.overlay.getContext('2d');
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, levels.overlay.width, levels.overlay.height);
    }
    // Remove level markers from candle series
    refreshCandleMarkers();
    return;
  }
  // Turn on
  levels.active = true;
  btn.classList.add('active');
  createLevelsOverlay();
  computeLevels();
}

async function computeLevels() {
  if (!levels.active || state.selectedIndex < 0) return;
  const trade = state.filtered[state.selectedIndex];
  
  // Use pre-computed levels from trade data if available
  if (trade.levels) {
    const lv = trade.levels;
    levels.data = {
      type: lv.type,
      levels: [
        { time: lv.l1.time, price: lv.l1.price },
        { time: lv.l2.time, price: lv.l2.price },
        { time: lv.l3.time, price: lv.l3.price },
      ],
      movePct: lv.move_pct?.toFixed(2) || '?',
    };
    if (lv.type === 'UP') {
      levels.data.bottom = { time: lv.origin.time, price: lv.origin.price };
    } else {
      levels.data.top = { time: lv.origin.time, price: lv.origin.price };
    }
    const dir = lv.type === 'UP' ? 'üìà UP' : 'üìâ DOWN';
    const originLabel = lv.type === 'UP' ? 'Bottom' : 'Top';
    document.getElementById('levels-status').textContent =
      `${dir} | Move: ${levels.data.movePct}% | ${originLabel}: ${lv.origin.price.toFixed(2)} ‚Üí L1 ‚Üí L2 ‚Üí L3`;
    refreshCandleMarkers();
    renderLevelsOverlay();
    return;
  }
  
  // Fallback: compute from candle data
  const cacheKey = `${trade.pair}_${trade.tf}_${trade.et}`;
  let candles = state.candleCache[cacheKey];
  if (!candles || !candles.length) {
    document.getElementById('levels-status').textContent = 'No candle data';
    return;
  }
  
  let result = findTradeLevels(candles, trade);
  
  // If not found, fetch extended data
  if (!result) {
    document.getElementById('levels-status').textContent = '‚è≥ Loading more data...';
    const extKey = `${trade.pair}_${trade.tf}_${trade.et}_ext`;
    if (!state.candleCache[extKey]) {
      const symbol = SYMBOL_MAP[trade.pair];
      const interval = INTERVAL_MAP[trade.tf];
      const pad = LEVELS_PADDING[trade.tf] || 300;
      const tfMs = TF_MINUTES[trade.tf] * 60 * 1000;
      const startTime = (trade.et * 1000) - (pad * tfMs);
      const endTime = Math.max(trade.xt * 1000, trade.et * 1000) + (CANDLE_PADDING[trade.tf] * tfMs);
      let allCandles = [];
      let cursor = startTime;
      while (cursor < endTime) {
        const url = `${BINANCE_API}?symbol=${symbol}&interval=${interval}&startTime=${cursor}&endTime=${endTime}&limit=1000`;
        try {
          const resp = await fetch(url);
          const data = await resp.json();
          if (!data || !data.length) break;
          allCandles = allCandles.concat(data);
          cursor = data[data.length - 1][0] + 1;
          if (data.length < 1000) break;
        } catch (e) { break; }
      }
      state.candleCache[extKey] = allCandles.map(c => ({
        time: Math.floor(c[0] / 1000),
        open: parseFloat(c[1]),
        high: parseFloat(c[2]),
        low: parseFloat(c[3]),
        close: parseFloat(c[4]),
        volume: parseFloat(c[5]),
      }));
    }
    candles = state.candleCache[extKey];
    result = findTradeLevels(candles, trade);
    if (!result) result = findTradeLevels(candles, trade, true);
  }
  
  levels.data = result;
  if (!result) {
    document.getElementById('levels-status').textContent = '‚ö†Ô∏è Could not find 3 levels';
    renderLevelsOverlay();
    refreshCandleMarkers();
    return;
  }
  const dir = result.type === 'UP' ? 'üìà UP' : 'üìâ DOWN';
  const origin = result.type === 'UP' ? result.bottom : result.top;
  document.getElementById('levels-status').textContent =
    `${dir} | Move: ${result.movePct}% | ${result.type === 'UP' ? 'Bottom' : 'Top'}: ${origin.price.toFixed(2)} ‚Üí L1 ‚Üí L2 ‚Üí L3`;
  
  refreshCandleMarkers();
  renderLevelsOverlay();
}

function refreshCandleMarkers() {
  // Rebuild all candle markers (entry/exit + levels)
  if (state.selectedIndex < 0) return;
  const trade = state.filtered[state.selectedIndex];
  const markers = [];

  // Entry marker
  markers.push({
    time: trade.et,
    position: trade.dir === 'L' ? 'belowBar' : 'aboveBar',
    color: '#00bcd4',
    shape: trade.dir === 'L' ? 'arrowUp' : 'arrowDown',
    text: '‚ñ∂ ENTRY',
  });
  // Exit marker
  markers.push({
    time: trade.xt,
    position: trade.r >= 0 ? (trade.dir === 'L' ? 'aboveBar' : 'belowBar') : (trade.dir === 'L' ? 'belowBar' : 'aboveBar'),
    color: trade.r >= 0 ? '#ffd700' : '#ff1744',
    shape: 'circle',
    text: trade.exit_type === 'stop' ? '‚úï STOP' : '‚úì EXIT ' + (trade.r >= 0 ? '+' : '') + trade.r.toFixed(2) + 'R',
  });

  // Level markers
  if (levels.active && levels.data) {
    const d = levels.data;
    const origin = d.type === 'UP' ? d.bottom : d.top;
    const originLabel = d.type === 'UP' ? '‚ñº BOTTOM' : '‚ñ≤ TOP';
    markers.push({
      time: origin.time,
      position: d.type === 'UP' ? 'belowBar' : 'aboveBar',
      color: '#ff9800',
      shape: 'circle',
      text: originLabel,
    });
    d.levels.forEach((lv, i) => {
      markers.push({
        time: lv.time,
        position: d.type === 'UP' ? 'aboveBar' : 'belowBar',
        color: '#b388ff',
        shape: 'circle',
        text: `L${i+1}`,
      });
    });
  }

  markers.sort((a, b) => a.time - b.time);
  state.candleSeries.setMarkers(markers);
}

function renderLevelsOverlay() {
  if (!levels.overlay || !state.candleSeries) return;
  sizeLevelsCanvas();
  const canvas = levels.overlay;
  const dpr = window.devicePixelRatio || 1;
  const w = canvas.width / dpr, h = canvas.height / dpr;
  const ctx = canvas.getContext('2d');
  ctx.setTransform(1, 0, 0, 1, 0, 0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  if (!levels.active || !levels.data) return;
  ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

  const d = levels.data;
  let chartW = w - 55;
  try { chartW = state.chart.timeScale().width(); } catch(e) {}

  const priceToY = (p) => {
    const y = state.candleSeries.priceToCoordinate(p);
    if (y !== null && y !== undefined) return y;
    return null;
  };
  const timeToX = (t) => {
    const x = state.chart.timeScale().timeToCoordinate(t);
    if (x !== null && x !== undefined) return x;
    return null;
  };

  // Draw connecting lines between levels
  const origin = d.type === 'UP' ? d.bottom : d.top;
  const allPoints = [origin, ...d.levels];
  
  ctx.strokeStyle = 'rgba(179, 136, 255, 0.6)';
  ctx.lineWidth = 2;
  ctx.setLineDash([6, 4]);
  ctx.beginPath();
  let started = false;
  for (const pt of allPoints) {
    const x = timeToX(pt.time);
    const y = priceToY(pt.price);
    if (x === null || y === null) continue;
    if (!started) { ctx.moveTo(x, y); started = true; }
    else ctx.lineTo(x, y);
  }
  ctx.stroke();
  ctx.setLineDash([]);

  // Draw level price lines (dashed horizontal)
  const levelColors = ['#ff9800', '#b388ff', '#b388ff', '#b388ff'];
  const levelLabels = [d.type === 'UP' ? 'Bottom' : 'Top', 'L1', 'L2', 'L3'];
  
  allPoints.forEach((pt, i) => {
    const y = priceToY(pt.price);
    if (y === null || y < -20 || y > h + 20) return;
    
    // Dashed price line
    ctx.strokeStyle = levelColors[i] + '66';
    ctx.lineWidth = 1;
    ctx.setLineDash([4, 4]);
    ctx.beginPath();
    ctx.moveTo(0, y);
    ctx.lineTo(chartW, y);
    ctx.stroke();
    ctx.setLineDash([]);

    // Label pill on right side
    const label = levelLabels[i];
    ctx.font = 'bold 11px -apple-system, BlinkMacSystemFont, sans-serif';
    const tw = ctx.measureText(label).width;
    const px = chartW - tw - 18, py = y - 9, pw = tw + 12, ph = 18, r = 3;
    ctx.fillStyle = levelColors[i] + 'cc';
    ctx.beginPath();
    ctx.moveTo(px + r, py); ctx.lineTo(px + pw - r, py);
    ctx.quadraticCurveTo(px + pw, py, px + pw, py + r);
    ctx.lineTo(px + pw, py + ph - r);
    ctx.quadraticCurveTo(px + pw, py + ph, px + pw - r, py + ph);
    ctx.lineTo(px + r, py + ph);
    ctx.quadraticCurveTo(px, py + ph, px, py + ph - r);
    ctx.lineTo(px, py + r);
    ctx.quadraticCurveTo(px, py, px + r, py);
    ctx.closePath(); ctx.fill();

    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(label, px + pw/2, y);
  });

  // Draw "3 LEVELS" label at top
  ctx.font = 'bold 13px -apple-system, BlinkMacSystemFont, sans-serif';
  ctx.fillStyle = 'rgba(179, 136, 255, 0.85)';
  ctx.textAlign = 'left';
  ctx.textBaseline = 'top';
  const dirIcon = d.type === 'UP' ? 'üìà' : 'üìâ';
  ctx.fillText(`${dirIcon} 3 Levels (${d.movePct}% move)`, 40, 10);
}

function scheduleLevelsRedraw() {
  if (levelsRedrawPending || !levels.data) return;
  levelsRedrawPending = true;
  requestAnimationFrame(() => { renderLevelsOverlay(); levelsRedrawPending = false; });
}

// ============= EQUITY MODE TOGGLE =============
function setEquityMode(mode) {
  state.equityMode = mode;
  document.getElementById('btn-flat-r').classList.toggle('active', mode === 'flat');
  document.getElementById('btn-compound').classList.toggle('active', mode === 'compound');
  renderEquityCurve();
}

// ============= DATE RANGE EVENTS =============
document.getElementById('date-from').addEventListener('change', () => applyFilters());
document.getElementById('date-to').addEventListener('change', () => applyFilters());

// Set "To" date default to today
document.getElementById('date-to').value = new Date().toISOString().slice(0, 10);

// ============= LAZY LOADING =============
const YEAR_FILES_RECENT = [2026, 2025, 2024, 2023];
const YEAR_FILES_OLDER = [2022, 2021, 2020, 2019, 2018, 2017];
let olderYearsLoaded = false;

async function loadTradeYears(years) {
  const results = await Promise.all(
    years.map(y =>
      fetch(`v11c-trades-${y}.json`)
        .then(r => r.json())
        .catch(e => { console.error(`Failed to load ${y}:`, e); return []; })
    )
  );
  const trades = results.flat();
  fixTimezones(trades);
  return trades;
}

async function loadOlderYears() {
  if (olderYearsLoaded) return;
  const btn = document.getElementById('load-more-btn');
  const status = document.getElementById('load-status');
  btn.disabled = true;
  btn.textContent = '‚è≥ Loading...';
  status.textContent = 'Loading 2017‚Äì2022 (~1MB)...';

  const olderTrades = await loadTradeYears(YEAR_FILES_OLDER);
  TRADE_DATA = TRADE_DATA.concat(olderTrades);
  olderYearsLoaded = true;

  document.getElementById('load-more-bar').style.display = 'none';

  const currentIdx = state.selectedIndex;
  const currentTrade = currentIdx >= 0 ? state.filtered[currentIdx] : null;
  applyFilters();
  // Restore selection if possible
  if (currentTrade) {
    const newIdx = state.filtered.findIndex(t => t.et === currentTrade.et && t.pair === currentTrade.pair && t.tf === currentTrade.tf);
    if (newIdx >= 0) {
      state.selectedIndex = newIdx;
      renderTradeList();
    }
  }
}

// ============= V2 TRADE LOADING =============
const V2_FILES = ['v2-trades-BTCUSDT-15m'];  // Add more as we backtest

async function loadAllV2Trades() {
  const results = await Promise.all(
    V2_FILES.map(f =>
      fetch(`${f}.json`)
        .then(r => r.json())
        .catch(e => { console.error(`Failed to load ${f}:`, e); return []; })
    )
  );
  return results.flat();
}

// ============= INIT =============
window.addEventListener('DOMContentLoaded', async () => {
  const bar = document.getElementById('load-more-bar');
  const status = document.getElementById('load-status');
  const loadBtn = document.getElementById('load-more-btn');

  // V2 mode: load all V2 trade files
  const trades = await loadAllV2Trades();
  TRADE_DATA = trades;
  document.querySelector('.header h1').textContent = `üìä V2 Trade Review ‚Äî ${trades.length} Trades`;
  status.textContent = `V2 Backtest: ${trades.length} trades (BTC 15m)`;
  loadBtn.style.display = 'none';
  if (bar) bar.style.display = 'none';

  // Set date range to cover all trades
  if (trades.length > 0) {
    const minDate = new Date(Math.min(...trades.map(t => t.et * 1000)));
    const maxDate = new Date(Math.max(...trades.map(t => t.et * 1000)));
    document.getElementById('date-from').value = minDate.toISOString().slice(0, 10);
    document.getElementById('date-to').value = maxDate.toISOString().slice(0, 10);
  }

  initChart();
  applyFilters();

  // Restore trade from URL hash if present
  let startIdx = 0;
  const hash = window.location.hash.slice(1);
  if (hash && state.filtered.length > 0) {
    const [hp, htf, het] = hash.split('_');
    const et = parseInt(het);
    if (et) {
      const found = state.filtered.findIndex(t => t.pair === hp && t.tf === htf && t.et === et);
      if (found >= 0) startIdx = found;
    }
  }
  if (state.filtered.length > 0) selectTrade(startIdx);
});
</script>

</body>
</html>