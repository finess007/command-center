<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"68210544c242b78ebe2020e38c425f8e5106d7928809d228918b689d55dba339f69c6997dbb5edd75adc3eff1aa5df4daddbe39dbed3a4eeeeeaa519fa486e976e4b49c7934dd9efd1686008c5b35ded5cc425954522654b44a6b3b946374768eb4c817e79c3d648fc0072827842cb2a90910524e9a3db7ce3895606dfab20e6bc072b4ad5a5d3b8372e1607a0f211cb8487e4d7316296b471e0ddff6208ef20ccfb07e27b8d8b8fed8b5acbc7e5456fe2af6df9a3da62c22eb4a412fa1fdd86679e45fb9e9f26663b2ae3c1159b6079125b655fd2336fd04032deb6ee5dd24f6c0272fb49cdd8373838cf5138dff49602dde7d9910a2b57fa21c5330f47d4b6141a008fd2630065438b49713ba32bb8e913ba46e8945beabb624145f5b73edc3361b70ce310255f043713f543eaf2404d3eca8802519180864808ed4b678af7bf0304dd9c221ef26b2a67945b4367274e5b5a187f6a48cd0c63840c08397b701583538e44245b5d32eddc5c696f7f54e5f3ad781d01ae915d37643372251d82d16d3f8ed1c4038467fa4a61e3dcb203ac12406afac68417c24ff3dbc3a980d68eb7fbc161e292a2ae69362817ccbf9c674e6d8628251671b68128ee3f5a0c92473f20d192e94c7fbcfdc22b043e1956e9107e07ca1cfae43489e0771d781bf596fb3c2c676d9e74e30154c90f070279504b76a0e4a6a50cbf10c8864080b89d7b42ad5d219c9f0bf204027820f84235760329672026fed4b138e185a1d62c0c2913f036757e25d8497d7abc40ca32c1e5857fe92ebd5ad4a1bdc9e9b859e8071a5aed5bc63564b873951c7d449fa62a6e4d0c74ef38805ed49432d9ad20808c7106c727805950c733afaeb93d36d2570b395ad6cf7f846c503c26f2e0344de518d24dc68b29de8875442a074bdb07011fb3553c55013cc46cdefd039a2b41df50e85ccb825efdc252908eacf331bcfb3080bda3a62c15ed4a03de1cdda33cc79562cb10240c42df78250ef41901b8832dff0bde24e48fbf3c97882b5a0ebe0d89d9742efa04a4fd91d26ed54e975eb9d42c6d03d1dab9705f42966c89aa85a5527284b8962354ed52e1610af2306d11ea4f9ff62233b790f4867675a79fb6696571f706ddff1fe1d030f2b72d2c89d1d8644350884ebc945cccf52af494199039084eaab0d7aed55a1650b2d863c6a2e76f4c9b94c72c1729fb2c2407e41bb0fc725c638239236a5ab21006eda17fd46ebf457eb28beffa8134ba19c1f9b4a2cab25fcf4e5453d5410e7efb6d5d57e4d0f81b04b6f9ec8feecb53f229a964e95e10388868a2cc2d8253febf5e02fda6436adbffbc6d25bb404c3b95c84221598670ebbd64bb670d9a444747a4563e91106a8ce256161ccc2c89c2423d4da05099b54f1debdd29be8fb82fde34b16441c2d74cbd217ed1b126e02b6e9c9a3b5ce1cf96b50ae22e1151bdc4b5e8a06dc46994c3ea70b8cab372f264898ea64d34b2e1ea67b2815bd329ce56f55ca305f3b2f5e6603595af9c117b6b23221a2d73cc469583df6e66a14c009086b8444f338fe34f5ffea8ac9d3dcfef77871024dee2fc12124a03333fb428aaf5eb257bbec01c58396920d9b4d2529e6c8c235206ac20159257ecbaa200eee0701a630a86b1cf60a2da0df9635efa307f38b4031429ea79940c0da635ff270744149a87e6c6f8c65da008b965b5217734c5825f9de7a6140c51bf2307092054b4891e81607709ad6b08af8873f7de8caacbcea005bd21045b711c6a8685d3af3c83b9eb27ade8d593029ce4392f5c32a42c569c074ce24836d5961557560a243a1280fd66b86a42c7d807c8791f3560c941cb815d72202399a6e6522bf8af26016672e91c925168dac35520a2454aab6e2c9ab7ed0175d78c106d133674edf0e44b87446b20157d392232f40e3124fef54cb1164371ad4be5aec28baac2c78de6bcc364d3e05e3af6a2f37b790ab6cff72371bd29dd4eab5ff2bd693e728e7dfefcbe4d9ff61052617294ddbfe15cdf05a5acf58652194d19e01c8a0f5fff09239d4796e5e7c3609c54dbbb9b6157c80088fc5d3acdc4078d85ce7fabf0309f94a24ba4857f5962ad4f10c5f891c55bf504ef54b972d59080578bbf014a61cea1b5d868b107a4ef08ddc4a4b1a29a8917a9ca5f1754fa835475a14c593bf3d0796d871350095157819ab1fa378294351c1405719c2feced26239ad791719c4b6bb914076fd18b2d93994bf7b769a755a580941e97c6fd33345369b015b5d8e5350d37b403d3fa7eecd7df2cf142eaefe1ae76a517ad8f10afd93fc645ef7395951b4ff3e582b16df9c5e104f364aa67d47833609fad55f4ab9b4eac19c0191e3271120cdb07b2707bd45eea507832521c4af6d0fee54e6dbd8ac5d6fa1a17789b5f563046b147325761cde5f56e5879f9e7d03ee47e5b6d87f4fbdbf13a5c696b69ff840b51eafe876d5d20366403a885b5d286022c718d05a84a105ad5e9dcacc3cebf689393d833f358fa0279780f3dfd84edfacfd795e1a5ba1b43eef5972ccdfc1c79fb385c2a23fa37025c531b3cfb7435e8412f47211c7bdcb729f60562acdc29a1f4e17712769d4b669a9889bc48f034bd9e924eb6c256909b196e48b11d56899aed3d189ec94cad06383b99aef129a8f402b8ad881bfdeb0443283ad3189698bf2bc44b5945887f9bbdd48a566cf0e2c80195157d347975817cd1e8034da62c13f3892effb22c2abf9ca4f93dee36c25d6dd924adfbc8a209194faaee9739054bf603161bebfa65c9c10dd642c587813b04a18e9593188b8bae5cd111a7539c4af3b0e8ca4ef5336cd1d9d24b3e5780a1cf8e6fd0cfef8bd10c01e535896ac7bfa82692eba03c4ff44bf40add0b9bb99f1ac4ef3376f8feb5a93539def373d73189ecb80d4f04dbf4d678ae7086fe5dfc19cc5c10bf9d9f9ce03557b86bcb451c10f2e6216d45f3664064f89625f6fed769222c187d41a035ba14e2c2c449305d4e2021296dbcfcca4c913b06aa3e869a799ae70df3b44d856529e54be1b4fd782a0e573113b704a3178198ea8d6f25627dd608aa80b63e5c1488f37168ae88910af42e22abd294c1ef65dacc6da67d593b1eba0ee1d9cb46ac60a636f9a559c46d46463b1b4bd3ce6e2b5fb42e76fe666c98b520ad1ae3302bb3b4bccde877aca5cfd63cba13a807c5d46858dccce5856fe901c35e4bd91d02189d8bfbad19808e14e9d993e0e7682bb6ece8ff4c41cadff50a2cad51a611a6f69d46e6869f4db5dd5a73726f20a8463789fcb7d69712602f8c47a9830ab1d5db5affaa56860db4c70f129d331c725a07af0902da0e2623f7f5fb0244858c564edf81fff094abb2f03b0b216742512094e71f3bedb6543956c069956bc11c08da1b6569e655826fb53c12e9d14c12cd19be42a56ab347cccfd860d687d02f13d0538b5b4e578c11a494797b9627d42c0c4d73596ba6b46459f7b2998d025121d27e516d78eddbab6a7dfac74404cda6305eb79bafa190af326bcbd88e0cecb19f5344974c508d3a19741c3debf33284070370b7fed9c74c5fa099cea762f54e54f5b7f6e865217c59a3456b02046fdf77d7ae4b48a1a4ddef6a57c2ac19e63dff2006389b2800b5f693f37bebff5bcf1820660996ff2024b3e605b0a4777cfccb6d5962102d33ad52a85ee933757d357999f15f5d5400fc49530643be5cbc549e4f1abd99cf9a8c71c64a8d03a2b3f41d4021f926f60281cc3605004a0c7bb791361ea007c0b52c1c601107b9c972a1e5fe861c7bdd324e769ff8d3e8ca84da42c691261ddf7b11bf5437a2aa862a7c826c04f8bccb5785f93366067d62f39602c4a4574918b38e1b509545a9ddcad9e1e0e8117478d1abe7373c434676b72aec0b500f152521b017c2e70104b92ee8042627aaaba8753283b86532931fd853cf9a07c079305cb3cf6db0095379bc2808472a861d7c7ea3e360e105d6c3e142c3eec1af7bb79998685912e37fd5fe8c256c43d3f61def568f20e03cc69570dc4b94d9b6788fe65faa736234b53e5a5cef87988c3206ab27afeb6acbc911f1d5639ca2403693cff16cea5bc2265ed961bb86bd8741d9cfffffea5cdbe1eb2ca13f6bba913664deabedebf5cd7e87defef9d6ea93bb841da05c400a154d1d72a1a99ac60b242f21fcef740415b4300feb9c4363c7408b4b77024f35b6e92121d2090aa920521a256a8c536d616e7e8be3b60a8f8d298e5533b2b1a81f2b0ac2d614983b3c6904e5a912d2250ad3dfc60f726b15fc3d6b67026d5d94a89ce83e5d81a7378630a5256325950701e0400a910af214d4026200bc3e2693c942d20718264f9f4dfb9ed48724db604326d8afe46e072f3de0a503eb1cdabd67d775a528a6ad08a426e82679384899087b0fde2502741aea4bed9a92b034a6ef158c31f4109d945894f0aea7520eac8733eb4b23ffd78d6630a45197b9c44ab6ca4284b8a272878a51e609f2b5e3ecd54a070a18b675d1e5b54a8c95bd37014b37fc263b68827de7a516d6c62fb1fb7314b42e465c9c5c5d625241fbbbdbfcdbd94b28f83c10c7a50ce0fdf24c4cd69f44588174fa5b406cff672aa591a5c93dbed8e89e3c721b1b33142c181dbdb4ea59ee6de5e68bf3c25b64994d8d8cb66df1448a60161619269ce26ad0de450d0e7b7115dc04541943fc1f03d7c68b9fae64dd293b77f7c26810d226112bae1a754e684e2e8b5e4ac223275f3778e27baad251fd9eaa7f5e71ec411ecbcda45b480c6c97f929f00983be85cab7bb57ae9a6d93ac955c8d6b561febd87d18b16ec3df8e95a2d636c23e04f97a84708562ecf671c53aed09fd86a1c8d26327b79c8dd7020ff695587d64a62bacd3f80753797a1e7f86b214075fd2c25d5dd73967242069cc81c29efbf02c6790934128ac7a9fe6317274b14b39315110a006fb8ea99befbacf942209c5c77e17bb6e8d1905ae219780fbd782c563bb6a5151e6fe64369d5fd04160e578360f87a094b873a278445e5f6100460b1bd7857b65fbe7597f496aa9afd0a48d6f8e001558086099652c77183fa8ed44be3c5dde8dad2223bc201376b866f365aec2caac55e5957fd53d2e63a4c0bff992e9d8fe56940311e9ec8e7b86beaf595ef682fa5a9cd672268b1838b03cd3b84886cf50e92cae3615e9e133ac38b06ab8e972e7c47b9d91dae48aee72b2e6e5e676cb41bd26b86db57999ebe52d4a8e585b7fb1a6813e80cb9bf90eb53a063b71651884ff14dcb5473ae423088d76b350bfaf3514593809cb13df1060720408cfb51a48d551e6073db86a17af16b55b4add255fa5691c792bd9a79d8160f8b5c6501c613fa2532ec0d015a4fa57d1bb4b8128b3684117465346cf2d205682b7482283bf0935e0e77547728a0313681e57c17dcbeacd138b11e6fd7c595a1561a0e31765e217a77ad445be3c9eb641935fbdb67d241e5f7b2af953ee3134633f811cddd65039a6704c5b2539b7f6c79c5d4302a08c1e7c48bad3debf4eb4848a7d527daa3e979a906485c5515d88cf8239c7e0bfa8d9407eb86e127f6e32fdae68ee2f7d4c612225065bc667fc52f58f9c31857434754f3c486c4483cebcf88326abc10bede6d301d9cfb08619fa94f2aabe6a06f44e796e55da466ecc701505bb5f4a5a1ff03ec1ea1c6ec6e842d883cbd295daa7a85fcfe3ddcdc5907d19a2c06a2ceb6a25c2299d5072b15e1ad8c0ae6f201570c2824e64aa39e5459f5869db306fced64b6a36ee55753b7973fc9893728782b4b59081fcf5117fbde6ae2f4c7ebf004d8d3322dcba52e11617218218a5541bb5467ae5c9411b8cc26e418dba7370cec0623962c8b1e63e88b295d02f2ffc54606126cd5bb5814fe3d3787b6660ce99295c69f71116e4ce1abf2167dc5a72d4b776410d673acd32b64a101200a5d3cd715429be25ffce7c831dbae34e6c79bc83c5d95cfa19742a958d849d4396abb8f5a993cd15e606125581f95f90ddce720a35c9cd7ef09ecae64c5a2006f2d5a7a0de42bdb3fd746694db3c8faebde54a9fbdac6ae43fc85cc7537158ff155fa771fba31a103f443cb9af0d877cbc70de76abcdd11f8112c502b934edc61ae1331c33ed91a2654e9866777f3d5db57389da3e04c5d9838d6113f618035d8241a9d82a4cb6ca66280e437fc8a4a444f2fde405d43c92ee22cbea7dee909259367daf8386d2ee2e9bbf2f92d091883216a9b56dac0f1283467f9b0b003709cd9498ad9fcbee9da64924abbfb4bd612909a345940b095747a25030b92467d713946fcd4194dc1f9eb3cde8c834d614249ece3d942877c80f31dae39a446821732cf57eeb222a81e5a143eb9d81a2f9793b0292b3f767243ab6daa446259f1886688b5a13b7c0bf978a0b4611f61a2444bca5e4ac72eb628746f12226d5e56ffb97faf078adc48031349e53912ec94a900aeb3abb4ea6fc88b19c1d5dfa80936eff2410e716e9705d97a62025fd0356359e400d1bb09c05b27220c3ff3a8dc40ebffb46004dd1c45f910c4d9fd29af966a00b577aeaca64b3f5536224d25b48c74a5d0937cce9bc99944426dfa83967f2d6e3814f9c7af16eb96eebe463cfad2592cb6bb5823df799d7d76c1ba0ac4a2bc758a2e8d64b24ab9c0a29b45c2835309bd37f33cd565fa11a0e3c0ac1a391ee1b1da26c22e83c72523c3fc8e1794b106cc70fb79a5be49c7e13651bdc84c9e96f592dc51c382e59a0d25987096bdce8bce676c5ddaee87adb0fd8b216dca21499163ffd82f15ab5c3c54f7a39d5cc6786e850227453ac370af9cdd50d46e783a86b6f16ea5107ad8d687d1f80a3d02704a6f8a5b1c21c5e9e3888fddf139d0c0a8c4d0a67d35e6d6b7b45438aff73f2d11275769f61125d73aed6186b187f16297302a0aa74c3dc8ca4cc4710f2557735e81731204a64aeba425e757c943df393f72944a54633683f9ceb1b147acd39db2ceedb7468cc03f34b18d02da86d154e2e0d41f79db6d208a26035f31e7fd1d13b9ff1ba137324bdfddb15f9cebd6f28c299fc1eecc4bf929373b81aeeea2502afbfa2a9f4cd4649317e30944a9d3e8701a96a86c5ba6d0d94abe813e498ec52e4b7a69c9f44cf95e6663eb5388c20f381b182760fa0d9d648fca57f7da81e9bbde67686b52c676ad260e1922da754eb2601ac742421812e0db940591c5fd5122ee45b300bd30d60df8fdfdb8381c3ed51335d1b506378032da2e78996525054487bec6a9f29b3350425a1447b135190c3c89f248386b4d7924673cc6cd2e33a1d8c9a7e580310316cdc5dbdbd72f877bb221a0fa82b4b8b15f11eaff37f16992ff765da4913137e2768df40a11896783562b57a3df602391a669fe2e7d7a3cd16b904620ffb8462573f5157d4d46d6be46be3fe894009fbab9af08337637513ebe906e49fe25cc46fb7652e652c60021d0f284c2205f1fe04ff918903de1bf99bd271c49a4c9c3b25fa335b6a87311ce3bfc81119a5720ca2d77f77e21c71074ef5b56ed125a1c0c70af3eb9b51dbd97b1cc2e3a082536d2fd80667abdbf736888a06460b9707c638af2113882738271427797953d6e9c2a6c6f849cf9b6123c5f7ee84d3a4b50eef34a192b815ff624e47cbf81cf69466c3d8401dce8096238972215e2d4452fbd2a41732a7b3ac286760e18e6dd61c4f8ffd19b99187eee8c7eb041f2ef4cad7cae02c4ab178abb3ba74470121b82dab355aa37f02b0c66a401d66c3dc6f0c61feb726c693c6553daa2dd3254ceea5591589bc742cb9e75fa944f88e7ca9187f1bc978e469d43882a8d4bc899912ac7a91a822c364cde6d832aef89c98f1ae69418ad2ad7aa419e1f97f0ac0db2b5d8b40fcb8a0f9b1b1a49d32ba588cc42eb83b3bd43adb502322c3b00273875f530f1fdbcb654ff59ebd1552d2869143f84cb5083e2c06458eda1ef06254953372eae599d56dc22391150a2030bdbc27535a1821c3d8d71b9a5b52293b0c17e06552d611635ae06f5191ed820859f3745fa9fca8cc78e70cebcc7a356421b87a33b76469e59689abc85bd19f8ce6e9bf4e72b73bbe722f7b4f048a99d02831e1ac1695e87e319da1f2a107dbe5b049619e410fb1154eb8a2a4a42cca5c1ab3093fcac81456fadfa87fb1a6f2586ed1e1504714e9ba26ae2f665a7641445a77410a3770a72d7e36330d5d67c954fda67f7c8302ed45cea39208f5404fc3d67ca95bd4410ba82cd3fb6370d5f7b373f2a287cf3d514ed8c0932f452f2b5f2e35a08274f1d4293d2a9ecb71409b8691544ebf673d2cec1c785a2715550a3f2cce0c143ed05fdf09c0c887f2308e66f97f8bad58c43e0e56ac140cd703ad7d340abf942a7892835e9c48ca918817bad707425ffc69071284c85a7c5d528cb97fb0de53bf8e48f745a10b5a439d4311c8db2911e671ea9fa9249d74a0be9fc0279e991aeedf83d4c93b43d842a3817ccadb78bfdd366728d7e2870c3279f71895dc7dd428f642b949c44a55a7003c3e104ff6055c6cca77d1afed8c8df6e63de862c1f6feb339037a9b5c1a12d79be606e18414b91a15bda0fd17fd2a78dd3183b2afbe0965f3760b7e6b71149964d6bde49807688c64e38efd8fb22d8d3a16ad2db70064ee2795adae15d561d231c8a991d65494c88e62c52b268c9ed2a98920145d84b3170224a65317f2521be0c3892280c88dd625ec53cdae6e1b3f5cd8d32fbe84923213abcbdb2318a77cec325e49f02d9458c49029fd6d3074ac38b6f2416c8b942c2d6e475f1d371105391055a53694cd0d1f930959b996de2fff11207088891b81743b859a415bcc1f13a880c26340ad96eb9e8acaf6aea4a8e905003fa79387df775d5a06f54c3bbbbc81fdeb6685e416a51ad39ecbbb6b217f1b18a3852619da5fe5eeb3f951f59256436e3fffb1da9c226bd9d31917c8dd36abc3abad115c291293ef16074fd1675b841ccb3fe3983c9605874fc6bf3c451723ad4b066d26def4e5a41326f64b1b9d749e2ae0ecb7d6260b6d29a0ec6e0c59ac5091a54788e9ffbf4b70c5678a439fc56cc747dd96f7081be32ec21809ab67530923d56e153840034d12b81fa0038d6362e7e1cde420938b33526cead98afc19fb55077a07e112f6913e1f360b814692160c104b7285b56d138fe15a7741cf8bb94d1dd51d7148164440163abd0a79ac931bbdda4923f17485ad8aa699d93b33bb78ba6f2074855069a09150ee27eae372bc9d275e4f23350e457851f998f2024ae1217c1b3fb3d5a6de501c3bc0cbd60c06aeef88ea96563c591c47dfbeca668599ab3264a1625ac281176216f598e7c956267b340daf5a4b5e2e239e8e5e65214b81e9c640d88608b3041474ff049b0f3b573f55ce96b1f1a4dd94b3f6a39ed848d600079cebc370b76285167f56e191bdbe27011cbb8e17344a82c0062c93e1730acce3733f3740d2a46360ddbc472b56a23f4ec161a6d14af2fe5d80af13326c51e1c0de1a2bfc35377b9566686418ddb9681ec30b147549a404713e3fe0f6336c7d5bb83fa48adb11a266fe1b20c842012ccb6499088dcb7dcbe240101b46a2ec8aa1cf843790fc980f4e693f8b50ec36900cba0ac64be11129aad6983b46d7090cf37e398c02885f79716acbb65b481dd1749c1a58059335d89911d303d985fde6523518717ff12f73893b3bf0e7e548a63f669fad4ff4806749aa44095fd2c4f690330f065426e6ace8401897bcc4ee45d16cc05590ef715fb3ea11909244ef798320675a7866db4b3c2286f5592ad14b93882e89f4aa82944561211ad1bfc6602aec02ea606a523b7a4e92394dac57732931e9838ba82bdb6da444a71551555c3ba5b87d8d6c1b3db5060fc6c6c88a6bf3cda8aec517c950ee4364f794436f7eb3b42bdd463d4c9b41d7399492e65cbb75218fee86594b6e55f2c740a1a12432eb121f6eab8dd7660cf8954d24bf63771770ad31bbdc21819d05733c5b6cfcde941027cfd68d66b02c8561c8dc658a7fe2ef2c8511d5b5e592a113d9dd77197d9a11c0d8a09cf8978310d9dbc39e039f1c73afe280d55ecb050e47f2c237125b5ebdc1dde58f0b4d233695ad50e586b0446e128a83059dab2851b93158ca2c8666e09eb3897638dd75c1dc301c9033efa57a49718450e486b767153173187ef7e9747df6cd831f19728ca382bdee9cfaf343dfba283239e36a2b1efe0014728e494bde4011c5101843d613a86529c69460d609a08b1efa1dd7effe52158bea944c81a9de16d920c992fa40ef21287fe37cba04493db4ca3af02a4cb5a4befdd5a8861b9ce24877b198e05e82a3fd8da803681dfccce0b8b00996145bab4ccffe7b1c1091db652c708aee828b5a83a1cb407b806d48c1b696d055b79228982e3c4ad5ae31f8161c1389c881f164b68197c9b10f785baa83f9bec9257f3b7da42a8fc41e8f9ad30ec7256f780f84aa37e0f65123dcc989c98f3c369f36361362306f6e23b58ec75b0ea1b4477511edb0550bb7abae668703402ebcbb047682773f38296be73ba6e4af1748c3c163f587996c9bc2ee6a68e41abf6e73a17e8227b1a235dbe8bff75637894e513a01113ebeb2866c11d6cfa6c92d2eeb9d9f8e2e71a303afb8bfbf30cbd34f6ef042f6994eb685eb9dcc8b5a81e9e80d4f242994405b6744d4b81aa66e656acd73591f2148226c5aea1be6db52626463412690c4267d48d9ccee1f8753286cf38e9d279e947d0d6ab38096679d95a5707a0e1866561fbc9764bee42d393d8e5a05a9908c084a8160973b401fb36567570ad5de3fccefbe5e74224bf562c6a5071d4601af91524d338237c4e623de188cfaad0f4ac45c458477a7884f35153546d7e1de687817592030572924c5d2edd74805a23a4df5e61c64c7bfeec47b52a99dd70bdf1488615d026ec2ec5f4488ddafbbbeb81d9e53865a5ea0ab03fa17d40c673c46ad8b452971eee47142ab8fbfd23378d4c14238bd79c88d25b6fa2495c6698b854c072f3f566fae995c14e02b05b732a11b58eb29797d0a8a79eee36858ac8dcab3c0c4770dd278c6dd6c8daf9a9e074422841ce9af5a8a3a73c9ea7bb0c6b0f073aac48419bd5985902dce168300419d69ca5f86f2c20a328608b65e762a21c577ec5a4b82394ef383a338300c82614c29bf9eeb332d95089d214085d56573380bc96f221979bbeb2936735d997d6560d318b25640fa088e38be2ed68dc98b49b44c86747c37fd0d7a8ce5682ba7eab3230be91009fc4087ab3d1ebf696df10b6f5f4238053259bd1fd60d3a0008bb58b213f8aff65fc719873af2dc0b91c9b6ffe62acb2d2e5260709e69a3196bb6b07a5c76b7ad73a41ec42f60b4aa004cc3d69b106b090288268f1dba81e1294eb9eccdaf1bb1430dc56fba1f6a07b01fc581025a6157d16aef80d76a671801049ceb74671b2a41392e2a3f60a5965d79fddfb479563408b2ced62269dbc6fd64815e169f8e9e099c67be4d82d6be2d178ad9a342617627303ef62df4239ef67d2e91c89fb76bb09f41fcb64d27b2d477b96d576f1d28be8ce8f0fd0e47a622d00bdcd4ac1bd99875430975b506151131c1686da9649fe41fd67f0b7b2e3717cf7cd6fcabc7009da8cda6405af27257367af5ccd45159d0fb520682b4e3e1036b455145f99d8bed89caf84b179807bc83c7088d4eef4ba90eb5c3040eb2272c9f601e18da0ff8822dcdee58066af37f8302975a0fd633867f7b5971f51612e2bbaf142a6b44818144fecd000f7cbef1000b8df410dcb19f3769c38633886a564429fef8a477fea0aede36781f90a367e0836bd060d0dda87e23a05a550d23d176f75de869768d186dc7df3d128383da84bed02429a5b985f444f27a42f552b435dc6b69eee162daafd5c55d6b4accdff0aa75328c74e232d4af77e4bfbc5c4e1bcf73070310cc2a8634aaba88a19776f13c60108fcc4a7b9991ff0dd5458599f5760425d9c55f487583c108986a91fb5f47d3d11f0cd2a130000ee9aac1426e55a1f6d3695ce3218f5789f8a0c4dc6e04a24baf6ac3e4a9d6a699ed8a7d4aa5537afd6b9b90c0bcfd54dcf56661128e8e82c865a195093a47b079c4c3dddce2f343e6b7fb3569a36d9a3300bf36fc76342bc8c2f13ef53e0b9112bd523787bfaae2c66eb3854aec25a9bc2d02c045e1ad2674524df3406d747351bb1471390fdc5ef3d7d278b92b22347c623bb124ae62903b3eb8aca7899bf14628c9fae3176cb79fe763fd7485babd6b7e3f5a62f47027437cb0ea1a29914404d32f8a76374cc1aae3d679ac7d5103bd620288daaba4200e691afb6b28a4dae195dd1f6e5e82812cb73f4308986ad693e2fe979ef1fc2433843725c64d861ad632caba8a1c54a0c1c4897a5ebff2c770d3c3277ba0c128c0bfd3c4afa480d6581fa4ace8c3b9375586b573900374fb364d661b99f5480c4a649bb9c4dcf724a5a8642c0b28aab3917cd742e48e593763ff2f8a25fa99f06199b50c54b70ed127eedb8b581e0b594cb5851c248d674476282bc28279b337c1c3792a1b4d91464f8428d19c219eb2ed9cf382a287f43ed571b6cf9e80cc0334a7c2d8c968809bfce7a0aaba8d820ad31a8f191f76b0de6b4df683dce3192e350e310b2b505f7ab39befbdf1261aa0875645b29691c146f6c926c2d3a1522e5c2dbec47cc702d490451da6207612aa4d1143c0383c86a80d977c275e1bdedd96a0c6ee16a1699908d705a18ed59cbc304eb50d22c6131c83d2ddee6424be2ee492ff65f4e52f20639608ead83e24f1d469ac30939299c2c84067dc095e9ea5e8951f3d2a4e1ba01a63d5ce63e2a695d4942a1a9053e25e1095c1644244030520af8d76802249723682f019a7523f0c36cad48b07e1a58316b6577bc34ba3d14bd8f778842dbd83baa8a58b77ae65becfd6ea98e84d12b9f0b4e4d9deef0928bd9049473fc5f8f5a248bb18a28d7daa1699eecba88139be26e43a9a5cfad9e0911860f878a6bd323153387a7157216cf538452cf2c6e8f1d249c1c993822b6654a777554b1fa4cf5726ebaad8b4ea614e061d3e0e043349a8bd5f290ee8deb7abe2279128a2458bccbb3bb5c8fc24e5683f388b919f432e432f383f4818fb6e96bb5eaa5d78d4ebfe74e52965a6f17edaf813391c092326b5e73efcd27155f047dbd0119f2a722df31ee93d3fb09ebfadae2e689dd90d5787d71d165e10ed07b3369889f3ac106f0d6f1ac4e366cdf89a72e8dcff59242964ee8a929fcd1cde78b913db8bf0872dd537ab5bb0eeed0ac40494623d653087288067458bdfcbd3e7ced87f2f664ffe40a35f17c0ffd3dfa28c0c8879916ba880b288c2880a5c54a7035879b8711804ad60ffb9e2f2b031ed2e20a4995b0e55f170da29b4403a4fec0c58dcd813d5a8ac749037bcc299359134601c314762d28ac8bd77f903817cc59fd42bcbd428d122747cba4172a855cd3a41edba531f886b7b63cff4debc15a6d7c61d461d4f9dcce7fbf0d4b9f751224eb8fb8a3e2fed7dbf9bce7c918f1a0a7e5b658c42510219d051dc4092ba686bf2b5cbc4c9ceb4b72f61596979a4270875d5a200fcd998681152bc62b0d1fb7a7f8833aa470ef4779bd3626c384a685e82724d27ca9472fecde4269d5f31007ba7206e04341cf7ab15b40b7187e0fc18767b27a8dd42731b47a460f1377faefb037cabe761af9beefeaef5687e30781f63ae1112a2ab85316abdddde27510f1924784a6c030a333ac0eca2905b820b313ac1de6d91c69bd383adee5c43ee48bcc00b04b0b9e9cef299b0356b490dd6bcd64d59ab0ad2adde6dfdaabe5ea043f9adfad9991b61e705a482d0f60fdbc60646fd278b79f07a0261557028596ef20d535beabaafbd1da2f568a969338277fda8ba1d854ef73c568d50f71467adb21dfcf141a1e2c6ed1148141334c76e90b920cee09b0a30078244daa8972284395180c0b6b80eb6fc19746d703270f51f496cad4ec743e0f6ac7d3c23b05985d44da3b0f9b5ce22a03f77d98033aff6cdd4b55693d646de582145c2019b526186a8aac6a13c3e66e0735612045ed216b1aaa6fa2d772f83075d7e77e64e17e79421f5852b695256f381ad8318d7e9497a201408c5d83cc5ca2e15ba7f294583b6333b4c228052eaa3b5a376a1d1077a0859337b2063bb93fa1265191ce9dcb46cbc9fac98a423970fb623fb9f71bf04dcaccb688c278c1976c4b21cf6d0d2585bbde2fbc89c5df5d0215be72d5b572fcba0a9edc0702167ff0e9a588c0fadd9fa2cc44aea1534a710a28e006c55df92bcc0c7ba882311db9e345abac9a0aad4182fd633d2f0133bad9c9f6027e1193f9290e1144a26ce8899f500318ddcf340637db3f1c3d78ca16f019f769ec0ce7bbd804912fe83ef5dcdb40b20d5a15ed769441228f94a1c87ffc2e7a6bb6c5b4ec394aec30e9c0570f013eceba532810088b672713ace912a6d807e03bd06c4488566d938d6dd0ddaf121a43027c92e064fea07e5da7a343f1b559957a307595a34ccc310063fe3c18db84d9cdfff9a5c9c676cc33db8d1b4f33066cd312d8ffe98d5b05cdf92780bb3698d7850788451200ed4698f7936abc4ee37a64c9cb58f9ed5f262fde4dd43b58f2ebd1908434dacee6bad6d8edfff87bbfe0256cf96e812f54feae8abdc59a69948a1640f51e6c2390ad32f58993fe0c2baa279853ef3b20fe307d0799e30a39da8a1bf6148afb16ee307f6ca3c07c8479b0045a6bed907aab1440cd893e4f0c978e3794e860d5140bcc6af766458c19cabd0f0e5e62c211eaf8d61b5e0424f0d4dca40afe6422588ddb96de7c8f83bdd4a178be5062313f50f83849ba64622a40d57a1db4b75a4cff0f8438d89bbe71f4def5ff76c5f99a0db3f6eda4d79339d0132d0475e7679d7d75fdbda3c78b9f0f4e174e11d9d3c5824b803546f39447fd5864f383512d5e101ee645847cdaa4c74e4473c103382005dc3d567f0d65f8ac54186d254357e68e85997e67959f861cf5e6d4ad468a982f032f67e86650e2d5b5ff7b1126e7a9ad1521b4ef46f04078775df57c3d0018ee97b1d4e078bb945e316194fbe65c55cfb1644570a3a8935f1f0542ddd348f91c2d893fbc9a788874b9408e5064c3dc6f2e6603e6c517b2e6865cc7384ecd1a217c02f1cff48beba421c28020464ba2ee1840c2fb775bbe3f46619a9e84520fa1e78b9076363fe339e296ade71ce4c5ee3816473d8bbeffea5bed3d5cff286ae61ef4de0e219b3af5681b937caa5f7b221b727ddf57b9274d58c7044fda22087807c7da7c123642c2e8c7f6d47b61fb8cb51c9301bbf14e05057b5712901019f2143861f46694984fb8ef145a4b6ad3b28de1833621a21d17bc5e3599dc6e0934ef687575618f00a9df4e13a21de09fc514ffe99792d118c5fc00d4efa84b15b23e7d350504123272a681ad0199e1185cc06fb5c5f9f84c95106ddd115a0f29b1f5fd2b333a9c50add26aa0a16937dc1c899179c68f7fdd9856b1c7d2125084afb7d5a45d7ac572333f6077e53eef5e4e026551f8eebffb3be0d733a0de5c59b85b03bb8523e3f9474c363b75376ab5986318d37e362653b6c3e704e1dbfabfcab6ff4da750f9c51b67b8a0e31ad734356210b86b70120ec21a985543622a933d04bbcd9682a36b259d98829ef377f2c997c367cc9d8b53c831b0d23ac028bc5758bb602f8a0bfc52e22e483c898a4d8340764c8d76a24be680d5e500078c233ad5806bc357c486e805fc2387b8de0727146e871c3c8eeef1725897ba2ddf44d65ae79487f466f8290890cf9ea576e3c6d18b975ea38ce1117dbc1ecc5e9253e1542d29eca3789c5d071790052630a373aaa8d04e5fbbdbbca9170cfaf2aa1bd0e8e7660cf1a7770a7","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
