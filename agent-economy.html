<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2d520413637a157b3cccc6e756a7dae6f204dbf9c631ce02a4be97862de533c3eb19a700ff3664248e744af4bb4bf216b18408abb435326b487ab40224b1b6452475b3ea28fd1771bed1cae40ea85c1e04b1ba4a7863f77f21c4541e63b587847a5dce88cc22c2cfd5d684802df5029fec5cea86fa10f68422304824d0e61da2e99662ce50e2fa4ef8f547e5577c65eb2b3efb4d2c6c9d2c7feeed7e00374247cbd3dc5cdf10a7c1372312b0e3962722a8f55e6d9929d222fe91463b1699112955c424d98018a9f62d1cd7c5da676b9250009ca4dcf25fa3666f995517557480808f7b639f3ed5036bd33378809d225c139bbea5ed62c8e24a72a54b812808c18d96287567945109f1d2cfa72add68af0a05c13017649f3a1c065f0e59cc594814701f64b046f22d7a862440b4f1fdcfcca70e39f5dd0b4acb2ae4211ec3fa12c4dad6ce5f20a89fcb5dc543cd8981172a94ec2f00a640fbd93899d55ea30e186e846d588ed69724d750f0cdd0f7e0d7cd200888ecb590fcd62d8c01e99b784cf19384b1dd2fe4449c696f9563ae6169dc6af0209026d83a918b8f7cbb6e6d3a7d56d816122b6dece891ccbeb4cec53f2a6ff2b0e173e27cb0f8954701c76fd593dc78e5a4be6db9f5fc7235849572600f6db37d1aab92d72cd3f4fbac007a5cfac50844a3b24579a9f65957304d2445f8f1d2915bde846ac1a312a8ecb4b9664d75c0b6aa852cb3e9b1225e40fc6be6c8e4d007a32dd3d978f6db8adf0dd358ad8402029799d5d36ff5845603a514bd2b53eeabcf7e5f3439a7478e546b6b10d1b9e00128ee30c54b6e2a26712200fa025146690115e48448931c0dfa38e5828de4fc5c401a1325b655825ac5880245c6ced39c039b7906a20c156d580a386e599fbd32d78b283ce59c34f2153140360e70cefff76c55d4f3eb6373fa04424e054b477d0200ea869337765e9e328302f6f22b93e0157583e32450ac2b1a9ae5087d22481b7d8fab587ab1d463d17a674cccaf1b51f6e7224f9f684ffb302d733469d06a2e6a6bdd1c25d70f17364bec44a0c94c82987a1c806a38b939b31600f7d6cfb21ddf8721607a10e5eac82c2f265da071572e1e61e6bbdf0988a415765dbb031e7579f40bad6e315a3703b77ffcdb65822b5da3cf846ec15d9fde4635326698ed7fff8548f24ba03b5f3af2ddef5ccd3d0a51a934b975c98adee724f6a41141b62f3220a064d1d37e880fd4a3ccc65bf8dad795eef6ff0138baba8bbd99dfd379f204cdf5261608c3c36e8992aa4e1a64f9dee9c0482d02dccd69af568e25a11caedb005e6703e230f79c5d80088eb591213acb13a4eeedec5bc245f68ffdcec41e4a8ad3afea1c632ec9945a79aed094c7e4e0876312c0d4ae718d545bf88e4a617beced8a5a7fa888c8fb7a22d9cb3e51c4093a31b0de08098dcdf9c4183717a7f236ef2e21eb270d2c11545ee06e525ae33c1514ef1be3fdae140578f09ae9b05fda8f87a71c9f92975ff0b39d7ba94e80db59cbf10ecea7be17c21e3907734b59bd536a31a0fefb2bc757a004fc2b222f9fa96d61802063f20b6322486ca224f4259ba29f2ca68e7828c75989c9bbd799b91ac32c9440b3029be2f00baf276a241149e282a1e9abdb0a0cc625a410b8f0ade5a46a1a1d71fe0678bcaef270e09ce3f1c18d461d4b5ce8fc2f4d7ac66984fc7c56315926a75145b3f16a26703da7aef4214c55b0d51ca3b668afe291c72b5461b5a6b868b5f68a5977232a2eec2e34787901b128ea60453b6cfe1cfbc1afe9f9d5f14a0307a6c95f15d3986d15cfe9c0c3b309fe52712f0b75992108cc53b7b8bd707f628fcb2ecb68519737ac94af6cd1e2cab7ab06f5baf3f6589a59b7952625003c891093d79a7aa53fce1bd2c33577f9928f71c9763480c9151bafb93868d765b3353a4d4f7dc20521e8a4a724ce690798852a9dc7143a9a33f4b92a02d6f088a9bee8b5f38b29ad9049b919a721ba2baf563f0bfa4d5cfd977e92d591dfbaea9508d5b8a00cc8ce5ac7c6b8aefdac7fe5b0fbb3982bc29816e26f66e97315c784bce3752f49764fe33b66a62a2ef0f0f1000c51dce44f40ed8f9de984aed856e6026ed10944f70b4eab13ced2e9f00d3c00ea65dbdf8aab1a0e796b7580903d31227fd86b0a0e7afab9bd53bc715e1f8c76ab94efffc7aee8433e52d7ceb3de9214746806abf4d51c2557eafcb0832e12b8f3a4f44e97e4c60aac0468652f1dd2632a49950d886ff674b939849c32637a8f3c148a096a0b572c99525e99f683ba18edd250e94b4b15f4388687efee0b0728308ebe0826ad1c8adac28512a91b854f133c351059bef5170b705e4927b8a83df79c214d0167c2df236857d48450f7eed1bdcf57bcf4db5cb78f9396aa02e9775e330e8bc89d2ed2e33157dccd2964664669f82ad3f1a906cfa4a50d4c379092233643282cb32d2b5f9d07174f5398b36a8d460ecb294406a253d4ce4184d99acabd8b6e92477c3294d2b892b1791dc786d8562d335ec39a60cadba4400718af6b30d43c2665722847024d153d91221865b0a396e2b75740c11befb451d4f8dcca05c2cbc986fbcb65e00db06bc1af644153d63be0a7bb36930576a90f4d1b7d9f9acc44699c6175048d3bcd2ac728e4863e8117b5cd4e426cbe493c87057ff5ab1d96d60ea36f8bca42babbfea355d66d9b503507e1f4a8020e9794b4668e24a16eecc2991085666923eabfff77bb46edd3a9e3020e8f598a82926daaefaf0cc1c446ec94679e8df92f950c91ebb6277ae2256078937f222b05a436c7a01441940ec8fc8405645303ecca8a603914acfcbe71b85141e0f5d68fe559758575fd18b9f574287063b3668417d27c49a43dd53ae14a65e3a89ec31dd2a3389824d09538a25467fd1c82122bd7e33f96da8b8a26ef2ab92190530a7bd316dc46be0596b1cffdcdecb32d67a1e7b438e76db61ac1d330a3c4713846562aac4498d1aa1f8fd1812a9101b81d658130cb048bc05a2a8b008c7e14b0dfe37fa1b037e00555428f8a663cc997c5da6f69eace7590ea7936724944056c85dc6b8527fee5d2a47e7bd75737d750c777db7ef590e54dbe1fab668827711447127362c866bb2d8ae3027e5e93bf4501a8122de1453758013583b8e1857092a621d4d57ce3d1b4f5fb3b65cf23427c8f624647d9783191d5a388a6983b2d9a161aed0a62e4ef5691a1a2aef89e07de39931c0e5ef0439bf4a7c3bf4146afa904d9605cbb4221f071f3205d21e2a91dda1e8fbb9d87640ad5ba64e40b8f8cd44e7c22b902dda4e1805a5a96580fd99ce874db82345ddec26cb01098211d779a6bc284c0ccacb2befe18caf987955a05c92fe1a7024ae36259e21dc7fb6213220764dbb6a4b46a8392c4be500381a94c0f57adfbe7027e4301023fc9f410ddf0597e8ea18a138c6380369890f84770f751cd90d8b0de4a1cfeda40b5d8f08316d66f1f0417b75430b73be00d1543d6cfdba2347e253d0e8147c9bbb878d1c4efe4d91c37e0e91ca8341a37f96f4492b50053747b8bb5721b8a73826a6e88c9bd7e350f19040476f45b6d6f9f6c9a39a617dd0da8a31a546c6db61e1df489943750c958304b960a0d97e72e5592baca2e66687da4ad4160599ea78bc8b0ba773be76cebc6eb81bca659ba9a8961ca1e0e93ef8349e9478b01e5a52c4785dd0665f6a08b366532fca35440b3b7f7580b2ef49da5c645751391fdf3634aa09c36a02aec443cc345d6b83a7d98b6e8e6d9d8a7c8945c39dcf363cc9da94987e35da9c4a0817218d6a716e41458de73ca1ccc2c1c9a9e21ef8358cc0e2a945bc0b1d34fdbda46a74d8edb7d1cfeb53516e4ce307eafa495355ac1f37ae24ca8b1251a8d6dd939c85a86aa982abf86e39edf8d78e0731aeaf1edb7910d6a2f48be3642c576e8168aa0ea715d0a6f63a79f4bcf61e4f01fb4cdc336626c923ef6ca17dbe2c05f9d38e7e6ed2de8c0e2ec61dadb17ef6e49c16a40e8b38a5d80cc92e7d4030aed8081bc7bc8785c9d5d7279ba2b7a1e4e8931bc8d08545c176f5c84da40e13cd9a931b30e6db81ca0322353fc6cc34750b2a1eff9ff3ce9cfc1c3b1421ac066bbec235ca6e7d8811e14a66a35f4b786da1c46b2b88e3b42bb5f5a8ba4d9c3a87f60242890b315a34403af14b3ef53058863ea7f41e8452807974868d858145b4900db2bac8ae2ea3f765db3e30487355a0177eef84a1a0a2f4476fece2cb2d4dbc89e787df75c6f5ef7496d176c1c5b9ff28ebfc8596ce374af3c947a5b3b984ecba68db2e70db8cf1cddf9d9fcfc0c6c686bf21372d4beb01276d5c59313a3b05bcd8eba191aab426de28775943c67dfaebde117fc50a7d75a5f4c5173ebc27d38e35dd003a65329bbe2a8f4ac209c415fdf55514affcbc374881fe077acc4e5eed2c1732dc9e522f3391afd6f7b23e1896f1a8c220ed84c2cdc55d3c2cf61b72170249584459bee8e28763b188a168e4768e5a82e4acaf026977c1263b566d006a9c36074877dd4003be1cac661b8d05d5f9ae9b01db2eb98b06b47abd1a7c545b994a49a55eda158f3813b6270c8e81c65fcce692b20f30f1fd03730b54b0602f112af5290b32bcce2e7fb11e1b1777353323bb447385cfaa1e9517d86e7d9291e4c5283cb9b860e7cf7f5537f8ec59d7bacf731f40f50f84be956c6875fe8a35fb47b6c315be6324dd17187f05935e1a386766f79e60c3c347440c88070f7d255e705968b009622548f36387658e448cc0db3c42016020421cc4301e9d0964e172fecf92551f8950e83f7d0607e5797e563d30c23bdba8ef84f7f64aa7c915a3351bb04d8b98a14790882be3c02f3c42292b983db1d052faaedb2c99f6866fe8d467920963357b4d71f22bd96a550f1b2516d8e87fdf7bf026dd35ab8db78cafe8d47bcb585d50e5b98a3dbcf271765803104ec597bd5e1f7e5cab7336c6515bfde8a68225c620d1ec430e73fdb47b4c4697e571ded3d0ee33a587059a1bed7dea20eeca295cde5402d795ea340ee269ff4d4d627f04ae7920058e5e788afcd9e4497447ad7539eca45478314d6dc0c3e93a322d51fccef1ec152cbb2ef8da82df3d0a09220a44d0fe20b9a52ae08270044216c848c990cfdcd329c17d9253f8dfea3cb8dc201594ce12c0eab493651d35f294b148cd84e24010c03079586c843405662cc5e1798f22dd2f1c4e5cdd52af8024e65640654e53f07316a99b24a8a0d23be8744f6733f9a16fd2e4b2fbd787914c442a8db1a7fa9919e49e72eb9862ce04273fe171a84c1300ea0588aa1b740b6c4c7f5793d767c83622acd0e156de3f0ef6f8995a9b8a38e7346ba7a5227d5525aa3ad323b52df2d863844e19c8161136a8d88c73b3bcd021f6e040148e8f96e4bda0fcfe08b0effe8a2f55cba7a6803b1b08aed68d94c2a15abc3360b60256ecb39b003d0d00bc88c39577f7f8e787318a9187a0103f773e9a4d0b27cb32c251b03bd9f6495ae11d545c69f6fe1d2e71ec2cea436f81f703304d9b68463e524f90227d2e9cdd041b6c088633a9a7c5dcdef65f82a89f0f0fbbb6f8014a435b00d91fb576e411cd5d493b402dccc7e95fb07b065a9302fe81a5b105c59c264c7631f89be28c5b4783e2fc2289090122fe61586865f3a5b20d47fa801f343a91ec6449b778ce529dec8762b2cc5fbcb770f245292a7faa247d6564c62a845d15501fcac88cecb155309c6aaf8650043cb384e619c29651f0b665c7f5beef84a3f425a841d0cfb3d7f5b00b238843b485475e169647138e9b746722ea2f4d27e7e76a541c4da06e6f8c68dd1ff1b99c9a02156b67ee754c3c4a6d16533fbf2d059d44d77b055e56595a26a3fc37a40a8b43712626296571669ef9df1c819ccbb52b8d79df2013bd61375c77ed18384875d2ce7a26d94eb3257e58befc4be8bf9a417b71471c9d3715d4f8312ba3c4a7d095f8132560fe105754998286ffd498723e58b0c6a3de9b00806c127432cb16f07f78f1a9b993808151851624ff7940a9c754de2bd071b57eceb93bca1bc124db6361cb17fcdb8d98302535e678949cbf279359f916d8db3cd4cbdaa7a7d1d9499ebe322c843ca3d8169067e02f1cd253f01bb33aed4f8d8842c5ecc785df97362d455e98d9c88c6235c54b9b274b9e2d5aea6414d7e4f7dd0a0d7614df09e790693720b07e08ae6ed8a24c9acfdfce4c630f92d9c7ecd5f484a26e8181de64589500c756d3a3bd2fea0b2f352b616b997b0fec55a9dd90104d1404327a802fcd979cd118141c68b8c7a174c5b1d5843d5e4d251005dadf1dca18868c28144fc6443270beba8af5a981e5ff63b82966c65385631e52345f805d430e7d4d5c05b4fb43d520c14426e65bad3f21464bb8ce9214059438707615ffa4ee611aeb0909bd1515ad4b275ba7cbdac1e75dcc30ee84f04c1a19e86ac4acbac232d166d1231342a67557b8611ceed46a8ebb233d8c449e186ebdb889b633d80aaaef821f05a8fafc365cddb551df1887a0157c4f4ed24427a447f5f1bf9c1b648e2017157a6357056434d0ee6c2c2eff584bc66cbb62531f57d23d7a1c1eb8f8748d31151792372a500e6ec662096567fd81df3d509142592cb81bb9f29f44efa26204001041a8ae08121f6d3a88e45cec2f8561de035d157b7955a8860278191c8fe9773d5579f3363da5555b5edcd7ac7a1a57afce3ed86946f43138a8bb4b2b30ff7adc4357b227c443c3480cf0f6e7d9fa7f954c5587ad69a3f86194ce048291bf0b2d0bcc5be98a6a146ad59ca03ca7514f6b0be861ee3b25172ea20c69150f5855a1598f008b30be3a14713dd1167dadd0706f9c2c02354c4bdfdc37aa6814b325d0729d08250cbc746d5e21bdab6622d1632105f11961b24d4c8c7413752c28cf1870a22a891c02d4c667d04adafa2140faa17fc1f787f8d5abb6aa65bd9151df162fd42c0a0f499b15e3165bf7240688a0d879e311410daba41e0ab5966a4d0b19286d23e34817139d4aa843a7a326e0de18ce69a7105a070122577ea045b40785e8824b72c50ec288e94122a7d63b1fa43573242e9680957bb6c479781355f47932c4f186c707af073f25cd1944d6e387c9a831644b71126b70d1ca66b4dda381b97929c67346741a1883594ca1f1d53bec031684226e759ecafb5c2a30844706e7f3c14b5511408692c844fae8fee61a8f4482fc98f7943f36bfd25ef3f2ee66e7c96bcda1d39ad879c21cc86a885c15a8c1283c73b1b5086c09cbc152b0db238515768ce761567e09f2466df89e7ce371e47d9b30e4958e1a50def9d16a15a1bd100f6a0c3100e6ce8f2c8eb827cc9e3b6e0c719f936dfb08421e1506e9f64130f24e1d4f10fa30b50cd4d1db5c690793fe13f89146159cd56032f670f9953e34bb0e3fa7054b1d2bc02930848b07b4e4925fe0181b54c129450660547240fbe61dec7b4f3f90993aae5662c15c0ec751a21f37b7ef76741ff4cad1397e12ca33d81592954de9232068a12523aa279f537c8f7dd804a3dd4e6e4b5559a281e15b7d8ba34c4550abaa2589ab19ca22aee4e321f372706f1e9055ee374464f3c9c48f64a1ab19b91a10de7a64c44dcbd0857107578cba1799ce8c0b39e08dbeea5ae404db848ca0fef6b0be5dcce3d05483be550c1dde7a59df9c5c99fbdc646476af5b16204620e3b59b63bde38435b5ba04aca2c629908648df988ca3401115c828e6b653f5334743e37687907ea19a47dde786af769fb5f55ec20cef95439d428a1690049dcf02a2b9c7fc2c51d2cb8547aa79765ad95ccaf5e42759f4c4843a431307bc90642d98c1e91ff011df17cc505a248b17eebda29a404321740aa7b48c5ee31a7d6b1679e7599be6577b0cf054ecff6711caf89babf7629c4d99992ed3219fba83b9e7ab9bf7265e4bb807c7b78f16f5ab9bfe30531b1dbbadcaa40de908253a36c3f74c8a32a085a6c5049970824be43ed06640a55b1091a595d8f9c8bf44538f6b338385921a4ba585953f2a4a248c4ee84634e940ee71e0a378465b1f7761fd971275b58db75049df2e76acae2af7c5856d2fb641c74c6fdf3620b2289a903865b31df1c5acbf7f0cbdce47d384eebb93cd66c88f42d78543053fcdc7a3bf794291f15187cda197f6f80e7adcf2a432aebc397d50c00cce1cbb03dc7317e53b0a018c8294c431168fcbb6fef0d3e28d441de8f43fe4166f45a2669ec2250764018fa0a70db2d94c064c60c2bff14bd49f8a503fb76fd4726d2d7316e0131b766f9f71b00339add5e2e5781c441e8e499bfed58a8522af629bf5ac90d8505b7113bf4265ee921c0dc21722022a57069445e2c9e83b4cff373561d4e1683e731252efa6d69f86ff1c68dc065a0643772b17e0db385703f7a93d39495243545dc229f2385aa79fdf3eb485dafa6fb76a27cb6645cf8738993695082481fee4662f006ca4d1cd6072ab31ce895ae864d1fd0cdbdbceab6d3d3dffb9a5e1b4fe14488a03a301d7d00e12c365433da9bddf921fa06915b4c9218bcb552365c4cbbc90d6b8fac7afc637b7e88ceafb31dfe0d3a0231999cb916847ee20f9f9d89b09aab46e5ad7d0e011069632a0a71bc4306c4790f12dd0d9de0c5c82371cf3c964dac94df296fe345791da13042ec68bd169b27d91bddb0069521f014cc504ecf9d6e1d70329aff9f9e6f0831901bd134e3f0826f3f1d2e1bb20d1f27ef4ad9164f24a67c786e07022a57a46cf20c21f3813ff1aed06c1e87157f928aedafcde63dab37bfbc70a8fd0879d5b346f84a5930814543d7a5cd09c116b5d796a2c1455f79c3ce94138e21e00bf6961d815b5cd7c4e883a6c7f3451fb40ef8a7ad63a2cd036f5b45c6c122410e27ceb6e6a8b7a53f7f1de28ab30c5e3ee5b2235810cbffc91640ca706612a9bb12229b0cdb45211fed13d645da41965d95ef6b80fc0f4959583c717d5abc093e26d4675e1072c071f58d5f45410321ca779a6ae957e57d0bf614fa648e959b109daf07660366ecff01e8de8f608e34ddbe8990057e626ed5cb9637f3a2c03b669234ef554765dc89657548a81e7c818728cd9e113cdfa1360079411503e7961a63952495a426a4196b964794bcd8ae4595ad4c9dd31a5aaf3e4eb4b5915cb703d7bc8651d30678e8b0497e67a44613418c7a79b80b19300574318db8bf8dc9d7e444b4aa42e11bd958dd2806200bbaae1436430521577e67a11b68f4969deac4abb2b4f9a63fcc20750f89094223234ae1aa0cf55698078beb598666d46ee8c9536acb4b431114d2ca320c03da85022db374048cf99cc226cbbca2f5c5ce17466911f2d5bf708d322328c00707c309b51e418f2ffd292dae9325376229ce03ab8cef9d2e6e23c36ec651ca080fdcae4363e19f7c2234a8b970c98350f0c6102a61574cc6278656225ef525ace51d25b3c334853597357dc38c38432280dc9e487da0ca90f94ff3d12a27b698fb7b12a196d894da9971afdf3c4843014e07c4aa3a5ea802cd137dbb41317b7f1fb9d9b97b48902701374693a7078e1aba352e8832a74e4c5313640560e545096a72732355ef0dc7853539bdec049bc57487d38ab908f69069678bccf277c6c2c89a4d6fc10ecfc842e73f10438d00a10d051e0061ab5fcef855f9ecde4e31901051067250398a9863567f343c5229d3d14ea09e02c74f20ca77524ee3e25067a17dc64f6c0025b0e5f418edadbf2f610535c24211809269fec8bd1c55e5f8848a1096662d95cad3fbdf3e7f7f52b2bd547ec5085f5d8d69a141816de7d20225d2fc765d1c1a56c6721f5fe8c95f0172cd609afa19db1ea8e4aebef9a60685a20a95272afcc3c1b0f67fc2eb27c57336a7999c703a4c6ef5d7473a57633e5841e4cfc8c4b75bd3a209dc5422abaec957932353d0e17ac1923ee34480602b87c9c69efb7966a564ed4a343e19b28c6270b4ece10283b3e441d615cf131caacc321e65e4616cdc9984add2cac99199519635cbc1fb0307c35bd7629be2a75f5c7e3979507b55a9fa9e347a97f930fc297a82eff61d430edc66bfb2896975be3ca15448fe28bafcf60398b628b1a6e8d656908d1910a7cef569564d5e36ed07c9d2e0dbc735ae3ce72bf11acf83004660c278737a33e0743151cedf4a97480e7d557ec62d5a7d66d47b911df654d30fea704103c65eefc0127460a29ca260be0ced079bbae17694c1f2c0fa87004ce694dc9903c38b8e5ef279b919d5ccc647b6d270e67f1f828164243f78c152ddeb70785a57c4029320f0371f75dc94e217ac1bdcb4a4ad2ef9cecd4447877bc897fa3c7ef070f010a31e212a34f5079d9b80c0e872655671c0a35f60e1552fd7b584b95f4fff3990d244ec46425efcab04ed933f1be6cdfb831ef248ec1070cdb5ca4874ba8705734c8a0d09da7d8420f42abb8f405b8266453e1d7752e0be4a93f17ce1e6899bdaf3688842b6e17ae1de65267c8e178d3ae9afcbe2f6b71e54de583def598aca1e7b70507b663024da0344b0f58cdee850fcc15d4d84aeeaa3f24979a079071df98afa929aa390e8969b31ad0193952e308e2efbeca0c89540ef61e3d906e14999ec2b80384ac3ddd82ff33aa3d3d6c789a7128b99e12369e571d54f8ba0ddbce8470774144211655793e9b14e2ae5dcb748fb2da413ed070f72f4c592bbea199099995d8e08ba2922f63edf5e33fa783821df72a4c7555cd9bb2b001ce3a72dac84ff609c64526da1966423fbc776ad1bdf4368b398c7884572118e5cdf895af28e1b80a8a2cc8076d410ed2c37d6d6c674c57eabdb58aaea19cfd6ef60cb21acb0e37e4fc2118df4ddca5bca69bb35e0e67cfad87b4e2470261f5c41fd150946e4ad2ae67796eadf444f2ddc621ddc55a21c259ac7f4b97c8d20da2b01002df64ad44d4aaa713d455ae27114ca669f8cdc4b734b7ec643766eb8cc58ce117bcf5c2db0546f6260b32ff6c428c3eae2f32eeeeee92dda3060dfe25a5cc64902f48b99bcd54aa49a690914babee9b9ea3fa742a72f9ab1a83768bd6feab0a32f3e36b1615724cc7358a01f53b6bab325705273f535257836196eb8752f3f825871af5806f1e206999e6430cae3f4a743d34102ef19138d52caf94877683afa4bfa7f8f16b8a38ab9f20c18b9e9351afa517c1c19dc3bcd01134b3129152eaa160408e6540fb45d780fd000fc56dfccefe3735e5ffd2c1fc8bf94fccd0c7d9e7a637fd3dc6d2f7dee6f44afef2caa976f2ce264a0df91ec2528d735559e68e69caffab6f24733feef99601b73fb235aa2b70c5b296db01ccea7d65a765335b04d80bda2db5919d386e3dd741d3edc43efc520742853965490997567d33f079add3404c6e9eda57636bb77a7e3de974640551221f88765f13ebf0241391b86046303f38f551a3f947596edd88d874ea946da24a2734e043bb28c82b9be29235e81a0cde0600d85724fce25e9169f14b20e37d2586892bb74040380dbd023c911092f8033a64c52c38be820183d08eb2d06b12c59412bcb1e88e05c6b26c48e06ef83fc43e1cfdf1cf2689bd38c8b5cf44f434996922cdb08b465e7882173b4ac7eea9b7d5da29c7c88fc5a1953b5717dc9b9fbe1f7fc44a46598d64878f1d212910d041044a169306183dc81f01d4aa1dafa278e138962b7955baabc70f3506d3bf441548de84b0f15bc405fd87c9632db5a370c4e3ae00a561a24416b83c4427d2d92fb99540cfeb89c191e13171a61d1b3f0686f59baf944fb468912ef39ebd7e3e46f94770fe0b4802cea48091e6754d26df83cd884098b945f5fc53b3d563c4ae72899d68b1adc10db86665ed289920fcbd42bd66911215f135766cbd9a7b3f6f9ce31ff9967d0614c8821d8424225892c3f93333aef83645a038bc901d3870a58da6cf514e27fd25412b3e59df055a9791e0ceff3ad38dff1c3abdfd4f73562f3e0523b5fb00230c2f880fd9db5374e34ecbb3f09f93558384c30e49825e2256426b73ddd6de204f82ad745cb158232510c30387511235cc402b155c28bf08dc61a56930c0b34c71f8d5f8d63c534c116f1646d6ad397cce14758550a365fcd4284b6bff1be158de4e19358dc31fdcd3df55042759ff804eaa58731e751ce67e8553b27a28f9d4a2e313426b00fec9e551b637ea772fdf4debe642e0065eaf54113282703d2b0b595d585fb2b5ffabdcfc0ee6068d45292574bdce93c5990720cb0134658e620400c9ea85e4a0c70cbf17d89d95b5dbb4446cd0b1d561dd96c41c95c01d95ff319c30bff3f2fdf586688fd8abea3db68d39782316092719c2cd3028cd3c1acb477b5380e88b42ebf94d169131caa861a64f9a56e88692c217b176115362287be4b91a3d63e3a4ab7b96309a72430abf300c998ac0b33c02f607fc72a543b50363ca3f6a33020cf9697ca9574bc988bfb631318e8004b558267f0385f6c9952154df8b1f85b484c10a288411e70758bc955d011b15bf56ddf6f9be8a03fae81041eca33a74c787269a60875498eb42627c49b9a52edf84869d739dc55264ce22cd6e6529b121a2a542eada64ef980ff3561d77a0b69ddce87f059e8d10e8df43cf13985969466d46c1cd6a5e853f92dfcafe1cbd18668079d4e94a0054000a2157e3e84a7184dad567d61c2dfb8b4cfbe53abd5d6beb4776f0735aed5a420f92158c99a8caae4426d525547db0e1ac6141e2c351dcbf95e9055a5dec51ebbbcf501ac0f97ce28816353186a951b2988e9ce2e5c788727704a1d5703a7e177760590ba82b74146d5ee0bcd78ae528fa2c6c7ceb8cc6d6bd3608b8fddf8f8e5a65c622a169507248de421a62ef424dd724bcb3dad6a2d100453777a775166e8de5e75945c9f7e47f537f933b238c451a42cc66d1cf24dda4d44a0d1503b657a868d0abc5ff97c9da2f9526992a0137bf9cb08073973509c690a898f9d899361cbede8a0482c0ffd50df2dc8e1f4f39818b2929b934d480508a63866ca3bd612d24b281afd01ae359b399462af0fe0fc7be00df85bf8857930ae187a8da8abb0225b8d5142248c78b8c9cfe0570cf845892f63ff60e4d799f2851b1b530d96d7e9f3be85f652db822162f93d1d697ccbf20458b8cb147d599f73e2388caa06e7a9fc22104f2b2f82fd58ada2b450756b9994a4cd9fb0be6f2ba2896ce60d914cf6bac6518b198768ee0e4040bcc2ee99ba888bba8fccde7e84397dfb72c8ab1d9e4cde18dcf7f6a7f66892675ccb84d7da2c5c34ab8f38be437ba63357a89348387b3241a91bbb1f47ca0cf19d5663aababf9e76131f0f699ee7fe9c8bbf0fdc4caeb58b440608e9c6f0be9a313c67211a89502afe9856644146d2a59b0afd0605f56d193cfde5e7bff75a2007faf8b8c76fbcfe8f4ce62c86303f9dce1788004229f11bbcd2555d82fe64f78d09683ed8d56e01cacaaecabd445b9663534991cc3b5bf8bab04f3aa74c93d10b1c118d8a1b4260d0ff44ee05864fdcd1c72c6a1ec77b1e0019d607670ca1eafd13ded7e23b5f510819ff6ef4f0c7f21c731bdd35060afc2460652103035c3837a9ec9a395476ecde3bbccde38f53d94105fd06714d0af5d0531ae018e53c5c69f6178a6676fe76945a9a5d3d14f00b8232303e291046cd85e62a16688f0de5fc76d777df2cb3c682671804fe40f65965970dc8682015834f900bed6d068a091e708d8a0f59fe0bc274f25fc05dc462bd5d2255ccde71bc195604aa56a805665d0fa7448879aa12295f94d3ae6897d8ad73ba7d10a03fb1e6f85f1b644fe4f465b532aff80c0bcc37d3ad7d48c8ac9ff12777c931cfea2519cb6c43484ba7a0b0d617a0fb6f88b85b32f996987c95809b4b1abda17ab6bd5419430996e32248cc47a73c7df32d0a4a07211d3106633cf4ed5f2ab390ce109b9c5ab2dd124c9ee0afa23d597947b34c9ae0bb0762dc9caeef558742904ae2a85d66e8033f089841d9aba484569f42de158dff6cc8928f00aa2499a7b8f3cdf95556fc1a2de0bed65a94b0a83acd4832d101f0e5d30ca0abb657984f0aec3e9a798bfa63e0c358e445f2576e66f9a0447b8bec324d3bca7f3f3adc0ac2fd69ae66668cff9884af511836d40034351caaf58353795130aa476e0aebe00a854d288bc3cd9209dd2ddf1b5ad8928903c52cd351342f08eb9c13bedf2a1b19e2d6ad0f8aa00015ae37bd47bc61189a79787cd36327eb812e27ff871712166762536f7fc540ec95a9b07773c3272c9ddbdc0187551a4d113b6726e6d64cb687ab8822e7a079308b414a8907f9c5e23e7d182525449258a86557f3e8dcfe00312b234b66888f22b21c1c20a9201ca824ec2edc0826e6609020bb1dbfcf127acc60e1010f1582cfa4991fdf335c672fac67e7f4a4e26a0f8a53ebd4a8db81782664a0b8b980e788148198fe83b4da026cdeca2dd47782104b8c269298222daab81507ff7dd7a68ffaad91a54eb66db994a653fc2916e991dfc6c2f98a98fc0b423c2979bacf65a63a22b40c4f77bc0f51e2937633f77003e545bef0d2d22f5414154a8eb750317b85f4a4b62c484372780f3dadc06174f6348973cc2d2f31808e48613f3b143cadc647c4f469ffdbb85cf86a171fc869098616c63e6b269fbc3526933b8953ff8d005129a2cb908283effd27605cc72778f2c0c9fdc0af7399fd4b10efbda9805d61dddc0f9cf25fa4120652a3ea2b91cc6e8536726f1b96705fe2aca025365c10ff631f3b9764c119e714c32a8a0a98e15e1420726e2090b1c4351cad8a6c510ee704c67d4715198b29dc5dd77b264b2177dc4e072d98e04105bf3b7f5f984c1c35e6d8a301b48a8e696d940a5109a369c6452ea601149c55a033ae3f240af5818f7efec761d3504f4a7f8d787c45130b77129b45063aad8f0729dc53d7834b7ea62c45c4e16f6c150b4784ac062250daa22c470ab748017b4331b92c556ac451c334f83477c636636c4c34296e39c033cbd54f86399de3b78ae0ae97589535b0f8863967352fcad668be0b96a2a6632aa640c63b3638740041f9bdd55836d6a915fbf2517e104676ca4b32cfed14b0a43a4829b79bb6d7b369b2fa268d5c4ad31f54964298b88959cca21fb132329f68df1d2883591f9e815c66a6de79b13f53406e9861b6a873806077318b317e9b3d1f1df8e439a3c56299dae7ec7e90175c52da1cbf65e904c1bb93a6b8ff13795445e557214223088d2e4ed7d71e8d787632bc512d0453ca3635fba3b2130c897e1d1b757a1b5df0243ebc60a3bde1ff481a1ac922f9d830abca62498694245bcee21950a55fa385a0b5f2b4cdac311187d0f5e9fc218c176fabe89f8fcb5a2db5a00a12249f12182e373b25c0f41ed92a0dd6762e65bca28419f8939c9bd5958ed12d28baed437c383d89d13e4c938d3ec272a7849128442cc9aabf8cd888664900de8c96fd6d1cef59c3c078724a797fdb2d4a667ad92c557081a6d7d16d42a5f873e7b1fb486248a2ecb8d07bee49e6d7c3bd22a17721685da541c92de980bc2644244b5903e3805951ebd3b386d4c91eb95f93c4c5f5794ca63d53454ab3f418a148f1fa99cd3efa691995492f7a82870cfec8d6a2db3491ddb4dc5de81ae4effaa5f94cb9cd167cece869874c535d757192677d3cf4d9442b3cd377d9377fe77655c16a50721905eade34bad392f1a9301f435ec6ef4c836494f27e2e5250f5bdf0a596a1b68de0342953917d5f7ed371d8766ba1272969f13d94e699747737187509c6f4a58a9f4fde74c5b718512b92d341e46e5ef1c48a44ed99bd53682fde4458a093dfd0050501cc70a6f2c40effb94fddca68d690d6d4cdad2c5395109d6f2ccbde1f267f3b09a0c8b965899741bdfaa05c48203cf349988087c475e9276265967bf9ce","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
