<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4b936c8a7c1d8a1d7942185de6efb6b9455ef257a1b23770adb133180a2a235b49b78120edf4ed31c0bb6fa94cb257b74f2411571d461a4f58b7ca13c3b5c356a1846d26759711de3b2b33f63690901a7f3739d5d5006318c0e212cd792c33032eecb4f368cde8a0b75753a415961e53d429648aa3382a18ba8909b9eeb28bbe6230a83d712168dde32b67d531473b428170f99c27a81c85bc66f8674c714785f964fea5ffd0cfec12dedbb073000dfa188361571e3bcf59893b636722aaf18c51952b4dab6a3f31581ab723efdf5bbf146c198a720576af329313ce922fb96f7870a45a381e334e3898a300abdad46fca9075e28e5989520f594dd4900c00415df7e54e80f6d1937f4b9be07b32463a1db033c8ded363e685c0062cd4736d99c7939003b71b3f3997cf6460a3c0b912cdf7ea3a133aea3f93df561bef72ad13e98fa8354a0bd717f66e3a46d83ac6f705fe65594bbd300ae411a16b43eb48dff2cdda2ab26539c9667bbe1488d1fb577d9c5e87738cc4f0b285e51d4890d5ca934ee8cb3c1e5ea1c1d66652744e36899e4d57b99a275d36918c58039fecc11956ad98f7a5b7c4626a04db087653c84f77a29f0c01ef5e2d197fafd9b4ea227345deac569936ec562451413e030cced6dee41b948bbb3e8c1af49ab677e37a794eb6a782838c34f7cabbb3ac5fdfe3241c13c22929709072c72902a9e7384457353136f439659c65509da28e9506716e0119cf0692ae46ea156b1151a09bc8043ae19a9b2cdf2711feedc21081a3325f53e990e1f64b2132dd079a3d083cc08fb202308360b779ed1375dc95375969d0b53d4b56bc86fe6ce8a083d9e8b3e0694e063edc4f707ad461242f2bae1e9c9d879253027feb329b389961913e1894ad4991f17ecb6b3cad505700178add95d7280b7d5ea2ac7b31b1227d2cb2f3a9398fc44afff4f157f3cafbf0a26619bcf570ae398935593fe7ea1ffb5a607caeb679d8f89c68ad63b8b48b74cce7605590deafef401b571cbe7714ec03a30047af43ba6b0d5bdaed8dba00b862982fa3d0c02a5b5573d789fc83a3f5fbd31f5691b5de925492854aa17aa30a71028c2b0a6fb4429936ab53722237fef3fd8ce80a11d4c17dce4394924150af11ef166fb85d7835061dcccd2be3be3a3ae67bf9e6d00db086824d621d152cc798d9059662bf112b26be731293aeec180977f5059bcb9b3317b917815b21b49928581825c98580116c6936715267bfd1025ee2e0f52430f44b1f7dba4dd54761126f229422396689d48957382eeeedb0a9297a654f517a55024f52bb734a38d22156106a25d38b932e2e5c37678dc025f351df8af9766809c3d5fdf731d73e8e789d0848ca6778dabd61633af843263e3f89be9590504e1733bfd71397b062e04da2aa95b2ce00c6edff5616a774abcc2896dfed7b3f41ce66ac4a4fbfd096cc3cf1ad89522033e17cf71a2b9a7f494e58b0f2df5edbe6e345f4862e3b536b31109d713c3a02ab4e3e02d18422e12ddb8701a45a4614b6a0ad8d0ff9dbb262e3468ef57d61bdb5e8517ec1b59040cdff3afbc6e6324f3f266caed55cee42c21525d13a3d1b62f2c360eea69e7de40a1d11929fa23e11c87159e725e6f0dba8cd6e6888f5c801979ce650238487b08e18412b79ab3e34b2ad636e742fddac703d2fecbf1a31ca92a89ac994d88bac8ab0045b00418a8e53da808781d9f04193ee7f2d91a5980913cf1e309ed9da72cb794327ee60543b1cf1b790f14f49c197d26a5bc8124dd71bc4a05124507650e4966bd0137697ac8a4c84252438362b17d9ec9a8cdcf80a6a9120e4256855e3ddbafe694c78cd271b1faaad348c74f16fd601c64c3de11a5d780fc021574accf06a0d78205aa784205af354d67b1309e171147aa4a24bd965f6ce5d5b8a5f29be011c2b59c8d035d7a30190093ba8d0525efff61b92c8c19fe9df2922b388b5863ae0a56bd9259f72c4a53720a7289f4f95032c858d2a3ed58d4800d8ed1ad23887b089f49e4f50bca92818d656748d8a64f7cda0302582605ad2e5b4bde4c3c65f1d6a8817e6890ecf5abe64c36fdedcb0268725bf9f1f8a270bd28f106f441bb04f8f00ae2366704da622949c7527186c453e0cc5adbe9eff27330a5ff0cd2c4be642e5ed92ee63ab25ab561abf66ff58693ddc39a666c00af2853db7230829b599d16ee56f25f3e348c910c8b241471186e3dec3b85c77a751298fb9f38e44e940c7302802e9184da59f5e31317675b95d8bff05c2642f0c6ad2a4dfc21849d04ed63d9365a692b35a29fbc9129bf7e1d4e75859ccdf7fb420710ba5168f56a9252524732acb03c1b9d73ce0cfa6e13edb4d44d37a016ef4bab6ecd4c4c49f033b1bfa8111d9036383780a5d1079eb342800dd75d924f546b9ebeaa7e6b6fd27266fe51688bd7c227a513cb6e50fb41f1b5ed95aaae5d28b96f8dda19cdde0bc6228175e661807b8a03f9675ea4b3c4a911ccf23f9b007774eaf9513e4fd196369d262c905a6f2ecad05834369f1c0b434fc4c49668c4a3e5a26f63f040a82025eccb55863a6030f19d2be1ae8af041695d06ece1a205e85dff1678faa95331b5d4c30c612f0f00b0f4484f0d1e05b8c6fbfcb6c26fd7be2b0e4d635167bdb159c7d43a868cd488b8393867f82dd91789f77f8f1e9c634d7e2b50b686ec22fe97c08148ade970f648dcd916cbe6ac6d6c0eda3faeb56af1a2fc89c92a8e7c982da9a90559fea0cc1b91dc8f023590cd6c1f459bf75c1db1040f4d07744d676864f0a57d3c6cef0b14d6eee935f7561644553142f1679208a90b81dfe37d38e145c1abd0ae5bf52318d330122fc3deabaf066cf876f4168e8b196e940ce1d56f64b8916cbae2736959b5465ba7c604153b52c9fe69384d68a712d41ae9974774127704aaca3fb41a34690628eb660cda588f025f9792d1f0669b27145854589c73aaa541ca5d7e02af3b0d4009c95b81b796fadcd2dfdce32a3a76ac68762e17a43a19148c362ef7b1bd63291388dd863f2c672b98fafa3bb7465e60e5068234bbf0dffd40e8779b5037b38f735092521227c5a176eefec1da3bfbd4afc9e4b523511821ceeb05e222b659c737d69a4da61f37ba2e22129498d50771b82834bb22ca349a44d9c620c6305eba63e14e5299f4ab29c089f79d2a467d29b4ce171cb1a2f6e3b1909e687b7d5e1be70063f6b4fa3a1a86e9f23ae9b0a2141557e8f255089024c34c31eb0b1c3a92a8501071e35ab879efc8aacc2eed0a93ce8211aeb40b22a85495941499a2f343edccb5182252ac90372c4bf815ed90b83a29b559b5af79274ea18437b9b1c5f53ee14ca863df124db1ad5090d7743d67c79f0e5c2eb9f898ce8c47b2317206514baa76ab6afddc4ecd69c7149c75d77f5bf0063dd2be272cf23337d4541ecb36c3279b3c1ce966ed8a03d3ebb13e27c1d695de85f044a6f6a6fd34a3379f8550b90c01c5f883e14c3a8e40597a31cd66b462fbc63abe683df729b767848a9833873cd623c8acc153df295494566001e1ca8b89d0f1f2bcf2559a4b327c2f582f3fdf76c850fef8f60ee6eb41eca8e40b0d951bf280dab82ecabdbd5e83dad5ddb09401f7b663cc594ef9c6eef29eb2abe22585ffd9c1920a70c1d3c87f0ce2a3a9992ef39d26637585cba5211c44d5e54ff024dc3c400c44690a5e88e56f1e395ceb8085969378d83752fea464e30e5195c9d494a340194fc7b48b5126c7842ef8befdb0f1188d62b5da927dfa9461a5ab7b7107560b8b0434e4d21bf3ade50b0bfbc78dd821e5765696348dd91068619f6418f26c7217c88f8152e28e011c0aacbdc0e99b285b309e75dec571f889ae1790d23b1f88177f4ed024f0ae34d59c5cb34b411805563ac4e7b2a9c9b73a4123ace129f89204e3002d065bd90e21f698287a2007d68a41e3b5d9538c2c4fc4908a3bd372d435edce55fcb41ce495ccbc07851910b47679ae4b97df1dcd9b5ba0c9773be8d32cc93ab6772c26f4066a56eb3d61eb3a96f2f4449c3d6bbecf01beb100bf9a565934824bc59d3e8670a89296293ae6ca7114483b8f9d4814b3e71a04adbfc55840fdd0a7ed93bcf58a540d2e8a41037bdfdc9d2063d6fe8c7e5efaf6c362882ff23e1902d0949e50edfc05702f392b4c586708324d96d0e1db1bea7e478744c5422ff932b532a0c429cdf98410cb2a092bd514f5ea9085be4eb4633431c7df0eeb5a100aa9229e25fc0bc1d748946e160cc972465deba47ffe937c1910df4606696965e60412265e3ac3a20295eb53a19e963f88532c4ddec64f99166bf10cc2abbc5f137ff07f344ffb218b8145b6333ceaa00e733728ab3c5b3a74225d916d932ceacabd12e773671c366b49108ce88e2edc3effa2a0971d4a0f455a03881dbe391d8bab5c94a2c037e9757f6cf6231b40b02a81adbc253ef3cf17f884060c381f9af75801e94ff6d59b00cf1fd8369c64badf64f09a586656a1a5a859f262ec151cadc7b732a3a032f663279038c547e448e65da07a89ebc3d2534b8f455cada3a3287c46c4e98b8e55f2dec1b05f31d303bfb3b44dec1c04c6286bfe87694b06f69f08176417aae5e95ac94e06365a9f027f41181a135281283cfc33373f73c5b083a441d815b2a598f6365f9948544999845b8b70770b86e17ab304f735eb371f5086e6ec42854a07ebcefc9494fa3ff34738001cea25369ab492810d74665bf16a1d4ace930cabd95786ca53095835ebd216e108ac37276484d613e7011d9fff4827499b2b2be376dbcc37cfd83711bb6fe60ff58a74a884c63b9e7b251888d16681725f46137f5be63fcd65ceb22fb73cc964c0e8578ff93c2273f1435b192c072dfa200139b8a8d17ab2c74580dbe661274142558412b73d52a9eaadb98b008dd913c4b5939fae2eb8c4424cba67f979e02129b2b74930cd7fb58f5364b6bf89bed4dccea07bd9b716fd5bc53dd0d856d77b2e812d2a28a10b890dba664205973da45a843a1504d4a54378e1b44cbeecd53c659a5a474669aea42a26c5a4cd53fb2eb9d4a6dfbec891a25392a1db2efe49fe11f8fb3adac3e78b57673caecc88f780d4ddac9db657cd678a5b2b92734b5bd5d5132047074082945ad46e376001d0352bb4f07d7380f0aa67baa847101a455da5883676c4bc3364e894bef44d52792251761080f13ad5930bce4fdcfd48b6a51c892e63b476b0318151b5b1c8e6a04c78b711c35134a12fa1793056939a6bb71ba7e0690e61ba28ee1f3a4696732fea981e4a8c13531cc8d22cf12172a9a964c350125f45cc543b708a44f20114c97b5c83e236518d451f5a2bfe83b8168bbea9c82b99559f4d1f37d4181fabb38a42f7e48146d1fa7a629dac347878c5be46de02fbf114793f4ed3faf281b78151aa4829fbf62dadb6a19466deab2776605b96616d86b89ad6c7cf0450b2b8922f006763fb8ea6425e236db5999910baba53a6c83ee9fa82fabf12cd868537cf6555d78ba8e5e57d722f763c5e954083f0a0893a679231ee1f908888c582e3610966296dabcc20498c05669f06b76323d7d5b094d30ff20b455f7794630365078fb98c83004097cfd5dd2dfd66ab6813d2b2b64c33b1581ea7ce038a4b6c0accc12ea1f3b046caf13c6226f5438d922d9424df060491ad201815df5714daf0070db7d4e81a78081fb45c8f5b09adf25cdcb13651e9ac8cfe025c61ecafc1b9e6464c90fbd5a92bcee6533dd83c7aadf0845eb36180409e99424fc78d44ae6c50eced8a97ef0c2aae6af009e5e7f6052f03170c33de4d7652f28b5706d667bd6d01f0c20efab67838eada93e1fa86a71ec3b0c23d31a0fa29590a40de56a178881a7647e3b62b697ed3ac38bdf22380010475d2fc53690d105ef5014ae6e14c9a6838a6d91b48ce86b76eb94e89dc17aa4f0d03217eb890bf2966adf9574a4708b82d63470c4803157afa29b02c439571990a018fe1320f9af501aaf58d0c1d85a88cef4a2735f12ba45fd797de735ea32401d8b075555cefe86128a05f4d0731a299ce672ee0d6b190c9aef41ba4f95cdf724b5f4aa17bd62c68d0449d4fb6b325834ff0ae089e51f3ce54549dae406f1779bf0267560ccc8691008da903d056780f669c1ec1b8e1cafbff47cbf161a1516e3df05ff5ba1b61cc5b20fc75b45d3e7a88533f8bf228bb7003f4537f523d672ec737ec93b543b0d834e67e9a588a018079b823bc4e58cfe21865750b22f084668fc9ad0aac57af5495348c37179594011e233e42cd3d71ede8168b6c160adeec6b633614876f88a5acb0d262e99d77d78a42229fe6fe2228e889f3b091dc138808aca410cd84e524f0ae92540013813306ac2c3ec0414d9d98043bb8afcf9ed8266fd747d0303891a81d615d97009ed36a7f00c945941e6dbb5ddd8ff9f1019ecd929018d5c764922e789493384e8dab22d1463314aefb20fecaaa75eb4cca932e039c64cdbbe7f853eb6c1b1a0ca466bf5ab42e7c106ebb85e0c84080b845cd517cf9015ba37dfcb9b0c716f1ddbe3778006a1e7416bfce953deecef1b2b6b1eb8850978e4ee06618c4f6dae8a108724dc827cbc4eaf511a7f25fa34429e32620e6fe7232c617c9ba7df54f130eb26f910ef899e14699e95f04ed9d17dac8a906adb9a13a5aff4c09600b36a16b7573b075ef8617a863beaf2cbc81fa8b30049fafb8203d15b8daf51ff093d65bfb8ef3eb67182740507704c620cc98f356e6df375b7f991c3486a4943d963f7819a9911d8ad40894ce1b2fdf0ea795f7ea04c8f75fb32f90a583dc68687ed4765304548cd4806fd8f54be37062c7559b4943768e74c42f93f970d8c3a87f049ff0a8e469f1baa05cada2848c39693f99632bff5200a142d25bf9e48144848ed5c0c3aaafcc043963cc663c2bfbdafa123410fe60b5a465961f165bd3e517e6ba19dc64e48372f72a2a39122c0c357a31c0ea8c2e530c16cca381ffbd23c3a9bff2c2f519bcc821ae0e78c4668fd6e9e7f8fe05515f3c16a8c6a24a5bef961fdc5ec65df04c2b4a1ef8d2b4283d9a4ec7a17bbf0e6529916ce839495665e65e4347359b850c5621c2cf8c16c51b482d3093eade49dee863f6104ffb817295bad8f304b048629034d173b46cec0181b52c8e9ae22b03057e505a7a5a4ac7b30cfa49abe1764a137fb6246bca8d05862da559ef314ab72c3617276970421ce0d0e0514bc6d173e710311aca1bba3bf1e85633c17d874dd75dac334d892ee8fafaf20239609308cb9be8a908f7c6c143fef7d0a8456df941cb6a58c7dcfdd67899cf201211d43ff3b0abe56948056a0c6d737b8a9a163dc6bc47644afecd33e4057359f899324f3c1115d0cff035c450af2e2211c5c35d6a15612f8a244d9f1e62af79a3c58ee67d78a770154b0d9eacd0de728eff66bbb815726422ec27ef9e8a0f7cbfb25f4cbe6716174e7d85288666e7464327114e37495061d137f83cc99451ccfa5e3d8f6c5c1299e0a5a9abb9e204a045d9f93f7468a828b04c829951e60349400c1ff48c3379a539f7ade5debc5f43dc07efa55274a834ba11a00e563118d3a145f7bd7a6b62c48fd8fc017da80506fd136078860c1c8721739b4e4c9cf4e43515ac1b928120af30746f8400efb1098e774dbc6ddec9bd207ec7377dd415935d07ed07db6898dc358c74dff7c1ebc9eb9af1e9c588845e59808f34c8c7f75df3a4455de09b1636adb9ceea577b26c40ffb7b4e2c3da69f5b23c0f8875cd7447fe5249a47df6826be785c4ca1e535bd44ac8c2247ba7abad9f73da71e26b559560a6aca157835d61de16d3a447746e712035dc482fbec183eccae5f8b09fd4fad12123f5d076998aafef34cf6347a506b176b4d7a2da020ccf3ca0ff811eebcac66cf75e3730bf4781a1f31fbffb991dc88e6e2447441a63aeed4d0facc8fd61d4b97b9a5d7472c9bb236bbcc269c034fdb698c1650b317b805ed3c5c0661f3453d0ff6ffdb75d2aca457271f18b209462dcf61d70873fe15939962489b9a6257222f80d05ade6962a2a0952ab1c109cb18bb4a3a1829a526c6c88631d41b90cd64bd13e50309e76e6ea4a7d5b99cc7d382c8fafb13da363c940fab1ddd0f78fdcac5fe3d623bfd0b00f79a4f8580b8d9bd204fabbba2e281c6fefc8b24b0052ade72bdc39af35af5246d6239933022a03870e50d2049bfb0301f8e082958285a134c1d30ad66f53455103f8156ee09181ee662423fbf6390a4a54d97f5fc9fa1e298b2038bb6c8e63d7e76dc5ef425e8029fd2f81e804f5cd20acd8e71ce988af0c2f417af85f283eb95eea15822849fd063688710252b0b6afe48316cb53d200939fb7b89d7f6936a31173dfa69e411694a0ff29e6ee30f86b56617522703aba514dcd4e1f31f25f909dd1cd15c9e177b7f6ea817c2d74d7023f1249c07ed34b7a48c4df45beaad1587422007095039c1a5826290b75f5d71f30b66b0f0d3e8729fb54e94484f875bfd595e05dfffb7d90b4e2e026ea37e149e4ce17eaa7f760fad4c97ca6bbd248f3786cd48448efc25d027bd8b24b88b96bf79f69cb7ac16bf6dc453065b9610f94011fabf0fd7c3878788cb3848ecb53e675acd4b986da266f1b7666a40d0f9842f2e23f723a51a5ecb2f9518af3a101e28c5d5235ce7560f0491e13e442ba075058d86edf434b0150b53c080a4c26d9c1dff313ee1bfadc619829c3aae1bd9df01d11afa122b961eb5870e3cd29d719223351c1f5c87cde9190099e1ba622a848c04857b8d445d0103e0d7c39fff8c550fbab92e51f9e0afbe8b6c86c68c962d6fd4f543c00c0ee3ac75f2f7c7dc5fdd6686ac5b3ca2376e22b042971c3695d4cc71fdb518e4366b3733722212e0b27247767772652c7b44824ae38891f167affdb239ed7af99b5011925d47eefe87c6f13f2b87ca1be0df0d0a5591f40caa4e3358d7d61293ddb414d37b7b012ca3f9a65ef1852122de77da09b213a1c98528b512e4dfc084697fc71ce5f66a93cceb7fa6195b054e27e3f3766e0e703d9ba0cf72c6f70163ee5c99aaa6b485bbcf76d66e0fb88a6cd296cede914fc65af81a45183e06d4f928c539e5703a8e6ab1564215d33dd33896b02b704a97e5b87a882fad7846b43f6b71190a4a05432d24fa19b7070b77e3312e5aaa5a2a2ab0143f05445111c40bab8b9f730d48c01e13617317feb19a45cfb2e7baa858cf879f4f50529c9d09a922e0475784a57f7703bdfa35e86b615a6186f0afa4b711ff6963887ddd5f1296d74c3b88efb3acc4527da0eade5191dc8b05265584a39ff886afe9f5e784a6dd13308a1fe5a69ea0d9b0776803a9dff1f99f3cf8609392ebae0f04037d7786d0c8b8723cf0d1821fb3f1971b12bfa690a05171e1e1bac59d7ed763ac5e22ea11a5e3a6345a867fb2a30759b4ef81071d49205e753baae58dfd15065bfa1a15aab287d8a0c9532da51843c180136808c52c37960f9b8d92ffcfab77c16353c7241f05efa3bfb1034d2ba0110ee66b2639d33bfb255104c472b060f61ae791be7a8d625491686216b71da31567cb1935ff5a53ba6604fb92251bfa23fc6746f45c000273b7500fc8519b41fea8f89d67fc3e2fbb3977a77002b41f8eccfc5168d1b11eab8e63e73e8a6f79998e8047ca8be2bbaed1d94d8870f2988dbac0c98b9f9072544c872aeb44b4df4e9f00083b01c8ff242cc8683d80b1cba3c31a8700dd3d4b08c884a35cca3e835c89aa965f376bed47214749b91b5253bdb9e4828c5c90f61bb5cb7ae1034847df5916e652e0e580a8d97987303bb69e36b520fb363952310a0eb7de5be4dc7ed1628b80f49a134ef41d20e706479b895f565055a9cee1f9f00c9eed0f741df390124750a8b353e839061d053688f7f2725eb086cb411d9c00ba045dbd1c13b552a2a3a542f1cc95d7c20dfbd0d0b8e956fa995c84deb9876b09ebf61f9827134a8fe59162d9be127a8c8133f8ae6d160e7058e494a30a689189102daf4ac3802e34bf0d1a6c97bbbf722be955b8255c58ccc03557dfe83e3eeaf3b79883bb4f1e1f89c53f114c73ed8e7a6165410df49ea80e4c8edf8fd82fecc464e14528be0581b463425dcd948a58da5d0c194d261654cad76a18a3f64a25dfb6bd62d36cf1a281f8ce23c361de200c40fe5496a5f33ecc16311ef0097d0caf4d9e5b619f7ffe9335a5268f9ff29a29e7f43e72f3620cf487bb62df126098b0af1ce63020eb31692b86b6f7b1ae0682cd7cbe1e57151cdc7a50255e3037a0bd7ab79b8658b44937f520d338a162cce68b6386249fbb06529bf8d7b91d16a9f6d5abb8ac83efffdce951c4b1a48b7a0c7d7314f3749a08d7503c69b6d56c0a1e75f1a747db3be45ac844878dea9c74740b1b2722317d934c63370ed96cc13c3dd29c1cf482a2cf6809a8cb93a010d3ee1ac13bcee8c37fffe6a6d57ba18cea36686bfe2e619bb2a797e19f3a190e0318493ebbf55008c1c573e096de8c0ba307b27b81246fc46c1d1b529738ec274990567ffa7d80342fd5bb6066ca6e28f1471c2f4ec0d35ee3a4fc97317815ba5ddcffd29c0f6dbbaf76f687aa9c5f16c3e83cbf8d82bb9e8e3410a1eb59272dd490cc01a95ae59fb1c40c3e5f9ec4a9cc568a5568973bdefe57331649780cffca3b3150f62196d304f1e63e8ee7052ed8a9f657fcb3d79e7fcd41fb9cebfc65b2b6b6e0c7ff885f121587a4622b423e51f81b269c6d6b5e1c17e007a28f10e97bd62307c71bb3e22f5f9968d1dac925c23d4b75d9c9fa644354479a59eed2fb862cb2e659abefed8664cd763de3156798e3a01ca0c5ededb47eac5babd0534c440856f1827ce3489bada7e3d5ed9b3dd3e3d20b04e5d936c344302cebdab35d8385fdd67e4eb371977502964f8816636e14fe32a8181b2d50c64d77d378258e641a381ceff8ebc991deabcf972d04f355e330c9435304bb5edeb0e221eef7c3eff4c50422b3f055ead4f919f3a2fcbaf0e206671d7915cc1aeeef0c2ccfc49d21d5c2ac97ced21ab1a90ccbab84ea721ad03a31266c45875a2c005b5b96d4d412ae077452c6fecba51be85c50d25c01d737e7376c8b3591260715bdc899da19807daef8075f61463e12cf5ec2d415961274a17373b6302198d62f4eae204d44770eab0fb0254029b92ecd8cb47d37326f9017bca1928c8a69dd43ce672c230778c592364f54d9076f4c66f4fe69b0f3b5d061c0b36aad63f226fb05b25f0bb39e85a2cd7be31dc09ea48e17965d9091b5ae4ca87913709b136f4bd99f308f6d490c7424f838e78eb84f0a1a92ab0bdf6f6bde7fd0428d243fcb4f96c7892a6d271f934b0293dba924715276444c6dbb6f9f46d24fef110ea58a17f45dc9ae32ae8e91fe6c68ec22c01398125c0727db97ded88039f3a002243dcfeba4c36381816fbac82202bd0177589e02be7fa36de49fc7148b098ca943c04c87a4ee4f82ca3434a34fb49f01a08f200b12eb72c963ff0632402d6f4acc48b71f46563d44a43e9f415206fbf0e1140498ba4f3deed68da85441652c11b7313d1823e2e643504672fcd5290e27d51ec1a5f238d4eb0e9f9eede3038f61f9189189925972f3375ebcd900dc108ab24e1e6d58f36dab290a48cb672fb00159627ba64073b5d35455a13dbdd02e303065fc90aee42d95800793a57dc46d3c13bd3f3e8c4c7141057818c38e109feb4208e92103cdfc19aadf45cbdf0265d3ee749cd4bf33f2c83116972c051bfdfe9046b41505e9aef963bdf718bc153f4be64decfa1670053f3f3699fbefda406a3d2802443bfdff202224d007c5234608023eac563471d25120534cf13c8221a698b50c712850c8ae35c7b458f26a876b1caa4ea6fedebcef2f70ffa58237c5bf76de7aaed606f75d90bc3ef777cb2a4433153cabce0d77a1ca0828bf101c07764db03000ad021ae7fb95a167b6ce527447dcc58de4e9509428927a10cd4a696466541fc64d3334a0e3a25faad758d1ff4aa6744298a9fbf72508d3404e608ae7fbe7e7a73ec7723c9fcd759ce84bafde6d95c3de88e30d53e2e42c6814f97f40c479bad2764bd941a56a9c04c0fdf11afa4c55339ab7ee63419772147a8cd751dde7a9138ce6e5755d8721c3d0796c30486555b226fc18ed8833c331d28729cb27b705882048524e6c1817185cdd4484ed9944ae17cc95af029cf66ac7e6ccca522b4c25f5aa6b81ab3cf7a68fa7f8083c91d37402a3a78d1bf33d357c28fe9c85f089ffd4c81cb952ee81e10e2879ba395a08a180f820d8c9b9e10656321c828179e8953f6eaf5b1a3395519be78b686bed9f1b6447c6495e0f60969e1e23ea2dea9392aaeda75182b088050cda82a1660ef52678deb1293517293e54f2ebbc5a2537a67021de5172c4e84de41f7ce6f43f9f071a07ae956d319274be5b77764d8af1d15ff2f73e621165d1e7f23f10987d68e126df063a393dc4b7b3e71b69f6b5f5613f7d95db2f3e97a7345cabd46c1dedf192a854a78ec525db0725ae1af924af89b79a52e7ca5fd2c0c92ec4cbeeb29208f72d75af0204582834d5b72bc82272d8fbb2ba6722d5db3c4450930bda7c7b8567d8776c23c901805a1d2c4e421da43f1c6a721aa7f8b068a3b58e93021c94f9396286dd4b159ba35d58a91f69a508e1902929b3d991d685a1a7ef7edbdd06b7dc136c100e057604ee015d12a3174656e39a381c5ca4feb3b0cfdbb3546d0b36c73b2bf33bac5c41f065a81574a2a391f81d5d26cd7baf26f45645859a3e7f583b172a7729d4f405e20bbb65ee7a18f0d6a215702cd83df1b70253802357c61803247ce472219aefbd3dbd9a97026215466cfa79e80acfab8f438f09ed12aea6465f1e3f49d537521985daa03dd064608bcb1a0f5b2489e280dc1b79033f917ec9f7071f0b908efbacbf24bf16eeb03f183e6e9a848052b892c00583a8e29f59e2a620cca1249bcf6eefe60a4c3c5255e97f892f9041cc964fa3a5026c3701fd1cec0e563a4b4c267836020cedea85b53480a0733cf1cfdd7fca5c3eb65d82f64a12b3c26510b414a95a6a150f6ab5df3efe8812a2a22f2747b0fe77bfae54e69808b4b4bf0e620b9254c09e03d2235dfc94f01cfd097c39d37a318a6b9b08b72ce6e3ea0d01b3a6f924fe47d0128f9ca4d742d57192d7970dfd5af2dd3e6f4b7174af83d78f02711d189ae7ffbc1b9938e604dff9d3a375e4e26a6eab64e073e0f61fbaf602405de7415b83f1cb6757e5acdebabc981ee0163cb6f0393d7c4da0f22e863b9187bc6b2a848cf209270b387777a2fcacda85f1939c8a8c1da272db4005ee88d51ecd52f4c9df71f7d0c2cfe566660b88f3360f7a212ef099f0abb9974ced4e0dd9af73ec10cd9346a0aaa35f72d6b10aad82f2d2213dd4f229354d0719e2bef2ec374104310c6d3f5c8159789be32cf0162364daaf40c7cbdd825f2909cb0ca4a85cdbbb9ff2ad1d375cb5628055141af1d50af0cfe73b308ca0a2706ad450e6cb047ac64f4f603360f91365ce7090f2ee120f5ef7b642882121c21fe68b85b3f9a388a2843bdf878e3b665da27f586212e8a29925e9958bf7833f578419608a237fd303228fd2ced731e91bda6e3d99a2df1a6a87b3c3a29544849d1540179ff47024ce0285e03e039059719c5b1313c2bcfb6d593f3f5d20d9e410f2db1608be0c55fe7921e46d537564b5e71c65e23287348f24f1d9e1d69a0046ba303d6fd468a43921b703d029a3e735b3fb834106d1eee15860915cc85650cdff0fb6b4ec5bec1ac3b4b20446659f1582ada095fa6beca821973317929d6aec12757a71b340d8c9d8dd3f158b974d68805f2a765844dcbbe7c7cd3edb0e89b401eb2f2461446db0ea42f46c3829fa7f0cbd364ee447ed0ce7fc9524a5b2d82342cde76c2280b5a15e61a0910f02b464ae2cba63f748b6b26a28f3d6c3ff22e9dbccc6fd77caa2b2a14833d9017e99068a334137bbdd86096fa4c8bb5e96a71e8d7796b6b363b588bab50f849f8779b3ae0bb746c083b528265ab9b529402894f33885918a0b003f357316e547b9c02906746f5284b63d09c054476d66d77cf3ac3d9e4779b3d8f657ea76633ec3b3f704c306e878e47212356d59eda34b5c94258db40a59cc5586f5108a60eb9fedc529893911512c3c31241ababaab7011c6ab35993c2b9d8a9ac0961f5c65d841c1bf78045565c6c3274d2e3cc0e84f1d60194e4d24ae3f4f563a2a3a3a4a58cd86e6ebe58820f5d55daac42e2853674c2ceee82b6c81e939d825ccd861534c3432faf69aa6591f5c11489f52ab656b01786abbee80637b0f209745b2ab2aacf4a55c528c496f0f5edc9af313c707b23098890281350a65020d6c379b9aaee14b689e71bb2f321e13bad141dd01dd7","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
