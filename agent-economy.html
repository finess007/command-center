<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1ee3df914b56527f792cd1068728a62f2fa14a2881a298073dacaad0bd897290e201493d0d50deb1aa73eeb4fcf6ec802be07a2c9b2736434c72b9aa3a4e03f42aac3e53e95dbdb095bdbffbb67e21a7bee5ff9239b8a96042cb17c3206ce36045cf9d4ca5335a639038abe1d1a51debe866d85213b2444de3914049c0d878efd9f346620e53f67e5676ca1ee934628fa44a91092655a40b2500955823497e1392736dfedc8c2e27f159ffcaa1ab43883e8af95f9c51c26072ef064447fc7ffc99ffd74dd834669a0e476f3449c439a79f261ae10adbad1e51acc98fb1d4462b0f1ff516c79e729d930f0d33aba496c8872e531c67620f97a45fed3c5b0f2f5f0f6512dbd215ce279ffffde4bb05696f679b6e025dfe97e7d9291958439cc915790653dac70f99a0795f29c92ff29ab01e347ad43a5261994d5082fffd9dde92ddf4f223d71ea35ee131563c647db37acf00f78f90b65159e15c799264459fe8c36d7b1b1d8448375795ad9541bad8f0ef537a891b09084d03283df5b51166ba1eb01e9923256c3ad21c2fa677026a40c29f9eb8e4346053fe3a397885900da0636d3a44c8085a43cb739cb0770440fcef96262b6367700efb57231291aa6b943a7cc14fc3e87f5029bcc75004329ffae50d8226c0f9a4ab431392c7e7a2c96933b5b261a8e09c756c49848b7177e45db3e95da13a77bd54f3e07362b0d6a2431351958966bf2aad2097885c4abc8d754fbd7e2bab171eef24dd092f66888f0b8dfae48d2e09cdd45c085cdf389c2a95614b3f4e11f9a86a7fcb93742f0fc76950c855ee9ab8f32cf08535fed083de9e65179a89431ef36317fb2b54da07d9b3e23c39ae6bb1854cf7b7dbdc6582453313fb5e8401a13d97b12a124ce13d2e7076a5e32583af0dd7530aea3a20c6aca3ea25fe030a4d129fbddec303e7efbd7e6ad9a06ed6b49d25fa7dd22af0df59198b46239ad20894b9ad777d1da7737119f20bc8c8cfe125309ab6ae51107b39d28ba188e1aea6d35831e61f2273893f9ac0bc6c4293048fe246501c5eff629ad0fe3e7de3954b5b0b7c13cc035e0af7ae2340dbbb5c591d27b518ae4708a61179e750bd16ac25a29fe57cc6a109f95bc0b5b03fc7b01a8f58b06df8459333e4e361dc6564dafff4a64f309521ceea3564d2931a4bf266dcb39c05d2c9672e4650fedf4196aa89ed5e81e6cf97bb671c6b21f70ba922149d89bcef60e9dcc68bdcb2e37381bf15a1d7a4175f5671259a7822213c44d03a9907178f3af3e0cb83349aa9cfdcea2c3b2a0e50ce36a82f904e9e4885a53e08ae82c6dedc5bc3ed41f51033c96f715f66fc0040985794a7be44664b9025ec3f4150b3899503ddfe3e6d6c2374d64f33aba4cf76274b63ca425488c45cd0ed37626556e66de55f472c3d5fb71a30b66dbf47f01ffb6308601ff3243a024b68b0976b2549c83786382865239f0ceadbc73298522841204d54e643cd937466f7ce895ca37a0a47828c8baf730c428162a14665421f0a5e51f44cbe09e24c1dccfa163fbe35a659e6e20e084a3866b44a45ed0d274fbc585077514196cabc2b5060cdaf78389eb1dac7942295c7feb18fbc83bcb766d3c0441d5c0dc5714caac81262b3e8c8b9eb211ba01bbf3b28f91ce5314a03a1a96fc309e885a75cbb3bdf1875d03a3df8e832399df57b0f6af13636f689546b2b95b69178e63e0b0aaa0924316b1049c02b098348b67eb33bedc960a7b2af142cba2452d95550aa771d8176078007857896688e9c5e90fb2b3ef14b074973c02545f31c59e57c0858b267f4344a61f70d024ff3b1f0eec9d1480ebf7e89ddb3636a896afc8c184003fc53004425310456d04774ed52e7ab12c7507752e7ba3c4d26abfb439c7aeb70d3046a794783aa091603fb966341643c64b1c97bed06d1abbbbc73e38e60be38c09dc05cbce3a208b99696929ca261a0ed9ce70f42119c0b90f69f978a3772c730dd440f8adc3468696c9f105c362f37ffe4cf0344ef6a3fd24876b54211709a6cb2144216cadd838e08adef9b07a4b8d1afd717a1892717eb6a66de8c09d591403a52c3cb688b70b6e20090f40688bd5341bc98d1006e6e4551abba645f490686b6ec0070c107f74d6be4026761b31adccaf8c67a4d1ca84b7672558c217d1a49780748300f84c0eadc6b1c873390dc84f14e2014156c4faab840f6e5ea384aecd254dc7e9f5cfe1c218c0f278db5967b7b832248f2bac0820ae0eb4a408a3ae842be92e527226a83bbb1713910bccb669e754c082a5fafc5790bf9c74dd37ce90f0e423c87f79e5916d3ede5cd1650f80d743563e4f6c9be4c2da5fde055c8f98aca080afff7f65e01e0a1b4d075fc2fad1f1eef7ff7b377ec7ea058da08439e550da2ee1b97365ea6b902648f35a6486c0669d55fa7ccd5b17027903c76fc98069ae22b6bb0648101a4fd56212c0ce540588d15ffb8129db39be9b8679bd335abc002aa04824f9ae68a8fb9714c433f7fa22286b3fc6eccf82ff5fe696e94a61b31fb3c0407a5b884f0feb5504c747683c68f89d49b3fa36e5d3b7537eaed263b9eedfe2bbde0eb5633a7b7bb3d7b3f86542df3849cd8b6b5d4dd996944aaea171a98663407ca5eacf3449ccd7103e6fbfcf8e8353d5e8f807ba0d1d8cd36215d381a4a5747f6f703b3fefb8ed7ba887fdd839c9009223aa827be87f00300e59adcdbaaf20b7ba60e302605b51510f1a7f6337d53764d401c685742f343a344172e3ef1efd089dcac97f25d6c2b9a62edbf06b8ce487425583bf511af596c894b70e718c4c43dad1e5a4428598bea28a1aaebbbf0908e1a45ac65b4182e72648aee4345c2482ab066eb05194428836c868ab841dff98368cf513501e14f26143e33ccecf52b70f7de5d0de2c86f70bbec7d86c1c191e967e35984ef88330bfd4bce8df83a73ee3ab306df5b6a9f74fb51aee40caf42d40bf526a99cae55cfbe0c01bcd034179d7e9f01f8e1ec2042b3f79955c0bf279d4530b8757e5c1ae19cf7559fcce157f4d2859c3bdac0e61ceb2b5adb20f7dc8fd0901b0c52549cb5d03b9e9b6217015be6ead789ed43b1070009436d8d27d764cba5444458f212dcfcc408c5548b2017468decee22215f694e1c55dd6e639b9a182258eeafee60f6ba3b583a00307fc3f55cd29ea1e9ffde19440c42594409fbb1aac5c593b3708b15ad38cfac8ba1845329790e342759d76e081696cd96035f68b65a4fdc6a7c9c6011e6c4a6d47d7b6e92ada72344375dc087ddf3520f991df621757b2191612e9c9e008d2fcd98e84c6209d77edb5d2d17600d03879917e8666bcb3b38fa463df2575464d8e610615e2e21bc18be9f1325cb4bd5a9133942701bdf846e0ae21114045fe577e4aeae0477d9e8cf0015b1d4e0393ebea4a794e2a35d39406b3d8de41089226ead3e7c7ec20d42f4171250e4b22ecfedc8d421d22acba0346050ddabcdb41db3e8873384447f197743d74934360a03160cd3e4e22b07b1e40d1ccc07fd024a377cc19d6bf8cdbb37ee89464ca35baf2ee42ddbba9800b16a1eb08768e2e8cb583f6d4695cd0808d9ecf674a6773719f52f2a2aae7531bac7d5ed6a4734ee8f65d9b629619c2f53689feaef5af2b14c0a49af573ab011048fcb17c8dbabe45ab3cd7e7094e632fe8ac40152b2c6d22a24432a841fe37829a2bea1aa2d60b7080e35d347124723fb1983eec892fda154161db07bfba8e4239c757b612ff4991547e3fb5cc5e3da02653ee766032b6a91ec11c40d5db32a90f58e97e096893fc0e73a719030adbbc84a1fecd62dc5a7918866c701611c107e02042255b79b7a1e969443f22b034e6d3761e9df838d3733e3277648dee414b63f0c515a35fbcd1bbaddf69da8367ac3f8fcb8c3a52da0e226f0fe2aad52b9b96db2a18e072c76be3d3d6311e65673dcb8b581bba6859c8195ef36333d1c998f8bdc2c70f464d6bb931c51e2aa75d2b4ae3752882418d2c3efa3107ee6f9cae5a13a748fc28a11ce08b9ec41fec66b3abc4301355de63c0246dfab6449d226505a966a3e399d74e2ecfd21b713815582b6423bf16d7943d63f55ccd68c8b90b5499b421872594a7270a7efe1172113bd36400101adffc5d1f8711320275f30cbcd20efe1587c0d7a8fad8e23715b9944163c6690a61807fc9daa346bd09f0f79ea05fa98ecdbfcf8e1ab2916e0dac8b5fc0fe1723b53047054bd59b0bea0b1b22a0d38e11e3dfa69cac3ec2612189984baad7c1ee217a8e739145c3f0eb4b399e17c4f6f956d1cd3e234aa39c76668e82b911a29a748a9e62fed82033c059a68ddace63714bd361f3a50006bae92f0d1ac76a663d2bb6a93b6c0210ab4fcd5bf619cf4a87ccd2fadf39146d7a576e2df5ed65b27f511d79f4f074506e4db78991918ca2a158458b7a99ac3c3380746c0a2640d27f02e2501af8b46430441cccb1c4642dbd182fbcb3128f7bd527da01738f8b2856c9a6a6defb6b6005bf986ae18570a6dc7e9feb47829afa57717fa9456f42e370b1f701328f9c09310db5202e5b44acf6e3ad763bf84a122303082b5ab027e99938abbcbd46aad6ad908e881055cfff8a560bcc5e3d468bde6d1701e9677db3198164d01a4699e4efb16cc41372f241abc37e6ef6fdaa0f83ec0d5e798041d6c17edd9d61d97d4920512020029572396b676378c7ab1b295f1c0240d00b1a9d0472846ea8eb2822e2cf8b4700a9d58eba57709dc4fb1aebcb2220b87188ea554222c4bf868e7a3610e69100857779aa644eebdcf023be57f6555c4a8773309fa9ae120d2eb02cd0bbe6d2f749829814f262accdac2e883a08b4352fd06f12cef41eeccd34efcfe4fd4cf7c4d3fe8ec776e191ae7cd7466c22c4f29efe29478b1d45f6153a6ee6fe5e93fe145bf6227cbd895dd9236c952774b9cdc3d6b00fb1c60f0629df0cd9306b1acb884fb2ff6e59bf86eb07a9b0d644256436bf97843b9827a2a596395bb9cb33631b2ae60a8ce819643c406894a657ed24b795fe543100b914567efc54399084d800a4125216c93aa6727a72b86012c493e635a77ecb155ec671ff2b97d6e9176fdb5f45a3f256a87dfce5fa0c04d0c4b36a314f993dc34e528a2a0308d2b50a2a9c60ae27e5d4ff37950fed96e152e9a8d70c055b8745b1e3ac849fa9659e418b109ea90b6b7fd5631dbe3d7e93d189d7f6f92550bf1e033c5397374fd8104858a06d95d58dfe3d5780f20f0c0e126a429f86803ce93151a4574b08f65aa2a0c4f7b495a2dff79a41ff153c9a2aed2403f51a214050eada8145e31c8ff3c1be22724cb5094ca5ccba05f0ade39217d3d98da9f1a3f93c6e5c2ac393ec5fd5bbe274af87f0d300b733868f18aea81b6ce8b447bfba020cc6abaa410b57a85304d23be6f3dbabbee3c6b05a2a01bc3425102f49a32eaf31bd32ec94a437cecfa6584dd358415779cdf493d5f6a7712ccb18b1dfc4d3a531e8f2a014144fac3b03a900241523f00183066f3b5c08e1a48890d8c46852bc8e26157475a7678771c671a6f8d616d00b79ac2d80974dd12d95d1890fed88d51e24001efcbf917f2f58ced5c49f7676365a1990cf57bb1ee485011fbb3af879806964fd97c6253d1b1ff7f19bc207e94011555c01af7f362ce24168d46a4c1979f2c55945b769027d8559f8c4344191c185b99e011db9e27bc0379da019d63a2973a9856063062f40ab4001e8823c5cc4967fe9c6899158c38ec4573372cec7a5810f8435e27bebc9b6a597b6d09a57eff98ac8abfcb4d987f53ed557a86378d50503dac75f8c51cd91e26d8270652a81904a4210c9fddf91e7eace83305629eaf40888958ed61f53675da588bfaa7d205eec62d2b07df3069ac6bab67fe07967670ae3b760ccb59cc90b03d05411155c95e6708d666894753a6dec8fcfe90ae2f19376323e644b41bbde957b9515fa705fa48e3229986cc02e8b61396f5836daea6c235d8e6262e6ab813f7f9cb0a053da3af3e9f70975ffbc19061893c8e132967bca5cb0ea21d67dce66ace4f6fd99432a5cb7a7ab94d0180fcb6c3588780a2cf58c094d1d83e1fd7a67df16fe918d1646440c51d6267a2e9bf941e5caa99255dc54337e078792f8dd29f5535fb96c0cbf721bf8bb2d3640bfde179df18828493bd6b9934cdf55b4fef2355178d010499780c732737f4773fe58d9d7f710ef7df3116e83fcfa0336a11b6c09427f9d44f2de6ceb0ac9f3ac9ebd49d1d04b932f995134317f9524e23a512d1404b358c7abc42876253e957ac28051022f48fc9da4cd394c86bd734959465b16d8d90d576e6b13c9190e7ff77f7e4b8761c6b6ba18edeeb2b8c074f8410123b3f9a1b634f4ab0372523dbfe866c19ef3a4abcf825145e8e27b462bcdbffa101c25a9934ed37b04ee7431c18189c245f37a6f5ccf3a72f5943107f66a31e01922cbe454762f1b10550c065ad77cd112b05c713f2997f26e0ac4492a7fe70b707c791022bfc9957006b1b5aeb09ceceb61392a78cce2c53493dffdaf503ccc582fa190310a7227b7d9c8109435a250eb5362e68ef637d896b41f217059a5c8d8b725c75626314f96c1eaba9c61759135871c2ead40aa72a8917f7da69e77be5b351d63d5d1398fc76fdca22cf2a78aa6e4455e1fd3103ec34ae910aa112b55c6f87f0e130596d60d875eec80b0e52529c4259a48bccabedb0669882fce3ff6571ec81ac91ac5411078b798a7450ba5c2240edb2549197bcc0696a6f55c2b29d1fe35984de7e47240a4994b98a32de5a98ea3d901e0b691caa6e2f00b712af5399fac9129424aed3d6999e85d0b7b73005e54655129a95600d7ee5c73887aa8eca069710746f1ad1a2516e040712c1ecfbb3095b911a289b7adadf387556ac043ae0a58553fa1717f6a41677dd7eda9830a962e10345e776d7d0b8ef6c84254f0c2639c1f250f4eb252d31138999eee7d398ba1b62f526c1a424c8adad75a54b83d7c64565b54cdd39e007acd636f51df1a53f1132d022f603986b20a83d7bfe44b779b9f169f0ddaed8b41d27337706f407bbb7fe00d48e79f5f75da65d7a337a41931381e0adb2f85b4a813efcf36b8c27b50cdb678bb12a52712abede0d4f79273e1bf5c720e72a76b1d7d7c7af12a0fc44fb8f3aaf57dbd575b59468da84d06dc0c425ee7281404939839ea683e1dd12efce9a4521a0010b357944cad76fb66be9e1d2c237dc8bef181686cc30cad917d0fc53c79353057898fda491993c98974249fd55b09bb852260ab7e1eefc359aee561e557cbef76f67304e270e71f52fdb1d29dd88d85d67dd3a4f763b1f2037187408383bdb6d6ddff66dddb280ce1e26807ee7a4ef753babb63aeac96deba40a1db9a048acf2379d185f3ae699bc08d1cc31af34664231a4fd05a61d3fc5ac03508cf73c7f882bcdf23385421727542daf65d5365f2020671e8a9d3965521da2e26a6052a152654c69de36eaba2e89b13826bf0109f10590a519748573c5aa56e29ffc5f34b74df50e96fd36db3e1a915dfa0de4ef734269543a535fdbb1172ba537fa3b6b3c645d5a2767ffc4993fd01afb897d71143bc5453058dc520fea1fc2f0adefe00c11757d7fdc8dcd19a7a866b57d2f23acd1e3eca8f6c6c5f33eff465c7040e1431de741cc42af7860d7f4f9de02d4809ddf6a865ba6894ff80100947c3cd17befd469712328ed5616e767262d537a82e4d12adfe509c632ff2652b5098f24047976131012f3c8e47b6e802fb69203874241b68c15379e48ca55312d44f24ada6c78c43ecd9efec6df7c1166f6ef35612f7f1628743728a84cb352f6c3dfc6d1e85dabedded129ea02f699d5bd6ccd9886da39f59541f8a36a14db74aa2dc8755724e44973b82fd12798ed5e9c36fa3eb948600a0ecd2eff69b633a105dfa63b8a7b2087970802d3d4e03a60dede121004b5a1d283c709a17b5bca1348d805f2a23ec851a70211a41e13a74f555fc5bdd2b71708274381c1865eb0ee191d7516278b0e7f25ed0f9882fe4e08364be2c0ea22f782ad4884aa9f90a8b794d90fb9ac34d76041e0c5f037df275ee59818855e1cc22272bc64fbcc98c3323940883657732f59912aaa2900581d7b0c149d2c46a15d065722e23f602c3f341b1223fcba4a4ac8655101a1f85203a11469427bf30bd187738ff2d9adccfe4f0c5d264d5c82d6aaac57f6a6ac6198e71fa32ac2ba58be9f63b84904aa4589bc0f58398e6f147419c09bb815623fc5d97e3cb9c4b19152d56f198d2e1a5df0b81babffdab63a776415e831663a387801aac42afe25310ba4b583dfa05d05ff129f7a63560bbf521219cfb20fdc5d6b7fd0b22cd323351a420e53a0f7b5248095b92ee1c639fc9f4bd57b9c0b691d2e17dc5dde613d8895c69051a0f84a894e6a6cc5f7c868b67f430d37b80cbbb9b4b67300f237d39bebef49a2dfa8224ebb50deb97119a628d24ad8755605df4becbc9061778552917bbfea747ccdd74d37d9f93afd09c7d8a30aedbd87970ddc88ebd6fb73173939f591b3e6a216de025c9fbffb30949acca1bb00279fdb9bd9b29103cec8a1263a1efd91b89ac03b2875d3fff880d731f696fe69c496180d85668bcb7b2840549b53111be0ed934c28dc6324a27c11c7267787dcbf76dc126eb86711c4e7aa55776912189f8aeda71dff04accb3a1f468a7cd15a7882bf12867ec99f172b47ff1c7bfd1c2f41c7612f3b68adf31adc5fa82baec596ce3c80d01cc3f692859e7a25c559689102a92513514c16971c18c2034c33c67f031ff7785d45519206341543cc17f685accd874d649e204d6b57008db7a7f87c76f6c24eaafd1f31568729c94582b288dd85bfd115ed448648fcfe45224b4ff98b93196ba992d20fce8cba975e2d9e04c93cfe0f06331e6d716b2f90782586e384b03063117a09b95b165d9a9702f787847b23d2b5a4d82fa33f03a99d9124454345f8124a5c13ada551be35419470da0c3f7e57174036d55e743c553c5ba60d1fc9eca9a52af2c692cceb728376da98927fc143da22393c6f30e66effc34172d8446179cca7c0f7bba8b012dd8c73a0a12096d9bca89f8e2d67850bde6d001508558feee7b5678143313268d9477baa1a634286385a8d39b58befefac94fe5e5cb20b3f6597551c17b90c86f279f4a4528f4aca006332744b519d7d4af00aa0bd6517da0ba98e6ac525844f93c31c37cefdfd9f8efdafb89c403ae5fd297166be2202374644753af6cc90d6fb192f381329aec599a39eedf5121ef2805008b80079aff3765f520b003c216d01ab6583813899dafbb7ffbb709035a2682b4f2a5bb79bb18e51511827d44044145ff97fbacd79cbd538dfcc1a9b60143435194bca0d62bf75e044694bb1c6a2e3cfc3196f407f8ce9bbd5f16d98b7adebab579e8fd454fd70694c99d4025c7505e7c4b26184ef474f82d93e28f24c2cb872a6f13525dba0856c72f68dc748eed86d60881c77a829e52f4d5d1a39aefc11b07625caf502c35d8262d8db86d292483371dc8dd226a7dbee6bc5bc8ac1eaf8053fc8907d43a45cb9301f10dbf5effee33174ae8dccc404156bd62030a4907ec75dc0b511aa56dc5887c162e85b5e58f5a0a924203ad50443d06aca05944fc3ffe09b5a16c50ef6ae74de7dc4b19caf3041ea4ec2d5ced266fea9a702107868fdfc0b35b2ef2c407fde31c1792811810775e69e115ecd93003d87956a7ae1dff53a495a4a8b631a733c9a8fa45b68555bdaaa6ecb6f87834a21e1acdb4a7515d1b122b35761f165ba353a4ceaac16fc7aa80895a750b0753c635a915f6e0ab9b331512080a17ecd8fc4f99defe7a5e3789eb80003841c4c96fecb0ec164755072923b96ba24612f22f30ca0372829550055e79a12894ae653a31224bd95c9fea2b48b0ddea6417ae482ebe04d1ee0deae9b1ed0f5970055e446bc994dc081cb44eb9411fab1da7c01562f7ca1b0580fa1ec2465a0ff3e84f15fcc7fcb3b9d49b09f1a1dcec82794b55c3e89cebd8d832c01c5c794ee20979d9ec89c58e07ebc1395c9c22e9fa95cdabe1b969b9a99ad3534b77c681b6f449f001bffa1d354d34c6fc8eb359f5eb630d1121e58aeb35baa964ce90f45f8731ac1d5b1af9acb3746f9426d57e3669ba6b5ecf50ae42ee423cc99412137479ec89aed17300734b7c0bc77aa396b191cdb56c8a935d1b9e1f77d682516942b44d23396f20021cd6905989522745c42140308bb630ed2de8fcc78907f54524034b2d1a38d7b4799633a02a2ead1cc2604493fbf13c4f519a6d7a3618a26b770f8f084383d28c4a5d07e4c66d92cf26355aace176f562d25a296a9fdc506a68a6ac15b2f0a31dad2488bf604a008257064b4090659ccc830992f4bb516968fe27ee13a3ec4a4c6e964814fc04cfe855559f6ac03f7896d6fba0b2b1874795c5113e05ce5cd451a4c63c0fad58030e51c373cde5b53e3ac44df89e77ca3b703260a836a14472e54de9ab48041c1a0be07e6a1cbc31927b2f576688dc91af8f5c437471e6f5c61fb22e096a0f883ee698138334847c64743fbe7e838170116e6b653f1560e007109b8a844f1a4e24217772e8f07a70de0c0341abe5b5e03c7f8cab3d5a85bbe15883b0957b75997d2186dd34bb38a87fd9ce0f7098307cf46c744a2d8733e41564453867da4cc296b5a60cabba55bf1460472fa6627477a94e613875358c04733a7a67b068bcd48a2dad4a2580b571196f4faf50d28a366a931da89210ab21a1ced230a8d8f456884da7c96a8a1d7842e18ea91e977f5a2f7b714c69e10175286b64cc7b6096567ef2926ed1d9c084a08f91de5062b9789a704628876ff878c34ecfb86fbdb43a6477ea9f8ec0ff3d74afcda18b1bbe4b81505dcd7acb53f85221d697c3d1d076b0b21b21ed4f8bd072aa1b597b25268d3945001c3677040dc3c17a1e7d2b9d54807ca9ba5acd902e06801952e1651394479b871f0791cebd71aacb2bfcf911a4302df15a08c10544c0949aa0a62ea152117bd968e59624e3d61fc0d94e006b265ba3446f6930849189fe443f2a0cd46b2a8e26d498b1f331a95902c3791a4fe8aef5a4ec5f198df8603869e8396fa34f671abc272ee23d3e3dd4e11b7421c61ed522c31b4d5c66d5427596e184d2f27f43e3c4aad1d8fe09497788baa821057ad80b190fccdf25705c279890c7336e77e1b18136bff15753b6e4400040943c2cf2f16f6707e2109a5762d2249f038c1a1c2778303f7c5752c9dd239aaa966f7a86b363708241d6ed33224988378205d90a1bbb1af965a773976ba8c88e3201aa41d8f7740f6722ca3986fe4c2a1d8ce72b86ba1398c4ffa1fef8e84535870b919f604e5fd5141361eb899987fc33e9e23cf51ad698cf71f0d5e1bc152949a041a25c640f25e99c809bbf5ed2833bf4c9c5b434e3fcc755ed1fe6d6e88074c9505683c9f81245f611406fb4a101ac8c0d059c89a769cf825670270e1f0dd080a28bad7678802f507dcdd7fc966b78d58afc0eabfef863d5f1f8f18d0c598aff17fdd7cb0bedd8ca737bbf741b3d3a1a7d7c0a55b0a8d68c2f2fff7f87e937cb43708409a72c908d671c93fe36ca93fc0f3bb5669a44b42c24d9c7e2e63386aa3245004be7674a33053efb734d150622bd35070c8e69930d1d6773b1aa4bb6806d743a11b0386ee938064ffb540e6703ee2c123d7f59bd5c6bd7e91dc00411d86fce965c99875574f97cf6cafe7bcaf32dbd3b44662bcda5e81757dd3120b1b3c271a55d69ffe5af542e2cf4014208db59a4638a0e50811bde7d16cd967d0f66206cea82f2efa81770a38754ed9daf99b71621e89c95c1a529b639064311a83709a3fde76738a07f3bfe47cb71180bc1d3a8e0546fcadffffb1ffbb1cb663bc01a82d3b8719864223101b754af8245fe72c2587350012fbf41054c0dc342e82381aec38ac95152555ff5a7aacba4ca8ea883fbb870f8c302c855be47f4e0217667fb935cd39c5363659e332f06c94d6019de2cbe3e68d8bd9e12da46c2af88bfcf486a6f24d776b09c35d3a39bb05986a2ffe14a3627b59caef1f11bc8aac53122dacf4899c0da8f2d506189412450192fbcbdcf4a32a0dd3a067e056262f787b2945f7a4c756a0f971b2cd539d7aa336ac001c8f63651361edea0a86b3c4b7d7c1576eed83551d1d738aa329e84300a34dcf0923d43fdc25ec02b96ca0bbb5b1d04430a1d4579f235a3c107b13e3eca68dfd52be8dd413858069cbc0b7411a8bac4d6e4d4f246e50f227f9440922eb2a76a59d3fe11433968f8e0e0e4c3c4d9c9d67b15713a10757b36f261b9902bef5d57a9d982a53439d265d6f2778532a995599c10062b44cfcc3056bcc4a80aef7c79897a4de9229b6d7bc53ff78319b0cfe73bff9a7a86f882b9c8e7d6f78632932e5641e5fe8b077e97b0a9ab942291408f01cfd185ecd62a2f98e8641aafd8ed2446a75d26bdac28386bccb903967ec9b1d4e2b3370d5877641ddc703d7566219230489751ee6df120f4228619f47a37cd72b4840711515f31219ef67e230dc9886c39976aefcf7ea5bfd6b06ea60234585f1a692403031c1f9cb0ebec98f6e86e39094f9ea8cb6c004287d40ffa31724779fca80e9ea7e0217f22dee3f79d910bf71bf226616a5d1e09158249ba0329c36533626b10be92ca495a5cdf5eac9fce90653eec3ca3980f0658bf0efbc3c53ac2b718feb082f01c93e17ec3b374348c0a7d23c532224d281742d4592ea33cacc5e1e4b4ee7389688fdf84cf01514a7500e095f93f8dd2a360cdcac38eee02d5337deea1c300acc78f88ca543b06dde1773605987ee1374221b137c9a73ac4f96f91a77aea541d88c1d4c4aec50dea977be9eebe11f45d4fb5ed531d08ff6a8aaf60b1253a0c4074f89e295432a846f03afe08a2af6396eff1ccc74438d8604cf46d300245c9977dfc15401c49fb12dbd4a804a73be6a9b8542f74f221d54e87b6deacc3ab9c03f248cfd71e274ee49fcb68f690b92055dd38c0148a185f9ec12b79baff251cc9ea6cb1c456989551733de2eef87bf9475c79bb7d0127e77d81f09dd68d89cdc0af4d90a39fc31486b20eca4977b678d2c5234b272f373a976650188493c5fc6385eb487fe1c6e050db443881e104be1058f7f1e513ebdb15e50229bac62ee18ac46923338d06a28066844ada970d70479ddee6522fe83855bb24e8e62c4d2a87d2f30d085f0864502525a88ffc088046c001ff1968e95776d917eaf5c76735519b027a67acb4edbb0c6dc9a8d058d1cba15b17054462c1f805016730dd72478ed9bb8a53f146a27e9b6d9e5213ddcfaba59ce05270b7312edda2875c281247fac4b971bf12b65d0edcd2a0f4b72a7c70a552e958330126ab4af2f664af03a1a87fd3ed5e7a1ccbc27479861483d7c96795cbeb499e399293a081f9df82a10833a01213330739064ee2dea8a2e8a0776d1ea246c98768b8a7a3b37f9ecb3e5aa9d2b1b0c7429b3e9ac923cfe55c89b2e4fd33ab2a2cb4fd11d449b5539810e037c4ad96c31ccb24b9d0cdf3977664b5b5f42912e92c089d7d340318ef7fcfbbfc3ae3c4748727a73aed68345d238e702bd2ce20ddb918c6ab056918dd7615e66b5e68824d08892fbeed723a8a0a0d64f0e69d8a8adde907a9adf8f12f7eb44d35f305e4e9e6f8210c7a9031db3e49c1cc3851400cde7478ccb920a003b3b7a406611dd0f2c5c6be424db905f21a7180502da98c2aa684049b39cbcb8688d769e7e3ca27a47d180e2ad2ca604d4fb191a697cd802b378595fff58a0d14176ecf9b9aa3ac1ca06bbac745bcb7e690360fc821066b3c752159cd5da3e454cddb38ebbd1ef9daaee12111979029250c5c0c52b640e1ee4a64413697d2938d241dae3f82bbd5e6c1bb0a941bda402f209c9c9d9a888a44f4a68028ab9104f675d35272a0272806f5a0fc7cba5c5b224c97edeab0aa44938bc3b98474739cfd83c3909aae3e0aa384e53770336671c1dde8e4e1cf933a2b09025453c926a9291257450f848f222221c1694b01ea70fa732120f7b62c6148810d51fbb05083348432333a1a7001cc8613e95c0a085138826713f292e1eb4c591b7e02e63b0457f5c351bde939526c983e77243ca9604f98cf6dc9315d4f7df82deaecffeb3a695edfd11809b766dcb00f89f99ccaac61a9d8398565c3715ad5291c7563137750db24748ee97109832bfa0605f319bfcd81525ae9761679c9435748d17b3c25de81aeba9d3ae74513001380c13eda90591e12f2ba78c82276a014fa2650e1ceb3939791ec5c009c17a849e4b644fbdcf3a51f5eac55d52e2199c933134bc353c1031584a67460b34bb96cdbeda35b41b58caac52cde9161ed88c03aaf55986ba7db846fc325f971873d27f86982587eca1ce3a62746dfb0adcaae8d7bc84edaba2320f3fe184f735348f2d78075d6195f6ce8b29684696aeb9a9fd252af9b807f9d2644e1297d3602349aab3b82ded60bd969ee58398da4b10dfd947f8d6af6b6577363ffa7ccf64add60e7a09539dce3e378ce11c94e55fed2e27e89b54ba0238ffe91a7c75a470a368d73e335e2d28b2094c93c867db400d72f99b71bc0083ca270adda2bcbba6db9649e17dd11900d9635ca401a53a39cf8c2cc67d647d185a223fa68b543732db0e928f6fc511be6e9e61a2d3c9dc4257ab6697a5b65e631b04466433ee8208d68f32361ccd8600695a323afc3040f89f54a5b0e41c127b4edd4ee1ba605e9ba02f0859688b81017c185d3637fe10aa17980138defb6bd78a68905d328c82c4e605ac0ce0f9aa37ed6b4d409a34eb6afee62a808facab7a5385d4a5ba649892e35102e038d7e91e99ad88382e2f1878cf7daefc661a3bef7775343ced5dd7b0d6e9a566cae48063bb120089e3a5b3e1f3ab794672e8d3cab7b2182acce8bbc2b2aec526a2967117042cef3d71f7bb608a1b13690310bed81ef7001533369452f9e0a7e2b97b6cbd9e1478c3511171094002735a18936c5b7fc20238563c16c09c485ada15f1097fced73dae1dc47050e8e4721124012bf8592d101d87c400597b19954a633a47c7e85885f629b3682ac11eae628ecf2f7edc76b697a4b3ec043e3db322fc77f3f81f8fc8754e9d0836ac0206292ae21ba2b548ea8a8bc7c987b358067f8c8a17c29966acf61abf1a7ec6ec20ddb542ee8d070ab9b1d553d193e5c24d675216a9c30d668e0f8a510b60b590902665e73dfe80738b1220e6cec373560de109effba6b9da8bea0bc4d5aefa67d827f7bee446018bc01cc09e49fc65b4e7767fb326ad9849466895b4063bddcdde9da1acef2b623df09aa1849768fba9fe5567a09392d79283f8ed10a3716923a1f957cbb12d917f5fabdda82ea7e64445724b6a1d9eb8371c884ce8bb27227a762ccbd3b64418332ac7c9cf5b9097f480ed535aa8fc24637f7d578b20cd5ddc6225b853fa6eaa8c4e42b6b89d2284320890b7481ead514be719c01c926fbaf4ca075753689ae96e4f242cddcf4ca292feac517c4d21b82d47c4a961019b48574f9c4a3503f6bf9950b7ea0ccbb0c388bd16e710674f628886dc7186038c3c37aff5a9c2b53b663477be8f223dd764ea700e9c28e1ee9eb18d67c56f8435810d5af3a23dbe49c4ee567948129939c9a9bcfe62195d022f5a87bfb318b35f2382fbde878dc31d165d6758fa324ed183c95a886272c9c073a87431fe347c163bd27ab80efaa30c4cd17e81c233ce983f2a3e516cd8da8c4b6f5264f144952cdffa04b341fc08945383158aa847fdb863e263d1ed19f2383179d0c8a8c496ef1a8655ba03c147cbae6005c677d740e507ec62d98b4a5ab3a62c2ba3fa9a8015be0588b7d9fe2e","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
