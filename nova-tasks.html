<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"05662cf4361c9f91f512acefd72e4b63c5dfc73e578534c15edb12bff58741ea0f785dbc2eeff7be8dfb34db2c0208595aecb6b0dabfb4bdcb9e6863251e7520150cb2e0a36ae4afc9407717cbd82533fcf3382c22f3bab888f97a592965d83f987b532a64cab7be1ce900b5040e330bdd766e4e3f4d94f2c3735c1a411d85faf740c5ac9b073dedd951384c0534834d5d4c3e5208ad4d5877a5188122fbf661ac0bba4e5282997bfbf53b0db2be23d16d0ef4d03723be799c1463af3bc4eb2244a06a22978b733c01c26e945eb780e940e0dff3179a6e505dee76faaa0b79d8bd630a9677d261f66c695a438a9ecaf5573338da6d6c34e1940edf6d3422ae63f29e8310f857310df03a53ae97c83b1d8a277f141dbd9c5d03e980203c4aaa9040aa60912a0c2a51a6c460b12d520a833fb7696351271b5fcde465768c0b3555b7cef904d9e6c9694c4960b3490300ad8724c4b3a830521ded27f1fa416adbeeb1db3f1eb50c04258ff56dc4bfeb732700746987d4e99915c5576e2b5b63c2d6f3ce39d6dfd69aa5626e59c734a92705c6b9df65090465822be318d894b6b3318b1c516f76f0cc1c0c4f42ca629a7059cf9a387968d7e58970e2293b0d6d30ff3ddaa453f93a9237ab5ce3b87b1feaf0c693f2e7e1c183d4e05fd27bcb86b1604ede81343ef6fa697acfc32cae34e8e46cf5bc7aa174213a06cbaad9294482e43f29898d682495df22b6f0ca22aa925beaa84c90a76d63eb0e1311a46fb0b1730bbe644bb399283399d6657eca20554286974acbb289733be17ec256ec375281f444bf86be7cf45e6345134b05be7e187dfe3d74e59d8b0b25fedd53e813e8ee7125ec87320e69dc1beaf7a41b4b622307c54254148712b9d8d28e41f93f4ddc25dae5d0f8542e9d67c6c9dc2ed9434a9868ba4f6d617d6633df8e11e76d5d5519e0152962101a05f232aad07e1091ff5904677b85f5d50edd9bcd03b3d6688879c10b5e044bb6c75997dedf913127d25cc1e6430154a80a9e52f25a3edb839e84beffc645692e48dcada89551a7a7507112eb53c33ce558e0e0d32108dc22ddd82e9929a7675b184737b3798081025b70eb086f878243837dd3d01f5141cc060d70a0ab17f689d79a3724a3841673c0c7a64e3af3ab57d5ca376e6d955f3a5276002b8bee303d8744e612a39e6ae9cff03b7dedd703fad148d20d4fd69167f5ab9b3f15adf516d9159a8e392eebc5e248ce521137efc638aa1ccc4b7fb9351cdb671d64339a0baff84d4c406bf6a458fa9ce75c0736fdf4b1ef792b7bd001dcec9f015f6973e081a52042d92adbabe19a44bb10590e99b029285d850c9d90c41cf61b2b9286936255baef5af5740c71ab29aecec564443831ec5bd2a42229d1e01bc953773c970ec98a9ff5a937296fb3b5854c2bb65fb04c1c64b9e60645c09e20545fd3757df1b58b0165277f1cf0fe87b08cdd27a42eb6c219ef23de555a89eaccbf35798154860504dd1e23f0062a7904d38d7f0c0414d01033f77c6b6530b96a3c4a1a218fdad68bcd53743512ea23509889cf6c312a989b16ca040b2165baccc1d37a910826d8b5a6ba7f197729d46a360eb015a4a1cda6a580a2bc3509024700ad1641606116519da48c18719e1473242db9b60fe77b39a6bf832bbb693c2f01d1edb00a270ddbe3b1113b709948c8c9b66d38f66fcae2a5f9666b6ec308e8106f41cba42e29ab9f699dd2aba8d2f636fc6cebef72614cb22c8164c33a59593828ec38e2a2a633356bf2d120f01df16fbb9c4b282622e83212e6659c104a205b050b2be48b4f2792f2cc7a84aee445348cf20ad5990aba8015140bc43fe39eadb575726e06778a7a5c08f5f6ef720656a39ae4b8f9805abc3093e60860c1cfbef0e021a93ede5b1a3c0d3c0d3be345bc9297acbf2ff9b427cdd2dabb6fcb2acf965191e5e20572a682488c77589871ab1336956615ae1d6ed6d574ec65ad8e11777cfaa39598296c9bfb936c914a12794a58c70ef81277a129d9c507c80deb43e3fc364dbe5cb9d74ea73ca549e6b53775360804dd9286cfaf72c48b073de7c5aae6af899c0bb05c92c6c57355b38427b6db7b75d549d8c892e95d964b44d6223db6aed21b2de822eae610d63c6f2191c7cbe79c8112ca3150a17898b6420d23bda9fa5db6821a0acf227e987fba08628016afa11c4ec3c6e16d0dd2523ee22f2b590ea07d055aa773b50dd0774b57bec243eaae5040f1d1ed97eb3279ce0bbe6c0f96f3f444a2e2d04b096c6bf3caa93eaea5026aa4fcf67f1d21baa6a9d249408fd6bbe3e0b6a2a4de0053d3f413cc10b2dbf08aaecd096b7e7b9c853d7ac6e1f564102d9947c30cf01509d29fca7ffdf95754278efa0d247afd33039e681b97462768c5c9dd37cc189a254891bea7d2bb037583a12afb23121b1b51f2ba8e8afee4c66935be9bb4e25204cdaf28295f2edaca26b3460b51e951910a0195e9581729805c997a8c89df33cd523bcd3c6f8ad1b02fc6fe6d6acd8276dc2a12f8313dc2b4d9818d23ccecf698221de7064a541b3231e41b34616d0b61203701cd9ccd9901c7d0d78c4bb01a5eda1b61f26c633f5f48d21d469f4e5f28be1dd149efe7a10a7a3e08e29eba5c813a0202e13570544a876a5e00c6e51ae2af471b09478423b126cfe622866bdece79b59469524edb18a1078771b5d1cc830b6b7723d40dea2928fbffae3e2faeb11d711378c4a154133e160fcb50fd6865b660a2641910fe8b255a247af6ce5b712f32697b41a915dde3d2c662e0c4125eea47fa38572abfe7f256c11da9f556775085e395c6eb34d8ef514e15df5044fbccf6a530b97ff0098625db1d877da7685e812840ab8e8232cfb79db1a598ffe9a15c2fb42d236253859db84bcf9cf86f3cad599bba603e470b74d9610a6f0092b9e77365743fe8f465318afc2e15fa4cd65eaeefed4a3962ddab89f6132d70d8d45072f126352bac5c4cc67462e2015dccede399f9d7f39a92e877f01828ff88802381536020400fd6d82829892d9d82bfc58050c4bba95cb01014fd52532f8b7aeec8ef093b236877248e0d6f371971f18b25382f924bde91c82665660c4b23f29c791f84b1c3efec51e8a1827f402983da8e0f6d6036b5b15a0f737a2c08ca618009d483774eb18eb581881fe0f22cbc577e1e24d062527c635cd4782260e7462645aaf599a160505e9756ac34ee8f45b5527052811c9ddd607ecdfc47c67e0b327cc199fa591ab4c8f5c9765b5843e4607fb7a39b14f6a0e4975efcc373e1caecc3590321677ae0a85ebf122244d2733defeece2aa044f4361374879fa17c01dc68766b3e0eb636f968e1084b8dcb185416a656ea6365b03b84fba802e95a7a86537289cc0cc4d5f4c400c9a00ea23ea21373cf4dccdd7ae6f7bbfe62e8e6f61b07434130084c3a69590e6ec51e67503a165c33691460e1a457d95903288653b8d8e3355561e6e8a1f7776d88c4126c856e7e0baa752044de2a119440f38f3781e97df6e86df1356dee49296c5d19c9298a6f5cfc92865f68a2041e80601989d9d0b39b0c03c60a72f7f421449b654e32dd23f9574a05102f96602644c8a68bd1cda8a3af8efb5da2bb9467dc6704d3953f431823c4a30a8eebc63d771c40722f6e7a72c19bb6d40e401d20a20bba2dfc1745d14b9b1baa4f6644e451f44c749efe9aa29abceb05941c091c1c5ce502aee03e9561d7b75bd54f7f1a5c57a70354ec050b4b46bc2b3f6a5944bedf4f968ea390e7a1029593aa95a0bab763db08899d930d9b1d6ddb87bdfa581e312f502b0d0e0e898acc0fdade145e3ae2ff770f2afb126e763caf5f9f5064acea97f7cb0cd53c9e7fe85e6f7cd91836c17f00c0f921de3cfaca69ba2df483dc75bd9c98c1c3c896ee4b82a7ef159aa10ddf2bc931428dafbf9ceb160091a4f4e0604319da5872bf1bb06da1219176420ec3b648f0aeeec0b69fa7730d524208d4e70dca518958c81b1c0b7536c747b9daaab9232e4a4a75dfb9e14b202c5c27e569be3afafafdc1a53e345835c66e43598ce0e9d11354b7dddf683eadcbd43c5b6ea2c4e64275f36f9d0b55ac96ab373a2acb94a152686afff9ba78a51780f369e50d7a44073bd7187fe346ed86d76d62ae503c85b0f6775f1bc671cf839e2f427035a3b91488d8f94eb7193b032389379827b6e4555d065d7e793bd0eebdf300d8758e817b2532798914a7d6c51b6c5911e3fedda81551444cc8a0929a57864d7687b28f3978424b20d1cb4376384fe742489ed3089c104a3a7e5fc2c4aa6c726db6668f6b269c021327c8148d0cc2343cfe8d9981f2d42c0feee8a3226986ef0cd22ffa5b6b84882e44c64116893249242c344ba09296783b9b18b04d3fc0c4647a36c54a4b6ab754767793a0bd1b040b5f9602357248ecf7f41b20017484e590592379d20ff5cedcd7d937a453d0837eeff24e1357d3e760cf191292b533c03839c1867b4cdf8a1d6da7c16c20bc034f1babbfc667a59ff468dddf60ba1690ee360c502b141307dd051da8fd4057a6c69b3507b8fe10eed6028dcdd79d19ad9e93a5941cea957107d4d9e2d0737267be0ae3d655bfa8c1e4200aed1ad8b427659aae2bc9519f29abd7cf27883f6c897ff72e61e1096a1bfc057ea6eb56177874846a178369778c53365d6365dc01d6e4971331be23a28f73f63af68fa46a8d2f9639523a4492019b1dca14386d26438def5ebb979e1cc434e385384a4e801d624f42b15da9c0d4fcbb2ddfe66ff760582e6375eaae393cd0dfb156db77435f413afb41a20fee3e0bee805e28d97c4973ec4bc8c8aa10b55c67f38232af702a60f02df74742143bcd596ff576b08c2082fbdf69c360db5cb47c42c0d14cd7eec0f65b8f89b2a006d6ccb970d084fabc665f8c718c8775ec4966c0d858d22b44f2872e3ffe4cb52893c5791f3aa4b52ed12cbbb7fa37bcd31f66aeb1d528bd4cf646f90a2f697d5c97eec8dde60d903a120524975c98beee33782fa2ea784e5e60db9c8a6751a80e390de0ec89a542aa4a44218ac23d8fcb1fae32fe7591590689266db0dfdc097c6ba88b38c6f6d178af82db6007186ad0fd6aa99b7b29091a3add3e79716bcbee076b8bdd012c4639138c4077840d97e6ee773dcc1b7d754d704b9849afe44edf17a2f3fc66e40805891c5a78e64cca539abb753042a3f6d0762a2d3ccbc493c2c1902750cd63b76930d278afa099e56bbda446744d187bb409e78779d04e5094baeca8bdbe8342efd400f96aa9c34790a234c434b57fdc7e391d136b61e1a9d78497f6cf5251941c4a32d6e70aae9f73d0e59074afae31dbbc4ff54ad2a690e6a95eff5a97fee13f710c82d06208c75725f39b2cd339396022d22fa10f1af8b1969dde62abc69bda47caeac1aab7b256d13b20f2fdc3c1f358feeb1934cf6274abb5a753791ced72c8b962ba33736ce2fad2da487ba1519e09c82c30e67abc9f176fcdb9ac75f5da54512b7771e53fbb86a9f4c2f384afd241a40c46a47df19315b00d6fd47b31d2c3f7b08a28b51da3b2aab33838216cafbb7878a156d0b507273d80575e6d5499838ab9826bcf5ab16fc7134d6766d627ca12b85d2f024d4c7f4be2e283cbd40cab680a67028d5538ffc750e05c9b211dd38208913fd02d9f0b9765f7953b965ff0fde564bd3e12b0af9cfbba03a94d8d29ba70b7c2cf69578060363a005f9e04993012826d8d91884f36d21d1ed5c94654275dcfae6a8d539894ddf729b557088bfcf4a022a8e81658fbf9c58ad50eaa18103d4a3b8afc640abdc9d586228ae72825323875c04942bc4d6aa54a211be21442096c8b6454667daa5a0389fab93f1212c4b6e1b3e38636ebbceb6a124ca9edd0e3b11384b3bc8440395de487a8c6608fbf9e962dece1642bb2d210b345ced4daccbb63a8da643cba1b25f0c8be135ef33387d5a9acc5878663ba8a62ef4873aaa55a3ea08b8fdbb35f232b830deef22cc8917bc2ae60e1b04c479c8232ab315a2605c27c710b7fa0c6b606418c1f80c07c4c155aed382ee308f7565a90856916e5c9d3eb2bb54f28f46c0403710398dfd2dc189547bdbc79cc63cce25260ed8080e0727275cf1b58950028e863f3e2dc271793130c5867f306456b566e80c1f48470c8b46e9dcc83e47b69f22ae03506e985bacba9217fecdd4f9957302e9527cf34915275041e17bdd0bec8509237e115bd57165ac4cf74d3b6c2b2267c0d6710df796382e989e53cf67c03a7c437bd588a1e4dcc2fec0e832a1e550321d1554df0935cfa1228ac7d4550051122f909608f0bc5254c6d185bfec6c10a949069b369c603dfce2e6c90521537820713b7edb14cc10696d7b7071909df0f15b21526ed5514164fa4184df88f62396bca346c285bc9ba12c3e5db2ea745c17a48d5133cbad7e3fadbb4cf79217347d3ae675674f214d3f51057bae94bc05477031e44efa307b7d4f176bd75ab458098ed27e52db0a1bf909021ae4ff10a2c378420fbdc8a2ae94b0a78f903d60a85bf3aaf2a24ccc30fdb8ad71c3194e96b7deceb28855e603aaa8f665dd944817f42c1e5136a60eb680ea5f59ede0cfad281f824dbb9829a730453319d8d4f9e15adecc09ac83992d7dd22bab58300d0c9e3fa0fc2b48769d5284a24ea12b1bc4699ddd4cbaf1814237fe1aaf518f5be20f957d2d023254f6ba30d197a6c2e9cdc87f4d13c18b9979c482b2f0e2e45f35ae0d2403da7e574d05635981130e55c016b1544d05ce57d2e7dc1259608c5b91c909228b64fe75de4833da80e056fccd41d54636c955d6cef21c713cea06e6fc1856c8c7ecfaa9fcf96b0a798b3e99ce9ce75251cab0b2a60d5d06d39c25ef91aaff475b4b6ae44e4f2f1307df7a876bb0f84ed8f4635ee95eff2f331e118d72c9d5b34e2857928c5c162cad2dafe578be7f68c5b3f4b5c7afcba13064220d156dea0e269d171ddbaa7b987e55fc35bdaa2cc04af604f7ffd384d39a976b0beaf709a16bb158cba351c5d5e12e2d523f49f1584d7c99ebf0d9c0033441c06c0ef5de8d67e826bde630253eeccdea2227b0decde28fd9c383cc1f4843e7a69ef8185e66016c605e4a553838a442b83b67e4fdc0a58a0d85f3a2967761fa0cf80956450fb123d90cbf51aa84b2a450661f7d24a58df338c5628475bf29ddc21e30f3906d59a344e5716624175d1552a831b78f134d5cd00a336ffb7e71f680ae0024caf2b1517a684ea9eb06fd74bf75332f7ea9ebe3731b56647a58c1a9c8d1fdc4cf1b45f9dcf7c2fa1f9667033be445b3e938db64886ba1e7c89cbff7b358baaa96344bf44939142a17410824224160cc8db34f79ecfb2eedebf47c41451b22f64bddc3131481aeeb09bd04077a1d360bf36ea3956a245a9a5df4881555f156f9d2393739ffc31210e7a72bbbde0f3ed12da42d3c8765e8e44fa83ef32c90cfd89bb29f9e48c9bf625b9dbb4d82c181777fcd166067f84a52e08f9ba68b90e410d82670d855329501d0c134bfbc13aa50d703ee6c572092da34fefc3eb48e9293cefb0f7d723e1c442ceefd3a6e5c2b0fb93420822fb1681243639be0e64a39e360bb168d43ee6450d97fe64a1d8349adef646d317d9e760d0caf8923e8c906da56a217275e3a91f4e41466e2257f15573e47918fdb805a61c8016a72115673b8a484c0a7e3ecdd8e3432ca834519c8d16121f732ddafb266f40921452fd5b91d10eec552bada9d039b611e0ac7e5c9794e591874b9f84d381572720e57a3f52351c27fb735b343cdd4293b11eb1fd878314c40e0dc66f22143d1ca0e7d6b3cd42b41a810651880596ef63699136eb724251ef265b158745c63abd86dc20b4ac7fa13d4b22f9febf80c3a4628dda1bcd5367116bd8984a0cdf07216a2a0beaa6d97751c4d2219cf765e22dcda825b952d96afe71f0d749a22141f205a664b3fe3b0e65b62177a3360acf68bdbef46f46b1ddac6e36d6f50e2c6b01e43ed2329d95103b9c2e5ae02a7685bbe5e24c68d9df6c20d764c9431394798cb6126035a5927038c01dff9a5babccf8e4a29485c714f9cbc910f803d6904de33ebc11f47c83aaadd210586fbb2f31a0e49a89e07b29cc9be87014a07b3f975f1550f2a82a28a4bfdb7924ac2617bb32bcea0b6e2a30f6849f05e5effbf6cb98b59f85ac78a2828c5854cb45536011117ed8d71bdca6509cfe5a447b0569b85e229274ee981adf33b788b12bf3a447ff93c031db79ad5d751c9dc6da5ae0d107a355b38de740dd7b5c4e4150044b75b0c62106be313d6c7900eb39fe40edae814ab16b9a9d79fd1c16e93b2c547cebca5fb25fc8a2ce5dd7113f30eb7e7e7ce4d901e471e533b41201f7461a567c46db9fe977971ec5ac6a8a2d700518929186a05d9c85aa0f0e8b70e84b805d4aa5e2221aa11a2f9b5ecbcf426f769351e7d0e7b515f4e7dc5284b2f9ec74f8680f56672a5d2761542aae8540530dc7ffa3f5288a72c8e9f3c550f106771a0d83d6639778cda6e83b8181fa186b9b7f3d02efb2354d4cb4e6bdd05a9c22768bd2bcb4d6493de2ada28d6be3115d9edc96f5ce1c944b6c14e37c92d10eb3354565f2d90bfc422673d685cb5ab3a5bfdf71440fab8473868299203c26713a48d93cb9972ff2175638367ace1eab42fc6264e4d3ccb3226b87341a2506543b9dc1a99c86d053eef94cea1b534dd04627808cbaab66fd54121916aa5a25f3263ecdf0f398397f9ccc2c31534c02e90e35c3f167c7d45b1f36f241b1991e0824abcc51253f7442779f9882bf1fe43a936f162e875c357108dc07767c5257f97638d56f488aeb52d4419862f6f8629d8b081f628702e4f18adbc071c44ced1f0efb0d26eaf87282d076f47fff5daaa85d2e531720525f2688fc32c1d1c2b6577e352bfedfaa8b86c75f2c972db62689281c043a915f95ce45f8d1b98317a7aee8588e24b925fb05dc59a833ccf3e873514eb7aab6e6ead682de6850be1688c883a15646098156b2bf89d8fc633379e7d6a31becc17fc98354f70a3463f16a07a4fbaebdcf232711f974827f3b3e814747b740bf1b162c7dece736c9c5c89288a7653f2b395d615a4be642a0f7b28d5055b7e5d1a9a971e103ef04b05a2b50fcd9a17eab67758a1b6d4ad8282662a46a8b514b3ab1bb2717ce866be635933f71f2d796dd2664bd5df0b7eb61f3d0f0b4b7e8a86c271a782a0f0ac754374c60b6747aa9767244360eebf256714c69acf8c2aa967ec5eb6b485cdb1ab2c1c550a1b58ab58482a9984a33dab41ad4447f72b60fa98a69c91d09312878ccf2ab9879712821a1ea136a91adec7136b9d147de8c41e62a8418bb2fd52151f44abe77caf0463276c5ccb26311e6c167432be72f2628a01af8725b39ac9a512becb0de82c0aae414b666216304239e368c5ecbbd067438e1d27357dc9bfbdb3e02821d6cf7e963f1067a90f47a552fb0649612d9193da7e1c1db855d56ae897c1b45d6a657d96359ba329a7ed2cb53d2df6153511ae867ff5d7c3509550555a34f8419d163e77aa47edef031b13d4c8072850812fc62643fdc59a8abcee224c4b6d9c0c21f394bae48d65d1108e1b2831a6f89a1ba392ba851ba3e81d941c7964841f4ba26720dfd6756fe5e4ce982d6ba471801856d8ca9049628cc9ca1fd9c0b22fdd25eaa2209908aad736d6c524f4f08871cc4c750452935e9899c5670c5732a09bb8b41bec100f690be8aa035959293941e2475d001d533f20db227073ab397e3922daed39a78dee467d734258f017c1c0692e021b9b8b6240dba217b2cea0a4b95983ca21f039980ef0b7b32ac5c38c7211e2ae955884ce5e0aa962bb0fbd8e1193f95f32738b7c3617e916694cdbb4efbc86aa43eabc3cf1b63a3ba029bbaf9a055dc14f2f05dc3a0921ff3c1fa0806067c9f3b88cd40e1dd01c66c61c6229ee4f9eaba8e5c53839c160406ae56e221e41fb4a0c9fd21ac2cf0c1fc6ce1d8b3a2e300af11e9e444ef4d91f73000e6168ea482caf717a48a1d26edcae2b9ef1baa6ec79bec17c66de9ce84696ad64c92ee501158791b8317ac73bb2213c5376949783c1ddd66d9365105d41acd192e372bb202f74bbe589ff2e5021554686ff85d7aa5cd1c06445245d1fa91b3b3605c62dc4197c5e874c34eebfee796584240ff003f0b8da0bf6689132eddda11c04c8ce11a35575b1c4cf1c9003fac520c6e4b81c99f526521dd865896bba8984916a713ba0e0e73c0a0b2220ffc0117f25c270b5beebe3f94839807b29b7ace49072b9bb6503d929e09adb78594e445d635cf5a3b2a1570806db6acd13cd6e8229fca8bd5a7e03313e5e347521fa6772a02c27f076497c77da61ccf7a54c77e047b60f43010c28b9abc4a505c5fc98009d491496a33c1b8582ffb662fd642a6bd72ec78913ce87b3d62c804d1e2d37726205e7cf4479bf7d8c4a64c6234b9de5c23132cdfee2e2c661cdaca6266f3a4e715d0a04a6cbf1e3229b3f2a248670e4958190b23254e358fbb03c67561e15f0b0d62f541f7bc66ecbe224106a21bbb86da688c3e3dd1d23ddca595669804a0cfe7741ba6474872a6f507f513af88982a839b8076775217c86bb4f7c9f4869d01c15f46a19cec856ca827135421e1887aa6b6424140731a0b2f9657a52c66d8a190a6f5d31dc40c947666020decab8eabe2826ecb92e05c9fea8fb55d83f970c458c3368d0057ea46b5487c2a433d7af47a1d58f43e34bd691c826da9564e88466287e5e7414d9db2c156fdde4cc2921b11819983727e6c954e397de97363c27b51ff6225124b2d75a6f422536ea19f413d3504fefc0737630e92bc78d112275eeae9838afbad5f6a8f62e05899e9b29855a1aeb968b466d7850f7958dedaf815f1b72ae95f4204a2b58ca9d62265545ce0aa32b59da1c4147f6af0c53de6ad9b7023186b01de3f4627120edede788a100275d09f2360450886986489a08d99a2e38c34b1c0c0d1a9d44abf7c3934afe5ab80d8af008cf6d816c834bfbb7cef46c9372310a0164cb94f641cdbbbc1472ea82e4d201d105978284e2e106f3e21b44b3a26b1ff42c953b6cf4424714a087a69292d4e59958c0a3115f8787d7f6d29f0393acbc56ca1739f84c822412769c5af7eaa0f746c75fef69a8c1b7cbbc25a7c77faa8b72987dd63d009d4e2bce4d7148f39d8a1c6b5ce7074b9443439d4832f956c245dc6d6eeeecd47dc5178dab971c628fe2f34e4864298dd38703fa18267539a61e6d27d5457424af0f69156758d2b7bb0740d8fe8010890308a73f2c8dd37f934b8e178786b2b3fc962093f78042f4b6c6c1b9923edda60956b17d34ac489a22e04f56e18d6d07039498b3fe4539d8b45ed31719abb08feddf3db2f35e95e43a96f3a3d3ac565f6fa5f7f51080fdb694e4da86e0cc3205e82c18d68d2134767cad253a201035780235a42c350b59493b2dfa6041f5038f0a664eeee7f14152883b1e10bed32437d892937092a21fd8e037498a95fb76268f9eb76eec28ca994f91aa027ff8acb6640696536fe63fce09f0156e4394ab92181a1da33cbea15f9c375857a0f6b50fd768e71e9c4f5fc74b9211e6dfefba05e180f695381965b93ae0e9466edab460f96542eb3522fadccf26c111987a4f87525bc21530e406e71768b2a27cb05a5aa159b36f8a99387420a4350f5d839c2bfeb8ce234492a97873f67cf97260a0b9cc0ee2112cb94ea9a6726ecb554451a343dc8f61a00aa0332a979d797d7504557af4ab0732cd16ddf9cd7059b7f870be16a925b75263af5fd29c4d3026aff72e32b21bcccad32d66acb63ba3573bc2383dcf1f7fde1c25eb73575c9b82740aab80cfea30f57ec7f5106f77f982dcab8a2025b8542b1026173d53a0518d0828e4d25104e1a36a619008a5dec54c29e60351d9ca0b58da513caaf6434d6a19340bcffdb16125c409604f5b1822095e7897edacb181194e9bfc4f33938bee37b2fe6e01c3032a30407b4be17c0f5b534d7b7f8ef1b482cdf0fee43c0f8678feefa573a24d2aed04a0feb32be47e1cb671216d3dc69e55f823428f6fe282806652493d0602615059485bb535bb433f1099349ee09e709f726e175d937219a448802d2f98a4c3ed07893b6c4937254aae7c4b5f549be75eea6416bce67c3f292c8105eab6925cd031ecbfae6b87a3d641f58b69db6650c9ebb066dea8b39f49de3ba7ebbdaa83c88d520c7a8e8d5bb7f926bff30e07641e2c3cd4eb61538b29f9f89d19c304c8f7dc1c58431e2361320447cb4053b6290b7026d381cdf1fcae13855266302e6983720b7e0e71d89b9eccc5ee7d455d2c8b26e84546b10364ec7d6124e67a0c61fa24938bf7b0101e5f09f5208571e3486f8901b9584fc6420e0c5823766f7aed05994acf6462492525faff10fd77a5c7bc9aeabb42e1853848ee99574f9b592e859cd7e720b6518c4c6fe7dd16b9cd5828b50a8d7957552ac1c328721b56a53f04011bb0937f73ef0509429ad150293937778d50188315b6a966de3da1af7fb849b949d21285d22fcf9839ab75375868dfafd79ae7b7352d5f464b4ca6f3bfb13dbfa49ffc7695d54df2aa0e253830b36a49c24b205b512c7de12dcede9b7057b7bf0d7d735dfb2f8441ef0846d17741c51dc5c1b41ebed554d81137beda544ecc9091fb09bb4a78d6b9bf820ecef571340a76f357f9510364f16a80ec1e60e3ae2828b5b479968130f97d5969b717b10997fe37f9355912e91ec2d5a9af9376c7238472cc5b9229ccd8afa7b5971b0075b5320d752831ab8e9ac075208666f0e455a1dd7cbec91d2da4a291d953a0aef85281e8c439705798c05cbf317bee16428a8cc14e19343a014950e89269826e49de7d6f1a275868f047834735671379998222eb7071d524e3d53fc7f5b963d791da8792aba90ef3241e57f83bce28cef2a8d84f1e8b79139813160afae326ac1f78bb1f9833fd2486428e8a4b0d9780c66139f89bfbdd134acf2cf09155713c9fd22657a806ee61f11339c4d86ccfa92e1a825a5dcf423259433a76cfb08b5a45d7952a72404a5c6f736c4928c70f6a6705461916ede98d2822da52730df9403448db566fdb9a397e1402b260688ff88aa45071cc83dfd4fc3f7b7781f10a1957fe260a5da2c8679f126341042d29336bd0e65c50c33896099d4722c3911c1066f84087fa20804a812b4049fd2632c6b932ce55a7cefa478a6d5b596d49bfbdbdf91134575b03abab49825938372d12d123ee1527c1d746ede89ebe8d119f3dfeed15079b0fb06246179656ab6e7886cfbde859a500a731700d9265d8c81743c2758da3adda37302c0612d6a56823b0d8c12a24f510a533ff8336efda668439d0b40275334c4409dbbc0e5b17a22d1ca301176769b943f37a71e6411cd6b0a2014915ca507b1e8a16595da42d863d002ac7194adfb90df2b6f5cfba568d0a48bb7b895a849b95d8e172143f6b87a8512b1b49eaf5e2aea32a67344b960ad23767a029aee05d9648e02f1857cfe39a5e8204478732dd9df3ab1ac3c5af5471ad0407f202a7bca4e457f582dd0adf7f1250b123c4915706630ec7d1500fd4fe36554a39929590596468eee721b636aeacbd03f7122ffb580c6760e46641bb41f3a9ccb27a1cbc5b5964520d609c8f6ebcf867508442d08f9bbc198fda1a8386c6286e1d8dd8f81627c0ab298f81e19f69bedd7ba95a000725cf52347cfd6ff2b70ee083dedf2cffc522455149687e94f527b012a2e326195fa9da96d83cc510aa424ce53edababe28d8806d456af1b0f6045fa65ff43eba526029a04115cc39cf6a5aa1982182c0ff2208294cf58a1741def8b00ca560efa8e11e8d4784eacfd9904e3bda3b590b7feb754b702b9414cf5b3f26d7c865b38dce1771f336dfba6b88570e231d31eabebab5e6f57518028dec5638a5dc9d8008218fff05734c62a3110d286bdb782cbf8c1c093411602cbb9128574bb03c3de058696e50f6b3221f905d1188622f4ec4c59da45e032b40479f1cc11e7d5bbe9912238932fa1b2be6d76b2f803b028d98225f1fb47338e64f062fa452595c2117b732afd6939643c84982b8919a83f9a46b37e579d3c9f8a96e7787911f3a9834def123bfa113e741c68bca1b14ac8abfe5f2df4f9c9df8fbd563039b09671c31685df3af5a7c3327cf19f51c6b0e32e48946259809ee0e556cf8586bb513dff020d5bfaeb259debbfde199aa9163557b96fb4ecb37316c184804e07cdf8432c5e57ec9063bc438a664827a3bdce2acd818303bde555ab15a74d091e220fbda2a87d5ad4195c7f238e4a0442cd3e079788d7a1a7c6892de5fe1696b4c966d5349cff8af3b35791ddcf7afdf80f2976dbafeaf9441755ac9f13","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
