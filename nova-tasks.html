<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e104d2c9d07b0cd2e079527601913c1be0191bcf40f665eff6f23cbe2089c5dda852c0600fb99135155bbf751998c2e23519b8653819023f6e459f8935e4179b16ff231258fde5f89ce4d60691533d283a675556bf34e9bd52ebbd63d94f81bf972680cd118e4e5645165ac70fd402b29b90506a7c67bbe5a91595b09e810e18d5b1f6a376a8f31bebb080798fb370c1cb81ab37a7af933eba9198f80b4144fc6eef0d0139909a6fcc821acc2669da605debb3df5946f4b55460cb9bfebc66c692ff0915d5d25938cb11cc2f48ecfb1bcef3c105bc0782a5b48ee0504d289dae28e67c6160d9709ef16a541b51930032f093e81a38c11deffaafd51c63aacb8b8b9fc355b208fc47e6cdd71deab16504616db41ce41a56f5dcd1d224be1dc07d2c2ce050414b783cbeb91f850817551a63f3411bb45918b017785e07b2a5135b9e718752bb8b16807b712d4ba917afff4a8009efdf48063bec02ce3ef5afccbacec5ee345a39d17ab3d4cbfa043232805bfd99c6c6bd98c7486bde679f87377e92d902cce174b63e3da5a4d5f7c94f4fa7e306e58fb6e49efb95c69ea06d4d02e778ef209e758753bb83619196073b3bfb6e3be2e272bb3ed05ce136e2ccf4f4e0e81f2250218a65b79a0c6a2aa2cfe64c72b36eb0bfa5056d914255470a9b035c91ea0f8846b6d265d0c1fd808e598f0debeb4ea85c135777eb26b86091cedc9b5848c13ca7b105a195a76c419648ef6b3931f8f58cee7624e3342a1ffdced76d375e4bcba086f9c23242fbfe2506af1a93ad7d6f2614e161c69552b049669c7524c716cea6410a2ffff8b26ad48fc8ca1866efd437d9a25337cd8f2d66f77287b73f6cdefca986a8b533000cba9b8935d5595e98b15fc6e5db6b6636c99c9d04e8e1263cf60427cd155d09365c83a3ae60c153a53601313e61706443c3767fa371ffd042d81f374a09a194358decfe9d7fa7c7f698d1fb4045307e18d937959f59e999e2ea08cd94598d71b4898ae80c803ed1eb7e0ef4d18f0b87559375adc000db3cbcc45222b271d69798e4bb18f49f847a94968855a4268697912839d21244bd14a02e701eda612b6c64272c5d8dfa5ba988130fc24ba66bf581d3cfe5150a080854fe6021b0c288ec995fa20bba7cea4b8a04b60333f302766ba1149b7158413319aeb6b39d4d48f100ae4cf8ed209694fbe2c34836cef863b1875ba1981e1b0c0b75693c9f5a9a69b0898d299950c9464c21fc0b8e8962660f1d0c37a3d78ab33f1fcbd35d88bec2d48a806e49ce7a5a4dc5a75d706e90b900755aaeb14464eb863d6bd571c330147f315caa4fc7c5a085d2b9116d505158c70f30495dcf0bba65fa708e9876d84e6cfa0892dd9c93ae7612ee503c2ebf538bdf3dda0e3026b122aed8897c03a09cba0934f89f25badd0b6de7747410fac4f320d0c2e69a275abf2e683a2dd97163bf036c74f8ed1ab327aa69e7e4ea9d2b6b3cd7ee30acf3606f5306390a9b4664ca446fdf17569d4df5df9aea3d3d005f3ada9c18abdddf87a0e738a0f8e4b346c739f17a948605e26e8103771682539e9f3a53ab7404a9e2f2f0a8e48eadc08a620953de51c873d65d87dc1ae6a0e96b59d023eddc0baca6329455dd0b7fe88f9d7937017e833a306b8f37913072a248d36ae0c3f683565949e77d7ee7a2cd4332ec8785fa02e802ff57af9a1fbf72a2f09aef648eb317b5ec3e18d83ba5a1835707ece5d6fe86bf37367a75996ec6520315e53f8d957ab99a9ff242e8b93261c063d927cb8c625f09ceba98544a1ffb1f8ff5a7d4b6eda8839fc9b4b6db5f60691555ce3fb9bce49c133ccc891ecd1dd2544de81ea91b0fd592d9aadfa304c9c6cddbee265e5fe5c41a1339d43774fbba62e47d3acaf3bfe468b483e8c25087d7119f9ed605da7af9bfb52307568106831a1823e43069b39dd9ba2966fc346d35dbce06bfa3fc9fe280d0f4a6fcc3082c07cfe6414abdb67f7615af651217ece830f20c385f7bab6a406fbc117746a7d290669df2b09ad5778dbdf86cba813b31a88ee93b27b20d68da11789758099e5b4e9c2189727b9340cfe539e96327d6316b89299acff7acd021883e0016b263230130fd47e2874c20ba2b31f8947ef360e7a244ce568700819b4a42044b0646ec647702c4b44b9743b1fa1a6fb00a63ea8ea9e5b63c8599c5b7066cfb22c3468e79ed9329000c2949444b9ba4e7a106b778a6fc1af71a71d0fe269c567113f9c1f37b6df5fabee5cbbc98ada661e3f4f17ebd95409c0a92da1653cf9caa237c253834c28a4888f1b555bf4c98f9a4f1bcf8ed9545875d25c1ece0e3a40cc95d976702f6b5cc7f09f3d73cd09516358064e78efa5636c0b28b6dd11f468576c5d56a0bb42bd4093396d10fbe1460baad9f78aa597010218e9ad97e41fb57ec9dd455d57d1e7bb66ef3cd2f621636898390fad4c09eec35b844416c5033520d16a1efea86b67f564d77447341bf2aaf6fcc670a004d0f5bf69b8c8595151dd51ece29d5f3b533e5194318fd71d907a8cec9d330198c4d21457c22c4c4a3b0037d3cf6da02b33f55a00df88ff8f32d3da0cfff435e6d29f1edca2a67c8e65662a3e789ebb04a3e200fbaadbbdef334fcefbb09f9cf3d1cd3f2fd1a509aa24cc0b26ecd82fe4acc28506a119a5b4c04a24d822c906e6dd95987633d771c710c0c0b71e3c17d372c570fb052e423a2419a6c4e16063dc87740e054446151a08212aaca45e51d54588a2cd5bcd1a8041d407566dba1199b5cc7f677d156567baf3a59396137b741a6755fcf6e45564f3aa99aabd42263fcdea514bb27f2034e19f8238d7e961d3ca90e7564821814fc04e3d817dbf5d447ab65ed34c1b81ccfc38c05e86ed3c0061e84facbd3074e2447c60cae1458ab5c8d51ca5c53203ff018e0586661ee393d4550d5f4549d00472f834e9bb3f5d34b03741d9c6ff4c3d00a5cfb8f3a194c3fd324b7ab38bf4e95c6df6815ce342685af974856e921b747e163896ea25451f543ab7a27790286c8fcf0fbdc36651c866691888a82030f493ce2caa326020df7a98326ee7688633ee77b02828d545f9c79c1a13555b8e6fe373586c31a887a44338ff63ab3a449de3747d4b58bd62cb410a96f9ec7bc0a3f29a99736e699091539c298decaa18fb847fa9cc67b59bd533570231ee386a882bfd889a5ef3d43b68a2958dddf08651c9ac9534aa7ba9e6e9eb7a0d90eb2c1d2d69cf1a7f4b8e8e58398f6fd5429e6c7e019045d66c5ffed9237a5ec4f8e453709ed73bacaaca92d2830947a3eadfe14477a6fac8ffa64aae876f2c69aacb591c0cc208061654ced7a54314dd5a71169808c00d2884f39a872b422a06afe2561b2cc67a81397b4929edcf6fdf61273c091ba1918d36168bdf621a471fb38bf0a0d6742abbe031c0d13fb7cf2b04a52ba5374b574646e0cc2f969a816570987f6e42be41ec39483576f869b6705922ee1248c73187ac994e90e1aa887e67fb1bc1fc60a5a360f0d46a97b74f53048f60a69ff45df381ab2b1757ecb5ac9b0ed5cb60f04bc674e44bc6d7d6f854710fdcc2654aa82b3f4426ef1f47b3763185034e1c7fcaa66bb3edb2059c914e389ec11029a3b1d9e1be227ff12aab21202d8da836972921229a2ac87387d84d5a5c0df8ca799fe6ebbbb1f76e39649918e5ce58c759f4ef0160ee85357c01b54f21819289f8f8b6835fb9f47441cb81027ca2eac750f057098228d33be985389157f0a141a7371c00a8b3bd264e7233637824b9e239f8bba7f74406d9796fc827c5646a2ae6d043edc7841c4f2fc01be5f855f5450fa5dce69d5d917f9165e426e3a45d8c6d33058056d3fb68bbc71eadabaf95d22884b24da8b7dc6ebc218a07d3a0cf724840522e2439262e021426bebd025b5fac1cbdb928d2a0f9799e066bdf4bb07c4f58261f46fa869125818a332e79f824917169cb8c0c25bfb8a3c9c55a751e170586ce4be36fa3a558c685a5df67c3935e2c972e6d69a1cbbae9f954ee53c24f47514b26dde7f9893ade72c2cb099e2680bc2d0f0f932c9b8d7648e01f1123253f235bb9e086c8d91760ae5fe9c3152f6370ab5de054d22421e13b4006d61add2a1ccc122c6fa63f3676f86ff09d1b2749a7846ab159dc005caaa9e80c5d38c02e7623ed8f528d7d204e281114149b77df695d5a3112c0636b1f4c0bb16b5cee2c8359ff2258f1eeb9f66550e8b771b24014e06a77d8a9f7601c505c27f68ca94f0b6dce22877de39c6e8591522f9f44c09aea44a549d8e63d8f077027b18caa2983e9a157464012fed965a88e60f467903994230c091c1abcc6f9e8556fd8ee7128134faea73208f213d7784599da5f67e2d9ecf021ea623562da69919473b7015e8353a98f107cd3f16ee00f2c7855baef5cf6cd33f3f34c83b878e537f9a92dc3862bc78b035064ea7c2fbfe50d7a93304e29dea8848fa0ac2e96b08c6d207fbf064284c5885fc55323f53f073d1c7be22a692d5a9c448b5c287f91db35016bddd6907fdb6008034cbfcbac640fe851ac43ba1e3186ef5b2f73255cdf08e255a19e41c1c6b9c87fc38ede8965ba0998b8ac4591b014aadaa6850e8d316e0b0341c91e65b5f73719cfc4bad05699abb3461ac03c28de58a075a92eb6d96055b4f92e5b018e14e613a03efdfb9616cf099512aa321f5d2b78884594de21dc414057a89ba20a0ca1fcfe32239545b6b8a81389bc39605add3fa2b65f718e5f85fdca6a868ed8a32275880e90e71a5654483719086b8adfe140fce5d81ae1317c1c2376e1744d7c474da69e846ba0f6789be2b4b5fa9fb22fdfad18c6e44525684132a75b32883f87975df22fc817677b291373a59d9d9aed7a927a539e8728ab506e05b313c379f600cf2c399f6ba143b6dcf7bcca78bc927e51aaceab68892e35024a06ed2666dc2e5317810bbda25aac546543325bab8bdc14914ddfb2673c958c9995b323ade640141988ca726f1d62159e1800502d9abc9c0639baa08f62f2b0717a196d41dd0c7c39dce659b8bc8e8fd6daa28028ed9ccf5ac36b85abcfc5ffb2f598a03a10037a9caa4ef7d300beee5147b841fb88434343b3ba53cbf55a6d5a488473ce050cdfe620fd89a7e19b280aa2eac8784232d829e42ab2ee8ddef721c16584a5c5049ed29021c1634bec25b71830589b9d53b0693fd86586f2b2bfefcdc4ab1f3c723d7e6fa07a9e688a063d4e31f832711153cb6ebbb2949598afa7f99fbed3b5dd834e0b58c6fc83b58d9b2752e02e66341e96349a8c0546a86455e16c1e9529692d1c8a2613bc2ad6565c68f162b7983358c6611a368f128e10918522150d7a457d42445e22959eeae8331c873ed8708abc2327824f43baad1d9da996779eb46e98534fc6a38928120b7cf47dd5ac087b062a407df7ac650ca61f583705ffe97e5162e221dac5a0587766bd89997031462fd544000fdec1f362f3fec08d0247cf337224362356a91fb4419d634a99b1b1e5b6570df1361ec3aa812232b21e468be94a703be898a005880dd0043a758061668033045d20de31b316ca6961009fc5062d16439538db8ebaa8798673e63dc18a5c233ac0984562384fb7a74425eb07a9e6d461e1e1bd14e0c0cfc4e513c860586e761996e55199d19d1255b12ea0cb877c3bff8999a055f9f47bebc38dd378f49f11a65c3646d5a7ae3b86a6a707da5defc7ea9cd8b665c28b0fefa02aa42189682177a1e206a140629878230b34f673537f558f7d121cb6eeabbbb798d2207c520229fb48cdf6df6a08a2e5022fa97ed42a57dff233cf32c0f7b83d8cf4da55d3af3770110df0fa9ee91a590c94af8faf40cd715cb2907a124992e47a9d2564d58dcf52e2f0d07d9b252101553243320a8be3af8523a313fd48728176783c1c36e7df5a973ac7631b1327b75657a7bb379adffb6ca7c531c85c23a1c524572806fa367a308c8efe8fd2c82410f4c84296c18fdaecd8a1733e7f8139f71ca598731804c5c1a47b6b0935e85bc90fb6398c30cc696267d5e3cedb631b6c0abda938d455f3f715a938eed65cbe6c71e1013292f2fb3cfb5888d5ed3ca68d70c1793eea2a7b7e75b75b32432f45f63be555e930dd990efc7207742707b98c94c02f39b5d5ce3264b9ada72b58f05b5e638a5e29cdc98f0a89f7633e09348f5bad0dee54ff699f047c36f44ae0c01a5f99459a178580f3f3ad3a60c772e4470c9dfe7d881215ab05074caa460be51c3408ec8ceac37969f969f9ddafd7b45b0a3891ef059514fcc64a84d1676fb1f16569c0e5ad70947c7aef42f1790559c5656dff48ed52dc1c2a11b534fbe817a45e0bf17928c5a0865a91284c2ea60516e665eb19e5341224dd81978168781a237a314409b1f42deee9ee0bd39575ed5d6e2f7b54945580ade201a52a78fb7b2b5edd7fe764e208f161003497ca1fd7697f2f09b73fd44baddd5d27b066cde47929f98236ac9d336a3b8900e1f18c2ee25f53532cb4e210481a7dda5d2f513416724a2335fce93b918a7b9f03585ef80a2497bba768a48e9e92615bbabc5141b41a70585d6bc37dc1bc05c08b5c466af84f625532e992cedb02f1ff041f5db409a6bf0a4950c5b93cef4a028f28b1a78a115e312eef58883dcd058370801bf9327928ad0349081f900ace954c1cbe07e8077c5fc149cda803d6c92b1417e3c8eb89515389e2f3761fcbb579ea21fb17ecd2df61134a40a9817598c8182974f8f285eff5c0450a8d0a613dd835fcf3ad685f2e456a94a4c2d3984c97def1636acb19a95560aec525b8c6da51835c2a1280856a60aee25026e624fa8fbbd895d4f2dcc8711cf3793a62ffc395027b53324ae343003e805470f4ad62da7d854d19b4a2abd3c9c5030dc78c04720fc0d068a8d6b86935c95c449c22d0c94bf89d519012175723ed202facb66209999c40b7570685aa0aa1d0400be69abd5ea76308bfd2566dbebc59b7137bfdc2e63dfcec370c08c377c8a21f15dff09b7f28ee6a94bd3a9cd4f40b4e404e5ce8ed922c462151b54e8f4e9784accd4a006f0f9faf0f1ef0287b63fb31db32e6ca94f234a61763ac0151743ab7dddca61d3e40c7cdf1ea4d65595f0dcb5405f68d7549ed91a228cac73865d25822079a81c2980fe053b7cf70eb2a7affdbba4b99f5f7f2b8042a11100c52f55fed542ebbf4f603f6e3201136a09ec37af675e1710d7f84ea67942b1121268362dcfce4611b093858ad8f3dccb79ffe8afc5ba663d5748751cfde4cca64e41d239c93b43a7f1027f0e43ecd6d20f4ecfecd72ec3278b72873f0b676377262f269bc9e166ed5de71896b3d956e0f07bb815b02ad4936b0220574aad8a77592295c603c2a07e1fb226816adfc02d4544289fcf60eaec0ec29db9aae77a6e49dad714eed595b555a0e340b9aa52f997cae7d2bed601df70250956d7a5bf6cc868b634671e3476b3735e7d474f736ccdd135955312a386600b9f9e8690b9c48a57519329217ea2a6ee9855068c21b31c9c34a0c98417375faef1e2170cb926122e23473a5dc75fcbc952caa8f68b7f891755a08513d832611a6b3c5e4a845bede8cc0a4e44a725f1043e7f5a3541601b0eaa0c27cf65d48f6a695bf3f7b84e02cee397f0a3ef57bb7bfa6223f770ca008540a62356ef11c94cbfe63d248fe65b8befbe4923e875603bfb017ace762d4343a70e2ba5be4bec98b6fb80b9120f43940785e175e680904000e6ec0338543a898c9334ee9c80aead0bde6013384c7a4fa81c71c67244294966620de7bbd1f3430d3f547bc77657b7ee94b9cd8882471a6990f09c33cbf989a9f3729d83e415031a5528534a19a8a98efe4718d554409286f1c0db8ae8a7f84c424e652a46bfe0e46e92935ec2992bd0f61f99e1262119f29c69aa62646f6dd36ac3848677535c445fa84513615bc9f6b4f18050b0afe5a6d2abad0c736da17679c08bf959d46bf412c7bbe2cc7aa953d2c6afa2af427f094560d4c0fc97ed8d589bd1a48426a5b7c3b45f75f93f0f6ef9099e95dcacc44b1ec67f2b446e6535a797f3e3748ae453771fbb78b9e569f97492fea00df6326dc0d846818f935cfcbdeefb29d36cc7c1ea08cb0f3b9572d999d79e1dafb6a3bb2a1b636b4e5414e01b30dec2297985ac2b0f87be807d791b9c67101cc4efb4e87528790d6989d3468fe4973096d99bd048aef6ee4bc5e873e4d64eeba8649e54b968d7542884731b7b960c832ebc06d28eb6baa7851e7e61c39a0e88caa4d960b55716eafc740058e6bd649f2f39222ec83c85749a6ded547ebb0d203be3a72fbcb07fccb2f567961d6925d9d6fa7d2be70a153e9db0cd77ab7c3b32a063e962b33ce3c071d2ee11d485012a3b7dc80ab650e816f32c85b588b8e19964e9045e5942db4efddc232531625968e7267ca1252e2707ae8bd138c48a82206bcb2d0861cbb607b21dcfeb567f1e9c88b9820a5b60a2d2099c653f58c7bc80703b382959ef3839d7ec02a3da95d90d2375fff32daeba629feda31e9da5a628504494af6731ff9b50f87bc8e50d4f984689760056da30f775c6a1da8ca81c3885b468ab357d648c8de14f56504aaa87a6d45101e7366940ee8d31f534e1030e9ef9eaeaa983fce2cf18701392494000cb916942a7646d176ee1480dbf3148871f54ff4b9b17bd0494737ce9a46342b3beb28c228d7a1134657ae8c77ae81371808ef138ccab241c948aaf35b46ec940f35d97ce4db71fa7044ccd61325dc4d81464cb3946863c6e9d021549d2e52a77bbf4ae98c40eeff096ce53d529729f64f9b696873459a6d51910f4da5de37c7fbb5498fffec12f797dd9cb1dda81cd9f8364c0203b8b3eee56088b842f00efc325b3bf1d2fee5e8f2bf80f165988b45fc518c0374982f1b59605281e828fdd4b095ec47ded874d83ddd3dbee9263d543cc7f2dbf5e331b0e6ea40ba23098d31dbad17fb2f10c9d1492c098df6cb0cc8e3a2c6baddfd71bf64c4e0131dd916824ebcd5237960bc340d981f650e97159f4d76ef297120ca60ec9d396e21c4c4ebe2f599710df9ea17474d4ad254ffb4fe13667404efd388d7b92de250bbbc3777c21203dd34b98845f93cee20341f16f6ed52cf840d3a5669ca4f5052e7f776eb1559dd46e8a7141b24d590dc430746fad24128c23ff4e4ee46ca7d3c4574b4293f64c64c621f9343caa5d85fd447371798ebd2c44e0635ffeeb8bcbc21682dc4911c542c46eaef3d296954e95c575da36f38506f947b0497a254de54441faa49f83ef0d5c5c2d9af8efd0b3afcc84cad67207a8bd4edb695bc9a9260f23710d5229635f7a068c1e63b34c0f68c271d54861f48a557d95f0633d836fcc6f8ed35487302ca214c0e1ff98c09147709ab21bfec8aea44a8b67bd94cca7f12deb6f694fc6a01e2e576f966a52adc547d6c2afd4bc0901c49bbe101383d4ec69ad406fdcb8914b8277328b86020ae86753476ef4531e5a14b241a1487366a33fdac74f9f2fea7b91dfe051d2709782598a14154ac304f5320a3b5a30eb89708c0c97a11e32aeafef6f616d95edb7d066d09b3333ff3115195210db8672196cb713c578e224ba286c42d1ca1c1b4f737853de7f2d5de6e4aad9e0a6b32fd9e78d51d0ea6d17f5ff65d17e032d77b07116a2ccc7c534991355129ba4703ed3651555a18fe23cf1cbc24342b1e26740f1ac3f58886f95e604d81db8c742155635a0c5ccbd46522b9850e5214013025c3d1860c09882a609e30dd0357f351c08515f2ef62426d85a4a8baab780c034463a7847a674850a0688cabdae6e6853e4698fd211430ac3a7c6301299cdd17f10ade4a89c236c6a8a63ca3b7c685c632cdecd723ed8877cc3707f74085acf9a060eb368eca2d49e29dc72e43aa5c451274bb70fcb85462cd57f21fac6b9993fd0f6acc6cee9ea83eda6fbdad71ecb5c571632e959c8bce8178186f1f09f1d324a29b2e0fe170fe634cf3972d0f2527a428a8a212d5b341efd7a75c145ba7a6944d9ec4e3547d295a11b5996cff83d7fd20bde9a84bebd63ec9695490dbfa8ccc908913fe586b7c7dab200c57ce6aeffd6d203efdaf38875dc5e061dd8c4c519b9156114c36109e0e7108dec99ab36f0bbd0566e5143647ca2ff8149fcc0121e834a956f7bc331a9c4905e08322181b80c10759f194797368185a8832fd1d101c2d1520eb6a9ae15207d1faf630b7d90315a46a6e858672ad5cdb3acbed77802d4ea0f188c07b331fd5adac5411280c01ca8a4ed718d4457ca87b6e01c57eecc185509bf3ead62db2fdd0a806885bba90e2fe3735f12ba653e6b2cbdac6959b0722e82f7d68882c375b91a07e6d08196aecdae68f359726ceed7e57cc525704bde20fb2228b841bf3a920a138f8a5a788de49918aaf5121630832c2bbb53c69033e94c1c2a1179cf986103b92711e04b68001e769088e7e7ca9904bd0fd0b42f4a4cde62df5c7633517cbd0a2e3a72d0f5c466779f4336f7ae81bec4f534147372ffe7cae5da71d87b57e97e7fc905878a1d0ce80ee6a984a5557119b18e8ddc53c197770365c8a64d819d73ab02c84c41c321b02cb8d6ecf9858108ad2d314d0196b1c7bec35b90c88aa344420a3b6f47885e449e2607826d55710dc74acd027c01ce59a33c9d5efd412c1154f98250768cf09ea9adbc2762054e9cc1d520d03e4f192ea1b77c4d58a3c86a5f258cfb6c3869f2f8cb10c087d205afdbadc31f385d330f8ceadd78149fe67c9becf5269e4cab9ce5d288ae16de08f04d0b2264b6631f6fda54d4848ba81712c8d338975f6a220da6df572b5a89681c286dc751ebeead1e537a3a1c7bc9cb290aadbd7272f3f2e0e1338b03b741bcc552affa012295130cca924200c40c8cddba44c756c9743bacd6b68c31213cd636e3b45ee0a459658518be09f9762549092e26236ed21519854181446eae3874e6762e3740b4f2e22f118b40d5f76efc5ab2f5a34184d46f59dfef4b68731e26c2b6d678668bf5f0d7538977ba6632cf9fb08abfc40fa299b298165c49942ce7aa43b46f6c109418d5857baf9dd69786438787bf175df99c0877c9d57007192746c4138ca9e2a7fcb913522832d53d08df09f52d7258550499f001432c45a83741d0259ec4990184a39e7d78815a0d7b08d482ecd93f01b13615943931e0ee4e6fc08da023e2c9929adb0778c4a07c6eba3315bcd21d83ea8ccf3ae8f4c6d9579da39026c901bf39e213cce113f85263fa8633e63b4487386e6f7998cfbff9f2a1a978e44ab777f25f90a8d1aaab50408b5f4465d89c57e593495ebe4f847cd9021600865faa99991f524734fba26e7e3998f0739fc2bc9ceea7e11944ed9685206b584aaedfe315c721ba2f32240e1c550e2dd2a40ec7f6ad5c64dd3c222b730756df3c4fe206a2ecd93ad8787a6078029bb7ea82346c02aca931ff9db546f980c8d5198715d8e7a28161cef0d2b43209ca93fa30a370c73c1eaaff4529869c504891bf7eadfdd5d451e5b937f4d6616e9bd86fc3067f7ee0d830e6a86a61c9d49e0336ad9526281a843015010a4425dfef4893b2adea189438cceb4bc299738e78e5fd141a920894bcb5d342a38c7c989db6bd96beef0d9e0c773a10fffe744976c648034ba68339a3c914cb2bcf4fc5f4f8bcdccb66969d6fe6e3aa237a25d6209f1efbf93fdeb29743b69ebabaf8f47f00c7d620b6118a64299279cbb2f3fb6ee9a688e858d2a517d99e07d0d45a026f6f863a175bfb64a1993a8fd57a767faad62a47e09bf7d423ed75590f0901b2292dcde0b07ee787201cb1ece1930e1d175f9a218cc51acc270bf630cbe5c53a0303103122eab348d6327791a86efdc01870f1474be9d4403b8d02750c333d009e5ad79e624a20074ba6ea5861e765df45b518834a5e88af8a784bfa77a6f79f7d3c1887226e27c7e4a27d5a4c03e6c0720697afd5ad79b3652a907ad2a2c6020c3d9e87a13a780128439ae423c3b4a32ff44ff4d66a163a8816739464c58817909476bcb023da9442bb823380891c8a49129830d9f6a96df784ad3fce1473bb8ef8fc8ad993b93bd9c6248508fa6bb80ef63180ed19353bd012711e15ead6f3d34438026a71c1a9243d01de63aaee7ae4dd358ba34b82cb233c2e38b0a4bc47c4d32212f2a84ef267728e6f17572799917a3ee4dab4bbb0310211a30cf6a293f1671cd13ba7913fada7552e4bdfc5178aa5a9bd608de72a7fb9e42fc302a2f5115aa2805c8e9bf5d15bb2081fc07c7522501ff57d89534628f83771577d4bf84801fee8485dd3cec2367ac537f0b7055dafc00a26bd63941f8805ef4b58587284520780c2c49d6622f7a15c430e170aac411ac4a98b2af1d88a30db77485c48b903fa46b088f88d649126af9cbd490720ba7c380534c3e60a0817ab80a24569dbb61434a80cb17f0d99d21f4c47180fbbb9514e194b816dbcd554b71588080c21485fc08a36c3f3407420627b2855453380fc6a9934c07553e5cad32c8a1c768b2ddb90fc62f934e3b21699009315d55c1715dbeb51b560df4ccd4a03009d566df2be5f845f2cffda4e0290e1a9da120c64754fe8730985eae9081cf804fe6e7431706159a25bf249dcdaa5ecd6d417630ae42288aa8688cd72c34d173d3b020a51abbba274c56fec21cdf822523608b8c0f94bde98666e8e21b7238ae33b32611cb0d444790fb43526437c9d3b04da58d0b8ff70e7fb0d3cd3623bd5971a1e76e35afd39be4a4ea8cdee25af0423c4fcd8d066aa7515ac3d92c57a0ce9566b00b57e3e74e4906d4c6237b5e82efb73c22205a0001a6a767edf86a2e13e8d6a998584d06e9c48ded4d78dbfda63cb9d8bb127eaf010a210560d374f7cf2fbfd537909c28dd8df970e32d9e9fa5d19dac1fc01cea72bec25a29dd45a712bd3ead53f66bdf527aafe8e14adef97ec9d9400361aeb3cfd715ddfe3d8123000119851b2858d168243580d3064177f5bb24a89ee1293ceab8386b6b636d7f82ba215e37d164b5ad84483edacccef37a11fd69500fb0ebae18eaa54dafc9233639787af4f6a3820aee19bab9a288938ddd72f6f55f0b783ea7b0b3188ceab33a633ae054ad7f92fd808373755a945c67834f36af8776404e085111e676d971625be246038308f4b3a310eb18f51d00a31d99e102d5e42ce9282e77e7f9db86a18b092fac4be922b45d1d32ddaefa2a81e4c46bcd1d2122b0067b98b4e1331dcf79605d424240fc13ff3131dc81b1dcbbb9272aee73f5cd83af3d3345a1fc92aece25c54f5f84521614522cb60957e15243ddd5c95b716a26799e2f1218f3b63b764a622b45aec0c4a5f39c1e3efed860b3a83884fad44b0143458a3ec74720fd8c6577869d9a3a609d47bc10c736b94f4d632392c2346783b56d64784c35fff5e98d3c758ff5c8c863c36ab7ffdf943ebbbf6d8bcaa836e33ce05f47d98752be6a288acace3494fc1455b032ea32492586e66bd62318b21c6fa882ccdeb3beac46f8bccb4a816ce437ef80e85666d96a1fef8afe05f21be83b2adb228f0db5339fa3cbaf654fae26a72a4df133fd2eb4ae496b6dfabd5c65523eb13e3cab18dc83703ccf5afe3525712bddfb14b8ae0c19794d6f228f461f4b1de6870b0e39a5811d046135cfdedf602562ca3ebd51131f14d0fa79b742dbf97c3b4a45bbbb16e5c57b83c6e0b6e5ca21d51dd293693086b028a2c3a15ec377a4b9a92a28640e789f141f743e6b23d85421775839298922638a0ea7b93b741680ec5a8ac7ca037af69d7ff7f856d2fc02eddbeabad0a479e249cb6626098af9975feb19c377e2d8c2ff6a5b569a3f1acd9739b293bdcb19e0b13b14f38067ca2b48732129cdee5b88647ee2cdfdbe677b2ac846e4d60666ecfc0766c26317dd4d159b33a6841da6963837d10bc9ebecbf67d431072aa769303bba2517ab991386719feb2aeefa333e075424202330f339caea707fa7cfca959216342325546409bbc8a8f92397faf2e68ee3e9d3f4259807b4f775ce21dcadfafeacb7a135f23bac320c5ba7a87b5c2f97539ff724fe22f54e3c49689286ac9df6bf298230158e29a961652a7bf21ead9fd6d166703ce244d4fc76d85974c3a686a273504f104be12e14321fcad289486061040e498dcda979c9ce3800e70842ce959d4a7cb44e3f003e155aef1910dddd510a6148b46a7e94a97eeb7dd474c808b6848d32fe50cd6c74a1c807d0126c214cb6ca213014159e8c7c069b5c481968910f90a556e0a758df56c3ef609571487055aceffd4fd17032b32b27925033c369660c80f828b6d31d78d9aa826789911b28eb3400ef9aab9ab836287bd32255a6956e169660c1e7471500423471275c8905e3fc6fe28734b70e012d7c5a2e4316b7fc57a","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
