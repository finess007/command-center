<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"02fc6accae3e6598ec4f4b22481671b51fbef9390d50e8ac5a23218bb984f00eb3a27219b1f9123705fc9ce9451a67c1646fb8684888c6c8655c9fd85758381536d1a9f08d98f21b95d7c43aaf89cdbee3d7c09af7c7b6858dac4514dba04edc7d5fa4204ce5dfd1354602b0caff4e780c19476e3caf3874528076ebb27b767637a8721b98cac97c2fa2196d03a60a4cbc39fb3c78a270abc6ad4ba92cb5b6f38f00202bc522df693d3f712e14d84e287aa97ad3731e029aae855c04fea4361440b3286e142634022d40a1f7cfb1fc8aa28a83dddcbddee0b3c573fedcbb1350418d241b6b9b498e176a24579333f07fec516ba72607650b40d1c883d1f7591985d4316dc21bc511c4a03dcaa4dd67700fb9ecb26f8f40da0ef25337e8c8b8ef1243ea3e2ed7d0b517a00840740ec667b5cd1522d0717dbdc95ed808f1ad5a1783f0ed71fb4ef044e6a56f9cc27d12f8b47ec2ed57ac69b51833f4f20425e51ebc52c9001d6f689a5f918c01abb99ec5237c2290d7e8306143e40b7ec86736233de746a96f933e0f6c7c695f10b0eaccbb58bdfdf1e42e82c349c639837164a51eed2538793c3ffc09ad8d4bd7b9efd63960336fc5bc0295db38cf063cacb491f509dad27741e258bcab2ff2fbb22f349411c778b3855504ecdc8bd6f0f54e0ca67cb0a2f74c3d575e31e87d74331cda844b4bdc48c6bf9ac8d1af8a23ab9be96f8c7367ea24a99292977911416fa4f1b0de0a7be1e989714c519c6d0f9fb690e1e259a0cc5233877be38816d94971f4fa73d66277082dcd61cde8b3387c5017259d9ab7e944e1673657d952bae6715fc2a4c7dbfe4ac7f0736a376f3df697bb416f2eee8e2c0819923446d2f7cff8853a637bd59e59a5dc5282f190ee3594fe8fbcad15b673d5d5557895dacc243150d01e98b9858042b781665422f0fac33673bb6c5f32b11c7b602b9de77a6396dbe3d3ac18b9877c7110ce9b43992ab9a87c7190c95aaaee744ecef6b79f5258aa850e432729cf746daa1a3df0ec94115645cd3fbc25e32cc750d6cf4fc98e21c1a3139f0563684b4c36270eb8265324fc48b733167d6ac2ad90c0f5fb972905bf11d0f2dd3e67b2d72259dfb3ba1363fa1921e4eac303020cd8c57d13ae23570b53c9c8c7060b0925d4fc6bfa1d03b6883948e99962e6930aca18a44ba6177772dc7434111c5fceb3c2299221aa798888fc712c182933038f6a27eca4fca901da2f4222fab726dd686b8ff524fa5bada961c4884eab7a26696f8387cbf1e869ff052095e6f8887d36a4ca4393ecc94ec02a125fab583d64d2feff6092fce499ecf5fda44488de2faa78d7943baf08eb64148de4e4dba7465d0fbf867e271833569b59f95554f8913c992a72e4d9d141e245ae3f4fb59452b88007fe78ecc988880eb09ca50ede0448be366a01055f52e6016bf9d29b459c5348aff58b4a11202b0b6a5dc9fbf96330b208327f38feaf2922706c056bfeed51d176d36c0bce7e6fefb1e91115feb3024d1c4e27837fdde2bc798f618bf8bd1d336b2a1bdcd6152ad2aaaa5e0a5a39058778815c757faa121dbd15d75338137a6e869c419a7fb35b26f4cba7362e44bab3d4c7a87fa135688693320b9c1d2be1e55cfb29437fae4c1bb4bedb8fd22da3043b6b64a34f5e3487ee34b60e8c217cd8610363b091e50588e3cd989cedc860227e5c1414ddec5d964e6785e7774dd90826066c84f4ab67fe0a3718847b67cc21dba0a43334b9fabc798d8ef4c91cbd473f07a08b60919dd2644ac97baeebd384ac1b417ba3970ed6e42e9032a459247ed795e852ee60a27332581efeb74b39cb2854c004794c01a15b4b011337f25aae8a588d8c0f5dfa619e1f8d73ca84ec54ac43818885522ffce6d37ef02f479fc37fe8436d26491e1a33ce8ecec31874db629560d6e48c8556cc9bf78a5ba12dc65681bbecdaab695816531f4475da724d87b43468f1b5b0f64f487149be1b12903111ac154aafc754877bff04b0706f10af15661a4c4ef9ab2fd1b642a93868d7477a002a05144dcbd29c7d800cec03565c356bb2360d44aa869cc11ec9eac771575c0b8bdc92eec20209bca127adc8d918286fba96e63fbf2bde0909b540830a044c4fcb58570ee53d5284b942f6b503115d3068a90cadfe39642d597860043c387b5f5d26b32de07b09b0bef485d5ae52fbd799aaf7764499a55dc12f1b4195701b6d9ac23c5df7a57475eb7b05e2df3bfe08597714e43799613afdcb7f3f8032dfdea69832f57d9e16b22ac79e7246d565de975809bf2f7755c5382a68a72990760f545a794753b14ea4b28fa1210d63fba326f82817b448a80c159c4f96def5dc183b9abbea344a2c88f85cb3ee0d70e0d9db9166e05374396ffb31c05dc998c19025f7e4278b4a9dcd6a0418757efa377572f11bd660c0fd215eedbe91791a0646ecb3be5072a6369ed9a55b9c5f01128752b001a918202aae9c5702a11424013d6893926afacd7119a6852d60789811387224e971ee1c06c2f2a58a905d7c034a329035972433291fa3ac59dd3bcc013c988f4f6d81d1589001ba0e1b477ac1ea6064f15c8e4bd63e02385318a18680064a474283a642e4d9aeb3990b0740a33ef9ce24a7710cf6ef00ba5adc1b3a2870a264d9abb28319b33c9d320689645895c99e12852d7ae419645a0d61efaafe9e0fdbae4bcaebfcd6c274bf4af704c3b3bf4058ddc66e7263f1b1d44b5fda93faf6492b3a092160dee650fcf99d031f48e4aba9b35077547fde5067e69a167d0b60c4c52ff6d1d1038aa0f76d69870c06c7d2615964f2f4e4fc1487c35074a363932d22ecee8396b62000e3b79d22ec68a30092134c5909734fa5e0785cffe7d2146b160e9f0f38480d4e414799979bc98fd02f4144170da827e069d1093d06fe541db779127f44a99bb7056f35719a0d4c36936d70a079b74eef98b913f10f5025b606960b55950f16c09bcec00c3d46669b05c031e5a6df100f0d1dceca19725001945798dcceefe15df43110d13ff431eead472a4158d63206360aa763126c5e88ddc4d5a39fb4e0b7090034afe8bcca246b5da720a07e5f2ea355ab0f2181b5994bb8895d3f6327403044c567926470dda4501b97e8e7c551d00b747fe644663fb0fedac32edcd139148b6a732bb9a6b2677a67cd5efe12b9cedaf8099f6b7ebcb2fcbb7b4b9c54d7bfae36613a32a769a1122e4abd8e73d6401351a4794f1ce8837bd39660f0ed75d63ed19b85c936fb9fe0869d8ab9427dd6976438860aa27f6ef0acfe50920c7b0629f3a86fda45924a53445ccdb4cca7873a8905ec002086e4a2f17d0201735f5bcbcdf9dea591a0cb8b4cea2f266da8cf4fae32d49737a378e8bb5d3a5da85545846819668d9ceb6dea893e89b0b1447d80b6a2f5b2d7c871778cf07cd4a887a43afcf8f4b8524715c448137d2d4fa101eed70791a4dfa68bd50613c03e3156598e33004509718e9170076d902f43ec7ce9b8b475facec3eeaa445de080d0d133953c1631f0b5eaae0a58f75245a620e4cf6d1d8299a98ebeb8b9747ea994f4237b7b6a92b570a585f408ac7e752e6464c398cfb099a1e08d40330e72a80b8833a2f21ad074e74ad31f9d580841c2881dd1821e2a4829c7af22bc91e54b8bcf01905c1407fe7d3d6c1ca0b42662e2f2c61fbcf417e4ddab864c4e37f17d6a0346e1380b80cef4f3ec035d0a59c5cbe7835b8fe0647c0d61180e7802c336943b749a259826f2c69d06742934f43f24221eed30228e58fc6c4c979034c407e705e0fc6c8d6d960b8f4cc50a9797f171440a83b11a430e75cf09a40d90f08d385531e59aa9f13ec3791e22356b7b277252b7d1ad903a0a361d6cdbd7db0c679ea013c859c5e934bad324367287673cb432ed203adefdd35ebb71f4a676df65c1094c766fd36f7472ed5426bd84bccf375c710784b7c241bc47815825f6c8b0d8af5b12457868dd97f02ecb2b01f6e1f15bdf1b65c05526722f618907c5f4faff1adb65d9e105be980087589248d47d73fe83416cee5a1859b905837cf78f6c07c5aa979beb76527e83ebe8b88dddb2d97f7d1ee55d881a9c9100c9dbafe7b41897fc905602428ac44cfc9a2c6ea3492ad6f3e96f61642915d32cdcc03ef51da6295935464b456e8ee68a5f32e2aff7be4e6b4df7bc6f7a5bdd79946e0c1594ad36e32d51c1edfb7b75a5492f90ab5fb82f10c8aa047e2e297aa6cfb9ece02a25b86f621cb0a61a83b43721b2add55d87b5f707a62105d3983ed5bc54b6f538b71d535467d69459e392ef75e94122da2e2c0907792b35031ed2ce2edc40466526d8a47e249d3f608a0d581c29a270ee4e9ce745cf41381cdb0693fc8d47e86c0570056e4aecde69a52c965c0afb576ae16f035d0aa9a7510b94682762d030d3e63afb2272f67685db2a431a1f770cdf6c4a5deb19737c6f20b3f56f6454fc6a4cd43ffa389af09c68d621205c24f38e3cd4926d7a457127e04f6f0bc9ece113ec46e3042bfec4706229c10646ac13ec9d652ce42c04dd843b66bdbd2d4689f7a63946838f0561977ca7328d856489f8b5e1206764139edb1587d05367eb6e7837e983a1583050f82c5b4f7fb0814306ce12ee386c6eff2195521947640d47fb3f56c22c0748c79a53d0d31225b854d67b5ed34c26eef96ac720c41b08ab5b37745a76c72320e31f2ae0f3c925c09261c5ca13a777eb82bdd66ede41e76457f82e9f21a3ffc5b39930e0f44da26c53f074f6b415cdcfba713ed4764595a5003ab264a60b821a22bdd38e279702e4c134457e037b962ffcdb1e81382ccdfb254165cf3679b88b62610ba31e0f003d0a9671b3381aa1a50fc9bc2516a7e835392d322c273e776ae79a558b1971f7e2963766901a067001129d57932db565eaa20772bcdbc6685899a7f22cb0a2c05323d4a4e72296bf948f0b8c7bc24a4176da9d399e5247f42e1209a73fadd59857f18a030f5a80cb3abeb30a512645513ac353b1348c6c1a88b5315f1b0de807f4000874fb1b584d408622f5a54a2ee505b7ae13e1835a91363912039113f8b87d749c57b1053a5fd0fb0be8f578092997f3cdeaf6f28c846776e06d80987913d566d943c601555d22dab80c049575bb7b17685c336ea798e26b5d53c0550971669ea317dc5c5026b42505e5249e7d6ce84d4f78477f7fb4477638c00d159f51a07e97cb359215baf9dc114dcedc994c0d3dc17fc1adf9e5db4a1915c35bfc033568b12cc8db7f6d1ce2932db846cee63cde2bac7d3a13cb30562b2f166093fdbc2778c9aa9e93117f8861b8a55ba7f1c5229fe299af07653c7a60bc3bdcd697df98e7312207c75d7ff7b4d1d4982210dece68dce16e3ac1beff3647f005c2d7da8c7b9ed0edd3dc28e35da0d2be9e2bb636ef10952583b3a67c3ad7d3344b30556b8206962c974a480d0ae6b8d2beb8822235c7599d24b00b8f2ed1c71150b8853c5416a1b53d2a4654732b332c2ab607a41e7c1501b91f69610ae9a7974c94fbcb39fb21fab85d90f9edad71ba1b84d8a9a5812351751f20d9f35c32b988fb0dbbd6afbc3c673e22e2c226c3c6bb08ff7121bf9343f6a69de05b2eedc75763e65a47239ce9c04e1493587efb0b1d8b874c1aa07fada784aadb5082354f4954d200b3e1f4027714776eea0a1d674964cbc663010deb09bae0f2cecd142a4a88704ccb2184e762a2b74ae483f68a04639de77f7eee987bbb76d3b5c55f67d375a89393f906061818063b7c18951e11c1744e44676cdb28d3484e8c99847bd820bad54da6da007fe17782999377446280a70614bc8cb83e3fd0c64b02bb8aa66f6dacb8f90ce7c4315e593a615c259a3ac01905b022233b0c73cd726f3df7fc104084e092b47e1e9a1e591c6b8a2f848031a8216d56c0dc9f899ded08112bc174133bd51d4d3357ef8cfcd3dfee115c63b41ccf08229d74e64a8181c13c81ce6d29bf436a05aa755ad34fbf30af70e0931edc1bc937d7adec1cc8a84f03f0a025847c75ef70c1547dbb3534373ebbd1ba30c16da98c97acfcf55acacf82fdede8c3d0a11729a3cee9da7bfbdb40b07f9b4e578759e3a0df43fe3859606ce694b206bbf90ca80b9a44bcdaa4619a11ee2557b4b410f105d2643afdbd5d0f651e601c4ec11eddecaa321831127dfb97739011b54d4c09fd38d1fc8bc24c9229ee81aecc3c3d562b1ddde19f6467aef69a5ea82e77dc7fc59f16ef800a1f3997df9318fcea3c8ff604f357beb0602a99e2c60942d7086c39ed0fcac6a9caad69073c2f484371734bc190ff4ff7ae2d63b934353d454a7553463f8a58ec74c19221dd6229b9d5ab37f8ae92a51686c1a22dbda04e98ac66ea46bbae80a226a060108124553073c8009b952f3f185eaeb6a7e864a9a7280419e6dd5e8fbc201084072f5d9c018f5f00da827147699ae1e66c17cb83277a8eb3b349a27f037ab503d3247310acff8ccc405a0ce5a61453f7b1ada558307c28ead9024a2f812e4eeb3ff8beb3ed0fa4cba881e2d61d638b635172de1caf5a288d87c7fa96658aa6ff52b7c5b1a60afd480d6d34e7afe441e130a2f8eb1f76df05f3d23abd87da819199281fca5da0fff391f882271c9d5d65f486c1878f467bbc118fc0b69da4bc0748746fb1afbdd79a49d5eeec01229e94f84ef4ca2c27c2bec55c814bed7de5109820e0d117e282ed3aa1d86f70efe5c27b27495fd259d8126294a05b8810a73e6fa06f707d4813ccc0e2b94db21244ae624bdcac373599ca87c3d431bd1acfe65f8ef6177793d0ceb289533c96268772ce6f6147ca44fbdeaaa3e592b46b6ac9183f5fc1301fff2f1b38ceab55c48c41ba750c591a86f5c380b274d33fb2d882ccbffca06e86ad67173c5c497cd9078b18c879d2fc93e0cde76702138d37eb1045d8f737868e28f1b5451e91be87825427058226f74bd859a3eb9ce8de514b4fa7c1b84aa19dd6ef5202a30fd86e704921a8d6891ed6ff2bf9e9501bd00b5efc63cf3045c9381a8ccd91c69241ef3d303b8329ae3e4e3c4ec188e0347d2744f6c032f835cf166f97de0037f47478499a86867af376cade0731a78f2a0704a7c4541dd375a849d4b5086da926e9e53fc49c1c5f5d5aa94c6601598cf6e748a24d60282eddb2ab984ec5e5fda3efd0b7fc72f5b146eb59a53a19b0f093ce9ee26a36ddcb4191265ad98ad64263fb3366f82fe104f38caef105a44ac1e37a27482cf1660e0345448cf45a41b3b61fb15f71ab7d12d387c54dbdb65e0e877ee51ae5fbad0e3f1e076bab8511cbe47e49a6dd6ac12af9621ec7570023529b7ee9323674b8ad3e77c185dc7fc467aa57f3fbc8f600d642fbcec1809614dd099b7517b4b21f18b13f4a69c9b53ecd3c327e7c9913d38c602ccdf9f995d40229e37b854245056f3a1d14bdb898ab3a714f18794bcd3c5a5a9fe58373281d1b366a7cbdbbf343c6691c7e61316633fc9a4d819eca36c0be53d8e6e7cc8a7bfddc86569f9ee5fd2a9532ee1ededefa0774682e368768e14132415d1f1c01463660186c78363fd22c98ed072efbc97fb31a1b99a85e0d8ca89d843ae9cdaf2ff003ca4f26e37b029e8d02d0b55656e3dd8829e6bbafd55c903d869b800810d9ef48078f398420ca42bdab16102629414cdf1bab14e18e8f1d195e4ac90d7126356899fb3b8be0c5ce4a752b5fbdc6727f51bc5d3705dfc3fcf90161e6f28a9a1ef1f7c716e21b96ac89d50411dc92ea1c84d083526a9311c6f12475da4d2aa5851667db2de98ba9c7f0a72548b149efbfa440dd76086842d4fc59ff0f79a651fc376c5cfb210b2499ac753cf2df279c747d0332cdd9cac90877359f65a569073c29eab150918c14a544f48409c459b5721409d02e52cc6726b93642f3e392126666ae2b343d144c14bc3d8047f83581e675978018dbbfdb152c82c9b5ddb79c060d8777a77daf97c8781b9102fdbaea48bdb66123037ac57507ecf532090a148ba27b443d2e476271ba64bebe4b2159fe631463d3d69a346af2c704946c1b43b46632366e5e1fe5e7b2e332cee9cc7bc06102b5febfefd74f2d819459e384f5819173972ea649ec1f611842de8b86f417433a1589cc9d4f2e88d00e2c2a2e096bb1e647257ceb8352cc371f87bd673f70fc00cf745665e9c55bf75716310b6276a2aa03e423c2783c37d3800cc8162d50ec77dc09ec130fa7a45c68896ae93811346f82d77babc4b4dab93be3faa9eb2fa79f5984e5c2e1bf2d02b616acecb57f1ddbf8a757050951ec3f37f921ff9bd183d7a2f107829eaa29ddcc94517675c6596b27b041444b0d37bc6c7f8986e032dba3eb7b48d7ff6f6169e8fa4cd35f4100b2728f3463d66fa44ac070ce44c5b4617c82f911e8d16f13efa68a1ef911f80fa9b785bd75693a21fea134752eda829eca8aa1063d0fa9206cacee518b963bbe2415ce5f248d27e5ec9d8c4a0a4f74ea2f301c1e9345100746425391b01ed3601f63a5144b4f11c96463ac24d36efc14acecfc175e6fe071673f45abb5bcf06f6e5e14e3097b9865c6c5b1dbb30947d07ef08a8fc0c4f7798e7ca87db2b38dbcfbd281a031dbe7fc2d32cce7f388d00fe3f8e7c5438c90aaa9377832522f3cb6efa0c85b6206471177dbc144b2dad397c70163baa4e6ada24402c9d5273207322456439f4f533d0412a7ae25d9a2b77d8e1c24591db8ddf4c2784eb193de843234003345364cbf9e70d9c3fc2fe83d0b1fe8dbaa7ba555b6aed61ed64a6f240a685fcee3a559e89f3eb1543bb7ba335535c54041b81c592387e55c2f2d4e81655bc652ce90c648608868a79cab38cae71a10ca30abbc1efc8f2bdc33a9c85cf24b9e6bd1014be569d2518f3ade9ebb2a3d8281f4973be0b2792d6e97a341b777c95c669834b5a024fc79ef464aaba42f6ce81ef95607be33c19adb3de8003fe7791ad897a0fc023175465ea8b31988866dc3edac07a5f78ba3f4ca831aff03b9f020199f9256ae2de481d185aef34c78a8a6ce353557a24085975d1eb2b46b4cfb5bcc2b5c5dacc3af5bce5c28c38334161ff16373ac4dc8ea07094c477690d5ac9ffa3c68053f6b1b4b2f98678bf1f154738f1196aae446b80ba6fb118900dce42055aad1cf94f7bff3a22c32938b02f2ff8210eb9e6e7a7b81f11e595221567c9b1100d40759540bc7f5a015799f0cefc8741d42dc6028ba57f8dc114f67a592b802cff6414f2a8554059c136f868796996ee6be76ad6d034280243509a197b7d6465054fd7850fe137757ae6bbaaae6ab52eb62c6cc5329d786e048e013c7f6d8d99b10bbb2bbe529349c0e37ba5111da52cb53bdb024e17726b3d93690042e117508a20c7a12d50c1487aadd3b7c13cf04a8521693bfcbe36d36a28b6d8b2885ac642fc5e2fe8c65bf1121331f8ec0aac6ade258806719bddf5eb84d8706bac96e51409d2d76383b4d231024eaa47c3b4d177f98d961c77420c354f77ede310940b03cfdccc2e131c6c3dd1d97aac62935d862d94d471d32063b6345870ada8e1fd54dc5c48cdfbe2b148d6001fd268195cfe1fec1fc1cc1741127dfa89f93ce2637b4d5df1a0430dc72c39a882bdc9ff599cfeacfae5fbb72a2b28da3a3663dad9a6ed6a88502c70d3ca485ce8f845ce516e750879b4ed5109c5c2291024c8da7b7af3aa7b3761b062e0ea4bc528a82f1a95378c16bb187adb27c74cf12e20e9e15cc69d12d2542924124b0825ccc74851d9ff4d39f5841a526b10d113dd9fb5adef328abb85733c14f51d53313cee10f507058a1254d74a06552ba826ed827a4703b667aa3eda9d051327f2c44d6ba2f19614db72fdc801e95bf81f5bc8840ff5c9ead72cf06e359ff4f3f261da86d17c4b2101759f7cb53eeabc1968b00dea9327d5688df0fc87ee1d5ce30a02dc6d0074a2a210b2615c60caf3d063183802d344c6d27887850db56be47dfb77ad216200d3e30b4650712650bf20e348212d105cdec3d031c2dfacd071bf51d5bcde8a319ef547194b4773a92fa17cdcde639e9ccc5139fc1347a26d473370b67087bc3d06363056320fbc00cba5407eeb0519706581cc82121d209f5355dee693e87ace69b552c84a0b2712a93f5e1957ab576081bc226e2f8b92cf69dbc31a7abddfd837a3b08ee7a7c58d455b2a350ab0d49ed4b1b97e68a138e1ddbb6c278689bee91e795e09250509a627abe56f7becf6a8d2f44fc4963d3a5962a0bdf56f864076822a90a7d49adafa5531d441b261f3931366271361dc5c77d6b4d04710d167949b6d5d632053beba354a0ebf5fce90cd24ed76f08f875c46ba450fd23d860b7fbd3a80562476e51f24fee3153c80e2dbf22a4f14803e801bb57d650cbd90f5378906b1de22cafbea6cee7d366d14bb97fd4432684578bfb34ccc6e8bb4d2af01fbe89cc84b62c9eaecb15fe11b3cc7c3407f25ef3c1e28706ff6affd2ad262011e8618f1f2df2db6e8f7dd23a5ed9b0a35580c9fabfc13c4f5c064369d61c5fa946589282ce3a1f7a26ebb0c11958db535574184c96088a3bbab68a15683d1f62eb637a65fc2a1f8cdb7a9f3f15939bc9d72e1d6f57f90463d92e05b775b9e6f2aa10c9c4398a245447320e2a6b27b7961d28f5e3f4e2b02bd2b174edec46c45f8771a2011434dd194873b1d8bb64d049ed152a7706f90ca95f7eab747415bb0e303f0e27875d4e267e55893bf5bbdb289774e319b3c70810055e4e265fac4e03243bd5a27f86203920b61e3218f8749854cb91bf30e91a103ff7811c5063ae1945955f24913e2210823326af9ccb38ba883efc35ef279b2a51433ebc488b1714b4ab2ce7905a792ba7350392be6f21e45f17e639ded8384574f33e01ec2fceb494799e9073e40a782a6fa7e117f53d37b9b050fabf35804314b788eb05fea8f6f8c0776e9a92d34809cb9a27b1eec715ab6f4ecba9135846cb900a887bfde05aef2435cafabfe7fd437223ad5c596e6475632dced993506a1df9e0b1e4f04effb020bec18b461ba39807376f7bfe0507c6433cbb347054a269dcdf4bd6b3c1ec9d77f5401da12374e98147edff776f4e00713af0a092d5eed03c3e5e5a4321c6af2505168d5c8256e6393449f381d5214c57c1b527588c6d754275252db742dba7989a9fd64557a29956e57cdaaf72187bc9cf0b7096c68c4851eb61ec9aebd3260b9d5dc24aad5b88026e3e0c72f1093d5b8ab93dbd1d60ccb06f61bf6d0f4acac0c298a595d6986759c1bd43bacd5b5d3ba8befc09047dda87d87cab8bb0d5949e732656c33a0849552dd05b8c58e7548660be3389939e72e37df3135ff8e387c2acb28677358c535bed8753331cab9f4c9557c3f8fc94c7537624d5df590502e64c67977652d1d0768831da0e0c5b9a9e817f569a330fccc919a97aac5501d5462982e25b2760fd226021e90f8dd839311dd8ad556d163e4efc908c6738790969028e688464b256f19fbb513c9d7d0121fb85c5e30496bc36668351ec61b0b40ff2596ca016b408fcf81e3cb3d843791273f1f945bbb8fa94572e7be546d4bf5be6ed7640aa00a9979abe8916b0102c394af7c1ca0ca59cc5b9dc999cb990be6de8f1b85c05ea08fc8de4beb223274668f5024d3fc1df2b364f56ffae4131d88a1f26aa2a67fb7eaaa2230588b94d5de438a54479c2b6b806d431691ca5179e17f7d8d06e3ff532a1cac77292ab3dc7554067bdfddd1811db07b6492828d4cc9ad25cd6b5b428639b0f9d5f5a6c0bc5e9107098f68992c311eaf521e72c7ce2a6d40b16ef099379a035797804bf1ba86c93ee4af4d41f9675596caef739a96cd9d579da9be0435038da6b80f6fdbbae90f94664fbddeeee95eaf7c273d4a8d5fbdd5967f3b5a6123d2a24bfcbdec6ff80c138eac9f2621a7f81cef52f0a5ce61f05d598d45cf6a13a15a911333ba28416d0e143f4e3b8937552da660108e49dbb2157226deaa7e86e2792f48c43816eebe9d61f78d374788a0d27327dac949cfaba7ef1983fa47ea9f76203329aedc76ae9298b3a430f10b79af3fe3217f73d12fe7fc0ef862da01480d413df8e0059f6134f0358fd6983dd6d8c575bde68ccc8976a693776de5205f0182d6b630932d06ce94182239054da510db272c2431b66acff50761f618417bc850de7d5ff38c53e4fe254cf4ce2fcd8b75a6444c1992068368940dc6ead8e7a5d1a68f475c3dfde6505e8cc7768e5f65aabcf334b3ef408833f31553af314d552646145159f2ec6cbd3888b7e63b4504a1e7387701114b70e0beba7a48b80176cead3a9edd3ffe262686bb87cd0aa8676307a8a179273e3a895a3304124b9a07d2b6c5bf035ea34857cc1a83d6e52b04436605f5b52e16bd405a4f8887a282f3065dc3f9f2570eebd088ba48a1995cd48854594f8c800789c83ba432668d4da114dc43a48299aa702443a7890f3a3d8acce925136d53b3238b32c721d66702070c97a926a94c94ba1e582e046b7851c7647ba3dd9585f4c5676e714776a68fd040c405635e157ab49cea21bdefa258f32b8a7ddbc6a64d55dcd51c9c934500286e285f87659b917247f13e77e153025b0a702faa74c14a50e940467a7d81f2620b35810970956154edfa66dfd740f07cfe248023c2572f5f4bed9c595b4c356b5ea88ed7d6f3840b8dc289005be15c2abea229882dd28e47476bd35ce946ccf5b1d7b6c86f6d134928213d53c8cf1cfacb0b24ee4056bdc9c56fa159345e43f222c5eeb4443bb42c5983b45754364d03da920342070997d00937618724ba6a3d4c52e8d731177468052cf12318fd6ce64425c59c51f809ab3aa167668810ea1a0a02974fe3ecbdd7f7867d05a6d237cec7307015d7f0f4db42560b339ebc40ed2525c9c1fb13b6727682db67f4bd8fd415d05357e76d639dd8601ee1d6a009e30560e6b22e74668f2246a5ec3e1ae32b5011a655984d950d0cba1c7caff145abf180f206b7fe71107cfc0631ddbf5b643bc90f212c17059b2c07cb162761e0a5024fcfab301a29351bd5cb71b015f0dfe75824a3f36d084de85b663866ed61536e12d6bf94c9d31760df50de4f3c740bb42c4231415b16dda10877f16b8561e683e9b25b6d1ee39fd587ba6e81d10037905d617f0bd6c8932ce1796d6851fcbe3e17b9e4565b987300ef9e85205dc072d1d1ac659ce7e3782d4275c0a73287c9959319e08f4188e0d7283cd1cbd50ab5c0f8e30d017b34b099545c7000bf199a6e63323b671c8376c4a295a8855d284942a64df48f73886dd2592abff4e19b3051f523e15e5395422e791b8bb436da1c9486e64fe71133a456fb2c5c6b432d85957d6f2edfa5aa193fef9dc56b105c78954c2a89636fb4e6b490be29de5a77ee635ff73101a6dade21971e274c3e216dc7b92a1bfa586a7a1cd1fef6354f41cd760e2559743d08874c10945d52daa4cfc6bc108472ec17a8d75cf282659655ac9c4dcaf0b9eb864da5468bed4629da1176eeb42b1a4af0ec0841d1e6742ff4ab4fddd0f7c3c9809b2229130f6c7ff1a93e6ab4ad7bc0c40f602f1629b05c18a82aedea92f9a109f40d831439e84540409d2d878653f3db1266915a806723dfdb65de71a2adac3c0c348875dd5566ed9d6f06575fd0972e837bcab727892923ba8803b13453b096032e1a5a278b4323698376344165eef2a4ac773014e31242d1a2b17f4a586814e4589c0bf600b081688ea3adfd650b65fc1a060d367c6699f774b9bb4e8093a032297e59b2dcc1d40d95807ed9b46f0ade447318c4b2e9f6bdc8034dad053080f49ca37d4820e7da9fca69e2a7388c7289a155147d53590ff2b0e7a4c3ed78edbc557a300de7b44bdcb7f5e2fe11b2eee192bae826ecd0a9e46e06e09a14a86cc1343b56dc16a01b0f322937aaa7871bb2ae23be611fc0b4b170a5deaac95dfd9e46b81b5e4c82f395decfced58e8ab807aae3d9ae32d89c3f33cbdd1d765cf43a811d889f4a2bda4b411882a1ffc5daf315fc2277a35e37591cd3d470ad18b08120850c2b5650613474182f2e635c89327bb702aee6b83d0c4cda0618ec385a2702f7fd4e862c12408099c93b4a90111c73e86eb141a27c16fdeb49dd03cd4087255fc1794ab48c5a36cb6b7454764952b7844a7233b9ddcd373b089cd70257334b0c09cdc7e16a6424ec8b6dca9742f5857ad4f9ef92055e8e01031a36da43c0879f91184b4a43ba62adc184718f7c95b6df78ba64c9c4673b5e0263e2136c0140112ba24327671134b384f793ac2fb1c0f4fb8abe4ceafd52eba34d2eb54e0295a13662af8c052ea401ea8c4ef93c6f55ac338f0866ba77d83a752a9378d4389198392401b2dd3be81ff3c7528b2724c7fd08fb1c36eb57e6c55228e9b062876475686997f7c370fb8fc528b","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
