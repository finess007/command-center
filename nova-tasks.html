<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c2e8c0623e6bf3ad48b34e923948136decc7c8b4adc0afc7597a98ba6658229744566aa7577a781153a26d8015ea098c6279a194a53f8c398f622122e47acfdeba7825ff7f68d0e1f1362ae3576d3a7a291ced293594bd0acd1717e4fd9cec835e9ca4eaa8b3b076cf73fe26ef449849808d281a172ec720f6f6813e25284e5ba10986287743c7ee23847fdca5233551377fce9d085ab3ba4d4dcade8ebe4069724f4ae9abafdfdf8fb72855dc2fcaebf8f842a031f67be5026be3fe71e2c213562e7bd81ac852ca3180f13194d286c60bdceb47ee987b6015e0dd083e2d797bc325873d93258ed5eda928a70266ec3e7597b4d40b4cf021f59bd107398628b38c0b36000cd4825829568410adfc41cfdefc7f85d0747c1edb3b916f9a413db6af5fafffa71113c8bc0966c242363fc04a6d2c3887380271f04a4821750eef928b784a92e9a7ad3a73c6de5490f6fcadb623a09df64f6a3b9621e88dca07e32d16cf543f2a82c45cbbded0e30e7ca1017826dfe1503bb537a4309f1f781978060fb27c0611c88c9112cc7453169f48719089622a9af6b8540e7dc29b5976c2b25e4875b27cddb1f0e9a63c31f501a9e1f93ccb1388898c4194a0a4e781a10b29f3f2be379f2a8e0ae65b1ae93f5aa8a3a62e992d494786f85cb107ba1d9593aaa00d5f09777a2561f4a04aed8c701472a4570f02629cb0d91ff975fbd52b9485940b53728588a9176a2b0b8b40afe38ebcbb0f85480553b993f51bbe871c1e9ff27aea26c2df742d2275d19b9be145fe86f76cf8b6f8079587bcaee0466a0dacd6986e5fbd271f13708e1d7dad4b04afaf133192eee8f7e5ec88e763931f3f994eeada399d95491d687756023bb7696a051c0a98e991c1b8120c7944d506797993840b9b774015060535495499e432a4a68623aa8e58fcb108df54a58e326992642ebc4b9a138f6a2208a6753b427a6c94ff08ad8529234d01b9e9cd60cfaf96ec6fb65e59f5f44a5593bd53c937df5119dc7919075f8068fe000483221ec48edb4b157717ce4216217486e8463b94384bc25e7f0695201a20cd7c698c9264fe54da798ba27d75750658b87fe5e8db70615189b3c1ff9db62f2d4de7de3159286ebfec89950f299ee345fc2139b8dcd94da07929dbf1f63840d39a071dd1dfdc3e0e219a019bff8485d924eac52b1b00bd4a4e04349f64ea2f21ce7f1aeb9a2bd9462abd9ab8d33d7a37d2949e57278a49d4e41bddaac2aded8e3041f128ae14de5491e54b27379ab3f1b2b5b5db821e5c9dc39aecf4c9c6d9fab14ff1494caae0bb21a28873d67708806c041e94a6c3a6eb82318ed13465148355c78e4dcb8764f0757a65054bc88ee1bfbaa2daf5811f110a87c9a9d3c1e6688f7353fb857851a8624f5cf5d8afb0c9a78b6033ef7bdec3a45e6c7bd08eb86b9245bfbe46becc6873642916c254dd25270101004e9857bdae6bf978bfd7bf149fa7c9f8539212e22eedf05efde8fa75aac22723ad17d7c6b7caeddfd1210bd7af39bf2d598d0e0d7be625359d7c01dc3d959e0354ac592976bdb8e091c5a7ab94d8b2ac104e2eb2d9b0c02c833ee43547dc9930ea10fdc5ac5ac8cab289732ab821ace1bc062dc3bffec0f135dfb2d306680f215d041addd3dba1faca43222d72beffdab055de2bbccffecf5b3111cd06ee6296ec9cdd72c1810d4c7d120c932edab28e9bcab52da3bae96a0f7f8f8fa9b66a2964392ed9a3c6d9b0b01a1c1eaa0ee5116982d10b56fdb8d7c048a1ad3b9ed1819c38cd3344e1a93e6b5ae87c5be5aff6d906b587b0d239967016abc595b16905c8e1412ff8b630b018e38625affac9aad83198a435e08dcbba960b453fdbace455719b580fd472d8b9e8b5099b93af53daceba7d70029734ef9793238e42881d7912f5b792b5a36b77bc6f343424c1124615967b9b11b0baf3b83fa1f5d3494f6f6c1ec39d201a116740354d738e2f2afdf8421376736e353590e1435b3cc322f57f028e4d3fd3bb4ee31aec0d73f9ec37d8fd2ba5755897321922811abd494462f314780abb51a89f80e065a8ed105373a525d45633a815a971623b86dacd0b91e6797fc44c502a02b78aa778e4c65ace86f8839ce54ded20db314eccbe783d62af4bc207d4d65f6ccc46d2e846751e2f058cfc62302429c0246eb3fb18514d555330126670ddef862e78b545063f8afafc5b2da3026bc2112c58ed99c9ba2ebe2b8055ad5674cc8acbbabd8637440e3e74c2100c13af00e6312183cc2e8b69389c844963cf0c17bff5e3236b4cccef5234921e2f7a588010563ef73773bf39b627e598f3957dae4b6ac9f7bbb49f39aaa6a119574bc6d8b52fc6a4cf86638198e3836f8ca49cbd7e193c70d5cc8b1c161355a28eead19b667f6042938359199393b70b2f93298cff339d30a94b8c4ed5e038238932f51385a9ad54d7ba9c4a3913914e5809394fbee07fcda36570908710d4f5cd0add8cce21c9e44dc9f8eb18139241c1473f5c346aab41eaf70faa797f7cbd0c32c2efd9538e606cc57d6fd3404fc99faa7f9e93cf3fd8290d16655f2a46336093c718e9751b1445ad872b71a8d7e84c8f9c8f86d9766f9e6f235374859a0a48245999a3fb04b7d8045e26537ee3f780e024d11eb6c6d22ed30dfcf479c1d6c9d89d55f7c50cf7062cc89de864bde5d1becd954d8f5154eab9cc24b8528b98ad1ccdf32ecd7fbf9e97df84f558df5e4537bb8b84c63790758e6619664a01775688e43197ac0a4483e392e950279b4c393df240f5f165ac836fd01c99613d398c91306a606eceaf46c676ab8eaf5e4e7a698b361cce094d1dd64a8b947cf07a520252367499369f12671401f1372a63e418c84e6a3d1b3e58f59438621455366ee95c52f13db23354dc512b920a48ae583fe6278ae8ca2b0a3df7483d3d356a0d258ed8a3f3a60960e1bcaa1101008e6d02a479107ec44645100ea6d4ccd314c55113a4f6bf6af08a9041e73c37da48577d5b819fb5cb33827468b0bc015a45a236dd4f3bd8870d94206e6524f30ddb68446945852ca65b2ad05a861ff7ce03555a480ee2700e8c881bdfafcc1020c886f36f7fe76290ae7ccd0a81f4d7395f896ac650b50fe19f35ef8613e1c9ce70bd95077840a366850b9cf153ba028c5d4ac8b0ed15e8845fc344fcad9d88a5f9cbaa77ea574428baef2c8cb39ef6a2e71be561ed31d354b0a3c7aacf7ebbc736d3c2afa51c176af6d53439abd360f56bed5f86fcf50f09a85ef416998dc038375e6e1ee479f39e4c090c9b9e0cfa3a6704fcc2de565bfbc94e3fbce1281450730dfe8e79599a6bba443349b82351c8d548dfad577a39d78610679c74d6448534a5fdb058ab9625c2c0ce5e0072a5cf3b7751ea663be74b35f8d54295b0e9b6a7b1e52a0263e560e2693f6dad3ae6e592e30016c919fa5901c21e00df75dbbbdf9748f255a9ebedadb08aed9be9305c789202bacefbabf714b856a56670dd6d414f39d531ae4b4f26e857ee30e9639d28e7c7746a2aaa0d3356d1edb38ee8a182eb22300526878b8315f03d4700ec5880e33df0d0a98ac19834b080f2e738077b07729e9106942ef016555ec1ad1c81430029f7624ac7ff91dfaa3edc5002899c1ab2120b5fa9449b33baeb929523682e2cc537ff540e2e23b3d895be97ecd6602b9f547d8d5b985e868f6fe162199c34f31583101059273140068bf1075c5d12b8546cf27239e743c028c11aa57e6a9feb838a176c108859125c8654a46437db6dee1576db81d05ddc77919758f9164a4422ffbfea848f225ac0d96aed585a0d8e46f7b6afdfdbd4f50b048e6418eb16d260a2817baae39133d981b28c1962d138b524a6de4c575f5244602883a30aba28d1f10cc72ea157d4ebbc626fd3138e42a55e45203a7844e705df637884c5d3aee224844a3bff5de81ee92e24f705400d6142742f3a48c22eed92c0b953aae6b61c12b926b4c61be9b79c16ba269d7d0cf18b36ad554f3ae7336bb9770e841fa1fb661e977711272036f7a168ba750a36969742ed10993ff3c88fb401c0acb88d54e5088e4423bd3ef9d4bd844a944384a759f01b48351420c7d5947261a19f1f8439081f2c4ed22ed1cfb358a5e88da232fe82e55db6c023e99cf7ce17e9be9db9b793c35dd6121999bdc4653c74db2e6784f83bbf28b2564b9984ea23922033473f95367d4e94e88238b883835ceac08c7a79460955e25ae8f53a2f12f6835d7ff918fff6e550b365cc7aecfec8ded605e9359708848012078f753bd545267c42aa8e025f4b84ebcbb6656b216e49945e98569643a14dbf242682f201de9d7740c5d9e391b6978e8e59f8d5b1905c4272191409a00a568134b86e0b2bd53821ff48f105dbf14c9dbbfdbf238d15c093c3981eedcab11e3915f65728e2d2725542afcc9b52b9a64c057866b5024690e9911ae6c81a9eefa76a75b0d4ea3ce85ef7d51b5211fb9d4b30f9f78b2fa9d51742339cdaceb3f52110a20b1930b0aff8bc63f2f12828c686911c64831fbdcbc805dc7ce955e8eba5211d09db5f4c5e3849e7ef8445dce053947ad1efdecddaa9ed9c0ac5f6a411b8b57fc6fde93b7f5ce38789da680879ea80de4882dea7a9a57473f0b207ddbcba333ebfe611832f9490c1766423eb795e446f409859e9257d9768036d4f23656f8f2e00ec7d7622c69ba7b41952e0692748d06fad34ad85a184ed9ab768a69594ed5e4565c821b7849a9776a8df99e6ef586753f8fcc9cdab38151503b416a2e2664e5c2f4fe1ade18bfc7d2f154f160385c6ee6af9a2ef8e97e55de6a07a5e713d47504794b4a5e4ee34848eec82f49057fe11224cc5d6d10235c224ea1e5249b5957da87069180511b451405c2b0da5c6be9deed06dee903ead55a274af38aee1e23dfa64a8205b2f79fa148e643d6c73bec7c33a13a5a3cb47ca023c405c9c802357d0e63a4b7bf88b4c03f86b0818783a232a40f10d23801bdf7f17758b08bc5164a8276fcc0569346be7007b90a26e5686b032f6fdf3b5562a98b2d28a392bf22d11019b66b1286ead9c87e93058c8023ea69bbe4630c066a2723abe56cb134938bf0000166f21aeb906133490bb5712084b184b3f38fbf7ade58816c6cb8fff24b27a67c74b28d5590eff2bf79f8382d050beb9996b7f9f086c38688f99fa94d0c9d55c25143c6d5cabd6eb57a12903cc1fcc4ac6ba56c20271469685d8d7c604b103e0d307af2e77b3819f4b753b33793108018f16783897f990a9d010f4108ab8be3746f116e2cbe5c866f5960d83be39856805ed67a727cb39d6936ada2caf43b257f5bdcbe2a45f8ad81fc9f3e07f24aa7408fae6b263bfc4da6d6a5b2de009ee624d9892c4e33ca1eb8170dbd2410919ee211a2114be6e70f4835f266a6239acbedd126e4603cf1b6698a870751a897cbb31a7dae84710e3c548b71ddbea25b6e0cd171132f414a9dfae512bb17fd2b3fb534b942902625aa9eb44319811752f60da0dd3fd3601fa191d001ec6032e46ed2d9995778a3c3a09fa82f5f48f6cdbebab3af35734912ed57bed01c9d9947141b7132034141ad8a0cdad51db5bc25c0472904105895c86375fb385900184c79c3eb766582b33728c2e51c0219bdfd00b9e4c0bdcefdf5473154ae7fb126ac1246dcaf9a1b468fc2d95b71d8ca907bde5b25e0dd2164cc65e36d6691bc52b4223d699f4d3ec159e7f31ce31e9a196673d981d94c4b83b6a44345f60a1c915ac8bf533428da8fc41624a653023c53125546355a1511c274ad5204f8f0a2f9e85da63368849fdd977386799ecc818a0a7d92f2c20086c3914ae2f386654c9687b35de453124fd383c3c27c946607bd0fccb70fd6af744aca74b6b97dcb76b87fd811d131b7ba8a9c7485965092a76e9d6d61465f06fc075609d0ecadaf3603b37a39208eac8a2444809a088c88eadae866c996f67d1ec35c37dbba8503f8280c9d91cf4b2875f446519a04391e6181bf6eaca2908982f56286563ae7c2b21f6e67b5ebd1a00c819295b3f220a84e132426c90454d7a621181e03bff9c88c6d864f8772d0fe0f6a6e8b1fad94acb612062e5db3755f04b783ef9f4f1cf890cb18f894983f6803098b7ca079351fc3d1ec55ad69298154d4f03cadaccd188757c2c157477625047fe5e801ac836eb9fc92f10fa8141f1d5e7e592408cdea3ca6cbb4edcf65c128d684dad06f8becee41031ff6a409b0f8dbd496730599d80020baa56ef4716dc3d8cef414bbca4a5f7b9b3d7a7af09895c97b4aeda86dec847105a576616c25c0c9deb373385556a7c761eb795a40a51bc7e833dc9bf4f99df2ce71a3f811987ce367fea6971ceccf96ae2bc2dd166af12a40e3e97666efd6317b1285ea5fa9b05a8e59e99d012a02e84a453617ae0b033020088dcf8f229b9c957c3b52c0cdb8d042be2cc52e7438dab906ec49d0e44544768d3b0228973adda9f999f221226cad53953a265dbf44bb8302be7bf1774a50007e03ed6c5141e6567fe351833d360939b9c6753b8a33f75f63703ab0400429a3ba40c794e79f6b335c0ab76a9e2257e674689bdd3ca404b42a045420287f9ac8bad9d16f3bdb9f31126a5b727feea5f5c50e75ce563700b84010c9920376146750bd32ddc46ef01a1b657be1a0716f931855562681c57f60c39a353ffe990a6ad137b735f4f74145dc9a57bae66fee5aeec5d5c6ba4cb53e28137caadef16010e409781383072d2fd76752277700d5b7e49d88fa207222601827b27353d35ff980ddc000dbaba1528d58b185f18e9f5f2be1994a149fabea255ae008cdd7e374f62619a687a5d2c2159ef1e4178b9670928bb9323e13ba3a0dbeb9309db48297bc0fa5685e8a0e17b6bdddc0fa12387fb85f6b9433eeb3341b3e700884162e379cb25c08ed03510818876bde424d31358f60f979119bf73056ee754a2df6e3bce38a16ad8da5df0892ae8a94af01e4accd182e0b10a984acdcee3fd8c8155333562f53c7676e1f5e86df1c2a98bf5d025b22f128eea8d6ff09050e476ad6d7f211110425e7bd5ca0d6182d2c2b99363d22f06d683deb66f7fe4578966aab51aabdef276068a47abb2eb085c9effda31f0d0d9039217ccef9035558336ced36ce3d58d4248941621bcb49679a90fa28bfb7652d5fd56a4e35b914887f26e559b28e3f79f7884c70d0ce78995ffc4f169180066cfd76867cbe981c6c75d865d81e113688dc910a0c38605a3282a1e0e9fd03d392ad0208c5a54e8e95b853cb707e6123a3f6e2a533a4e8ed599347312e9095f659da366bb527928780bcd4b8da3555afa46a71b5370c46ff1ca441ddcacf8a8630da18392df685d91fa17c635f7ffd525858c632a32523c8e65fc9413a8a6ba23ef9b9d7d76892a8daa9b2ebfe6475d2db97b436cb26aaafa53aef2a187b229bee176b4e160b5ceaf0384b4134b230e0498fab4cbad466cd795657d366415832abbf33efdb36ad76f9dcb84ccb8e64984455e958dcaf163b67b84fc98fc28d1347c042675be60076c568ce26fc493e354a1ff08b40f1a6bfd42c4a5407ecfac5fcff9e9d2071c3f783bafa6def42234ef35aa8248e3e53b0bc981e4aa3d120eec33ad93a6903afdd824b01de7dae186b2483052affd019d092bb434944f174b300e4ae55b4817a4484459d9eb06bc798043a63d38d826706c8430b982b59510bdc3bf16f84f4a21b431a9986bc7473fef026993ee74f750ef6a4c6eb992e2a603003fbc1b2e6295563d2ea0585eb1076ecc8badbe00eda7ed2d6bd4648a0e3abbc8defcee2a4b1d886e2ed73e9f8e2c3f2ff10a08e41d46c9ab0844fe3c821e4a19ea15d7774454249596ffc90fdcbb314a5291cc6ca3272491981e21e3a27501d4aaa2744ffad86460a2ed607b56d7337edaf24bddc37c87418108427ca01a3c6048413828b2203a6f92b8c713d7eb3c8940e7ff269fadd545fcce4374d582b683a4f4289ca04fb9ff76b5f30b94de48509b93e699e64e5a425f6013b542e785c23018d1f8e1fe7fd193b977bfd46619c55ba7cf262b5c2b68f75e264e8fb625bcd94875817a9cca87d81c6302edf615b0426dda18751706d3b52f3ddadf8babccf6e183f58b80ef972c9f489b3513170e5c5df6bbf1e52fba44b30b9387f0e89c10c680d8ca68c0e9014136e680592c31261f221dedcbab6b75c512129fce6f1de64dab68635c81604dc32934298993a076b85e7d55c103ea3dd5bafebb81082b70a82eea54f91098c7ac1ed2b3f8e966001e06b2f778a08bf17f937ade0a6607306e4086d201f56f00d92e65f6b73cdf4c70c53a9bfdd1e283c556fc4aa6cb0840a3f836b66be34f6bc0f9442fc17de202aa76b128c1db623d80c54a029cf23564b17b224fada7ea505679763fd34146dd2acb49f11b790b32181f6c754c3e675e05e202dd08049e90406298b6e1d037bf654e0236d3bc524450a08cd75e6a0c2a1bf1c8b1a6010bff84cbfe8ec338ed023a1f5347061949eb6c1c9018dba9d5a6a3ee7ed1c4b51c2b792389cbd005f205deedeeb9d6a681d39f3c7828a55371a73864cd5e34863e07ef6fc89d7a06cd757a8d6175bc0b1805ac232b4ecb6f358b16f9f6fdf1fc22621ff5f3be2a804f0c42e2c5f972b08feaadd706c39e3e16240e1477d1b1a61da7798107f5b36f88155f5404933a5816953aeea73b6c4f5c9fad89323eefe38f36f6fbf3b7fb659271f0dbad7bc99717887ad04a7c7916ec0cfb888934ce91b03087b7b4e50d22337ab1c059fab8c105fc4e6a02e3d75d33bf32bda0efbf0c3daa282a9700b5b36d71adf83a7f9e45314c5245c67deed9138481b19e277d83f4298fed4f4b158361493a7f381da6262e4a344ba45c3be57be55e80633204df33da2a4887bdd6832a2aec18a9b21b998d1192d3e20b63c04a95f499e793804c529a0ddbb0648b637ecbdb580aa0b339ad669d2a65634c57a64b009112acc94660dffbc98ef5b2b0ed78a364ae98ec8a729325e23e8590e82547dfdee9473db80dcca3b6a0b6117786541e0a7b8a9255fd8f114859927f396a71607f247f042f885e9f0412d6acdaf563cf5a114f6f8ac6e5984e8504f8bae32e07f16f7c9e81f8cd91d9a2b1d4e26adcca78c158b2b5bc5048275c59939526b0d25b14546d8c7232768b5053b2471616d1a00d6c16f3f4052b501826535ac24eafbfbc8d5f3d11d2b07a3bf87c6a87e834fc947c1497c8383296d9e251df276193ed30f10ba30313960e821f5bacf9e7e918c5a73b30cc5c532a53ec1681d19f9550bc38bcb3070f066ec5b12ac78c33a1e7a3f5882dd467c06c338607c578eda22b9d7b57906f5bd849717e582fbcf000125ab62c53281a6bc93ee99f98f435ab0ba8517ce4293fe1cb79853e099d72b1d20bcab85eaa125637623f7e1cbf3684f11ff9280cafe0c8fddd62ef9e8e4ccec27ea37fe260a4dcaaed71491909b647b8dac0b1bf78d91fb45fb3a0e51ac1b29442929affea78fe72f884267cc0f1e97d8b7a84d115bca2e731abf5cdbec8a1ddb76ebe4ac8640651f82f52d25e6b7d0287a511787e58f6439f0b966799f8b6d1c60cbfb30bb843554c860955d162237141b4be60a8a386a850fee60f2c5a081048f9ebfe6d84d492695937d14eff18ce6cd6ab0a046f972aae1154eb24a36465ee3acedc4cef04d820fee4236c9eb9877b0e5b79d572aa1e03608462e4fb402c432b7ec5dfb3f7e69ccf91599a83c2bf900c5e993a7c7068ce737a161f603c273d5b8b5a7d3724498cb1eb10c9aefdfda8813699730a05c414f295f630bc58129041973d51fd843e1e6f0906d2e8c49d370268cc1d4a2c5feff5579ea3df3c43e0c3c01e3b177ec82b9c7df9ab29446489f2ed7b81e2728ad35cc549ec13b926a48572decce06b9887b651ebee229b1a12df6f2c3a806dba5bcd6a37eb61932bb82ab945d0f4a4f034ed3fd7c79b280ca1f09c1268ca710be0ae071538f88b2a381ae48699ed4d924536d5a7a9c63f33ccce15e7b93c40b7426fc6427265d2c3801bda1cf712e766904ab3c8e844ce828be7715e62d4c81cccff5524ffd8f06870b50d4e621f0ef672fff2e19b2fdc183404eb0cafc5122335df2b3decf4b83c59e16b89441b97842a7de02af2a6bd221082f2716c8124b1f18bd4a80073285022b91ab0f6299518add428477e8802c3845e44e80b81ff26b2f5e48fc162c8ef9471e444fa5588b854abfd34f706d3a423454c995acacbbd3b093283d638187ec2efb6467198b7f11aa5ebd51eed9b62ac770af41786d8aed37313c7b0516fb82fc0dc475b5e78b2b51e0ebd42350997b42e128356e1640c5e10d6df36689235c5c355d1481fb7a0c81cf362752c442fb15e60db1f5f1304c70bf6354ff9fc28498fbd35c78f902f925474e5c1a1e1a886905bb77047735305af1e9c82b2737a8b1b8c3042ee66c2a017e0b3d9fcc39dd3ee2429be95996e2056f59c3e39d5670eeb76cfd6740e4e07dd07bd595e418fd15ab62fc2947abf8a7330dcb053e14d7a7771f885ca041550a0096ad8f603834ac4b0c4da0581e4a85985213e19a15cdf4215dcb2490427970361268ea6a0e38935323024a92482155e8bcccab4df955f1ea648f0c4d5a621b8de61d43d076e2b3016089cd7930178a75a675d5b4f6cc8e6ff64de2129c26db9a2cc59108700f3b8e9ef091436c3458a9f53f1b6446f4a295ee60875a09297bf6cad41441c539726a5acfd73cc34a3dc5543387990e2e48e52d8a562cc38db70af81d9f7e5160434f974209e7c903c9d95c87db144decb8dc2841ff43fc60d1ad96f44f6289476ea8a919e4d73f387bb12cf69d7c5770c56cffcb153bd0d35d94776817284f42bf68ce1ec024a6be949f38b0150560ab18a0c4aae1316a9a65f073f550092448ec07e43847f36d8232e256cc46a62b569c5203161dbabfc82b538d29806df15a08fe18c654f7b1dcde5d4dce8c139c477b4c94148a65f01e6a89a313afe6d711aca865b9980d1016d1cd39cd6939cb9ceb314d661ba5c4d4a0b9e21cbffd4a5f23ad619976d1f0c518040cc92027d71c574bdbb43b0e6d2f0f55dec7d621be1f52312445b0bf2763be256c3d60c0f45a6a7457e42b8ec207356561c36ae6a86e42119c06483c4a96c5c3ded68c5a61641b8b1dc54185724bab6bc2261f47159f810695d0f00e578f29eae4770472cb8ccf979cfaac9c4b0efa61355ff62f095123f58bbc5e20fdc971caf1a2a2ba2c7fff3b6a3d3055442f666c463c69d311a8aa2e6cfada612857fb458d5d49b7e19f12aa84537ca3c72e775e335a69750d6bd574febf8e35fe13c3e9d21087434a7e966fab49838f53ef0fbd5a0d6fcfc2dbfb995c3640f409624021214a628727d95e57cf0abcab621a6d98745f5d6be4a3ff638be279941b9f966dd81a67a097e7fd03853874e22e546439e78d6055650ae38f0f7ae8d6ec516bda5c435afa1251c7ea5cb8a7c91c1f2318c85b7111f6af4d7ca2b630499c55658edc6813a793fa4077cb152ce922648e764d488a28c027120d22f3b6516d5154f217ee4c419c9d11aa2fb52ca4f00aa1668e1b3b82f19f3eb516863ac64e0e2a444eacae207271f2bc4797fc8c7ca75c58983345997641c2536f9af2297f9d2163f6fba1baf4aa872baf0878197c0d99abf05832fea4adfa9289d6b4b52c3d5027ec727659a63c863bfd1ba84a371b508a65e31bd29bd715660af217374e81c50400b4bc7b2f1cf3f4275f9b6767cabec4451d41dd2d164a530fc3cbf71a93e9fe1d6dd9c0f30c0309341bf9beb5b969a1cff7a34f13ec0a3c27ebb3efd003a9132606c9913eca48c13b5fd19de90b96d0dcdc01bfecfb3437a1dbe0bb97eedaa893557c948589cec3779d6eee31b3fa5f25150e2b018486681ae67686eff57607c92f9fbdbbaa967b57b4cd4dd9d8105ab53ece0202bc604e0c14da01dd0ed13f11f177a0e3234213056b13d7df64cdcf1f43c3dc2471c60b0e3a2b20889c2ed9d49f1f1cbfabc9b930ce793e28ada57b5335fec7e45bbf1a311171f077733a749b2b4767770093ba94e170a0e8e7a091e15e9a6157b260bcd3912f2505ab7b1a7cf8139888486f60bfab3e53a6a8308ccc3741c5b9cc21d33ab2340e450abbb151e835cae99e894c0daf6f37ac5014216b7d19271cc248ec20ccf3b1c9c4753e358828d51f42a962101797adb254bda379a5516062cdc66d0f7a4bab4e14c759c9d3d96a069c19f465db69bd8d71645d6bb4b6ff2210198e4c510afcecd9a896d1a197a32ac2190157808b645c0d2094f8ddb7512aeb6f54796b5287ef9dc9657fd931e6287a370df1e6dc7698a29435d2957311ac31d43bad11a9a876fa4161e14b8e0002062262edd0b7ebcd9acf876364ca90282cb159a2fa00da89afbdba1e7c2f6fc3a781d310787d59992b82c22c371b1322230b090d40a5490233ec5e16491fa358cfa9b6012209d8d52cd9c43c627bb5d16cddce3b3bbdd7d8dc4dcc949670075dc4fd67b8fd72be1e88775cb8b8b7a0b73fbd02d7c2099528f67c1c2ff00c2f2c0770690f342d6c875449d5515b5a69e53e22744785f90ebb2f493c3d6b290c797b804e95a851db6c10b4c7b4304f59c6baeffa6ba8ef42e875e60d4da6f66d7282bcea91ea24d49963fa316ae0273e393f9ed0f105acb2e14129b6d691028afe218aaebc7cd686b7417c32fa3ca236306ec72a15594ec55bebc6225c0c3c4e30847859a206350f4d9a3e30c2ad80ca32cfb2150e149676f7e6f27905766150f0675cc8bb6d6bf79b967ed475db3bc6cbf20ea3c3b21b62a2fa0bb51bcd525df5e19d6924e6c29987dd5627c131461168d95e0c6ec59b3f4ea63c2f340af19df8e7f70f0aa5be76f38aefb4a8941e45c7f5f1d856de0fab616d266fbcd593b9b39811b0307eee93772d699aebf5559530aab0318b26bf2eae0cb58c18573ef9893a4e2d8a842cee0b92d4c66e69591bf980bdd1b78ef7092f1719751e527806ceeb749de085fbe2a6858abf358f6d9a9fa2fe59efe359e83da029b28b3a0567eaa23fa2d8db7cfef21dc1732545a1b8a0a07d389ab0fddabf1f2a684a28675b054b0f6f6abc8f7df9a1f3f686560185e44baa3b4f36366a7b06752087738d06d5b361a709eeba8db638d36e9a7568f3aa1a74c055f103ed092281784a2740110ecdda0cd737bbc0fd78918917776ec3ca480ccfc5a752f7e3d9697c5aad7cad232d1079162798211f52b467ef22a6dade65437c3efc4840484b326aed4d130c77b262d7e4c347589f8e128c204b227b3ba1dbb3478d3ab353af05dffae2d6bdc92f49f8ecca125683056e5c58337f2d1427890452d7249774afba849751164a3a00c5afbcb58091207b258adfcd2a9761c0ad4fe1571799031dfb3c855135feba4c370838b59d76c128664b7f6e7fa539c201e66076ffee83f0ecae99fc1b8aafda4ec54f2b98c52a38ce50453f251d9ce080307a9c8bfc2ea21f484310fb0804bca48843f05b870fa5019e2e2c0502002d28004168aa8ab8bcfcf43983540e3052e5f936f9ba3105320860e41f7b45d41bf7050b16f53666c3115826e3d2758aa23e2c5c7676e2da8c153938085ea7b1881847a0ebf1fcb66f7ec2fb71ee71978f3f7dc12182c81d90d7e88fc6d61031fd795c7f7cd4e62e9afcc8ef5951e269be736a10d33c8e11ecb133a890bc603844623807f4bccb4bdcb83665f35fbe96b5c059a2375421eaa0cadb0f682462520516afd8a00ef42c6409b53e4b22f1e4635a46019418906adbf838f29248a2987b4aaf9a638bb065c1e77153bfe67bbad0fecf54c271fe20c630bc25ddcb3615788d700a968837173c692fae78e398b1299cd4390446edc1fb735415b3d93d82df2f578cbe393b6eb01053c2aa2f35e38debad0684573e1192f1b7b660f1af80d19cf1d40a529e894ac36a7794b62b4f9d9a6eb2d1295770e6f5818c76cce05dc2c3c5e22033074ab8c6a91271afd58dcae188c4e79de290ea1a5a1fae819f614baf17bf8936b52094b319dd3f688839724dda531c6b127c0514bbdb5d5334172549459b5b3ccb4e59d33c5ca1ef4e85904f68b09b1cce288fa5f54b2c54a469a402a3a010b3853946c07ad6abf5eafd3406b6bd8cc00993d5fcf221c18fb12f13ed014ffa183b683df976dafa263d098d1b9304a22bb9491ddfa9c52ed3b032a26b3f17a9ecc1bbfa20a51b4664994a88e87da3347921a5357e540ac29038e1baa078f849b693a5f2ece0b8592772de4f352dd398a9a5b7318e6c0367eeab63fd425178405017d09857a2c8193bafab2cff20ce72253e27a5d08b0e06ee13b99fc8af2afbfdf3925f027b485efaf8b88f6209a7fbf2f40bc54cd36806f14bf4f1a67","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
