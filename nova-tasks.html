<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dc304094fda1b87a2872b99899532a1752b611d4dc671027a91bd17df3688f11ed35eaeac3292ab7ee26df81bd2fc7900f9087a0b6b3b310f919b7138840889958994e003580fbc141aefb976e1f29cc9d2cc56bafb8df0bf5677eaa36e3de4f88e8ef0e32647652a647e799c1fdb04cdbef002ee3a38e82b2f2a8a1c770a8a9a860f38b93aa03fbad935738879d0ae581b9fcd8f620d67f1e72ab1ae0c0956226f2f5988d850cec22ffe162e68b07dd5ec2a541de8b07c9eab738c3159a5471e637eb79ae33d62c85ae0a2e18bc06e086424537ead9290ab01a8ab8a351a6905ba41a3337da16a0b7b105c52402bf8238f39722eae131c85a4ea5f0923a5b03df04a536794e37501e4e3dedac556c55f7cf24ff5a10955f7aa831778fa40eb41ca00f8c7d1373f99219a178becfe67ec7d55023ce9a1e9567c1ae755b9500752ec015a76abafaa83635e806696d6400d54da640e2402041390430a8e6a247c3f2900605b91798cef862a3f7fe2801cc814474898f4d2d8959eb94cbe967bf5f7a201a92dff419996772defc7f5ef07ea83f27771f0afeb5213ee1af249eaaf9dc4fad2c60204702092c6f5deae5128af334024596294bf26f978833c496f9edb45178b49a3e5bf65517d287e3e65ac1b110e533ab8ce044a8b237d28e361ae504995d12ec3964ca730ddc77b27f257e9a5a69a25c055efb52e900ad598e46e6029971c05aa4f5fe37299141f2ee886fc9c05c6012a948373026888c8338956d14263c19d2e1844415cd137f238e109319c2c8fd60933d9e672e2c3a15d0593398fcd83e9fed6cf566fa6969ea6249c147bfde232ec43d87704f73c39a59062dae345bbfc745477d5f890a4ffd5080cf3f9259dbdf86a94a994f7ce0adcaa107b0198565c7ce90e0141e059ec44e5f6d260195506c2c48105b3490b8e30f8519bf2a73cbf2f53dbf6739eb15dedbe3a8c0b0ab685bb57e49b0834fe54c5dab7863cf15d1d299a3831f4d20a3de557c8f1137d65a0928035fcc1af912f90457ce9a3651d10f4a89632234af4de0cdacb76813b19fead6ea861902d5126c7f7228a68871e371db1a23390f2c53b1a14da05084219ddd79325d69910d1bba99b200cdb50ba125a9ed6f590da76dbb10ef049d17a3718f423f82901703106581e8b3293817613ee721e2a8cd85d0069e36445024a27e13118001d2e92b6a58eb8c87234e18c7c785837ba37c4ec4ad7337691745307d3f358e877256306fcf17bbc7cdadc826f9178c23c8d0e4fb908e43f85eba264cf552780d8323492733c4ac6f44841114e6c196a3b2368ec4d26d1f5b28a147d72369fad9889606e7a04b15df248bd2ae7b500e28b3cbc063b2364219e35e822f5c5dc801238686cb0736c172f973ba6f267c22c504f47aac7585a5b1d0371b64e84e2ecb6d8ab935f1363d6b325903a66b47640252bd9aecd64bfe4d836ab9acf93b3fe257f3c51992ab852b3d0383e2837b9067c44d3ee0c42f5479396251c8f3496fc5aea1a63d48f5383b50135bc2a883d8a4b30cadffbf03857dc2b5324c4df090d8f46a53c4963393af3aca4d8bbd9c0d374c3c9fb17641459fb77a5eccf10e22eedd89da31814774aef9e3cabaf4e60d723c0eebcda07f8e7b885209667f85f70c708a891b954ef7c619c81b48e7d30ab66ea137b80953a27b74ce05e9aa8d840e716be596dbdaab4a3e7be81fe9241fa94ecb150ef86e3d810c615a0a18bad6762e37c8860f6c5278dcb63e76a0f4576190335fb75c85bc386c603b162ff9bcac5771a4383001b46053c5ff875c5757e1534266ad690d5184950465f32eb315b3c100c318e5d46198d0f2a007b6f64470da37d46ec93e02cc35bd0bc96ef155c313d6e1db12fd9d2fa2a017bd0f84f673bfb98fd27ea0a1aa0a3c2332dd94b0097c6c69836152146de8320be113bcd7a543af783f5cdcd05dc2cbfb9eff32693a57f39942abe79c16d6c08ecb08e3ab2e448f324187bbd099db98f72bab2fb9177690c8a06454134f95b2c5a0151662fc1b48e9a88c51523353f32711891cacd2576d640ff9a3da8834e9a3ed0a1eb6c557fdd1389000a21096c874c756a261eaeb5859d7cef120d40fe9c96fbfd957a4d8f5e5fec36d1ca6f070d89e42176a9e091412bc91d241fe4826487275fbe91b5401bda9fa64f840622d4b0c512804b3d7fa535a2d9701ae73e2fea29a16f8ae0de1978c6fef3afa10d960cf180d46fe6d456691215843f45ffe230d615c7a3a5bc7924777445980d8900ee2fae3ae06c9876aac33b8f6482d4c4789ef5acc4849ae35ead3f0c9fedb78bdb16d31166b78252c018aeaf7dac8e16d4c9cface02b25eb2abc5e80c4d299ce6b88f23ac798190fba5069c63ad92b7119896f0d520b3665f94e30998714982e81d2af189454172b85caae7f984e92228cca0f7798039fb3bc7950eba1748f3917081d35340096e4ed9e0c86eb19080f8df039d04f0754a1812146c20b6eb8f85d1a8c4bce02b99ac87138d79cc647128791a9bd5f157d1125b4ed5da95bbd5fda7c3fabb042564e046d5babcda1cdf7b3d0d30da935d822f648684e408a6431223f94668ba6f11b65e91a46a60e6f48b753b0892a42f1a2490a18ba3c21c62d892be07d4696b4db18dde762db10c967d0c02332d7665f29ee2c7bbd43fe476dca343bb579db5cba04f14f72ead282d372241dd4599571b4cad5c2480b95213fdf5a7dda952ce9c41810afad4584780bb516636a78a1607532014a1adeebc1f7bd6e7e85d55436c8eac626c21f4400d2d094307e3cf4c4c3b20dcc93d52dc9a541e6985d8202c98bf761a60685b08d5a1c47d4bdc3962ba1848bc14862860667542b0671e48b180a0628ffd11e9046cfda5d847b57e13037ec7fb7242aa3a0a0285259969221d5aeb08d084e9287b722096f5b3bf2493c8f88038c1e907f6530166f7fdf74b59baedc100ff9e99264540bb959bb8b44f288dec3ca77f9700303521e8e129a65a59dc0c519a577a6ee6fceecbfccfc4e91a2eb2def563e6b12bfe0dfebbcd4f467e3378f5b7c88d81ef76621eac554db9af250a398c67cc87426f03ecde1c3e66702c2c4a102b717d54000e21ac598f7888f385ee6e4472edc1e5b7599db7abf59044185ba1197ad3053d288a7ae1f79e1d00c3e3b728871960e260e979a4e4b714513ecfa9ca39d3cb04b813a3711c23f316003763683ca9092f6c484b3095d590ceca4c512a129f741cc3570bdeeef155b9efbb962df36baa91323d0606f86de9f859960eb62e949826a09cc9b3a619b3da5fbca4db8da7572eafbd42e5278f0759fd2df2701d29bfcc28c7267d937a60bb5b49fc90f36bc3d593b4fb4bd1dc58cca89f31b2b3c6e93b9961fa3d5e99ce8d240f323d1221d8cf0e38494760b511e39849d0b31885390325c2656c4784255b1e63da17f3349b37b925dec157ca157a1845dba12b13e0cd2273abb444af34327bfa7428f192d61539f5de590708d59f5153f1339d78d3021a5c72cc2d0d4d47ecc3ee5cd923e05b4ed8fa0cf6e8c9ab8750cc95c5e73d26552213d3e5053f4f7d62a8626522a8dd75ee2a7a24e3b07c84f7c1a278c540d27ff27ff5451479b358ff53e940b663ecea0eaf5a276d5ecb84ebe31bd34dff714ba66d0bab364350cdf10cf545a24ef841fbdcab82dfd27d0693c7e54724eb341c815a98cd7cc364c47efa22dbaad235510ee9422c5af521667b9ad70922afb49f5816730cae6704b83bb36afa478451559a9614cff22d6831b2d52c50c935dae1567944b0ad6d576f2560915a47fc00ac10991cb95cd9204f302eea3123a627236a973ddc68cc4b10ed2e27bec4ef1ee58c6401134a6d4189368b160a3d70f52d534acf05d25069bdee4fccb0d5d5b524e88838b331e43a1c0a901138bd435e65b69a88cb6cdc24d9e22d6463fd79b7a39fe36c045879a432c7d8ee2bb8cd0775c5bdb0d81ba7ce6d00eda0842c2dcf4539d98a050551126f76e2e6db325898f14af2b40684f56c8165eed25ed35fb460a7af2779de6f6576fdc86e060bbe95a2a877f79b7e363c908b35ab12f1bc5d0b6e30f133aada349994a83ff929dacf556ae0e4f009a5a13cf7b96001157f5392ca46325ea2237625c7380acaaaabaf4b61c0d5116f575cf8504dbaa8466335153271cee55cd8498fcb371d173e1e045033e268a4cf0b8be2212d747c35f62b24f75628087b39dd1fb7e9777d30156f85de9b32aa71dbdad023ebe2f381c8e61b1f1df8dbc61ea5df6e95caf9b9994eeabaaa8a141415bfc79b3e8c185a472fd60296bfe2eac818057998d1fb8193cf929c262ee90efc9a25eef259dad87e38c4b38770a9853eca6d745f740afed5e5da31950cffc42c6b619bd6c1f3b4048fe63c97fa917d2aee8d6687aac7b7d94bbf7b700a1a36a28377cad7cbb97184de2edbec8a7ccc9de2a0a496988266f89771085bd51c36e8efd2b6d15ceb49a6709941a8abbdae9526508127842ca3bf702a04ca6997170964a1335be54824fb82ca25523a0e33ce941c71ac247e2dd320e0df886fb60dc98637b8cd557fda400632b013fdb7ee87c44deef791a1f64ee3501b4ce41b75cbd268005762511a7c6f697dbf27a4e4bb65257737da6ad198cd8f7ee3d6b4487b5f0a0ccc4807bf3bfad04191c9132ca449aed6425d0ef7134cace85d43c45931aa621435d2e1e0b80437f3c5f4de1619c5ec1ce173559dc3c24df86d5edb439ba2dca9557cc5c8800a26dc84f935e25fe8cfc8b1591454863a5d9ff05ee1cf228f50f2daedfb4393a224b7121629edbda8831f8f66e4837ac0a3df7c6d116e88dbf5e88194f1557df1a3855c1afd76bbdc5433d58aca795e3ff18b91fd80859916df4e9280fe47c9cd5315cacf806164ce35b5fb579709726e3f1bedc16b01f9537103b45b0de8face29b761e0d12f20a1a05b5da842ee4c475585e404e93645b54ed958372f750e5163c35524f3865be17c4cde07062acb43dcac9663597463a33214c3af37ee74e9897f9f5edaa77db57fc2341f67357f789f5b3e1f6414b809dd36dd360baa976fc73740235d52283c03719f8dac6add5dedbf04aed892733e8c6652e1cd3019d04d3d13902b11e4eec11a8f3769a4c8bc5615b87e2a76addc9de09318d15e067d8c69b1d33110045185815a9e2df3cc5096b5a3b738030a81e9a902acfb6df9236c65069566079a09cddf439102ddd316c63720309db302192fde5b6572612f68e18bbb6486a656a8818985d78c0faf97922a34f0bf46e92ecb07af1deb09b02b107586561d8351a9478297260609b9ac81dc0cbe72a53810bb424617a9e212c7eebbc6e20dc5b52407605c98c2d6fa156bc3067644fac13b52c06b2e57639369a85804c18c4b5447d76f12cb868a1267ca7856b34082c133cc52ee86d5b513b93a089e04fe96b19738ee8096a0b1e39703a38b2a20f8419a83c8668947c132c4dec05dd52e40f1fc4ceeca7b9e0d6ca9f4622d8dae5dc221fcb67276fea8be180e6909a6292fd1e9d191159bf21d8047a926d9ff5ceb9c259d40c8431f1202dbdcfdd28e7fb9962cae9df419d9c94d78968f2309a10624e55df655add5a598ca4e4d63c7c50874020946f3299b413d17a2b99689d7689d4ff321c82b0194395a4dcb3334556ca0edd205473d042c681e073da10dce7fe919a9ae58e1a759acfb06083517b26c9badb3db91375b77dd7446cec54c4d185460fe682c02f9b8f93be85dbc71287492d08a9574963970b4d9048503bd7359a87d85b20cd3901186ce47aeec45b60f2142ea2718180ad04aad126851edab1018789bf66eab7974bd144fdf4263b8d17199d8da412c9678ef81b5686f9fab7838ed36f82b625becebde2ff80d4de6858ccf86c7e1a7f99187a5c2f54ff99754b849608cf11ccec4d71672d9bdb6b5a49f8fbbd108b3eaa2d3baee185283b9a45f644f1aeb24d34c8a5b570bfe8f9368946d30837e448b5f11b37837b41f85e4c4c66262a67274a833952c5861bef6bdd9cadbf6767e00845fbc371c78adacabb83c7ebc5f7f016d5de0e3206be086f261860007ba0439bb1c1458b7ef8f007237fcc6a1f533902e07eff1e662da79955946c822852e47defb94b025ac48dbed74a0f5e5b446307242195cd1ef7b11e19c3f91c5d7e6f4746bc8f1bd2f3d0f1d54a824694f5ffaaa82f30f9afaf0537acf9a72d26007683a11d8a5ca586037413b4070ba76fd60080d59c43c92b2ed25cc4e9c7ca304a55cb80da9051796a4aab64241eda29b2470e5cfef96b835ddd1d8f5ae926a78ccd04335a92510f4bb85bfb3d8daf6e8c04b5288bcda3058b692dd8937cf413f1a4cb2033f96950c5ab915fdd40203307ee39dc6a163ef0c2406f4f2179a6c62d580a45d0c31cc5a9db3beeb3cff222b98ae95f8fdac0da26e065d4153d5484130ec0d581be024de2f94e558afb783aef4cb8ee05e50452c8b571bf0303075e8f3c97bfa0092d7f7fa2055ad625891d605c67aaf4a5d57b1cca44788bd81cdad94b6b0fa5bdeb4d91eabab79536eb0869ac4e5b418b06de79a4dfbf50532d0bb472a4f1a14c15392fb863d5880351f79210794b614e003779b55a6dacd1f882f34796320f41278d02d70ca45cfd2c913d150e257c6e10a31a393af4adfb660c7312d63d8550cea10fdc1c1080362761627446d74c39c668c3853cbdc7c375a8c37cd72c80ac70502c6740738886cb7a1e79ebfeb2058a20f078398ec578d78cc32017c237034d4324a74395d0eb82b2c23c9957b689dcd7738ee3804717e25e5c36d718591db3af7457d73dc4a6bece389e635161ef9e8e4d47f36dbff414849fbd6f4e4ab25870354252bf74b9ef0bfa89e847e0f2b4f73ed301a978c185e1b16a2c1ec24cf45666b8ff086e41c2a73b744031bec38a27cbf2e23b6f78cc31458f0176e3e64c5e4ebe9d81ce7421404142d75540c367f2581c710a9d576fc65bc9f3c8568a489a641fde5f2142e21c2ead3911df7facd5cc25345463ca3558c290f375fd2a08804087cab35ddb60d28c820989a4477403536cefd67340ce8766fff8a88cb698af0fe4e6b71068c88d6f66a774d1a8fc7d70729cc6b311cf8c382de2a07f88686d664b3965a68d62903d80df5a782d7fd87a56e8d34c6bcc43f818d939209e59e4172a7cd61875faf94caff162a7fc3da069fb42cbb5cc21f2a1cdb186f63f86ffc416b1ba020c3b4f3f0abd101114452634f3e939dd0acc192fc6b057d95bcc361afbfae17a20395ea0cd6f9b3dbc4a7f043ca8dd2ce1422d289c7b76870dce2fbf0461810aa4ecb4ec9f1e054b1ffce566250608975add8c0e8056d868056e9ce107fa58552493e368bf472c4321b101b6eb756c010a1e4a952b022cdb5dddedf6cf920aae5c41c47d8f5ca35d4816d54ef08ffb9824ba8dce24053a3f176324a92aa845ac295b5259431e8adb963eacb1683906121403abb9e73654894ca34cabefa44ee68a7bc121d2e6ce101b6780909b12866de6d7ee40400f6160a774006f2375304842dba193c0412c3030681002db11b26761da938b0aaddc9e3c2f932ac210322372ef66499550a871de009f0b77585cc41ff949f34902cd8c5c9373ec4861e7fe161784de17c9eca16fcfaa21ff18ffb9771e84822a01b914397ab169054d3007521bf4edd5bf5fe1fd48913332a6290e5621e8e36a36b7c537520a178c249cba7b60d62ee1d408f124b5ad78fd25a6eb3a98ff2f5dc8cf34158bf93d478f233631d901114b054b57c9878054fbff4a84cf312a6ceb55f714ecf235ef1f4e6b4a6260696a332bd7cf0989d4569cfd288b83311f50c8c4232ea39f2a0bf212437acc66c4e3143b408ef72ed5972e5cf944cb049df1dacb3925d395499228cad0fa7a0fc6885e574dc3029bcbd1f56986a593de00cf419112f8c3f5d75264eb0d0dac0fee2176180d5c8e11ed40d1d1f866d37ea33add99197db749975de08aab803d1dda49a30567bc5efbc184df63915289a203855f01ce0726e3a9c8676c9ff7aa9c66ad12f0569d3b9c30258f2a2ca9ac652a63dd5c64920e0f38d3c8e1b000c940ae8e6973dbe41cb558ce82d8f9444fd239d7b7fe6ed0e5bff5972df0bf5faa53689ac44f2ff4367073927d0c2e072360a396845c74b480869fcf49c023f867f57b1eb18bd551d84b71e74b6c15097a9ecf806c9b9a5e66e8d19205951ba4ffb48a4d249356c305e747c637d5f30444aeb62e672a98a008bf3e76bfa03c997f3d566dfc58ff9f079471e4e3427c4b7c9e620b34aaa5265901e10f84de39224aa253c76106b8d4fa1ad3bcef4114e2fbfc7d44f61dab0d51dbdfe390ae02bf40f3ff78dffbb99f07a384e07ea09bdd84df39238153d6b8d89349ba4a8cb0ad487fe90a7bbffb1a1c8bf269b9871dd6da259aface3ea8557d9162a98d7802621d6d58b5eac1751b38092c57ef5545fc07c89a05cdc04abe0ae95ce344dd1865774d5a23827a338a65171a2db077cdbaef0e3bb36e8146f8210e5c96ba9b475ffc5cbf84d0a517867c24e4aad80ce8d72dab884df329152d4861a1cdc0f1215d43c6b53e769618e2f1f64b5f28af1472e0bc8fc1b02715a7c7fab111c507381c27635a056a6c258adca81414e4ad0c9b02001abca03c2ff72c3bbca5b2ac504c1c1dc1ae8cc8b68c50be372fe36161362e02b18f8451dd0f9bb8717250897e965465f3f8c9c4bd53825f1009a97837e912e66529c14c556b1e84b5c891d5fd189c26b4bc4a2fe7e7d4c179994006943dd892ad54b9a4a930f87fb2145d9eef596906e0806be9be04104738fc144f6e69539d41be79992dbdbff13748b06e2b3a80ad891ea58045b4d2a7b4d62d77ff128eb9ec39b3eb9e00f8ee8de92b438e0b1e50c92e286dfe85825049235e708329a8b92ef3856519fdf65f029bfc1c9fc621fc490eefeb8ab7aa1a3142f23395b73d00e1c51dd4de84e2835b7030741c02296fe7443668018252688e4e7811383b2f3c75d4df2a52cae788d1b62e9ff70f18745ee6a691df1d5ae61402f685f22b6ba9efb67b2c99fbfaacec9b06fe1609f2558109d4dbc6193a409e188cf5ca270a00be9e76b84f86ffa42356bd097958e4cc027234a9050dfaedea624bf9d2c924cf7b54506f6fc1192718d3eb52941bb8e4cd6dcb6268b3c6fa1e7132e013b6b7ff61b65792f8cc4a291e797d32dfb28ccacc635dcc3c9644ca3bbc04f16f428aa2410efbe7f74807f20379b8d5b69b9a6a10457c3eebd5661cff5a0a53ca4311dc7cabf9220e13f635b38fd26fad3bb9a083fa4e145197f0d96a12743c9072cb7b7aea5274cb4a0c33823f7335e0d394bd5e1f86f71bffc9f77567535d042b7243ea97e47eb1d59b8b2508810a5345ed762edff2b36b397bd6e264a56f9ff410ad98fba86207987ae69ed81c6bb442a5a789c0211dc16370c9df447b7968b24f49e218d3b16a5dbb1cba5b388153f498b2bc136d1030adc40eae84f074024656a469f62135c358be417fca74207ab94404be4c8b0e05b02efe9a24bd40abab0d92ebb2557612d2ec1de26fa87a70664f1ad611335b5ea5412697717135c2079841c092c7047d4a150c239e1b71b13cee98d5cbc0d2b106e38393a56c59e794f60a1e63d87c29f559b808bee1e85a758e9a46b077f728c1cc3d8949eae9bc2b204ca2fd26dca3dfd2aa86776282f654e69b0aa33289a7959b4ae2ae35eeceffa0abea2a23e41b1eb07ad750695229d93b57a8b7776a4a64fd0f05ec2cf2e1e5f01ff3f1706890cb99d0f267894fb47bfb327cb23d65b3d6b9353340277935eade932b43c73319b47b98392a83fba361223cb98152d59085f8d143fdeac7cf619bb32f0287f1ed3b5ec01d340d99ba383260e29973073d2830c369d81c85d1c1d46dbc9c4ca3d8009fefd9484343e33ebbf964ad98482d38f5204402fc70b5196929a2d3fb1230ac998ad15b51badd0966878f451683f081320f917c82a3f5013f136ad9652addc17d7d82217a8314579819f74070cc24039c58e11f7ad0956e66a3fdce4c98dfbf4c735c33d0b9bf402ca4738836866f87b9a36cfa1a36579ea5b5b17de3d58a213bf62c319f1d2880cdca80c8a2a09343031d315493393ab3d30837d8013e24ed84d1d34fd314db002c603c3e5b3915cf1f5b6c56ddfefbd42aa11fdbcf781641d7c1bdb8133601c9ca31b44bce11473182dd8f900847aaf321b10cea803816ad8fa2b2ea6c6a88a4f0fc3fa33beaa35791dff5f7670d512ae44a3d6094519340aa027cb560dcc85e8605d5a85a6288f4693d59a67f513e806120d0421f7aaf8a3722c7bf59347dfaf9a761d6fe1ca1b8b107e37323ccb2a491421ab075eeb695eaab69fe984f86926e6e28658aa218b037d0f666405a905a4d087c9730f4bcc4767f4c593d048d762f0a410326f19669526d9a5a6711e225554d59e0510349a82254edcc5e3465dc0ed647e70f3950ce4ecba9a343aa7751ba2aaa52f79ec1311c41cbf49b33d8d76720f87973a83c5dcd4ad6d382be5d00295652317e6dfba2f28176f9836e5aabd1ab6d04346fe520dd32ee12b8e30d9b74cb159d09d5eb82b24555ca5ade6bb620e80d22b406a793ce3dff72b3cb1c828be4d9cba7c0209b92a43a8b6583cfebde955840938fafc235e5c4347ea898888d70d054df85b68112ae7d0c6ef0981cb12f450a011291663fe0a73251c056cba717fe9f046d27f87ff59dead04239b9e759e68c3e171acb0bda843ce719fa73c8e14d0c0919115a3f553bf5e9ac352096bdda71c9d0e4f8a4eb73ed34ebdfdf1221eef6f913783764ded9684bb4ceb527af6d67752cb5feb964b526ea6b8f3fe48e698987f1bfa9245aee65b6e95f3273ce32c8740e99a603d84af9ee01b666a2074aabd35da7e069b025d0bff4f59dcdc3460cbb6e7e67e1729d1b6b93214da4d9ac47db101b55f4c3018cdcb5ad56fa491d4da0670d9d62c1d9c7d422bc13ce081278755fe334aa257216193398ccfe05d1dddde29b9abe86fd2f27bbd08556edba2811024a8500e3e7cbe8569020592899fb58e107ff2ae4c6b0f1dbf8c21e09b7238c090f99adb9b98b9ca2396b8c11824db25c5816364329587086e151abdec30139ddd5f664d8d8a746b9f004e5127f1382ab704174de9d47f94c9b8b1cfc4032e60cb3615ef44e1711c064586ec2fa40834a25c6f59a2ce8e726b7fd07533dc868984301a502bb5b146abaa0f4199883cb878494888c83f13360a8ce0490007e0edf0db602a528240d9d77656318e3ffd366d169ef5b77b556f9ea23a98ba815c677b484e0a4a2821813639980d7528615beea4d5d3505aff0c0ce70cf832dd001d92d2a4c62524c13ddde3ef14b3b46ad3cf2d9fe7eab68d6cd4f66b04ec3e5e048bdf73cbbf456bb846d5298f69e6ca2ef12f8a6d181d1b65dec07a112c35d2d20f7e5908c89cbe2af3afba7505b42474ba22727171ffb4e341597923e6ee4de7f84e843e128e2e8d6fc4b1c07beda0df07360208664cf16183b485a99180b4326c3b3fb2f0be4c28b815293558790c4f71358f1cbb56e770b973f375fe8763c328fb97189dba62c0c2091b025d00c3a207cf02832e1e18f4b8cbb3a32464b8b5943d97ca215cd0e5cefb0aa2491ea8957dbf692d552f173158f8d0196e1235980372fdbb16783fdffc6c11bb9183b7bf593a653b55c25ffb70c802533c708871ab2d13cc218a8de4558d906074bfcb71056b509a1767623648de53c78778ccc676eae7b98c3ba8e0cdf103c9a117f8612341ff125b125b6218287faaaa7e651f47efc021d274469e7d8d9c6b717909eb5e05e4b3ced36efcaa61b9d332d1fe7504f067498d7fc247b499ff6d83501c198b13ee1940193fb878614152f3599e0bed5650e2c850c40420fbacef3c26d0a418faade94e0d93fd482c6b31cfd22e647b38b8c2a7e5277d41c2fed9905c96550861db98ad98af4da382524e8055eb13f72803d5be01c5bdd8443c95d36bdfaee60b95699ff87088adbe55ba14d7ee9d7fe4eefa8b9cf63df110f3f62cbb4f173ff0aeea457bc59d21c22eb9e57b290e3b22fb95149857d04e2c93145681a0181353a979fd8f828034e4dfafe98b09d4a6b8a80b117725cdc5a61ec0dc1949b849f9c20e10f500c8d2bbaa5af4228152932d3be869b1265f431e0e1ad04b3df37d0a8db8b45944aa5281c76926ee38193d3bc0303a924e4e9e43c2f12bfa9c2f4008af5b7992063e8462f3dcf7f9f62ab08d43ea6f0493c623e902f53e2480d6eb7dafc2f3f8c558b8475544351277883877267102db327b7f0979d2857dd989f9aa0b09853707b40da2318f2c9fa50ceb9dbe90a1058de1e6ea438ec8b7ec0d5df8c43ff2ede6b9ed5aa98c86ee78959a75512f67115c3755b59bfbd9d3757b748f1341674afc1780b20fa837ca11fb71d686b6549d63639945f17ee29ededff97e86085de1dc4c1d6c23867b1d92455ef407122e8d40ae46535ccacb6274cd0f491f3ebf4903e9f4803fd99f271905121151159676c431be095515adcd0bb891ebffd73424f67c04e3b4548280e9cbf234972cf5b8ba3a9b253354a81aeef1f07665fa1c705bd37df2e798fed2cabbf4415bcc6d03f1edb1b364a46e522a4fcaf8c254b9d46238360f92009d6d83deb803741ab33b33de7f13969a573c9e7e3030447a7c3c116495c8248b8a55a85e7106ab09942f1b0caef7363cec2228b3255c5dcb42ec20f3c4a6c9ee493f6fe9449586dea22e870c1e96539e4eb0b50b6a7049ac1c11fa63d69ad214e34035eed0bbc9ae54463d76ecf0f4ac8733232b963262ef3084d0f2984f943be2f1a26330ce259b91a2dd6cb9f3ed0ce63da9f9d9c6ba5cb713f4a6c6bcae536101ac34e03acb5bd9015f2c2138fb363f31fb6f091e4552384c790a74ac1e3587fe4588dd48fdea11cc0a39d3c52120eba0483e7119bd40b2c0d9665058356cd22cb92c18f9738ca6df43644c45be82776b9233cd8b2d8ced275622525feacfd9fac050f0efb3f03b7b90a9c5b6552996e17de74a5237ac30387bf6c13b42d7382f3036b2ccd7f00607780daee39469afe7113479ed3b7da8418caba79111352ccfbda3a487bdc82054fe905cf64eb50fa49e923fbfacc4ceafd285dce65b013bc0ca1cf6446e120704677beebbe4c8137a281ff80d3c565e2b3dd819e0db7191208a57c9e22696163ad4005079078ca09b75806480083d31625f6465d0f0b5302342a281bb1b8082a1dac9ddf5e679d1e8d3d11206e4d864582321a2a832628f23cca2c8443122b2c71af37c3313cd23bf539e88c441d1504b5ba6d1571360ca5241660a92d0ab91893e726a3f171666a2a661fdf74e64fdb6a0623b21c2274d5ada27315d8feb9ef315ead28b0b828bdff5decf6aad45dd159f0522056bb4888913ec92eaddbe21c0fb547cecc5a933671f3ce4e12bd9aa03e02c29e1070fd3ddf33b63118dc90607c8e101c724d12b4c6ce925933a10b2b6cb61417a86f400a3282b059d2a2792c27085e28e376348c7d1ffd3e1211659268d75debc0f9a0af5b49416419fba3ba7d7ba5783a393eb57dc4ef20b6a600f71227cb3576cba02f27fa463cf48c4c8e5a8b07204ddf273f950c671d347a969836e794e9c63f385c7e700dc04b551939395164518a46c64e08e038d7382b4eba2d78582dca31678b88c7d01ee4f4e188407271d2979cc97ce2c2d22dec149b5c692cd649f9c915523310a6432b1764eec13d2b6e5c11aa0161d5bb03d596a67eaa6fbf858b7ac6b31f1fa753b6c511967ee527bc49c40684c8dacf35d908ebf431bbedb3e33f3f09d9f0f20a33ec2672ad8ab501d8cfc8741442df43b9cdbf7384dbb28bac2745a838d865c535822b9e9b1c650514b5c1c2b7335633912945a5f59decb2674b1365751c5d87988434f2b8592d667b6e0f2e28da9de367c9db2c2bb4d18d111f793959ed5a6183241f0efb09daa199dd45fff6318ee80f1477cdbfcca1381ac4bbdc1b57be559ba17c65fe5e701666eec77123c2dd33d95b670f786d07d3286ca0b2c1553db5f1cdd9f1c2b584ae1711efa19ca6f7ab92c9e509e4d50de05897bd4592b0e67055e9257013419d63e27e54bb05cfbdab186a6f76fe36484795c992e9129c01ffb80bf012c33700c9fe1394812739c3cfa708a7d07cf4d21b6c747d2701ca648d3dd5f6ab1bb4570bd0591b9a9e074d349fd8e358f11297a93a01fc087f92de23d8cb463f0561bc04a508f5bb200014d7016277b0150e680562a106881a0c2ca5154fb02c399486ff5e7ec34b2cec144483e37fdcd163548cecddc682b2aff85de56fc150efb486b8431f5e23118ccd3273fc060dc9dfc3bd5f0a7a08c99","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
