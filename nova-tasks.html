<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"dbce938579523b76208b7ea94090092a477e4d9f3021ea0739f75045ec3dddc16067b4c9164d6b7b9eced6a0232e89add34c40376d403ac6e3217aedffdb0a9bebed95c167a7483981ec62359b55a41a649ee980c0f24d83ea019728c7ecd72f506ff1fd660150e62aa541867a71769d9e7576de4e99fecfd1c391b234aaddb1cdc51930a9cd6663b392a46b925d797551d5ba38512b6593d0745b6c0262e86e3b5159930825d149f5a28481d54426cbbc7ebb28afd923ca26ec0ac312440c02e498e4cb7877b22891fb8394b4a74fd9b45561ccdc9c12f3268c5bd9db8a637f1a682914e8e99698f38832b4ce41708912e1f4ce5645767ad28025bd1dd35e00d574e3e6f67feec0c04f9f2c8f1578ee0ace49de72baacc094184b0c0b37919de2c838cca931c47d861f0235a8c206d3d21f80274b70d02ea6a82c60346b4dffe576f8915e9b61af1d3a60ab8da18ec9bd9e54618372bf48781bfdee7133195b1c5b49f42dc9eff545b0ce8b49ef716a36ecc09b5855399969f17f052fd51f1bf77ff75216678c6baa7e21f35849767fa0aa394e22159079f74f0396f5073d149b0da95de89954cd5608e8ee63a6ce88a4e9f72d6c287d85a0b37e5898dc3302ef0498a4195e0cce7afb24af2f81e2fb7c95ae2b5842a7c05fc2d02821f7078293a4801eb1606a5399c3b95dac0d412347e5b5e65f9e296613250fdb09b8145641445636a37f9540d5f9b854ecce5690c8f934b2d2fda062b9b25a7e3d5c3e44b91e29e73c7aa7ff4b5cf2d359c8f1a956d99281cfdfb6d2638c9a8c50bc89f89a4035517a004e318e14a8ad19b272c376accdaef07cbcdd13ab563a58b3e8d1c1c8dd05d5f0634c09afcabd4bd2e118cacc569bc4fb02b60a24e2e3f2bd3a6b533fd92cee481e6ea3e29f2e4025caf4cdfd189e0435bae91f5be15ecc430f6d6d32e9a5ddf6852afbd32dd5c982985f562abdc305142e41cb43c2af71368b70f1b1c0b147089230798cc2a9870b4b80163df8124c1d90fcd0bd71844fe04da951ba957231d1d79e3079b2eed44b8119339ffa11a140b3f9876f7d4589bac1ae96d0c6edb89d587ea4fbee50095a2a5a7c2a901e18863cb6c94f75ee5f1d54275cdf08a4d81de2774ebf0867888949a592446699cbc7498852af06ce989a308d0f54f89b307fe34865b64a3275ffa1c37a72f00f93e20b292c410ab745a900401ac61abe7278c6eead0f5fb624d536d2aa90886cbd984ac277b108e5f4c55cbfa47e537a189fd63003a4c600296b739df0bd4eafd53182170c39c25b41b6464cd94640a91ae2256ca09ee41034da1630b2dad46ee47409085a06ec72d0ee1361c856810469d43fc0d943b6be6b816f02905e7bb77cc8909a13bad95ca41cdc4a7c75683565d47c6e09b4c9f9aabab8b487fb4af4b21160cb02be19c61dfe800d6abb7214c4f1b2a65520a2dbfb5fc445822dc1df36474bfbf6b8c9f810ad9a4eb80e8b2c73f2bbfd6cc3a1f54314363607ae42a22236db12c48d272dc6bef0e16921d6aeb093755a3a8c2ef67034ca581ab9138eeb923d2fd6e811bf633f2071994a4eb45f884d8ab53b6ec385e1940fb8efc8af904c1982635c7910a84574053f4ae38d2d72f254b6e1868c08a78bb44802678ac5c730ea23961f37f9e869b5725999cc6d8e1b429fb752aeed1c3e2d663e4cddba6bbb69b88994aa9c6c552f3f14f2dbf0809be4d54d01dec17bf3b1cdfcd13f2ea9a321172d55206b26dca32a48269cf25d4b257fd31132a1b008a69213aca8368df7fe50f7ae139a85eab606913d9fd96388a22f282770882d5729dfee0003ec070664e14a34580b2b5da8ace83fa24071b3485c3d3ce4feb299a1f0eec777f908672255d44a25e6bfbe41fa6ab536b31dabb3541be74cc236d0d99d584ed6e9492b0a1e808c317ab7bd3c8915b3d59f8bf27f4b0ab7f3b5670afea8d3f83949147dea48e247939de441d8254137a0ae38568071ac9a9201b11cd65d7d7ccfcd1aa3c7afc5135bb434150950466960ea88a661ade41b70712bf06fda59fae907d367e7b7d662e00f937e067d3cb8dfb9fede1e984ba7c0de266c0bdf4631d6d99f864c39458060da5d28e073a5a469fe1ba80bf2c1c6607f2b022c48c7c122dfbe007fe2a6891fb80d8ef8c833c134d593c0b882a2bf1dc26a8934c46e3440463a59347baceb922d83e60b2e84d4ab4fc26ecc9cb558ee858cc70b57f660252de14abe9fccf1a014aded9511ce21197fd6000050659899064a80211ccea50cd299ada9872164c9bcc668d3d6e72c5024c18a4feb304f6044567eba0555f93bd49cb6482a0ea3990662ea00108e2cb3d40756e2e417f735a301d581521eaf2864a5191111545ea4fa907f498716b422adedfb026cc265ba16e5afd0e2d019964b50feb5314b59a840dca6b14a0bef8880553af5457ffe82f7f1ba45eaf345d0d579a03389058d0e445981c403899ce47d78c27f00a46f498b326f3f1678c205c7a4bc54d7bb79973ff5a1ecc4f363470ff400d583760ad64c048de8f7f79113d0fb30b68df4bcfef1cb16716d455c738b4113a690cd07153193c484deeb7f24535ffe41005f9b64c7733c758d1fbfde50ea9ce45f3dbdf267f698a91722c21e1aa3891ae8231a3576e96e69067c5b0bc3199bcdc4144404396991eec0be3882be17ebf8b4a6afe0f814ad63fa1a6d7b77efa49764a71a31cf5fd62af5520a324bb18739abb76a68cdc2099c73563b374a754882caf7687e459d1b1601407a6d586832c984c0db0864fdc391392e7c49cfe4cbde461e5bf34c9dd1a37664daa996cc2ffd6b8c9623b5a0efb814722505764033b00bdaedec09524455cca22c2139d792e2e5f6bd2f1094c88ad52562be77d9dec3b3bc6958e27b7ba5390f459dabbace4979cbd5a98debd8829e76b07f6e5d67857b08eacf4f02742610d234350aece2b0797b491afe65b4d7d65801bba4065c556bc88054b010b253c5ebae712fe399632263887aaf2ea7b6ee630a5cee1cd093aa8cbe24a574f95e2bfe9e97383d1515d58e56ca7ed75f1e58f0a1df692ae402857bdbcdce8e9352f34452db9239f16d68e05ef260e487a2c998ba7841016555164014edba24a0753e33d582b62e413d08e41ced8647c7064c87f1dc23fead976321bf2c3563c5bfb0ffd8a90e7623a49428165eff1f161a51ce32ce5b9dd0032b9ba8b74df20f8f8bd19be770fcbc6f4d0ef4a1bbe45915e4064c26b4f6e8c1b6a179981d6d79f782b98937591a3902ce0964dfd50a08d97a055d660b064ddb18cdba38c2367dd6b6f3979f6db55eef43c619da051f92e6b12f574faf53f39960f35960414bfc76a96b883fa1a321a3f7f8dac18385a365d058bcd6bcf29d8ec00199c53a5a4131b597e9493f0579a74a5d17532237a8fbfaf7302816a36ac42cdf0650fb216547cdc278d0c51d9f9daab465543551f36bdfddec17bd5d54af68e8e1193378bbf39cbf347cc16f67c322d63dd55d1b9b2dca4d77d02c48253414f769cef46c176539e8125b99addab6b8d82e7ccb3f83474d8c56597c5382e0cac8cf80d1204a6302bf0dd718b8073161715122808d1f120ad9656ff6b09b9776dae3c582954092ac62093e494188d56f6b8d033cc3431b1b83966940fad9a6a5dcaa122807a4dbda2e3e8e731b73789a8959bf69affbb8a40c6b6c2cea6a1d9bd3f936fa46056b31b6b05771b75009b2421d27b5fe7552c42f9804aac2a959074ac954d2b08f621aa73726db3674c9b834e507abec85416d88ed992feb3f5da73da907d8b977777fd5b46bc4f92e2d25faab448a2700dc6ba580459051b6325c2e0383de729072af89818f35ea674ba0442c0acc97146b3ced814052e02bbbaa0f756c7b5c4962b2dcb5bf00a6fdc32ab7202a78b5f3ecff70821df779f82fc175a4525b4aad9b9a90eeb18cfe86d60968d0356783d11812ad210c95c8ad43e6562244e1d7e34c33d115ff107446380a1eb5d0f69fc0094cad5e6a91dd316b41dd163d3efb6df89faaaf77db42e3755465368221f17424fe3809584db5d819900505cac1ef937e4595514a4bf5013bd49dba38da2d02e819606512b899b203a3a65a9f1d24362b77f9572343bba7548ae6f3c45d248f0d0649e4371429b19556708b25b2341763ea7c48eda519ebdec6c02d2ac7f2e45fe2ea2ea3fdef2fdfa39551fe369ea3661837cfce968b677d0e59d8cdab296ab9f05a881f839c0d0098f87a35b27d51a23233daec707599f91543e9a768e6c30579b49f51d345d9f3bd373b4a8f8b3508ac27bffd0f771322ba57b43edd4123e02113fff3954fb1ef4d5910bf05312a766fb3e3c8eb9ffab5da8003bad1f73aabdbbffbcce497f2255703842040bc375c7bbbd768b629cac7408db9df14affef8fb68d7bff54a7a590ef0fa70f9a0998971dbf7f6dc9bf8a52a985d7d9f8a5c3a6b84eecbfc69ab1afe866f7d0143fc9b17e7181650b915462fbccafc2aa4ca9fa8f568730dc743f13f9fdb28300de0413c55c0c430076948628c93efdbf9ab13217589660d2ab1472635e2d112d5461d62efc0e5e860e3e7012a5c806ea6ef8400c4b79753d60350b83d9d5dd932e3edcae1dfba25e36ecf147d923170e54b310f3567316ba71a600b0b11e5ca7b349f2452e4e029f4d25ba763c6b7c68dd9f5394419bf5d4351eb2399600eaf5c5978527d837d7fbe20a3ab0bd1bd20605f2e61ba3bf336280946915ef2192e8d779adc741ea3c8b9e91b80b8a0dc1b6a76793ec719f82e60f30d880082bd9c9c9f2b515033e8f90a9fc4f0595903e466ca3a3cae3dc22c6b9b571a2977abe7f51e61a03ae7e0da85c2093c75cc08c3f92b75712204cc0d34d5b6dbf17f0fbfc5b799b2f4cfa1205f5042399d74a003c1481101381118cc31d4c2be73910bd8acb9a337a48762221201b194d9d8f0feb7463034e257d8f063d649bab2fe9df04f4a861b1333502f894dbf1ef7c34163f0d7037703f466516871eee25db13449da91f7ec43de7651684b3e0ef1169a14f9fed6e077960eec6fc39a6edbcb835b22b65abcc56c00c43f00533bbca5bcc712342accbed7802f7bbfcf4739d2beae967624a48bbd6cfde8796ba6d9d47c242b72037d8fafddb381c2f80671fbdac1f27d9b5a6a0eb081b0b9e7b69c72168a89624a1222820a824945972d90168296af233889674c3478c771aad97924360d9c6c98dd0e8938bc44aca1a6043e77b8548f17f887849f3fbca37481c0234eaa09c1b801f548f806b74bd353807a03b7ca20475df08ae0dd48307aae76fe0b37e44b9f1fc6f1b8b8fc745639a7efe76081be7e06a8aa4b0263102a96f3fb94f7cda591855f6576799b5aca0e84686cde194fc0567e289d00187b10a7851bf97f608e0c16a37e98535609deb24e99dce209ec4fdde426321bbbd6cdce652ad6a9930af52533f52b2bd7078c6e0608e6ebcc945b3b699e631a1eae3ffb41dea3d6017c095adc2700dfb1e68d58d21abd72b04f3c847a4a92cc8cdff61247bee0d1d9bc364ee0a74495cc2611974ac567a87bd5b8527d2105ab5f76add5cda8d45147c9c29299ceddcff13d2e67b50a10444f2f9d460003d1c45337ed9eb07f012409119c4474911210785c9fe7aa47707767568c368ed761592ece3677ad8d691d8f5b6db9bdf99525545492bde4e87c3e14bd2707e0a5cf9c65e7353b3d95cd185f077d3f75354768e822cbade6d84cc3c149f87a76086ae0588a3b1b8df5b2dd1f273d5f90bdff1b2c904c25fd8732c7c880917a53f5182d9b1b1446368e4fbec8d9dc0defe5413da539d6cadbeb69b83c29922606624b229a08bcb3b10476767d25db5aede1f1938fdc262606665d10d42798bad78ad2e1e6ffe760bf8a63d0fd73c3934b38be706d6f448783134ffc45d82a4a55033dcf10f2a22f264caf042b72868932cb2b6c269165c942e96ee940e219d13d14cb557b1f1bf87092d4e9346ce9d1e79ee35d60926df89cd80ecfee3f065a23b3dce98c9fd39fdc86b025096b2a3025efc615aac7af0a662919b423e9228428e8c63b7fd2240013c0d5b89a71df32be091f3773821019de3aab3ca789a06bacb40df0c3351faced8430179b6b811dfa0b66d10f5bc35b3be85231a1aaedaf600f19eba07d47169e23ca42140e35f40c435f88a3ec7c8924f1de06d2288a0d4fa5347883277ad1a37df4d241c223c0de0a97800f1c3f7d0322a959f2dd7dc73471faba7bc029f686dbc753c5547ce6b2637b60a0d7e00518a65862405a185e1a68e391d4fb5b07ff83dbbf3803ddc5e2bb479d2aedf5fb2e62b48ea482ebd2aca7079d8824c325c1b0b59e5eb9fe380ca3eb6e2fbae37ba852a2a091ed1970658be74b9a46d5231068fafdde12717e70bf17bd8b0c2e503889424c9afb81bb119ddfe444eeffa468c813eb46acacd9de4e2243681a689b460ffc91e8c3d34059f7cb9fc05df320794c83e79abf923dea5509066b33eafbb624c8b5846f9b5f4250544b38860aa5a3f6577d1ed511b9bdccee2bc980d87ef8131f4e3ad24af24f7c8202998d7741d9576dc5f427b452ff5e901944cb402ce33ad46829538e61f353cd34a40cb1d5e1a7197070cefee98b9badca002d8a49eb89a394fdd17832c491848ce8fe95cd8f715fff930ea7e36274b7b0228a5a58135dff95d76f3ecc3792e7e52d3dd5cf861740fae7631007d554b339e6fc2605970626d5b2014540613bdb9c4130e72140232b3b9465780b5712bf486ba382b13517243b337a780d19a0e2dec41d58d3452e0879d8d6fdaa479b84114f882d4ef748b48d0c5917b1bbb740370a7044305e4d1d335f5ddda48b8a910655fb9ac393729c073d725b97e648a3e46671e64960797b08202a6c09b1a700e35e34ed5122e9e338b9b98fb78b81f9b75a19eaec018d94afc710cce64261bc92e48a7bb84903c610e9e174aa38aaf621069ba8736f160cb8a092d6df9c2f235e5d5be1913692553c97168e54c70bbf3ea8729bcf8ffa5db6cedc27164e59aa18fd9639cda68c655ad4165cb6118feea874e13171bd8c901ca7464530727f8ec68b277d39a33fbd6a8532c4dbf7aa8d9c065ce88af67c3d3db8bafa9b96672707cc8839d6564bebc24f9ef46e8cec850b981c866c8bfe6aef80258f369d4adab03f7d6c74e6b20d71877025c4e97d5ca15ab83eafbd929e8854d760d9f6823488b05b0da8f42228d33dadaec0f0fc44c489f3682150bca0c1f1422c9b00f87c142990620eda440390b639f4aa0bf51815ba30c33f618f765e1ee47e3efff217db28f527da103160c0526601d61667e99bc003536c685ab435fe2239950dc824ec76a8342287eced252cadc9fcba7ffb315ac540d7d634fe9f6a9e2edca4ca6c0644676b7002bb4f08588b2941988f826ab91ca5c983e66f0761b21a03e701e6f266e67d44e9f4de6675812ace90f482205147161e0e5743e64af05bc3e21f2ee43d9802a25063b01f349d1098d99cf04478215173c1a3528dfbd04545350f524bd8119d3190cadebb3f4d9d3155708601fd9e236ed7d804a7a938bb0abb26992b8eba34b468f263e583491a155a30bb71f9384275c80d414b3ab280364c729b6e7181b5dbc3b12590159ba2533cc01adb8dbf2e3f334d7a75e12df44f076004a11c268038634b3f3d78fe064e68afece4b0ddfd471f96b0905ca015336901fa00c48f64869ad046e5f0b38bbc9db08b3b3dbf4a9aebb2eb80cf80dc5da7dde922d45caba6b5294a60478ca9634fcedccefc8c7034e39560502a9bd94f8fc33a0dffade7ad88150af16e907e8a92e45b987775bba4b2644452b3ebbba82dff3dc1099432623e38078189769d1bceb2a478fd3d5b7cfc8e2f471f51e7894996b3aba5e37d9898ec884929a43971a7ddb4368c7a2d15dc9e54a578906c7a164aac7c80c4798be7ca4c4ab271d02890385697846d8eb57e5b76b01bc45ff5edaf21d131194e6714103ef5a22fd885b5e6683c2e492e7aafac87cb3067c6bfb8d6998551212c935d7dd6bdde22b8676ef12fa21b62c93e6322aa1c32327413d7734c1545b67113c372b57e97b5778c1d3a2d469055f9d1120a77b68dddff2958f5cf60f8f5e137627e0dc508aadc1cbc72f315ce78fdb44e9327ef3a94913059a34125fc327bd3b59ba073936509dba72a73e8875ae2d94dad3ce353e717a0a0ff7362de8c3c5b3688c6c859ca0dc0d7bd5e0e12515269192fbcd4b2d5c48a930aea12678feeed816c2164676ab0ce5957fddddc880a54ee56d8691ff191502cc74c8540bd06b35f08c1eaea89bbf102031c3665f6d343ba6b0ee0faeda5dfe96423e1b0710fb05b9c62103938573620a936b830449f1c3bb0ac58c1a14b325db3b5bbdd222cc053d1967ec10ba03e2103884a84d2022bd1d2e043557f7f09493c89709b1957181f5517ba64b5dd8ba509426283269b6b82eae396617cc37cc3c1229a7e60e780cc863c61f4e5615e56b3ae6b47dc2a93171f7564e79972e24146e13beaac8bdd8b67253b0f2763acda5e2eb7b917d1bbb01d0ac714d88395ab79c08ad8b3daa9e150ea2a96bba1ab8577d2f2cd5f391699e3f907cce668340803919f671c671597077831d044d2329edec78bf2d01a85f45a19219f4e8e2e012fd6df831d5d9d0a63044930b3cb81365afdf653c67373304324c03fc0baca91906008f9f2b08b9a6dbdeb1ef7000bf1a7824693f70fb9e9416c6bfe7762683b076343b204f6b32df206cf9bbab3fdfe15bf12d44c0047216cb14e61d4f0d9d41cb46c42be4a20fbb60b163f6803ecca214535b8de8b803c044c7f2dd3630d905d1d3d400d5db0cf5f5fd5f29ace62a84e40efc8a338400e5cb11915ef2873afb8218d60e4d38824fba4496263d40ebc973c1f8dc71a7bfdc70fc8fc3c6b4bf989e8482ae77efdff390eaa62dce86465fc9f1363954afc867c549bfce4171f2261124a716e07458d21f6aeeadcaeed7f009bfc1a3f4f8a7bf88c3e65ba45b97d212711ebed73b4f4ba041cf2dadefc67f1788917a87589a83f159efd22345e2d43930a1a524437780cf12a603ef1578567323a9c157ad9c9fd5f63a9bdbf2f26e1fa4800122117cde8bc5e44fc8cc896b968649ddb5419753666e4a3693f9881ae272cf9d5c0597650fe8682055d37321d40a470369fcf62ce450ce7509508def455c72cc0f68b1cce74ec0e0616b28cf0b836221595f0dccde25b3697582324e36886fbac70aa236f4434aab718c2c5da7d0549b1ff779d874a866fc092915817418e645d68314363f5b06439af706002fa5c60f0ad22e788b48609b7bb50497e8422f858e65dc218592fb0ed8ebe53480fb86ff28e42812c80190c8c83171a79f373cbb17cd7f09f88a9a40a026eec32ae5e8778cc3d148178095897cf68295da4a1f4bf91a9fb3f202fe7818b5676acac9080506176a1f76e64fceb59446233a9effa2721422f91e8edc35338f4c69be538761245c1f92707a56463a3fb2a8b81ec3a3e5a4255285bc575eb037544ad66064f7e590674248e966ab849c213b0685c7602d316c1cafb62c4a9ec8ff72dea48ad3713eeebacb6e03232930a3a36daf6209901f2b7ed1b6d978c927054d3046647ab109fcc12f39da39f7b032f90e9e249335bacc5c7b47d001d7e56407cfbd93bb9a55d44cf37d90a81ddd2375d50bcc1d907ca695e6c37906d6b1c056d6a8fa1c3a6ee3b263277c113989b924c39714b276fe00b9b156d09d2975be946cbb3d2b2c81977052e3281231af8d0f5255171c2fa11c7fae456a11997449e095ed68cfc6fc950055bcd75548af5170048a55fabc83d3d56ab887bf32c3342aa1644cf6edcda038ab25e3bd1b8df093a476226b299f5a07a9b6196dddb25bb0f9b09522f27e118fcc8a0d513dcb9d3837e116e2e1882aa271fba7c6e48ad190e9130d8a73499bab798cd41937441f4981f645672e9db44ae612e006893897d8adaf6b84b000514a2c81e4e9a8e6aa6e8e6e2cd807ff4b8fa27c82e9bc9b65ee6bed60955c10b4a875fa1a6727571efaa310b111fbb6b4746a2d4223cfe0446ef573db22df0e832793a631c97b4ebb593c26c623e7c946db1ddd7bcd552ef0fad9de6f31fa9757dcd3c8cee0fda92d7a7638f96fba3fc26f52ddc8e19365ca2d9b80ea52d492b5f7da858d385e8860439402375bc7dee333ee6548e3ee386b863365861c415c99e6892793c8027d9f11cad59b453dbad45a018f4bbed39354167746ab045716ee7543d52a9a4dcaa8b0f040cfc9c592a5197ed23fb03510ede845fd995a386e73b2e51672e8a3a49f5041143f5fab95591f51132dd37f541c47dd44583d2c76750b78bb3f0bc29ae94d9954f29fa51ab2f42191e452405f17cb52ecf6d1c225de73dd5a83689237a793c4a1bda949d400d59eb567a3ae330d5f9efa90671e18cabee0e4256c5dcc6941aedc9f85ffc213c6e6c0aea758981b7f25facd12dcd8acf1dab913c2dd4ac8d158b74ecb8f3eaef8177f644251b053946384d1c9263785a78717998e0da273fea8a21c7f70d688f3dbb72b0d82d55ecdba5be039f2e281ae1b45055bc6cd92673cd93bdb6c4de305f3f6391ee974030119d4224b84f29a4f2abf806c9db087e6487ca7475feb50654a735db85863b5e66d0f56e945c592b5bcfe0449158757910e75330b1b502f7278dc1667e5efbcdefb504203ee119f30a1533404e9b56679b84b560d52d841fc6609eb623a342a7d163eb1c5ae542a51e79f06892b6b67cbbfb16888873c1dd48e992ad7cf56e4a688ef7cd6a2c29763a3c0cb4734db629be81149b62a25988a9313033dd7bcda6f622efdb523b3eba22a00896385160754bb4706965bb784ddf3958179bb49101717f3f14dcad069a30414617144d59ffae9c9d100d511863f694b335e83671b6435ce59c0a3cbb29228af4560601cab6e450c07f91f47e9afbe32eef62b3c25035da65479ec2724e2f7403aa41f725386baa69dd8cab092e1201d271127b59add23dc777cb0f837c39c3671a712dd6b9fbb711794caae8a9f1db89eef0759fff3dc69d96e4ccb5e8be08b3761a23527e31dace9b5881339b4a71ddf0b69f12aa2586b263c70ea240bcd86a221ca3e338105a48567c46edf0993b25ddfaae1c4802344823425895675416da02148be65ad826ed04a33f715712519cb7f525ffaffbb5d3ad6546b8973c813f709c24af000450f3b6465c96905db091f11eb34bc39a2e4bf16418ff015ef5ce770c586e1d8ed853ae38d09d98c157cc91ac04fbcde1eb49bbae5fdb8cece72584280adbf881e488e0f1d96c11c7543524392bba4478482e7c79caf4c20dd4827ffa87c8186de180b577ca8a1585c70936d4d84488b1386510f92125173912c5718c3c15d84c84802d106c6fd21f927802cb3fbccb20ea437c15f7aacc7e5547c09bd9de90c13e1a3b3e048a7745445b06eee60cffe872bf10fb5c86d13a638e7464cd687850e984f87725da01bed6ec556b6b80920ef4fccd975a66e2a9fede3f90025f3db367483b999b9bedeb574116d088f6ce9390d46d34e661e879ffc606eca2dbc0b23223fb5be2ca224e6bd72f6b86cdb49342223ff9ec26a4bcd62212cc11ed7fe5ad56c344ef339b55299ea25e14b97900b0f3f21971ba89c78ad8e61f653f74014e8f080b95001c406fb33ee0d1b91c747c65390a7e46ecece9b65c16764841cb14f2e1c16f85e1bcb0d51f0e6ce913ab0e751ebd963ee1499c9a5075538920c0c4bd291c848e241d19933b1d4e7a698131f6f35543f303efba4782cd8aabb9e8289e0328ab87d410a16c956b94d3ef9a746986e68b1d442d4c59ab67484b56d3c40ee90f061b1552b27fa5b986edc927ce1f21e43d3b00cb25c9c36544821a69abf434d74c9fd9722e7e4ddf13732ee160441b6d378f4bda56bfbecbad71ede9cfaa6c5b143cced724a246d43ba7809b6c9c14b4b96ccb9e9fc385ed3d1edcc5d3e3d583aa30e21948b36e3c8ca44ff4a12865aabe15c6b3fe4abb673b811cfa565b2b2fedccf11aaa01a537a5ab903c95aeb0b51f08b29d8f2dd9875e2d3a084dbb39fe691b25d52271eb843e04ff3c600c2f7d0f5e69c7c78290a5c5a87430e78b7b3726ac53b4577e5acbacaccdd5a26960576abd153ddd914087c50152a5e9eb4ba77f93ae90dadc33699ff3dd71cbf0ca4a6c3296c76075c09fcfae3be3990f5e0bb5707f22cffa98a965dff301813b410204a197ba66e270f05dd3ba3a7baa3877aed532a8da6c4844c64a73ce215cb64ac185243b96d66ecf5f9f2c45136b02cb4a86a97f32344c9e03690e6feca17106a24501280b5c97ca5f51ba3dd528d6338b0a4828435b8714fb6988f46c9b47a7ad9171515bf75ee6eb99fcc3109ca2ba4b7a02b1526669f33dc3ca4d34ab6f28abea2e9d8a07e283dee13dc0b1a2aeeb36982f6c217a08452a0b6f265280337348bede5a5c310797798d099494172e494d8415858f2f5e1bfbcc0432ab9fb3e9f599df2308de758b3967c48b0ef114b41f544fe9b9c714f29df859512ac262bf8258cf39bf645fadd7464a288a369c7469d5433c9d5c2338d83f4d7d6499d4f8af9d2fc60285d053f484b0c480d67607853e8aa3d54fdb802af5b39a4254f565918fbf7e28a94b262027f991aef30921ef192f9c229e1e6f7e64cea2be75a649dba78d9ec934192243f2f4df3947263e6f4e62f89ac15905cc85828ae602d2fac01d66ad4d482f1a10def540c078cc3d0618f9d696f78b27b3a628addc8084e739516722067a88e4c9a9866d5d72ad57c034cf4b3e1657d14fa2fee86e634f4b0c096d94d43f57ff91dca0d01670341b1b140b96455b7cb3e9dbeb36247f9db2bf3a492b46cf031917f63c47b57ae0c89fdbc2d8a4c8c3f415e155accb2b767c4a7ba28134a4b1e4d9a9d69f30c90d85fc6e0867fe9a221fad6d04b980e9eb07c26d75e858f161b674c916fa250ced754faf08f3647f45600b7e0f4ce4b0dd5d113f80bb5b214200dff6a748afe62fe4e70ecb8d13b0f6c6173c7906612e7b98043efd50093e7222ee3add7c202ee97d94de7d6a524540394ec3a6766d18891a49170268e93a8cff8956ab825b9a0549a0629fa1c24f1f1c6fd692d04ad6c4bc371762205b4db60f55a1c133c1cd8aab3787a1d237ce7709948a2b536f3f2c78c5879794840116e56db93f4fbc636c3a2951a08e2bc566129b52d4ea1ff97002666443bce6f09f6190f607ec734192dde7f1733c78ed38ee26b5428c23bde920210af4f1da55395f809f572ed0ec0e33374de15f5287640d2c5cecdcfa87cd4e8e79434137008c7e42103211bc4c9fb047a23cd3a1917dd410381668f2a04144e1afd5f1c7df2481db6ddeb9048ca0a792aa51687b7be030d23c785809f04e76da98d541100b501e83dceda0bc5839c78971c48416b977bddddcea1b1d662336068051e8ce45ab64e4b3db2916d0bc6ed801b49528f4aea1f2ca4b6df06c6c7f14864097e0d683793d8538616b1eb219f3ee6bca3e6dc4f213871ed911f39606a48b0eb521a5c092829bbb65b39c035e739fb7aecf21b08ecb42e8d25e4f897971ffafd028076d149f84d49f4e7bb446a6b650239772af6f89d24aa3ca3b3f161d21a3ed694a1e9b32ea99a367f6dde4d11c7332257e268432a60ee7b2ef0bca96ebd5494ea59903c374898eb62954f2eb52cf21bffd05b6973e3113ce5ad1d4b373e072099316182fdbe02d6e6ebe3a12c45f5b01d0d4f9c4f8e1e178d1633e4bf2c66259c93adcf101eecb3636e10cc69a85cb6b5a87950530c8856c8cccd7e1660dc35a0e3f958e4faf20a54b5f2ccafc98780e611803c6d1d5b5fa890c5154b6f8c6175232a15a3d0f0c1354450c39c3bcf10195686fa8981fd7db42fd5c2bd4ad318f595c3a7b673850da762a9a74c6a160eac7193c5995bd7263b35e745cb0c3c65cc3812424428157169e313742eb9f32cef565b37ff80b5be5ceb8fee1a745731896c939a28160e09a9399d810d81918fb4a0bf7d1a84cb4b93312a30eb98c8172269157e9460aad6a9aeb96e9eada4a3c026c9489da5222807b743ef71d8b3fe63cc2168b15e2ced3e522e6cd230ca9e7939a4b9733f15e37a738524516fe30cdc1e7b943f6ba462b41ed9696d02ce4aeb3ddc0c71b2224eba4c0f1d63ecd57c1843d18e966ae15d9aac0a453f9f346d4e0f98cda64c4e0a0e762461e96b35b6873f7fe636fce023aded21495caafccaf7d4b4a6251e6d03b90a0767fff7d6bd23fea6ac9ab329ca0d78d9dc251ae640a901dbe9f0db60cea9710053b2a54e2d06eef06f17c2ac3eed3c33832c8154fbd78d55d67d69b097ac24a7049d1d097323b6c04be","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
