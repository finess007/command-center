<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"3a921c4adca7e36b25bb818925e3637618df24f3e03d43276cee1d5394205f4acfc6fc1556383aa989af75df8cefeceb395f9769c34ea52acf797d2b381fd3156718e3da86fb5f0711723aa4ff980d4d2c8c38154f544e59849af71f31d8cf75fef540ed12e4a92a261ceba117826d56c4c5e249589024c4a19e13786b2007abca81856bf05464ba1c9a779e9b256ea33df43994d0a68e616543df6e33702ea548659295e4589fbb9caa41c1a6c847f598bae717f21a7f5da8742f6023b3f67635b18e96fecb045de121eaf05a9023c3153ca72c7d0d41b5970d342265c983fa0cbad6a907a67d4fa02d14a8343065ffde256d5f19ecb3868399c66d67f4ef5d13f6bbe0ead2caa95ce34c1cb5f1df89f53418e1a4750bc96c0153824c21a4f35e0cae9448f76af70abb0b6cfdf824def4794da4b36d07c3458a6f530c0d4e76e0ec8f9069b44eb343933cb7ee238bce6581cf9f0fdc18eb4c73bf1429eed1790cc2dcc8796bbb0517ad67689aff1d307b6300af510833d9a5e973e58cb8b2769898cee58aaa9372119448e50d146d181155baeb61b00a3b217ff2c3ec53f94beb299fb4b344e725129e108eef2139fe25150bf1e29e78db13c852be10c0878819516ae2c90e68274f28aa4b8eebed414634bdbf78e4884b8bb6f7663eeb6610d953792e89bd9649a412964d4d50f72acda9b00d32be7de093e26edc365ad7f639522ae5e951d8beece51aa6cd00c7065e10ed25059a814b1003986a9ea80ac8494bc01053b042ec221687d101f542d70d4c8a921383473984f7084dc96123fefbeaaa4b7053316d04107cd317213291355888c95574bc41012df12f4b129b45343e75cb934f80f77f9ff2f29be3c065c82525e012fe0c1b1ccf36fa2bce69da72b027102480c63d6a1fbc4e45f8061925868f4554e8a4e9ab4bbaff3b95e726010406530858bce8efb52596aceea3b9160445391c72ba105f91c7eb0661a4352745f708b0378d3133918266d73aab032f2204dc2f2550c947532d25409e60b4b8930168cdcf61a6831e3b2479e467428ffe482c2351344fe3dd38e6423732cf6bd478e5c694d04c55e3667dd048c7680c454c2225fc1d5736c397f1b562188eb98f45d05d19389bc21317e0296530bb2a244561b8905857a17f9366e6f09f0bd6ce26613873adf97cde2f9fd469b56edaf3f57a9c2b78a7c960d5d1b129f5016bba0c27ba9ec78958c45e48b8f40a0b2de6a108ff01764c63a09549090959c9b50ee163b3064e368c63a4bb56fb7bc6180296e53a873c756c3fb21420e7508cadaf05920ce100a5302fb23b505e7db027f8d38501dd088f27847cfe2b88242eadb8a0d9354d93146c82f5034b11385ed72f2666c5d81b9576d7216351232c176d6d9b94457bb4f5f622283992cf80e311d353f1816132451f9e7e692b9a8a4814c26a994222d9277fd64fe983f5c84912c51ec94411e37bca5d30b2a3387ff53a8ec664a07e1bdb75301ca5a48b63523393d655b0f5fbcafa839597412cd297e172551819fc61fc6d37209db4d9030e85805fb582d25e819855c5b27fd0199a9aeb0e8443f614d4e5f3c6b9f2c2ff76ec0f30a6af1f6f3fc053d2f15822249fe4567504a0e811f6f8c218487ab8a5a5194766cbcb84737efae6439d4dd37a42f5f8a3c1b89e6f33fac51e8542cbd202454b72a9a4901d1eb041d65cb30f6af9366c9da64e8b506816b3341ea3c9b05d49e60e26dd98a0cc63c6689e04dac8fe0880591be586032fea6b9baeddbbf24c3a950702fcfeb7b98b4ca01a39ecebad8b58ea66c158d38881a59a77917040cfbc439ca9553758ada27726806f5f9fc06fc05ac6eed46a5440f884c5a171907efc0f519e399af1a040ffca34b703dd7690fb8670c293466a680e17246a3aa8af139e6b26c37fa7f5cde6661090dd30664b80bd1e2f5c905c9953e006469d83c76eb4ff4d6e8474c61132103cf381818b661ff1438b0ac5a6a2ffb58e3764b8e6fe83c3ab1f38a0cebb6f8fb9c33f26c3dfc282d5c306b273b49e04d4f0db09c02e64df301be2fce4461955dc8dfc6bb51de1741c46dbc04fe5227274781d094a28547ce391e51f2829e1f298261fb43e1134d02526a4b06af4be5adf7449a2eb1cee6c356f707a9e8ad41eaf405b54ef03b5962c57a4fc968f8f53b76918cdcca30e1bef98eb2feb7b904d8730846bdd606bd9ba9da9efa90d8ce14a612b905906c8a32b31f123dfa117385f23070f53de5679555532e17ac053488daf84f74ce7179f568d0089477077120d58f92bf1d0bc876faf55ea69be9c6fc02d3bd5ff2e8335896afb62c3b0fb1500b80e253124c4366565263f3e77cefac1b95cb8e21de52ae605d9c3fe0e19ff7467f404b3422d002d545948d35b3136bb3df551900abad2fc734a61d9dbb556bfcbed32aece46fdef7f97019002221bf3e70fae2378e0c0409c7cad635a8e1c77e3fea5c2622c37aa61822bc98b18b505482180f17698716e68d2052f187a9ae0f4195ef8dd7c28007e76bc9ef878dd97cd04191425c5913cdc567f9254d6e9478548518193a825e40e8e26b26159c726a54672753ed721d6d60813d251b63c284db903ecce7e1faa0b78e03db111328e12cea6cc6062781faf64102d92e4a4f8ca30f259b68708f2e021279a034bff48fc28f52437923df0e01069a47370ce32076112e249fb5e13d270f3dd316e4817376c6418626c78c6d0b2def33fe68649f69320de2b5d90920b579362f77a0099fdd679c77c3e268edbae285e8c2ea2e56beb4f691dbbd6930b60f055a17d7555b29fe5f9b8d0d0fe33889bd41422ee0f1ddeb3a83cf259f52ae67eb8cffecfd817eecfb79dcc25a5e4ae24b1f2009c3e565fb42d19c21e3195d279d9cb5b133b5a2600fd3b9da22c68265b2de27a39748d1978ace39ac07a402b90f42dd3e0a46e18f1ac2daffd57b5f8d43d2485ed67d0dac557a98d5250170aa042520f1a9c4cd9676ac983790cf569776d3b12cc086688e7394f4646c722a380b440258a9d65566e585c586f407ed2554d22ea4686d0f8c980c45df9a9f86cdd582d2e06f851fce0e0f81e16041ebad83998f44c1225bd495c2ef4fda53b38d1bd311d8d6279b78defdc87ec6532a6bc99c2363f8077845a36036f4aaf747a0945ac1ec6d320bc2ff69fcc536916cac50392016a830b2e3d2d06a9344e4747f53b97d498881cff8d4a7c3e690498061d72d18958b12ca90b89543c827c3043b0b364e7d8752c0339b5f616e317edff61e249934c0f826e6217e9dff084df9dcc205a7eb0a70afede89f45e13a870361c2577602f4e8c56ea1f0ade469333741d1acc4cf8a597b37ebc5a17fd5ef90351ec1e486e575e136e4fa90bc04c7f484c72cc50df5c7cc98d15fb703ec836dd52b42f63f2044ca03934b314dc7933c52fb28cd23a1084593daf42e93288730a140cee4b04d940b648f7b84b28018b30b0bc806f17b79c64d0c333f17c18416ab13c55174355ea22da52c450772ae8375015419742e0a6db3e4ee51201e1a07b534b67c59f48af078c23e0187abecc651fe2d6abb028bbe5f33f483852ba2ebc579aa611acd1dfdbf0f082a343530c196b55b6e4732dfd485bc53248c8311f49e427b58ff257a6f33541c6d217a44f8a98c24f90e491fc0b30984d2235c1974fae2db2041d16e5a1a4e627ad8462d0910c7fd037855db6d27eca455bc0a5136e365573a3d75133d4c18ebbad9caa7693f71b034c1400cc80b07f13297cc2e7f77a3c0e4f1e16ff05ce8044dc932a124563dd0660acf4f47df3d864603d2b176cdb6f31837e8faa67a585c890e6f6583925ca96af1d327b7148b0f1e4988a511ed0367836698d6d552c7df3c78df54e87748fee8c71c99128d2db82c01994fa1e6c215b4a3d42e272926600a2f7bd43fc6160db655d061b54096a57dca3cc2f4b86e4a4ee45da8b91dd6d48f31c8d6be4bf0f8341bc0fecd3da7b054f8f364651a2df1d8198908e6e04de317cb0ebc16807acbeb9469e53966e300dd12af3d07bd061e8580f528e4a9e6468d7ab6ab75b94e47ac0a057c7aab4c022b050ec960a5c9d40604389dd6e8ad32b56373166beebeb736cf24c6f4f0662cb92ffc7987603a1e6de0f095e06f8989bf24614afc7c899e356a7b166fc4e7cd87bd3730755367eb3246d19d2e7644fe22fbc7d3a80e62766e1db995260f41c2955ea7849b620e4f3771ca45930651b3cf5ebf96c068eac005211a9830c7087bc8ae1f3f6cd26e138381d4730051d99be925e9b34e766d7e4dba9bf99e605e332951daeb136f6a500dca7e155ee981ebd01dc305979214a5210b01ac823a3cebc0e4a7044f8e572e559924d8b6fd03569b8261096f8dd984ba0a728a4aa25643132d3013343cbd00bb85e20546cb7ba8d602fc22a8695ea3734eb458d30e47cfc62596dfb989e9a9cd4625270a1807b618ab305ebb24c86f725ac19bf424978f02bc2922a4a155976f4dc0f2edde7dad7bd82f0a893fda404f42215ace5311a1acc5a83a7c9932d37e02f001de4519d20abb56d0f4a8b676c0b89c3a2d685738df16962326f9adda3e8bb33a93f9fb40127f023c7e91a8c46fe356354b3e485bc348e5873b6f33309f27db3278cce20d4dfd390e95a9e175f9150515a6ff84fac8ad8674d3526ea1653e19d064df1f2ee2406a9194d8c07ce35bfaee6b59f060d72caf8cf90d8f88b53871897821a4aecdb9df059c1b64aaf6bc8d244fa79903a68a9e7b2dcab5703e27a39fe3dc265a16a0ab12ae1857eb40d2b53965bd8f18a74e96e9a7ba4b15201d9de03549990b73045579ce63856d1a5750b21315041a931c7c7b935c12bde337818dc3e5074a296bb3f57f7db56dd057f6f582308f6f7f32e71f78d4f212f57ca1f5b61869d315072eb50b8869d89a91d94787090b71838e9f2b743ded0c126ebb78896e56c634e0cfd61b82f65892b779bc533f1e65cbbe4bf42950174210839758a4d09f3eb855f12ce43e5bc10e32d2c43ef6ea0674e6c67840ad0cea7caa4ceffdcb6fc309567ba4b0a9282a638f468e94d35f615249c9054ec7ed479f5ce5c397bd2f0f16f20556e7379c0b2f3fec1d127bbd72a50b80edaa9f678558b298a95a7dca07643b79c3afc9a1af9286313ba1b21a4dad8c71112bf45018cf0c9a304ee5cbe354210a3bc10845ca91563d624e4258143b9ea47b35ae6956639de78aafe167099c193ac69751ced5009629af307f04473de8a2fc5106bb9ee868f051b6e4d1a3994e397b5fce53ee81959c940f234b00a530a22f2bf44121bc53779b97b3d383b362f7bf9a566cb68ca821802fc8a319a30373c9cb4cf063697e0c9bb6007054f10595130712ea3467a2c20331b2021efb116aff2838d689caa351eae4c168bd6206c04024304358ad2c3c51842a76919c25f3e37d88710fc0379350640505fb6e3f1f0a7c47e7f5090ee70e824687576e58396411cd03e7986abc420bc26e998afb2882c84ba8562204b8f2667f26b49c5a18a49f34a744b51f74106676f4898d9eb9bc29e43dcc5318bdde2397e8338d684d8cb992431062930c41c567a2d50d24dfb5b2739448183c347b7f2cadbbcff5ece7aeaab583de5a3c4531ef45ed91f5f9f1dd80de9d66529e454517d5504a3e51dc7b61e357a560801b15dfb08bf46a5adadc4ea57f0579518a2043210a851bec3cf2589426ff9d5e6618645c74f31ab0d3dd5bffe5fc90e61d7da7c038c31dcbc1ca1e240f44d261bf5d7d9cfe661d0316b1f1f0acf54d435756431f0522a7d1a1c3e15e6bb52b766d186aa587fa880ae70cf8da5edd37c2ccc30d4b53c4536ea991c4c36254b531e041aac65f737a29e81b92a8c5ade4d10c1345c168fe87a976a39d35c831829886d04ebfe2600d6bd94eeb361e7098802c98336360596d1a6fcb417c45922798383d2db7b0065cb01a2cdbe51c08da516b7880d889d2fde4b0dccea561c9fa8899efa417a012af766c365335c7bd6a0a8a1d1030a88fd5eb72c3d1387ef7295958f6c6fb95b419a9baff2dcbf6a7f66f865cee9b410d77f65502fdf39ea71514194e54f3c2a837adf6b75c2a86811300ad2322f3ffc8be4ca53d5fca2627d87916897b284c4b13df93d376905c0ecd43490de3086a50ae4217a1453014631a9091b579232b74f809af43f2227452581cfc0a38be4f22567958239a430328d2f045ef6d713c949407ee22f75ce6593f6598dd404eec93093533c307e3bf21b9223202df11044bac577d1634e7b78c41a367e1a5c101b469427c62c836e4027342ca2f34eabb3c73f5fc1d35ff106efb6d3dec8e747f61ae68bd82ec6e15ce7e137a1a37d2332a02d8793e2cc903c5e77574fd49139a539ada965232492a8eea1d332929c8fc89f94dcef007f61ecf8db47f7217a8953a08eba638a6c3e73416b63d9bcf2537b8f7de9da35a0c76f14b89adb39d0e9e2c79dce6e549f467103909afad18d05c55bcf1608370e368430ae30ac14c4c00a4338ef5a44c9f2f20f3b365279364b914a67cab6eb6dc1e4382c5184c3b62012d82cfda8dfd94f96d5a6b899d6fee267857175f5b01bc2c438c871af6467575dcbed7376c849d15dbca0a1da5ccb8d2f6e522ed6e7600f9f90eef161ec45f985a51a49b61cabc3da824101c40c1568077afc2776228b25a6575d32b0be862d40d290e75613700cc944436e2367f4658d67b1e57fdbb4c41c8eac5a7b5ceee747af6f8cc4b2a32d6da7757d49d76ce5ad052907b33d9e36a3927d3531480b6e337b5b096c8d35292978e1638876b67f8f0a2ad3c2790190dc888d8670e719f26a4b88a3e1158a95031439a0c8ffd2b120ff99c48cef477bb32a2ba373d035117de3999e95d30ee665b674e23b742fa985bc1360447f3be1ce83687ccb024cd90527eb99e513b15e7603e96649e72eb25217080a5d1d4dfda969f3f7e04e42fd9aaf67ca8b549662c4c7c600e5802916b2bbf2cf947d99828537f6fa85dc05dd18d737d57c7748fb4a67e2686c7524fa18fb4a1cd6f8a83e16786bf2b0c2ebbd20c712228717714ecd3792cc946ded55be4dd46df5eaeb97bf7c14e3853954d82d884a4c77ce1c06dff69dc13c3bb71a38f090cd3521d3500fe686bab14ccf401979950f0696140dbbdb4c11452a8864e6219ca01018ac09973b0ebfb95550cfa9a6ac1a2b7a8fd3705494c3dbf2728064011a5028fd9d6ba1d1af59381d9fc46f53a12126594d68ade161e43374ee44bf9bf4a840a8256de9901899963e56ae5b2d01a8500c066e023e671ea8fef31a5e2f269b03b8d1bc47cc1b4d0d0773071e70039c3c28682271d266e884d0adf1f87859dc8faa381ef22cbd1888df570f4eeb36e10d100621ed03e3b0168617756937cd34fbd4a05592f5e645ff8fd3037ff46694b4fa5d1f435ec31b0079ccf46e699d881e2e2c14207e9282fda6d60caef27b1c20b732f2bd343975466ee310dbd5cfc0a6224552c699624db150363a62df56ca2cffdfe91305505c15afb3cce711ff2c3588c33ca9b727faa12b9a3e540a5282392ca0dea826b115f5caff0a0eaaf76ef35655fefcb47b4bdc6b1354957503dfbc4042359474f71c3d678285c3e1acd667921e018ba81eaca024096e49113da7f89e997284e74cc8ddc5259e8ba635d90f7ba7b510e7a6640d65326a4ba523fe7d5136141935709912a816bc51a6e8e00c8e0ca14327417a4d14df418f49d2803c15125733da3173e94f1b20e790691281506f71f323ab87c4c8d0a523caa177cfaf326d1299ad4c131bd546e49c561cd4bbf99fe8b0ccca73c4369fedb6d4bf11c861b4040c44d27646eee8be6436a3f5ba6febd2ec5a45f026cabbf107580f9a7ff4696f9a27852eb51cf98cc8b658cd7539ec04623150cf60b607db9105cc5c547f02d4b063f2886dfcf015abfa3473e6588dd21e51660248afec93c858afc3fc01c9596598404424f4b2cbfc8038b940cb72cad7cfe2c792405417476a118590fb4d940d3604d950246bc4bfea6ff39de4a23aca1db9c21619ec0634fc1e530a0ff616226e39cee3e9c47907ac4c12e8ccb90795f9cd54b9cb38dfe19c1a5dec30164d43c2f428aaa4f48b00c24e32e71a4bd913c0f1ea6f73afb884387b06f98e52160decd9650d243061cb1c8c41faa95687e7ee8f2470cbeb650c507f19ea7e6b1ae150a299e5aef506b8cec7895fecbc5a9cd95e951d6f095405d870766292edc4eb085ecc3d1339c43fcb96c7b702d0e00ad3c3e4880207c01ba4994cd4b4a65a7448a82a33afa103fc65a9213e48dc004828ee83f2b08432aaed9afe65247661134ce306072b41a45918e214391eceef7efbb97f7ea42be896623f9e35e87c17e422337b9a7b573d81891d1a0bd497caa793d32f229616044c99a52aadcb8d7ce7a643811134194855cfdf2c02924d33a591689bd5bfce088465d220725038f07591f0f4635c5c77ee586d8ea88eeb86a16f13da4f72cb20570490def749e1133899734dc08299f556368552ea88b2e76366abbde05dfc3da36e30c8b208432b937c82ec6fe37ff4f69e4a77e11398689289c8cfd430871c4ac3baa581e7a94cc8ee9f8295ef954ba859813bace96e900f416a7334930c837d094686bfefcc3a6f2754f7dc6762786e1cea68f4d8fb7a804723fcade50d2220efb1014ef99341fa3636b41c8c616d2c4e62474c0405be20c6c74a39e9a44952c9f77b4e239565fcb0e97baa9c9e2934fdfbdf43ccb0bb6c2033ddd4780a2553cc4dcdcb34802ef7229ede1ed0160e3fd7cead88c0cdd17dd58f101ad3ad4ac9ba72a555cea5b30e6a2268975cc3fb14e86c46b0b348bc447515153c06c98949e06256bf04e57a232c6071c153d6d1ef1efb473a1bc413a89daa8c3785a20ce2b3932c8934eea8405115d55bd1968ddcc37acaeb6e644779de05929f4b1d00fc175a346d8e794bb1e5d857551e5169c493135c701267f9f4493dfa5b7e322b71227f87958492104fe84aaaf48d55ac8852082488c24d6deea126e248be28aacf01546911637be14e02e764496012643938f11a91dfef3d96636e49a63292cf6bc69951c6f557438b8dfa1ca44b7d61afd53c1a3bc7fb401b57f251021bba1a42cdef8438a4624ca75e89df1f78ef8489ece556a40eb36a04bf36f8bfb4f219206fab52527537a5f0fd8c1dab6cfa93eacfcf9a89e96392adc15f9e5f72dad33dbe7b6200d503dbd07966f087300f7df5cbe04c2bb39f41247e9ff5ddeb92c1d9b6d0cb8a4fea9847f7748ba67f586b0e3215f73f1cf9956d0c893e924b628f0b52a71fbb64c2f7409d18d78f1de452c45c5c38800f27014a0684bc2f70971a982bb696a6150115e61661e796a5ac86376c9085b0be3511dbb2da3463f59ab072cadaa3eb84096e32fdee1482764e642c7e4f5795d4001bf4d5e6cf2be611889ef3d106ff3b6919da846110dacf687588c86ec28fbb905199e3c9d806b53acc48fb24625905af81ebcf01caebd97c1cbe5e16325a89c0e7fe87ccb25bc8b159f079c34496e174a5d4fdc7da9708d75ad3ef48e2e0f4243f7e49c3e00710319dd6e1d96fcc04b6cc437f685ac16ef5e4845777aa7add8a3d1a6a99e6a9b3251bb7ff3641bd2a151d0708ddd6c9c9f79a29335d7fec730888038570cb9baf99f279d594f1eca00ee3be1a92576c6ebacceb32f8dc3045b4a7e6f6b03f02c509ba2577bedd6c63e9e182952aca30f0f19ce0d1b50c58421a9f61fc7777b07f73721fc152636eacfed587a8dffaeb4ecb923472f4f95fd4d237242ba8bbe34c3008e84ca89e818e73766ac57a2dbd9e0e2e12a69d7a94cbe5b552ca68b344291b66fef4056b5b6d884ef2e29223b87316c221f6770131e60143d7044f8c108270afe85b66ca2afead51cb2e001324aa27dbd4fb22a4a482a08d56a622e6de1474a4739c350deba8f8e459eda9a9d47266c893b8fde3b596c000a6dff09b98fc85dfa4cedef4d59bb02709a5e67643cc3b9dc0dac71ab1666a895c51a25d91e2fa1f875224860f139f8b82d0094529fbb788c183f0fc234264fdd2c9eacbf817e825ecfe7b42162331ba5c5b7232b4119f5f86698a2bcf472cf715b67e1c0f744bcb327356c6aa7d33b597faa0f645133843acef28e3a1f518b119bbca3f89c151e70696e0a4fdf60c16037a3efc98a99d4ddf5312ff109935277b4aaba125070d782c84c25555a087f5429248d8729d014e8c6946f364fd24ed52ad406aada7222c4ba3b7e81a47eeeb5f8737539b87dd7fe0693f30e93c190006de5f813658867a7226a464c6a817fb07264a14a11acdac0d3fb47b84c02ba58a997f0547bf9e2b257f8881387a80f4e2ebfc2fa17fa3bf2ba079f7283c74db13950dd93516c785d54aa401b77dd56931e2edba38039e334c326e3f33d29a8dea9684135e97620d5916a177c774b89db3160dc238b8daec6304d6d7cc5858013bc512a559775f82e4f7b59503079154d670aeb6c2d64a975c8c5fd4339ce319bc887e5a72161d2fca8b3b486978ec3958330fd13db0af9c7d72ebb4e7e6b8507355266199f5c9816a037c2370d5c12cb921059fbb5e571c9e57e2745aabfc72ac91858f442a17362bfdc6336b1522435adac2d1246c92c7dccba746a311c4d5ee01480de74692adc871a94c9661b64c06511ae8fee560f5d02a6d98464d89379b283f6def43d3f2155a67f3871f6a83da628076d173aceac76091d56246c7aba865bcc34da50f4c1ff76d853a690f63695c5fbe2db204db15440b2b49f241d64568d2440f942e883c338c7340ea516466db4d7f470eca5368a8c54a37d16ba97781c8b95cda322e229340e3fc0a48b8f0c3f46ad6223870215c8d94faf20a1ed0b2b30a0d1f92b5f437a85ccb0f1eaabe52baeae6b2c56a44f651d585a597dca91bf99924e4779e667d53f637fe42ce1aa3a32c249094117a7bff1dfc824c67418470da2a02577c038520b734890910caaa6b2c2ce38f0ff265df0121f0e81cbee073fbb2a830f75316cf7f60b17415bd612233a9608bcc89e519cf0f774814a4abcdcaa37f399152b23c582f80f8ec0e4232c18e1a5aaaaedee49b8c860724e665bf2038f89ebd4f46f62ebb3e547c5f535108eff93ba805e64c8c0242c49a65f6b946a15cb5505d702baf69db6b3cd456c922604968b5d2f665e7880fca3015723bbc517bb654c047f2dcaa85aac6dc5069861e830e87c432dd4ebc85555b2081b5ae015c8aa6410d0e5fa84e7881784c7e1085106feed0281edbed6f2cd4909360ed854268db1335944be0b32ef398a4bea408a46d650fbd2d875c2aa070336c94e1d97f4ef829fab1b83b9c93aad6c953b5e0fcf9a4be12374dcf741945964e076fcb4946adc63d7dff93db214c2c773f719e380ed74e4015ec71e20a1f34d00ba4005ad4ad393c8350059b1b45695d5a06b3cfcf2716846e13f90c78ad560307f6ddb6864fc6b9d3420da0665d892722641424594a895c0828803c4bedf6416e188b9b7e9cbdb6a6e263dde8e02f2b5b6b2295e88ba070ef08b641e424c8f4eb063a03c9d9059ab8da13aa111420d569a34b9d5aa3142050e67c3dc8dd02459c3913e4e6ad0391094bf34328f77ccbb47ccb1144fd01cd5136cffa91a308d2ca7ed9982433d2b90e38056faedd3c2077d80089727b88dfd4e7a51987f75dae61484a92e20fdc3480729161ea0e513b00be20078b4f3bacc74ba01e0205376d513ff596bd06d8f8dac5a8557c5eeb5efce9ed01d6dbefb612c0af3f8908cb4b6e545cb5b169e71c279037df04c6f4bd1d672f990331ca737601174e1578ae015f6148175db855600a7e379d200ab072d3a81d302cc8affa345415a82b0026c4ce761cbc3994a70be3b67a730512658fc7b685a5e145ffee4e76cb22fc07d4727cd8d954178b269a8ffa63d41d2eeb852e2f3c72dd7e76563560d97faf8245f1f5283e351eef98b26bb6d31b588f5f8cb216400e9e8f49b6725ee8f9a43046b5fcae7aa6585e5d3034de09e0753db775c30b6e4348095dcab31fa32db367c003f15a053bd6956ba6c0778f4c5f33cab5d35028b24ef1fdf9968c2579fa27dfa78ac7cebf3dde6fd1610c0feecd131b7a03f56bde10f9640e5b6173fd4f8aef26935b7f2bda425b804445fe546f50baad1848d5200708e422485a4b284c38d7dce4709f015ef33ccd0271861194288ac016bde0d45d6919290b40ad2c8b355ad391d115df7ea256020567650e89c715f267f8a7c81ae52085eeadc0346966cc09ea25313fe01d6c6dcdde84fdedf980c8913437c6daf8e3cfc4d329b624b9222985efc43e1963f647bed390482a919983ac9b2b5b5468c0161c32672a19ef5ed42eee14ca8c8395c118008fea4a2e9969518b206bc9e5775e486147e71f7b5bdeb9fb5993de2fbaea82cdc4b955552f4898bc7ebbb78fc3f8e9f97bdc1305ec6360d2c938c604ecaf195340c02a43953df6be98d3b79feb13acd410afce22cc162791176d19cfe5b09d690328daab617b399304817ed1ea4bc6816404e30ccd02c6afb477d1d2566820fa14c83a344cc2d418041346bc493c2b4362f742d45d9f6ddcbed91ed9f691ea7cfe1a93363f1163c527c4a25ec155df23d26d7e615302c130f2d7c5946a7b17c76d87bf6490ee612802f34ce2737bd27962deccbfb4fcd7b0b51e0cbf423309ec91f481d9dc7d6f6b4fe44dd896458260d7299da6b5aef189ef029114197526dd4a48eacf1fb41b804da46559dc3d24dd81bf3b28d5066ea823ca1a1926783b5ba04dfd46633f2037aa6d9f489f567f589c68128b4a64ec4b3f3022311395df1ce6f69e2b66c8c39d69e4aaabc9ad5c19b0af0080240fbf3ea1b299634b8494b2b362d2aad2f54b0008ee544b33dce91e37bff8aeb94997a6f423c34c83f3959c037b2eafdd56a7d802c30f24e5944942690af66847497a60ebe60672882662709aa4f387431865e7dd56b71be214effd56344a78a859525046c574d098f9c770d15844c4df22eeccc25a06848c50dc3fcab7ec5013d061956df33fdb966d66f8f9cd59f6ac89f76b8873c99cb4cc8cbcdeb98041abeee092f5df0f57000ccc4243c6c35bfbbc7e0fc304cb4bbc0d25f87725bee3395af414d5d78d39a536266320522b629e5bbc27761aaa25d64c2adfcf86bc1553f8db6224c7a699678bfed8a90617a06109aef6d6e7785247fb7b294ed24b4d32b500969aadf86fc5f9957e560f33ee3ee47ee53426160d21d761b4f620d151ce1a2d6818bd0611622af2cb91311b4a4fbfe87e155a91b9a139f1239d9ff484bd38fb98b2d37f9ae90adb5dc538c9892fe0477f14aaed222aaf1abf9a9111fb6d704ad042be533cc4eb15165df7ce3c3013a808a8e381f443ea9fcfa327decfd652921df18876482769c7c16dc3a5c9b72c073bebb0842f11e89ceb856e181c3a6aef8e8af671c69b25fdf1abe425e46f11152c87fd3f004c08009f4d2f643f483959904d4fe204eb49a5a07236e47d7cd4cd4bee7130c7ea09c8dc3a518a9bc80b266ebd4c6cdd203b091e2578f31ed7c4c3667f099ff34293119b133452f3c7109c6fb8807b90c16282e7a749ad0cba124dca27790fd92410ade85fbec7007a9c31170878b304bafc4087bd923e5869f0658366ff9caa495b89b37c60cefba99af7a5b10c80eb7ad60c96d2ceb8a7f9c6bc441c7e67307591c45dedf84e8721dbdff48cefc29ea9aa038bc819110333021299cf12023f90f3c7661864830d9e62020cc6ed7906557822c2ae50a91de0a102af61fee25c18152f0c6e5bdbb36d231365e7d19ee4706891a328494ff39767c49b0de0a90c54f7873e1ce8881d715f772e89a9c1cb82a8cfb944c28ef1945f64e71447d9bf5f57508cfe8c60ec8ac044c3b7c578d1fd383fbc83feea80531625be363f57cb5df9fd468d6b72c1553407c31ad17f262de5a4e2b214f5cc3c30f360cea058e50bf4a32cf14007b71d63758f3fc1b96cc0f7460971f036c296b6c90d19f7c6b869306a22b48042d85f96f9e52f829ec298587f1136f11aef1cb7a1cde0b09d8398f6219f2e7b7287138747295ac55c749039fbd5b29a62e45ba782cf98b30b6971347d4769d8d07eb918bb95a66ae2e2dfadb34d56b2b738e48fe943fa73da72dfb5b44024d8573dc02a4bd72030666fe4629aa6cbb5f74b7628f0cd009ba12443c327087e6b6165ba593f88521b9cb5c2a80c83fc9e8780d0b5bcf51072cbb42162b4cdb3525e3d86f4bdd660327f5d8b983829a9ef03a5a3beb0ad04c4ae24f37fedd31e478a81d2ff56e93cb9e1964b34a19d2139c24250a53d04e25b64efa7ef049a81ed7be44e64974ce33816b3688241a52afcf8f2b994169dabfed5","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
