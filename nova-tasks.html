<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"66884d21d916ca2845ca9b1274af87ef7cfb1c6213a489c824588e69f17ffef98a5fccef13f15df26862a6d35a34e2015f9e3ce3268caac90a890ebbbcf0ec27ee97919e1a9b28711a29e39d9cb379294883397c7168a39b878099bc2d957deadb8770ab36c2a79ca1a4dd3632b33680ef19978fce36ff4280df1a82dedd5c998cfc470de0dd7ded913c7c9dd7c070ee1f3c9b52bd218ad0e54c0082808fc759d03abf538bf66d15d81f2183bf6c2aca1e1430535981ee3dd74109ef921aecfbe1b93664d1604253fcb2da77d1dcc0f543f08e57627706eb7655c411f577e70eba907bb0c8ee19ca4730e5c2fe1a28378e8ff7e4ddb5dfc5d6c7c534db3ffa6801a3d2dd13b2f4319c8eb291fedf784b72eb7ba8e761b9f87efc914848d6ea8816f9523ca5f2bbe27424cd203ac09cc0139c9e610ec93da30574c43035025c2e9b950b61d8b62909141a74c86735556855fbf1d189b98200f2011f60cd0a69656701597f5ccf9c6f2ea0626b4ff0075eaecb2ed7e6c95fda72279492631c47a74b3c23ef589ff9b59cf5ae96af301b9f1105ad2aab89d3e0a7db8636afbea6aae0b9d17ad18ec02d6508c1d7cf60db2cf12096eef245a77beef03a16f2e5dee702d017d76f97bf960cbfe4e21817f98c69bfc9742ac17c31b5d06c91025cea5aa0f37ec0608586a27aab84317d6cf64365440d668a7446a78304c39d2d8f8896c972043bf09166605dbd1cb69e48c758fa3c86514173f50f89063b2940a93c0bf0c48bfdb80a520cbc6c0952f24aea183ddc131dc0872694b9e9dd6abd20230a3e567e0b287d64d488d5d4a02c84af3e13ae6fce8275bbacdb91bada20957dc09ba883aa5ca706babafe3b10374984f1c93f3f6fd71347e7fa3cf7d34f921eaa22e1a18c41c588d8e7751acbfac894e2ef73eecfab815b33082fa80a289f39a93851532938ac1539f110a6a1b7320f88cc62964d0d107a7cd018a1cc392fc15fc538e44bb5cd0384b7b66a5d15080b12dc42d409af2078200dda8e4468c75fc8392eace7ba2a5ee10c6a7502e3dcf0de95715238bd0d52bf82084941b174ba2dbf35b408aa0b6334550657d4c7df3d908e4e0948cf9ad50c18121bbd7f09702a19daacbd6819a510b41ed201809d27e8ab00809073e34057057e6142694c74977ce215443119893952777a46ffc345b5f9811901910d7a31d445fc02876b2571638df663a6838768c0ba205423ccbca1225e7db8ad28f4fe28693075306b3b3c94b780b675b77e411f2a227e77abca566e92ffe20afd7b951dce2fb6a631eabc179c729c728d93cbc4c973a3f90d9479817ee4f832e32e83100760022c09a4fb1bd5a971ca41f379e395a6ee161e5c571961dc4c44d825d86d6f9bdb99fc748cf85fb2724384dee2cac00932b4d9847c9403db0b097ffc4dd718698bbfd8aa3fdb8e011388a288ba63f07a83d67a65112ad057e9487b835fe6dfc7cecbc7f2f7927e1d4e9d9fb4ae060ce9ad55c225024c3285bca7e6c2baeee59f8fd0034917cab8bfdeb7e080e542c2c94cfd31d5ea70ef3788d1f6c8daa30672612913d29f6bdcae3a6746e85964e6bf626c60c5cc164ce563ec275b8f7a83eca663d905e798b2a6e1924848f49a320a055d1c8a2869f64c71ab350977591c593d5df486360eada07c3ce2ee19f7fad1f971a75d017deea3a4a180877d41dded00fe32cfd41cc3d47a9ec4b10ea323298a6297050705c5356232bf37bdced9966afada101df3714ece95fffb98b647c21fe1fa0b35723a55077b39d51778944aa84d527d96513a755136023dd4bc1f7d47aa65a094b5385142be61bd5d8b1a8533b074cae3a0cc0182c973a755ed3ccf3fc279fef0e84d68e164491de30053d1538e1996b9e67c8104bc55a8b78c6ec2e4dc71c46ad775c4567beef742c55bbce16e144883874f22b07819fcfeebbf588c84ea7b32b67b3d7626b43ca5f0e7725d095c17225b0d4b8f0dbe93b2b904e88d2604ed281ef8270cc485c89b186c3f17ed83c63d914d403289c54c7b1472a4491fdb83819a8c7f9fc6b90d3b36dfa636b8b0139a5ea4a8e767e0c6cebb964ae7c6274926a6c2b08c7e0b4f706a72a39f4c0170a84248f744fa36db87c1cba9041e78afe775eda2b63883e9dc57e0df0b502be41c33e90bb478c0be784eac0b7ad78d9a33147d4ec3144883e70cdc8fb50b932e4df11aa5fa4989f7b3f4df69e11e2228c2b011b08e5dbc355ed4c6ebcda5311aa8bb6f174f7d92b348c369e4b90808157282ba8a3b06102e36fbf6a060378a1ba5a49c609d75f6c2ec58d1b25147212e55550f053e3c5b751c781d70be66ff2770c719d76c4c6b552d5bdf576efa00f3e0a7a54a414e928012122dd17a1f00f585b944f854fabd297b6c6302f68c494427ad81506767c07b794aadf356efc2680384fb79cab36fe17067ca7cd33e03f9cb6b5917bb9016e4878e6baedcca09ffdec4080e8a29bc05dc61acef007b5c9ab6925aeb9ecd8dffec9c20c70b73de21011c9cfa407534e00efbca51cc78bfffa49750302c62cfdaed6a7fc780dfb372ecda3ee4bbb6c8378142ac3885b48bc4d9441b1524856720208aa631904cc23d223b4563e567fa893ba199de37d665c3b4ab16b167dd54c2589111c86fd11bedbe02c0810782670fc6520d881320c55f8dec12e3d32c85238968e5504157d9baab3ff775535e72e4574c70d6345ff1b6b1ff0954de118ec5be05a8dbeadda1565f33af2945c207c6ba03f083de15d09c778b85fecd99d0e93a9322ae9ea6ace2a0b3501bf32230df6106da4ab748735a22c70b830f563c9e64d420191e22d99f4b2ec3947af6f703fe64f10d91e369b05e181661a11cd7f29228a04e7c88b7d80fd9eae9e4122bd94707367135a1b0ad2f58176e17361fd62d5b3e5690d95194288c1c538b26ccc65171dc848e58e30ff092f25c6bc0a317e8e26c8d4aba8232c77bdfdaf2a3c118da322d0ac5d371a79854cb963828c68700c5a043d60f019fbbb222b8e44520c43458f6f4fbd9479aec771552ba3fed5a60c4e962c4cf93ac8d9e40509386825a86595ba699639e29fa2daf688525a923968788a95e7d91efbae70cee87dd263790d3471687fa9e31a7eb1a2e4730cbcf8b4b470ce6a98298733c1b3fd448b4b31c9de3b8152129602b7df8169aeea60a33d3a4e13ddab48550acd1b08f6aa173a54b84e59cb2154a74c4012e55dc89b96e29cf8e34801078132538191c0592a521d7e8edfa77812c8aa12fee54dc6bd41bf6a1e7f29b9c4e9a5df27afeb632022fa81cc9ea4f6cb0bbdd00eaf3969a107bbd2374509d4ebf329adf7cbcdf0cf4fe15d53c3e6190317617ad21d01497c47bac57c9cca8fc5aa337f52d3a5f1c1911668afd166ea9ccbf555b1db017814e060ebff3a2c5dba32a9114ba723ea084424c8e76f3ca095690c469084b76cabb8d43d967199f95dbcbe2cef2e843544778d2bdc0533743b99d07025c0b8303cb363751421c97905410b1035025f7200187ea8a72394554bf2d87a42f5ceff501a40d6aca69ba0afada9fb2027ac87bbf19ee0d415aeba18251e82e83d908f4383a055f5d4812b5d487441204ca2c51a793e22fd1dbf15da6c16233156e70e0a8e292b5862ae74ed1af98e76395ce1ffa932028362a76c08c76d7c8de96feba82c2dc3d6b7d1c91be67a9649764a306de02d2ff1e487cc5febf97619509cf0286903702d8ddb5bae2416ff16c8ff37a0b07f945f075d7400f376fc478018706eaddab9e3b0e2fbb1771c19568ab5e5bf13cf414c92b407300f590d74bc00c7c3d6e04f911d576f8fc160b857f59749ddcba42091b3469bcad3c79f0b32fef6494eb25d98df2886b673300fc7e95abb8376424634675be5cea274f864886dd3cda5792a62f26cfa63aa2c0d94a24e3512aa16414f222ad22f99aebb34aa6623d4f0d38da0427a5e9402a514a481be7e1008d2449f5ed8764a2d9ef8b821593decbebcc3cdb30d1953fdc7c9ac3f95762b8a1cc6694acf06754c3ebe59316d36605a008e57a878e92d9f464795513d36e339f6680b955a8c8240c021b105c4f7c99778b1e9f1a4ef4a297965e804a49b5663f5c988fe31c1293363f6a2f6caaf902dbd41aa98817058575c1d5a4f14e6b16cb1195bcae21475d42c23477b2d2e7a342b14ce902482a8c0eb937b8265f31d33108a41f5605e4aa9eac42053be74fcd1eb2fa3e68e668df1614935e8be756cf3ad8fa88af590da3b57234757737904d0dc0e14030d8c8654fc24d07212517e310d01406b4a66c11afe5c30084697e0d651efc8c2355188bf331248ab8f03daee720ff8524eba4de46a99686ee1c09f27cf4b0a8dae53bd566317c8dab0ab7fac52c327b3326e1b1dd9ce219ac4e7271e8e7622d1e2db066e8ec70d7b2f12fb286626d7e236d01a84d246144ec0f17c6b22bb1f595532a33c1ba1c88b110303969e9a9ed753bcfe679be02aee6b8881fd6f69c045ae9539c339e4c01ce9c805434acc766cd0a3654d5e40c37c045ab53ddd2d7fa847f1c1cd8d7594cde565bbc82ab1952231286501e632190ff359fd1262a3d4938576a119e4cee0d9691ef77163ce640c3c80c958553a1565e40e1b3d4ba620177436613f9387db61bb18e8470b19229b301c43aa8ca006d640ab49d7b46ce60364fd2e7f996acc9b088ced1ca1270ccad57720497ba466772444c5d6f06711bead0c6a4aa4fa412c0f98e82164a7883efecffc3100d9b2b4c5cdf4059aed17ab25ac34c2dc2d79b96238f41a265bfb3c270fd6ae49ffcb9289bff4c412ed31a8fa54bdfba5d88410886557507313d766560f8840527491bdca923cbb90e93a8bea396b4d755b27b2d19f906095d87aba52c7251e8d34599cdb3e13ab02ad2476679667cc2528aa4de3ced9e3db6bbb1be331336816a3bd7c98426f7bb06c2dd24e580d50ab5008a19c85cdf0881134ff276dddd86ea808c48cfe3d49e91b40ba5c64b1a6d688da66d04919e3d10a3c5e44d43ed9ca0f8ffe074ed7f2d6ad67d7f1f3b70106e936aa54b3ca68aebcabbf38bd8282f43410f9bb2f17d454ea0c3e9b282d96f0a6d97feef366bf6fd13a7f06de0ccdc009ac8237aeaa1ea18c8e57d2be17526946bd50eef15ba0638c4a03d9222963e6f4e5e794d9f566d25c7c9427a44989b0bda251453bd6f72290892df46dc0bcc78f081cb3577a0595611af8ca7ba43632bf0a0c5cb5fa24d6d91f1c0ebc6415528b425e19871f0e0da7b3b690297ddcacd94191e94ecd3b806e45ccd8acf5fb11b1aaf3fecc238364679fb17063200bd66fc710a0a2beaf483fe32ca4889577f69e5ea4b0269358d285d24a2f4630e6c8da69733821efbe5fd9260836876618597c633f26d6b3db415c06ca2b357722430b87b881dae38864e1e9b8e6e00bd3e46ca666d6a2f1a29691196f478caf36dcdb56feefceb8e6ecfb477efebaef7e75e153279393e5863589b44690c6ccea3f0b02822f665c7b2ddeea3ef6ec0bdccf4bef1ff632b061c591359257a39133567559af09fa1ea67562a5f653fa8c43e90ceab34fc1f6d160571e97704480412238c6252de46cab25b6408fa23d54f76da2819ff78fe70c7906602e84b1107c39bd308a7d05b589f4af429a04586b3fc02874a6330b0e8cf24d465668fecd5ea1f4cdf4aa8c4e505eb90543c5cce8c83de3d6c83b96b8cbd9078a8f075ec04ddb163f9cfe90b63b2cecb8184e4e8c119a0ba21350b58200ffb514b04ebcb6eb4ac7aadce8f4e36ee2613f231e5c99375f8e2a955d9ec31aedf88ddc26c8bf3452733b32c5b24efee83f4fccb9d82e4af693d692a5262c18cd3d45566d6d838218f8d24e2efe06b513bfb1c6287a6af3a979a0f08eb9e3f419fdde7e3ae3c32111a691fdd3c82508bacbd4e03bbb06a6fbedbaf1a41613d7db6f2b03a477fe6bf9e7bc99d42b4a7082a61fc9f597666d80e5438776ebfc90c1876e56be601c5c3e13d865a41b24eaec10f69f3bd89757e34b1d17a5dbcbd354503234558b74c110b8cf69034093d28f54e2cde65266810008a901bf6cf8005a0b5d9100b96a4749dff505bc37cc46e6e89b728eba8d82f9e10546b626adede3393abfd7f8b3ab5851e539dcf21ead2309f3fcb13c529ef4059e40d0c2bc1afe6a7a2811512572a62caf2187cbb3539561237eaa2dc2478c0d9bb08df49e84756ec940d3615717492e73890481548bc13b19428dd70c4dea4e9c34467afc7e12fd67917877367fc33b78b08c4c67dccfdf48d6b8d48b072b254bdc7968bb002bb212d449a8bc93874c7a0e981bd39cad4fb9a6fc8347777db3582fc7cf9d49575c9848d63b92c10dd8c962a707f6e7aa30259cd3e9086f669163f58413e5b8e7120b070397e50d78fb2e44c1c79ec563d79b9322b5eefabdda7b92ae4bc05ab87b8fe7392d7a09c2abbc3d550a5a8472997e7479b09b78cb866c137748ac4a7a7d2cf5bb4383c1aadbffd6647142bfb16fbf69888ae9210c0778a84b3b564a5efa90a2f5a74c0c746db53a07e81fbebc3cee8a00830e1963cfa6896007438ec051d2eabd0847d31999e7f12c960e49c43feee404c826a99da38936b5bb2f530e8bfea7d99b795316668d3fe00187f3dedff0ab6fe0fce5cdf65c4bfd4917d37a9944e77fbb9ca809c73d2e25a73ee6ba798f46876cd365b572f750790553700baace25a3ff4998932deceb8d0633d21b97cef5729d651d6911bcb1ad513085aab20933eb4e09eeec452b465621d4449c6ac26d7e8562027c19a8eb561fd38e0eae0f5a322f24a065692eae42841ff5a01b7ed7d24f9444848ae512aadf11fac1ab588fb32e76040c546ecdd354f2a9bda2c8ee1d9be77da9e47c6bffef5e8e30f1d5d21893f58a79111652fac99dc7b22854a02e4897e185b0ccfe4995a367212d60b573a2046549748be8fecd237252f9315ee59692677e0284b470220187eb69d220dc828cda4327f98c8bfbf7a4d09bb50b721938bf2d7ef1c93559b5c38cf8f7bbc39affb3208d8780af08e517d551eea5cd64b5bf5a9523c619781a8cd77c29b838bff63ae1f32132f874a0edc27f1b9ef138c822f6a99e5f43279a0f1911a21528d3332dd44e8e93114180b14729590e5a62f47a9785d36c73ddc4b496176936a89265f0e2d4e7193e5b2775d611908a8111206ca908b2b98626c3deff8de56587d18834b0e2465738efcab49c489e355d4f253d2f56f9f6b36148e82e394f445b8728be874079ae1da25dcda00c7f34cd369e0b041b50e904b3aa92f49f1056d4609a07598d7cc0a7ff0f6b1fef871c6106599c62bc12d3eae43a8f29ea15d0d8bd4e86c9303bcd9f8c7948bbe9bf272c5afe063c7ab04f8bc5ec73e9124ea975ae451a9e9f67ef817330532ba8554c86af65ea0e13a807432bd9875cb687485348470e95169df496e70276e775fd5a8e17b88474bb3033ee01a0ca7b69712fe6d69dc1e86140269646756d780502eb2e6a09849da4c907aa57b1797a7617bb3ea42d181c6a3e493f3945e058e3a5f4828103db2744d838dd52ad76dd5d7cf0bafdad3a6c5865a7f4299a0ee3989e88cb7237c1e1f8d29069de93858880503c6254bc4a0fcd3da0df3543a3b29a457206ddd4e73a59c5eedaec2496f011c09fad3d680fa5418620d715dedf828d3b4be1d69069dfb06842af3450534b163685cecc92e0153473434b9ec83ea834b3ca97eefb189ec48edfac5bdff0e9775f077a75900753d9535147f86d8d001ae617f6700a54918339c45897d047c8f8f5d0fe17b46d84f131beb3e16034f5d486a6f92757af721e49ac781e0db6810a2a96bc6c37272789640669de22c38c8fb8a6daa459adc2e2ebd3e1ed5d916bc292757b90296f57b1ddcd3edb93aa692f5ff5f554c6b1be3b7f975118ee881b30bf5fb0ec017a1f9becc65c43af4bb3edb0982cad871c55913d680083ca6098c31b0705a4550f6eb16b81525283b4b802a7f68d8d700b03d1c0fe75bb77b25f6b29c017bb766f463452cbd89aa03c3312510ffabb42177b5198076b473b7b0ecc4ccc673d33b03a7ce59c071741bddafd7ebba7e99f207534e8f3182085196202577abeb46012bb43e55713ea262125772b134cd97e7106d1b399d990ef4ec3ecdaa1e0134e869f0af57bc3b6d84cecb9621ff39b7571146a839dda8ba5f582741b6fd215de31f7e45bf7ea2b842827e6a54c2bc1d3eb3338bf42dc17c427695c217d38ca2b080f0b202aa5c801013b726db0b71790a79c51607d56736a0d0849905a8e5f57f821f1712e0f47927a84db32902c09b98a2302e788f3f2b8c30842feade422201d8ffa3e0a781e4b5646d38f5bf17c78ce7c0a118f73139f67e86177bf98ae2c10472fd5a5ae56323c442de3c579219c06ce6cf4d9e217c900318c1df9da7db49403d246895ea3a5a7bc39b4a11f340a76972cff08e4645148188125c37be39d25201f21680543f4a7f5e80d7a633227f784961907f5f1f71238204f788e81f2ab657d863831eaa979610fa2362fb579030b2449649889a5c0ecc6a1a9df59af2cc401f3c50ec90ff9bc067423d12898a146c9c0a5f56a09eb89a45bb91feab2e936a46b7a339fad2af90e035584de5c7a7e2ee540ebf57848b9397686be90c319e0ea5c0330de72504d0e921ec02358059ce352e8670cda429baf65640901f8c114b03856fbea484d368c482b43f7cc5113749f30d5b5b61f8ba024855ad6dd1a8e81986b4bbb9339768d2b11bb26c0e26f07d58115354c7bb808fbab06f0897756e21e5bd257afd3a2eeceab109fccf21ef816cf832ac56262d0b79dca30558e59b3fb26c4a44a86a935d4aa0b7488ce86322794dbfe8061283607250efb386927de606b651e6ad601787ca0939f98db6e7e8a19ec2ecdd5f82b55e628988c73e0f577b7d0019e01306ac3b2764d8cbc35ab10e4719bfc9d555ab01370bea2bf173e8fb2ffe203db7958eafc8b438df71b57157e0b721aad36b2a202424e8dc1d2c08014730e7e57d13af478b660f86801f55a4f925b112994303c5c48e4dbb133ba4851b049bd0387d45e7444812ba0d2cd81f38c9acc105a3425a1e64629a16ef0933e8bec48a4c6fd41135f723a68264946783baba3d1d70f91be143720c0a293e23c818cd911e711e3fbc6949a9d80c079f11396c66ad1379250eb22ddaad03cb1de1ed363e43ede49c09685f90263e8a380243d1941b13f4d8b1b2b0254173a0d9d5680c936924ec0796e202392889da85d97a782440528ac4043eed457b59dd6e9e3942b300001e8c9099d06e896eee059eb5cca7c9b6174eccf723b326519440252e3d2932a77145366c065e0debee6450cc93715a0a75ad8e406770e68569e343fc881ca608e8e620521515ab348a2d1aa0af73ab807feca79727da383009a586b0d17b18092d0bad152bb5c5fffb4f3855658829c36fd36d65164439b61a0b35a10eb87096d378abdf78971ecdd8cea9ad3d092baad38197367b605d6b113d8505cd3c8f75e2711a524b059d5af928e8c2b9a729885a07e031c79f441e10d359b423fe266ffa5a035d70d51efe6a82618a40dbbfc4eb543179c1dfd85d76247e27b5ba91bfc5cc0b947ee09a33c6e8e598e8d973db4aa09d78b8075d3d022cebe4d1a4b1843dafbae239e2f2304d62460b82d227ff3a09a008d84d3f7baba8c35c70fd6286c7485b7b7c76ab2942248eb54e3f864a7b525a677d9ba083ba6cf921e9cff8074754e99083f9713ec30d7152dbb5b7b4f5441fc83abe6c2650cdf3f81232063852bf20ecf1d17a4a16bdb3693b8893d2bf1d32eeccce430f5f77d2ed0d7b4d1a61e942854703230334c71d612ff942c09a46adf73c09d8400783544490c67dd2ff02656d6c95670e5ef0bb30d82c4433f57758704c54de099de723c286aa826a610049dbc0d9571a1f7e0c0797cacbc017c4dc65491dc829444f16fd87f8f256e0c933193a6e25879dd40352e57066baccdf0a0703a4bc546550468d4d66c6311f50af40f48f7cf1b3ec867b6f4aa9bca48e72e2d6cb582eb6597777ee2fbe578aba7154c2b3efbd1cc7f68930ef6c7433d07d5d7e7f7f1582e431340e2cb454b4ceb0e3b657668d156a36a5d25b63be917a174727dd63ff98b1efb6c6f02a14d48c6e5354d5581bd7b1874576b08e4d15c9dc4f5b851dea98fbab95769b7d8fe13446ef333a5ca3601634585eeff57a37d41a986e4df462bda84fab9f380eee56db507e0f8b0476422d6683aee07b183e9cb697badfdae61a0e799190087794228397a2def6cb3a9679824f7dbb96889cb1e507aed9525ed07b6ce3ee3cc1b5c9f37f2f107457ea6657d983893bb48347bec9caa54b258cf3d091d36d00756ac95380644bd56870562ac604827a59c679265932b0876e042a0c374fa3ee12fb320615a2e414884dd86433c0778f18ac284d7e06151568739520df3fa2aa0b79d7cc0b0aad9af134ada6d87294532099c8380209fa50fcfa3944e65a5e9aa09550d33be313bc265ccca065b1da7567b127112d692f886f9470e4d42401c2bf5404208c3064ff4d69299665139edf3a361b03f51132519e821a67c4d11ecc03c94de6e0eb4a28c920c4b76cd3ca99fe34a6524fdad96dab068e245fe2f09804c2caad1b6ec11da03e70d31584dd30cf67af32c6f3cc9009f727aac77133a091ebe9bf37b465ed10296eb96efb7e2b19d30f33818c26ea7cbd1f2b1eab5a28ffc9d4dfe3fb112e3847eab25480902d655f4de77937f98a3b48dbca707c885e902fa9dcb6f29ac34445fdccef273bb5829b35925709b445c0bd037d7dd8a27e5b7c9868b548c56a72fd4fb1ded4bbaf34cc57e6d62adeb0cec501002e46adb751f35894d1a462f3122a83921af2295a5c084703ff72557fa513d5dbe90d4bef15bce3b11b18430032bcc73be4f0f54e5fd8f9d9dfd57a123e69cffe41f34dfb076eb7d813e5973c1d75e75d5aea2b5eeba79901b9a229ebe4bf46a816a76d2b35c612579bdc57921c10d227fbdc449cfd0c0e413a7fdb0690753c6f6bbf1c9f8ec7d881b0e1929775be679e3dda7917cb4b532c8afdff63e846cc6c501c67a2c35e85198639cfea29a0c8a33b66578913ca65ed282837704ca48322108a181544ca3ad4b37baa3b5d34d282001aaa43b684cc6ed87f5807044cb8e45b4a1dc0d967406772f2e2f961a6d61350d366aca903ba631b4c0ba65b34a6fc567f9eaeb5fbfcaf815c99d3addaa2867cd5a02e46290ff8ff4a93fd977cfb3048deadf8f7ce5b1889b32e349b09924baecc49e3cefc633287cdeb070db68d069895b0874707a9d2a0a7ea41c2a767163ec755d2c63bc17788981e2d9a31920c531deeee79ba7909d4012f341451c1ed94d214d189dfb94e4ad997fc56009ea945f6a1bc424f0f858b7fb265e8d131e22a06706f62cb8d66780642910d50f9fd3eacee4252d16cbc5a3a6fc9abf47a22f2b708869207de1d4795284e2572dde3a01ff0258189861cde59e325030955ab139c929419d75fc258563a124bcb3ecd6b0a16b63541d88d8d2d826f8ec3975c6921074beca0003d6bb301c3b54bc15f3968519e552d040cad0aa3e2c0590a594a51012e631ce12035f28cc4ed46e56586a22801e2e18fed1452c496115c280f9b8577d12e90ed5f9d6a5f6afe2b402b64dffd7664c97dcfd219c3cb2fadb12d465f1b15927396d2d834b9ab31a5dd0b84fcda97400dc8ee90de58798a3ea0db2107d18e7f3e369db93390eef6f6b78204e81f53b1523a7c17b606f517fb97387bfd615b56b47129526f93addd18a6190d8613f4f58c1b37970051bd32a12e4affcf486da6b566e577b37a954d347de4b3e36c93fada115aecd72da56f067a3733b1d921486ac3e5a5e5a8ea4969175234beebbf1996218ee9bd0b888185a3b34a1d8d60da557d3fb1a00c445e8e5c1dec5ec43f65136c9e2efdbd94a4fd702cd76032ec1af3c39a0bf1f654a3ff8860cae89f7210b7eeab95e73df2daa3c5fab09eb2d2a225babf619243709bc4ac24aa4af506a0c53f94109b4a4b7c4d5323d6817f737f15b3ce194ae31bf2c4af16026349f647d0ccc0ffaa7a9becd2285dc2d3d0e19c0a0cc5584d1d5faa7c7b616abff67efd36da2a2b4c3dd7bd42a32476359e9e23c98cc6daa88e43c737a95b716f502bc0b8a413d302382468bab744ad4d9a4bb781e8dda71292dfb2e92bf7f896cc85a2d1b0c8b1099bf922e28582ea7ed12844b7cbad623c14784f1813b64298da901ba743cc15f0bac1f17e72feacdb01cd9c9e87227c78e91b168ccf6f8eb472bbc20ea4c256f243dec12c37ce2b9c273e0bf62f563230f92ac4882d7d3bece546954a53108899193a2cd12f8aa2e0f8c1e64ed82cb75a86812a72b29b248db372a762e5c8688096d10606a83d4066e5e17116445ecda0fff97f29810a9136976b002ae95a158b855162680e5adf6c3372ecca3a381b49af3686c51e6438e482cd572550eba4d21ea606ace8705303495b1dbf05352ff05bb2cbe4588379dc54cd44d0438ec9d3d8d9bf446f4f210bd1feda3a981509e3f93257e2cd06a9c85c9825fd75e07452b7a74acef33a88b6d98f680e6e50d5e7d33ebbd3bacef4c339c367e28066c40c56492bf01796d5fc1a92e040e0af7fa8334b0113f8e227653ba087ddc3d3bba9c40a1ed3a72a66831bcab7b858a7768487afe3d07d3b96470b1778537e30c4e79a98e6844ebc1b4a3a7253e0d6a4d40c1250a50cc3563647a0bb4c7341bbff8da3ba1b213a3f621e25288281eb69a308a927a67f42550ec8384630074d888b894c4c4851e4a0a14f134522e699284e3208108effff38ef383e9027c923a59877b23aa985f66f2be9273838f882fa647472001b7afb60d3cc51ee446b99fe7f748eabd9d61510b54198cdb93dbc2aa2cc54c6d90dfd8afb8cd2cfe9b8ada5a1c61936fd03d4f2522d2829d55cace7bbcaff94bf5e91afa1e71e25e369b3b4a091f2bbcc15d1fba4e8f2ec08222aa3fa6cc98fe0cbc2af01975eb378cbeb4193a9c7e0a8e953f2e536ad5f71690c511f4fa58f09e5c81c43992ef2f9394d9de799c70613220e4aa9afdbc48f4e43b7bc0df789a07f4f492f99e81edb0f583500d730db42cd6e18bf58ab94873383f54995297e45bf9e5c8fffd63526f86ed514649b978a66c758e9bddb4a4ec8416599e42d95a1e925975d6f6daa9fd715774cfe1d46a64f33730020001013a18f7c7dd2e2ff7fdd5e57e322547773c0e96e7b754a7f7c16741dc2a4542f8f76aa99559909942baff4b4d1da7b338237f0d551170180f722085263017bcf2c30787b8946c64c3d487fdeb723fe5ab04c9a786703bd4c0d00d87642181f7c74f646b41cb7688da19684fed2fb60e62b702f24d3458c90c4ca615febfc0f1eec21d39851646fa07ab2820932a721e275a5a9c235b791aff0c1b297c84132fbe11729a5cf811ed4575b4b932f308b711dfe7fa6cdd418c0d3b55988b089725bd249fb7c36b390aadfa731d3b561b0ca55f03412c2957d2c1a3b54eb14e623362e4ac4bea9a0afd010273eb20d7f844e65b8cc455f17892cff0f1eb35ac218cea679644cb22b56af037293d969a5ff0c004a930c09873820ee2522b9795758a7b98aa2ba3d4142fc2735ecbe0b2ef96f68158db831362778f8a72ae6373ca94f1f180ffba5a68e2738b92a88a6ecc6dfab7a1ec53bd71b477421b312c82d095acf5c6a6bb33e0a247131df9accae0e6c8cb95c776517fe4ddf3515932014a3cd2e812376fd3a27c35d2c9de1c851f93f31b02a2b737d0648b2ed2cbbb0d0d7f2d6b874f73194132d70019a472e79eaeb09b40cf6e989dcf74d933ca4eaad5d5054935f201f5084d663470b92950d43eb683e6ad6d701285cba1ed7ea7a517d38ea684a833c39619f1a59d5f055b4360089437ba6570e6a443e3fdefd627302f7c198b58d1bb2b4f1960d72135c99c058e9774b9d4b8c0fc887fb1abc722e062037f4c0b316f45d83da30ccfa5a1ad6d4a1e4f0d696750d31c61d5c210fcece2ed4541e30a424c6693a8d4a7d9b646ed9c865fbb703eb667c30f38b63c8ffe8bf49f582162e71c8ba17ae8c037e2320e178023484dc8b5950f0625de0bdd1be99bc99e41c50043c679149cc303a49c2ebca325eae4401ede30507645ef40b876e95bfc847fc7003100f8026ee43ba1a2723c434feebc596c1276bb28820a3846032d2105a21569d59052a058b60b424d112f70a7912b56ab363a342799ebafa99818bed2be27a08d44479d2547d593e72a51f8f1fd1a0e10b3f7b37cf5386c7fd45020c3f579faba2d7f82c74f354f777b76bb2b252f22e8acf6f715424bfe1df51733a59b4aac5b13c","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
