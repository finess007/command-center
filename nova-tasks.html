<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"23b697393c0270388beb083562e2ea52fec937f2c9aed0e146d06040bebd4bf5ff4f3306aa136be7b7c220ca99e3c02ec074e2924971c89878abf3f211726dcbe117bd78601e1daaca4fb174e0a36ee741da51f7f48a4394a355129b0fe40bf044331742c69f151091dbc4541b31eeb4e9b15b45b8acc4f1ee21c7d11dc384d519839c1d4537b3521a925e2946c7c7ff1e6f702f401bbc0a5e71134521e42caf4998ad46a2dedafc81d6a7f355f5087764c160414c92c7de4f297a5563dfd7b6d7b4fb1cedde57ba60f41c1a49168209a60678c13d91a2c8dd30ce04b2a4e910cf1f44e2488dbee38bb993f3da0435818eb6fc7c4f55c1eb210336815a5607340a7bedd716c99ae30608153a17f71bb74249c417eea642ad837f4c075ac6f1ff694fb90883435552a011048351a680baf0c3121b438ac82391474f4937fe2e1c0fdbabfdaa0ebe3095903b86daaf7675bb1b20b65823695e2647632a13ea98877c9bac60273d86c545760d6c955c49f0d5cc4499789ab2d6fb2f5f499fff7647fdda6cd0d6e2e8345ce695bcfac95d873772782e210f0e4761f7f9a2b391aec36ce767ef8785e26b8400caddcea96ab1884801ca66c18e771543633ba8cbaa3eff554776844a701cc103b6eabd8a9a2df203d04da631e6112dba50a25cd545969797dfe711237e014e5a27390ded2746c5f06d2e923101d9f30c378ade7ad66e9026d99371ca25b65b4ce46b922f354cb08b397e69ace820390fba689045d95d67f51ee6809b82cf062ec85e944f095b2fe8010339bd40b104a0a172be622e53d22d6fcad1e1799a692813962b9d8a00cdbebd462d748f2cc47319c9225279365572fdd863d2dd9473802b8e61916d689ce6934988f6421d1e90d9f07a5d28a388094444fd9cea312fd28984881376fcff6c08c8f1829013ab9137245e92ada31771c7cfa25135b014f58e5f182bc51bdf5f4cb3632921800a38c3495c12ae06a7391e1d118917d0fe2ea2e14851193842a3125d36874d0851407194758004ebb6bda126922b062ae68115a94ebd012e30a9313ee6e3a44cc85480c85cca766a2892691d35a26ad293db28097f2b2a4fbd7705acf04c79e81be5eba1c56fc2116a4b093462fe5e288aa15bfb5b87a4a2e19e5a4bace390e4262718123c1eb3812840901803aba3b4643111e1fb9a1178b8c4ceebdc954028156da5021d2ffa063e786d066d30a121881c919ad96cb1482f9c71c631be5c7ab40a85226840c74e145528e2def003600aed0e31979df56acb58aadc4b9d3003133236834261765553391ed29af1c5352961d2e83a248e9d8e761b93a66876633d560b6bf6b75156cf47c87eac4416d1f3620dc96f91915ca51e36e2f94615f48126c362e2cfebd82aa70124c211fe6b4c9454adb54396c404907a0990e62b5ca7a4aead21282b15555328c9eac4b878c9d3967ed57358a9b459880999cb3f8f0ab17e89922b21436a4d63d240f7834b60797533f00a6b75bec6d0958022c1255ee5b8856918f8f985b400f161d617b7a6af8ae87d463ad5d8536915e394957740bf37afa65d8f0af76dd7ddbb6bd2bf53d895061ede61c146a9315584bb6972a6ff4ec1467e4786a643e2849c65f5157057b68d32ead42cef6142637dbef46ce119d5529e47a091926e13cfd3865c73b54bf185930575d7db2bfc2d3cf68df35c6563e39e5985004045fb7c7634246de58368678ca13ca759d798b45e199fdcedcfacfff308f54165b58f038332eeb57e59ae4a842291b2dd35d86d4f83aca415e3b6ac56e4a1feff7d3d0e47942d4e65c4e15dbdfd3e20f8ca450c8c9ed91ad907a4320e4ee69499ed40a7ab3037bc8ff23e72361ca69e9c59b7b885f998abaca80519630f691bbf31466f5e3013e4670f2b5927f4d451c39300f670a8603c0c3179a24a2ed1ba45e9c3816803d11092681a5090d7744574d79ae04aa9ec5e6bdefa8c5deb9f6e15aa380e923e9370c5fdfde0a00e68d42aae4da4fdce0e7b9c1021c7dd5022c51a2fc459a765f8bb488ea8394b2f811984b7a3d46051407df56d607e144311b1b3864d7fa91315139aa9252802d71043251a80c46603bf354876f36ebc6053dcf9a15ef92f4f55b7869eee57334fbabcb78a9478af15a7ea4e6a298ec896884704da3ebf20e8626018fab0d3cc4cb034fc48f8d7b7602047b27e19adf1948deb6ef87222e5048f8be9ad60e4a09c736f4d0002a2a0dfb788f00f455e10bc65bedf662cedfff6213a4f54cb051588e3f724b38e81c2d2102a1d6ab3521d7f394107aa0c30b0320b456033dd83df1b876978c3a769d79096f5fd87c5a7a99cfe75de0afbd98cba13c771de803571def68eb414ec1e7c8b785abdd2aefd7e166b8503671bd90062c748d423a89a8fcf09384f10f28f64fa1ff8541a7ad37d1afae7a97f03bd8be1f3c430c323dfa3033596f149e62c1a3f3c958a2981ab5ae3ae84ecbf448b2d4566a6e58d5730269dd8b4afc627696d39c9b67413b7576fff12c3a271924b731ac4849aa609963c095c16e6316e5dd4a299e7cccf7db33792b171712a397ea24380236f6bbd6f5f790428ea27334d33d3e2b269f7199aea244dba421c12f674589508d2e495d3ed40100c4ed9d9781295e4f368309fc3271dee094a2e4668903c0da9e51da36ff334403e8a4bc724056372a411fca39139e6fcbc47c9668ed3d93f1eead1989a1270ab497c74e3d90dc59b9df661a7676694f287bcee627af4ea0a512f9d3697a3ceda48174cdc0b5f7b5cdf6a1a6aadab8d8bd0b984015a4b1eb928c1eb540dc355e37bf5863c7794b27630b4d5a61bfc2151603368d6502cc0066c71f1cead805faa0cd2f484197c9a3aa247e9f0bd63480576cf6c5a25e988622a0ac36d1bfddb99abd9b329a25b5758b9ed8b071dfde3eebd46c3d2ebb6522228ab4b2f04ae77b5c97794eb1c5479c67db2436cd019297a4c954b84519446c0563c70076c572da1932645ff23db4d8e2c2a130e62c0d21eedfd058eb24a481ac2c2342131e86b12e8d323ec9a43a6b3ceb7a2df5d7b5cd703843f9e9e39e48083c830a27bb47af9b9dc0ff06294a7621f1f1f684dbed5e3a9aa411f6302b5d665a748e5b886b29858d685742131d524cb36d987d0540bdb1df1687512e2b19e8facc4c483bea437f57b8a6a79944afe407ac25636d5428ce5d0ef8fb6c438bdd79c6f0aa20bf256a8ee2012209a420479e530b7f52e859a4895dd3c3914971518670287f3f21fd57ba1ead8681b35855955ce3995b0c66cbd3458133984fb74976a222770154347f6fd4f85345a206f10522a7f60cc84854fa4c5ca064dd3de048bc33afa1ac66b379f53adb436bb34b4616a78489be704e2102961a48da30a055e240c761a1a6e17a248bd334353887a53278ee37528ab06361704f77f64f7b32f551d703649d6c6a0224b92d609746308c773a71a72d35e98b872a8b62a89fb56636c20e2d55be96685672cb78ce1c9a36811f5306a095bdcaaf87c19f5b22334359bfde2afa56047e734e73a657be7a07add08ad4e67812946475828f1e914f4e6acad7524b58162fa50098a701589080acd7452efa80bef177ef8d946bfd0e43bb523973a18589e00ff39f1a545a21a31a30d9084d6e8aeaf2ee9116b852c882389130489a0d4a9ee8d80db5244fd7b64ffe642fd47a759fcd6c0aacfac3dbd0e48ff398cf1392853eb4e0e5b672fb84b8e626520a519832707eadc28984220f8626c14f0845b696960fe050ca90392daeb426494144e87ad13ab98cc1597a1ac838fef4272eea67d934f45ba2eb64165acf486b68a439c53f8c4a93dbb5446c8281516984093b3d443a2dc8cc120dba5caace41a5c16d4fbc59ac3c96d46af6c45964e4c149bf090186ed9295a48b8bace4b9ffeecde6a09df55a588f2bb91fb8b3141c1d4536a93b3f2556dcd5a5d3e6c49435623151f24a127d49daa2c092ebf9438683a7b70c45f272171331c673ee53596a9985aa4f7754b785f440dd0c8ebe2299fc9456f8a75e4d5e6a6d954c2f6a6cddb41d92e96434ebe40125315bc2c5e8053a37bc3e07b543be23416483cf1fa4b9b4a793d1f541c4f0353d0116e92eef31d83c6a307dca928ed3dacdc5c358d72d43036b7da71463d8c7b76cf8ad3f749143ae26ff48ce14bc20bfdf8e1a92096cbd09edfb73ecb14fd7aab44a22ca3899ac2dc9aa38a4b447f5bfc5fee6cb8b369b4eb04f4e3d7d55df4aca809823c778bc1a32f8444924ae32abd5c0e210642aae10b3ecb8687f83905c577244814d6445a12319a3364cd270607913d13b4d27c2d114b5ccc9a48182f165a0ba5812cb59a4d8bd6053a8cd294c7affa63d13aa6cf6f9348d65291bafbaeef4c6b5e87094c71e42d9175bea4e8d8555aa73873271a35f5f24934ec03582cd392f83172a658805f64c7d179355156f694b1e959f2f8ed56ec281b4a8d5cb1ddb334efdccbdd690301972291543b6b327414c9bbcd6c1693c446378b9840303e752c60a48097a741da2afddfe71613c3301305a070d0ed9bf675a139f75cb8fc2184f14d3f68ed7cc0d911120152eba7c7a0348f5bf347411b9d261e1e88fe85798f541177c5c5267963c05db36442e6eae1e802baa5d5b274220fcf16f3026deb5bd815292e070ff866b68ce86b095e47f0c45283b4140b72359338918699ed858e6266651f48d33d7f8d945d97ac1784342eb2ff257f999befe3b3adf8823a2ad3c343cb1e1b7bb34951883b3bb68956735a294147d4f66554a1f132e2fc6d71d593bb2420706a7cc3d589d9e7e0257357b497483209a666ae41e8f91ccb9e0488193a6447eaa43fa2f830c45f6285e438375d1ee07c40687673a27f50fb4296c1ea5689c520a3eae183f4d21264f02794c38d22dba5188fa793ed1cc6570877d327364aeff91c951014af5f3085f3cdb0f12f96729afeac33dfb50eac753b0491cf39a3fd9d38504bc3b4f6079f4cb5ddbdf768c78e19d3c2060255f503478d5bb87602fc5b567fd2ce098c60c2e52749d86f3d705b7b2df83df309fd23042ab89b545e9f51c9578c79e691f2e06056c0d071349e4249255ae0e8e59c44cd90354b01a399697efd92421909e8390a391e0077e289c1788e29c93b544c38515f080e489b260bd9aaf0ca784e8c7a9969c97d02311c87424fbec45291d86a15ad66d44a3d33caaa215b8c009a3874d94084cf9c6e8911056cbf38f2cd42e01a6e5bd5ee65e5072c2a72f8bf6cb713267754d68a44272868f36f5439e1367b5ba648fc52872e39058a5a3ebea3c4f53a37d9f934cf88aae233534610dafa2b18cb22ae7bd0c3f2421956dca03d71ae04611de38b921fd1410cb675d7ac230a698d788478ee6c829e035538e93e4f915a7d311919990f550993844e1e18910d507900b1a087ebf8bebaf86bfef2c28e54f48c943efd3419e9d19dfa4061fc2a982d3d7edcebd3d54f059064983a30db599989dc9bc0b271c0c6b74d08a369927892db9eb8a786821035fc39df4ab404c0836f1f57c7a7981aec626aed904d7e4133d5126ec5eb811ac4666af0c18b13db528bf3fd93d780863ca4deeadfbe25caaca223b79b6afb89c7acbd03fcbab87f30f45912559ecd612c3b0543d175b70459d3a86cda97768aa9e3ca2416d0d7a5fc51bb5b91f0e7bc19bc91f9b66e3a5b207c3c0fd9710867634f069e645f73ba00afa2a8ecbe999327a56d9a0f68061b24042930daf808750d9b54b144f3543f2bb4955b83dc8bbf275799e481048f5928e7b189af4f36f52a96f70d37f1972dc71beefb0d660750d64d668244bdbfe3ef9cad29502c94ec9af248bea925db25b83018d8d3f710ad85518e84c98f3359d572b0b583686225e14dbf8a1a5586985436507f08b7c9c57c48c2f4ded6a546bcf8ca87a87f8eec31214299d322308c53fe809f50937cc734dce6238f7b48c0227dd949173d88955929a91a5524d3788e11f0b862c97bda74ad4fbfb9c14461a4667efe373a3ca289df777cdbf44358c98def4aa17eaec26146f41e2853e7a7f0fd89e2ddf348eb03a9387172bf909c037a6fa25b3068e0e6710bd98e2e4e25b30dc4de2deca8525299f798691d70871060a2696d6216ac2364e80e73cac62a07dccd2eed8d7f64878bd40790319d8ae16e46cc716ad29575b67f7cab71569aff41e05fa846cf92a8230924a4e4144263ce72c12c8b140798736c8cae6c39d8331da173a61d86f02533f293a2c740fee5f86cd72ec876d9df48f8f74136d619b17c5116d42bc2489df5298be30df4bfc69ca52a4bb0b46d9af6114e8ee53520a39cf2efb891c26fb70ad978a3ec82674c5a97abe1f291648c818188d7b1b33241fd5ac9cf82e827cba869d1f3176daebbb5ef43763e2d7407cec9d8320b8b4a7894cc5fef7e6e040ad3e74e4af61df0cb9b07c55712853c56f042394920e0f9d232ead5728cc44bbb30dc66c95f135f9fed4949d27d3affe5bd64e440e38c30f9ff10e36b96729b33150c9f7bf55e065a4c3dfc7ab82ac52affee3c32c70391a83253ed7355a2aeceef228212d409969e37e200ddc7e3611c853fd0a38d6a9dd783f47ef9598b1b0596384942c398e2d98539f3c178e295254075d4acc3f71e9a0f2cae7575ba1a2303e6f7fd03a1a74fbfba047661b9e28a7c81d03501d0498b8f789182f445d88bb91527302d20f069976859ae7b18f89412d27c01db6f117769eb5ba4493bbae0e26b37010ebe2868a644bc290b6832ba6f251400ef128c2fb7690abff3f37d0521bd21df378cabf31e60c8f64fcb85f3ac012593eddd56e828b6ea33d04a60578bed9b478c19f05a8498ddacfe3a52897667d7d00b64b7fd2932ed31b84c9c4d0e17ccabb27f172340e63b31885fecfd321eed9fd17a4756f1d6523637987cfa636d11cd2ec284a5f64b6bd4c53eb2746e5480802a43d39fb627b84e4c490f4f3e873adabe63418cd98652583d33ec589c3c56ebe34c31fd7c83b9f740e8f0938d0fbb609cf8c92d04e28e51941a4ec0c7b85927658262a89ec3d9cf5d704962eea30269e244e3b56aaf5985161cca9d0e03e301eda5879c2f02197b6a46832fc4ac06e7347c82516607ab44dec562ff09d24677cfd2d02f9fb4d178583a6f2c5f3cc3edfc8f18e753366d93e1a9dcdb4fe92b1f9a1b744c5ee7d14065fce1dc774c56065b677264a4572eeb601f4fb97269c58710ae52d7c23b2087ba0e5e025b921de12b2ab81e6ad94edfb726685bb13bb4cd489760a9b4fcb123c7067edb011e8eedd4ccda51fb0ad075142ae6340285c1dfe1bd6fbaae9b6c947a002915530623755bf366e9385c8e073672f7bef874c4cf18f6fe38eb70d656dc73a3d44aacfd4300fb1ddc7226a5017d96728abe9df4c7702278bfdc534f24408ee1324be95cb4629883c956e9874011654229b92814a8493c3a0b0f755eff652fb05a63221c160fadd6d972154e7a70720173ce4ca6230a22bbef7b5afc0b9e8194111bf14427a1686a753d802a3e34ce6fe7ecf2dd3e41bcea9aa44ed9154e28e3159844fbfcf0076aaf484590acb00b51028e398fab5a80a0f6074d05c3a99f8328d031d24452808239cb275d5eb69331f5b2553578bd7317d850d02a486f7bee6f9d1a8c4cc4cf64723678f2bc1a4617e04c03b4032fcb7f63fbc49af2ee403155e9d9f8169a4379dd47cc1d8b926674bd4185bbae05701db6e63320e6733b0b62e949b25fa56ac5190549987e7671901e60555c2db5d203cc40bf10b2c55e443a9db6a6d42218b0b7363a57fd576650c2207bf0bdbfeb0f28370184cab7d100c131d55cbcbd3afce6932652325184cc60be957a7af78d972a034d2dcad55225362e71fa5db65b12d41ca22ca4f50982fa6255086d1b968ac08515d8ef5fce4ffc8f7a8825046decbb895de09208b7edfba65a24411afc4bd48ae968f12695b644df0a4bbe7086b6e877d9f7e8cf8992ba02df7eb36ba8d9af30844904b913d4e921923fdddd61530904dc13024d3565150ae8f44b3e7e2a462a36d699e4694c440f4d79492a38a1f92021ba5d781258ea126c55c6f7bca80b3df04165f33572aa802f97abc2d36faefb607701c18e00fa9b12dc61a8b39f2fd7c71ef8a5d07cfa8e9bdeadca8d03095aa2da78b56b9f459376a93550a4299038a0b60868161bc357e6e362410b147a951ea9f72e6601e74071f807c3870c18a03433218ee289fb11905c1cd1f3f4515b8227b487379d236ae44afcdabe8f90f391f765d8fdae4ed452ffb09d721e79f4de8ebd083e5c3cecd5ecb68939268c16fe9dd96ae42fe4aae72dce5b69b3c103aa926d885357b058631209685c9cd72b0d29fb7e1cfd5bc88d28828cb0f2c4ed81f9b6f7875872ddea69f7300172d2f655610204c1af305ea4a71237c6231f29fbe52e4a914eedcbd431dfc0d5215714d84ed49a0bf6367db0ab8ad0958ddc4c3675cbc87dbaf8c11de2d4c1fe6dee9d441c36ae2582c642eedde745ac38994b0a11f7a468ed889d7954293107c9714619062c1dbb8437314e2fd98f1b7c3bcdd1c12c5cc42029a6fbfffc9e82dd9770da8ed4cf7d70b8f85f4324be8f70fae1f92c330e5746a7394d2c23d17b13df37118150f30e743ce5469471eb5d646b333fddac990a1a65c95848bf228c04743bf8a079b8497adf6456a7fc2f137eb478af9b9236a91801665fdf60671bdd3c5f3e46cf3ee9b08d0338f80b34152ee547691bd8ab65eacf5ef2e3ddf889c1edda3b4e7a904f42ec06958c2d13ae4f48eabb69115390214ac9cda498c156e4ee6b426035d4fb791847cfcd67b9e4af831fe4c0ec0d30ce128e52004f1db48b156d4d9ca36b2364243ed1883f1330ca1325026634316a2a348f3e9c0c634fc12192621ee51366dc9bb0777997a7a504a1890ce54989c73543dbe71c45c8b17396ab7c0772377e9c47647e039f29f0460e6899bbf3bb36ba8a0156c66f50f0c764474ab89c1d9024ea622abaa29a933c2425e3ad71c6b31b2c840fb8ba35b6099df1d45a0213b99a53fef5a405cc5550a304388c6a54d99daee430dfae7d85d6b105556d1c10af4c4c70bc485fd3d5785d8e601505949286884513a6bda5c575a94d9a76e3eb8d8f2e6e0ee08f25241dd5db710aa77596dce749801fa7c3e48a064708dd1ab6436d8043315ab9f6361b112b34474f7b39960ae04a507b16c63a074606fb4f1ca85927747eff12d7c12c088f6a39b09eb5de453819d0eb33d56f8b9c8e09539336b71a744d010f0c3a08b65b2cbbea28a64fd7553df1efcd429b537156073d48c409a40b609d86b84bca61704251e251a6d317ee00a2449e4b6b7d8232ae04c776bdb6bdb18efe77caeb51f9870dc2f6aeb1fb81efb183fa31eb138186a5fe0847d47fa5485262681953636d305dc23fbb97208bd389dd425b8c367367fca875c0398ac3ecc97ea60fbf2c3f058ab8e748cad8f27317a7f27bfa266e52b28e3773fe8287ccd91d7b4e30982919a952b821af834eb14ad1a73f073588a41ceb5268aa46033894c75748e96cfef05c8c5aa21aea8953a51241ae18fcb48535364ce942a32cf4bc83ebe6a97a214706db0d85fa7195f51b38701d07f5d3218e3e65b1ff9f0a057c306d771ab5dd4a48e578c60af23472ca85e1109c82742dd8242b0bf1317c3ba7e6f01a98121e3ff724e0c4f8c22d0d99b69ef81cc494d1492761406d2315ec474dd9126dd99cc82cef34702718c3c97756a0d6dce98a0fe31bb9c1ae1b7cddd2e21b358b199ce40606441ed7dfd26e7447d09209cb100029551e8da40cd0ca50d88786a0acd00f1fd910a337dc50bd3665ecdaa2100cae912d236ed4aaa8d5a022cf58e4afe7c4da84b8c3ab41f1a4dd712f26eed3e96c2a42469a700b923e49a4d8e1e44b68b4cc232c75195b96846893165e0483144be285742699567d2c3ba19a43118380f2324b1440a6f5d8a0fc3437f366dde79c9e034464c1ac744cba259bee53c8a096a39d9ca2a458c018ec272a3add107c51dfdb60d66a577286aa9d72ffd21ef9000b6341d4cad53d1204296240f983b554b77264787713fde8961dc4aa5b576eec6ff881b9cf3a302f14364820016a508d46875ff385ce194710dbd3bbfe5e45d063b14867310d7d042e5adcc56f3e7fa7d0c2550b9c3afcb0747d9975113641c0cae0cd990eb13f0f9d9e74fbeeb808ebab31c32cc3b7d88f321c8d5009503425246d69bee7847bc15553a6220a204d5b6fe817145a5c11f3bb361cb5c76e22226ccfc396dac835fcc751095120d6458ebcbbf73f61ef6b98adbeb58aef5221a963061e259f5ebcce163f6f4fee324aa33b61b8f097ac1f891cafa761d3daa9bcbad55f5da5634017f666a97e135f3c505f518b50105c0ccb5f656ba162e7fc78bbc80e1112525cfda7d7a3ae5233b24ab60a52b2f9dc4b03bda19e44a0d5e257f8cab8eec781fff8131cfee86fffbb613b010c1bd37b05389ca49ef843b64195bed42c192f626777e32c5c636d3d507d3ad7b01a6d033db5240fb32d09981c92a8ff72210ef9664842b6aaad285c064ef6e0c1fbf1891493d384ebd14c287ff633251d12ce690beab27f8a619990f0200dc9dffd56585c8136878c922e6db4a93618222371985d4748c1d07e016c933f6872d7adeb9cbcf703a7423c0884e54a8bc4e572e751767116a4267c13b4e92dfd5ebb6af7ba0e55c745e69979d3303faf8d6cc93e0a8cd022a1a6255b8c12c3701c0b88e00faf836bdbf4ebef706a0b11e2416a76555ca349a922ec5828f37485942a212acf1854c18e04b7bdc2caf48e123932153d93b34b9aca7b417d6e2610db4e9cf5f891a51d76cf279931fd504098f6a71b27ec48674df46833d0f9b28ff19cf8ee5ea68f299cfa0534f0a4b41188d58ae238597cbbe4ce25c05151f3e877f0125dab1c39bf2676b8ce9999da41a34edef0cd464e87805220490e75e8bcbedd4c69d3f01259e66545629a214282c7fd2d5d8606622a8d40d35df61af6856d21b69e231b79241d38f1017edcef9b96df5ac183aefbb309c97890dedc8ef1c9caee8f835a3c0f541a2f6fc8530c8dd5bc0f910a52e0dbf6963889e578a4e7fb9ab11773f27126ac4dcc2fabba4dd8d2b7739f8c238202a66a5bfffaf8117f59128fa867a49eb4101f73320f888ae561c48761619bd1ec637360a03efcbb4239a6a0306c5199b66bd95ce31af75f031f8c08b5650fc5cc317b7a1195f6b3ef2c62b1d21e2198af756aa5748046d6ffc69e563ddf929834ae3a52713e60b92ffdfbee18db0345d5aa3e04ecbbda9b0561ee98f45f8789be5e2f8f2a1f85a56cc1634c665342bf5ec4e42c2b42bf42f93fda0219da7cbdab0fd9387fc87379b03b67db747731b2bf6beff933e8bab91e35beb10c1ce132fc2d69d19b3a263d27b3823957e92a7ad8c65ec49ed588a618b98874294c0f80a807eeff995932c26308308f530f1022dea454729fc212124ccd16596758351d2e61efc8c5e15ede0ec4d4bd2a35e678af28cdbeec2ff97ff8b4312adc9ac4502280c9779cef3dd57509e9e20d7ffbbd3acdb39342347b8bd48d64ac42330b52e5dc95ff303a8e287f6a227d3a11cb4e8f6b727f749854c94a8afa5e81d552946de4d87f044ac359576613be4466fd019dbb4d49c18b64cc4f23aa8316387870132641bbafdfdd0da8409fbf967727f98ba266fb6966460645cb584d7be62bf2343c7b32949be423c1bf21a66a57d693c4670cadcbd082fd8992a7ec88ba1b66febd472b0dc7836554665e44c3a098c201749ec0f34c9fc95a8361415fceb8a2738db10faacfdc5b7621cd30fef1cc94856c2f55c76ca83020f697ecadee805f7b67accc401bbc7922e574a106226a02482d56fc1d3817e4bffd86c16160429651462a36458041703031206cde66e73c134fb44bdf34deba31803f3e01f94d64997acfb8ef8b5640300fa06259c141cc018e0e504810035ff9e25c2ad3e9b7a025282b1173707c3ba9bbef070410fa246d9e2f430b5bc0cafa2fe12445fb587c2390814521faee2b282a698371381be453dc9d7dfc15591d1b5fb77602a07208296ca6c6a078ca4642289459c0b305f2b6bcb6cdbb946b0484b56ed4cc240c8946f4776e4e1df369b50d1fd86e8cbaccee42ebdc5a7eb1769bbdf1ac0973882ccd96bb24a5e7b24f7cc29155de496f0161187c311eb844ef6767a323d353d7633913a215eb2bac28cff26d3444f1c93353d4e91ebf1caaecb62a0c04e9575cddb9c7b1cc301b331d32e61e1132180f708f056c1f2eab974f8399c2665bb9dfe2f25aa1de85304813e32c4336ed32b3fa292ec45d7d80f2b4dd4168cc163ff148a5b40fb8864c9aeff3c9e3eb13d5dc588175ee86a9ebcf08fc92c335093ec3a795fb68696c18a7305bba62c6009dca999adbfc891533b5ba58c3ecfd5dc1bd602c0634629d638b2db3d002ea91fd6c0d216e915f210c2c3872474c943a3439233e1f66bb5915264f102366d4747fbc0bb08e5e3f6ec3cb3cb802aceb4eea8260d3df1554a6d934ff6df61b55dd71d708b0a633511e73b720cb4badc913a4e0a929fe26c04f0715728c6e681aa673413c946208f2219143433ce48ef3478766490fb7f9fe6f8074f4c0e6fe7b8ae6d7f7b1122cecbbb5e27f5b8ff5a85b6b4d139b0aacbb6eff4f02cf75f41569bd9ad356c3a30653d972f0adf096d9ac1747b2645998b1da19b46d17f1dcf01e9b9e0e13dbc056f32498688454f8caf108d80d27ff8fe978d1c1c0cdaaaad50fcc5dc7743109891ea25951777eb5f94d98e01fcd91d59ae2ad46ae1c2bc733678ac3cab0e617eacc647385585be7c43764a6a24cb4c63f5d1f0d4b2e060402011ad70c78144ec9aed613cc07de1669a3df89b704feb84b795a4d5b1748f38f630ae37924119f91bb0ddda6f000452f3bcdc5e0fabee6d780c7db3e36ed3b965ee041401c338497fc35c61b0b868c0729c81286f91c0f708e5ec9d34eec469ef42303947a66820bebb9a7c931198bac5f9a5852d79e149b47207570f67dbb082db4c29bcb4a596ea0d2ad913591c2afc661ea49f22f6fd0d279348d0e5de88ab6bfb146cb2e848915ebef775fce52c55ba5e3d29ddad49335ca705a2be939793a21f9daa048d33c1a3accacbfb55311433ff340eca1951e173c143ce893dde4bf770d518bcd85d6f3e507908f606b3aba3ff4c42d23548c74dba24e3b093394bd4480a034e03ad54c6110ae16e4db076654c54b0c1b1a7978f5bcffa61a5ec70ec99be29552731cfb811b25ddd6f9c17ace4c98535687fdb02d3eddad5481ccbb222e68adf38b86c1051332c05b8b8ea8fb3e41c90a158066d25a1c98e5d1c528e442f2e8f153ad034c7b413e42d686612017c6335d815324af013a989d6c4afe3791cc498f81f0e93cd0e8dbb823bcedb616c9b48a9d04199316870083c9f72941fdb6a381f06a63f3355c280ab2a64145457a4e2d29f8ace126a9701d1cc0e16cfcdb11b4aa9bdf2f6112645ca220ed01e3e6ce5dd92d3b0e22eaf64253b6627bf3732750c85b7c1e104b41352ca6a660831d346e7d00c945a619526faf3c326af106991b0c323d55722c61b64930cb8887691077e19316799f9c3bbeb99b5b013c47bd3015436e3f4f5c1209b0702f11b7f05bbc2b532a83ee84bfad76b1bcfdf12ec812a3c1ce91964dbbeb1e3cc801c776ec51143a67b97f7df6434395803eb080c7cc6ceefe32a382509a2ae355c94d9a355b92fdb11c476c40bcb2eadf02317b0af3c28852002f19ce6f0da479dce65566bad2596b85fa004f9fb762ce92b6cf1813c18438abdf98d2b3093ad0cc43161e41e07f112eec6f44b71b7914c6a7d2598b1abbf3b274800a1f3c09ff48aa7ec6a07d03bbd82baba3591dc4eb41eb10c89e9026598363c524e403eef95e628a88b17a0f4c2615b356d2783e12409ee42b01ae74103089b856764dd6e1e54c2346d2b1349ae34b5dc85376f96bf7f6234a797b679cb7b8894180b9f3ac5d011b1ce6a3eef3d904336e169a0ebf5b869b5f22a7e68ee038e72194e8f5d9cc37901d1756e351428c6453a2bc569fef164a165c77bcf272fc7a2fed9e9669c22952ce96d99330d658ab38b939c373f7da64908e65e09bb8131b9081ab7d2d563baf30476fcda96b86078af3b6e2eea95b2ba44dd65b9479d28c1bb7b061f7d4eed20669d75d2e494c304e60052706ca5a6d293d81db599450d11ab282da03cb46f700e59b1ca7a5fea16107b4dc0a4db9479d6c6af3f2ccf3e1a4280bfa0e367f3992afc8f9571c7e83fb171d3b962b4d4b9ef18adc1bcb66ff6b868b978274b28d27a961fe5c1b2dde401de3fcdc6a6bdf4743687d9c9751ed3e887fb7","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
