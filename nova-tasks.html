<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7243b5cd457624a90225c60d9d7cbd2400f0060b2a01e39a0c764a6f6da63e64cc9996153866b3bce99690b8c528715c63e875481d13c3301ae69bb9896daf800a289f0228395235c3e4f4a7c67014bd3323373c26883aa59aa28b04b86523a4bafcecacd0f616e81810f26c3ee97275e676df38e30856d571de423e530aa7e9be09497bc96345e02afa0d8692e8fcca02d5cd7a6eb0c12cb5f583b0402b61c02209107f30432a50b534e4ef7a9ed77425fb82a12a0f44a9d2491b22254ce598c85e9e386e3ee017fe97c30298722fc29fb20cd23378edd5dc15f4fd0886b4d5ac6bedcb5623cd4fda0670cfde666d93472b62c68442a0376bf183c9a8550d3469ac7e7e520a361015a55183185f5509b87b6ccebea94b018f62a512396249234c954943689b5b3e85ee69dd1e4efc79e94b44308474fdba4548f08517ded903d4f1f27c34a47a2063adb9cfaea000524bc55b9dbbc04abc73fbd07ab07abf38438993fc2dd8eb465de22e63a26fe84a47e01e28e1848f59c6c358cb8d5892fe4bd8f9b66b36b8bf2377a986947309cb4ac371f5614ae8b3be365957f7172bf73c264e4ca70305134888368bf8f78be49bde49ca64de9c4942957fdc944e5df87ec96ee6f8b1803ef156554102fb2d740d23befa2e5a63e1e16a1eb524aca38fc112fdd10b7952f2b7fad759769f5e7a8facc010cd05959ef9b807ed36831a8e73b26d190bb3b6dc774f3de2ea87bfb1ef1aa313a2872706fed73e5c2c4483993d3e29f3813953e071e01c9e82deea3461b6b102002997d2be8e303023788dd8a37021261537119d857e50b358ccdf88818693f59ab2d8a7e26f47388f39afab9e8160eb869ae0d006f89e09eb5a032c2017122c74fefb0b5544d53cf6de7d94026481f6e8fb5d806103e99009d87b08f84e06176e17bb61942595281e3cd72936660bf1da93978d9ea8106873651965125a31fe67ab5a66b38b69f8f953f615d0b12327f225fdd7bc2d862f6f6800ec8840d7332c112e218f7433e3d9d657561f44a188d620a089e677ca9c77a3e5186fda244e9ee644fb64fd88734d4af98f4e9fa8dc65e942bd556e7255c2b0432d46263e0ce753be2e2d52f4b07a3d976a482e312985482c81f06b5e948337fdaacc85187d1d8ff90e3fa055e91f674bf0a27b580caaadf485e60cbf01d4bab870110d21702b17d1bbf2057b8904f97e888251985e14e6b787977f95ff92ccc79e79aadbcd1e645a0798bd1598a1ed4bf6507830131f289452160ed64036d01f3cfb2356b9181d1137d254150c208f6cd7e7bab786b1c7ff34d23d252b7944de37b2763915ddb56d03902aa891183b40379f4e263b09ff93260790e95e9359fab998d2feeafcebbcec22f22675b00561e2135606406530d745d610a98f5ab20bea7f70229c4e64a4e7ab89e686ffe52513ac9678cd4460cbe6238121b8560f24ca9a54ae1be3577beafff6cbe17800b9a42c13fafb433e56d1beb3a00a9ce28c8c15fafd794e3b0fdc36bf528b21e6b88a5291d923abcc77da03a6b2fb4e78c560b9acafcdecd6c1f2a9db46ad272c89dee6c10e56a18738bcd798d933ce1fbb0df3de79dabc794729112c9a91698b1be1232634a507100f0810b8cca848d54edbc3c220eaae17857c72dcc0bdd21b129f92046c568dcdf9f8ad5f9c6d5e8c1add450074f1d667b21d6fe8101e975c49d514cf9fa2a42d195a35c236a019fbd7c5cc49ec608fdbed1ca296561fb0e01a02ccad878b95a7172fbe9b5e8cc7fbfca6118d3df7d00a66848a9f2cc6f3270b9ea7ad449e000e52240fd969cf6bb8e76e72f9fdc2ba9f6e4f6cd45f2b2ee297c4bf5758d16a795642a3aa509f572a78cc9fb5b5bab592987245f1796743b61b221972641c2c245c247d5f5facf22ba9fac12095c02f82d75bde5d99c5061b1ed2111e400a1adc39ded3857e25dfc26309030387daa5d24e8465ecd19c4a63a48be734371e1d8bec209666121289182f1f2d9a03a8a4443466d470fdff551e3babea51e34bf42bd04f8095b1692312262868c26115b0e783243823e911c344362ab367d6985373a90d60bb94d35d638daca385ed17a18a56a4fefde21a8df90f7ccb00c5bc45cf53e8d8194a494f8766a27498bfa0de8a0900db2385a3be1a8097532ca4454229ce636bdc0eff99c2ff8b7bf652b5449513748bf6d21ae9ef32441fb18cacf8372f4cb9be765cda0dab00c797b522ac81fa936c417621337d34fb3eef9f9c7f2e8a0dea6c4749f92e2a041d184fd0616ee6829726344e30496bc498aceb3d236b05e2b4a4f1ce2728c4c3b8facaf935d7170cfaefea4f9ba56fcce67677e8de0481f6829bbf5766bc23e38e8b84fa4686f9f7ad423c3827350a17c4149fa08c3660091587d3bc31b76931fbf395920e580bcb2e9829c220726d327907512e6893b86ab615da82daf0436755ac3959ea81601ac56e83c9c894bb2a81fb4dc3dda474fb9224ce1ced7339ae2f0c549f682e6828d8539c175d72e2955c405a1975929f2bb105fc9218c22f836a51e67f2bf83db7b44a7f3c0e4b49dc27d3e262b0ad17419e3eb981a4f79caf183e2bac5a207522e8d6c29b5e5934b6f34cc763661c08003dd955330fba40d621b86f81d90161aaf2c0541be7230a75c7f562584a67606d2e4b0b38e77097a7be87373f38e0291521cd69e6a7498950c4f5b9876fa2f06991b0b7039b1de39723c197e79e9797e37c683f6fc954de082138c0234e451aac2eadb9165686f1aa6f062ce4953977011d0345e697d3f13e42e9c3eaa0cef65a0fb5c0d9980084555b9ae7909bc29b3450569803cfb153fb1f43b5addb20c539dfb799a75c4e21588b2a25d3f16ecae6c9abbe8c47dcebd382fbca06423b11c88ce3285e88b82fbb940cb4d2118c0e81988c2928b7a4c65389f6ab9657a7e2be0549a30b5cb3214e6479c234655625233ecf6c057c345b210aa949ea99abf9372ad23366fde462a2c3ecc4a9f1fd63422b49bce9cc5c1de4a9bf28af673aed58c7039a1a44d8b692fa64ec0a4b5842510d817762ee50012508bf6e6e00903c997bd2bfd250aca8896dd0b4c8c3390a8d45ab818d1bf81cbdd5c67faede0dcd609cf55f29e808edf6316a6cf480139931333a6b184030f643b2ac77b61d24de11faa2ace0cbc3a8d16a3423545c0a55f7640571e6fd991e1fbeaf76bfd9417d82ad01ea10c41f6da61ccb21489332b1ca80fef6585d70bd392be2ae261314587e951e90015e2338a738f12d3c77babfe17b0236946eb058c86a02af07e18833f93885dbd8aaa862a874f4247e84cb0c07a2e0b95b17d6a36eb0bddbc46a64207622f4eaaef9927a1fec9e43db23713d33080b4db1500ca99e30d13f2721191520e14062c835ecb27e37718ee2ea7938f3af0efc7d468f106d411fe61ff13815307090bce7144f0b71d84f752b36a66d1c4136c59198be7c1b9545c4d3860e14ad3bf21f37616c7d58a4f2e3c17323aa80d0cc98b1ea0e631a268e4077a2e5b56179a9f83ec1e223c56cb4086f0ca1f1f339c2477c20e1a35915774603fbc372b325fdc58eb3fb048232666a6db4cc8cc64fcb6f5ad2c5fca952404a6adff292764d97b80aa84194e0c74ec0c24df1f15ed1adadca263b4b4f79a3050953049330f502b698f6c64c5fbeb6da578fcc20e89ecb79f6fff3cff29d1f3becae5a798be40957b6bc657538ec952e9730bbf6a48be6ceb33f5ad18e5c1be4af08c3c939d02e89b69bc9ab1035b2427994bcf4f093d273f1a566e9a28fabff9f3b60f7909ee1334eba2efa579e589e2ad6e2cdfa04aae245de1b67b14c0cc44a381ef1647f5aa6e844f9e333d62d829ac0cc4cc1a9c989a15bc6078fba5265ce82140bbb75fc8057221c0870c348425d36d6fd62ed8fd27788ae26088776d72c84fece89f4f700fc13aa12a2ee377c49614ce03481c20dd51d477839d1a757f808136ece42d660c4739dc6793f40f42527b737dc279c48208084350386de5f4a4af14ca336b20e75cc8efbce6fcfdac7edc54dc04e71e9961cf63be2a72dcb0262e59df69ce87369223a94f5b51a5e050ef245aa821462b8637df6cdcdaf71e8603c7e110671628bb371141d6ae564597a18cd921429d8f10795f3856dba780018d0dc0c69750d1fbd45148fb18e7cceee6be1d6785a3eda20a78a506682c4fe9b8db300640b85261a21b362f846bd5a0706fdb2daa22d4311b24d0b2d2c1a459fb5706097b2b508b5282ce617dde9341fbae1f3faca9e31d1063a00d39465418a7cb1a39671e335569913fa5573720a7fce64f2fd48a8d045f0a629500393bda1731c90f5eeb16a4e9694913838982305298a4c5d8602da98a8af8a38c8be628897fbbe310fc4cb80f19e364de639cb3ec64ecebbb060f5e855d48c190578aa36079181c1d1a23730ef95858de67b566df77f6c4065e6919ea3a4068cbad626b3b50dd08eccca34839d5901bb97847f16ac346d2ef6c71d1ee833abc671c0b5c7c7a555812461ec1929a1bdbe0e2c242bdbbc8cfe81020360d8c5db8a765e7e0b0e76e138587ce494a00c373870be33078f52ac5b827949d11ad1c577fe09428642392d3ff5fa4f5b56fc524804d4a633ad9e4881c1e2109704236a10caf90748b4e724bd130d6694d06e8572b2af4c316a2482810f53470eba7cb865351e99b98f47db502427f843227c11ad11c001367f7f71da8634db7f445e01d0e6e8d35670f6c77bdb262c2322ffd52a814d44054859312c04b2bc79aaa8b88a4f0651e2989327c79a3df6b1c120a9283d124af4572d49c82176ed4d7e1c79e055add4bb1257f0e54324db02a321848f0b94c61194bf98e003b18706b5fd87ebe60a0a751f773787c6032b811e33efd25bdf73bcd9fd710e4464e0068bd9d6de136a17e6502ce706abe6ad5b625a875a9503cb7da83b02d6b907d0c45c845b0621e1ce23d0a3c6a935982980c7c32b1203a9ecd6eb858582fdbf1ff055b2ce2fd8da8a4caa0bb54976b15b745d97b3ca2f2ecd60a23f7fdf31e77c65c8da195d8a43bb2efb912ca53adee03282553ba9094120284e4834ec9353541aba87cca3b0bf3b31b25bc3bc1ef95fd62559f8ef7b006103ff040cb334e6f284077adc7e20ec82a6a24e36d2bae746795b8ab9682ddae8472ed3a2844f2640b6f91261478028f2e2a5ff2fed6a19a347defbf6fe15bf407aa3608192a022719d149ab7b64083ba5ed70c670c9f4e363ce0b753d42522927e79aa6b9eaf905acd4a5878554cfe04996c26906e2001665bf4fa9ab6cb44d0a32dfdb294bc2722f843f38b804ea6150ee0a1351165953768601cca56ebf472720a1cbf2469a14f6ecd3f17a7e06d7ce69ba4686f414654f1106684f35faa620905b6126609e5a1ba89a927cf2af3cd98294708de66f88fcacbbf33f99fa0ba29c9b824e689a74baa2cf02218054610b23d48239cac7c89106c1694e58ea5ab9590bd35c860922aa5c7b334fdd8b05497ada957b1a0a13f278cff05ead25008905076a0d8f5a10c95a7138ff24cffb781501395b9c7641d0137a26bc6eb6168d008d808e02edb56885d96b89ae6b7edc1f8f144f17752b21ae77f5c50d47d06b6624910f004e78f0f1cbac5c11a277d828bc5dd77e5136b2d19d1264575ccff9d337a9547e22b0ab1179981be569e3a055bdf5e2ac8d03ee1c64b8f8e2dffa1bf06d895d08f04e8b66b3d805e3837c3c09f234b52933e2921aa11746dd55970ca2faa6875617fe4a36f32afc3eb9eed4db2b3152c4d6761584e9c88533b1b4bd506978a1f7093f658f805c7208627f8267d611683378da0c3e7079a1d8fed20b7ee9603b037ba1965bab2fd6f195a79620bd426a8137781f7ba0acabd70725133fae262ec40db91a5914a1258e4040952941c7db70622b1a8ee909cf66230942167a0671a27e26750300239646e18c302e188820953ed19711b89b928933584427f81eef599c6df85557903dec47e3e41b74e3473c1d11bad3e39d3c4b7b7f9db6193d2d1695e7d6381358e0c403c4855225f3daa41f28238bfe0e202754397432eac0387614ce96b812e60f422ae1f290ce60b60c5cab44eea34cc232e2d8e812f938d33b439e0045ccdd3169b4b3ae458d2207d70d7404405d4fe3bac50748a09548a00a0996ffc235a77ab4f4db5caef7e72a5a6d80ae6b6e6bb466b2ff6885aa26edfab5d5b59269c5a7b78a04479a7c76f4b3aca59ff91a18d5dda925c8cda2f11d52ea1ab685c1f035902c4f0f196fbd61818f7212a85fc43fdd54fdb220780920351169544c5f087e97c1e5ac4f95ef2cd80eca935cb1d9b41aff4c2b3f13903cb6a3ed1fe28d9a96bbbf36f1dcf0b64260e67eea2a35f3ddf2fec39f58960a8adb58ddf6e33fd8e351bf195bc0f692428f72a5d1b251b8a9b46844ea07e5b33343cc757cb34037d091fc9ac4acdd50fd3e40e954981c78f6afe6f46f79f746a9bd52a6064e87a59d87b1bbd797205a79a2fcc3b82481bf7557b38a7c2c983017361de30f56be429d20b515eabc995f6228f42b9436309e9c20fea1ccc145fb6b7dca290d9e3bb0f4f77ef8c65d47cd1e435f1121ad1fd7a94b941a8a11d65bb09f366a863bf054458e7e1241c7d23cf01cedef0cdfaa57ebbdb8601f65f069bf94ce76e321104430aa5924a99662e55287be7fdf7d20ce74d9c9e00cf2fb891c83ed6086937a4b707663ada5ce55f4f407103147de53dc364de15222c7423772e6efe57cf0cba83002fe0f40b0b68e095716c01e7d648e9d21a7884d17e6a4eeac6f24b0b7e9d2f995e89cd13113db8bb314cadc383b00ecba9abd5a20e17e4f7dc7ee675bbe3f1e0eea338d396331dc60497ced17f7f3a7290cf3b896daaf8c3bffe731f5a239c5821a3ad581b2e25ae3565a2d813e47fb478f11a02012d76c27131cfb4e19eec02b33b4e95bcdab30f0d3780e2169a304014902140cd998ff03d3305d7ef02c3b7c1a6d4ebc8c7e67b58cb75c8c32c264165aa024570b5b54d8da023951604d23f8021f13c4f3f4c87ae77c6707d2a7feb1f810043b86380c140c02fdd214b8921e1fbfaebe5900d1e4a3e12837ef5328083e836dff4b9ed97c0f9c2c2d389e6cde28603d48315cd8745f57f3e10ef235345b012df573968f430f9cd4dac3089dbb03dcbd75dde0678c7b8cedd3b950bb06be68c2d36fc7cecbff25fd2c71b1850f52c24b53483664fa0abbaa65cdde7b8a45d33da149bf36ae91ff5fae1a9bf1a3a4286d735065dccbb0bdc925fbe7ba5cb02f5f3df5289391aceb4bd7a1b478b8df4647e1946ff8a336a798a89ec00ad4eb04ea4855928190fae7ee54e7062932f562e2043ee54214222f325917606ef8b49d666b1009d6896a0df815ef7548c7f045594c2965fd299eefd63916d7b94b62d0186b108b149c78239c51bcb7ae40e87cb3fe3ee11c0d62543dc6e56d22f341a49c167a97942ac50abe1c473faa9c032035641ca9f877fce942d0df37bcafebc1f49b9ea8962b75b679de858ce4208b2af569a2bcf45246800926a46442c0a86b85438bbb1ccafb166f3148cee06cf8042bed2dc06d280383bd48fdc3d052bad070c96897116978b76b5c502709eb63486c2c7b08fd66046285b20e53e60dab605389b786dd497475766a0aa6fd9b651e3ae7d5e848f0aa7f7f722706fed6cb638062a5a500e0c8a6505ba699acd0087e421b6e79b0932bfa1d8c0bd1d9b020e887b10ba2fba52f77b5b4672659746579ca148adeb39ad0107a3c9bc6da9d1b8009c276bc7801f4302da6cb47bfc198bd4c1a59c730a8970ec7d0626822709eb173ad2c89d662ce106356b153a75ae6f202266efbeeaa9f90928b38f553b9e30b5e409154f454aed142b548cf788ace51a90e6cdf04843f8551d647bb86fce97969100f0398f8db6106fa115e6fd770202592fb9890b9fc4a31bca8a89e88ba0885fa83ab8b7413717a2c815d3c4e4a7b8ce2748582ce1d38f30c8c209903379d28dca5db8406903dcc0a26e25e6b348c7ee6443e7e7f52429419c544b9436b959eaa5d7f2b9fe784de466b5fe627a707a5f988cc8091c06fff17a8b978715d1515c72d202dde2998119774fb39cbc6b3e7167918555bf9c44244a16af9e9c4f6f0ced7683385cace70c198f3ba2b31122e42866c62db490af012504531488b796e8737f55a75252a34eee8da8827870ebe7b692873df0f6b3a02a0600254eabca70c6af8eb65694972496cd5f25a15ce9fe507995514a0314b6510b23632f47e736c513e509a4b36d9f68137594c2e680935822934b6f18d6a4d2803905c5c115215aa0a5192f70d3a59a2743a30b58a57b309b4fc43aba78704f064bbfdc5ae216c93507c810e60faa1313f276f2178d9ce6d9c9239032ddf78f017e6c19a6f38d7cec1425ea112cc7f11abba8dfc2af0e38b190eb43b8aa25f5c5b82b182533c7e3da2022da8ed08efe4fbde6a8663b4683871b27d16b49a16f189d696fd884916a90678d2251733927d5b3ca4ff906615f667e90aad302e0660f52b84969c7fd3a7110bed8342b93f7a669130a94b8151d2411f626eeb2319991942824c42984514c5570d5c2b330d3a0d20a3e4e23dda49432f0863302aa88eaf4fcc1d270ec12e739c21e98ea5d7dedc4dcf5258a6d70ae7c09fcc84b274e41d336d74d3d251db80c32e3bd20bae6d287319f4a89fad893cc6fe86f9026ebcea75e0b3cfb5fdd889e55ce1190c29602ba8996bcc9047a2203aaa16105671ac89a37430969f9030d5a6b458b0306a0e6964ebed72ac0ac8abbc97fbd0efba443174a30d3e8abfdcc813a77ab43fcf91ece17dc19dc1dfeefeb563a2d415773d7116cec6d072e0dc8eb48690f026fcddd8ee5b582ef8ec60cf6b7de31ca0dc5245440509c260a83995850b0247c632448c995468549b1c4951b49170fcc1013d2819baae3483f625496f98957fffe5a0cd5bd997b487b4f61694aadbb66805cb63daff04547b43028d3d4d1be1b3b32c7ab5d85dd93166c471a0c63393fd8a5de51bdc4745818f5a50b4b9369f4c6fcd921ad4fec443ac2fa49e6c0ab4dfc8fa1b066cf10074603b4263b8c931b38bf9dd9f201b202fcf7fab5bf87c2af95603dcf8c0c6367df48dabf0dcaad4cc6f311807133572c98e4b4e167e7befbb05816335f7966f48b199f4b7f3edc25a80ca3634ed50a916e5cb9e3c8255d44d20fed272568f82791671300597304548f179339d043a685f3cad7afa7f5fba9d7cd6e3e8d888227f9deafde3891baaec9af667c1418e6bf3c1c99c8b2ad4d2250a408bd2d46cf21494b37a430eb82b0fe9407c4b8ae9e118a3f44dad681bdf2135ea10ff038c32cdf1dac4b67e8edbd715e84e48876e9e39021abdc902d3defb2987bde41d199263f3a05db1f4e4d91dbb44f530937e69f96b9f1477f62d2ebbc6cab91277b28d10fe9f8474b2b038b4c7499de4e4f5447692c1c3f4af36b86e08dc76520d71322bd75c336e56b3884f508a14ea4b2efe8176cfdd7bc98ca81e3a92b7be31fedb32473fb0dc39944c9ee55981f77865e73e5f5c7235a0158306d872601279dfda41c6abd5b52b1cc82c6702448941aad814e0e8327fbe31816c64cec737e08017295d0bc1621c3f8906f4f7631306d5b17f7013d3fab8d9b79eb72914d501bdd75a0d8451d52031dd05e8d6bc6dcdd4b264e26b6b58fd7c4517b97a46c56aa4962582f6e5b0391c63efb64deb2bfb096f71eab36f6612fac0e446ec4e08e679f5ba0808fa5aaac927937c14c36688d37e37bb7f45c442633a0234e30c26b2ca3f0bb1abd04687e6d5a45d275980cd968a73e39be0531a66676f98c8b4285055b35027e71eaf7276ac6cecc1ac91e99988bac9928b82dfdc655fcd33d14819834a1e4af8aa62810db4519f09af4d98ab2539ad1bc44fb879e67f8fa98d389f3305a3ad46f9625c1e59267629565e4235baf8e601aa4c07dc061c367e290976ebd0d9789c4933d15de1029557c400b2d6cc5332066f387a9fc80ee6a28e9e30b7b577c6aa7fed29b10b2f317fb95603d5a1109202993cc04874eb5130531bbc7b284f6315dc84cd6175d5a0cdce8125d065a387ab5cb7941cefe1f10c0b9b624449b29a2fc84731125dd6a6278e6689b149e43ae572921c7b73b7f12a1caf0ff0e14299507e73fe409f5fd74326c86058b4f7948e7f83e9f81a61fd471a2e32ee82d9cd3957da553312d25bb49fd811d74ab0967f61548fe64651a98dd2bb34ace54664f0fb3950eb9498c953f2724129336b6f5a21a46b7ca791f2ae6e1b7657b72a4ae0fb4086397ab905ea1e1e42d19c37a3f42f51d1d39ea80391ea02e42a8aa9317c62376f39e54f0111e52fef910daec12afd9fadbdace7f0910c0840ced1132d3df6948c546bab770ab68a681d63ba0a5c0b2c2fedfdd40a5a9e1626861fc68be18a596c3c341e9f161e696214f8d3a0dd40675392e3635007d913d6b014dcc61c15059f7c538d50a75e1d6dba0d1544f3dca16553dd15874529b50fd9e94bea68c9921d4a52e89d00318793b9832f8348582bc8ac15a0396b708a9a65d5b7627365b403aa900beb1e04514fac9961271eec804506fcb69a2bebaa028d29231cf0e78c76987884ff4c0628e7b22e772cd81cd0833193f580c9cf1d696e8dd51e0148a8f8888fc1198af9adad1eb33a62d4517dbdc29e8973b68ed46544c97ea8a66e979accfbaed2b32b22a228cec4993fdadc8fdcf5f1323f1adfb7039b2383197c926c37a8eaee9a53d1c82abbc744ed8cc4cc45e163af12c1f33e4617b2a147a9522063f124824718442eadc1ebcce58bb43a878d9c6baa241406d45ed3fd879cfcd6bf8a13576995e77c875c043e9c35d3e007b430670520e458800382072b5e0e432749ba7b43cbf42205aa0dee5307e6c116227be3dbe3fc15bb61591f31eb31f2654b851b3e19928d11c4ed66a69982c9b8f814fc6f2fa910ce27349e029b8787dc90fe9288f5b5bd6163e1549b541266320ea016f95009127d9ba769f76a3d5022f8abcbf6f5620a331117ca67c547a221214dabea557e98d221f91b02ed2af157a70dab21da3a334c81c0ce08ccb53016eca4a8f387c074feea2bd0d4eb645b23171a84550eb3482ac2d8c3a5cefa05447afc01005ef2396dcfff96be42f91be489330f8e1a8812264359c29e41633e7f0ddc1af68bf04e104f7eaaaa50281bcbd3f4bcfbea68d38280748168327affa0bf9f69b76b620f86687074304c1f80de279e4ec3990fbe5765832e800744a354d6dd17563e9969710905b9eb1405a12d792ffec8958a963ad11bfc570fa63ca5dcda0b87628f9d7fb7a168fcfcff9875d3e4b20ede311b208d26647e65efd9dbc5049f48984049a52cf9b8519cde351713ea45da24da7f93bbd9305db3290e2b8c4961441d8e9ecbe10e27ae96fafbdf1c7e00d51e9ec71dd236e9f84b6de21c7d435b47f04c1693adfc88763d492988d1e7f73a8523a95584e4770ba988b03c3bb251a4354ce2d82b58e1a3aca3fdded6a1208c3f86dc259bfb5f73368c168ea0fd48f4e4160e327fe279698b7f77d0f368bb42a80498ad4a16c077edce3d0f40d2804c353508338f8bb7c66d8cfdff900387dade011880731fc8bfd683f90f209f1e522a2d8592feb2554742a9ae5a9f0e2f8c197fc4945201fac3dd7b58a55c67a6d719ec8e8a0ec6c922c661130093d442024e031f32f8afc1ebaae6a0ceb3589da0894daa8360448966f65c2b4cdc4bc6fd0b6f90059497a6c687c1cf1abcfc2b423e337433ba6e92e9050fd316dab0b8cdbbdfe11c38f85b67e373d017c6fd58bdf4cf20bcee3b7c50941c5c73c603ee873f9b2ca5a29cc587125bf7a3ce6c33570cecab02dd27384f0659eaca38926c5e0006eef8ad5fdf187f3294a1f132c407ef17a0904876317f646f8d2595663a7ee64fa2904f4f8c26fc303f73af949a4d9e133a4fa2dba897012b3730e5a8759460f3d76e19e34467e347215e04ef269a536764d1f5120caf658e799a8aff66ea3018f7c7e889c3d5ac14228164a3c334749e9ddd64a493a683ceae361dfa8633627e3712260ddce4a11e25485270215cbe6c786363587b887e2bf59b63f7a66fe8daaa92f9e6cbe5c765a250dfce9e1be0c8daf3972a7724d6b18d8525ea8d5314713588c26f3f4e6d61da6c424e39da675f1832f127132ef0e60d1665b3d06e414018c63c211aeeea9db38e04f3b1aaa3ca0a5afa706242f83e8580743dfff6bc1a95578436863aca2ec8f127a5d55c272b802281cc8ca36db1750c04bcaefb398a3fb6b82a26a611a93a6ffae54ed8af1971b88d703da7187d28cbbfce4816fc339f3bbf9f9631a6dc18ffe0d8e1758d9ca0c6dd96c4ddf4dd74fc0039f99df63ef0ea4b13ab8c5a036da687319c5d34810c110b997062d0c7ba0378857495b637f0146e22b70a0a1f2b16d5a988fa283a38cd244d618e65fe526aabe82e3d7470a2ef400a8e265c75293293650a9b182fbe07cb5b3e91b39db8a5928ea1d8eddc68f7c0559ed09764abb906d4aa64a17564e05021ef43049e1519c4a3abd1fed3f700ae0faf365fcd469d93ff7394ca2088718b4b195066e41e33888244e0c73a2bac9637e22bdf6016da2904d9ba2961f8165d2d8f1ee9bd1dc64dc377587ef73100aa0fe61e4f5ee297d4fb2d0147e3af9878ad1afed609494ecebc551e056916b9d61252e9e5b24b670e7c5d2337bb5d6acd328817a619a9dd65e8206ea42fc56d017c1dd90b6794f0ffafe70234b2d71525e47f942cb32b132d87673e6fead723a7455ce9858f487ff4830fdb63af10b53e91789a9d1d5bdf2a2b67e4c9b0d1685afac38af81f34cc3eb069df391dac8a629e357e9df17c528c1e507a719d0256f0b4546749820bec35537dee7166b3bbbcb9d2ea83723f36318c3c83957b6d300d7ece9d66d890a4e7a8d4d04fa01960cb89bd5dcaba0215faeea259af2b45cdc087ba0faf78ef1db35df2367599a0b8038517f025b2740e009051d027215f6c73d05419ed39ee5ee793e442f1d88cf1f767085d31110a63c5b75e5cca6e093dc0e2a660bbfb6c0b1015f0d9573640f0fa9163aa4036bba2d402932530b56d95381a1df6ef2fed7e2605290b81a0f769d8226f8df3380b9a6ff3f954546aa597c2c5759bd1e92baa073f5f08abcad4127b54d86bdad8d41f4bfd702d942dd9517e35516f7bae10d689780e88b585afa376e06793907fd444ed66d181bb1bdd552ca4c3045815ca337113687ccfba118adf62f917197d68899de3b16fe5cd21792ec2f7e4c83811c5c20e7dabd4b9c490dcc32af1fa31e5b227e030a80577f85617ac29ffb7d4f31bca10a6ba7d43e759fa8788dd0113363b6f2d8b64a55edd8e76322441a003ab4f93b17e59b5bfa1517fcf2ffcab9bb1669da65e3cef678bd2963730084d4c56efb7feb059d2a030d28c5fe53572f6f2a234cf857b4cd2c9294e207493641b70ba659dc6828e01457bc99f0f10cad6d8b4c8ab6b1e67f105f3ea52c19db63d0e7c3d8855fd14093218fa4b5bea0e4e2e679cc83e518371acb54dd8a767f33411c6af6c14df64d1309b3841ed27b1e2b141a79d91846bcacf1b81e7077c55f045ff270961b3e96969d068ca2afe3200b500501e44b1a5f49c3a59a98977dfb82b34b7d1047491801c52c691a7c44110664c2c1f5a50028fd37ec0127b844a0168daef040fa3bf8a2240087ca3769fecd30ae44fcf9a0e4389b3bd2d904cd30e0e5f76940380e40aeae6a23361a6e291a19c5e1e3ef98bea476a095c0f87989520be56b079cb1407da088a50435b6701447d2ebbf5a2b94d71d09028373d3a0808917252f7944084a1a74c30e44c10b1347dfa59c79b8e80cbcd2bcbf241968af291d28f5b7d6c236aae748a949ce35c673330a1ce0b711c5be0178dda8d782e94311a7f9b6132f785fa5f9e0c0c47db09d15d5bfb08c0231dd61cc3310955764608a82da50361a1083544a8ffd71bff052d79d09dd6ad976e4b262a85d7a4d1b29d456bd08bc3acbf75cff6f2311e062b70cabfb2a731da9bb59e814e6b285b2454592488967a635ac6ee8f6a2869b9bceb2ac342438bac95572ba19273bb5dd5414919a4b87110cc768fc7731e9d7846c68f86dad51a776fcb8cf382955df9a07ea99f82e9885b1b4f9473932807c2327628c3e2b658ff00a083f357337c64779fcb4d732174b8b20ce4ef31a5335fd21a7dd78f756c3d620715e1cac9771e6ef52c500361f4e53a583bf4ab8541ed34ef0b8c9db1cd4f65e1ec3efbe492624703bf9d955dda0f3f797709a34ad5f7e14747481711c009b34c6872d02b44cac1cf17b15ed4caed29fa6f7771fddbb8b6ab3d5c97d5cf5","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
