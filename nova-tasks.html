<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b99e00138d915ba9691e5294e3c0ebcf28b64179932efc47467178820553f65f8afd7218bd59b07f12975865f034923f665e26fe9c635fa4ad41302d35dbbb552446341a3a36e185f3ff0902c7890e4b457fb51ad67d287e54a3a1da7c64391e31c8bca22cd2365a61eccead508a4d1939ad2d28cc84ce61a19553f96c2c54dc6c1af85a03062e1baa7b434f8a194dcb05cebdf7c7084e03190d4d93ac809702e5e1d4b533cb85c88c01e97d4891b9613b72fb2efc9e47b3d47be27817b88fa338dd805faefe7e825c027bd02a6ecef91da877c268dc27c5c9f9da15fff4626560d2a3722c66f0b5d72d88eb8b8a1d6160625ef15537aa12b02f130b571ffc58f3790fbe9602e4be782b2482c23d482c5c092627c8b633549ccba49f49b61e878f3894ab95aa41fe101621995fb925d4d41856a7a03497f76ea0d1f18e8a9eceacd4063d2bbf5038ec5ba536f1c50eae99ab9a7beb89b982387779fee4e2e35b5c50770cdfee7cfed9b9d8ec630671ceb585779fcb317d5d44def9464ce85a5fa35bbbea5e565aa80c4754b62531c3fb25b7401a898943b2b0777944051dd77d85a823eff90af32b0182355fb801bbf3a1159614a789ccf7b0bbe9f5bb8494917913009897e86f804e3b1c92e56d79fa52b67a4dd22d7b703ac0ee2d77957a28e8a0e2b56b292ae856aba23847f00fc5588f2ccc888f7ba0e1a7c5dc4179bf8d72116983c128f69ff3f6cbd0b36f54836fda956e645be4cf70d42c163d0da7d30764e0831a7dae976c1a5fec829d8d72c48de9ed6766f7c8f81b4d0539ce11524e0bce15a908932816a219357728add61efecae2730c25dcbe5c7e8dba0750215e728f0e49d196b9d002f6a45a202e8a709feed4735d9d87516ddffa83dfba8dfbb50a874654d53b07026de93f7df3d3a5c0a7e91ce48d0b78090ec45e4a42391012f35b352f688a6992bf8217e40949b62056494b7fb5dd9519b445047be5db9412041cff0c4989f3dae1660f26676eae788c027afca87e0caf6e4aabba98803f9d700585044e3191820e71adeb808850d7d5df3d088e1f6fab80bb458e2161236eff4693fb1315cf4b78cdf90063bc1dc3e11603e96c9010a37eaea878d7341758b021d7d901e2ba83c69af3382ea4698c18ac9c8c58825719538f23172247476e8d2565ecef0f9c6eab6b76f2376d29c178b69440fdb374a7ebd2f68bc277b580cfd57ffbb779842cb26829af7bc4c940d6032384019836927355e5290c7f3bdd58d0e72d8ab40d5afc5532c97de25099499c96094dd3295d1992fe1a608d5eb3de33410ffde2c58e6926d8d9c8e6af9d91e783f3818198c8721400af0a87dda7dacf7e013a5e178ac163c49867359075e88652af287240d7be75cec6ccf6a676e8244be90502bf3b5ca7dff545856556267d5534e6805dcbaa501d5ae2c64586fcc3fd2baea546456b8d371081fd6fd6486724f32e0265d042002c4985e12711ba08467ca8fd132428939453896f9819af31b18858b7cd8b67a5ca949be737a6e6d6858945b92b7e4a70764cda0d02518e8f1ea38ea59ab0de6b8609a869a21214349fe7a12992f019780076403dd71aaa7bc179663757f773f9771411621966935b19e0b120f9a0cec0338068df3352c017898835c3198e4d26c3550d418928d40e7cfdf9f5b19c356c485caac578e26a5aa464b758ba0af7a17aa7728c077f38c41fd952f958b18a3616b182ea8fb947a65a7e85334169483f4c9f546d40d32523476c3e16c32a1e561bfc98493160a50bd5a93a84864cb225bcaf8d0aea3d42d24e897141fdc96978faad43eb70786ed5c74cce9c01aa13814e5d6aae0b357a69e79f8ead8a3da38bb8eec8f712e83666db8394fea659ba883894e380f44b1eca8bc53012b85a038c5c4bf70f9e3be37239340f1457319fdafb780a0309aef9cd89f348509de0fe230e47e87d94b57922d9c41c3e909661b6b002df14093c573b9ffaf046536afdfb85cec24dd3034221a3947183844797a219b994510953571fff0a96205ca1758d3a6ab90d971c08a043eee174602f3859c7acdd9f26f4cb4be28506dc9a8e8b34c4d4a9b24029c0226f36d063481ef688bdaf8f2493a2ac410fb651aba4185b9d9d99d1223c577265365267b5cda1540e5833e2fbfafa9170f1b5026980240ca72ceafac291ab5adff7825d4572524ab96f4483a07964d35a600fef155a149c93210cc8d887d61a61ecd44589295e9c95c223a3a44d7233c93095e76d42cb858c87288bdb514519986f55e4a16fdc5b3e6b9ca9947345fe613282ac46164880d5afa0ee77a7c8059752d343416382785220683ab79d70c1bfe08e8ab26f9783b50a29ee58c7b5fec042be102f0ff2ce6cfad205eb2bd40dda97903389c0cdcd0c9982231c0902deaf1da0147224ac7ce9b58f25a007e8e7b4c00ce2f0b3dc247633f268c54041a38f7e5de816de3634fcfc473062b757f824c519fbb961ff981725e68904f87975bfd717dcf9cc7406d362bbc170ab03ce14555069b0be49e14e9c496e54b7a9ea3afb98ee540d39bbbdc13d2cc7ede865f3e824cffddb736b4f145cdc2522ae3b3b81cb1a629c729da06d7823cdaa265451caae5c203b20b81f3b87d589779f8bcd272d9ac0526a546001b2edc5c29ada6f2eb2ec6ac768cc72fdcdc388c494c0fd3c030c6572587bec8aa4710d2d789a6f2866dfc2b4e448899b843b6b237ad9b140f34aebd0c66567acc82223394b1066abb90cd00fb6205fe9f633ef7bb12fc92eeaf9dfafbd7bdbab3ddd0ed32fe6f5064fab173bb5cc5912d0b30047b6b950f766330b58857893d73e386e6c2d1f73804377940d439db141f9106574c07993f4422cf794d5107a7ce0a0d6d383600ae7c6c248da82f549493464f828f684c84f2d69e29ce0003a852a93eefcd18d59db69fca80cd5452eb0a933485a2d4cc4cd09d6f27cbc28d4a1a271324ece2610e2254c7439dbfa0fb6bc5378c5dadb1cad87e9d099bd8057579005b3c2b5fae528cc99404195c77c2b5b1b5c01219ed7b4037acf85222d11ae0720ead99646ae371be8ef5016bbbc89496c730ac89dc8c6d00eabdb66dd45d26ecc959be10d634cccf9df704f330e33874d8148c7e788b012ae2183e871682596671eb9191c8e47da28e03295baee5443655c7b8423446966d80afa0a1a3336cb169db10a9a419691fc259be35cb680881b78d17ea4e657177f1c019b4428603cab63bd20d766b687d5d65f994c3a230d91718c06e8be5749c8eb614a44919025e42f4d9091c23a06b048f7b6ab646853fb52f8680d1cf9c9efce6bd1696c04b8b5dc9d6e110f76f1f02c431ee5d1834c58a3cf25d65913bfc5dddf47b46bd35ad5d9ba567b88c93ef80119639c5df5bbd70884d53d60f67ffdeef8f7fbdf5aa53aea4e0ab449b47a219c90756ec1b0badce18084a4e1070317fe5f50222e473858d8f26988fb41f6f87a87992b686d1ced6803a01550efc336187ec7523908e818b2a308e6c32e7324bef66a31165c559225efb58a05939db93830e4659c1d1aa6a163b9e80e451c39af3228f7c69c0c569c67d3830bef1a03c3d82e5e1340e759885a10c85ebb392821d1714681fc5611758f2ed8cf23585374e5ae06e452ed21fb8fca7b629879037dce5f7707e9a7003637b6f7b7e1d304eb7c1b71c496b2e549d3349d2dc1080dcbc1c10fa74d52624087e12e665dfa6d4d4809cc973a4107049d6164593e2698bdee6b448f76ce312f697564ff22a351e5d4e75371804456ba569398bf874736db3403db0d53038277a5382cc8758b4895f41e4f7c6e099411dc869d9e5d2580bba11d26cac890e9ba2242bdf3c3ad288c88698b284bf9309cbb7a41fb2201e74a0c7be7831e223572528af3bdc33e4879737feba8263b2029941e82ceae689db199d7267ce0863e0a06d4ba80597d57bfc3393bb4d17c55934e36044432b58ad9a6140b975e84c737859f15833331fad579fc6d38a2bf2509d440015058e8b3eaa2ae02172da31b0fbe1d8581906125c54301f5385f9a9931dffcfdd9d3f52cd19dd601c7c370ded98839a0f666c5756ec31771cffb6ff89544b8fe2be721233871c59bb00b912548b2c399c9be5962f9c46b8d323104fb5fde6c3959952bf6bf78e4e39614f8dd6398879372b5f4ec9a07d6b77fce4675322f3e9e9c2f3ec11d05506a609cccfce0698a4c5b89d3c0fcf4a4942660b067d999944b9f81ece26f585020dbe8bc44a732580c83bdd5a70aa3b59569762073a7dd6c04031ec7de8b03a3999007385ea0fee12957b9fa01200d9fb6595109c6daa4050190d6b9ac52f9c713fdad8979d77fd7164859dbc2ac23574f1c6df81335cbc1609c73d73551eacdb2b436f3fb6e6ee623afcad7614864065c4eedcd379d7ffe7ff44f8cbd1a37d18f2a850bce5850c10e4a49de437c922b38900df7f1853f21243b4f935fbe95e8bbfa57dea2ad0fdaccf427cf8cf853316b315fc769b7999ad1a749e64d578696a66c95352b3e6be0ae583f68aa6d00f012157b92b504120310cf3c5045ea0091cbcdc64eb7889aa4abd922738268804164ef68ae77777832397839fa4cd4dda4e786988d775f62afd0325dcf53a6308424f44efeeb767038fa946d2ccf9e7f19092d3136f85e6285c39556b9016658fdbf4e06e189912a182a20c3235dc6f551be01f7cad48df3bbcc35c0358cf2719073f4ccbe5080b73a8c6477a310e47eef46ebd63989ef589644430d0dc83bdeb6a92bba3c7f9c56af43758b0b01b1714770746883e778097475579357fde584fd2906880990e5f729de9808347a8ef1e2ca4f6118406f4e002458b0f0682307ecef9b2692e07d8f0334fc098cf6153a639510f7887d1c5048b94afb7f339acf749513554b10770023eb83f327fe8c320b424b4d819d3bd514c0db191b54a1cc7808f992bfc2a1a1353499b268e270cd422626fc285e58d74cf956afffbd529f1808c14069dbf7f019047cc9581e650c30bb971f1ab1aba603d156f3fd347b42d3a3631c2abaa3aa7500e394968cb28a0a7f622d0e46abac257c19cc4f2e91b1e3793274146e5ddf34cf215ff998722658f4fcbd677aaac27dd9f9b7a6c708c85bafb515a410373cdf2b9aa337d7c9032deb633eef6af9240205596907001f5b2dc932fba99e513c3420653cc1fcccc1a5cdef0fb2782bee52e6aaf3760555b8a80a6b2747c7ae522d543d8782b3b47a42046795c618d0373a242801165e7b514f29fa67af218b5f3a907eb7e0b1413ff0d611a9d0caf2fe6a532c07131e7c67e3df32509fb1a589821e8e2bfb9dd0df8b33f2570307f72749d5dd2f7ebc1a7768825fc6e58047e5ab1cedde81b939e137a7d91046d54de7a58ce94659138d05f523bd050e0459f7aa516d9782e3b7f27f810f9ff8bca618330bc381f3cfb0b85e8d3a03b772156f333e8150cd02d93176ccb1884e4edda3e7fa14660981b06d51a081dca8dc638cc0b33622a6c693c0dc1afc50aa27a60f44942dd695dfa4388c27664868130bc09b27e9fe22adf57de00735c28533a1d77ba01dfbb834813b813afa3f364613d8611f9ef8d16aab3b601d5b268ba8980a97da689a2afecca68f92ba9fa25f4ab24ef46b92ac5db635b84ef3d08cac749338ee316422498f2665ea82c2d2036fa8faf086d575a2b93c4e9cfeedc85ffa1c457e400a4ed045f74ffd684028012fb1ff5fcc122eba0f19f3cb1f4bfa2a56b1ce2e99fd47ae075922a27fd6c216ef6227bdab32a8e2cb8154fb48536aeab63c01e64de9e0dafdab191b302cf25e716d9cdd794fd2feadeaacb57cc9a15f35bd418ac4d13a21e6106f3d850418879bb340ae953df57361a9f9c4350ca377e0ccb2860ebb4ac68456aa21ff24ee13cc188b8015fe04085e2568b93188da45d05fdffd326bdc2e9deb853dc18a035129b80c968447cd2ec429dc139968ae9c786de9ee0c61cb75dec134f05318feb97df7a2e2d1d0b1fbee05e201b8b8a627855a8edd237497c4b784ac1631f0620f53a788ceb5161f079f1a0bc3140d4e2ab9185a86efc5f0a91cf32ee683b78c313d5249d183cfae77c88afd882884e7540856bd39f696765c7cddaf16c664948f3044676619a568777507ada03119d23ddac7c105667f835903c2992342633c3a421e9a871f9782465e520384b0875576d3a9c6baeb8aecdf1a78f3afef8cded1f44199b6d754ccd7d328aebc0f24fc2efd991cca6ba3e2aa715cf10f915d2df45555dcc1d39aac91ab4c507db27b0694eb6f7680c4714ee51ddefc331938e610f362a38e382709d6a12669242c4ae817e29887e4c6f374b849a4cdd19663ae374a38b209314c05b378886cea8b1ac8f2c7a72da1fd1b68bcbd725f55fcde8e1d398e2207157368b6a6366e80eed5b3c068ca2137132eabd3281769e17a1f4fbc05172caa3c33a00b86fb7cf9f694d9144a3fd4d19a61aa57897d3d42f6b642e3a114149bd3fcaf81eee77d635fe587bdfe06b5be8661af98be67bd1a95e2806de5774760a6610f315130a21ed236eec526e76f5d1544b8d64587f6540a300694f944b434671ba84a431a84e9394886f99d4d701f74741a8431decd86e67bb0347621c3e8225f15770b8f3cf46fbd7c9dc393f62bdbbcea9c0b2fd158d990165d2d7da68f335362a4e04362a8be16141038c34e50eae4c95d1207e2fba2058a7a6782080769c1440c3ac600437ce0ba7e384c00a5d9c44d62391a0081289ceac3ff9b733b6f742b0050754a31379b70357ad9fa6dd4c4e8a8104c542401e16305d8cd1b9039f5c9f55a672cc9b3748fcf9eec0058b2e278b55c705c0b626bf1340e18315bf6f49053c3aca6635b9d8fda9330b21005bf5ecf84d47545d1292b7ffb19cfa36c60810e09f2cea67c62fea88ba9589c09f06e8686877bc1e4b7848e29e8ad22a4f249d8ae811fe78260d02a8d6537bdda6d8d2027db9cfe5fcc7c5ccf7aba86ae54232c93edb1fce9c88157d41ec489635d7018fc376053b4e9c5145e2e5c7f02909fd377fcca9e9cca4bc9c90cf2636f3d0d3170dff1b2ed3a7422e90d57522175721f20818d0264568af3b24772ba75d40bc0970ce638838c667f3d19d0729d445023bdc50bcd94585558bce69bac8ae8e6cc90a463a83099fe504376a3b32c273d43e3b1c183f4f722f6d1ba39a6f1341abf59c41995b1ebd25780b07b9a52ffd4ba417128a8fc21ce0acf5cf5b0bb6544435e043d40ea382d7f3766b6e8b3412fe7a537f3798465cd7c328f9ba7ce6e3cf0b9b4ccabeafe4963dfd412a51947f8dbc554ef95fc436f7361715efead47c5f30c213881cc2cda528ff0c848a1be995c9aef549857efd97c7bc09e1387237b3a0e2f1e5e964638bf181e5aeaf5b8279d6fc80048178e8f39102ff9c8a2a536e9e1b2387215d4356abe943d0aad5ce50d0ff84e5e5ee436e05a496245a5cbbb2d7c4ba3f5e4653c2ee6397436fb676fff9bd11419f33f4e9e8fb962bdde5c5e9218c5102c0d095f1b9fcaeffd472e00815042624976e751a6d43d70af3eb24d8a3972f8393874655530c07a3af1a1656be5daba70da5d9a328836c749d4140db3472508f96abe1acfcf426af1a0f7d9e00b4320a90adb51d6f0ffaf4f626f73ac90af4c2782386a8a46c6700c112f04f19ac10ad5002c8c8f26aedc0fa99c3b21228f223396a4f104d9767d7e127a1a516c4bea3b28ce5545536f5b9ffcd079784a144faa802544c398f3e767b0aa2a61482284936d77c19e258d253114ac9419bb907b8b20ef83cdb05a56395af905afd3f4d0dcaf5b9e02b487d6e2062dc9e7b1c4b9fc08af2a692906234bc3df3a74c9b0cfb80d4496c9dd13fbfb96d343a647447677424a77679b46168d654ec9ff45c0b5fe384c0f3ff518ff9602dbc2e13c8e7952582ce4eb2c41eb98248ff33613495c6ef6356bdfbd0b6be60836cb4e4ed36a52198378fbe1468bedb45d0bdbe4df69397ea3e5e472233d39544720f0c84e2fbaa44138e218bf877c1677e42650f48150cce8656243734f6ae4e991d0f2c318af4d0f46372600ee07f2af6f1ea6d92b0b7fa9ca7840bb4f26da717a9cde136a6a6f1907e2b7dbcd785621cc970cba7a3e21d06d6ef1fd230b2a924eb733a1590a1187b473438ce1016cfa740f5866b8f802119eacf18e7326961650e26003c3334064b46f687ec2883819d26f9528210a5287ce749e7f019b17721e6b56e254bfcab80d745e62d2f795388a7a7994252ee4ee1317342cb2c0eb598e00d338035ff99b94b2367cda8c03e7bed05f27492738742320547dbf4bf499d92c4802cf9ea7f222979cb967cf3089ee45cacb655014379dd7aeb59f6d184e12cbc8e5d4401a5d6321a642383f80b700194d9e1b714b5ce9af69ed365722ffa75b687ac4b8078810bc8ac4972a5786ea58c9396dd64b5437a62ca0f14c72386740e936a96d0ab684bd4a5aae1aff761177dbb0fe39b68b642d0af83927dff7bbe9cbc4f5fa7c11103e358e1c07a91dd2b8e390742541a365deee9f901df3b01da2b72492b109d85ea9824f15a914893d0c27ef4a85445458174df002eb4fc8831849e127d08b378db25e7d63cac2e43aa858f329ff175d2d782f4a6feeae1f33de53e66e7ab7f9091d8c819e304275639a272091a174a44773ec813a62510bf285df667d5e4ce0560008393b4d57aa013399846109fc0b7da028fb197cf9d49bb15680635b8eb35481bbb3c3fc1686cb40b1a311a7254515e4224c7205d0e3b14541aee32bd420666f3e101310c190d60099fdd56c6e5143774a6795fb82ed3957cf014980183ff18eca0e510bfbdd4cd507f844e1fc04bcad8452b9f9d91a213ac78269a7ea5cdb42fa0841708f5b676ffc58097fa754bfdfd77870852b87cde86e9d6935775a1d51601f19808dec5c5a27550a06500a0773fa61dbee3ea0b6791a3d5ac682d02864e4f7375474c4415009a46f9549ead7e77d49d549a96636c8137d7daa18fc6a4805be7af40869f05bc5e2b72ad60ac51a75fcd597f7c6b25a8f07cc2350b9e35a096655587e4732368766e42dd7d8921aad46e0c70bbada1d9573401f3bd23cfb264d03ef3015f40e0b76f97a709f12e1fc69b8d44c36ff9aae3fdc8465ea5aa252e1d4a20651ddb20354ae99f1d12cd39b7217f89d0c972daa71f0bda89f57a7382b4b03cd358a17a7655b2a18f7e4a264e92dfc79b2c9a7e9a7ceb29c61af332147b436231982630729da496faa7fced00713d789a1f46a1227f2fce23f4793d4e328451d15b4c2ca6054c87ead87a6a61b45357202c9496c3c96ab8b43ef876ccb793c2afb8eafd2108ba8b6828da8f13407ec404bcbcc89a7ff7e7178960994851131d1fec6ca2f14e211e7d7254e04d81d5fcb7b1b58222bacde7826d9e11a22822cc51c4871b8de630173af7e8dee24b1deb70b472c205e1c4728d1bb137f796c4ce27d2e52580ab8a830fd6fcfda6432077b92cadae626c7cede7082b1cbbf6be46383685f84d57bb2757c8496ce7961597c8a040d2884ca2820feab82269c5b8e79c6baeed95ff77d3ff39bd364abf4bd307ad60b58d6bfc198f4f18675f5e808927a278b4b08b49b66982413e0544a0568ee93e8f54cc79e8b8e7532b43e4d3006d48e2edf7454ce9fa8898747207697956b569db7eaea42b3d6db472f3b8600197d9a339a5048005a3453851838ff97784781ee787e5b83a5eaf8c5b7001de960107a780a38986fee0c250387805edb1891348440e8a42e3af6c14318c56b532840a74983e495e7daf6ce05b7e28c761b40204e4a7ad9ccc349b02ef104c58316dcf1afdbdfeb0096d06a2666069077be1a1ff76077f5b2c3aede9576fc4699ca898d6e340ac063b9104eefe0f66c67816fb944c468b2c6dfd58f1f46fd768bd3e7f2121d698dacdfbd4125b7720924b29b8b221e18140f7a26844f5d52212a94ec71c596749b15e7768d62294c7c03501d70ff4da4c19772958504f19c9e6af020d359f7c5a4a13589474870a2ac5ef71dc18275dcf52e85b0874396ff46c338258283f8c4f1c4828741965a2faddb97c2836ced7711691c82638cd6aabd67c8b8f3f3f076ead683be9052142dc4d5a9241b4fd7c5b0803a9f868cac4f64c0b10b7123fbf227bd36f1f28c15a0e1e3c55a881cb2a80de28ab7e5ee0504e8a7b3d94544f5f7ea060bb3c1d216c5f548be29888e8827c638b465dc662bf580f79b062c8bbc0595ecb10afcc7e48135e86bb33d4c0c09e0df8fe620393f5584e3ad0c599758dc9358691ce7d6dae038b45a8d52fb3beafdaa1c01842677dfa53e18fac97eff7149924b478a6a28f3395eab8f2428ca097e5e937593be66a06b5adce97268786e9787c18c1850b1df41e6b05e459d1067eabe647939449331bb8d9e9826754816176fbc682c01324e08af6fc39842efa9c392deedbbc07bd7120c3f46f9890d4bb93b1b894d21a22b4effac63464c150bda3cb14e1fdb8fa795cc709a12aac14f14eaead4e69bdc645aaf77b96fb6f04931cb9fd97bccefaedea0a86443aee73676bd2e6db74a720c3f534249a41d42069c143bc8762bc545fe3a4806a2208511bcb8c81c70a033bf977f99d245b6be5b9d48208b4b7b49c3a858ad6e2101dfb51a59050edfb72e92142b2afe4e9ad0bdd63aeee3f50a6ce5fb70d0c2c3b83ebbaf8d3a2383f7faee6082e34eeffe1c21d22521a521a08f2d19cd160c41117ad5e520d9751f882f30490c5ac843619656daa2babb089f9800acd87f7f2bb43feda7d255497e53778d71090a52f19ed72b032ae2ad9c96f38005d25b1caa67753270dcdaa2613b16d760c7fe8578aa5fa1f66b96250bbccb935d3267b4bbd494f9f75dc60ec9f50e5b3b73e6d791d44f9bd6b406e198a8e3df507bb728b72e4a5aada3ad090fa881670d497ecc1871fe4d21c573501b149eac405319532c6f24b50f57400c39cd0209651772fa78af37e86d5b4004266d4de663de3cc9e80fa098b4a38cfcaeae46791c52e53cf054a3ad9f63e08424eb7c21a2c9889a6209e7ffb48b65edd7f31f68574e77bc6fb3292e8af626c5eb86f2507e8da3988c712d3e4582bec5c332f7f82aee25a0faf948be3c37d3ba123c6fd41bf380ccab0febdb9200568bde89459e9b4b827e66c659cad8ff8b366f321b77009d7b72a221607a5389cd89684d706a0f114b44feacc4118d0b86b729c7d74459973f439d5c0b5f25f7902a794b23348b5d3bac25442529da74339cbad5651235e868ea8c5306c4235872178633e842413ea6449c75c5e9c52285b16814f50234b08a063215293ff6b9e3fc81ec63f04a90e8899f097173da4d77cc61265de0358f6f3430f8676ec4175ff9aee6786fdc5e2c94ba329ddb54185d429aa8e545345475ad16864d1e2fa639f615d9fc6a8d1a1e2383c3bdfdb6fd4b90bfcb0f6d54a000f9613bfbca73a34bcb38838d6a23aacf36c84451d7e5736b129d14ae44616fdfb8e5b0942e9da5c27e5531cb2e8e92b8f472431731335e2c9b9f962964d4136f1e8f789dc6c171c46c65bc57f14187dc19ccef7fbcf3ba69f0418a87a4dfadbefa1f21e98b27982844b01b7d4acc5e4c2dc9e0754e025a3456ade1f70e68c03cfcfbb13505a9e02d35e8cd4fc2b8444a16e5a5c7a34b2e9104e5c2f2a29f0c2cfb51ff33e8178618ee460334d5d433d5bf6cb564fcb650ffcd8b44c57727fdb38ed206012ea27388d6e16a27a2d79123beac2db8d1b97dee17cf2d527f962ccf9151b0fc0add15d8e548e739385b9387584fe4a8662bbfa25bb3e172fcc00085f4ac5b3ae96e5d0a96b51b91c30921c34aa68ce255dcd3bf0f47129739cfecee22fbed445d69e497f72cc70cb46bcefd1c5a749416ddaf6dd6d3e4f65b51058186e4a133dff916095a2098d97273e966c9a8888f1d3b22b3ccdee9dfcebc225530d9986ed07eb512db2ca0028ecef0cfa027eae96354856fddbad0dd5491606cb5180855f6eff1827e1d29c497e32335907ede7c18eee0a06ccc3658a66cea7703a6b687ca5f5acfd7a1a88652fd3f58fc0919866bb591fcb95c75c7ec806379364ea9dd93baf6045195b790049e822f98f1e825eb2313070d8d1f509a7c2d4dba5cd2d0ec3cc678fd9d1d52a82cfd20a94ea6bbb2f5653073512065abbc23632f776dd96ba19e8f2e39b189fcf7b9d079276428549b636f186937af4463f1a57fb01fcbc5c647eaa767b5b1ce571f1c779b3d380c968e3122d981aeb007bc1c5d5ca65427a62d1eb1fe9e95c9354c1334290321f86bd6498c1ad359b7de20bcfa8bbf893f8de4ff23fbf5ca2fd9494411ca008e6bf1433f1b0bbcbbaac7ec3f5c3ae1d64378921fad177250c2c5126e2c97a7cd704f756ee348f542a088fcf1dcaf39383e1689391f40b6440864bf606894ea62958c8eb6a76530d437be23d4b73c223923b8475933588b1ac55d691ab61bc57712fa8d8429832e0b1ef563405d8ec27befecd2d862257fd929afb9f7e4f994a720004ad5be9233ea37f9ecca551f710fb6257d08115682fafd414ace87d85f8c37c87a24194862760c95a805f97e870f4122a4b985d1ed7ab87db3603a31fbae8b1b1f2c3583ea5b4456197d20fe9149d62a6a3b31a9dca67da9bf76e4d5f426afc38140f204d4be55876ce46bfe70fcdb9b896fbec9e037ba3393e17173aefdd4310c6ffd3f8137184ff86ad41651d9493ec2744503a5eb859b91de31cef43c4573867e7907d3e774d231531e05378d23cee22a63ab9c78cd885f57faeaf7ef4ab102265a5491274d8936d1701968a1d29a1d91936c75652ea335a4a54c0d9a4b4ab410675f3fbb4120b7288712460d981156c336571ef42c12669f816360205b32d7da13066c7eb84725f9196f96d0b923f0e583badec0bf27f124ca6145618c1ce5e3a53f89dade6c64d39fdd4324ecd04436bb780f6ef139a3073d4593a97ea8659f3d2b1c00495f042029155126ceed72a5a78d4d263d822c537d4ba204f520574bb936680ae91af07e6ab5c77d44d4cab0ebeda3a4d197d513bbeed4e109448486f4448f37e29ee7a78ed0d5cd63333dd6448864b8fdc67bfce836ad47595e51f89f608b2fd052564d646e6ac19cd7b341629a9d07feb9a36d046622207808669225eb0af9b6a7249804d61b4fc5bc8fa67773f427c9681026b7b4260bdb29614b37a42c9abb1b71c63bc30fad8f8571b22ba60fed56b0773a6507d157e564c7a5693d19f4dc8529a660056dcb23b8f3fd2ecbec60d359a3c5cf833dcff2d241be155e6cfb03b8c4961ed9281aac4c5a2cb09fe1d5983b34d077e881b7c2e7b3f176ac7ff73407da4e6006c5a8639d98e584449de5486e09175c533a350969232c1aea7d2a914416c2a55298708ef98c58629b50e48e6408b3967e691d4fae836f42820cdf3f3c11a5f8c3566c08c482001a3fc17f014b6687652bc1c88fd82bec6a42b79a4e12be69e8596453de84e9727e02a2c0515e3ca3cd17dfa3c1783f87f601243e9b8b42d961a21e7e12d88fc5a5271a9726c49c56049887a811a2bd19ea7f20ff336ea7a55fc8524b7eb57f1424185442801a7f8b64af98f57293d23580aa747e570978e0d2a1207c67e423b96b1a0405fae7d151dc13946db374779112f691558e5c6170461d0c4c329a40953a3b790ece0d300d3e0689cc60fdc77da6dd1b2fd70103fa980dba436e9983ed53015ea007a8b2e667ea253f4d7d25fe27d7527903409f6a26d3ac700febec24203e1f2c9d226b02bc24a1b07aa1ce08b1981ceb0e2b56c2a01b7e45c2ed808460c8a2003c3ee90557a4b0e5422b6ee8cd3238fb40f63f08330b043957df0fa42562df4d203b762a658f28bc722b8c8b26c2e7b1e32a82cfaf3ed3b9180f1f60663a07b3936ae922df3a13d211eee89bd7381cc57996fc7e8d7b74cbe34cbb2c5197da2f9f10c65bcf6bff25bfa13668a156ca0d78b695105441b1b471ee97586a525a210161e9cdc8522fd9150553cdcbc55b8d2c5a2af23560df63f97452e0cfdbcb4322e4eedf4382ef2223ddb5af41f0377249dda49d4c489d9ff90836e12a682cb0d15a9b52e524d0052bc131c5e8e49e92e948a0f53dfb2f664e5e971c3378ab64c32a0c7ae737bad931a423e94c6b68d0a508f4ccbb0da1b497a7b009779838913e8084f82116804650c121bfd2ba73af14314b6c2c99c87f0863f1d58f1ce210d6a8d44ab37358f7f67071154b711c4fa5b798fa1e4b5879fbc49a69b355a04bf78e97c26347f9447500bf35a5c79d71f2c845d789ff46fe33168fcb62850027dc5250fbec898b662505bba4480fbdbd47d8d35a9f47a2a3b79657f487dc9cc8f9f4d728badf088cf25df76a223d331f","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
