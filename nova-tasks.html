<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f4e75f9ffeae36fa817d4316756dcb54252c88ac83f43fb5c11a343793e8f4ed3cddaacec57950cd2ffd990546cd6f0ef8b5c5f641b25b73f7476433f79deec77a6f7779438915be278cc041753560af8287cce946a4dc1903e494c5b802236420d071816f35f13228c3eaea62006cc60ed3f6ac0323474be60244bc9bbf61132bd20308a1ad4c1610bfd160bd899dc2cbc967675d715edd720e7d2cfa328ad161744034ad0b124366d3981357111136c1f80c79cd4530339be9e3892ce6b460298a8e5aa2818b1821c34cc1d3ea1af8cdf12c0825e06d58c19629b1bfbaaacad9a80292dcca4b0ff7e784441d0eb1cbc47e228262a1418e35d2275cf385570248b04162256134e473c1e84c5a3cc3d2d6b836dc679ae6be3fd5c5e79a03b219fd4ef368632d2308099679efded488c27cfeb4d8b11410e4c7e2264d2923d7ef21f94b66c433084ecffa5fc340e2f63cc9571c267518212681e2c7f3cf1f2fc400d24aaab37e9b159a0c28abe3ad2ffee32fedc2d6064b0ee5f679745bbb60ea6d6dfecf5168190761ef9bd627fc3c6f02443b259af1ff27158da9870ae8ff69db92c7198499ce61aa0e36d4b8e5b5573940b77d925a5b3a91d484e1a2ff87aaa35660daf0c153b733b109bcaf3c7186bfd9f294142eb2f8ccbb5fa9ea562d0773efbd67fda995951e99267b990a1575f6bb16ec85ac8a87a3dba1122bd6ba6994365d08014a114c86f5257cf126bddd3c56afb189b8bf3a22cdeb731163d2be2e8fa84afb6824a34577d2f1b890d62ac34e9e73b96259120b4d279d60ae685d058ba2473a80b9df64de7928f9ef82e011055e46ddae5796518f2a6e6c3f8a146eeee9a37d406f590e09d55275f693f6de0962778e0da3196a24c3849c016e63cfbfdde99601b2247ff4bfd72ceed87b3928f5e1e480635b204742adaf15d7b8cd1edc30ebcb6584537900e0b566edcc3c6dc16cfcbec8796e245efe4640e599afdaf76ac3bf75a896e490fa107cf9b373be6d0784e93d83e94176f054b03f2b33a206bdfe467ac01adf8a39f1fd8fe27c2d98296bdec9d1fd1d50e8979da081fd5addad65364d708d29fa1fc07b1bc9e1e553acc5b2c0520d9f66fe50b7f6927c52c3fa5561b4f6e0147efb703bac94ad502d6caaca74e516b3862f27827842e3990adb1a29282e85766c0db2ea0d606f7f687653d4716f59109069448d22c012932f236135aeee7ec6023f4b4dfae16500b4dd9c36a5ee804060a30696ee91e991a959c7c3fd6e77160c1015f4cc0f78397d78c101634dbfc9aa086ac4be68bc81182cf2656e02175c90eda9db5157fb8e72f8bc8d520b2fa35b2509732c677d5a6bfac37dba6701a1d33066219e3c8b363db52fc62ca9bc553771a47bab038b7fd6dcb49fc31e5348da3443fbd9d69929113c6ba0837a4b784f59b15a1b05baa725edd566c0cb024d835511587365ddc013388616f7988e1462a6092821e08feb563b668eec338c42d97c74b7458b8833f4ee3a2a7d26777fef8887f186a24d381f193f46ee8013790ee75eaef7711c3107abf72c67ba610ba44b09f36fc10763511acf189ce62f7d9e5c2579bca65443d520497ac7445a567a9dc88d4e8f0451e34ba858f5102c6c19a0a8b0c0e87dd2a0a3d05e7ff52b5bf83e1bfee863fd4154e72f05c5e94e735db436aa2e6ee82d2f2e6864b90ee651bbadeec41f4602cd72cdc1a4041028e6927d80e604205b9bf188d0c9e75ec7cdd4cc512f1e7b56d4afad24ce65d5a96b172736b024f72c0ad0d4f09259e03e22028906a5b005eb6f29b9891661d5fe12529417f46ef125c5021f10883968cb08695f6c072a7a8ce8b6b939a289e39155fbbf560a37bd587e7b35ef646f1cf9989ae62e7fd0606f9ec3f178f57ae2a47c2f172a09c63196d48ede598783cead1e99795bf310dabf952e39e5a193bd596c65be735c312544f4bdb04339730780c734f06a8c7a7908b1ea5a1602be13f78586573b976229a0e86d13e09603df1526711f3098d0b5699ed6a381d138c1ca6de678aa9d1017d9554d0af62ff58983a3057168389f7df5ef421467e11ea16d75053183b92f2d14902ef03cd9534ebaefe9c72d6f0b81b4a4ad873afb0b5e9bcb0f2a53851fa54b4cac31bf0c4d0d9918726638d5a97524351e93b3bc97468c23043e0268d1c8fc6a48800b5c2f253e10b65c67e15d52418f02b74d61354be2aaccd42a7e731aac94f189c8a72202327e7ae8dad688770379f3e905431724eae875690bf804eada78637b4bd161e4f375a0ff033cff69039944857745378e88301682be883cbcebc7dac390aa576ad78b5d6ed5b0cdd9cae7a6a70fc94463c905bba9bc362cd7d007b5045abdd2d2f592e54a61c207017ca329fa787e233e5c301e45c971dd861673d61414fc38a8547b48cb67e2b12ce7ae83639323b68fcc72fc0c18617ad3a9b834b4117a93ad8d21669fe41fd642fd10d0a33f4f424174645af772f3aa33df9c34e8a7bdbffb11334ad479b4eed53628e4f424c912c02d217c69b190f61f12f234480e18abe17a7c0a55144144b1ebf0f5b78c40e178de5399d0d5038149a86b84478d6692ca36caa585742de55631898f5a0b8865d76f76004c50faf0ecdcea5e80f5303b16b0268f78c73b4d441c68a6056eaeece1b84818d394fde11aca6934630d0bf4c639b3a5a97e8ccf363b4b6865bdb56e52f9a551bc6ca6107a4c69e041acdfe626218bedd0f74baa2bf8429e74d630ce9bb6777a4a4597363e93cee788a46f517a57a75cae0242a779e8e0f14f0e3c7630c6e5e4c5b520bb1b829c82dc8ab4d7d3013519fbc62adb6f8aac54409e756179f3e1824a20de616b30360ad191aec4bc9777a52c87a8ef7adb7b2cc3ac673d3e8c4bcaee97ad7ce239e88463b711376c5b408a12b6553210ef52f4252db435324bda4e03789195c8668f56678f0e5baaccb0545790d2ca47dc82af4e7f11cc47baf9304bd2399cf8766cb912fff8a25a33e27837c2ca84adf827eee7804db718b8c04b760696ec282d1653b3c693e9b469622af2cfed4f75e80d33f40174b9d07ca48b589eec3d680da181a940c32b453a61004c94d7facdf32f6a51cc68ac5e8ccab6afa4cd218069f79f4c5e87784669e58980b0f392325b99d96c0569045296c58ecec9e8e280b6a436c231fcdb52ed3a0e6a36606d148d0897a020c70478b38c8a9ccf1576ecaa9f3ea41dcb1f70efab9fba29ea9de6855c930ea989f5c0217b9dbe68f8340881f5b06c4216c89032349b3086e69224fc794c963734e254203f74dd6baebb0f219744e55d3d030110f07d9afdd36958d14844d79fcb28c13dcffa3850cfb850d6e3d2c68644e2479650612967134af21178743a7c0d4860ab4c84b75165ceffbf4802800de2b8b72dfe5eae757f3a6922f5694cd5fe98c00e30c65fc8ce88bce9156c983e384739343cc0a6ba40ff6ed91ef9a473409a25d28cd3abfd039744380096551e7e4327cd074b8a2cf7ea06ffc82e73d3f8d009a5560a8d85cfbe4ab08369e8e425fff3e0f489154982ff30f0e69960cab5cd972f38f96c4cc162b0e361a5b240e057e5cb4ae838308afbdf83bff84bbd7a626c10471f681f6e1f62506158be3deb9e211dea7d2f4b22444d418b52f036a8b8192582702e59d522add0bdcdb1a0064b0d6f24868ce2fec9a706d6efd6925bd46e11f4b1363b629401f163bf65c1bb76124fef52078da029a2cf769d9deede351269ddb7faed648ece796472c0dab582ae59ca25767fdf979a2e23f0932cf64e1d953d759ca7f7568ff4e626077178ebcfb0e827d2523932bc94429d8a709099a8c257774bcb856d83046c42b743a897fb5cc75d42dd02c905e45151b95d40c7fdf53f8bdf321ebcd9b4aea45635702538a78bbff35ae12f2982957ccea0b0fa51549403d32a19f8157474a2778f05dee7da26a7913cf42d68f78e8ed8ef9966d321ccc2b8cbca05b2c3e2ba1e115b56b660c27e7e8f879c1c141037399904758835f1992339d085c91789e8032e8204147de49513a0a2cc751270bcabb8adcc79c682de7f4df3308542f5223b6c467a65bdc9b29474ce75bc0e7b38f12eb0ba3bc7fd8b352ae12af323485ab71b0ef4498663715560378900e9b77d3bbae410742dd9cc6390d428322b577f913cecad0d4522a9978828acc9fc1482bfca8d6873928bf7a1a600030c7136049bd2cf7af4bc9647ea140e97320d0404d90023ec99957e1ae4d9c478bbcf2a6e47d2c2c767e0250c8909afe28a13a120322465bb46edbc9e704400179758c8cc6fb8f48a275b4d03b71ceb3da7efa3218214b011fab92bf5b44b6268d3ccf2b3efb5f767fefc8ff30ed61f93b6d988f91b7f8a4a6fe7748fd052c924ac20cd360a285aa2d94e18d781dbb150e3965e6f2661aaf19a106fcb33b250a0abc349310d94b192886a6964d326f95917f43ff6ba2fd79f3cad5a47fb03366443f813f3a5bb485f27ec6bf78d0b7c4cf3c4ffeae13dfd03afd5891880ea29213b806af2515a7b4f7952f396c0622a52554d275b7a34e9c5ba1f282ce11430ae340e9acd8381a5e1205f375b9afdf72ea67a8cb680e033463300ed7ab87765cd99b25aaab22c39eca24a3cebf2cbe45cf73fd49ff00041bff1de26b96fde66d2c0d9be28817973ff63718c4dfe04929dde847cc411cbe517cad0bcad4e76dffd233200014e56cfafe1992adc96787f2c2b8cc4a7112802052b19e9e83c8e25347832330f0c592de7f6e0b93c9c7850a856924a973a65e474be7ada36a4b4faf5cb3d04966dd8616e94c12f397147e9823b5e58ced2e7ba5f09185d7b6e9cf8a0389f756a1cf3bc103733b7c948d9252d77fed1c3ec8e03b53e5362cfb0f5735d092eefb551ef9e11e240c3275201882d51e4e5b75f9c129e1f1f6356c4962a12ab0b8ed5437808245271d7e3a1075879a23ab06e3ffa4cce46ce8283a5239d779f847cb64c111b63f2eca1f10128404ce3182d31d6556fed0272e0245e766c4f5051c164057990c0c9915cac427aee68b1b80c28b5eaac6d5cd21c0b64245ee514717d7b3821aa13cabbf4f510ab8aff10a06221cb8b06eac1cb829b83e20e1c0bc8b6edde6bc9eb5c27126c21904f5a4c74851dd3250dd6f6878ef11fc7ea6d02796c1612d622ea95d729f2718575ff4676f24439aed75d57f6c82a97028c44cd4d83738e02c790b160138358d6b259610eb20a83dd0ba2d8f4bd17ca035b87514dd1873530c77a85909dc0959aaac03f76cdd6e5321f1cb6a445530b3fa59a92f6a5fb7e99058c197cca7ca1ed51ddd350a26a4a24c2fcae26b2b73f55e6def1d913b3255318dd41f42d5f90b916e0130f39f693c186b1f1fd420b72898c7f09f337d789369deaeb697cf82e35fc2a1e7261bbffd8a8e9aa8dfcfad48174fbdc187e533c24811d3d21618996c1ad8fe21397a9f159da33acd29352b4f4f8854bab263e95ffcf4027575ea866ae080b964da021df977cf5ee1df59c66045baa582e1821dd81a81b186e9dc70d8d27951d8aaacceef6a0d3fa2c14e656cabb2cc2a1d81b4c07dc3ae8bba39dff890fc3c2993a3f0196cb9767f8de00d2db009f8de280df84ef95520da8a1f6fb6162c4699b6ccca68e7e8f8e3aa846b6d5e9f2153be9ed8e80f650805b75ff86cd001371f3dfb10a4ddbb45bf7ab7c6ed4718b1d87a1dab5c5f0bb8a765f724f1e150ea619a761cc159a50517c566be8feda80befff4c76d7606a3788ddf9dff17809b5bc48030d4dbb4926a2e92b52cbe9f834c34938a39f66b60ff937d6fe03bc31fd9e280b924a0455701eda2255ac182a6578bf6aa4ab5567af9c279795af561144937feac397475baf9918ed8b0b49fcc8cf9916498b9d3d3053aa336e4567217efa7cc7b76820e63178503f8fdba8ef1d804a9d6b7d46bd211edb5cec6269b06a0db4563dcc81629139abd6810f5d8eee87043348974fe529c98063bbcb7aa0fa0d1765b706330ee758119a2e04e58f72f1e373a6fa8dbc09e42c7e03ec4c2c3e347dc875454d39bcb74bce459fbe3cd28ea8d8467af5164f3df3ee9781f0f5e9aa4e0ba384349bda3d1a9274f3c8ddc244590bf1dcd6538e8492587f5b178f89ae58562d86e6e578fb2481004eff5a464027cf3785de7219938117ffd42896ed037f2f0e0b2c1adb1ae678f88ef16bc74c16216fcf50c6139c129c27b3fc2ae3e9a3239c83ebf18104d3748fc301a89aefb633fb8b55664889473b1277b6feeaea9a7145b9a332df7d2299040e5142602613359645aea14f93c8174561e87b72a22acaf261bda55f410f0a25e97da522ed6fe989d048604d7fab86a15daa5cfb9fb1153ebf212c3397119fc1fea1a1dc7f972c7cc26d4ca4c9f25ef57b5311d633897a75ec7719ef17ba271a9a327bb4507781996ab91fad9d044713a7d93150914d3ff873ebde07e73038698ef2aa6616ccfefe992255b939af7484cae5edba18646b53508328fba7b314fe49348577d137c5560be28487900961569afbe8f7c0d2a53523fe11f26f15e2f983b9e6dd73020893d07bfabeed116e7cd4349916c05ab60bfbeaf1cd31bb12c495aa0d8c81f50ce52aaf23530bd7a2ebab0adc086a61da030215fef2204bcdee62e31f3a7a181986c02918fb6dab4237870d916d7e040de815d3be595c3bf89192c665ef89006a0a71dd16b1d1881e4f1d12482b0c5743d7e53f061ed2ddbfcf934dd021b3f6ca962a0dd66eda67a520e8c4ebe431efd25e9876e3b561642f92951456dd13bbd082fcb793af2fbf0e003a06087ada8aa8eaf6b8da013a42596b17f1747c03d92ceb287b369d840bc5ef202d08af1a5660f42f183fbac97d466a730269ee68351d27c6617019be554eb9fae7aa215dd1a4085396881387c8892c9d9e867472eb1a38be3e5a8f9054849ab0df180a8575be65bdcb10edb7d569b2a4a35f073c4ce613ab539b91bde03a41b32bf62185fee15bb3dbeb4ccc1e23471144c92d3f3828eebc8c8168e7a978298f2217fdd78d6ed4df5e93ee778ab510ddd1fdfe0c1f6e8a3237eba47afee25280db93614b3d8c8cef0840b024a32b5ce6c909139f6af0ac469ae0c4ec7c602e9e491e270a2286f26d0298ec5f591fbac9c1e6b4352b32a346999cb27a4e1d14884dccb306506d864ae6922950b5aec701114c27f04a1493740dd58082214ce5a9e9df959b753829063a7bec2218b1f4fabddd0d010f9f77a9631876185b79d1f07e5b7e8cf251cc2cd5caf49698499b05ff6b53b96c5cbd05eb8aadb5a9fd25df7d4c3d3f6421cc1c1bb28ec908b8db653756327c6caed238bd1beffdb045fae0d2c98d05580e2571cc2023d8a990fcd0d782bdd8cd8b809772c80e7331e339080ee9020da4b2896910edf6deafddd9714fcad270d84cfe072f40b8c61a2e4fdfd0085baa5bca370f6a6f54ff510b74022252a39a02d9dafdc9a492b4b78ee69b93b4e0ef633fda990f6be97152f43a91cf0e7cdc4ab439c53270b230dfde688fbbb3a01cc1e0f26366610aa42424871d5e1a401ec5693002448f99ee3fc80e87230b1aefd6f479155dad9ade4325e6de011810e275e0b78b6311de93a80f8f154cfe31b12e6166d9265251f6e01ed6314ef0e5345520c25a6aadbb537501137197ddb1d6d5ab6029cd10743300744c75f1f7d05f7762b40083c43facedca80f1170df5b916ec8ac288e38f93aada341f8cdee1027ed4253a39a6b7cd3519c2e407c6454a24aaa51e1ab4ac9179c6b1490efec7b4b21eb1e201b02e88c5e46e911c790331f613ce91a1a4d638145312832c422983b80561f9a9812e079bdcf59b13621de1c51a75ec82a59aab1e72140534ba9c31cf9c263dc397593da287bb295d2a56d04c4cefb56226778b8a3057aa58ba421fbe799193db46157bf34783a1784e3018b103d7f2f2b8b97a5efa53dfdb4166555210e749fa0612dac080f0738ca0ff35cd3270182d412d92fd8a5bfd2eef8e4dce1a0db4e3bc745a404fe16f1b37151994ce61d5a09451f3639f58b8652ce8905b7f81fce2d087729ad6be5cbea0967db5e5a8dec991111f1c4ab7fbd178942f4184881b86db4d416ea9806ef58da64ce5daaacbba90107dfc9952b4cea3b9c769d2f351467b7975c84a7aff1b062477704cf2833705359ac01388a7f3ad872a59b80195edf1f02b295eecb4f462f515696011a357983477e680670622e89e770be53c28b4062e273af0fc81aee07824584fe4c6d93a3b715390b38a4ad830ac71a8d7483b71b3a50d0ca4a75265db2554b38f4b35e51c0130066030b1e78f22209048f681b5d4da4347fc9c20094b8d60b28380d4a1293215331358c2d8a844e1c9e5156d0e8413d64de13d7f979b97986cbe9e75e26dad490617b45fbbe38c17c07d71242ebbf4175c40d4341b972e8787e5aee170b0d9060011f350a3df2806b8e3bb6208380b6f32113e1959b99bd410fb7bd0a6ce172e87ec14c487ee877a712162276ccfaceacb222f220ad1513de7fa7efe15ed6620467aa6223d578a77827e1f4d9c8c529c379826465e58e83ae1a2b2a26b2cb7642bdbea78b7c3ade043c79728ca15b610d6c30d9648c1422dc397237efc8e4b539ffeb3a71a20e78b057c499a3cc27075b2b362d1b4f570423bf1d983a73d4cb4d1ab72bee60e369ae35fc93240be6568c87374c26530c36fbfea9176faedc4966263db977cc1ccec03f99f3b054129d77050298611c7937aa1e53f198ea20f5ea5690ae4b3f6bcc18bb1a189fc95f7df5535a13fd1ea50f40ba4975b221fd7a02f24b7afd81c71c305fba472ed7a1c45ca33fe1ca4a908c2834cf2ac6947db69fbc81064f2ead2ddaa763e90be7f347daf57e2f870c165fa24ccd7baa6d62a5699b2bbb9c999c040d2de842aa54e90c1831585f4235d3cc7bb0f4a0660881ea8b33469755f73e803a964b0da0457c556a6013e235567b0726c9da76bc49e11a703ceda340eb44e8325641679dcf62825bacf67a36aa0b8542b063b8bc128940fe6929ffa3a3ddccf7e008e01bd5b0ce277e0ce5cf8847cc10714ab7dc16628e9879a4f6f0e6505856e10bcb0f324834dde2b6f82ed9b63a4cea702f5006ca1068e1ff5812a8096dae92d738c40b7ca18e2a24734cf0422891d0008bac8a2dabddaa8b6ceb9ea49a2285aaea2b3ef814fcf3e7bba6e1be058dac3d5adccecd3495677b51c07d74f63b34f5746fb43001af3a43f8f76fce8e0e8447524c0956c7331ce39fe383629eda0598409d7fe24782205a1f3e7eef15b4b8986fcb761e6453eaae50bcca8ec2bca58ec4966746f3ba5f312f8d0a59ef391d45342dba844ea2f47b16ce2930cabfa41964d577aca6b5159d53bc5813d3412392c4ff0d68af29451bddd9f44d00aa645a0fe6dba071180320bc765ffb40cbb3c8e387ff7340629fd0856c4b5d035f230e4b41467079ccc3cfb20c9ad29bff9f1d7804895133bced376939a6f11ef9bca203ca935039a497c2b18e1d4b0ae0b9b86299f1dff63e78812efdf3c69e6e8c7953a83478a7299996d06d57ada2fc87010a4b1f5a007adfb08c332df571c4ab5cc2eeb978527ba6e2ed7cebbbed814e8ecaced6676aa4576b84ce15b5b8e6839f5e3bb74de292c9bac0f5e38a60953a1388d3cf3b851c3e5a0be919c3062ace2974324138c61c1f5bc34369332fce54be9e435b82daefc9f719fab37ddbb0c05b99bbf991bb524e594b5955c14637f7e7023339ce196b49762432898411aff628e0477175ac191ba32a941e2c234cefea35c8cc4941c9e5244ab0d9ab2a84cca49b51999b2c87d603ede97d8b4ffdb7fdf5ba6ffdcb471969bddb55900c088771143ddf522a61e043d1be41a9638d12abce291d861ba024af57e883381016e4041d02effa1a6732612483124ef1bd0a0409c8557d36aef28c07c016d6726e2c89bc110cc9a439d7787bed69f83112f4853cc942f9561c6bfc97f98cbac023688ed6b635c49fc9b67c87e1c648cec4c303144c711b64275ed41b7b54c48665f40c25b5fd92d306e71543d862ef3e4d374964d2df53d74a470b6270fb353904766911e972913036144f62b6458b5fffa1c332c1fba8c914140a0579df7c6a7a37571f032c27c39215e6ff68888f6f1cd11a43304e0187fe52ec0dc3d9c70d83e563564f96821271e04ac50f56c3223f573ebfba71e44dc69b1f379a4598e6c459865abfcfd2c827994b93dcf89fe347a60a468363c72bc6b6c0d1163c5f679277feb92f301c98b3950965add4772203811f6beb850e94a6627a462b8359040376575553d6dcc9a80a00d7d98a9f435037922142f931fe52990ff14de3b0d8128c5b3a1582208cb0fc63c385335bf5bc620bce23fe97db048a8643b5c63deeee39d68dbcb93bab117cbff1fb66430b1d4f1b353712e33b24e85283fd2a209b0b6cf98aba2d3acd61cc3fd63f0a05150da330c5590d00d1e0ce352a05a18759b1555b377432300ac5f30efc3281cb2dfc24de2474d4713b87b4c6bba2745ea297cbe49623a23ce33f4cdb4317b908b11cc9264196fbce253aac3defc0f779ae3cea56c0e3ed96d8390f8f26a1454be178bf396db50943e13a064dded7f671737c70b7a2320d751f5c7105be9a0f82742ad50e84ce15c22bbd157519d9bb7e5886f152a72456252524385cd8ac0424ea97c35b1cf39f74d8a9c80a78b34962e34964b7d306a77c8bb3fc785db4ae810d7162f261b95b69077bca375860060a3da6330ae54adb8d03b4ea2c5393cf4dda4446b1d5e7a343cea733cdcc36380874a796e2bb37e337d3fa61d3e7533563c285419440d051e5c9f6bb3eb0acbae1364cef2707fa1176370a4db47dcc74d57005f58b558d9d9063ca1fa346332979e0e01dee047f1744bdde5cc826e78c4916f8998a35905232aacfacd2936b07d37c6658be968c3f6ef90ca711bbcc8db23c980267f4453cedebaa7d953df7ed0083336b8bb0afcd7f231911f3a2cdebcad63323fe17dbfa772db96039049e5209a436fe4073fac000f0ddb483b482ce9c3cd4d899775fdf90dcd18172b124d0d2374fbc058fdd70bcd7701b9682651d5a8752fd34206651faaf834aeb92c6aaef04de32f33c2647a9151a56248d147ee80c1a9f6170c1ae42355eaf48c6c52199a7fd920faadb010f040246ff750c702763c039be1e738311c3ec905fb5630170f87ca111f386b2d0b337ba0e5d35d2487623b6375b05cbba1c1e0d570074d5b716bf9833f4caa52e9c114a1e07e6ad8e358c14a6f6d185f95ba0563c2c97263557c2d370490aa70c3213cb836af87df23d92d9157ed50fd53078058e4d2c7614a4dd84cce12174bd009e0e9a00b52f5790523fc1db42331d45b7eb1886d9b49bc6d7f0aec6e80e543e9f4afbd2fc42f32360d3f87580a84ed7145fbdfb4455d82d7ad710eaa158e22143396841cbd2b88f03c99a39591d3452cb4d84d7aedb81d928fa4994d29a35ac8d71b1481760186099db9235c21f9266babe45f830d7e0497677af9fed4658bffd8f80e79c36d8ad0fe1c067736aa9fe03f26a2406d1518d4ad9a91cafb03b7b7b904456bda28d842504fa293c2f49fc90069864541d2eda191bb4ebc8197d6eb27d8e13890fc1027a4516c0f12e10c6ab18487754e3cf469d883a9a15b3c9b43f83197051ddb4517fc2e40ae73adea1df7f44da62b02db277d3f89300489a135cb602f6caf4f9419f6dcf9efccf774a4251ea75b4fb09c8d1c93c9de501a8fdba43b33065e4ed0a6ea96ceba4e156a9b9467f9909f18fe72194d3ae7aedfcabe05a93a64bd79d4efc202e95251b09817707ff460d905a4941a2ffce165ca7f3e8a8a140493c8dcd4a8d9e8854c9a76d87bd418232aa0bba91538c516f1369b5d9d9d1aad60ec162077cf331dd2e427b910b515f4e97403e26f6e868b43f84ac415775117b6091d836cc05b2ac7a324ca5213cc63116a8625838d04b194dd2c0f74ff246f342d5b60feb1ba2f6b08577a1e76c89183d2d7a22545a55dacd4086573f403705f8a81ab4f5d8ce9be7ba9b27be01ab5cdfc90ff4f629929c10daf080595438bc999fdf4cd5a03cc54d008b35d834a96d2877f73a4726a71cc85294cd244837d859cd967a4bb20ac98acff5626ca54fdf03eec9beceb2efb56297c136b626a0d4b2ddbf3f43204d117ef7ad0fff5224bdf0df455e17732ab27fd2ce5c5677b83a1b1003a84110d4df61710d1a4e9a12fc17f787267080345187f921ff4b6f5396bcb66593304bfe8d1733f35ed3a0cbfb1b305e8170ab1ebc96204ccba69633da7b7e629f11c7c489aaad18b323c5ec9f6cd7956a254cb94f1f6fd082b4de69697ccb8398ef23d9058d4907ac8665c57a9c3b3469db64bb4e91bbe02cb16ad552b45a1887ae4320b7fc90c2746f1aa231ea1510381f9c4ce252ddc1ce7e6abe98a921d2e685a72e262cb71dcce08335e0b6b7b2c73c68191cd38e898ac8482bda7cb6ead97cd80a20615381da58c22f1f43ed50ebe2d4f6b5ec85f43a7e978b786f74f0efab2a740707c830cefc22e83f0a2a2a42b173367a3dc7e33f70f94bc72149010bcc6279b56c0e6d2917539db043da7cba54b9d02122849f4c413c281bfd28db2d8180d3cfa71cb3235b2f0d5d89deae3c1bcafe1fe89ac19774f9b0e290128159eac77efc66b0a0a0e028754e864fe68a509bad7a908e87cffc311f7e92504e78e0915cf3a72ecb3eb85be21083afbca108ec541b0f1a6d206f2e2fa984d20a66b1c76e9515e920db10d6ff2daadc084d63d75b9b41d8e3b0b61ad5fbf23967479fc8260bd443c7e2016c17a4dc546250e8d4417440b39220c798613ee1671baeb6d2c69044aba374e5a3c05f5713ea0e0380accd65e7d790625a10ab0836075cc472e80766df010640562c28091ea94301e8577a47f6074d93253d0829acb090f49187df5eb14a3a372963dc527042ee69acbc3b85ff5b0cc061d01f5765dbabf752be96d85a8a3936d39d1a5b99b440115c70e76ef88594a44ce89fcdad3903793f973b3f85a27e1637f601ec038f7adcf583e36fa0880a944dcd76453598ee9924897298b7593d4ba5b7d73af9c8a1ccb7d4e61f79ede2b4b98bffe87885f3099845cff47f7b98af1849ed28de336e770f4d0e6bc5ec512d6e1440ba5498fc2f80cde00170573452b4bc6b5171f1d71ae78a6f5656ee8a4f1d40ae55ccc686cf55a9c08fcf20f3755d32407baac8c7839ff8faa9051ba55ec85d59002569efe6092c2a35f6845d34f5611700c3f2a3526b4d74d8be558686d5f790a6c616ed955dac51522aca4a47b8507cb4065f2e802dad29c4240311b09487be5db55826bc0998f47764ce8d5807013ca31a116bc64de819b5b89751c1132d12c9029d0e31bccd70af31d6702c6abc03a15a020886c4cfbe927586e8ea2c3cfd31d890fc3ac15cef6136dc6b048a183e836d20f0d792178a8b5f8943ec0b311525c4a5b0bfdc0779c033d517b1687df8b642ab83775d7ce91129372b1a971ca5146f5c28f7747a9180fae00eed7af0cd999ffd28046b4ca4f56a4710c270f8634a994f43007f69c92ddc498d744474bf2f62c0d04c677c79e6a0d06fad29d6935aec0613872c095c875ab103ba31fa7fd568b61ea9ab587533829957e405516b70f0009f5cd0c22259308c801885e938a041924deb8b3454a200f4506f85177285a732ce7a75321fbaf4b8d05818f6bfc7d08aee986c03067c1c48adba09f23552843b528534ed3e7547fc6b443eef27a9920a696b21bf777c79f79e46fe0668200d0925fe421fcd5996a9b6b04f76fa3a9d4f7d9b80b472867a2057fc6854117a5c5965bcca8e2e96d6db8558d3bb4b7108c6d5c6f8c1295d6fbeb9c9c9eea40a6e927c6148cd8668d29e798832a4ce7265cca051bade4ea66cd348272dc9342001a2f43f3d4c81fd12ec6ff756afd606e727c5075f45a7ae5f0969501412953604fa6675c7c35bbf8749cfc1959a5aafa4681eeba8896687f9b92ae064af49c76946ce57b861e88ed10519c2d360a7aeddad7d1088ea82d703c83c930b4b93d256a36f1831f397c135c27da6b5d16722f46597a23375e5744f94f3956e730740477946d21ea015dd49af87ca0b25c0b257787b9bedbe78efbf5c23fbf7e8ff0f524da7ad41f4a7c3c9f98c1a296274fd1cb81017bccb337920ea3faf5251ed51e2802e5aa860d2321847c0072f96e748ae06e8847f4053bed89906f5b4c3e8384714b4445d89f4ad3d172caa8caf8f73a762476ec23b419ac378ca5a7458999db210db76a26e35bfefc6ecb48a4a7ab2d55b26b2f8a21954ddf8bb3c824399949c9f3db3332f00464f4f4da3ed005cbd1edaf0033db4e639749316689888db49f9","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
