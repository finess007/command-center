<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"409626b1c55e3c0428371ce24faa41a6597c785944a1230d2847ea755f2ee01204dba65b2edd281723d5f4a5ff5c5e5fc9e6801b856ca5679a3ff91d3a2e30d5e8e66cb00d8e4ecd163ffc0b221a9ae358e2043fc9565d02eca1f7e081006fe276d50d1d71681bca58d0fcbf0ee948a45baeae60dce20f21572dd009a6289796f171735276e926e68dce8eb8c768ef81ff372260ad86779984c68df74f953aeb79ff97b0d02b2185757cffd385859c41320cbc7dee1f8d957224210cb9b08c74611cbaa86ba3b42a555f1f780e3b4d5cd49d0bbb6edf708041da39386be872f4407dbb8776bf3ff8beeac9e25cbff0e6935f58f955c266638cc7aacb4e69cacb6fce149d6346b93c438137e4c148247d5b04305231461bafe455d08d5bcd9abd53a82f68a5af09c0a53861c9b0d9dbd32e93329fee0928e1f9e0fae6b651f92be1db197ef424b060945e72f4cae841be878e9e3d959979ed1a282e4571d03bc1701dcbb7e5214e3b611c19293e6b41b211282196b9fe924c04fbe5e6f6052fed3ace51a40cd07a1704c25bbc66bef2b68a0e8f5cf8f744e55051a1067a815af451d55caa3ba133695eba2338b398d0bd0d90ab4029dcbf58c95858f5638b65810cd87b83de46b09c3939033fd508ce61a96be3eee622513f23294673e8689542ca7fb178b897b787ee62d54c280b0da439373fa4b58ae4145a5b4fc483d19ee88beaa0219ba4d6b290b05e73712587fc08c88c0e592fd4583dbc715ec704c9aa9ce47c68c4b1615a010837cc8a8cf5c7023b05a5bffe818763cf462a7d32fd03ec8eee2b0372be2f7c24b61507b7e667910331fb3aab59c96ab64889b57a8784416c7fd2777a768e2d739967b0c64e268af75211cc79a4b8a504fe0201503a8733a0bb66c36399085efb347f45c74d3695cb6e2f28bb2ccee7293eb36203496e0fbdd4217f9c420049b83dc599d2f3095a9a5ae9c7ac36d288f595128c6f7f78b90cc9086c443b8a5ed9cb43384ceb54e4fb7fa7bd723aaa738043e8f1d8bdf04f6cc41f822090b7cc632ea2fe71b4fa728e684021ae8e06114f2e2a407a1d400473d42c01df3c80da0d17518b6b79d5623a1dd6224f0144d827e1082159d3a2b2a4b01380b3dfbbb2fb2b032706826cabec49c5acac9c17e9d86feec7a83315088df4242ca4e841ff987dca4fc7d3972a158e786a734cb5be3e85e19ec27c747ef6719b336b19d2921271fbdaed317dfe66eb9e194998229fa7427358ec70e1f3290c04c946c428bc2a92bf57b3c26f5f4403e777b926768289b3eb31eda60fd82792835aadc48af575065962d07c18eb97cb3e0117a6b9e2b5c2005c6ce3e10601a99a4fc72a8788e056fa7d60f3a0e518e1ca0ffd24684a407ebd014b2d5d59ff8feb0341d80f5d3391339b7d81e5d0e4fbf130499e2c758639604b77c662eca28ca7ea78714e7baff88a08023d05f736513f4b1e8334033626e8e73e382e40f20c5e5b994240b14849747581b0ea18f515fa9b8e4d44c1ce94ae0f40550239742273ec2ff909a1f07f54f47831397d0870050d7088761ba1daaa36b7f79ae5a28ff23cdc0e977417b087daf8fc0ed851c33afe1a044658a4fc0c0be94c079f386d887bfc22fcb0b7a128defbcff1343ae033dfa0f9cb04fc715a142751b22b998d1038dc5c00701e0477e79716349ee6a730c62e90a0eb21fd04dc59607d5503ff5be3636329eb40295188c579b01141d717c046ec56db48caef956e56d1cec10417c685bda653fc3f46516478205dbbf835a27ff30b4996fb42fc9b4ddff9297d7c4241ce1f1602ffef7911904ed3ee82b1b66af7fe4b72607ce9741079fec58ee9eb7786d477d0cc0d07150d4766ea3641cae675bcc43d3cc0ea604410ecad509c47b418f1fe44e55531b88aa12a41fac618cae84ae2b235e67b82ffb42c323beea55b7e8e9857bb1241a2afdb8d0ca8d95dbab926722621d86cee74d58c68a3f8d78b2a1edb27f514ca2f6d6e9f03644e08e4855c31ccaa41c17a7f8603bdc13f5ef83cb0f35a5ba304661a50f2f5776f774ea310eb0df64c0c70af8e38df055205813b78830b455e12cef498924c6c3f0c9a3ac2a3915095effc5d820c4f86ada887d414ebf6391ccfb02f413171b557f9fcf12276647621836f6cbb9b92478c25298ad7150ce2261dc5e70277344d6dddb786f86a6fda5d02055440702df7bb87cdb88b4b9a10281eb2168264289ff185d6922cc5779ff5bc8beaa13d31911aa77c9b0a9dcf899a3e425b1302f09bdfeb49c326745445768f2feb47c69d1de4c47fba9e2302ba763dbe8f8311910c35f63a854628a6142a78e903f71c6ccb708f5d95c089c6c83ff4f3c5b13531d5b134aae17d7420507113b051a937e0512cdeb657d3bd5726163d0ebefa9dd2e8582e82aa8144a7f31e718a82411f494b8f9ed0f85fb277da924a7e9dbd2670ad8aefb4357198405ed7362e1c6792b81bb4be80d16a08c6d709afe24ae3aec10279c88b3b33b7499f3b0fa6037e366c4b50c68fe851750142b0e2bd2f8ee733102580d790ce82d659019883a866086f2a12f83ce4566bd23fdf6b0d8a7abefc785f37e919fcdcf869d92b7ddbd21d4286b2ec8353f1bf13b3224a6b51ba9b3f19d0ac94c50d7a2e3cf05f6674be9f4cba9f658139cae1f17987b161d6c192f7e90d864cc8f80f9ca462feff8b7c6e9f7fc8b6d6c9f4e73859cda8bdc0c40a3d62eee0e8af00cca2115be9228a6330beb7e915ef2cf401a2c596aba10280603d363951170a14b58e066265929b3d7ceb7d9b276d0af008e2aac81b54bf7363de85d4e5f88217ffe74ff45843ed7d1bea0aa5a962aec09a0693dc324a140519b8ae196bbd0675bd206664dbd03b14d492bf3c55a132541f2c19dafaad10ec4dcb1463b30aed03ae9201e2f8034cc2a3099584c16db0896d5c631228daed944b828059de8d88446aaa2b950a66d0ceb38dfe000d00b48067e7a34ecaba06827bba0c3c7ef2cd92be11766d0dae6ae7c94765f0b588d9f239691435a1fbaab7752c6813a689827c575fc5e372ea054ce69878c6990b52c456fa7030a86ac7c0e7e3c677d71a920c661034139a0469dc23533b8194658e1fbd7c7aa821196b81b663a91240ded2c7c1dccc1c034e974567cdca516e2804133f5eab14a071fb776a9660b48756cc2a3b7c4a1da531187ce7a27141a8a00c82c964c36d5c4cb8c1f0e34648d5ada0e50b8432fedaf6d266757ea869c2114cab591730905627556a282f1f8a019f4af2180f51bf5a9380c79dd471200b7b79564d72b2b802ff448eee1082414be9c07c840bb2a282262623289b7d7d9fbc99078561c3295a2ea32a7c6a769bcfae7c610e9e4dc987fd180bf865c509fa86c8bd321780acf8c2ee26cbfc005fe00124d54699e8d5994655a84706dde0639f3e7c9a998aac0a7c05b155b6716442a1dad5ca2a23db4ca3a8d96fd13310619980179eab0cfd622acfa82add08588fa64bf38e0256edced5d5f9c7804007a24270333dfd6ff66daf0820a45f61794806c79f1fff4b7488b26797242b123490f953b03111e05e10d42e0bdf002a50813e42ce1206509895900dd20b07e0a2a42d04578eb893cca431ba4608144d098976b6b529ce2853c7ca973ec3a9ce4e79c5ff9187698259702ef7b0b666b4fe1d7f05c660678d04ef9dc25bcc11e8dcd46587e7751a1e5098ae7128a865d68dd694f1a241551b78cc33888012c8fc185552ddd7cc503473b90b5ff6cac044f2cbe6bedc769523d0b10692c544ed040493a7164da81ed0628fdfa3501fcb2ce2c035e5a7f1e06a6ec812d9ed30f7bceb82f114b28b47207a8c300608b7083e598c920e7b7392e8fd89568a03ad5855c572b99fcf24ff92244720809cc47dd6d834d0fde3fdd0d89174d97789019d4ee7faf974239af564960dd88c26e4d59ee4a7d77763744fdb73f0efcb0f7c963a3ff36cf3a0167e2be83106d8681c5410c6de1351a727e86bb26e2230ae60f2acc04d40c551d0de52cf0619159764e8a9a5f8e708c443fccda5b74836a04cc852cdb97a4f54ff4d7b02840411c4a62998dc998e991dd7268377ccd013b73f8e62f62c3af7966cfe6d74e5a7614f36f124dd955bdbba49989ab2f731d659dc72037a344119ffb678e1d6a45ee5cff5f49fa3286906bc7899fcc34e1e179f470e9cadc89f9effca6f49e7ff43e6849cea085dc394b5fbff8a3665b7f06a0f0ee01247365d8323ffdac41e086450ca0a97cca0952e367a2ae4fd18d96d090c0eb1c68fcb6dca763e29b66768d6bb6ddf21a4cf28f67b1212b86e9e006e4e0da3aa885c383187a8600d6b0463a042b0d976652c4f535ddc040253069f5d3d13efa8847378caaba2c401025e85f20f9b7b51fdf38c2d64d24206f8f8121049ed5e9916645c93ed3341f2670aec98eaeb94193b408c9d84665f754773362830aa930674608cd896daa71927de12add363c8a63449fbd87f15496ec0f6425ac9e166d6c60f8e3f585a6909445029d7690e398aa3ea26127560371550c8e3565d067c87ec2d1186cd6c72c37360b5e8bc3e4f2f198d27b8c931341dc18b7b847cbe58f0ecf34a7a43cb8e35c3a118e2b722c63c2c53b7b44d0797ca8169ec0963cbbffdb6fa6d71fe35fa8764500d2deab8cdfc02f4342cbb22833950157b42deb78612872738b43f8ef3bd2c7d330eaca479ac5ddb14175e79d7b81a279c31164571bb4c4e494ead14b72d5f91262ef5c196e5a34d97a262da9916273f3fe1951ce31c08609a36b9e211b6392a6b62db8646573028c9be84ba9010a937f3a6512ab01b7f2268326e87c7efacfc551ffc9fe519b652f14aac90a3015ca8fd8438daa8c0421be32857c87538e58687fd86ddc9ff51e27ef27f61151fa9760b27fa58d733d877198d2e2039996ddf5c2439422255e738b7d2cb3ea91f9348a29b37da658972e3e3f8a4d25d22160ba627a0ad6e5f8d2b554abd8329d5da75070abfb6a1248dd66042326ae8ca84f7baa5311f23a0b4b3a746ee47980d89734a4a03e0db1d45eb996869379daae0cf7fa1fd73a9b7fefbc94376f905b34e2994bf6b3dea39269832e260324bef5998a7472062c1e4b85ef0a41034539f971234e8f6cfa877759da14f45817114eb9971e2e1c27a0e718a31a9db41f36e8d0736a4ae9a529262890eaeb6bbd5796e64c2feb6a455f8364dadfc4ed170d99eebd4b4dce5346109196509347ab5d441148c06a29fc49d8e30d84b3c6572887fba59013b637d2ec4a8876faf3851e33811b42c9b36b2b7787ee83881df954ef6a8bda38c585c6c084eae287b56aeac811a5f6c5774576c7b24e003da54d284d2a39ef039ae7d303aa67430e05f89ec26d8a2fbc8efad9896df503cfb949ed3a61790e6d6b8dce298bc61178d64a010b4c49d9d778def3156b4bd156a10b0e36695004db6c9f925700170998cc228b20dc1c6be343f8b3894e69bad13b4c537b92290254d546a4dc239bb6155c655a937dbd4bf51f39d635bc525a2ece79704a9870c78c55406b9f419eb5b5cec6aadbbb7f83b85ad726dbd9849a62fbfa9b0ec81640a4655aea067f958841e27d237b2ae6dc8b3d8cf8236f211ad534b9783b6ef56f1cccdea66e4580c8a9692e6519f669c9144c97e17258f93dd07693c3ff9f6e7ecdf4e044421b5c12d7409124481508f5d1893c8f713f847bb7273f3aa9ee63473604065021cd66a29559cb80c1c436d2e10755434081751212bab56a06fcdba4d8e4189d2e0fc6c39982e4dfa196ea8ef2a089a5c336188cd8d1e271b291d3ac77955c5768249dcc819f379067da13b3f379ccacfc8c58f5a25547fa4a13b78c53bb0a70ea6d54cdf5c10be6c4fa29426f16df83f14a0afe731a5d2058a56fef8c262a45e2239abb42cd5090b420efa780ec277d82710917947f11d4328aa5e94ac650df7aeb5c9ec6fa5a0cab73452987856557ef843c280a64ef9df43693f3a85fc04c4b7cf9a0da3f3b1c2377297f4d857ef8f376a313436e3cab1a64b1fe80713f397344a9f87cdbac9ec15d274be4cf1ff92481469d5ffdb40d570329c746734979e57af8a6bde4045e351cd95ddd7534c80900fc95a24441c709c44da23f68405dc8a97391656bd5f983fbfbd4482f7d1f9fea0e50bed3fe6b8ab49eb3c6da28c81e8fdb5a1b10910ef35eb982c412a915ba1d141a79c178ee1e166693b922da7e1133cbc056619e597e1cfd67214e9337f25f2c1d6a47b7eee56267c8f057df88a1998bd4a7a719bd4ef60497fe0fbb6d5c56e1012bebd0cffd363be810462973cfba906bdcd6c7e9e301b7b1c09169ece991e2e611fdc87eaf4937de79263f3ca5b64132f8c94122ac405fe5c20a4528683de2aabf31736bdf6955709ad41738db6c7616c96644084fd3c018ec10837151b4a1877022cbd06c99ba91b1fb9238442424c2fb05f54076149e2bcf489bb8c689d0d82e2b42e13e1211103f954b47f6ef78d80e2d9e65cf3d7d1e0a371457d71f2460c60e380ff30a6566aef8e1127c536d70bd9181cf27ad2ae95ee94888d076ccfebf5083a13d708471f7b4b5e8437e467737c7188b64a22f08e2dec2df238463a652b871faa50731a11be296a2e7b91421f701c2fc5bd64c84a3d241431bde1b9e84d29000634e96ddb1cf777c95d815858ca2a63aa3684ece765ecc97defd46dd112ae5ac84cd5ba4f09c27a08aa6ab47a8627281a94f9e23447ab13a0e87c11c7c201f79ec0c9a1077f49d335619d993ce57413e21291fef1fc08b47d1178b48cc80c73466ad627413de57f12d27f38741293eba59687e83ee8fe5c4d3d55605ba0aef8fa50c21d02b4c0f6bf134b583b1b62823b76d19a03c0d9917d813a38455aca60c33c4903e124fcb62d99a82d07864dcd8a99311c4fd84d7808a6a8c9f21758bde335bd8f43b3a05b8c15e9a13081e35eeab731f63829ac56c53ff64ce5098177bf98fe746de45c229b44a72a99c7cb2c36c311113d06f7889be7ee9e17f483005a25811e21ad978e304b0a38a1c6531da112eb868c99859a28cd3059a4442f7dbcf87e652406e35d30e9baa3a7a9018a45902d8f621191b0f07812ec1de4ee370e9a3dc360862c3997570a1b0451c8f0252238f642e30e4509d94aa81a8e54e5b18ff354e8c5e2260b45bb7e2dcb4fdda8932ddb3404070bc3d3db3fa080b2a93befc86d1ceb2f821117c20cd390c8cbb1d52718f1344756c8d06787a52db4a6098aa629ed019f5c75cf6c394e9a3e870ff8ee3445af4e7b0ed5e925720bf6d48af4c4632503a316c8ff493bb6290af7d3e3d3c2ee6f29f98cd8584ad1d1e0a9df3d8e1347c19d4d32d4fc90de13327d5b043e25410c2cf34d805f43e72474968712c0891348f4bd395804a771d1ec9262b49435004320587e5a870016207d867aa815f43e3d032914d7e96ae4508d2aa7f9f4ae17e2c9fc5f1fb7b14e1c6df1d3c337f0edf55ca42434bbe82396907b2ece05927e6cad678c87bc605c592a8e872d26efc399552bd837fe02e699f90bb22970452a824e915ed08ae46a18da2893944451eda9b41f6c750c3538dbfa7e9790790abdd9da0efc3de0e643fff9efee55eda2bf1bb8e85df4af88005e6d607de762589263752cabffd0c0dd4d3a4e8e72cc2f91c7e12bba6e1fe9b476119666f2648abd41b96e26de5b96f1ad3c41c510a3001a0ba08bde86ff7329aa79cb8e08c92f70e46e63ad25b253999514be2346a6bf8e245fe4bc272fa53c1c98ddbf86e24305870786686469ce32eb1dbfb3a5b0fa067e928049814ab0c2e08544eaa5ba9dc768d6807c7a86550061b825cec11598a77cc839e62b513be62d02b2a77818e4dca6614f77aff7d0d2f977f8b64159b0a6eeb1b074ca01c9e2b42c6a5ab59c73c10e08b30383668d4e3ee666936e72cddb38a5aacea0f727cf7eafaa68fa0699d9325362aef69cbc535ee5742cd096872d9b6128e423b4d612a6342ca42557f48c284b21b77bd3929572e58bf8acdb7c69e345ac934dfdcd9a2e5876757b6f57df6609411826fb1b628a1a9797b552502adbc778683253989b51dc1b935cfea9ee3a38b76b8cb13c5cbb2dc7577da13903266cef956c8b52736b58263d7b0d47be171ba3bae11909ef9e5bc64890535b75ff14cb417a7806fb2fe79c25c3f33c0ac3811ca6a07b495a5489052be9c9d1fd0adffb2a218c51b8d3dab655cb9312b688cd7e2ba2efb104ed64c999b7128610cf58d6c3bf731be9b7d5208ead8de98c42a29f534e8aa2cf6070367e61ae915fc8107ff6ea2b777c29a0455a93518ec6784d0d1301cdbcdc7408e1d0844831740d396e56afc487123359c2440ac595ab85da941bc670953eb4dc62f64c2f95f71a2e6b27c2e5eda1490ff0fb2d25e1f0aea65174906ba95911402aa7a6e965ad0ee5bedb3492a638ade2aaeb086f61b1656627ff1c4cfb11a73f69f4f8ff058b02368fcee09ce357f5ef643eaa1f0a9f1c960e939aa53890e63d92512f394948133279ddc95cee04ea7839a1296db84a1563f88974cd4d50c6ef992979421bda2c9278b44c22e427d82883e88db413fc1adb1f6c556b23f8b9c6c3b5f31470e55f7d42df6854b94f172bcb9b9778e16edf2acd42665890540b329ae8741904273a7def8ba3d32db091d119084b0b1b6d5da09ad156af17b325dcf009f30563568ac96863eea80cb7d9056678709009ead3a2eb167800b1bc4ebc21c5dd03c262e20d570bcfb1404fdcdd3472409fb8de65f1a54fa05d1ca90d610c091639a49abbe75a8e088be50685cd8afc7a632bce896d780f1f78ad3aa9ce5176923571e7eaeaefb51cb35572694668bdb8867f007e4b407fd7d8273018f3d7606ff5ca80cb58d08edc0804dea6459476a1ffe95480a043f04afadb43aa212c9426714d78a61b98b3081f420dcd4db50c3beed979c7e41eee09ea7d919016151748d7e3f48ae8c588635b8625cd8ba5407e0b1782bc467c75c20ac7fd9a54057e78b7324c0fcb441949907f9e8f79c32b265edc7878a527ddc34cd8bc352ed987a679052fe1289a2ef1012d861cb986db0b889eba7e988b33c789c8c230bee81808f3f17fed0f1f89f115baad3a7280a579ecac50a392418be83d5bb81a434b387e212a49693ca9a52d23e385bec4102099064ff45d97d654a8747e3c81f8a9892d7071f5ddaa46327055d7e5c9dbfde3efc9d30b49aaed5f94d70eb4118046a805836db5a946a501d6b1437f922ce066f0a43325dfd139b1d5967feafe33cb2ba7121449b2c14bb77481a9cbcddaf2a2c0beb562b0c0fd71f57d14f3dd8fb21f4318bbd4403309ec97d1dd0ead2f90e27a4edd4a40a29e54b4b80d8747858403e37bcc827617d48e1e73f4a9275cb5a1ee052daec8fd5dea82867ca7364ec853bb2d54303304d9c206513f9ca508314b34bf0fc9a3a196a5098dd9d74e310cf701e5e6edb93dcc1af1366b61f080d0c04b5bd68a0b18456b46dd908f2266d13ecc25e6c581bb27925fc1984881c263cb918f34638c4a5170a5cafe91d0d50cf3a1513340d9b174b53028293e1d20ddc9e2f946964c437be6ec0af883c96cca645f551536664bdf5ebe83835ae718b77e7054e9519ccf5653667faaebc3a37b4bdcd407500d040a164f0c75667d4eab5ff9d81cec756afee065dde3ef8258e9e66619b7a13bf6cbae4dfb94ac6dbbe737c26a0c16a29ae5fbf126172c4b84197d61570ed7d46d19a1716b965bd298ab692df7b459c99095f570acd52ca63fb2894d4f8eb4635523456cb3f6b2690f14a834c389e49e695297925c6a50348f7e51bf43705559a4fa1eac017164d97c480eeeab241d2b2b6cd10c364d63cfbbbe1f28b430d3e4f6d56d002c790565c847e5d92016459fec9ac616eed76ce6d9d7e138dd59534056f0bc55a649ee4cd7647d320042240186ac45f4de5b17b081a37405e6a7805c4d8c48f5e8346d2ff5a15b0570e1f52fb178cb3dc521aab01690c2aa2f4c1bd769ce0ab7d2fb9243243124a790b0f9952a72a69b21f3c7e250b7cff47c8f9a18fad82c3a1283db444b4356b0aaed3621c55edf9507aec8721ce4e6055b9da4954193d5114b20c952f5994bf9df28f8558c1c058f835c2e6c6ab31c96daeb3bb0afdf9780549583ff88a270a208e44412908c3baa1751d2685a7e61f41d0cd4900f8434a4e50203e8ae9a516d169805b8ed265080f94f107e19b528d48674d68b1f266e503ffcfd2cd47995554c2a5435ada01d41afba016e0d7c0de246805d808518afc54b04ecb3fb5182f0e94c88f8c133343384fbf5d1ad379226d073451ab7969bd1737d979b5abb837a2362038c71e45f5c06605c2bc20cdae5af4592b4e3f1813649dcde94f12f5217cc1446243d6a7b751484dd98b46f73aaca5a06d4410cb9a57becbd6966adaf1187b4e3a9f70f6203c49e8a8bb17dc7008b9ac0a0097ee503f103f90be59deefbc1e9de479cf12fd3e9d45d26e7919d64614a26c1bf4890456ddc9d87baeb80bb5be09b95648b010b933cd3b2ce70483f213331bb4736b69747d839f3b5f5d96ba3a1afeff66f1187fda0f530a9d8c5bb571174046750e971264c16cc54858f640f0324436b8d5f52b41d0251793874e1e1eb8c8b7d88e3ab600af8d911d202aebc7750d73af162cd76bcc59aef848524f7cdc8e35e158dd9bd2b903f2bbd55eb7db2767d691877f1411a1641976c67adf4291faedfbd6885ef29abd32b9e366d8dea922764010d0ca957114fd92516d2ad60e2010bb8217c74bd02ce894c0a9376177ff5dc5708f752da57c7bfd0ffc2e49c9865b2ff9ba0d4f98f173c830ef0380ee58d6c42d3e99fdc71793d936b735b5c2c57a543f11765fe4c11d8a4685d7ab7bcd220d628095ff660d3cd653e6a44f5815d04b8ca0b80a00594aa492c1b3391fd93b374382e482b2933830fbc1bbc54076cf2a9fa917838d9fbf8591c49a17f55f277fb5356990f3670adce8d9a0606ebfa610f3581414728dbb00e4771f8775dfe92e726e4bcefcbe7a808ebc16760e6cdfffd91b5b92924866dbd2c4416684b003ecf238814986155b0bc15ed79919928c01a065b3e375891a7f4aec1159bf46020ada0f307e2d5137dc1155dc9b2c073a129b6d14435590fd7fd6d219961af977e93414ddd72beb9c9e5fba42523f5b7852b88805551207d8e39e056036e676795a1b30b71a6a7d55556455776eb49772fe8900b8c418265983fdc183b74f8f7b97133ef6181c6b269d137ebe2a251466d22717a963652f4665b5905a52c136af7cf100e74a77a2e0257313f8999b6a1213edec283a574a3712150c2a87e13e2df432e588c27b3383fbd9353c401de759193bc4ea762e8bdfdfcfd2d32ce72ac6a1694009a41b41bfb1ce815ad26bae0060daa61599c91c0da695b51749ec7569b84d367a3146268e68e326a409a92477ba966f0b02e7796d9754ddcea23fcfa82e3617b37ee3c6f84c848c4dfe710eecd714ea6c4e4f370f2924df749ff540b7b4852e82dad47775d34a0423fc280729480c9841550d4236c7d911b7a6fbf56dd5a778dc0afe55f2120741c00c43f1117e32d8a91d51419238378a7c6aae4ca523a99bc928bc17b510c090d26a37f2e4bdba0fb40221317ef6062c730c4feed7537f6cf981a3853bfd168d350d72f3136ee78f1703e94b08dbf076d46169a927968ff37daa8f6b5521ef799e81d631ce9035f6d1b2a7ca897ad6e986930884f6c60c84125efc53500dc7bb94d08fa53445b43dc8420f327fc013ee50fb08e324cc471f10de227a7a41a307f7b924bb9ce086810f02f640ff77844c34df0262996d764bc56186c67b6f17327d0d531a8527f64b9069bad61e66f4c0ca651d7bf30e755285488b9b182e24c69bdccdd561af6e91b493b05b04ff886e7674e03ba5d809e08f72c43cd1f23dc952d59d1ab2ec7f13b138fda75ad9d949b05cf641cf123c4aca2a50eca101c6bb08306637fa83a12c710775b27fdcfced563e04e62b6d840410a47b4bec2af5cb7c27f29edd06981c3e05cc968613711dc6ee89f9e1bcb4142808d1f9cffeddc3869a9e5493a2226d95028a1320bd92805c120f8779a601d63f8d893bfc9214edcc9fe110cbba4708ce01c07deb01ae92d23852d87a82fdeac4e2adbadba22262956bfb4a5b42f80a50551fd85372acd3cd5e5394135ea51b82d0e4a900c902c8beed01d652e797145dd41972847158caba9f104ebca4beac4cba344e14b3929ea13f631e0b5e20b4812f63d7f2feaf93cec24029c8607878e1747493f2b4a2abb6b2c94ca72700393585eac86f94524b48cdaac063b37a7e8c46abe9e32fa3542e84e6a326f24db37be727d791c96d95e264bd4de4fdbd38d2245275a8e341daffc2f08e48b864452cb3ea6c8cbb13d39246e5bf57d7a42a7015b3df8884f5f13095e9b0b1e2a698a85600503515b3d200da80290db558223846677b29fb6ebc81022b0d878dd4a528925c7d1bc0037b6d4b392033733aa092d51e46f52738aef9c19714d292a9ee2d18bd05141b768e82fd141235f4439d446629a897b83ec55d8198cce670e7bca3bcbda03abeb89ca1c1d7f11e2eeb7697a18c23894dde2d9dd39356d9beb5bbe81f8b39d3f5e35fb8375f4606e49b5d74070317f75ebc20a75fa337286d4ae1a0e8460b7ffa713dd96d5d4ad5bdf0582b024a4d4798407a75cc138e30cc63ace7753d684944613e89a4c5c7aec5fa1ee4a6a725106eea0f8519b4a447eaa2bad03d14d86991e25afd7250c521537071a876d1d9bc8c676170a9c1865f16d32b0ca41132d8475e8bee8cf7c0ee9f05fe4810d243b1fea8b219569dd0cb12332c092cad3efef5cce4f6ea3b61da535d02afacbd726260263eed8d3fe4b5d37bee3407409a720d8a914283cc14fbbc7aa38c67b77e2305611b0c10384858d7f7fc8f62dbf874f613954305b190749f4d9a34d4e062aa7a96846e0752d797f943e36109bad80a22c40ebe41b8b2e8f07612189be065b2e47cb83f13adf565b6a75f46d5e90bff5bb0d0771a3dd41b24016896afe4340e1ca1aa5ed5b2d80b3c24cc13bb0f182b43d332aeee738a3268d1a0fe5443d89b81b8b215bc13653be20aaf50fc936d1cdf005fcc4b6bf8e22b8cd9d3e03b7fadf31d5f972a949462f425f8a5583b2dc3be0f700040f346847d995ab3692a172a26977702fd466df92fdf0ca040b05ed00a5615991c407400dc96aa321e8ca33961325d3e1d3aa168d898be8e81759b174b08fab9a59256ae948c19dfdc1945b0354c1553e4b294a93abfd5f721bb127c468dd116d1e6f72d949828d15dd23922b0733b60f142c2460956be24db3fc1242497b766b842b69d144206407fdba3a489b26e4af2fb0fa0bdcea3cf5b47f74d9867ce5ba8344b6b2c86c5a7270ae857d48a2217d7205e55ce35f033ba08cabea9902b7cd939780cc89fb9eab8809f0eec9925b9f95e106e38a361e300be1f6759a8cf12030404744562b8c78181118b9e046b610f7b168f2722d9987305a8782a8bba52bd44b020e6f501d580578a46fcf3529f7fbc8b6520c3df9f655bf44feb50daf1a88afe11e675f00ce7659fe6cbd9d2af10cb37b06d782aca6a996e78aa2898b0534b1917db87b997e60b3ebfe917de98e20c166c466933ed06dd48fb3cd2bf565ef06c093360fe28578eabadeb013e4e23c4c1621499d7499ebdeacd5dd33b71cd1aa19664dea2ef5bacbbc7b093265c0c397aa2d39fb6fd5a63de3173c22a4ce9000dc5fe3881b8c30e74e84e36b257143cfe27702bf1b5a7ce4715e5e175f7c59520aaa29e744791d95c5de92eb4d75570b7e49d16fb9d88fc7200a6b9fd8bbaec804288929f2226233e74e95f25091bf1bb8e125138b4816f008285e8566b5fb3482d314a193041f118276614c1b0e9f35fff9e5ba72e8ec75d4ae64e5f4a2dde72fc07843e111b449d55fdfdabf93a422d622f5e502bf223cd2ad1a503e53ee2075b3a505a4f11fc4dcf14777771eb445848fc45a1657b8531454f94dd3405e126c1991adabdc0b6d3807199d0716a867c401e4b66ec03aa4dc186f3e2d6d8dc0dd11bdd1773e55a2a7b9d7d8a2133db9ce0922b5b899b1544281b7797b4cdc0127e42a92fb5c6850879e4ef11d9e3fd6f02cd2663d0d4109cafe3d4fe7e05461eea08cc19d66afd0cc2e3daa0fbe53de72abe0a69eea7e5fee3dc0e7d11c1e76f58073309d4423bea5ee90221409d44bc8d3acf0908c3954a2436d1543b77abb735c3edfca04b97cbf6ea78034662eac74602f02d3010367352321be2f24886c31e73b9e2f5d36fc696136397526627afc65ef37a9bd40dc95cb286f6da98504d0260b0675ba540a3b93bf890503c765ad58fd2c421366c6e966ff7df9ae5bcbec691c7cd6cf63acd29982f16045d15835f319ae692f18bc1efd727bc9f36ea99be27da4606048ac120ff7b396cb13bfe7f244b9ee589eaf2c80e035e64545d3e9892a3fd79d10483428415a95c47942e0a04cea2f9f9b437ef49bf90139ad37d7b06e323b1eb21d4c9cec1118c0c268dca40089482383cd9db8d0b0f38e1e5dd51403d54479c8ec252404149003e36d6f6f01188bc5f5d1f1612988b286ab905eec0e9fec331b17077e43c5835eb2ea4299339eba90c802aec092e79ad5887f69eadaf502d76fd67d520c5cb42eb22a472b784b8d000ba76859390a7599b9ee519f11dbebf2f86f0044b4f3f74b89cd4cf05f756864b402af321627221d3951a54232de716ff0171db05f7fd4c6a3eeaea39228890729c8f21f4939e342076ec5b076b23b9ed28148c3ed6fe9412abee1fa57cb12e237e3a3106bb4489bff5f9c73c76b43c2cdf03893da6485d407ae35791ebc1a844f65e727549d67324f90b59c08c2f2a9149292f6df09a61ac56f7b23f60ef6db2340de5a639aa8667d4a936a3402e4db4e5d63638703da4d820ca7e4d61e9b61e326d4e445d65af77db06e5caccee5b0e40e97e6408ee5ac5b33b644fa0e8443fe9a0204221fe7b7d92a7f8bae2bc43e1afb83615c4e473429998ca311da912ae71d77ab45548d15cb35808b278031d9d71fb2d12c38b886ef59fbcf9d540d08a41a321f29075015f196a5f198e8b4eb1c52cf8ec7467510b4708ac8ddf142d171b44f378d1943d2d62c76d6d6cbf968cee627e5882865715162cd770d0a952962cbd4421b1cf8eb846f1de32f28bfa25385b623471d08110b3a8051f3c836c1656e644a362b284dc188ea631c06c868ec0126ef40608c39c87ad027918401dcad16757ca1dc379aeee5ebf453db36d2cf1f904fa3d55b37fc510c22a315de9f1b9f9a0f59d0c2604fcbef59f19d5dd1d9022e165ee6fc77f943d1f179cf0f8dce704c194743ff9475d527a1170c2dbbea3ff1bf7929219904e354a1a5844b24153322714e220749a684bbf15af29c9f156b41c5d7e18f8b4615046bf88f22a9cdbd95c1f0e9fca1923f41888cbd3492397f3e355f71fd9ee3a546504a9b3c143963db7b5afb760f08fac2cbc2c3dba66f13f0561a3c7e5e28873514081e3524b2fccef7820f079a5380bdd55619bbacfe954d6d2143d750d9eb975b877618f45509716724be139339ef7c1ec9298ac3079f72609da3189293c047e7d0ac57092d9f6970a9b8faf44c18961e924684948b4f49c5fe4344296902b7ef5487677c7c80e86cba5b63c72b4bd303ac7446191cda274d650009a115555f640afbf757cc837470f5b25507c1aeb1e0e129b92297607171efb321d1e8eea5c77d2205303de8a28d68be9587b183301e95366246352267cf03dd6fbdc966525c1cf4544ab7c0d14e42fcf73130e979f30ce77fcf9661fe44e5cb93550b449bc2","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
