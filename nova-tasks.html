<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"05f226ecfd77754028898614c9124fc36caceea8317888f493f6a87f530a11f6ed68da097a10f382fc67ab5d85e7546298ce7548d2860bcecbdec1dfb484b5f15811e1170dd8a52e918e0ff2ccb3637b614ba85e7e5baef85cab516e06106a86eac05151236775a9e0415d8be52f46085244947659a1c6a97f4cb8d8ccb2c5d44008d4ce9309e29003a7c6be70f936834fae4d44c3e68b968f894033f63c33ec4c4bbc3efd274d5a8c13311dc430e6311c80e62b368525e4fc7ff1da62138c22c792f9d691c0f5cb61c602b00228a96d4a697e82b3b65526458cd1b0b59f3e1185a7396eefc509c1563a1765f7ba075d4e7991d49699645dd437e439c5acb023024125730dee6dd7f8190282cc9fe9db58b1e2ac36b20b25c1d451cea0dc1c7297847e89859c438dc779e5f239add67fd1aa16077739f85ee6ba56bdb350ca545ad7334193b8b67cfe3dc2d58b42efa616d2e188d5aa911f9827c7353280c7444f69da91a4a688dd4f411d776230b6c0fbc1922664c55a47f051c3c4ca43b1ea72d25d52881af9d6cefc84aa9a381f459006e669a691394c27fe21d9a3c4203bc79306b9d74f1618d78c0883376cc7d5b7a7b69f2e4c7bac08eb871b5b480799f174ad6bd20f4c89b3d57563f94e7a8e53960674a32db2e692cc706381dc8c8e166cd9a62f65464120a3c166dd4022c7f7945b9ae92ec55c9f3a831744ef5a717b2e6ae91cd8a3928deda54c53d04d0b19c529fa92ba937618ee8877cd46d0658de2e9585a6ba1a591264e0958a52b8d0f49f64408186a10c8181447b3890a45170587d8644e5cd33156f44578f894a48dd84f4b588e853bb8d27a5b91dc4ae06059bfea5c2a9f71aa53beedbc24ee8fb0fb1933de673d34390f45c03e7fa8e746f6004e7f2f4ca071f1ed7c02345204e1557298573b54c9bbe09892d4481d97d9a14ef264d7d9f22083d6c1949ea848841e2a777611b80f84d2b8d60e34fbdfdd067a98f3ddd80875e4aa78f932c0720f127df3f05e763510ee291f9b4b42e1ac108dfdec152265d1062664c78dc55018744aa1c0bd0d91d1a5f43862131d47c49a99192253b6fa5cc9119816de3c3e1e640488588f866b0593eb5eae48f5ce32fdb087061cc876e18f9f7ff98300225e4f0849cc3f8d9d441d36864612db67cebcd9635081a2d12cf80d16bac4cf4a3212d984e7e1845a167c038cec83791c6d111c08b56a1ac2d21efc055247230bdcb822d640be9958dcb38acd8492c5bad89340a718942cba780c003f07c355ff84d2bcc4f18bc2ada514e71cd7b47ccc53f33903e5993a4d64638d145cc8ce39c9c3b35bbed650f74c09f146f3be79c36eba868687724aa9e5123bdc0837b359d566253ea9f807e05ca34ac0ce95664f77c20637962e0e0cd4e5dcf8b02ebc844c7cf20cc2cc6a05f185aa520346662c0e0930f16e5beea040ead3683f950bcd6da0bf1a1675bfa9298088d18eb57b644b0490276b03b0824a78aa06c7d542b940bef8a622ecc7a3b90c82d33b1c69c71dc03cd4c83bfe296e94925c4af1d348eebe82e7af7406b3808e4dd8fef1798d86290a8f0bef7fe28f7813003b70c53b98cd7c04e188f525b0848181d0581333be54c8c692fceb46533ff4d81fb00fcd6c9cc9aea57cce8c2d8933f0a4825360fa179de8cefc80bbf63a2562695ad085f0c86a5b19cbe72bad55a9b81803c625839c979ed12c1a6dca313587afb74457e44779ae70db5193e6297bed244c775809f6dd031913ead1a6e79cadcf8898fe11a50a2d67f4a5b5e874dc70f652f317d56277bd1e3242de67fc4e3feba7a0e6c2b1b414ba1bf63dd356a2d9fb01873023ce19192cbf88a031ea9940a976942bd76fe10e709a545f6724d8c7fde9322b42bfb000d4a51ae51d9710273139f123852c05fda232c0095898d0a3b08d59e66bb6041824f0c7d3f9d05cb9fa9e62d45131c34394319d34e68aa9bba215909f13b56ee571d9090f6ca1ac11ad2307bf7c013755249bcd15252230618e4dfc6f1203fa060ab5514e45f86f8f4f75d680ed378b6033cebc0734d2f40e17e49fa6b7a0b9e2bc6327f09e3407b5b8dfd5714cec1bbb2b5f1ef6c865c4fa2d2a140e4203d4e7bf9719fc27c2fcd41e48d4ac6617e5c0663f5df0e75ee5788885ac58d56754e343717b8650f15bdb3ff9fa93d29df2abf6e6c45e502640dbfd402bd0d092989772ef6d1da79a71a75afcf19ddc750a5db60f7924baa97b41d2225f59477779f559bc982bf7e48ffdac1bb1740a6dbd8a8e8fadd9b67588d8c2778162214488060c38abf0a3f57b54eef71bab200f31f5d3eb1b953db45b21629df823640805b94054d97ae8a97e18ca0e673167721cb99323f79c104eee05aecf9448333f9a3429b57ac4c4bbb1e3efb3136001daa2046b98348894be5b9b55e5c299dff665018c552abcb48a5017e1a336aaba2b5cd4bddabb1cf52440674ac024697ecc3a1b14690e2a772539526c4684615ecb80fa3e6a20abd5126cbbdb67435152d18d9d2c3aaf86a2a50efefa71685a404eb2ee0e94a93245d0eb07e3d7af8b98566463c9aa8617fd382be199953572ec4e9c197e6df33446605a3264c8c258afb9f858eea72e8540f0bfd9d4e81fe9a39af322f1db43278eb513eda4601ac89aa1b8ba3ce3f0472353c14e28ec74b4830f38062c60ae1e39204ad8d8e589b87ab9342fe859cfcee08b871213637216cea968d6bcde72d1b5e45eab26d64af590655961bf01464a64e2f1cf7d7170cafca18e14d2674195701c8a291861470e969750ad9a5db8c160be5c6d0f8b2a1264411412dfa8c574f8b2a6e3888bbb8122236a72a8e10d9e51d329dcd297e43471df4db08706ce3775bedcfbada02aed67f8a880163274567bff8d1bdc544bd97c19fdf4f44e4705734686b1edabf95458d2fd1b3e5dbbcbe38b57d3e747060436e8dce1be95f447bf0e385182c130230836f721c4c35e28b903c3b9aeb10d431dff703b244c1a0e073a72abde6976c38fbe83d2d5901575b338fdeaef3fc81b3c25a0b02904ccdd2665b7bc8ab112d855e1f28fc078d5c81e093ea2608d3f76f7354c574466c7d8e4421a8e04277edbc43d26ded5b2a9d7011146eb70eeb97c42dba2e7f441f471a79e11bcb6303e969dcf9f306907768604ba5a1c6dc3857e7f43d15694cc042e2aa1c8b60581cbd6affb67d367a8515ff1d0cb14d09ba04840be9e8b8de221dce5283c6992c5e1804f14c21a44cdac6d20dbe66056626ca84578b3008a714f78651eb30dfcfdd6622066986f95ad43772b58fed9f3a6f8a7f9a4620f261b32d5782202fd231e8b281c09b9185367cd1c09717a2bc02c327a17048cf0a02dd7e8cf28f99f49af948523d25cfac506574a3f3f1019d274eec06b46e0989468e2d6975a0ec1d80ae8eb7b97fe37e211063d7fdf2ecdc38ae001adc3164c1e9e32c98c48aa9bf9287a45f24714aafeac0b5074149f2ace8a58d16564ed0f2eedb35d286264ed18d13429b4cb77dbdfc0b25c4d55ea58ff5e53e75e6b431dca535015f5ca25d20673ab831f8039b3a0dc59cfe7f24d34b02af4e83598c41fbfaa861c7a31b5a395a1fd90e68cd5cb470c91d75d8c857456679fa5a5a303df437dded439b9b27aa76b62f86b5ce5f963203637472b5d752747adf914258a1211dd0ca400498c475f414d1e397110bc72d75c1586a37ccf280b8037034de87b20f0d611d42b75bdfbb3315cfd6c745e7be491821bdf73142bbe90a1ea20661dc363aaa09889932f693151a088f7081991e43d035d55635452ee6078b14fe0d814d965516767452ac4699dc4c4b6cf498bcf3f988cc908bda19d2917a9f1c93711fe0e86d9aea9ccb2493b39ee5132ab20078ffa9ed742b619aa3748432961b41bb3e0ae5ee86806c314335102c093ddb041ea3ccd888e297f45a108edcdea9404b54c8265da65c9ca5d933cd3c94b86102dd8240830c2c5b0902d47bad99362f4c92424a5847d60c94f79c4c8fb60b491838099975520482b1c8dce9f0ca524c3cf1607cf43f3d8e2dbbfbb31e0e31638fc10aa17f653a92bde9c26062f0bb43d5d31b35f72bf0249858dd2d7e7e0dd94cd4c4d281dbcfdf9f60fe9cc1d97cb9c05b932fd41974e7dc6bee0c2879354410dbdf785f55811e59f7c387d3d8aff0111126076760378cfe467454351953416124eafa80e55ddc0eef739d30e6ff58bce00fc280da5581e9e675b91ae265567049b5e997dea36c0384bd910f111a995e8f253d7bacbbf3f5f1080070e4c1e812c8a41d8f70f49619acd288bb1b45de8a7c384331c9ca838de449dbcdd1e8a4d07091061545e2e0f1d1d49105a9f1f387b8a96245a776e424cf4702e3b6fbbc8060cc670d98b5c7daba4a5cbf1ac751e732fc00a65755c1cf003011a82a3d41aedafe0089eb903c38cb8f5ed39d0737ddb6101f12c378e7a52ef412070209b2560429aba54bf1f85f7bb8ec166e1ffa3719bdcafd8197dcf37474f4473b63abdb48580c5dccf38c27ff66350dd1f2fa8bc474c8ac61069691ae0bdf61c949a6a0e7239bd99a033c0078d3a954559f075f0108a3f45e6dba62c266105a1a0db6fd1dbb234ff1d9c1f0ce0962adf9bc740c9f3058682df199991a5170ec2cbeb56380f5d3e616f29919d7f7dede6714b84d4f325121248ff8a95b7ebd101b2514d5dcf16443fec81e171523e25d7db911c7230d657973a4bca8921f7d4cfb59bf0c8dcf193470f75ba18926c9babccb8eca9d7fdf5ca877b67e76d6711be8afdb1d77d2a06f95987d32c4136f5bc7a453b80653c5f733cb0c33355563d6f9c62b6ee083763f92f5abe0617802e68de3d11233d5beed6a6376daf98f24f7bf3337c4e0e0e7a56c207baf95ae84437076e80af521932b9c7b6570d4f486c38ce0ad87596f97ae4b034eb21f6ed3a2fead64e6f146039a3a842195abb4b9a541160f31699e1be8a650c6e8c65302f9531d558c1943676deeebbb94ca5a69af573d2bf63f4b31df83745a52ac31817749fbd92761eb651848d69b305a0daf0a7d3e70fcd7f98ad0e19a8370b2422537db2df6ca4dbd8859442ac27004b7de81747ffac236658d2f2d7e1bcff3729369c33dfa1592113634de7cdc0d11d3fef7760762721b55e1091c10aefaeb4a6975735f96776e6327fafe192dc83f920054c30797810e1dc1ad12e32e9e35d73a3ef920fd9ae953bf045587e5fea4b35e4abf0583b015e14407aaf5bcbd1868ce074076e82ed76e92285b74c46bf6bc5bedf065d2271b40115f934359a2c4430470eb3f2e1941c5aad7a4bb5e2719eeec3d45ad4fadb1db869c55bf41ffc64a9591b89ee172b85e50c9b891d5c999daecda7646bdd34da52b88f0ac68518474c732f1f6b16afa47171343e37b4cbcf423abc9f8745cf3465e00e5fed90d12db50f272f4317e5a820ea8ca300c479d3fae790f1aef19cc94631a85b358aaf301d05a0e6dc9e926d3e32e6abf73f75cb762b0ca14e62067c2919942d8888ef3ad476ce0b954eeee9b6ce6a1ba36e6326b30ba6a42aa3e83f1dda54c35b34b89e9c9441c0837e3711698208d2b7b149c8468622eb59724abade0306b3297e94783630a1bfc5e447185ded6a13859bc797487a55672463f9098aabd41ca32d744ed21ed5c4b1cdd75ae733151e7acf891103f9ea3695b6b2e2cb0ed27df217ecd87e315b510f48c935b7dac896d746ee5b7cc29ca10fefe116453a0d895d7552e2d09d2c254f7a0dd88f0e9a3fdbec2a2c206515638a2609cf3ad3e5f5166f071a8537445e890099802a93ef7604c1ab482c5349e5f67e18a8f0d365b83c60eee9136b770895ffe67f3519a03643c0a63bcffc302194de51f2f00e14b445659b052e97935e80f48f945eff00b7aace2ddff08b17885aebb5e14156c8ebfc4a84eb139dcdcbdef0f6324447b66a04cc5ad22fecf1db9cd61d0e0967ae2da1cd5f51dbc4c7bb096dea6ff5ecd8d8597e8be86a3143a9b3b4c6edb8208cab97fb6fbc0aefad931f9660fac7057a11fb898e9cda15b0099b92dabc099e7c442b3ab1fdbaa67dcb0b48536243ce3900e3c460308553d9a8ba34ce18c71562f98ed63c9f0cda65596f835d68c10f8041203cf33034c4cc03ab904e3a9092b9bc81f01522265deb8366454393f8b0039bbce5d9647c55a5371535552a4a83a0ee3b628d77de986476665dd842aaad5aaa392a20114c1ec2981195b3f2d334df572b2a234928322d156a372fd66d2abed98817cd11c66948de3eef58947b4effa32cebd6e8f0a285509de9060fe43e1ff76d383739d31db912189f74aa674ec942db8e4379e2929c39874fe2894791b85bb0c861f35a8c9401cdcc30c040efd36a4f957cd6569eac8e3f2cf8cd27dcce73fb226f0e21285a65bada1cde85a440023ef6e96c43f6119bd160840b1e587800311a8e13dd32c08b4d3a51471b1c63aeb990dbd9a1f23b15232e6e5b73ded9c1a2015c456b96c16d8f1c510e7a6f9323c08d6fbc7a5c644e2347ba69a5b29378209a61499a3ed9e123c564c0eea696c92e0c555250c2d48fc3d917b8d2728d9e53cf6338d29b0035adf878e5694c506b88bdbf689f859812f76e73d1cc4f52854d96155a2c39b0988e6e80d0f5401d959f319147e0acaf296f70054e0464ce5c612503a104a9d811f51a9019c2dff8f1db4ba89625a1348fd6c2320115c4f3cf6c00b722fe5b7b12dfb9beb8b11d66c9d84627a96ed39f118d0b40d15ea03554060f9f0ca916e143c5dde14ab5ea3fa5241b803bc12040fe27863d7e2a3804e23477210b1db2ae7c31b144f471bc118ddccaf07065e5b19c77d83ecef52effc246de6195632143a82eff9502ee55b03755a70c0fd1d32549ad02dd851deaf5256b41182d81638341fab5a92838f18c02e8e9f989a7965ec24cb284e8c72a24aae261310f90b4b10317a9267c5355d1d9fbcf982ed23fa073025e2400e2a9d16865cbfdd9d0bbc95fc355d0a9fe0baa6d1a6b254adaa5eaf168bbba43ab1ce27e3c12bfdbfaaad3331016b037d3e8b288ed80828f28c720c1b27ab565817b38d5e7ff9dc262b5f9cf54c7c75ca86208ceb87dd049a811cc4df3ddc9f9109424321bee0bb6bfc196d7b8fc301600b300d9ae7ac306c8a674b40a623529d63a3df1b7abb3a8d75a17c43689de5a2715bdacafa0194a1c60777836dcfbc73d9d74d3f77eb3715308c2fca87bac370ba80130cf29bb755122037c93e139641b84329b374a0a42e485aadd5cf67bba3045a43146bbac1da25e5b56ea26dbf5765b389e5d6bb88f91d724935dfb8d750665dfb65bf521476a9a241dbba43d8912991155e76c3bab20c91c1c294b194f7d06fbcb314cd906b7c0573c032630c0e2bc90322413fc0274113d86c5485ab1e01d131f16ec28c6f81ca56fd6c2767e2a8fa326e53fea725414aadd51f1797aec1449206ae560098a9c614fe34d89b0855248f9048ed80f7adf390e722a6e0fe7e758e7196072a89f30789a3f15550ca4691b1ee599402233da6ae5b121a46ba2ccdd33e29f3e1fa4320cbd7d4134f92a116ca6de6a3c3eeb98d65860eee6db65b4bf12f3105af5512a51f91c9e5b0e24ad9d2dc7bebafe772c9d9dc6909aa09fa203de8efd84759847798ffb9d4d8f1e362bd1bb6b92d195cef96bd6b68fd3a450e8a4d6130c1d24df0a89e5c03a0e9249fc9fa73de6adb44c6fecb322e6613aa9eedffdf56b7b7d27a16f5afa96c0e1652f531a492ac530fc65eb28417ef2266404da48d44993e65a653b77fa0dfd041a90ff7c3a09dc458f27bd757d3ae006dbbd7b8796b996ae0fc38f271b96f2ff92296e5c60306649c58e0dab1929cab86dca5bae5e6e760e39359f3dd8aaae77506ecfacd8845dbbc90cec44f5c60bd977c4722723069db61f900abcb0ff58ee35a1b696d30e775651ff7653d17a850f65c7681a33a6ba3e6477b85794e69b6c4a94a3a34fc731d99a27b90ada5b357efb22fbc743410709b598ee4c9d21afcd3f0e802356f570b5505bd0bc7580668bf03aaabf367af4038c9d0c4b90ef41b68b8c81c227a00740788303e7aa946f11f5585024b84fbf693fcb95f224a0486120b8942895082661e41ad4e94f2791bfeb3449c5f89106f72398094b9ac1b50691a3d3f16be159b774760465fd80e5bb7116893d982d6d6efcf71cb593b0306712bcec77a753aa41658d7c05571c22e02e75f3c30cf6b79e8952a3844978729221ec690960cf247ad72cecef425e3c1812b02c60b347cb579a3c051f695d80ad47e9660c205b7ce2b34f2b7e41bbe12eb65eb2434b9d788a3ff17e73f4dd43eba4c846c6e73b587356f81566d312f4d897b65f92e1629e4f940f034c13d53b7b0195525d5d5eef87ab384b421c952a931a3969dfaeeb3068a1f4976d1e719bd5a115926d2e2b9c18e421e9abe28d65c2a1f5e1eec97223b8c2ec7b825900de19e242054fe7a0ddbde79a5207836f3bc9459c5561b23cf684dcf8098085075abf6c961c0d3eb24eab0e38a971dac2129b2c3dfa4fbb019d7fc778cb65bb0f873d3e97478f59f3f2cd202e1ea497c5ef391cc6ffac7b848c4f8fdc4f5728dc74d7f4a8969c704842c8a79051f70e506134558970c9338fabb1591d04ff2ecdc495a2d10fa3a479c82ba38b5aa78f72306402c3bad97adf51588bf964b701ae833d001c73bbbf2f2f336606bb53c14e6d259b49e093580f75f350655e413dddb4ccd42e78951327601510d8355e6599da600b779a510ed8cfda120fb8587dac63b5aa6a3b3138570916a8391f5b9d64d0e18830a0e30ba9deed535d996d8f054a864a5c633da4a7add752a1f06796aaa9e6eba4852702d707603900f0ae48c9a6d10031134c5291cf85946bd68b7c7de702cd30d9d4b107318779b4f351e30df2e6be3f3b3917e64bc8b257cd2bd03592f32b0560b00af3508f225ff5e69ba4d26eaeb89813e9e7abc633b70a64740f179dae4a69883371f7c756e7057893207061a4b873833f2645ab928df72c1d78c989708d760986c7593395b68224ba75381d70ebd41a5be152ab8bb1633ad6375e688e562e5082ee3673d68681bcae03361e75697721b15ac2ec925a67b6485969a801d0562c5e9d28bf5189324cce68177afc4e89abfb387a44acf61a206bfb24fd7c2f182e8cc30cdc6cb133c8ecb0123705d86df4b29b6f7b5bf45da50fa04fd82430a09852320edda264f76171948e8f420920cdc9e368ce4b8a424f457ed4eeeaf1eadf910fcdd299daef3637734b0739dc8ef7abc0b8b7aab186fdd2f317c3cbc257f9e1af1373cff98c53ce6b1c4ff7e62b7068f924c18bd7f44409c8dd69c1785fa75b4445a68f45e9c02a9ad884499d7e5d9ed65a78b7e73118b4dde1d93126b07328e413454ab9ea6f645e87d61e6472590886ddea82de0d22dfc82d039dd644a340048dbe6f4494eb60ffb4c6c39885dda5b9ace245e96fa21b40b71ff996ce84cd095a6b0618887d2669178289a47ed1a15ea487373b9575cf96f8f9085397f399fe1ab07b58da2ded7e37c66ebb52eba951b9dae5c801cb9804b3b36ffdf2551d705623f1a2ccbdd77e9d506cb9a8383ad212ebe9086963de933baf2eb1023eca98d2fac8f237f9f2106e084e769d1da12f1da507bcd4627348276beacaab046ce9e745630dc1886e13dc360b1d0a31274066576f318efb25292138ba5b17fe350df433bedb6c5911bf8bf9f6cf8179e3b45dfe1ea4c588b9736a805a1a4bbc7f3facae734368bd24dbf44038a8b1d6a1fdb42da2fc2a9d93b0b77f01833f187aedff782726b6b7923f840baa664cb8dcbba775206ad8c1bdc90f81336a608c1451052eebc9180b91fd9efdffee12931768d0615756ee8462f67677aac02226471cddee7a29e07cc39933588a9ecd69df1edf12877111ae0366d829fc0bd37e6c03099ec3e3b383f9db8d209506c00be847b00f49b6c8d3ef8b00407eb3ce487539534cb653b22f402da7024cf15daa026091ad24f348a7c8c266378259c9585854c88fae4a487e1ab944c620ce97f059f8f271a175e181a2b90d14054a3525dd4d7120853f74011768f0d7dbb140f3d50173066e56a1d9ec6325aae02e1401f0a0903c2c18f3b673be801dc4526fc40e47e5230b89af1dc2fe37aa73d4b58d012d97b8d2c83f0113fb3d452ad9bb5f78f83767f879504c7d2ac2fcc855a7d4c6f2717ce389097d60d8b8d1263c92cc9c06735fb3d2bd06309bd25cbde23b37f659c4ea6d1a416cf19f5612775cecc6092e23a84f4af2fc603b2cb9416065d1b2133285707cd66b23c8f4b918cad26f8df9ad52ffe68db91ba809da9b54419c142c4783cde380f9a548f40b0d93de366ca1ce126b986256b7662c76eda3ae1425bb05023917fbfcbad33f035bc7d6a39d563849c77fa9d4e2932900ead764fe711aec9b8099b4baefba938faa20ed1fb99fa190ac196401d2afd6a7444e5d964f2f59566eca3ff615ae2a24aba95b826bdf93e18ee982ec435d9e432265876c3dd1d122933150489e750bf46069461f724c9eb8b618661f468dce723d9cb06dc7e990a5a01445cd2defc4f27a34da6ccacbbe30832f05e4c3ac220b0cc49b6bbc34448bd665a2c97917f5f13fa2446744107815a75d81f1a39ba5c3441287d715dcd105a75cc89f5e496191f65ea1e4acf71b08bb4d572b6647d447ee9a572f7bc96584ecda4e7115b9e8171ec564563effbe914c7db3857be0f6ee3e58746ee2b599f5d2b10a7f135d3fda99024946eecc88b1d6d27b3f0e60fd62f7e69c79c5b3424a48f6102a6457cf74d35793321cf644f644ce137ddf5e0708232d72c2fbc5ed64d4f785061933fd9de8ab2b22f13b03ddfdcd073b671d23c64c09f400fa59f82cbd0f7f54a8f36f10ada52ae996cc8c6d9e22b3674c1638cd176e3839ae5fbe4e65c992e929a9ebbf92aee7fe1debab5964dc89a8c0b63882d0c7cd3a8b068918e1752d9c1f4170b3846211e3e6683ed9a8330d34deaa8c0eb9cf396ad2dd87302246278ea85fca9add5dee6d8105e6065f88d1e529e317424079f0b2f5afe656a3c3f3d77bebb9e1ce1030a65ca29994834df16e46eaec46a11f700288d302dd4c57a256f4ed22c96dbecff38a6e7b8794e6eea30c4f20108ba9c91c8ba37a5bf82e63488e4a2c44982e4eb3cfab94b38e60539a92f567109f05b2076b26b73eb83ee105c41d9e233b6146b3380ac42392db9cb63c7877a83374195f47d78714d72324e738e896a376db223ab7b6a0feb0bb3233d9b8178a0a6686cb66feb76241e18a4459963a870ce74a729d24d06f8edb9785f529c073d6255293922e187f612a07edb699c0fb447dd13dd6ae5c75a3cd972861fa0a45ecdc53a9bf103d7ec5d3798ad5efb7686d704efd434dbb5ac9d97756bc4b574100725c89eb086cdb26745dc56cdfc1048f8944191ae33a89278e2fe18e41114cf617ee54eff617e34096dd504d5f0454f18f50c7f19c2d3255358fd825438ac91995e8cd2acc5dadada520ee443234e7250997c0801e049d2b39c37cb333da897109394bed51c9f2b163e9f5e875cf14b397d07d5f03ef7da6c4abe77d30ce0c88232b9e57db5a00f98ef9568057d43bb8e266c646da0bdb52016ab2d4f1a2bc6fb7c31fd170d573821cb076bcfca11c01a59b169bf98ed8aba59f6467c69802498c2f8c001769e37a4f1f12ab82cdc6e57c2e18b1a66baef1a8a48c274dee184f5c63d601b8cd15f2070df0dc452e2064e7383bc051f069db5e2f9891678bae1f79f11f6dec2ac7ec7418ff23cc4005bcd22d7095bd669657d3729f4588aef3ef097def5538df225c3eda2b9d4a2a1a2671f33a1df932ffe8c9f10e0a07011c7967ea7f3297158389cc8b0663970442b83082c867d28ca84dac9cdd559b04e5779a5e013dbbeda59db15c097c677b510c07896f2e775461ade56d9f84f442faa797c9193ba8c66f3ce20a1bfd8233856f3bd10506b1326bf97be839c9c2f221403ad1d0e6b9c18851f1e125fa4536768af1efa84024dd3bf8a825eec65f63050ae59c80d3d20ebc4df24593a3dfb0c6ef1329263cf5047138b9cef4ff6b4adaeedd85b9559e7cb1c2791608c5281aa77b5e3684fcc165409aafc5dd4b89a74c2a3994937503a84e6f1bd7fb17206111f573fcf060773b6adb455f0c4d117f429e5c993bd7956ff43f1859f5d5cb5b1717a71d986a946f2cce91eed27c4b8c37c53ce73da72ad74673a25f1728f0cdeffedc0a91c0f0a5c3bb6f9783ebd0915cf2ff7ff795bda0fab98461851e62c2b14644a9f1a1960a0de7ce3f9f80182fd344cac15ed06bf05fac0790cb29febdaceb8edcce469a07fdddf25d5e60f0bc78306b56ce0b12416b489bd923e768048f569f58f96865e77fa4a9a7f8adde8f731b763e0b7925dafe390f854d06caeb1c58aa4a9c2c5d3e9877ee09b360f4ea554293487fc4817b96f9aecf9a69b35149b65a3b4ea3ef9c259c91691722cb0c7e6c04dc89c9c7c0b158302838d64e6f63e2ae2fe1a316fbc67cc5981ce4f1354d70595cda98f291153bcf9ff4239ecdf9e01390b614ab6723e4869cfb391e82491f06d99ecb767cb36a8004f56b53e4c59ef271d7b548f1f22408fe1647e182d2c8f230e61ceab9e59075298037005630f5a15e510ab3117e60382d6a8e81261cf8ca164e5f47ba70f6da272c33d54584ab828ed456b47fbbced2ceccd71e6706bfb61f0c548bb9a5e3ec49534093174eb9b15a90f5aa707641018f65a61257c4bd3b38b0266938734e49c88b0faccb48c09ecd2c8c40cee8c53b971015afa6a8386132d05bceb858855daa2951303dd130c3d17dc5881eeab646af99c609a3678830d0b664159d564e021c38c9feed0e2bf79adb32f3f5db7b3ba51850aad8d7b284f305981ff2fac05c2eb00a4ebddcc9818f338e34620d0b126c14dbb60eee3247319416e6231289628c67013fafc961595d2bf1242b8521f647fbadb843696f5d2061e488f21b023b596b0f5b49ed62ad1314fa3cf32474b9cf0301c2bef6e7718c120a6b4431de56c207ae379b3770f0b83465773abb3e0cbe10fe0c0ac606f7321f1f12ae661901f93086a16ed45286775163b0f2d0f47529ee25cb56f350da49ed6772d260f2f9e8bbef40e2a766ed8ef6219ab89a1e02b04b97b9b3451c31bfb7e45384f5031472a8352bcd73d6f6b25678da7d13ea3021636824ffe2cdb144b1e7459922411c702128cbbda30ff7bcbd82e10c8d0df9bcc3a375a78736b24cea78dc2ab1e2204bc9594c76fc721d8ae7995d3fbf3ec1bfc23b4f693c59ed17253cf64e72439fa0e3141dd3c99012fc989a5f1acd76b021c694735c1507e2ebcf0bba72892bcb06c9d895a4af46f68d19a1db0c908cfe8119486f5538e4750e59d3c91d2e9099a36bba0c4035652c6a0fd1f51f86139b5cf2ec12f3a385fae0317615063d888e455bd1a9429689014dcd5de37827e2737e815c473b1902b68cd79bd904b742bcd590a97c5d0d998316b11cfb6cd950a8e6bd037da48feeb3b757d78c4d8d1573b6bf020524d9410c24ba5e72ed72e0320d4b8ec0778da22c442bb543b8050fea194be4f662f2ddebca7fb39ffd9afd48aaa723ea15e350d4af0d92a5e14cdaee6cc20a5c755dce9410732035f72f206860041d178bad911a1684a68d7407f8ee3bc4aaf8d4384198f713d480a50aa1520a3545beee4a8542310c6d07ab27d8d9e6953d3e94658d5ea7f0f73a89ed9efcf5f475b2054ce893200ce83bc9d54ecec3318df24f7a22dade40c30b393bb4a1c38d0a9612eed4f7c1915b31fefccd98d432adbd86c52b85ba52a1600106fbe9ec64eb53c90f19df358eb5be6a55dcabed3acd0637775d459cec795a62de822151f4df84dce30d4a2a062002dd276a1e1ed787d96b441a723ea9a8baa9f06388d2f7dcbfcc8fa8a7323053faa517aeecb12104eeaaef68ab3b10a488f0edee906f02094d89576b7279c124224565b9da1a618e8f67d8983064eda39f981d9147008a1400e3d2001afcd959da81616f81f3fb738ef4921f2172356faaf430a84f7fc1564aa09e1186eb2ad8bd49a1354e62236adce39da73f8c75176cc48c4cc8221c4c9a2a24c9127f7341ff95beff85b06aca88597f21f5d5cedc44109509e7a71cdb99bb0970962072913578ddf3d5de79ab8add33859eb870d0584f29902aab877d8074a4dbee35e5aa0b8e604e29eacb5cae9aff033bf03851ec87ab686d73c47623620044d6dbb3f405cde4740e91a1bdfb91ca8c55122c96ec83680658f35153acfb42a19aa64dc897adbf8f61d54e38e9dce8d1dc3602bbcc39452552bec46dedf4ae9bb63d2a2d65dc2ac977a76fe4feb61ee8f3b3acab5eac26","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
