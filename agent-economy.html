<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"70241217441eaed90db8918932c819d53fc09b4a9b6097126fca17eb6f0e9ecb8127ea0fa9c97977604dcec112c8eab3ab6186a64461eeea5d4567bac16e3209b37c33bc4ffcc7ee5d19b33a8b6c06b8db34cddf61c2e4f5cee196e3c946bcdc4b35b1d091c0848a53eef763a83cd95c8f22784be46db6a5bd00536d8758ac06f44d39d9f6852529d6f25656b110dcb0b95e1768cec597e182a0cf3ce962983eda01eaa5fa3e73d34f7c500d49dc360fe56315d47240338882badd43cf1dd1dd5deddda410b04e479ae5ae9360975379b939f158dedd6e4a824abae30243c48918e8a440db653f01d0b3a3b655bb1fed2541629a61c996ec1ae2432cb705557c7e2ef712acfb6071ab446cb87bcbb49faabe0542fe1bf9036981a71466ccdc09c851eabc4331a2b457835c8affc520d961ff2fe0b519334365d32f8f0e8958283c97aa938e1e1afd46d66122642103c121ce7d04b51fccc8ff7aa34169eafd0616b7d5c05b4c113b91b5c5212f16a050c4d8bd7c3ccc0ee34df78b09f64dada7de2c7aeb8e551df14c09b978d119c142154a196d9844eacef410542e984ce79c3570b3aa2ee5fcff652b3f2d744e5596330ad35001c7b3f49ebe3c856d4fa6624873e0bbf901453ee7ac6de169d5cde58b585f27649183a3e1b7efb398c63f4a7aefc6a460a7ca1aebe12847659c42cae57299fce224144839c9217489db7b2ccc30bccf4f450e90247bc2dd388e3ce06d3d6d212865a86e5b5c7f19d1eac0c113966319c5c6b6a65097d4746f80c54804404f9b210dc7925a5b6fabda5a0c6bc0416471244c0d87ec60bafa4eea17686ec4457a6cb69403b1017b9a9117295f05134d945cb14afd6366d2fbc04fe2914b9a665c208c96fe4c8a8c9311067f322855c3bd1e639d78df9bdc9405d75f542ffecfb32a60351637d2621399cf93d19dc6ce47e1fa63ed055c4b34cc1ec65b86018ca178ed6fb3d4d4c06368a81fb48a0d4f26dcdf2f2f7cebb4f2e4ea0f9ba2d89e2b2139247629791c9895842d56f8fc0172e140cbe60d1336299deafcf39c8f12652524014354e1e754ef81ac3fbd89336ba5c1b11ecb2252b324bf539326915453187ad2d7503cd5d076f11e05bfd533718eec9c6d03fda07197ff8dcad3a957672d333783a92e1189f4422d5bfa378482d5aa4301e3deec2f3cb86a9be45339ded51256dd17c2ccc496d0472e4763f0792c573069ea8beb5191acc81e245a4b8e274394b439c6bdb8b44f9bff8ebcb5c5bfeaf10d1102ad879af7e2e8bcf64c703f00ef0aa17c1eedbef8cc3a3fd595234f6747e75370ce0f6727086d53b3ace9342d956222903a624a381d8cb171fccd5d10a96147b146c5299d363f670a9b7d382157443e72ce1e9dc9efe20c3c00d476723b7f02021ab75ecc2c8eba6d3c992350a85765d8254179e6bf4cb59f23ffa0b87bf1ed7551ee898e65a0b058b4ccb1b33e8d6feab55dfa23bc6de309f82087616b20dc423dcd2b90b6c8bea707aa9c391ecef035696f196e29234fac4a29dfc3d0a763ad13d5f065bdc0802d438775c9380a703495422781e7d3c9d8839f21669f10a0d5cab449bf5b8936a6ffdca0e16efb01b6f2a1f419a2fe02976c5fa22387586c59d9add46a0d155fc8c219a463e944e7b2b543ebead771c72febd3a959b804ab91191fda6743e5b191869ba597ffef63880c08dbb0ac4ad56bf1b924a0382ae133502ac2f56cff9df8a716ea9ffa3c8002f9f6d8d5c16a58cecfd51953de9a95ce2a4c55f6e6d814ea12017671ec78008920c0b6475c159a47f5865a68e04fc255d8ab767690259958a8a2ac8768f4c066d20dcae3016e429ab67052a04d3feb62d68972a9d9319c640aec4d238050a7bd888d3eff6172090923ee85cd49ee43e23840f86112ee33ae680477d5ee1eeb1232238ad59b7efcc166e55595a44aaaeadc0820f4a7ae06871ed6f84cc0080f8cf87fbdd5ffcb9c7ff8fa9b81a7bd21660074620ba044d9d0332623cd160b757fc81a10c3c577d421849562385e8ec926d64bc5fecbaa250e8a47d1a931369e0d4f5314d515ac77f83ba969366138dee4e099abd624226f000dfc5a422c5921c77f0396acb88e521bf79a282aaefeea2c2af345d7ac68e27159be31f041848f0e50fa9ada125054fd0d330b14398fa06f7e651b4673d87a1428796d87b2840d6208a34eab087b7480eafe7681bc991358531503dcf6f7802e86a2a43c687fa9a5897a0e81a3a282eca2ee7e800e6c1cbd2e04fa841d775a2dc2a87b0500b7ac3b9ca1ebfcea55d8bef2a618aeee2d98069f34f8de46d9cad9d726fe47c2cb0993dd69a1c5ed716be1741d9532fa6cb2d5058adbbbb60e975bd4d4cde4139275ed4a69b4508ecce9957afc7f36b75145ffe11c16c06b9cf1d0cfd72e9536095504134396b6f283ec8fd8d5d88291d351f0e38be9343f69d4c46447ffb0370a94dc830086cf36c0698980a9ce08005f8eb6dff0754c45178590c7c539dd332b4e083bced4d938d79ceee65937849a85c193b92c3031ac43581cf99f5c01592aff9160aa9a69f3da1470f960dfc79bb0c6bc5db4889b95a785c45d57638d6818934631a0331b73c47f53e177751cf689ab831c9bfecd6efc2e178d2223c80655b7c1f440bb87a121281004f135207a66122e4deab154f7504cbc81f549700b4765387b31810c76dc26e74ca2e8a3a8838825795e665c120b947817f07e40bf6d3c1c4e494046fbab019693a0bfb1a304cf9c4d5d2901e588cc93910b1046624ac5aec1abd3a3a66027f6706582f239d0ee5dcf42ed8307f77324b2b3541b28dddf75340f9129595b3193a0e849035ea35f12bf9066d1e7baa98bf229b9212234236aadc4a2ea26e5c4ac306e07a0e94a7fac7862843a6117b0e41a0f80c5bb41ec2809af969f33e4d6abffe515470825792fcf0440de79853ebda0586ed2940cc2abecf8553763c7612d254887415fe534bc8837cf812e568da4f7cf68df9084e981a7ac6f5c20e0bc35640da373d226ebf5a7132465175c4ae5585ad16f81ffa58be9920dacd2d9aee236bbfabcc7f691c0255ec1cc4408aa77d662311b96c030ee6c58fbfb37011506475bbd78318fe1b940ca4c692c79f2c2233f5fa3ec3485765812e7452b3ccc012d13a90d7bc5150f5d20ec91c0347260303380d1bf0aa1c03001c4ff2f722f69705ae16c0ff0b4c5d6f17d416c2d15805dfc778945682c1a77fda98dc61a775d85e89d250354f29464b9f7cae44ba2ff0853a901b31fa0a00973c155ed2959ae566bf41abba3c1660d1334c112c50fe1f0c3791e253dc4882432b30ad664535d078492c298fd2637bd58a7be51596fd809aeaf311d5435526126db51e3275a2acb152c34caa37b1091e3e7f217d24ec33c8a6730208389285bc47a86af936cf7f41135c0c4bdf31a780dbb050d3530f9e0856e21a0333564dc0d9dc5a0843f41bea750ff2014fea1d193e3c21f2bbb2456a976c0bb5fba63774e1e2a296de295bb6243c8f802a2c29b180499d7fb7186a927c9902fe785a7835130f7395515e6fad87503a6709e82e084384ba1827762db5376bd891d59d01849518576170a83c01a57bc3a1fca131f0150534a965bbc8c8df28f24704299c6f73a00a4ba820494cd2c336143222d0dfe1dc65763e4d15361c1890ecfed31dfbe0f590e51c4a7badbb7223b269a1e7a568fb8381517a5625730596899913b1d4a54fa2c23e15695ee9f597e31413ec23661b2a12bf982e1646c255afa4dbb71aa68c5fc130bd521aa7229079da70d17b08eda25580a94b73571bc8e7493c190bb457aca25c255c02f56ca2ba7810e59a4dd42d8cd695b04bddede3f2ff7e0d277da900c2b05a72c96c9d133c7c95c63d0c2dc7ed942f24beee3087672cacb0f8156994519c449f5be7c4fc0b000fe69f11fa9960c82394377da187bb6e261ab54197562d1a0a8a502dbfea44e89ee0a0fa252c4aac1cf1f0c6550f1e61f0916856442c7514499b0ac0e140ea2eb172bc13279a257af80959b3c51cb8f87634bca55ce4415cb4b7ba6f2c6d2907bcad2d3b24d65e699f569b925b3f5f3573ff52eb3530b44c05d08ba0aa7d45dee97d3da628837dd2ea1145da6eb55b21c51ced6d81098cded74b709b8e7f1dafaca52964801bfae50164ffad57796d235a2250057057bdc452e1f9eca208687a2fde4e5ab72cbad3553e1e6f58d2fa8e6d40040b7ac01a1981ab111da9079b0e9123ce3cb54d19f890252b3ed908fb0d3c3131a01e4f46aa3e1e4b0c704baf013e4c9f8cc14a933946e6920874f88db0eab6210ee765048fc902e199d2ebb77dff68b8e454094f452efabedb79701e778622d12ddc8af00c45b5dae6b5cd31146a67daa798a24e1903f9d8c01f937a727a542c978ab512938c86534c45a9b15386ac7a860d417489a89c958b07ca60974f6d7696929f9bc231c61badee957f492b42e6a126ba3438ef5842e82965a9457d73bbe9c01b48bedc85816e7843102b6331faab3ed04d1be571803a61129938418b7b55e1ffce39168735b50ab0e3f32015f0d8c8c46ee2c51d3b3cafb9f755232e9de684bfbc42b006c56bad624bb2798aa02aa6271dc89bd42418fce0f8e3dad202c469bf47384cd1cf170b0f752e3e3083ff1000a45b0029ebaf65e8fc5e3b5a6f0c3d9adbe84d4af50b62a0d50af3d174e0390dab5bd28fcc2ad4511714dee4b8cdf8f68a8ebc81b6e6f6f9ff4d565a2b08f1a149a984f90da3101e8a2b9d7b2c432003111d7006afd040efc2f083e2ed7dcc6c469e8e7a9820d967ce9f525d027c690fb1fe4d99d0fca00bb12e0ce2d48a27498c305d332bd07bc0104ee47efac390aa70a5b8caa3745a706d8125f19b87b101bb8f756a104e1b8e79859337e6f191d47fdc73934ec7c8a597f5fd3880f7a355f7029ea1f7c58288dadf9d4a619f5a201ae90bd44b5ca74970799904566108c7fdacf356974dc95ea5dcd56de117f89a55ecc91e201fb5ac93d61974b146df86a701f4242d11833e4a176cff1c28c942cf1d5efb9bef1b0bc1c61f627048ec4380281d28b7d82c44993ad380c016b044b171d7279767fee794b734d08f6d0d66e8d11787d15cacbb0b697d1320c04b2731fe14673971f16aead14bff7369fadfb52081009fbc2efa9c20c2350ae6fa113389a857a5798b00bd91cd995c469c955ccd8378f56fce6018ddb7f12d2caa0f88421cd573b60221f6f8fd9044a084e4f75ec1df22cb1c4ce4d608e4a6e39862f458d185d142efed339c5ff9625b66aee3b6cf7c66a136cfe1cb6847736473a4f50233be4ca20c60763ba6e59766ebe9f3adbd2b6339b6610a04173417769efa1bed28d236d83ef1b23827286112351704de873f437fd0120fa8c28574503bca3f06dd892d3ec1be68b8039109ff0615c1e20a329d066ac77f7250521fbf2902479f80f517233450f0998ed98908b8f5ac6520a481d99c50bcfd4d84b4f181bebc65ced194489eaef6a7c3401d4d4837b10c1a01afb938e71b41ddcfcd8c708558e736e223c0efa10daeb8d60cf00ea8ca697b5801cc3ebfa5e8431ce998ca4d2b566385cd2b24056a374210aaf4e10dc0ff4c02d152d6fcbc522e10fb5dd6817c6bbaa5275e88572cc4f3955b0c209fa7f8741ad27085e20ac3c21440767d2459642a30e220620ea3d8955a75f16577142ee5b6921c542ad6f8e93e9e6077a0ee58062f7e38b464cb417226211df6f90ef855e59841dc72de1bab234ad100e1ab6063b84392c765666bef75e8b495043327719d0f9af37140a3be64e9633b5783edde3c501ab545755570eae612b3089ddd2cb9bbd6d9b6d60dc015b58201ae4ebf1a875cbc34ebe595f858b53c538b29b439fffc8db37565f4d15c51e0394fd22ee929c83a06a4d8e6fc9818c516b4878971186cfb67bc49ddc42b6fb135d9c69c54bda6deeea9032fe52b2cb803da56d0264f1ed1d2b4752ed1b996d6f0848bcae6d893ef09be8154395bc1834d0634981353ad00c50a5dc496d3869e4297acb90674b1e9e82b84011cac752e0bc1738b640fd9fab5497f60d27e34e079297bc21b68b92df8a9e24f4395c517cec4852d9240dedf7c2fa6bed01c9df0b76c7daaf86144cd31296f7e62c03ca029f90b1cd8b8d77e1f362d6a23d868a0b11a9fb18ec74110feefea31b01e7e67618733904ea0928d67f23cdd2fbaf8d56f377ae15c66fc39966d707cc1a0c124834602fb8e115a9026d0e1c0459595e7d870d07401336902295ade61cd2400c161b7c4172727d1f485f36f06a3d6fd5e21ec6dd571b71f419effd56fa63d718b25eecc60bddd518a05f25fb20165bb7209567c71ba796e9b64d1286500e6e8a09e9f3a1ad1404b4536ecdd7b40097b948bda2ed04939f1c5b3f548136b28ef04755f1c7dd2fafae35bca4436731386f53cd442c405eda2b684f82bf34d786175808d9bc95d63ef83a54970fadbd00eb90d40f8e1e66643cbfc4b9eeebd0b718e3c010aafd3636e109b63349ec0a487c6f47beb805876e8317db222e0d6e82ad57fbbf072a9f34cc311edb82419eec3b2179ef3331c783e108d84b232a034d6308763a411fc86b72c4e14c0fa3e69610548f235e90400b5777f207bfeacb0f135fdd48536de4d21f629a8434111b6204f875ec2adcdfa796a77acc7950dda4740fd913efada6a7a7cbaae6172b3643ac253ab0eaec9215eca66dfbd97d582030f5e6c6d3e251125200cf5e7bbacaff3b076b44c7931072364c33bddc0970725b4103f63964007c872fa9829dc09b325ce577c7fcfcfed6d32b2de2e0492f05f310f929df70414b606d394e9a236bb4375dd7a29806be32be88974db38a29618318dfd15eb3231aa3e589ca302b19d499b0381ad00d4d4a1b0df922da4917065fc3aa45d96a58862cb20bba55ce58c72d04f7949f77f543d9d65dd5810e7605ceb2a8af72405cbbcbd903b0b8f9f39baab4e8b8ad7165c41e8dddacf0ff65027c729c3f068a4bc048452f4a450d641919c7f8e5109814a8b39bd406c70d682e139008be7165b6154c4121f6b7ec9c555738b04dfeb2014daa111123fa5f20d88eb166475a36f29f60633ace36a08b2f74e2eae2d693b640f7d29a8f9bb418dd7a6f61a20ded9997f67d0b51d93145a99f47b8f685fb894d42c015be6db98072ba4d08f70f08831bc1f6f54d29f5193674af31ccb9f6755f54354c942361c07b52a4232ad695456c6dfda5778cb4a97de4a1a92ed191522e774c3c4726dd743a7b35f955c2eb151d4f04b05ba76a22b1048cbff1d2eac0000ed050b96b347a3f1ada1b436a64a147ccc3b2cb9b54a2b5345f852309292d65512022e29e3f02989d3edc314ab01194ec14f38fc42b714d8d4ec5ed7c46cd3b6bd2e887b5356b90596af57e2cb5139d202c541831d8b408bb68806c1ef871825b18f4b30e9b9a3b413a50abc1a7e2fcba72dfb98ee27a9e541785d2b9d3797620d3e76376083d5b2927fc03567b40c7c8e9aecd3645ebe8ffbf5aac4a9108fb0f75aaf6242c794d48f4a7e1d10ca6b16183cdcc54bcb0f289f783996a44c8add907d392be749f5eca5d41602cf515a42de53b54afd49b3be72411b602b82a6eb709f80d8e2ca79082610fe0e8e35f9cbc5dd7c3c9e2c2fd295dd3135a92091d062661c1a171d9d594f7f6ee1673a456f75993468e3fca51e1c615d5fadf8a65b60375ea05163efb98f41dc1fe9e7bd147426054df37cc00f3ba3b781f32469f1835be63848f95b4b69f807e98d23e7fb92f3f629a198df8204130d899ddb2b781676651fc62917cb22c65ef1bc2c1731825de2e1094939b071f2b8e6bd47c22432564f8c08b345d92127d2880addc171eec75a329fed47a5e4ce4c148d1b5db0be4c9ffb7bfd8fd3af25c847db639e654bf6be72623fd5ee1b4b8b269baae9538295fd999b412231bdac68c72dd44d05e3ff42f8f90dd415cd36ecbb440866b37763736a46cdc1a9c3881514745b4b73775c77de262e79245eb164edc6221ebab3b429ddd397e4da1b6cc6e82a456d31891f89e02bd48fe0718038edb0cd104068a781e379dc762b3cfa1f5b78d77d0f7082fc200544b51d2d1694bf8d38ab4a8dc188b7b8a1b1094fbe5c1af0775779efddc1ae1323d3fdd35db8ce42b895eb18a50622b892068c35c2591ed7a173b9924d7c0a265cda03a135465251152dc93e76ab56ea48a29214b1700ed9b18f797404f89cd136612a6196a63f8841be98bced0129084924cc1bbcba0f2cc15055f6d320b634913a3ee754a8ad4305732388e13c1788e208cea40546e8f623386ec33cca388c08dff976e8a40824290e36c1308da5a7ec71c3d6b2e4609f23b135859e3cc14fabdf43c37f8e4817077b83f4a9f62e1d22c3761a10ba6afad250111372792b01df5e4966f27adedd03f1d42923752e5351e4bf197eb6b7fd9311a876ca1d461fc9be28879c98a7a68e49ba7fc5ebf90243e8d58397a20e20fb0f1e48f6fe890589ff4200bac035ecd01416294797a85c4212bf5bcf4ed4c1a0ae951c2c730661429fbc57b8eabc8aaad5404bbe6b6fba787cad6a053c49c375a4fd2dad584372695c4e0ca0c0d229652f7e81c647349d309e80469b2be3e93f356cb821c721cd4a9ce2e718d6c099d0200831891dec37e02eaf4ae89ecd458c41729e2868e31d3b231ca737b49ee23612444ae308a210dec21e1fc1090c0e8f1e408e5e4f2631441ffc59399d5a62f48b6a2150356b0e65ccba0b88f3a72301d7dbfedba3e1402f0dab689f14aaddafb24182997267bf25dee1e54f8ffb985372c9e719d18fc0c7881257d20d66ccb3133de1e6cac9b46a3104f1efd2f42192a2c0f521bcbd1b008fa0fb3cb53c1586ea44b3798692283faf0243a62930de83d1e7423f3d4b5be6532363d2ff510396c310a8b2cb5029c374b50444fd433c36470498e7600bf7cd3e0cac23b0be6d67f81a2daed85fb80a13f5d44a0f56678dc325794577aff39daf9df7dfe386f1e9bd65470fb5ad0921273afd7e548a552f8154f0fa5ca2defa216f229835296ce66f3479db2e16670e0e6cc9b12ac933c9625da2ac9b617f04c048a8875aaccffa4086a2134f4c7a21eca614454255ae68c4ff084855045b35cbd5b3042d2625e006aa4a8370caa0575b8f3ffca0b5bbf22ee3858d5366f06ced28472b2280a2b5e4d024b7cb61313fc9e48cd4730a64fab0801ea908ed3c75ff86bb5c499ae1ee7cf87c3d1e294cfe8703f8be44cd2c85a3c15e2a76f23255a8e9c9614956679b2dc9ee091e5f392a69447015a6a3465f81698afed62c2bf6a009ff30b17e226f0ff0ea937d1c1cc179ede81d6b844c7b3e138796c1fc89d714e85c9996a5dd3f5ef248a060051fa4a56dbfc916898a4682cd88ceaa0ff20bc0148a4cd4f4c85b800f3ae4afe26a518b11e07493d9f67d22467ab19a381abfcb1bbfcce44b5f222413a0e713c14bbbbb4bf85d20e47e1a9b0a90b478be07fbeb59cac8df73e3c9d7e3852bcc74fdb650f4faa4257d4e2f917e0e9f2acf38bfebfe5c0fb3ac375861481929d250dde4099c72f7b19fa7f6486e3909ff1301665b279cadb752c9b8b296cf5057ee777cbb0392f841cdde2d65a158c0ad9184c7b0ff16b05665d647aaa081d0b368751ac8bf82286286abaaabdb1d183564e3f272806fc2a16f232eec79242dccf33295680b773a24e21367b847631eb4be7c174f768435fc2cc05664538bb2443fc62c7372ff79cd09d33fe80a7d44361dc976eb64cdde257734ad273929968682dfabd98654cf6f8642b2ac4293182e36b8b769e1a3e21a7460e2c783aaeee816ef7f3aa1918a4e4d6791d4ac0c08f2b2915b327686039868c0073f5e20e875b4293ed4b71c560914bfb65918903f0f05e47991f12cdfad4b2fa5dd9a6b289457b1e3ebb70ae3ae014fc9b7e8f2928edeb62743b9e16333ef920fe429eb527c5e35bc85b52dd75d024cc7fd23d26336e06d80b98ff83e3d4ff33f9ce7588fdf32f34858b2b196abd51170d246720e408568029cb1e52492a22c3d0489512b78c3da2f037d9377540efa6c616999ddb4fc28f13788b250d8e4a154060db72ea9cbe8de17fb134d4537a4d67c9723099a9ff6f021233865b95d0ed9f89874d57ed02c2498c3b648312f623a86c0ebe533c8a3f65614525669211635afb036d5816eaf0002f6deb606060ff536fdb27a5622fecce368c6943641a0123b3d8c21f4b53899c03beb9497c61c6e8d624f832c0a11c724458138f1d740d37fde5e53282aaf4c40828715cafd08f7a996128d7338aaa02e6e77f0a634edbde4bb493cb6bdd8274116fc3b1ee1dfb2d24192ec7fb0fd42d991398eb461aa2d99fb5772865857100e7b580deeae23891acdcf69f8569adf7e657259f993222ab3a8513c32bec705e223efc098dcac83a90311edf32c05aa61d5e51ffc7e57a78028c4013f6a1a9af9b0079459e91b51ba11deb4cdd5d0a915e87e5fd707f46dd1b31802ac269c3cf23103f53f110b808c937e13fd172b86301201cd32129951aeea2aaee39d967d3bc631886142e19d8a84f45bed4e69da4e5d3be3baea680ba352a2931490e9dea716c0c6087c218650685fb1b2be416a300c84dff4ecdd1b0478be8251813504507db1d9e26868f817856c939f80fde90e0844350075ee373f16fd538a5f09498d50685c8964329aabfbd5373032c69c800bafe8792f4a6cad78e55baa14aba1aabcbae065ef55391ad5a5a973dadbc34feeb16b04cdfbbd1d9d73d7bf5ed3f942f646a0b543f8defdf5db1aded909d905befae2a5e6838ec7af1b99367608cbbe9342a887bd1b43119153d92347035b154417b18008a769d8eaeeb1733c7043986d7cab849e8d84e1953f6466af617830053d4b0dd5549eb9f6c6c8a80a7009049d179e50bb85b262a93c1c0b5db6e5948190c83e0ed8f899f95530c8340f975ee88b4b129a6f52b0e7696e7ab1d89bbf3be20f1f0794bf7b12e6c980090f0615966067bec6e59ed0b8b3c7dc721546ea78cdf9fb137ea1f3438a465a0ffc163560813de507bb5c7e86b46d3118cf2025255913f4ba856e93de00503b5a20d2318dd367cb2c274274c525990275ff5c52fac747fbc6603422499c47c627cbe90ba703b647876ed091011550d6d9d23bf5d006047e03f03375c29758505edc5914fe3e099e15ce03d1179a2e0a0a1413bfe723bb8b51836d5aa8fa8e1089c6a30bb2fd22f7f0576def1a9e9fe7aca7d63b4c30bf69153351166fd34bbc64e79c07f1e9a56c0f2a278d5ca88a7a7dea0a17cd756e9e99d11a186736345bcfb59f82ae07df68daeda4acd49dbc392eed669d8d1bd66f1825a6df98ae47df78baa32c1767563d485f99a518098dd30e93bffabaf9bb3281453e8a88d6ca8d7e864b6d74d32a1f96b9b42b332baa194bd9e4cad61a8d78070a65915782b6c9c6f359ef7ea750a9939ae6f3e9ed611daeadb1683b53ec6ee66b7d72cc1f3ad9d7e81cad8e4a0ba01e1b0176db1f187b1f5e5e43a6605b4e2a26cb2fe1a744a25664b58b11ae9f50bdb577f5fbffb344b8e08b4101bd62dbf0b7b3c346e494ccdc92905133989794aa2bf2a35085d57b7a186852ea4ed97faeb662c30ac49649fea2e0255cd668db88efa9a36db380b5729647f6b05515cf11b01fda98a68a586012196f6f3da9e24ce56d410dfa94b1392f195a016e892871b777388cd3b45b14d871f0a527653b602784afe7d94774ea363bed29683501263f171f50147e951c7e549ac2b462e07b6ce3cf2e797d7e5c268e5960a9ba4edcb5ff6697bc4af24ddf00fa5f18a4cb6e35cd5904cc009176d74b9fffe69a84520f7e8e500fdb4209400189300339f90bd022680e1dad84de68a5375abed73dd7c10bf346157f0bd4ef06555da8608c50c4b6030f8ae3f190be4ceb5bf2c8a147942a33984cc7c99ed54bce685b86c9bdab4f99e8a563935d024e38e0d35169ed13b9f1024461eac4e67d72419d2f40b89a8f8483fc702287e2461da740332c6ad765ea4a1a23b24368b89df03269f96663720feacb13a06ed08b39711f80869927e35fa643132e77ff17fa05412f2f25b8488c9a31f2589b19f511789773912650dd4219b28a32c1a14271d9d8246c80890149ada6c6ab1cbce8446cc4cdb142edb17940bb1d81389e07ca73cbd7d6c41a397a2dacb18edde2236c11e802c894a88d0894900214cf5d40b05713e5a21ef979cb3629a1cfce1529a3c5df49eae6bd8f29ec361a25df2b9966d18a47733253ae3a7996bb1b18e5d8d5d9fd60a42d823e71128bac2fb9d852097cb7e1ee6356d98346875a77b277f5e44bfd09ba290aa7bdfabff2b167f286d07244c66fbc392c115bc912a5b9bef3e4a0c6268650df429e4d2d129b497c16ce6c150b71834359414a85ddf019e61292fec8168c0333b7cdea824fe667513c0539357bbc826d99a7ff210d4e9a80727216ee1884022c02a61d6ed393e97bf343d5f64a34fd1681d6ee61523d80d7fde8716f09c98fed94bfdc0f0893414f531b7f9b736aa9f53ec3906ae4226a824fec8cb31f6ca76ddee40bb14dfa6a82a8da238dc54f9212e821ae3bfc153ccc53d570d2eed404b86a63dc10b964b8a53008f3dd10a5f8e009a72e59d7fec44264f0276cb854e3c571a8ba3bca15daa7e8f594178922c31a98cd636a8542d2491f804202f93bcd84da8adc8adfe7d818e9ecb04c85e36b46c7a8566670132b183b21c47538d8d9d893b053653c5aef68edcc85f1a2c83525c1f9d87d4c38448bcb6ec2fee6934e83d4cee6aee5c10043f91d88409077e73ce2d9479156f20c8c5246c134491b2029610c0c3e0deea6a58c5d2176527daa5343d145cba746f941eadf242b4d743932202972720fe60ccf981178bd610b7d843493246b6dc03465e1984738cc2209b5abb02b7c26be70a5ad04c34c21fbf246058ecb3f8bb8cbef08106a6987f7d5974abdb7fe98f070cad97cd9a889d85ad0f3cda1f1fb95b951f5469d7ab62e491ba6599921472c1f348aa3f9a0abc9860238c782c69687f33fdb866b342048a7aed8007531efc7a192ae81c26e3071bcde0bab5e67ea9a89baa96a19ced90febc368cedcc8577938d17af5060d8c829f237a286c403906abc93d8d496abe67e58178ebde8609f87eab1a347067e18a570d3757b99914a8d4dbbc1fd7bcdbf11409d8165bd47295c77eaf59e0e06ccbd0cf328a61ab06cc88e7a4296c07c00c8ea2223a2fe6438abcc1ec159d11bbf92b47defed48852fff48ee5fbab0268a6b1bbcae62a22f9036b4473c7d88b9ee942e440d71c0431a1705a692ed007026c34596a0c17a244eb2c73331d173c367b573aa0d89e861c2b72c42ccb8a4f2b67aec9294c67e93c063e67c6f064673bc254c0e292ac10abe0021c1c3575994404b8b4383e6327c258da3a07338059f9b18326e3ceab24fe6e410f4844c4b323443f214b57ab92c4cd042c8bfff0fa0d8ecb95743af5cd107bdf4f7c7bddb6e6ce4148aa6c5ba2d4c60160bacb87c579dd68e67b7857b5174048a9a66e61850bfff4345a7104b048f90702474d59284183afbf8339cf87f715c1bee60a0c26a1a38ff991323058b2d366b8464828038ccff4905a949a923f33e15181efcebffef61328e84ba59730930536c88d9024d242cda6fafa10a537a93da424c15f4c4aeb432023cd544a702ffbc7e7b6589b222b6923fe415de960a9c016eec4a78dd9bbf69864481bc72c2dc6e895bd872e27a407488ef9336b46eaf4bb3de0bad0f2398f16cf5898c2f0738e1aa48da082cff4233c611b361bd8d0c1d7800ce7c9a87f6e0746cb95590d9deafc813f8d814a38195e26814843c90c3800918839ed2605e4664815d17498c74f8eaddb3e186aa0710a7bdfd53e40d730e1e2430873b660d237cc93da60183168997f5d5e85eba475883b22650f6af52157d71f7c9083a95b65546953943423807c76f6594f5fb072b0993aaaff3dcb931596a26dfcffeb3f941010d00d8a6e6a8db461def2116f9e422e6a4c2d4a58e178809d5cb2e07a54f803eb786860b0a8399992636d22fae2d9d7a824ff37dafd971453b13e897744830f163c5e47c06336a85f392044e2f8a204243cc1e2fc566f9b4c1f7d473d21986d68a69a963d3f3bd76378a8c2475cf7165d9c949d19d44873d96592d0f7c4ec0a9c58ca838e662646de8ff518dfa314349420ec8b5ff8a6bd320f8655934667cc3c0fb675b9ef87cab5f66dd227930db19f470e1c0cc2f006820ea2610046ec9d1cf50c141b0fcf8a78ccee62fa05a84335f1038a3940fb63a06394521d030ad33f8526464d87bb68e6f1aa8c7241c67610211d709fa978eaa3fa71089601526ca39bc6d89f2e8f9424c27a49e56c541e65726ac0c1053d49d00ff181ee0b3525a24f049d65c8d32f25ff62a2643dac784086a07562a2094d4501028cb508f79e3d6d774302576a183d78202615c2af4e95ad97471c664e4bd3e2989004d92a85cba51a46d0ebe1577d9c27eb333c12f104da181f392774085f66ae234b2afef39b6b25ee268e3a291262ae179bd5d86c0c7b0b8db6bd65a83874c593172b174e459427b7ad52ab9d9edad61c195c3dcc6979e7b856afafed5609519461163860864776621a5e2f75c6fe7f6a3509ade14c1e4bbe960d33bbcdd757e8320f77fae97fd4d61507bbfdcd53ca4f6fd50ac2597645e4302aa9dd061fbde1a7d6431fe82ff4d8249e9a63eefcdcd85d9eb8f0f47c20ef56ca5e553369d62d52fa9c480bc5d880dda63784e831a82d6acee62e200444505db0ce182684d085f25d9d6a0d555dbea9743af3cd3b0339c1e8051ae53244adf977402c2d144ed84a7723d901aed6f542fee64ebef4b8999f791d292e8799ad7115816f8463e26f2175712ff2c67c61d206487feab8442f794a459bba78350ceeefb467082de3ac0aebf147a4ff85af8a27a6c05ba1dc363de333218bbca30e6fa72fcd843f0a3618baa4e06fb57407ee279d0e77d90bc16d0b619a75b1901256f8dbf99e7a6dfa9558819617979c263362fbd9728192897d658a61c984d29adaf747c70f2bdf420a094dc62d818b29b204a0e5d274deb731314655ee12fed4c1f6aee5976cd75797e9734f824dba15fb9f5318f5a19c4d8b47bba0987654f9757e35842010b6f01d85bd3313768b1e0b730751ab5cfc5e0c75d09720ba9bb57721ec8d887ea2e2e85324a79c70d545cccb55230f0e10f383bb2fb05dd2beaa76b9357b69c72f7b83e2e424063a69ecec0783aede59e361a682007f62dbe7eec987f3d8b1061c6d3517e752c122dd8b5c1152642e7da2fd235d51fd23bbbaf60add5ce87f90c616f48e1bf0522df44bd1f76f0b59868279a7505080a49b8225e5df5a8a5d0d4ed40cad45be1a9cc22641545f28a7ccd22e82d6e80d6cdc47dbee507e8c94711d7a325b95837535cbe0aa3f510e5f6542ac17dac780df995157ae6963b8681d451086d7db885b0b33e8f0e96a7207db0f1036e2fa86c6ad92a38b3c57b5781473001d6b2ce9ed135575efe8f2f0ffc7906f99cff6d302f28d9f6206c8ed5c7571a6f3bc51990af9a1f5d9a975b2d61b4d83a692be0030e1daa890eaffd742b9c396a53af5ee49be575bb4514d5d34dd1990d79ac1affe1a02eceb2a3459a5eaca0a5a5b4c1451fe2a852c99baeb8fc2f6e8513e993c0c576b6fa83fe997010922fb6900136100c4c7bb6f5f33635e3e83659305870376d22123cf5c139ac4ab4aba0d0cc320496bb2a8f39e12ee9f011ca635abaea1873c4d01705a4d391213960bf7948e2b8981dc61dae69a02f1565ab2b3409118f62e6a7e8cf31bd789dff884ad56f","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
