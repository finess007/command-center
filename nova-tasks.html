<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e7f703e1a5fcad04194c2b7b817aa0a5619fca20ad5002a19dfc51fe5894cb5d06faaa2823fe0fa2c8c3a86e390fdaa4a2813abdc0aa912f71ba13345304945aad82e2fd53a91140e480c5214c371e2951c2832361afb8d1283895371e4e11d234e6e48a519b2fc0e9e8d7c26f535aa834e628718033917d412e7b21f94769a4f14baae522f3b531cbae889771bb00b4809c2add9b48240918a28917554da1f52f5e678a5a32fa7da1a89d4308af4f26e4f2eefb673ddb70d6ec6a44058859f7768f7e6ef0c6d0c2d244e61321f4216e7b7ec0587f81e81137ac597059ad8365faa0d23b0ca0eb2254400fff7fb3b0035b2f4e1e97fb1af00467772939a2332cc7f41ef8d9c8108e38089cae3e4148d29de731961c32f8f6f653c827cb1c7396acdfa4f9756e9f0baedd6e437dce214c0564bfdb7a5653af3b6ba2804063f9b524a9286292f46d0f0ca804a368950eab36533c08f2217c297eaa15629073111aec7b86449182259e09433c5c0641b250b95b5ac983935688d485207ff35fc907d50071499171406e51dcedf8e92137b894cc12cd4f24301847aa28a4c9cd6f6a0ba994d7923c0016110985c210b11c3720ed49d214439bca8e87d2308dc9a5fa7f4a0c2e6edcc3eb9a43cb7e3aca64b9b24aa0417f51204cea27521b7b89f151a5f5f7d1b1bed18a221aafae1b6135633d141373cb070891a724ee14ed5c48a18b328df17e241dedb2c5fe9f52fe7a0b013f38809ae1528ad1647e0aa1e8a36699d1dcd7d24bdfb023a08818d3f68bbab8f67930988c503beade0d85348ea4ac5573df409d7d740955c97ea55856a0c7c7ab2337f6ed40319afd092e451e822d6125cda37bdf0ac67de6e5a87bc268e9122201dc2df1d22140fdf2e3be574aa9cfbc9ea44327b546ac310198f750d445a6b19eec954e789feeaf1dc45add05600f9b4a80eb0166db1fe55c7bcf7f40118e78aa44e2c0356c4b168e044826edcc0e0b8326b06bf18f152a354a2fd3cf891c35577b6f1b7239fb0ef9791f13958c28ad8f9e823449dec5e71ca3f5a0f11e367eedc617593864272bae6f2e7c7848b350f40bdb98d9167ff033a5cbace84038efe9d432ddb31c61dc5d99acd2252f9c1d66d0afdbf3f0943bece4f9fd7056a40ddddc7a226b4222f83da72b13077e961e53faa25466b8e27573a1c36faff6461f7e5b9c6d8ce210d33111b40b9ba786846aa9d22b9c63ddfbf48af3fd9394b85876cef44293e061fe9e4f4d752b86f143af7ae60a633f086ca8f1ed0edb8bf081f7d22771ab17765b37e35b51adbee93fcde22c0ec98a5a3e498683e74809d11d95a5f29a441d66a1f87540cca8516c8718966019d976fb86c56ce80729b2461fa996ab120ccdf20c463ee0c5372179bfd88ae42e72c9cf8fc18d01f7c7668bde68c73c20f4ddd8deb4c0e300b38271cf0d5665b102b79db313b04e7bddc26793edcb42b5f6ccaa0c94db9d871d7340d2021e459d37f72c11450b0b70ac27422d88800177295cb45f269d9e6d4addd9a9e23736101145387c34ffd05dfe2218847d7666541dbe3a91f10b1ccb23f4414b466be1c1ae3d3cbf331f6e50c1795f0b1ce59c4617aef610abdd75edbf799e1b7cff79b4e840b73879a20cee5ad386da647b0751e578767f3d43574456a55c8112b907b00dd7ed117f4f35b6aa12ba0ddb210d700752973e5e76585399ddfd5118d5c677ba93c8dcd71afcab48775cc431bc6491f68ee9d845968a3545a24fa8da651788bcd512885d38f71a792f2abbefe2a2b5dc755ca4dc33422634f5e75e33a2980c4c16428d95922f14ef79be1990acf46e8a6d07e5c3ea4acc224253748fcb11fbed9d4d9d74d3d7063d2661b73198d8179f14511f126e65fc2a99c8f582d8c00fe5f24f826c1bd1debe081172206cab5fcc772b4b079313a2db660aa43a152bc2d27879251cd88899a3569d94d0f88ff43459479c0723c7254344ada6a474140163f72b4d2b052fff5ef7875f7279973f09deb80ae0202eac1838ff954958926cfbf48ba2812a1a2429a106edbb9481876241a2b8afbea503632c0629cf30c59ea6820db054352a11620b613b848a301d94d4fce45ce7b2e681b02dc4947bd9129e12e601ebb2efdf7ab4d2cf30dfa3503c42ddbe957aa82cd522e9bcf9a1e6b2e2c67edad71852eac774bb33a82dbb1d9598cd1aa13d4f1a8e5ac186c7c290a513b42fc85081860d7489b26e0ca3399e255d42c5697dabb9e0e693c59f78111d7dced7a7a32cf8f5d23e252312215ebf69e927088cdbb450bc5ccc51fc74699ba70349b09454353f2c697a83102da6e38a523e0c34e3f2a3a4933342d572865438fc2f29f2db0f04d033035e33f7a23937836b3e665054a9fd0c7fa263f25c597f54fdac254abee51e387d5df1909f2cf92c1bf8241bd22b525f1eef16c5c08b246847f89c45d280c99bbe2e71166a24c9349398f9631dd9d0f991d80099f38600019c8bb3612ae5b961df5e955aad39fb03a4d7ce572b363500758c5772ac516d04006e90edee52217f435ac430ab2647b849726b609d577a589c2c977c7c22b5dd922c1141deb43955f3241ab55a5469a880d8dadb4fab698a37483fad4cf1aad0d6ac26f22bd35ed10aea29d8ca438fb80911f16451ff2f29b7db631a0300c5d653b422bdd9f6696a023ce8548ebcf5fb635fea59e33d50c41762e45e026b18ddf6a2abd1bb30896a2b74a3928543d21f08852133e22d1c34c80321f9ffe8cbd53dfbfc970241897f0106e837c80a6e1f9b7bda979a37a64ea0cb642d3565c46087cf0d58190a0f73f72945dedba5db65c4b46caf40598085835aaaf1836f59547eb1e0ac62ff0a771559b2cca59fb330c1456fa502ab9cfebe25560f8b2c3815d7f3e129a75765a7fefd0737f89a186b4a346283a4719327dcc6b3088d106a0b977fda4c884cc4e33ca8c9ef83f239fcf57083b45647bb5fdcde3e606a771de3d7aba18ec6a0d2cd302eaf3fa6fcc589e6ab2c069c6957f554d1a6663186e2ee7c59fda2409cba1e928b5ae01009073a991ab984f6d0d9e79344ef901545b76fa4cfead291ff3ac55da05dc306209c22c62cb8d46e4c5e4cb09bec0c61fea0a7f6c636975b3ce183a4e09298140fb7ba7ded12449db2a3584503069f73e2ecdb316225796d96774e1219e39ec840d4e4defcc836fef10a409e712d750d4daa8a2827872f2b1642b02cff0b8df495bd177e506c1f7106e2f1f313d7703018c2316d7bc9e72dbf26f76ccb9fe9e55d43580897b7cdeeb88f1867fe1c6a62364809049ce57696c1da90d7e481705b60bc362ad293243c9e01e431c896965499fcb5a02956a2d7e607ab4f2349c494dcb62cb86fe4f18cecf1ea807f5bdc58dd634f0f494bca34e52616235826efef0276e56770b3d353d271120a2e772902608e14de45d6548f374be296e9a4399181f3e532685ac3c13de55e8bd24e48a22d35c478b4700a8a322a2a1aa7088df03969f40260fb1e2078c999314e3b204608b429ad4d86a36fee97fa4d22a6b57668d55c9a1b7148594e2ae7767e2f7e70a01f209d5caaa7511343dbc6b2a06be4199e63706ae7f1e81c93f887aa62cdfa52ca6edac74cd7368673803cde42e8d6cdd8c903039861dc7b80bd4aea596b982a84b34ebfae25460022e0306875c3d4522f0fe2dc9fbb97a7d19ed624cbc8eb53f65bcc2ebb8d36f5ed5b4d8324af9ca6a9aecaa32653d74a277acbd759da3bba38a9d90a76996e3a1228fd05bbbdf7228c05092651fb06688b9d31ded00ad43adfae98f8e920664e970c1f705eb8e4b9e18df3c058b0ff20e06500db1413c8fe7758c60fa651e658d1f5473d0dd7df92953ea6fe24498c93c370de66376e57532b128228e9358ff56812c1a5dc414f25b79e7f7026eeaa090189da22cebbd65e96d77e6c117dacc5217e967896871d488463f2fe19433f205b5de3e641fb7bc27a0efcf4cc5d71635102c9df8632f7edd474c3ade48cdea2eea2a76e783373b15c2caaedb3e8a32abaf41e150c3695b7686f66f7c82bf5d7732ed5db83a58bd2d0dc95a8d87161085a6ce5d9aecc24bec71561325a4ade6f73eedef65fa0de51d72311d0fb25ad7d735e5793e014c3ddc0bd801043b3b3c9181d5e21d1c0ef23636a738cfc318c549417b06b1be9546cb90b14bc8777826b46f2e0b413cf8dcdcd6270fbef7a05df7a44e42df89238597df1c96c2b179e1f9cf86a24840e0f44c461270940d30b5695c4a23d9d2fd5d16dac3103e023ba179ce21f30051e20ce2a0a9607a4bfacde6e875e490516d849200dfb2696f79de16275ff171ba3f2f344ab1ec32592eccf254d24330f57549b3a714a3f4ef915d9f67eadccc3fe157c27a00bd488394b6fa0a3ab4eb583f70b021aa427a0fb10099b8f6e8886fd67bf91064d5a92f337183dc0a846ec832598c70391220c22044db23527b40640537719e86b38ff8cc2602b2a1ac4ef7d3551db0dd2db4bc65f229feae07efeedf2ba167403bcbfb0f92f2ce845303b843b39b46219701a1e8fec6f2f999bcd8905f043eadb391ac7f57763e076fa5fb22054bc3cf6ad1a703a46eb9910cce5fe4169105788a788842d5f4faefd1138f0fcd56712f0a78245ee31fb2f0a1f31ec63f7c78f0b90e835644d941ee8805d06d26e30cccf0ff55181a30f791932b748fdb110e3244f2abba96e2c99f7fe103baf12280ba30758d2e0415b2a55ba6cb54e5c480e9f2150430316f7fb8d683dc98d70463fdac4439a660d00e59cd438966194101ce0d8ac8a6c0ba5bd3febd5e436b5f5ca74641019b7b23d8599a69701b6c5a920da06c8660a9ca2b51c5592601c48d4acf518acb2397ab3eb5c5ad1e30e8e84fb8ce2eec5090cb2ed356729dd8657c69f2f87ebbc52823b63923df3a1d378afe1d704de37f49ccf2b63fd29d22d5912922b369c05b6df8989c26b0c884e886906c761e4c5928c96aba59caf0443bc31d2338c7fc755eeb69b4002cc40290d7e742764b0739fc99cb22c1101173f734691bc5b98e370f7b8ef15ec2c00daeb3826d082f9cfd299f2815da0ad951c87d2729cddb87809285151642cd0bafdb53a2404b14feda5eeabb42568de0445cefbe2ac0b36a6fd893c9df0e6f853d53af9e4d3724650806341c5c1d13456fb8821fd668cfb56f5d5e0d492cd821c2f5c1f83675cffd1bdc6ffe1a04107dc757d9328d579a953f5f2581ef5e283af1e787dece83d9cd48752a169b5dc5ee5d38610f786a85fdf3d9c648d39f551ba1a067d629f2b304693e2ee3bd76a1456a6182418105ea394648ada5569bc7e90fb4fb64a3c96b4ec444051e32183d44e328cf3dc382997fb91a42443b06872464434211ca87d96718c025952ae092383985182ba6665f5fef746c5bc198e4a40771a793f986ef9788624cde5f20078643e77c2d806e1effa961f49e67c12e4cd20ba79cd104d2d768651bd22db27902727d9f4546a4fe4ee1f14f7fd019e328e0ff9284086fcdd45e714f8ba668476d297ba5182fab53598ee8b2314ed2e009075dfe568ce5db5d61d5db869bb5ecb88a8a314333732809fb7e46164480964d9aae2a5f992804ee9e0a60718fc8fc990658b95539cc39242074f9b081ee26d01327a3dd8d873d254990df65690afce3614b0009d204432ef69e66d59f60d7ca0a8cd61c6d15321c59c0e06e2732c4ba671508ae1e3c4fccbf9f2015892bd66c59d8ceb899d58b4378ba91ec25ccc4de11dfbc9d8fa7aa1dc8d9668f2cb66d454db8248089894a1e3d599c361e7f6952d99212c0526bdc853ce22ab3183d44f749d65f4baca0c139a79270013b6ad70ac7860b90cb8c9b77e4c548cfb45094aec2fd1c708f3dd7753b7689c08c21555823263cc97bf6ebe3eca0939f663aaa6a2cd36487115bf30dbb031c8293e6c14fba9f55570eaaa21a9f2b36870578dda3645265ad92e12377fa29c2f5de666dbbea00845edde25fff0359b4f6822de92c38623ff2b53304c5e8342c9f7dced48e4036719c521ef951b0f7d3a02a2bc49cc62e161b0475ea9773fa3caba0216d15086b403a83385d04e19fc797d27bb7e6ccb55111f0971e8f79609f52981ea1763cffb2d05f09667d05b792218b721f9373d1aeadbecb9dfcf2e7328b770f90e54cb79febf4ac1779d4d857c31dbb58ad45d03a584a099d1aaf7f4406023d0dfb3be480671a02d8b6fffb2496dc719d94b95b079267dccf2306ccba7aa722a1191139be68f45ef55c892507b53b94b0ea6a18239b9abbf5b1e31f09c21a2a69eb2ad0a6ee95afb0f78065133cdab930d3ffcd796b4c134054e936612a8af344ffe493fec872f49297d4dad33e22755bf9c51edcb06f438f49bc54864ed2fbe2e1e749e88e240676fd7f99763d7314d520d9ec48c459ffcf99d0ca7a38396f5bbe6221801b0c665881ae065b8b47052bccd29db48ff06a3719f7966d3f48f41df2b1f6457ecaee187cc82e086b33ab7115a94a3d96667fb65e53da386ad7dbb3fef1c02b91010170e2e7a41006ff66fef0b73c3473c4d1ffe3d88bede05fb7d8bbcef5f75e39e16e23f100be03a4b069a00ce5152a4d03f0b70e1d47e8cc7ad2e3fee3a5f4f73e10537df7533e1d9d7419ce79d67b781b7b17fef8cea4e4d9af1ab6a9d1adba3a882c6d38134d6ca01d19d1b26178f6be14f328f9d009bf459c5ad8c17e0dd522694b89e1b02227ae54cf3834de268a61b75b7429db773e1a4fada1c436da25cf4254706d084f85ff0a12d14fe67507b3c82329f46afd032e01dc024d5f8ad70b7787e2b77610d5118648776d13777957effa91fab7f62ffce726977ba916302d606466b1bb9621c03ba9f751f15f673bafd2ba34c0da589dbf80be65200a52f036e521c1258ad76ecb0235e7bafadef5c9d06665ecf2edb7339ab57c869e3d47d2e8627e4ba07d71b1ec6e297b3d5c7ed80b2f188360f40e8641aea74a822989595f1eb818ea5f3da8371f0df34ea9d62ae3fefe65b279e2932bb2e4cf99a6c0131c82acaaa3238b480e1420699a705613df493905dcaa1471bd070472b27a07790ade171f923fd0ff6a9f385a8600e5a1327d9e6fd36df3e3fc0b87e14904ba273bba531ec477a7b33606cc5d9fb7434f4af93527a8da217f8fa31bde86c432f5c35e40a9bae6df0e7acf81d4ef66364e2678be8a52832487ec512482255c86d4dedfb721775084966fc51ebb74599a40d0c5477b5fbe5fd699aa75eb8de7d949ab636d83998177c151d3caefc684a144d1f504f27ed2c1788acf7d52589e46571edc880ff274c26f2f5cc9dcfd39e8135b54f25bd18f6a0a9ee874430e409b5818ba5a561f8c7509b8e89ef64fa12c9e3753f0f6ac9faaba3ad13404337ee16342f3349ab599eee592ec57f1c00a414b77b7e51349e5b2291f4053561a1630c0de6a3443fc0aa53f8b944ae02e7f97d1e2e4ab317f6950f07f9c0fbca76ce8e91ea81b08a5f185eeac5369b020b03d5387e1546cd8ef1541aea743048d391f933ef975449709a925fa2a204f2181a3633139b54f6af2ef4d2796ea92117ac24bdd5a6192ea0539762a2b7c5c0a9521b859bb18fa01bb6605e43a9c59d03e921e7a08c592258e88024663d2c6142ae744a9d634d88d6e1d55cdb0ef404947ec0725f23a4ba02a4f8379619ac22b26e164d54411658f3c25b0e4154586e2c879bfc30b1a837ebf4e4f80805febb8b0a8f35708730328a5ebf6bdef4b53cd04c5109d4fbd5c9e0512721c0c19a31cb575a09a053fe9e092ab514a7b6f002a92a159c9dad8b975aee405f62ce5bef25deb2cc76f191c027b10f01203cb668459ee6f42eee558cb7d3b5a3fb6e447c96bc20f9f5c027f1b3a7c21770baeb8563b2b926235dd0cd5f2bd3076ee99ec417632f657f3ba0bff4627185146cdbb8eb5ecb8463728911b19bc15e1cd6c1ac581e0b35725eb98f4a9c4851f7f2c87d5674c5f969cfec6e5952a9b033b13d27d4af0b23a0f7f0ea8bef0664a17b46f1b154c102d68b6491e76ad7299413914825e54551b9be836f93b19f4e752a09afd29848bceb76ee43ddfb2cfffa85e6b1b67456af45c65ebde02bc9b5e82280870f4785b4d8ee7506c5c91ec6571025910fce576d826fc46d5fa85dd2073e53892aee8431fbdfb88a9624a7f01331fa8a5f971d1df333cbe6c95b1fdbb4bb01b65a973ed9ee2897132604870892ece44992f5f2a5b65db84cf3b3b15ba12b6f760347675cbb4136f9f7c4c62b6c5acf392fa6e7fc85531a8f37b4b2a46a20dcb9d91bb5999ecfb77a840ef79c39e512cd46346b5345e63c65654e813dc022645b531fa461169c0680908de58eec2be8a6c637d2a111f5139642ef437569d6dd8ac8bf7593e19144b1a86dc5e05822f840809c975fa0e236786f288760ac8155a4f646928448a0595d24eb6c75df4f796b1aa2ce0bbdcff05b9e9dadd0710f74f87f15af281fe64d7b51060d93916d171464f1876b7efe263843159d8b08c6a00320bad5b6deedb0ccebb05e7a2f8d0e9072b09429cb8b84404be48aab4cb4bb093212d25eb4ba2f067de6ef2523d79f3ab359232c81de9b6d782079619b360a3c3feb97548eba5f5d4fe89ef7772acf7169effce66e9e39461ce73333562cd97e33ad2dc0674100467ae9a3859dd8bc6e2ca9beaec3ec13bc0db02f25421d3e805a107d1eb059f93efd2701dae24e068175ee113f2995739c0d00f6c5cf3799023dad16da6ab6258a5c68d8a3999d00a0664fd9b9e20ae144e1f96bbff791b74e9c4cb92f7da037e67cd7194872b6ca24cbe3f91438fab1afea1e40d018d47c3cb95f16d12478865f163514aa7e875b3fc6e46df5944cb65e3c3ccdb4fc9c373b1960c2385d6a4f6ab2b0c1f12198aa93b0e2943b990545be3815f5127ec907b7ae6a2bd6157e73e29fd676253ffe66cabf3424e4dd56ed4c801fdfeb58e14d6fbcef298f9c13754ac79621320cb82c32598c2213bf247bc1fe5e90a37017c3c83a663a7b06b004e00de34e7bfc8f935d607f40ac823c99f0eabd1f507d4cde0f0f447604c94556a8807d87e56c3c38a2dd5106510b8eba247d7538f5917ac388dcf673657c94b757428afe015b8d68b4e035ab294c8d3d7198ec33a13c1e3852c600da3ff8b11901b76ad3a0d64fe4bb23c407f29cf09d3126cd2a4df67953b0aa5b6d4264c9c7b3f55cce2a9dabb1362732deba4b226870353d6ceb1b16854facc4d3ea83fc578fc0a9620cfde19a480361aeb24e352b95767d119540dd831199ca21c8c2b00d378a9dd1f94cb5e1cab39cbc41f50788b5cf84fa3689ea36b52a4dd7c80c2dc240ae0a640aaee4759687f2b9d6876a90e39edeffb4cc525c8404dfc913ec7313a1310dfcc1e1f4b7d7d7168c4865039c2080a8995576207af98a75b62c6c0c4f3a42220024baa67a533e2e874af18c6fb65d55c6085020935e23d5841add7dd121e1d8e9683735bb97f89eed1b7873c84ceae0a0be482222324bf670881b6d0469de0539d076efdc36c39875ee6ad50ebf3c35116a944c3417f5ac3291b49a12367bd7e2aa19538bec68cd530bd734e103dbd042c05445294e56f99fe42d4fa8c0cc1e0867fbdecf46df5d84c4955aba258779dcfb9b38c078a2e91632caa1b2178d3ebf1ef25a6660fa8d783926ae154485bebfc003e467b49d0722eb715f763680a1e05fa57ea20b0252b4cad1791dcd8514612d0c87721a4c38f635d42dd2d26519178374dde9699265ac3d898fb42fcc40abdfd712b162402447313c732919fad59a212a9c60f1974d80d85deb5e117633894c73585a45c2844e677fc54270756529e78b01376799059e9ebac09a442c21e7b6843c67a1984d94f2cf14c5a26e4e91b6b62e1bf39c42284f54e278ee9310d64dbfbb7e42f3365cd5603c7485dd9e3dfc810f0a95ace72fa4eac085f7b4c97f970886544cb8fae2e4110d29944ff2e105eb0c446abb29385a4841b093bc5d484b99ac7146f4817b11d7664d7a32ebc6c1075d5a818d738f7761943807e7e6d4e93b7c7729c2c780cfe90d4d17991e7514dcd0e639a5a7fa043463d6a86f695ae63617cae07ae9f191b38977ac74adf8a5b213d6763bd92073699564b42c5b13b9e484a31f8274eccd79a2fcc42ded1b2093eb4132bf99d139cba0cf020a5531c369a3869a5063b68e379fab7bb2deee14f3cc359e8b7381e6f272c2552ff5a428e326c41df42858b655be1eb56e6271fb412526e704bf36ec2a8dc578a9f604f2086113a4edf3fd21e6d9661d8dc4b3c08614a748e32edb072c7b487fff7259f2087d21ea4cb5308775ddf6a8587370b73affb855781b07dae79a525b608b96863b4269bc007fde66e2ca2e8eed149d97a710adb5d1a34d6893bc4ef8244a181be59ecaa8c19c3e76d66e3221159c2f916eab024a7a1b12e6fa57445603ee9e6e0a78f7253a25f39ea6949b470f1537ce15772e220f6a48aa16cc0213d5c46a2a99c83fc226d1f15d65f5403c63a3ce385298d73abf9782d10b24247d2f0b8324aa1bd525ae0bedd02167252acff10d05845127eeb8302d6f0d5642d46fa39ecea0586c2a241ec70e51d6ae06289467070e1cc44bdb11643d3a19ddb46dddec2ce4ff1ee4b05ef28342774956299ab469d867e27cbc3bf2d178a2fd07ad3e58848938450e5700692887f76899d9cf73a8259250b78a3e1adab1cdb437522d007ab231158173b6e7795629f2fb35914dd49837202be5cb444854df7ab16061563dbce8f89e8598bbc09adbb5bbcfe1281ec46991e9eee4381dd7bc1fe186177295133cb81166c88f48bb80e6e12712fb85afd3c902224fb94e02192cbcd6021044828a8bc049d8136f5b25fddb10e1ad1744061f5f8bcb5811a9a97033441807a150a8d1506af3d2522f618b8aea2347683bb6f6755d1d3f74cda14bb7ea8969063a4f729bd27f8b0e5e4c94034e2a0aff191d2c865a3b27a2f6a481d751897de4aff9a3d745146ac4c322dfd8b24e1bfbc1fcb4a5644c9f52ef7ae4c2e17eab0abe2cf80417036f983b20cdaa9cfcd8af8c2b1fd528ba142958f02cb10f740e76fd39bc97e51025d961ea3f1282cdac72bd5a13d87709d8c4c4274a921c8c83155d71915682366098461a9c91573c905205eff840a40211e96ea33c1af09460a52fe86505b9ebe4a34aee978bf8c9938f35d82d25a3c48f03d43392089a4ee1adca9ef9aaaaaa94fb7987fefdabd4f8a689361829ae9c4b1e96caee136e6e70264a9d0c8c0f14a6a45d8a8b8024d6bf786a53fc4e4b5b3c05a830f3be6773d6c6a3fd34db23463dc16f0491234c0475cc3ab26e16e356dc91c38e1190d2ca6f87190c3b611f07e64d522632b3f9d8b4bbd09c00a7b77e8110d69524aaa647fc7132d8ab3d64bbe5ee1b7e7228d46d9c883a8789ce7346cc7328b11e1d08fe5ae6d70c88dad7cb260a64c13dc417dea3bbf211baca0324f0f12e7a7c51a3df5460d19d996b6283e74e20b7fe3e68c2662ad4a4ecc15a7e32ab3999823628940e21cc0ca04bf29f7ff75a473452b4dc3f091e09e121cad99467fbb5a8dbf789f72a50cec5ca21db099a9adc44cf3d4fc10f2c65e35acb243a5dd39b2acbab4520caf1ef078a7220fb9e1d0a0aaef0bcf728300f9a0ab4585822f4e485d082704cd375b0f5cb943d8a622f40128d68f012e887a52bf56cfc28d5b3af44b078fdb1a13cd62d46e52dc7932c47614671a1bebbe75dae0e0ba9b129a149b1814615e4797a02b4fc8c7c5d3de268af9a1a9a3524b0d0e4bacd4376d37ecca54bb81a8f40c16fd0e72efee273da4ae42b6efab785ae723b46e097d319595aba29646a94b27d9fab13617309616b3058bf7181435d7afad6110891ab5ce4c21a84ec779be63cc272994ab6c5c1f6bb8448799955d31cc56265aabe98ad0b83f0432e112064a600b36f7c02e478ef8735bb7bfea26f0b6ccc11c0b792e898d9c3cb6cc2b9dea731c778baa3329f143f51e083373a7b13fdd011da1a7660d9f2d56543f9d7657f5d09ec70384d049471874576cd26bb7fe7684d1a544a2b41de37c416c45bebc3b5a1285f0609c8d0ae806a510c2275a0aa6f487e6ea3475962913aa4997b5c062d520d5d4173b813d7d5a2aa8bbc4901dd87d8a53947e8dbaf18ba50b652e2a68bab463fd6f77bc60fedf362f819f9e9e91ebe73da28ad98258cfd5a1c105785b04f85aa501a1f5b9e2b3a816276fc18e88e6ed99f58b25bacf1ea46e33a8a81c652b4cb58c05c82fb6dd604d1df15d1f0d04b28bc125ac2de6a25af9068a5fd8ec63a834e3882a9772ad7c3f6a3dee9919d6373e8ed05d03bfc5fe5f56e7f8929826f3bc76f46e23c9b5f11cf8bef06004dc60eecf53a8b51bc923628611285d0f9e950dd7f17689c2ebb2d03c6321a82775337b63aaa05f740a45374e7525013ecb287c9dec5e334079f0d871538efe8ce7e0928f0334473d57a3e952f6c247e7228e187b6181c8cdd818492462d4e1c818218bafe22251bae4f44511c459d85997a0b974c9e05e09dcb6a2968c3ee64683fa35a075e4d78170961956a08c21f15294bc323e84ef1b05dabad75eed75c7eabe1609c8f5d95b4f16771f6c47c7d901e49b076b71a1d6ba871fd83f0aba04cb58255bb6b592ae7ddb2c84aaeb50dba57d601ba3082d276e9517fc8d40cc6abed436c7e34ba1815a5794292daf317caa649344c6d13f31bb47653d6c9822f8e2fe5219dcccd17a0510592ace3cf5c2f3bbc515648559b28d3652e93dd0aea6ce319f266d80b7f08aafca37fc42d3efa4e59748707fa48fbd3c24bb8a7dcc451ca0d2ac9a57c3281f206f79c67a795ca7cda6811d13bb7fc549f8128083a8f262c00b404e76a62d901d48fe3b6d82dac335a7bb6553945cff913734045ba89a09dcf60ff7d7cc7ad4c6f4679e9c3541cc666f4630c2e61e4bcbb2a66a9fd2623b90330a0706ee5278f18c4054f26b9076920e05542da5ab37a8b128883c4b63e75c9fff2b2da987c38ea249a85a191515252d7542d9f615ec2225da3de0d652af19b4c9f192c2c7b9a987f780f85b876ff80511755c1e8e699519e27d3f9ab3a510e64b2d4fbf16b3f6f6a849f2d8e3425d8b9445faf8a5ed26d690844ff4b3fab1d3eb4c81861780d0d78168d88f02ecc8c0ae67c2ff9e9fce8b344f29b55501c4f930b562c4462d7cab092de44506b02a21894ba901fe062d930bf6811dbc201c8b1a1559176ca76c4abd7cdf1809d0e81e7c0107b461100ecbf18b4df7d3665cae0848bbbb7a11d4827205469dbf27a66a0250e68ddeffdc27901868f0dfffa1d5d942fd8e3ba5ed869b4bd6de024f6675ff7c15e884e61405d9361150202f46681497193e07362978e32247bd56b3427012f883aa704e373d0e9b6efdf294340112c44ae534bf6d5ed26e4e6dda916f1e825630afee44089d09b37217e22465f87132614bf7b8323811ea51975043305ffec7aad7f2c940a664dd91e83816b7b107ea82ef2ef278c8f7eec0ac8cf26ba6f49d6644c078eac3b5d50ce8af5653356d7b9d5b488956746ef81b45d0e441dafd0c759e19ec7f232726b42be5fcdd9fda138981621449fd0c185e3fdfc431599aa48b2f39f63613acd977c3a29901260c0833789039ab1fe97018c84fb7f90fe8fd9fd2de757fc821dee34979fe9f88bb36052ae53191adadb38b5ed5a8cc1825ef9e27b72537c0f176bd028776547f674856a4cf332307648f0463be8cb902120e8e5c6927a0aa670b258b6bf2ce62ad89ba849be7354790823c696afb0b3d44fd125b1f4b6e0849e652f5d2cb0f12a5db7b353a77f45afcc10ae916e710ae6c141f9a23db0a4f2f4c585e80eb39c9939bef56e865fb43630c1783a33178a5d6cb26f8708cc2bf1652bb0669e5c06e4a4e0f94cb05836ef48f7ba80b5dc2a676eb4e88e3b90292f4817062407d16c7c835441c1fda3c577cbac693e2577a58a5c5c72ea0f04761110e87b853d9978f27179f1e8ef25518d026a52dbadd9f02c9e1cd56dc5d1b5257eb3091cf09702480e02fbc96f9888be4cf205f467170917e58966bbffddf4e261b790cdd3010be2287ca3706fd42b62df53e00ce39f29421822cff698fee14726d0f59bda8d497f48ad7e95dfa939077399794bd9db35d02ee5fed0372324ba91a5b9dff9cf4fcfc106c8bb3eb40827abae823d31f1c8fa49584b29e454e927b84d32d03f5a199f35ea6db278b132a025f9ca53b1b3ce25bf9bb601b511846427f40f7d1f45ab1a553d5536d0d55cd05bc08e1592567b19c025c8e2e9ed6243b063533906882d001bd67c6d0b05a1cb63639d9cb54735378b31910d798d5d1cbf3e46727ed3ffbb9bde1697be542eadb9a8c857cc604877cf059de2e0f4f1","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
