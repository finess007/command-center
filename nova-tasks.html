<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b367591d1248cd668ab738b01b379244529abf07ef1f54d68b5e6d00b2124a55bda844bc569a182614989b9e4d00806dc17ec958b156e542510badcd92e72ef54d86bc92f46853681e4eb81077da1fee0370d0ea2d5181e0172ab170fe5c18d351b4ec53dd046d09368e092f0f9be44108ab9be9f6be057242ecb170fcc748d3beae4f30d107ae61a1571f42453fb09015979e29a72038a58ea9ed975b777cb2e73a42437087e6df5e21e92eb6b9156815106e81a6ffdf1912ac9640a809a98084aa3338cd75b1f75105de62460f254dfbca8062ae5de27c21eeffbbadbb4dff2d4ce9c1ab42622859ec729254697223ad3e9347e1ded2c05da43980d336c05678e5b9ffff23d8cc53aa290c5c2ee917bd0df533e0c37c1aeed4380df30083502ea1f9865cf9173914ebb77454310d695796122a3074543306ba522429bc09d86aecda9d9a830b061d58ff00c37d50905947c14ee728bbb583d21f1e7263a2c340e2c84351f6d07c83f685dca285524dbe4d89e2e7c27f31df80fff0030cf12c2979cbc758bb4c17fd838e708ffed601cb2345a91bd53aec0d0cd20fdeaa7e7c617aabbc5937f492a8afe067854232c8ceb11a2b5f9a9d31f52ebe661f0890e5b5b3924201ec5c2636358c70c6c2f450e63ea06c453f07f2cc68b057e07e2d6ccee1bdf2054710ea07639769419607b65cb3cf4e61ecc5ef8699e94d7a3952aa9e088ede0262a61fae8e56bb81f04c89e15f2caab5ada304be9de572ed46453b17d14c18e3e185bed8abe26833f7fd16305a703fb077188356e7dfad50602e6d5f995a22fb965cae3e9ab5055186dd18107c774fd9bf71b0ea3c4670946653185f78d738d1f2479b0525e7b583ccb1a94094c6f8ca3172ca56e5002432d6353e697e2f632aa680b27a78fedf490d3575fee6d246bccff3464f65a9e3dd5f6c1bf4845d88c5def9ef6152525f1bb82c9075bb85f96cbda82a86af051a662a2bd6ca6d108944878a4f80e811db203c09d641fdfbb6bedce3e9fa8a74b0a610d659a505130827d6b4e06ac9b516e1d00e04c425d0cbd0149995bb07ba86649df1b8caa7c175ca5496ed263ec24edfe3797e5a0d14b05acf56bb464ec3307fffda4106ecc1a9924807df5221c876d36deaeeaebce0157c60301efa6c47b69f086a71463ba1ea3ea2bb70a777abad05c0ff69203dbeba432902af1c5e6f67a6214763392cff1c6202a6a5dd8491a1e58f2fcaa4bc8a9dabb524b8a64d9a39d39ee25210d28ff21873d7ffe6fd6acb2c408be14412a747668617d8265672584ae111a95119453fee3e61d0c50c80bc33fa0df010da116aa66b04897c3510205bcecb41b71c5b3d723340b7ff8c491fbcdc58167123bc2fbc5dc8a555c577621e4964cdbdcbeaeac896468a414c464b785785b8e4692c1699cdc0c56c25f3df59687ad9542020571a63fa3a838462a058c825bc889a6dbfebcce952bfa36628dbc1db62f6ae42e42f3a524d5da8d743cba7d84f180e30c8767b4ec0d7f94af0b96d1fa431e659e707a7398828a9f065f7c0e65ef83a6f6dacd5c073188a7d119a7f686fc3dea55c2de7156068b497dfaa2e39efdf6da4ff4e0cee5e1e2783c462a87a0871a75157d8c0c28c386d84560564fd4d5a2087c61d06a61f5dc6ec5cd9a6b4157959ad8ff933870bcd57433309b82bffa610f81dcd0b109da973cba4bd04141c0c29447868d7f2f9fb82329b469fc98a0a19bc6a28e0c748005f6f21ab3dccb086de9a49251862aa913a6a6024f11932f235dcc62489454ddb3fb7484152eea9887056db3c6462cda10cdb309fdb311299ac835265f8cc008f0d1be9af545f5ffc4c8d63ab5a95a6167b037a10e208708a5df018e718c26c61014a0eeba494c711b9e6bedca7ee3184baa4f5b652ebb451292e1a32cc59dbdc796e038265f0e5ba723e362b0acf8a1018493daffcc3f81f15ee4f0a755317d84f2bda0d348b2f873f62097ad221b2e13cd0e95e460afb5981cf477154568f81b2e8a875c09b2e33cae7f4bf0e4e60d61b1553bd1ea671e82c7c80646968e1142c43c9ac194f02fff1bfa45fe762f6a6bfb8061557d3cb9d59b1589e25f1b52b4dc8ac1283b5347b120e6a91bda74c1001b5c3844e1ad7d908d487c166bfacdd1efc07d0d8d87f638fbece4776cd0bbece334cf95884c9f4bf1121559b49f23d3f033563ee587751b7db85438b82999f9156d5cb7886215a6c59e7aff5bfc753a09dcc1a6b2da7ec55c46c703da032b4f15d280a18e04af7e4baa6867a48e277166be703bca81304327248146b695854b1a4e999a4b3565a5e5b274af64d90a8989a31bfaf79a497a9e87eb4aca978a23d8f2075deb7d8fb1c98d51a7a4338d414ff74f13d7906a5518c72646145d17b1736a30810e7cb3cdfb4fe7341d819cad483122cef9df5b0c8aca5ee1d41701227ece592b88534dce5220c9927085b7f013e410a5b7e8da039fa4f71d32f5333210d168cff8e7e92c0e9338716b94356147850cc479c43f88be2cdd3995b308f3b4bfdd33f4f88701d3469b3ff45af74b229438bf0c8343a342b2087b923a037e540bb1c3d55a70ab13845fad1c20ce69f691f1b63fa3f21959a86358f0516931df504747a04468b4fb8d89a8245a750f1d15fb064caf34a34792024b4c9bc21abe728d7fba33f5ca48e483b8c40d5cb0955e6f02613302f5b0a610a8abaa718b232c56cab091be172406607b3db70bb9e268701be19d95e40f59ebfc7c52f116ef3c1f0596a18ee729195e56c996c8e3ec9f4eceb690a231bff9e85d3830bfc574219becc683c6344d188d97c30d9f6878341fbcd05a706facec55aaa20e5da71b8d28e8e37f94ab01c100f5ac885a32ae2dfb63310c7165c9ac4229517798870dfd78c3d64c323c67d423263163fa26a787b1039219c0b2d7a78da6bb909859becd3111eac3fd5c4709965513cdf5b9060877f25098169efb0a366c019b1ffcb0e8eb237ba4b57a09c00714257bb0a11466675c73a6054d96357490b3638d5a9105ee8192cce2f7770b845d373941e77954385df976404212576cb167c15f8b19b559309bf07a374e6d737986c67f85b760897365bbe9abca857d8c7f755d36bc9bb3dfc5dff830f73333730c5820a7cfdff7ad594921cf8ba645654665db547522821c105e4896c660abb4a377a73c893c5991bbf2dc38b8d9e2b0bbb8ae363e176e30868ef0d0bf84c51a28388cf16115745a8b89b9ff8d105cc4ddfeadcd1976bf8dd765a17c93093b4b8d489ee83a9ba761b599495b0496ad7355e8b164335fe35105c8b171666b5d4f8262df4992eed9bbdc695369c664d1bea721184dab260e6f01725edb8a0f71cbe76a74a6120e32406e01ad0d83df1595cfc434cc95db6701d876f806263b81453df8395a893251e3506c4a1e631b157e67a6c41e94fd30200380b42878167fb1d5b005ef6283a270fc58bfa8f24390dd96d206a1ce82a19b81482f487fc2d3d6dc247b367ff51a9165db6dfc99dbaf3645d8732732918b25a5e13c6e689a7820b0aa1b34687ce0e269a4796f3b7975418e8feba000fcf36653d7507ec12f54db7dfc7c738a536c1197e75781e892ac58a9e743662117deb1219c97d40e67d182351becf27b2e6b7581ceb2080cd558d2683200738bac381ac6060866a0e095a642c2396324522a561e29d2b36eb4757a0aab9a183c5226051018ca6a1305fa27419358486d213ddf262c2b39ecaad0bbf13d17d534a7a06c47f3e3fd9ccb98b48ae83b0fecd774bd198abfb9eb417f381b9b0eb1cacfd9d894d66fca6b99e3d373081ab4ecd778831eb2aef31e856baa076815e587e56245400eeef4f0e62c0fcee681d13c914158506deeecb57245d7a47ffa27b47f6ea005267f1a301ea632b8402d92c6ed37ebda8cfd4d78de8557103394231738647f4a259e8d0736e6937e7b438d9592b38e4ca59c5df656d5cd57d988262fcc637f099484e28685d95f1518e5ac76f1a612bb99e509d527b8efc3ddec347cfe42254fa0b41a488e999ac0fd46254614713a43dff54c86d675e2b190a953b53e8973a7b0a721f4a75ee6aef3033c6d60236dd99b9faf0990bcd5390e7797b1bb2ba859656c621d9e3967133ddf08a7b041a86b2579cbe69586f5b240092cf593a8f2179531bb2d90c7b573d1a64c715e438e1910dfd551b84b97215b8e0825c1966b2b4b52c79c1ef7a4d29f431a09b44f9f55fd5ad53e8ef2acb0a59b7fc719c9dcdebfaed01111c601a3ffc4a1750ddae0b6091b564fc6647c3f3211642badc4ae6d26f9130c849a134ac5cfa9d3dd07000fc7279ebb57c347deb21e6e19b70ba15b944e8a4459dfb5e865796b7a6bb13b8ae7cacdfa52e2d2730a231a5b2d87418e5cc65c7df7fd00c8c518865ff9e49ba94af4d1b35d6dccb7f30d642f8c027e879feaa8fe4917f6a073243fe07c46f81853b82027cf5001007a645508e276a405ddc66a8e31b67fece51f137d966d4df3df9da09f3445858d7c73d3a372f028f3b59ec01212ae27ae32a615dc41fa2500174da3f3e9b4a850588d20d8d1a820a03fe5109ff4e15c7bb08b65d214d3ee633ff6c20e1bd2d225569d5befe56b94e2581bdd89c6a984d2a176d1b1274a00738dfdf5d2dbdefd1822edf5c3f8b230e8cca49318d14bb9bf3199d824ca152be48f5760f7d63ae33349cc3c58ea2f0c01055052074082ce4cedcc1da5dc3dc9bc15774f755389a136dd349a24dcd6031558aadc075196e29fc7ae1141aa6998042d67bfcf3a54ca1f0c9ac692c439daef8bf52069e393b5036ef525263389b11913a70621bd656d01f9e37a85a7837cc3757735e5e53d0382833bf894ec8dc8574ee7a5639103cbcc3cc3e3f039afb1d0955a365d5aad334e63b3d5e82ff5d6e3a1c8151ca82bb44cb02b2bb1eeb19ad204fd81e1b1f38dd5637d6c3877087ee6160b5ee249ab895849804306b32af84f24f9527509c66e6580753956cccb6d6f940dbd5de1c8a9c582bb3405ad05a31150a751618d9e48c80d94b5393f4d108aea06ee45712c039aa4229a3354f8e28911b3225b3529f308550de659c802b06c3d80b508a10032bcc290fbd01838eccbed1cd5b60295b07536eb604c28091a6406b75932f01d15248671d9d30e1462add4d857b64017aad1ee65faaae6b958e460557a0131148c6121800b3676a786632d8da3aed8c8d08fc8f613b13ed1b2fb791382406cdc070b62574f36d983d87844ae4de9c9b43122acfcf3d935f0c7f8e7b7c49f6f12989541a2a883418ef4868746036eae2312610393f4cb4ccc7d8cc17f5e520b2376a642f913f1e3e5fd6e4563b987c479505e1b857a1e8f245dee8977ddadc2522205ddb56f6bfcda789b6cf9fa1369d14b3ad566a63a18201c13fb17b073713cad780175f7f275f996979dadb5e44b0b0abb6bb4637a18c81575159472e36ed8b0239a9670e6ca68655c2a3c30523df693b3ad284e1f9b6a175ed14958678672e108dbfbebd61eb2e05d4b16baaf63be178679cadf0df581b6e39c38ec610e0d7eba75b3b4759b0040849a67fab00cfda664a358c43d751d0930dbd422ab939f0052a6f20859e8778fd84e917dc4b62db7a4fff098f4500dc1da1c8700dbc6ab0f9f76f3b8ca31e0ee711ef911f58ad589818a31752433333a37f1b2f1884661773c02e954d7f0c93081d5c9d5b922f63cbe09be669b837b7b0fa6fb3bcf46ddb2eda91751b8a5eb00ead3edb448d1077d560c8c7ca3407bd7476c5eb14c4c280c5280d79a9c278c60ea04c536fa0d93255ba06c616ff0f7d0ae078bdbd36379ace5a7e3dbd4fca54de5d89780122a4ee2874dcad37edddac829cab92ba5228701f33b4da13eb881d35220f7a93f28a2c6c89763aed9a3f7e18150ab3a90c82962bcfd6ef4498a5ea8818920922b7d557926e3bf774b941164d1f32fbc0430ec45f29714dbed37aec289f7517e71efd7bb666e11d2598808255de677e91c114d5a0f2326bae49004f657f057bb554e86810a89a2e35b3fce4e05c9c5a6c9a5c03148be44e09add0b5915827baf8dcc89a1bf241f9a2ed11373fb81da2505250295a500e99c256dd3d7e6531163057aac092822189b0f134defa417dca770a3f233f80e6c5eec95d05c18a00551a90a42ad9ddb1fb0cb89772164f10dca8f5681e12be0830d7e2fdc9761d386cf45afc28d787b66795b19cbf84dc824c66baf735c6c3fc7d450b8f55fbf5a7fef3ed76e6dbda33b68fa05ccb022d0c170910d50280ee0665981caf342a91b4215cb5b0f31802f925193c8ae4e515b74d685b00ab646f20183fbe5ecef0736eb205129262411c897e2ef5903c9f25f5a675a3c0e2d3ee483b28fb0ebb6561d26bcd563c9aa941372bcd8151ec1cd1131d48f1b9f65282ced60b9d018bd84c16dfbed69837fba3372b021938e434d78b6c2084e3d9b366559dd1fe805e001d0597d2e13a27ade2e2a4a049c528fb0b776b4969da2b28a9954921fc2ac9b49d3b5628efe8dfefe19449e4ea60a73a8d6995ece48819d8272fd2c4b078ee01b9e852ba51dac7b7b1f34cabcb522765ac8a0de8996a077bbfd27a96feedf6f894990ac2755d7aa5e1d5787b0f9a69d07134f69af1a933a4e65b250c1076f8c4ecd8fd0a0056aac7ce2bb8a6cc0773a857359726b8bbec6d664849ab5170274ec1ec17212152fd201ace37f4505b1f1af2f02c268c95b26f361de0f72dc041f7fc4191b7b492df179db6ae9910d52354aca82dadb3bd2bdc06c82dc9188700a3f291b89809623efe84b8c4bb19e9a53b9604df5a41b841b7f53eb4dcf81f2b036fdefd2d79c3dd5f3ce45d796129942900748e2b5b171a43c5b45cc2a36cdf03f9840930def4d5f6e214254ab626d831ed2d45ea3a1ad897eedc3feab78b236dc9d0e72cfea8f473e3f50a6baaafbcbf28d6b8a46851897b6c6bf04463bf164167141ccfc6dae4b7a39f9a7e757a840715514f1def4f4eef591c47c7c7c204ebdb8f37501996e223db68c03643c5617138c1fcfcdfe3329292da5b2363b6351f98d2eb8792d51bb631aa7ce63ff41986dad515c9441d23e97638721688496bfc36f31a570e96e42a206065f02a70308850d2c9a2bfd7c130be9da3a75f9307082a7cf4600be1706f714e27acb3e7e48f13e6d0c851e21772c3f94458ef2eaf794b1be883eb3efbcca236382563ed5d7409aa79b8049d1a006ce464adc97cd8126dcea4ce0f926f9fea1ad56212a442c53378b2322d4f16527716ef98b6edb4e9467ca16015224d6b5ced12e3d091aaf1d1adf3da95e2ceb576c3234d19ae470dd2a79d4b4e7be9754eed1c12ffe58bd922fb57f28e1789b8b8dfe04763bc992bba720c5fb49cbc2c4e65379c547b337979ff24b4b56cfbb93eb4f19db230a3e5e6fc1d180069791f33bd240f8e0527aa96f2cae32f39bdbb173a240e41abda9ce9b508aec06b6165da06e2cc6aeac03d15570a485d248f7f8729ce4a32ae3b3c1fa45af1fd8fd453c6caa9cc790ab6db122b1e6e2baa431a5beadd6dda2348491f3dc22f9e99e780cf28f6ca91332f65b66bf86803de92a5f9a5754477c9ddc0565802e300d9b279d067b99f25b106eb70b7f2db304247fa9e5b424115439f9355da8c666dba66b271c7545ba48ad47c46d4ce9a0cbfcfe9f3e280fc99279e5a915e6a6d0dc0b372fb29f520f459551c6c9c48e8a16ef2c689d7009ea1adf54708e214a26da06d6643768c5d8f2384fb5e50e7aee48cb5be3fe999d03f01c9b20b85e8d0051a229fba44fc19ecbeef23a2ea573d0945bc9852dfce315f9318ac5fd69c027fb62196d9c6b8cac7b8cb6dde8b5a88e3262318d6106f751fde6098daffce1cedd0d5a0b94845703974078dd3ccc6776cc131a99ed95ba94af14a33a1f1a62d262b8e351394295d2b8b852d445accf0f2ed598b0dca54d1fd33facce2177d45fb660375458efaaea5ea0143a231c96e7d95135d014ada8219c0f0fdfd9fda38ce1f0b35abd61f6e0d1fab10e557b952e802ea0425f9e275abc7b883432898fbb8191f0f8f58da0648f28db5415b399d9fb1d69eb5aa428fa31e1c16ab36d7df44634cb166150c4f43888ed4d3d011b5ddc2ea177d38713e4def8ebaebf30620bf44d9a38ed41f2d2a0fcaaec326bb35b6309540f8b309c6fbbea74f70a3785d983c45d715a50168d7c5be9d7b1011e1122b912691fde17a3dc21d18ed3a0d32519f75e8775f6a75c3a17657074112f819c9c47b3a1eab92eb0f102bfb5d5e8b6333bc4c0a8f13237aa968f723ac77f8588508deb0130c81ca32e73869bf314e9058e4a8cbbce96df5d8ab77c08ad0823f70e557c84cedbb71e144d4aaa51af431afaa26c514008fd369b7428f7c56989999c062c303feeffb80ca7abd8f540e50027355d19adf46d94f18a335bfdb6cf7756a28ac93861756168b3a610e994cbb5a4e4f5133d457c824924f62aab1b8c126b90e75d54fcf95091820e9968ce78ee8a340c1b4967a0e8e3977fdc0167a7d4ffb6756349571592c664c212c8b37897687bd68fff267b551b3c62bb4b1d07c98440509e64a785141313b236a95e1cedbbd93b5115e5f86cea241c6c95b4c4d4944f9a705b148a9b19f3217d342e201a51b74b3769d7eb304d3849bc3bd063f83c9f66894077bb216f8e1157aeabb0f432daf2181aab2d744f21f30063513c79c0c5c6aaf8c5834800fdca1574064f2b5523351339c1d1f5563618dd13fa2b7e80a2a0b4262c5a1e7ab620e76d7fa785fa421cb1c029c10de78bc77def61e7d8a4dc2b162e3a1bf3734caf646cc90bdaee77f68f90310859feca8448b35d2fe8b876a01e31293b15a9d1022b238466c345849c7fb6c529ee693b37413bb0b02189b92a06208ee9ec8e6d17465fdcbb3d1b5824b7438dfb497a22118ce7d18044c2dc81a72194748883a09ab4ffb7907e53402ccc5b7ec790c5081922cb9dc058171c5cecd1ef36b029c4617bbf250e880cccd53ce0aa5faa4d553324de8c0d3556c48e7af6a1c7e731a959739ebfe6553d88fc2d04f46c2233cf35b184b93261f136802246d629bcee958831d36c5855831c4317ff2699028ac7253809d237000bb128fea18ee7f52d9139ae81d5189cdf63d32d8fa4894300bec7e2bbe873418b0a9950360d5441073419f0092ea514c03b1dcebc03f983111371a71014e6596fed1d2de9e7c47e8eb4824d4efc12a6c4ca18d49be250dab04942b7eeb890ff081a1e144dbb9ae4f4c74a52891fc1aa395248416edff861601d45cb7e5434e94d27a3493128b8d4d079b8e2c37581ab0a970d8b0665ac246ab996b3a372e18857aec713385bd3d0ccff78f9b166af85f5b3863262ac6f38b998c9f37193d56fb904f45b872e56873f234501a5fabc7f2bd86fee3e748fad1ebd95c3eab5b5524158eb2e3e2e705ed89e2ffdab75bb875b078b2fb79693c6033e73e36179d1ca13218739c4e1f385cf52b2b5ffc92239f7b25dd367078d0d6ad762f616f0567b8d958f93857231b61c68848e272dcef2e1611f05123f48fb0f9c5a78fe4e6fecce1aba99d821fc5387c58c161eb821e1c3f944b5a8a6857167ed4d627197baa7b1c1bfb16851dc89b54775cc3da93676ffd6bdef5f48f96eb31d68bd88711f9bd29c6e4c1f1423ffa4bfc6012f7100223f09ef8eaf0ba458806c6528459846f917a8133d5962dfc423b4b93137dc20e55b8b6e0fae3206d73df95f2ba0632074fd8d863c8f1aa3b245edcfaf54576eeff844a7f2f70916e368e45a0bee91dacd264159365c158c121834a1135fd3390a0e43458a21a4b5c0ad7aaaf3fbb98e8369ad6f56e5ad4cd4c41b803d5cf51d596c3daac269a66604e4567ec15129f3d9f47dc4259f64c5e7dd4c9fc0c04727060fb9bfc62ab10a5b8448e8e5ccbd25e4797a9f7721e44fa9de9d65db9fc8b771d64b038105f9ee0c5916fec795d1ca2acbbfb38d35c09973966ee7505176fa1e45a533e770a123a1e67cf0179fbd6f0d59916ad9759a766b6b733f9927cea2ea742fe11319ec169b807e4bc9ebfbf4c765c3314a7f43be99b288fa5ece2327e903c0b32aab04f48f2ea031f06113d8ea132774a6e1b195a65f00cb57c1c13a11a2ef0bb8585cf240db7b6d1ff6810fcf85716acaacf2e7f9087a4c09150832976253c055b2dc9efa309b6eef9b7d52aa868279049f7f61bf7cae76e0bd9f36d4157d160104151d87c2694544c912c6da3b643a5b04da82d96040c6a089f49274a4cfec82426579f2ee14273c5f11d1525a7004555fc0938740a41efb1e0d05e17cc962132d8130dfd09f816184bb3c08ce6f83b2b0e8259f736340a3e9bec95190b9591bf27f31aabac469e979f4d0eeb2d31b97ba2698fabbfe8adfd2a31170a820ced3294b70241141cd7674827bfbf94069b5fe810b58e91279b14847490dff5518a881f454385de0fe8c23960d7a3a4731113a32f40cf746d7fc3dfaa3b30a989868da5f69bcceafc4655b3f9de174968253563091a335a1faa0e7794507a6b89241b9a96fe83961abc39a5f1f01daacf9425b332c8c267a255b677adb4ff750db19e4e60d59b35ea00171a26d0320b3de051329e388ac2fe548c80b27de4c34fc52a60122f5ee01df463f49a93e0cda17ef2ed7348783e4aacc0682de44104b23869f1290001c8a30e103836c9844394d288c6612e5bc9e1c1ab62d97b08a3f56489a5ee7f173a049cc22925a9002b78baee7e66ba728b10108e442df9f87d65a1fb072e581eeafceb39266d156af925fca292763ee700d0164af670f91678bd5f0a64ae1f366f290d240fbdfa5bb1982bc2ffea43be54d6134969586cb1dc33f4522f63eb2f120413cfdf2c2f23c474b910e9065c647bac5cb086924a6a42759be93a238975397afbd1201f93a21292fe036787881a8f818498cf34f22e3b5dbb8adf9cf3a067253acb5fe0aa27a7a8b92ace9208d0013af30ac88e81ff2570574643b1e244730c951b70ef515a9d7287344b75f694b6f35671d96390d14c583bc9142716aab2044ad03c9bdfcafe47e9126de88bee304606856a15326f22162e7828e0ee52c77ef1abb534daa9a67f26ff9a13429315a51dd2722b069f078acca5711131951f64a2fcca985de0d14dfb6afc250690a03faf62776c6be0672327999ddab8ba33899c23c433806727b9af1273aba406fcfaf5b0584d7264bad81dbcbd96d6723de0a899020a7ed3a5a39043e454d719002c7724ac41f167d98594b0a9db7a88a17a20434a215aa7e6e0cd88fdd6b9a342643bfc6f0641f68aca6bbc3d577384c15c4c8ed277125f7c619cf907b0e6e0821aa51ad86411e9aa33c559d2a0bfcd9abed73cfcefa231bea7350c7a5ab4e433add3179e9ddd66dc63e4cb63d5f10126f227ea06a648b2f1578d6bc41da338ad56d0c6361e8a91e38ea192dc9856cfe46d5f84f6d3c267beaf6a00a3fecb6af80bdf04b832f53a944d9e2a8a1080d68f2bfc305df091c6ca814e1a66167a837583d1fae13ae50c3840cc1a3f7c8b8588621fe9b1b0bb73008673dfec4e990e21b29251bd94b14241ac1ae1a7eedbad7bd330cd0137c431704c6dc448db00191a30b12ef6662144a5a4a2e14038e3d06a874ea9169289705debd6d5217dff901319d15408de6a932a1ff9d329b6f065f2481cda9cbc9e6dd6c94b36e805e46600ddbc6811d0342a382c5f360cca670befd47f3849de50b061b3bcf1f476579e40a2f96a04fb0a304deeaa25295de53a72916ebf06d59ad08d559603967e2f904ad91ac59d31a83cf08cdea255199908445b6f421df34d4034e549e36cc639124a59369f6ed1706d9e44f8d98e545641ba3ce8c5d1e48ee1d3a6301f22a3f4c181c2dba719617027f868efae6e9dd6b5d6217513a99a8d486e40daaea179ea9e36ca2a02add92f342250bb4b8ef985a9bd15001288c288528663068e07780b9af4a43acdedac0df386148f45a227297be8edfa5c7ff71209f1ea4e508dba60be89f462c3a4596cb67fb99702addeba46dbc2ffb532ccbbad3d1c4bddfda89ec9cf8afe7e0067d2d56e2dc66207ace982f600509490a9ff3bbd8e81dfc50a77de8931f57144fc0dbb53161cbfc27edca8bc765e3c10176564531fc69ea101368b86b3fb975549589beacaa5a50c4d44231dd345010ad91d3da7a374d2416276a040b7ebdd177f22698e01d543b7922012f089f71d830f65060a44fc51aef0d5d13440c2211d316c8cdcad3cd51f0dd8c196f100b253ff41f6a740a4d029903476e2165dca693a9206d6ddaaf90370ec415ce0ff5c62a5b72bf2beca0ad111dc8f0c8735e5bc494ae1c14fc23f8f0247f457c991c41b2aef2b97e2837b4c5b2e50981bfa478094c9d8fd731e5cc23ab15447108d9b492ba63e2b24df6e0e18114a2308c2888e8d4d3e94b515e6290382f7f8d357ef9a4d4e724afb01444afef2c2022128c7af984b8e4c05e1acc92ecf7849488ed73b0bd815b247ce0da8848d1fe54aae6861bba0596d9284d3bc8db113607f4ab263ecf8a7589d72f0f43b2d1d17c508275da770c7818952d381922505dab451bb26c6c8aa628af4af7c830fa01c2d47d1ba562cd71ea2cc5fb2c0fb7205cfc7bf9629a5419b6c8a9db64ccbff5a0576882e83f060b439b6238a62342b2d3ef133b75d96d4c0aad76b85b9df31412a4d3cbe068bcceb69b3c7c1218a0da908aef2d57fad4ca69fa1b7d91a8d78bdd0e793e377f8a05015af8a1c2c06fc1d7654bbc0c020a531560e07ec7fe4e3e884e29ca5c930127a87876f6cff93260e761d0531006be86ec82f5f1ce30eea28f34ad93c88629bff4d7050262351e57b1ba0b3e8e2309ab8cedaedbfda8f4d2130c554697e737d7464ef0808a3b314e803ac65772765fe2038d73986b64b8cfc0e36d98d5d762ebc67cfba8e81364e182d401a284e09293c2cecbcec22da76dd9aab9cc2cf3d0eb44b9460c9c7139e78eef455caa3ff23e60b3abf97f68ffe656418942bf520092ca981853be581b9155e1fa1763ae47cfffd53fdd648adcd648cef6786aac270f81179bfa9b278aad0a9a1e03ee6fe8696b21df253da33d9dc4a168a1a27c0ab90c00ac9d5d512dc24946dec491bbc88f46766b6d0d4f99c8eb74552d68ed4d63095654696ca1d2345cfcaae7380f1baf85710d0a817865504bcab51c1e3563b65fa3d935d9db5549fe88e5b50219a98c9996d948f31f6817a5890da2b89b9340aa5e236497e6564d7edce7aaf7615259c3ebf8941cc85bdea458d84891eeae4188beef127cf1c5ab39fde7156c10a075f8129015afb02c99da9326f14dedb4a1c27b9751682e82d26801ad496748fbdbc8f9215768b391ab94ae97c79984d53ad7b67bb4c98add4cfc9a6ea33091259b82207ffd88da0c2b24f70031b9bdb20340681d61536b1275b099f76e28b468c2dcb1fe77c8ddd5c1cb97d12b3ab4d1921a19b899c1213d8d48fb9d02474d1bb1a146bd498f7ba566123632220b4cbffd4ec8cd79bd2b5049111731aef227f368dbc4e67b33dccb8f1ca5f2bbc64a661e369e9219d04c690e25dd285a4f2173fb3b5d9fce5c0a6807b90e91fd74978952eaced0e4b32941da4f204427ec2813f85536bfca505561fbeb72cd3876c3515e80067cb1fbfb730834ffc3af8775cb275b1879463ab39df1b5ea1e45a93fb5d4c75644530970bfe626198a648957e85c5bd05c9924619d04b2ff613368d7123551d9a6767bd386ec992db63b6218311f768b6102282c6720ec0813d9b94683153729ed08f1dd8ecf79db5a53e776e7b6381bafdab995cad231c52f82986d9f607989c4c65b2c9b6349ece38ef6b540a3cddb7a7a2a6422c1cbe8327f33329375eedfd0778f74838513bcf20149971fab12556b48753d6575aaa8c75082954e279e6a8e13a25f4cb32c7c2b3684b2e94f65284e612f49b9fc917afaf9d7dc790ebc85d72e2fedbd696a2183e6411799c885fdea7d1f69a0391e10414ba4a2a02e9935b1de4df539c2cad1f0bdf9cb9dde4ebdb67c509609747cef3e0076387d93eb369391c4e10a0071b09a0caac2a4d67fcb56b58c5e6df91ff26bdcd3a559bee41e254ccdd5f880a6fce3e03f1ad6af498db7c8a82fb24e93c2e7e8ed5e655bb8b5ed4227ffd4d71014b43694cb39267c5f746dce75f535db43695b081f80e38af53e77f07d56d8ddc2efff9697c20b07b68692cb9fd5c635896fc62d80271a6ca00105bf432c9eed1ac66a133e07078e87cb3d3e276cd0e31846a699c337f843e3b93b3a3db736b2a29f3bfaa6ee25fae69e6bb25e9fcf4cb624b10a3a7ba2612c47e5ba8569bb3ac55b4e816112f5b2db2450c68def8b18c31a175ee49f06fe6af3fb267994ac9568a2f","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
