<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"49546302fdec8c0c3a41459ad006aeb36123e8cb5d682cbd1dfa2e1374147f7df3ac7421fb105eef88955f75317a205b6e1cc7e45687bfde3fe75183ec0b835f45c2ece24d6363a5da46fc778319c4b1338e47e093230b0dc9261cf727d79283b1ca88c68a2f84ba202b5048c4b91398ab22e1a5124b1d64eeb3c4c393ad7021ae53b612c58ade2ce0518183fa68cff7aef2db410d561fb948cd8b055fef0c71338bf63bb198b6165091f2a3cb3e39a3f0855a8dbc73809cae3d92b58bc4d33751ee006836def5c5fc4366c184dca8f4a2c6113d2b4bfa2baca16e298fff47754576d2576ff9cd3ee767f7a17a643e8920a8632e1b0643552a90692d71c81254d6f42ccfa7afe99f81ec4b245149d36f5a0f92f48383ac5ebbc024fe27542aa68f14f196663e5f8b785eeecd77515ed007cf4b0f31109f7f5f8132fa86b4c2684122154198bf9f5c6ae40a0d0fe536a41e209c9cb0abfaa53fbe4044bf65ea6bc040faa273dd3402976e7ccf2a201a4356159a96281faa4eb58c54932eb9c7f70d6b6ffd577e3b094cc319a664b7697a770b153ce709a8cbafad98435505305609d23667d24c5656fe48b3edc1f2aa3fda77c54ab7bfa9e5f5716550113b498ea642f0ad71668160901f171d8625bb8be9f6eaeede586943070b54b5871ed1d90394c02ae84dd5031ab3a67e209bd7c064050af5f917c2990b59d6d782d2e50368b8bd6000fc53f4e0bbe5b7b3b762607d3665858aeda54c44720abd64751ef18435d1aa9b0e8c8b5f4a98d2143ef5ed05f821ead7bb862585cebd3dcfda022e4d1750af3800ad6fee1a4875ad5ae19d35c2acab40e32fe7c7521a370d9c40b4592f3a5128f4225e5f4cca6ce4ded7e0ad7217fb0097b399a6bf6270893d0d5f5f2c865334fe6cf20f83d30aacd4ab3769e2fe1953582e6fb92fcfa71d58db74e9d2a80998e89cabe473aa60b4ce36f9ba575d14ad71cc08f6f1db43a5675bdedf1258fda82272971aded6b3332ccba8e70aec463937a3f167ce41a249efd336c00b04903c3d688122a11c1eb14dd3f40fec7be1e74e41503627d7c721cf35b335ce900a52a9a85004b136daba52030e228dc2a515d139018ac76c51db2c9bb5fbc1f398629e123341e54e8c300626f0934eab56a67aed5bd061faf8e22cbb3a1017d5e925b37fd4c54a7a7744b4715f965b55d489cf8051cb1cd543f317a3047765e6d806aabe3772f134f952b96da2ffe9f1e0cfdf74c903e111050ea46c9c7bf412c6dac99f6bff28252471a875a3f1c9825330a739b16f7ee522ba3c569b62b6e16f466a5d056560af46a5b1d8c9621675b5b7921ece9863ea1bb8275d5ae63d02f5d6f5f8154bd4367da60227aea5e162daf00fd23d6f0147b3e605524696908d64fa9fb4f3e8aeed75334a619dc4309152c659f7907f98d267b544779703ece2af999b4bb26f9aa4d896708c152485ef024eb5ef77afa2563afbb5d9aaaf9e117de39845e61dad9a8520c20d7889b7f114fb5adf03670881bbfc31291349a3c3b190808d8fda2e3ae501569356f168ea42f4aac63e0c4d2087a0c8621c2731692afc0050c79c88a68093856b59ecff4af6aa83bad6724a8e284b3314e656e379fa587cb1b8ba455c10e5bef48fa0e126f095803a5a23037a5e15f380dfee3c2822cccbb4b7f8ff61cbe6be75b9ad37ea622e95a0dd54613c8ec2dbbb120a8bd5a065f1953b771260ac8085415c4b4ce6a88fddc0be0945f1544b67951fbc3272df80e74650b32b62d56cad64e5b5247d45d17c0eb848604e04e200f5d5d6570130c3c084c1f4e46eef1ecf085f642645d80efa3404e93a96166e884ee5ff0f7ee04cd851c33ded0c6a8afe221418fa1134a96b1d9d262b83d7c5e5e598538e71c28cbc122c7e409f44e34dfb8d3e29ea24ad29fd9bcf19c35b7164ca05f9540c0079d8c003f9e28a8adeebcfbaa10eab2d45e435ed09e4e78298e71136397fa398ddce2e1d3edd822a622896efe074b55811641e8fc51e2cea7e56fcb2f642c872287dcd136e121144a061b77542b2677ebe2929984517c3448d83f0db19b8929f61fd8097a123c76b2e67696379026ad2ef86d9a79a2f16205f55e7ad777fd77ee6ecb8a83072f967474159e45a6b0129fa59de190b6ed2333e7e264157202ac9b734a1f3f86f1b8fbfcfc01b34b83855662fb9e99ffa24b22ebb63ae269d05077c0fbb6c5efdaa2c159903f9de3641802bb35625a085888cd3958cb138a0f77e488a35c2c1d51460e0489e14e647861164fab8631870433b07eae389c3bb4643233c60c5657cb781cd8a253b18efadb2b8ad883e605a42577835d23eaba0d963fb32fe696f188b7e39c611fef04561a214151a0d0c662692d8695c1c0c119231cb6dd9dc9a24320559ddd3c8576af2ac1f712ecfbd77942cc4efd44ecf3230acd7c617d1afd01d0829581f4e4d41860144b15464825ebf6c678352afa1f86dc79d4a635495f454fa3439325d1d0da3354cac063e8dc952828ca1a819a7dd5a7dea11aa80589d51528de0871f625d3014ddef6a699915519376ae5fe5b9136701f6e6486c84dbcd348ffc7f3b32bcf35f0c1d78e02344ac592fe34723bc079b02eea0e77bcbeb97c55797fd1f8a03c6459be0b77e8354e8df3603f79c45d6effc511a4d90036a0f19877f8fa8a1a1b7095349f81778a315713754fdc7eabe03fca14686d80ca7f0ac54a5d5531f54321863b9d4987615eb606d4753780d365717c7b079cb0351ab793c381da86916248f3800279da454e23972b497edd0c880645e8818384e552f1386e478eb8e317128d7e85e65315bf8ec6205e4cade640d6816e8f8650aa4434449b6fed708167dae7bb48b9c004c2d6a6a2ca19de09531131a8e10f9b2f3a9b590a9c3a4fe8b2718093939396e7c013499754b19efb8571ceabd81497802aa88354f06d8c4c81c9a82667eae2996fc6620de95be411f09589d9f55373f693d47dd12d03709ccb0ce30507852cafd1c55acf51d6dd56a14b0f64928d79c82a0f370c30a136df0f92459e231a8ff99203e2dfbea62d6abe8002cf55e675447b29c09226a67bbcd89a7a4ec4b4b524df945de4fa316d59258cdffe904bdade26a40841eeb7b351ff7c314c56335819b07450e4f60f169d9289be8ace1efdad9f9e5eaf697d23c27573595a22057e8fa496a91ffa5a6c1377179f1d4c7d41502f11f09f0b826785e0fb15dfe24b7af5642e399e330d344b2d13765fc7c108e0848331286c8a099fbba837c3b9ac0874ea64d53645a14acebf217591f89986c91d574171abd3ede179c907e1e04b98e3325f833dcb326b76947086a954fee8c398ff4e04537b96e11acd79016f1c8099eba41b71267fe2c94c66c31906296282cc4560b5394ed46c34a73e955338a9edccd0d4a497d1e62caa1f02a1966457b09410111ed146b78dd3ff075ca1ca50e2808d854cbd853c83ec0991a5de732eb6b636267ec400dbf203a4b646a3332ee5961b4f93bdf731169a61a3b636dfbe1fb4008a7f30bffb1cad87616e67ec652b974a656905da1854e3a8eab1559ce8f046a68d19a7233496216d9b2338abc78458029d4ac20628a88ab33d6898ab57da6f58afe42b085e31fcf5ab066b631dca1de78320510b4d655639048c091eb9d3a948c4340b0842a1f1dd4d90676522671a38d37dbf64ab2643bd007bfcd5b46a57b0740291653ffcd901f6b66c9dfafbd15b081db1b28a6db8d30663b1a5bf609ec42c9f101d6bd8e96b4e68e1b3b30701173f70c7c7f13403f0b3dcc7ff386f02b601977784d7cac9fffb1c27ec190b678293f18b81c155dcc3a845170f3d981b5886d9f7650d224641ea957d5537cafad17a992766bf8870dc8aeb8655888954b7371a80468e1d0b756147540771bd71e7d0cec5d1567e7ea84c8ea215da3c382a82cd3cb9c4a1c9d93c600a8ca937289e5b1189a0766072c4170adcd4bf74daf441ca5694f67dbb6270a39be1c3db9352782524080a89d079d9d572b1435d20021b65d3d0482081fcbef2ff29892654a4eddec58f1ae4eb0759aecf66dc671413df13ad948216902ba938bc2ccc8bf19d750d9755fd48c566e805d41dc45735387f0be038dbcb095facb3e254ccc9c77384620d202328f9b343aa88ac2d3870920b730fda54c2de4d4c59628f2bf87f35a8fb7818618f1b7edf421ed3e2d86fec04649360d0515e5ab82197b6a48d3aa1901b2ee216892fe3c87f34d31e61231bbeaab2d6798b4fea31a1629c8377a22a84c0f2e5d28ea1f833f9d2962fe946f15b80abb0aeb6105b26e44f69ed6889a978a9461222334e0b0b4753460925dce5260a589512a2cacf2679470964487bdf319031f08c780200da5095058e4975420831f241705d80b4702029209a35181653977565f7f0e99a653a1375858ffe790285fdf950e55ff2769aeb878bbd47635b7f40efa0f97c9e17197913caa18240ddb13bb84d86bd155403865cf8cc7c680909798f68faec96743e166c3c1025117a94539fc0edab9d4924fe117a5a2e71812d8c4a94ba3626e0ff28026ce6f90fbfb15e663ba72dd6e80c9b77fdf8018cb068c7b02c30655b0711832ce249675f71b8809da24eeb4a7b81a1b0718db6feedc5f8662f952c3e78eaffabb8c0b4ca7269b8ba10a4945f148d36425f62bd73855f99ec517ecf8d4234f22450219dd3227494b7c52681f906a6a1278ac98aecf6e97602bb8a977a3b3937625d0c79ce9934adc3e04af61ab499f443a1ef674e39d06d8b75b814dee4aacee8b2a68f7fa5b0a85f0faed7d3d6e94448b24a867884dba1a76a4bc7abe014e4273a0071b635a8979284d72386730208b74f6652fd8c1696b7ab1b73b86ccbdb7cddcd10f4035718e43160e7231b5631816b24a9f01e447a1cb58fb15df477619153770f21c27d7a57c627b39cd46eac3d6f722843733d0f0e092cb3585c232b2c965330ab6deae786ed67878a394ef7f36c4f981d4c02c3181e6827c4342bc7f3e492447ade4c654f8e1c66d3e4fe121d704efa6ec05d214d984f4133e53e297f697248e6d8ea9199d345a55d5ca10ee838cd1e7f264cd95c545df01465812542c6d933042787d5c67dba9b2da858db1f74f3f6c7bbdbba84ef150dfb0f3656de802813672b3e40958f333ae0d8df2afca18d938adeff1b5f5a8c02c7c4dfdc9cc93f5944f35bf4d15b399abbe7da23be118e8e9db22c62362bee0db54babf286890fba4f3e6ff86afd51586b1cdfa2e3c2bcc302dc723cf381aaa079be30ca8ad5571def430b04a4db22ffb6792f474aff2ad0c48583cbb0ec8b1381f815b202120109e579c512fed36c602f0dc92506ef0cff5ca56270b4a16afca01e92f45552711548384bf9e76b781cb44f9c946ce61c68775038db22b8283b1bc7eadee224b0ef8496dc22e4247a3215901a25f768509965d0f3185339432ca1b905176b1bd00cbbbbb1e6cb32cffc255fef37d02bec062ccd7c9be395dea6ca5a1ba876090ef0c53449cdc6c5c01d5b70e8fa7b7cac485b88da2338b566d958955738d44d1e93274227ed56866e24cb820f5189f79adb9a587b8527fc363504db7def41f2643b4f912a8e1e2e9bdf0182a5fc61e94cf2c1951ae423dc34a7a2685d9558f7806e894a86f800ad95876ea55969cbfc7ffdeaaec6afb28a8e91051eb9574a34e585044e871fed3376d95b9c6ac224ed8cc67c6a7ffde89b3e5cf4bb9b03b8182fe07c89a4dd7d36a38bc110a04b6b940b4ce19179cdbf54bcf69a8505aec2904aa710e4308f64432f057bff394f8fc98d702f168e7cc0752496e08c4fad43759829bf8ba6c7be1d51cc6f41729222c3d12a2f99905f3276b9b68b265ffa25ffa08b5d8ae45a2e565155b52fe68332a5e6f2e0d9558b4085f2af35d248b32db1be34010d35d9d693c578fe8e0345676c07f4a9da44d88377c76b518c936912f2f6514e72abbba6467a94a11eae51a41ab59a9c919ad10590884c1c33f9f346d181994fede4e18f4895c51ae3a4f7153f6917f290795c26030c6c67bc09aaaf938b1c6f24814f84e8af3bd674a07532b5a395d8f10308fc8f89518b1ba7d0160ffdd70966427ec5fbc177785a0fdfd8bb299fdce6dd7ea501c7a084537cbb93277d43bab0dc2288b7f7db15d35ba70ecb51c3fefd290ce9eade0a2ad6f5c3d238958ab1972271c6409f5fdecda0f708cb6d7a7c17640bba0ed5f28933d247fa19581687ef184a4e16242b9b3c322d9f7ad1817fa67a016bbd5befdfc317e76d7abc87e54c872ab6a3fd7a698430194e8c7b2b2a4c6bbd6348ba3fc9f1d63048d8116cc245ae6811066f5d234ce3358120e471c32e802bbb243c9927d96b9199191dbe9fb46fed8d5a5d741c59d391d6ab18b91ff018213d0f95fec095190b1190141862acd58292cec5ebc94e88bfb5874ae5f3d09cbeb40b600911ecea74b7238530e164bfa0114a447d60212984281aa9ca39a16a61811d409f55920b76944303a74cf0aec5610010d608e3747404938d0f80e4b309ef4e2595095ad33b30aab01ee963c2848fb5f30179ea4c31d820aad4ddd4e78239910dff22ff2b8cf439d1afb3463a7301fc1f2565e71ec060faa8ed63c0fdfd301526b6a2d07263aee5a51f3d14356a528b149443ff0dcf4ce8bbabe6f6a42df99de74e99f5337344d4d526eb08aa102b5279d910abf9fdbfbfd10bbdf86369defcd83f5617f3e183653f1626caa42ba019d925faaa169c047962f9ab4e66dd75e808f10d33d081985c4b2e87711e07acd769769de016b2f8515caea5dcfed88fac51a4ab1799f50ca6619225ed49f3c52b9747ec3843ac4773c14a112b9ab6069a3bfd54ffeec4bd29d6648c04eaf7aed9faf67663c267d1b2f5b549dc148e8b9c419c616dcdca5ac5b378b65a329e1856f73a6c36113244d1cbbb36198f96a9062aa0aba08479f5a88b6552689a3a2f11aaac8b6cfc6f62558666aac8c51121701a2e0b5a982c1ff34b1554d666f7b668d79af72f1c210bd1a17ed5b5251a63d81ec6f91cf65e3163dadfabdc0bae6a0f25d61747b6723f2a85af6a9bb1bef09977df1bc280e34f9d25bdc7be25dfa3830b22284b0244b528ba400d459e2e2ae0cb3e6799696099b090b598ed9d4d8bb2cb221a079c871e8d2d6bb80b970dba5a6f913431966aebe7b303286e3d48f855cda80d023163dbdfa20020820ce328fb1c0c7a33f3b0d733ff62dfd18d674fc76fbff07ba22021ab41c97a578235fcec3cd58b6bf322df8501d2dd3578ee622f34a03468a0e85a9c03d827368c1b99079b354bc3f8058e1116d90a52f3670dba527fb43d1d006b4f9d51ec7cf862901d2043b4055342192f0614a159f69cde56644fcd547563a1e506c977a8a9d8c54f57f295a90be7a996fd7a599547ad1f94a8dd98795d190fc02f9d74f761ca6fc4ad848d443fe35e5026f0e4e077280759592b7b45843d21575cf1d29761250af1c911c14b636213d658e8755cebdb4446b91df04be82e6896e8f2b50ae2d291b650c67c682fdce624d3f853a2c74accf210b11f9e88fa374269fe91e430023762431008f33ec9ef37bb7f31b13ced925d5d125d3e0ad82fa674b624d829eb95c625ee0517a264f854a01687b94c5bafbfc1b6bfbbbed5b26a8b536252118e1c4b4a9b8df098a4f0a77052c21dfccd4538419bd66720a098e5ebfced0f06163e260573182c56ecef2b89d1345aebab35d25751336db589de23a44bc1fce76be878894983e6c8b9341751cfa72c0322b05796b0a25848ec6da4e6fb0db186d89b04568e37358f25de1c21b815729789d3949d197a45c235ff8a354f4e0881aa646cf5340cd0aad7bca7778cdbbc76dfbb2bf1b44c4445b8ce33dae0f2efdaf94a0af5566d0c4fcb2136262677ee9bd14a364de9c65566d55446ba67cbf02e3d4dd6681d712291651697c957fa01495a6e862ce94c8b6e226138ffd5d6c1e76af1a98bd675c0ab21120477eb3d5908d7dffa3ea3711e8669a19463e2e336135fd75671daf955aed4dc3cdb05cc144f25c537a06c5a5953089dbfc7963d20cee49b43848aecf5d2625cc8c49012fdd277e2885538e08910e2b010e455a17fbb340d2aae0e8046d53a4f2beaaa1bac47557b40d7ef6c31c0f80f2a668e5d09117c14cb02bb085c874864df7d74a6be7850a72c4f32f9b8f9a2388c33d34c7c314738bfe4478260e340c03aff0cf13ec9fbb650952af1249a9857b0eb32b1c6317ebf744a5e3e62d9305ee80e2c86a13d95212e5f6f71257a48745bb67c00b0a721c9cc692db35a62c86a3045ad189802192b7773784baf5366b220602cc6cb6bcce0f40c31bed07fc31d582d7c8388a55efb20cca0fa49afea8ff8fe768972af5fe10bc237d3731e4ad94bf97031a35b21434f84791efa23c528d8db3ac5cb69eaf7a46ed99ed7b13728edb5c7cd5029042c1c32668c20c22b5ac0ef5dc4745a05c721c055d4332e8a9bd0b5a4ce3b51aedcb413e99412aba42408e31be00e6907398ce55100919aa092a3f50db8437715e1fa0043af8d32982f162fe0c7357807f3f6bdc7e4f5a8647a7acdee9f0118b7189b047aaf28467d787927baa62d2d68b304848499a23daa1bf733190eca88da2924154ad343aec2927b8b9713f3809bb613e7b12ad84f8a76039a1ac0b274c269e4b06250eb585caaacf1ef12081ec90fb475c91645033e8afdf5d6c681f286eb10cbc3f7f508e70577fda736c1e042c5d4bf37e2c321b2b18719aab365717e5f91537e9df8cc0cbaea3740f28c2f208ee3628385f66713a660faf0722a5c4a3d13449f1659d956d3d36f379a0cbdc0253b98ca61d2323f5c584917b1e4b341230502bfec46725743f9a6c285452c7c2f9a7b3989dee038d22b1495d7858ae33c6351a37f4ccbab04bf06447d9dc6ce813b4a959b3be27dbbd9bc30e7b1ab3ace52cf3d5c314c3783d70d8575f7aff9373f86125408c104f9589004aec042ba416eee5c9d0198e9a43d659479c2c9ff2a0455593b288a063fb319ee8e8fcf941105b74a72d28e245ad0b07095063259d049de06c7fabfe8f52d52ec5f5ae2fb820b9a7765b5ba6539c3c5aafa2c647fd2ec188df951dcb1ceb0642525e5019bd053423aeeaf395e0030d062ea7aba909e26a1e604be68f8c0e226d4d5208200ad0a47632719697458ae0354e7955b8c66ceb572bd59d5f598345abc42ef423599eb019dff7d2682a59b6bc5817030a110c95de75243db2897d215a756d17e4dac1792f791e3e7071baaa9e68a573a94394ac3fe0c8b0cc8374c84750a7db8f0cfc61d1f1ef50125c4f0fe7f37b33d836248df68dd1bb6813671ede20b7f8eee7b7027e45d6bd29c77a66861e6a6a773221fcaa96f14d32736a46c185b7707e273949be2abc1ab99ae7be4f9520c8648f41780a1066f9f3d08f2cd1cda46932e8e12aea76ce2da0554d532c1de299f10a75a46f8df103128f98fcb62fde2f49f57e817b5e93ff4077d3d78f00fd923a32772332d62f1ea65912f89f712005197177e9ae8100791f9dcc5b88c2b87558ff1d2453b4ff95dcb18609233a0357e105b5046c39e34d6b6dfa1f81fbbe4d775ab3a661969e7ae3d96456ccde513495fd3bcd591f892c3803aa911c4d21de670c22b57e2b267f0304c83979efea46f470166cfa1a9d2d2dc88f3a7f8634d2d177a0bc36ca49a4619e35db301f0c45768f77d01173b2cf057cc41fca9914e8b8eb048047a5c1113828d450cf5bd3e9138f906ddf63aaf4e16110b5751100014dfe7c92b93a59aeee0729110969644eba83085926b15249140249046e6f1c35cef7a38859f7b2d4d84e22a156568a4b509c22636ba1920c98ceb581a245ea6e49f6d2193bf18ffec38fc0fd8ef43fd54e27781dc8fbf0fb25ba8f33b0f0d0a9740efc1f7d748f0b135f30c5fca733a995cb55b7c1cfd689a0e310205b25af8061ed9199b3e3de51eb105e75287375e7927c73075fd8ebcd1e98b957fae31068e822c4aa0c7edc252ca8a1fa7a2cea9d27ec18e3b5184b6ef0cf57a669d5227d5acc1bfe9e31b9b9fac439e1f3779138a9072de156f8d9da3b8e8459f860be499f793f1399319b69d48633268935b70625f046eb780223840e5a01370a3b2592141b27a7da8790115c56f52112ccc3ccc5e28885a25c922c6bcbf9ce46608c0df623d890414a352aac6181cf11654283f93f6a322745a12672de1ea3f631885d82a552bc92acad212bf87418fd19993f6c5e2f4fb59d8f1c799d85b0a69778c01fbfb31d0a85cb87b2d69259c2c68745716619c9b590b0e5b13573fcb7c52d9d1cca6ded4d583bb8706edc80684bd56db184acbce06082db604f64e3edd0cca6ebcb2db39860ba33d951db7c27dcb0ca33a81c0c237b0ed39ffa3d68cbfd367ea583b15ff49d1b7e58593ceb9d0587e9a4be3b6e62c690f794af59504e74c8c3584ba87b1de508d915b551e18c22ab780ec51aa52cc786c3c366aede3af82372a2fc2272a7c173a5e60a41cc1c328c2fd8ef8c783e7947dc6785502f6d8266ad5f71dfb93ad66810b5358aed6ac074d179586cc210fd544b246776f8e6645f62da90c4222deb909a18365e1ba7e9169e40c51934bf3d70b2ea831cb0527ca95014a5ba5f17a876fcb6ff23f0c379135733ffe843a55494cead801721f2fe2556127904e5e89e1e31b98abad6e04fcbab33bd8a3b893d912e895990b4d74b56b9922f58d2af701d8177215ae5b8b73a7e6ec85a001d5b84376efc4346b69d334435284134c2c0182f55f7a7b45b11d8fbdfae042af3ef7053ab9ba447d6e78d37c3cd8c6b9dbe4b79be43adc0fd31167914061871f757e6829aacd6f283dae773ff8af71b6a9b75b4d335cc70303a79a7a83a76694e7a44629499c6e1a4b799c153b88dc5762833df8c69d14f5b0d5f209b1c7ed4118e6c03790de1ff5e76307f58acecea05b1ce8777cd0687458e8ade52f1e763b636d66895d9bb925dafcca31c202fa97410fdb8e368848d337fea0f1b6ca1712af055d7b26a921ec3b335cb5d0954bf2fb72d42d785814adba9a55f641266590d39e337808c634c1a20773f31e50091da05c4f81955ea93ca2273a6b2ab965e3292d585e58f1292c8b58baae530f2017ee7ebc3913ad04b56a2f3ac29af63f8d17ce928eadb873076afe2deb03aa379d93ac8930faef78b5ccfef6c52cb2e5feb58d0be12ca8664db3705a59c3dbe9dba1615d391610119cddae78d23e1fbd118f2083cbb194f539f2d42d4919fd96cc1562e15a3a36492352259b446c5f9b3ef97ab209133ccbf85953cccebcd64ebb6cb36ca43aee484f81495c3ab5b8f50cdf5701a58ee9f2ca1d80a2c9201f7b9ae2876c8739a9cb73f8234fcda0270dd1f5c7ad048634d07b61fc9d955af785c94d68705593efe0da9ff8fadd26c693aa98aa40bcc349953c03e06483138ef2bea8e55c8ebf954062a40db88dc2b34b60b16d86a8e61e51d1f74307db141d2cab803980208bfe54a0a61057d2fba2f179ca9b8f2c0330c141c4c107d7ea81327105330b3ba276c833b103bcd47132231ecf89d6b33942bc8f3687253cc844f9962475ecd1e2638a73274db77e6b06556324aab7d72852ff5cfe37a2e1ffe6cd62585666bd9ce82ac234bf5dd4a2137cde1d768ff1c6bf1f963319cb01a7ec67ecf3089ab5fbe6589401d23ee31242e2fc8eb6f6f6a42149fb2b5c410eccdefff15198e375d1a98e7e9e741c6ec35fd6965fbecbd0b841418fcc90cbda0ddb3e64418bf8dfe45f805bace689ee2e1d3197b6949eeda975ee6ff48fbe0e11aeae17234249fd40561fb1b961ee61a57ae85e7907663f3ec095878a7df139225f9f6a8c7ab0e43a464b05d942911c0dddec0892306022a1dd1057abab482771ccd2c35c02fdab88c90961d34914238dab0b76bcb09d0916f7792b0361650aaf267762293952337259a2ed4c8bc9910d4e201481da5f35a8eefcfe133a0fb65d34a3f911daee363479ae987cb52abb665a6620efcd45c5efa59433bb97b70eff5ec052e40a230e4ddcb97705216d8a6dec78527ee905e1d024b7f8073975ac6794ac01fa13cbadcfb9375ddecd9746c08596e709e7ff6f8c148690947bda3e5e50a6acb5684b26b58803439a0b0b015fc15be1fb8c6b4d8e99d59039867c1081d5259f7dba344989d6467412196359080f68e93b35a43e325c80a47e179e951725553834a49e0e1b8667ad8736090e77f9fffca55dd2451165ca6a4617eb951a862c5c95bfd9699ed57a8859937ea6d6282f96795196e540a4732f1a8832734374ab7931618c1534fac33d773241437367f767db9590cabd545c982be6667a7fa8038b66686c787b4de22b79b6d28adfd59f534095ab0cc047aeee6429abcd5aab297d354d5c81dfe906c8d5c6dadb09a618642d697c45dcf713d5b0a81a5fa2e89f4d2d8db531cc8f547a565ce6c5bf425c639a0b19c00ed3d1c2494b7dbbf946c0c848d7d3b5f125991f032e97b6989d34e1980d178c3fe8971a3bfb6be7be7741a58ce62832ba67f15eb7ac437130175b0a8d6e1b5b9ca84f728c1a5c8522fd60ab47002721d9de5d6e32b34c5c9170977df03718c8d5c712b9e30c5f3e1f49e2c4bc3c491815471e2478ea5acd09954243917191cf5a79935b4e6099d5fab2d66dbf746f862906b436be62892ac8bdd68278fb2b2af5f6aac6d2e04dc5011bb6335f85005aa719aa3885b1800c36c7d3b267d566544988e9a483c02c73124f2cf65116aaaa004a88e6e0abbc0ef3620dda938489512cda8e7b6d8129b5225fec862ede0ce7cbb3812fa88587250787121023f53584212232368ecdfcdde73c75033b7b5fbd0bdc88190e02d84e7fb7be7e0766a776e3735d5ffe956ef383e4fbecceefa9c896f358bcbf758c993b88f78948d29fff7aafc28b99142a8306ef8ed86f537fde423859953106664f33ad5348fd95d90326e7dc5831fadf0199f2c6c54f937012d3f00b48beccfaa2dcaa9ae43b09ec3bef1a41280efc675ab084feba62293eb2d4b9e6a4bc52c6fec1c769aea0c9c3824410a23bb3bf22897ad7a40c480df931aa82aa10c829ad0509374c63bbdd1eb16bf2ed4e668a5a14960b7ce314ddb51582150057e53e00dbc56fb6a09ab674fb94585648bbf2d4f15b284ac48fb887ff824bb44e71fd67c53748efe899b400e8ea59d48dd5a1c664a0e7e8703a1e61380a49c687f0311101384a22d713d72fcdc30aa3aed36371720513bc00b0f9528b54450554ad3c9519a3cba5c95582d4d63944d5734c5f7197e1d8bd86731efae8ec76f7dedb6162660cb918a428ad350778eb1f14cc9acd5bbce6ffd957dfba0ee558d9df56c9f446a4bc4003b3b46cb22571b995d367b79cc3b2fde513c0bd7f60b20f2780616e77b813708690e5f796dcd03a3dff3c119d4ee42f92d58f4afba3606bd00bb6a5810646dfef1bd235870068d9c3ef2766a43565a697264c9d9607afc47612ab48b89025cc41e49fdf194785f1b4bb3d8d10f80229a19c6ea8aa67aefe5d40ca3830ff18a23c53f5bcdbe60ba70c47910b25da138bbf3dc67d3274d72c7c9e844ce8db517f4189b4884e753ff9d4405ef10e34dfb626a7bb8df8cc0c3d9c1cdf7f9d866c74a5c1d849d6bf3be01e52ddb22d0e84cff4a8c6c3f85dfd62a32cbcd08c66683615b47c0107ea3ecb9bc6b11e04a2ef8ea63fbd3d1766092388cbd084284e3fe52741c0745152ed08fb41132662a2f5eeea6fe10582af0cd0d9eda91ff3300dd75d02a4eafc2deb9ecd5ad7c891596d2b74d40a017ac0432d8abc6c4cfaf72fa70e9d096ef5e385a7fe5972b88746caa32846eff7484e6cfb56c19cbaabc100751c1c403e54f7b04a2b3dc4e8982e34873e6cbf3b2f3734cffee27ccec4804c0b84a79de3c01ea01f69e4e6fe04312a960bd0b68a0f6ee148647ee14a203b3ddf94915b1586930830e1831cf4c5516b044cc34fe544b6b143ec008168b43d8a6bcf66114e722ba0a6e7214a48e9074e45726594fb4950b5f69038c7f47b8d2d0eab55b01df28d2bdd5cf4c359b5ac7576ecf17261de4b91f99794a332ff8e819afdd467d27fd49281abbd7e2a82daef3c40c48aebb1ba25ff3d9706277b891204225c2bd526aa19b72a6bbd37b8a88b5f9905d37be060bb69bb0f24cfae4d315f05621e1421042b1fff6074858aa3db4d6d55e16523742c57c13fb9ca05884212a896def51ce070a0252f2f9fd7044e53ce8279feffe0ccfb472e18c7630665d155fdcd66c653977b6617f05ec8a0b0c9932070ff3c0e13d2f163d8f452fc0cd5dcd678227ec82c13677b36ad8024b790a6ef2eca7fea6142061c9569550b9d2ded1309bbb6b20c90d165b5c4bc0c72c","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
