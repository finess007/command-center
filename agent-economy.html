<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1eee752792ede1f7fe18d43137be3ba978362798d4792399f5e5810c8c97094e262aa34eea16dd30c4c7ea7f8a6a7496dc1712b2444d2ff89c05d2d6a6ac0f68ed7b26fb87710c47a362e4db99c288cf5e1e01b8e40a8d37ff0d0ba9939d72dd53e2222ae0dc050d3ad2204aa8f8efdc2fcbf40df036677b5f0494fda9088cb1d38d4bb8b13f8b249d7cc12395d6c153dc0c3f31a348e6730a6f628d07b0148b6fbbb96918dd7c8850152f7a4c88f84146a49c564f717f5687bfe579ca9999f742a4a305751db5849e3975b3d42047c5e3ec839e09e636a305cb5c9a55e71a7832e4be2449424915e29e3da963613e42fef2602aaa18fa4b60f2b2c09f23684fd93f09d544a5dbadf803716612c57e28e311c83a7509a3a76d2c507db4926221d20d34571de56010039e4bbfef934edc82f939b7c446e5b336fa0307e35c51aa36688b57c5d7923ac967e446f926f2ee56eb08858b83082202faf98fad8bca7bdfb6aac49acf47c9459119b0fe269da0f42dce3b2b47eaf782af95df9e7cfb04098a8ed742fd23e4d33bf02c78c673f29fb4ef414f1721d4d094d394b21f54c798fdfb167f1ca88f40e82694d1a96d1c2adec249c5859d128b2163d481ab9e8bf6fd472c4203861e9e62d9de997de31fb7bc3806f4cd448c7cacc2eb989486373227219a5441b58d9e97aec2ac2686b55bfb18041249b5cee113399284d961e0884b15552b07f26c91254ccbf60df6c6df92c6293f87e4474697a5c0000bc94aa3f598d1ed6eb7fe8752e657bf9ed6341305ea1d4f42508b33a42b91675573f1fbd27e920a9533a0d9e218fb12c78a557dd92c3a82288d1d01565eb565231a96b49e281a8899444c736ad84799751cd0054c3c82c68e3b1fed3031c6f3b39092e1385febcdb2ba3d165092ba91de27ce63f6199bfc44d6892f0e393180222fce9af6eb5ff3b42734717eee18faf6cea14403cd6b85af323188bac0a636cb714f8d657563c79303a119852a080d3fc81e56dc7690d3a64ca7c613acf470340ba31620c3162da596c1b355a423d3c9f2df9d17eb40a93e1bcc13104c2d58fa60b3e2ece3fc7fad41ec411961b42d091bb5d3262186d6dfde3be9ebd06615a0838bf69e2eb8f77108e765c05e169db5151e8977d6d493a681f1d55af7aace922b0afead55536c993f95d00919b918fb4d093eb17d1eecc67a063ebb4bded5f31fb6542616a1733fb95465ea03a8d1c5593ab487a10a3e2335d7993dd022ad03202469ffc8e989d4d744356d6127f9bf84753b4e2c31389cd0d6ffa24331d187142b3df91c27cdc2011c2faa79f2f06d793a46b8770c7b617e9889bd0f94684b8100801ac4498a8a60c4b5e37d32a01b1c481bdd3549171573b1ec5b1c81b0a8d92d719c4fdf65778c7c6cf92082080351d475166c5ebc72efca1702b72735fd6d81a5148460835c2821983a6b9332cc54b6ba33219dec720efe58c4d3642058bc340b769a97bf49273dc4bd64232b3b5e9a8ceb42457b0db5ebf59368afc70f1e9fbc1f1b382340a9d799f08f9d598fcf995eea511533f7c0471551d49403ca592d52ebc18876cac70a1c8bca1b45ace9e590848b676ccb871cc4d8b9377f2cf7ef936316e582266737d4eefa1acfae2f6e35f6de92f0123e960eac2df626c712c3af04037182671e03735f25e8a92710bcb0002a9d76eac6739850032f9dc0a9cb8d75ff8f55ca215a866a6ed8e1331368942bd679461e7bf773042e367d31e048847070e05f5885a6737380994a9e9e730174425ddbfbd7f055c22800351ae7c609c2b1ebc6cfc7af6944386fcc12043f567befe977133fa41b24faa634c39aaa53b15a0511b3a59953e744da836f9ca0a60a33d958354c067c967132978d03e95b4e09a1c484017d19e0868852763cc872a6662202fe41e70d2f1749d9a46f3934f82116533cf49e6cf4bf63af009fd436b321049d361b6e3a1c86a5ac70bf87e0ed1d121545f15772c8bc766bfe2dace807dc4e1b63a91760030405be1e7ce738b7517b5b85575f9058c07434d195193beddb0d8456b58b310d4bcf04f5c7e677bf33b46b35468d8816e2569336fe7c8b4f6255e174af9de7e1771bd1a0018ae079a5aa900d1de9d14a04270829983e1ac958b55530d90b47bd1fdd2b30e7216a702193477269af4bfad85511ebc93400b7d230e986e7bf3e9c1658beed06fc65eb69a598f34dce32127701fb29e3944627a860cf8b978a86bb8e5935ce7150d1872195675a158f54348807aebffd4ebb20763c9f53276256c57b25ae83922cbbe1fc858e657816bd7e50a5b0fc62c955a412dcd815ab6758f1ffe1ce8954959143ed98660474d1cc4673e6b4caf8c47492e0c1492891e2fdc386a81528ad4002c4e6e971b6c24a7c7db277b6e4d7a09af5a01b5dd9caa1dc1f99f1d5e0c5ca956d41b0e883befa165783d6191980e3ff2ffe753e0c41ad2dc1d10b4a1767072e048c9bdc33a136b24ab5dff1c6d5fef082beb44edf197c334458baed8c3bf3bc6601449b5710c6f8014196570549523e34b6275d296b1ba4a841542a0bdf9e513357077d60378f9c2866e2fbd0a2ed6edf5cf29e3b4ada1552c7d07bc5f69a403aa2cee7cd329554b44a1ca0311fe065ff34b6eaa897665bd1734fea62b189c953b567b0fb04044ad17daa147ed3f9378e24e712acd7d3b2d0f62082166c0f8c216d898d5037d5abcfd745352542b6d7c86ddfdd18b7304f283d6b4195d8aa1b5da4a6cc8f69c72b411c4d54caaed2987cc5a54c9e5e74597478795d9b1fd898489175374ebaac4091f1661b9c9973b86374ffcb44fd397b4393334e43b80a4ea21c78c3d0f0357cbc25a08221c59befb13b3b1989c7448583ae8a46bff85f30aee4cf2151e68cfde0a0e5870629e18542e296d7d3837bae19b68c4cd08215314c4cdd1b6526fc78330dd4824bcd2224cb3a2fad9de5f4f7c1b72282c5a2cd5e6f467b4f190d88a9a260b86cae340b26065e7c6e6b0c594e15b540cda166b2ea865045863d0ebb9e5b6a614c759f81f7c5222f3a586f322155d0ae5453d17ed51436e310d60bc24f441eee087d2623edd790a388b4bfc9b85a1ce2ca549281452171d681023148de300dd3cc6503897a609d738f23e23d13977a467a7d1696ab79ce0d06f4cee3098bf23893a105be35641c77461f5829b300082eba3b6351d9630545704416eadea8e441827cabc8ee4df2c7515a1a150a3d034b7c841d03cc4c49a73ab0ebb78a3903253103187a3b559d33e3bee918fb38837c3734a044904ea6fb29d6ec0eb90af3ee387d1f18af9c3b69659395ce52228fbe067a602fbcee84719535bcee680f2598f09d661b3974810e665329c987eff4046195bd166c6251852f7230c4510196bc5676395f9f2629cf6ef7210631794d83802a2c986c572f4813843ac502a5010966f9d48321a2cfe4ad173f433b5dae138d46f0d65fa11469c3139697d2213a20382087d4032f9738dd5746620cdae6e6641b0510ad3e9e35ad72e6ea01de5e6a67aa9a9ac3c7a6d2b37efcec87ea8dd48c2e8b128328a575cb1951bb9fa1f7776e110e03afb71ca92f3d0e6704c147955f9c9d48009601952e9b6ec088ccd1fa5037ed5bcf6e4f2b251b44ac15e5491d748bfb955f42995808a9c3e3f160fb300f663faf111797b866fdc644340f79fde1b4d9e3b30ea2e90ddb04d790cfaa078471a5a1c060c2f1e0201ee04b16c62a3be96f074d450dec83133954de650f4bcdba83311fb46258a3e52765c82c4d8c3a159cdd610cdf4d78d2050969f5d1891d3db462a7bdfa9f41110669009c888a5d3b2f488f9f4dd3bf70794b932d1001524233d7f80f7cf6d84815792049be68227ae5826012eaefe41d8895f4f35cfe31f26167ab79972c88060c2f62bfe51b8cb9a8ddc8af3fd8afa4ee13fcc802862d346b030f73ad739a825db5e371b0bd95ef479b2ecb66592a8bb4f4a643a7eb45fd4a7dcb1e15ec652fdb007713f7c028850458947f182bb94a661e90c260286a184f4fba0610c133619e40443375e3f276336d43c4cf077bbeb968c9d73606af7fd177f6caa5323f0e6b458e24d4b208a6e3e016a2c8d6adaa2d835521d0d13b3ae27917a48e3e433d0599d0b5d323804afceb1eeb0634fee3afb9cd62c81c9e5e58848f468ad6900ac2096c16043244096abef8eeff559c9ac6b5974fca475f5228a826c862aa862d216fb23019eab2a19a0e5dbe36ccb8c39d0a5ebe8cb3260f665cd37709a46cbf694eb1083fbbc3c3d499829f20edd282e5e771f391361e10fd607177539b844435d4ebaa9e688166ece568803337e75286b0ca88d6194e25134a7b4e19f2105388f6a8e8d446b1523a42881e4c59851e7180703aed58bac3733f21f22aed9ea187405a66fc7007e267c4a5b4a8f61a29d65e9cb3253c3a46d2903fec54d7e120907dda82929735e48135313ee9a57aeee4e7a296a9d07f891193bd1e01afd82f4c8ee4a180d9eac9393b9ef44439741692d563d57e536f8a9f1e48046a9dbad8a5062ac52cc2d0007e264e748b46161c757980f7717ace8ae1cfbfa17f4bdd02c87f5b469dc2b239539c62cf9adf3ed48350a7f1cd7c18875eb9c20c2d8b710dcd1664907c5591d4addf343905a5c3e355ccb2e66cd68a4f1708c95dbd3d9dea16f5af8aaac2160a021db8f01b191a1d82a2285041bb58b5979d6d91a705a62ee825cd61a5b027c7c911afc8590ba3b7940a115b6be4d3ef87e911ed908de5093102021ad57f0284e6909d55f0e8c20ff0dbef45489d570b608493e1758b400b47171352a05786e2c86fb12967742334b069b0eff3f62e1f6887bc80670cb25aee01c4d06d6806dc22a0a47f1e6ea9323b90e9e09621735a789e2dc10d909798f8b387a1b8ce1522c3ee1ea99fb8060e0bd534f84208fc20ab5af6923f5a43b416ef72d16c36e2f278090f905c1dd6727c41ebb2b636dde4044372e0f012723ad8b705d5e8fcaf7e347364b2d48f473c8c5826dcb8db2bb7f0e140afd8196820dd46b7b2220c6fb5a429d8d9f553bd5fc5a60f51fa9fd3b5f91f9e42bbf392ce8b38e7c81e3de2c187689d87bf6783cb753b761d8dbd7ef3f7bfa00ffaa0b420e4cf6e53690ce13ebb2b503449670a807aff5a2de5db1c85ac98202c4c0361c550f35a3b7c3a21b612f4258c4644a1830de70e771d59d17d6d43446ba8c6902686c11d60bed076fa4bfd1e56dd5ec7d8e15f7d0fe328bd215321ae7978fe149d7ba4625a3653014e4c8b700e7edaa4f1764ffe41c203d18c8ddc3c6390b76a43fe6f350233cce6ed43d91603983eb433d665510ba8995f627e48141bd72fc223638ef8ba129fc927b2ef6a5a2349d4ed19c4beb056cf02096594b03b99f99f764216df527372580f002716fdb3e9e33aa3d9981ff3b63690eaa00b6fd6715caa0f4f6f82ba6445f14baecb63f3d4615e12613b246be18ab86d72256eeeed08ac9e03eee7c7b163c227914ca58eeaa3b03520dc6235aa9c8aef44c1107eadc8fee068ee944cd26de58066bbeaff6ff93671887782b41b32b5dffc4f8ef6e142e8057fc3e5146d42e08c2303de935f06824d46b24712cce89dbb14dd52c1da263557f99c3f687b638645c9a335d66aae00d6cdaa3b497309e2caff1807696c93582f8c48dc11e82e6d38be41eb11eeb3fff8bf404953a0cba693c3a543d39f8748e863fa39911f44d3d01e53985eead27b8ca12890ec574e7eb22385c3e24fc6c8dd6a4eb78f8b73bd37ea4754447a80655eb4692ebfafcbfb9ffb9692734decff9c21612259ac8d66f44ca6b0a18b62907b644b4c401e074126ae2469adc7423c2453ff4358db1be2815a087ec213792a8718dfd35f8367603255170e57b28f55721a096d191e81fff408b4fde3719b768f50b5067e9df44c2202eca5b7909f93729a175bee1b9f6a07e20d8504c6496bb6c4e0b9bc2672067bddde7555218dee9ffa91fc9a1c49c34c66a9ffa851129778557a3093876288165b12ba39f7fc5dc72576dbc716f839d1e150f789d97098eac73c95cbb866feb8e4710addd9a04eed6983760d92d2d1da97fb7d8f44a83cf190b74a6101b240f840e4284b333bbdaf76948d86a3ae48923186d0abdbf829b33b1af419aa7f9b36bdb56714926492528464af6e86186f61e7da825464673ab5e6e1b9e4b41ce0fc530c8e3583b7bab6937c2e01db5a8f87f88057b761e75827c690d13f7943831b4471f9db91bc08c9a1c22f223f07aec955332b8471db975bb45e45bfdd91c2752b315c6766bd64b31be52a98dafa7fb16d598008b379cea08e8964cbc8720e1acb9443200c5fdfc39d63cbeb7dc3f7fe9db4b1b713af97b6be8ff3e4e13c1ebc3c81887cbc8ab1de60c300585c30f1e85d1f7b5b1f794e500e8b1405fe2a6a2abaa8e74b17d2decd920edee1d98edddba54da8555a5b76e8f00e20a6f2fb52d6776a12a7ebd7c2e69aad9fd166ecf01608a3fa440d45f997d3b877918c24b0da96867d2defc34182d279ec4a86d735f86c2c696e1272901952364e949c2edc85f0b707dcf1fbe85ce5274191eca49c18d40f32c15eba07a886ea3c8dc0d7e74f7ea786e7ad9688b374c8f95ad9d11d53a9d9b03347814c4af7777766687a9570db56fc2d5c44fc6c19ba7f2541292abf83282cd1123c0f9341ccf4ad72db71087798ed479ea1a8687374b121c22180b1877ed303c61effd583377edae3225c46df04788d5596d03547fc49c718c21537714e8bfc4b0081ca58498282e89b8d84c8a80a5cf1bfee134f50763e31f0e3bb6128e0342667a8a051991490c8bd6f971e3b92a5e1af6755206f20a150b93d86a0619be6fd131e5a6eddb6d11104d414ec708d97a17e23db80707c9d1728eb955d9d393c7c156da3b798e65f9d7058773e4f3e21d268ccb6572f77c23adc8fb8791e8e2c4a72ce6034cb806835bd3e7fd9a6108c255fc4c3a5c5fb618843bcdc68bae61f49b5005c6b618e67b9185d017abe932df1a15b1339d41c0edea01dbe3e143c22f18bb1a1ed5e4bc3a628b15423683ccea7aa55082fa97c6722873d9c9ed7aa9f7b85ab9c93125159baa9d1ef6568806c8eaccfe848c374c871fb7208b859610d78c7e066ba8dc700bf2d45f7e5f31a90ad959e4bf5e2016b747626a341cd2971c070a6283315d5ec1f013f5b92ec22065f04e6a3b19aad4a41bc126a2e43bbd5eb09863d81763169e6152e6c7557bc5c5b3510457c24063e27fa4e89070eac7fa43c0de58906ae94599637e8b1f6435d02748b3891cd6669cb0dc73b2f0661c0ed670eb69e2097a7485f05265d47accbb55d4ab41562bd34cc8a004019045a1739fbcfa777a9e36798ddbaf08b2e7682b6adb1421b3a3868aa566d345dec12fb5540538d80c7a63c87b2e00b80c3d8deefb88951b0cfc5131524db286503a1002ff39c737f3b5dd3b88b19c1b5e3814e62c1ff8515022771c07dd3ae4dce0c6d037fdec057d8e45669f05465591eb4aec05e87c6a00e63ad1c009d5dbc8369e59b91ac263752088cf392ea6e94d135714940cfdedbecb2a16fd870fde4e9c0186b8829977c6dfc682f022462fc23889aa00539d942b644a7859aec8b378d5a0eb3014c9c8a2e67514a36e4b76ddfcdc46381674af3b8fb3c3a981a15e2474b78ae08f3d169c6c179b637c7637ac25a4a6124ccb8751135c14036ac2f57930f762554df046222d66c4362df10a2c1cf45edb1821c72f242d251218d9dad0226ff1926144215ac60b3d742a4b43bc7fdb7eb4d021fdf23f172f1706fbd64baa6a961669e38fb2f4d7cfaab12652825fec9f9e0214be85e2a368e469e95a2dc36720565e97144dab9a9f51b5378a6e936171789b60f539c5f29e18c5fec5c89a59ef3af53a65c096cd80910a2e1f61b7005faf2b689c01fde3ccbd5c16d61650036a7c3915334c2ccb801ec8549090a2a0181b8a6321fba5125ec051d49c701a8261b315d6012e0f940f1f57d7aa6d97f58cbff392d2ef00e4ec9748d09bb59c2526ddfd4eb537d447aed216510536ed261c0f5d05186552c06cf09c28545a2c46f4548f19453f29c5f05ab7f5f65a56ce4544c7d085461f128f336e7e13e4a931984dd2b348723ed4129247792c8d9fb5bfcb76eefc03393f0d596f5eb65a2e5871be412f284083cfd81fb1ac3a2913e32edbfd3b78e50fcccbb68c4b925e3d94e89ab62afaec88f24a337da0f9e094b93537244ae550716c88440843094011901b5691d949bd2ac5da9f2f3c9fd2c6db3e4374a30d272fe7bef649f5fd4d2d110e632143e94ba9ae19c3d95b3ec6eed3311b5b59bad052356a85efa2805b6dd5fa6c4c8c2d235ac25e7b052df0b5b344281406c19ef1f486d94af1de972ab5bae8bea4a2bdf8c5bdd1c28b8fcdc1eb85f478395b9b576753ab4c265931c09b6cd54e35754559d8bfb92cfd4f9be692c7a08492f5eab51cd32922bc235dc4882ef856b91e8df99986d562eabdd7b4a6f33fd40bdfffeaaf1bae0245965acdd7c6c89452bf74e6eeb4215937f7aa4e920a5273174cb0b6adcc70d2142f529024b561be4c55ff6c6bbe833d4eb896e247d8b2df2821e8540991de1c49b70981b33f16706083e7c8be22a13c2ca8f5422ed9eeda8300b4ea391b1f83757a82f3127cbc32ce90131e6be3d18b749c8e60acbac5582174dadb0e61d176aa8e5d81dcc78d76ee684463a19c7ccc7ad00a19418abf7d51b464bcf011be79110e12da12307e96a9f3ad8da4575423b4d8d2d14aecb3c946a6d74f3457bbdfa31adb59669ebe995b5668b1cfa616316cc7a57738308f93a6d6a93ac30a464476793f294921f346359620e624a85730f65f7c0de3d370c58d6e2074162de357e907e53e6c95f2fedd59747c2cca081bbc4c9476ebee5b2a10634532f4e345741994b9564952c874021b22b770041e474e5e534cda9a397883721566e67e837dd6a31f87b7ce59e0a41456477585ff7d40ab02b37671aa5a673536846b06371177c0204df96f80ff4e90c011f0a55f04beab17b154e029d5f5af9282dab00ab3c4d6f9378e7b67c167ff87458beb338e1cefe639b49d1d60aba3dccce36ab9e44c08b8a5fa1a0373e00a4c6d855de1c17228db9dbf66023f33853c1ddb9809175f11e2f6da97a7645fd6df5043e1af7314a73dd39f45ea073a7f43536b0eee7db15fe04e04c3d8decfde437504d5fe28bca5d9bb3c71f87493e6d02edb1879242dd491de30aa90416c11e677bbd4ce1f98e0eadd7f16712ba297a8d6f5642f0034dd7c8d0294582b0c9baa065bc60a8d5c39e1b5fc86edae40460c2090a839f70be040b56c3fd92dd9a069a65c3d5a67dd6b4b35d6a074f6bd2237732b59f5e0535377e11113a565e2294ce23a5d4d41011283b74e546d5d6afe3175a73b2eb8a47fb693a7ef5fdad0a058327fa1d1f5cf7347cf0bac0acb766f1ecb9421b606c06039d5804392829d0f4a0cac4951da914c5ff9b9e499f6f41c65c1e7c419bf159b6d9bda5ea7db93e382fca5ee1381897603937b0458e15a81d788fc2189726a82d5168034cf9dbf4c50bb3f7b7983b2eb0ef67a329773cf38e090bd25cd4126682842287c5e749e21fe6579c9ab237e2ae533b2f188ed2e1fff211065e1e92005fbaad58ff1f3ef7139cefb1c639dd94910a4f54eb649e1784d373d53dcd5715db8952ed1ca3462440ab79b41931a703940014107308902bfc502962b04d1cf31977a04f5008fd59ad259d372f1745f89636a2b637f47aa3329ff1003ffb102891474ba102f1c9a48a09bf11f51e3633215cd4c967a7623513c7d8f036c4b13430bcd57371cc59146cbd847c6124bbc011962c1df8e30dcc98e003ad68d910789f141ac26d2d4f2f7eff9e2786af8b893aac01bf2583a4c4b8abe7b0ad9e4747ba66b3063212496c3f72135ab13e786b149024edf879bb23938cb228faed20ce44f5589c4d1a647c615303d80f48c573a1f16b2a4cc296978d0134224af9bdf676c73f491e561aa984902da67894660c57856521ff4a04aa71f005dcad54c1af564aa47524f6becbcc024b9c24bbb3f138daa6687ac846c14ae196f7d663212ff4dccc20f1771ca3fa9cf3e2090858a7fb978e47e5b209b44c2f03eb4dfcf954c31f5122a5c7ad4a4bc99e7bca8506d49bd7cc7a2c79b27ce14ba10f944f037de0a2a254b8c2b197706e13f3b646c11a8e5fac37dc2f7422ea105ec6eeef12371785abfd34632b077759f430d22e69c6b7b3cfde34f0f97764a6981d1933e783fe9358b911f7a4a15126627ee5ff746f0952c0719b9a11cf2050d5efdd9d13289db1dd52e27712b77c1c1db0c710bd23dced505c39b72fef86d3df1d1d298058cd63f07bc5b410ae1fbcbb11190d5559a24b16dfc7fb914eb4aed1fb4463eb7c98ff81ae4291cf32090c709aa3b2755ed26214e8351e38b90f3c4a342189b75c2e5b5d392d0ae3a7470a8d3353531410b1ac113377c422e1e0fa383790ed5a2f1dd18d6295737ea875b25d10372cdea5aec33a578f5447a1c559e00901a4a7a33bb4c3f4cac0e321a6d99727b7c71565e7941572588eb6e92b1dc78077720bdca6013e34e0d71882bc8e80c4161ad40384f19b9acf15178f301efe66b8425ab68b25f9e57a695f665cdd01d56094c02610dcfbfbd553604845ab5241ab96f9d6d8a8eda4d085bed1854794de70b2b013fc5e18609a1eeb770b72c368fef9efad6a61db5847dd865475e4c9626dc17be7deaf0e12b7f4099b4509922897c30b46f38eee6cca5b875d80114e9ca12a07ff0163e0d8dca9ea0580945052a17145b629609072957bcb30bda0bccad64dbe7e2aff2f12f3fba1bc1997cb0148bae7f2e68d07452f8ebb71832c7044b069721e1f86c806ca02918f7fb89f983e331e968544aed0f8a7df7f0ed075085d5e30dac5380459368fceb683a2739577d0126bc92ed6851ccd7d3b05462150ef75c0191dd6fcaf830fb9ea834c0efc36fa9074c27d917065a82a46eaa7fb5660e56cfb14529040ce2294e41a2fd505fd521df763428495d1aa9b4b02468bb8d0d9587093f017135cbe6ff34786c7e4ead6ea1ea7ffb2ce9119fc1aef49c91499cbeaa947e1004772f9d14164f1b52c59d49dc45c3ed1b818f632dcefb0e8ee4b722425fc4fb8d445732dafb57413637b4faf624264e3de3e8dcd79117343a1aed0ed9373f18aabcb04aa847935ec3c4931f84ea8787a91dc09960787489ab3054209b74a003fcfd9cb2ac873dab47bbf85f6f140c1c79f928a5a0c050a6696d3128e1f45f2efdf33c3232ef6516e8502c39a97ae58268b4ac7cf58188c888d2d07c3b6987b4ac910a7dfc727673e2623af5357633c84d5433c3a64d9b81972acfcd4230c09b69cb6c6a2f27f7791376d81bf5d2bd1cfefe3dcaa0c13c4b80506ad444b8d4d0c13971869dcd8846d90ab2d4820c904bd2a43c97f15c20c8aec7aebeae7f5f7aa33f3912cb366373bd55b53e7d1d5dd13d2a94788c7ce405456a2925c7802777a2202e0b2851b739c40494b1d262ff7b36c782efcfbe998bf16175bb309f6c33cb2e5029efd1dfd17588e2da481e42d8636d7d6de1198de8c8ee9c858c1330f6bbe94589d5107bbad261592bf12732dd68a991659a3a266db71f9d88e5c63f001ca1f022f775d0f3e621b9f49d83f18e98bd56c199d02de6a19c3e7b71e273e6553f1b4c48e25df9dd67cbe5a970bb336a63dec30e27cf4cb72e94c1397d89b4f6655058639a244f74d680bc2baa71d2feebed6c4d8cd463743ecebe172b8ccebc03529ce8a70ea0d14acae9e05ec4149f2295c8970ae609decec2e8109262ab784fa46316f5d2206f3bb99aa2205376e320f283676029adc20ed879546d9b0f1a339f7d01c1e28567dc0b81d3897874932f5ed2f38f1abd28ec29bdc15ab3a4adfd588f624ec3a0340232d4c373726a422f1a991e2bc257796d49c236db3b5ac0e03494101b7ee7932b40d76046a3c31b638792a30aa5e8370a9d44952f87fc9d52ace2e52ea8d70c1fc02c6ca2ab9a8a7aa32c42925c5d5dab8e6122aefa508b095231a11156d05d14c06cff1e23d938350a44b8dcecbd1f60e42f5dd326cf9ea58cbf2e1b620c2fc9d68ad5f5108f734bbd0ec6440f0ba1b2afd46702116611718c79171da239a14a4d39049446f8457ee36d2aa54a63e4d4510a54955a7a12f6bf0a67c277c2a0a564a014532f0f2cc4cd76feeb8c22aa560546b0858a3a2d552efdec45d36b407813d695a505979c1da5f53f9ccb69d4a1c56b954dd05b06c20325e2db8df898370fd753412a5ef0a9c59a4ef0728a8b652e77fa7bc1d3e630a769f7ec9203794f135a541544fde2b5922f6bb6deebbecdfc3b7546493d31996b0fce2adaf0bb41e5d02508a4dfdbe7fecc7e43ceec1773aab4f23e56cad7f2fa9f07729632fb98ce7b2ac01a553c5e58481588506894acd88b8739da76c7dbf01a616871c0a2cf0786f8add9ab1646f02b02459c456ab42c15cdb04326d3033b8054594791b0f488dc417d69bf7f8f6fc309514582f1811eb27f0e399c914f7221a50eb4c6328c3106a44be23ac0bdf33406776793a9a641a6b2e804d581c18ebfb53e40395ea42046eda93b6c69d24ca39d011cbf6798a216eb0a2787fde5ee30e6d18e1192fd03dafb54b17d8f7b70d98d2e6d07e98b181e0026c17bd7bae6f4bff05e4e72996b60f2f0cb9b71e21cd1bfaca894d25b6bf8434aa3ad960ae5db81c41b2aa2411eb882b91843687c694fdf9f61dfebf2cf0ae3e9da5713b1f442dd635eb1c383687c09ce3655472a898e8ec89c2061f4e70c47acc1b18df185cf49d45aa4eb178bad761b3d48a5dacca9603a8bbe615df7283eadc6cfbe27338993f96a22c61a89afa43a5b384beeb32635bce2f44502a58dcc5e726f9efddadfdc11106ee788487eee33e67a5793f513bdbad9e05983cb5a73e220136cb639572fa5ae2126168795c9dd4199b765fe2994f26558455e39a37c2a6749af05fa118b8314ca52b4c970dddb2302b353c12b76a4d4d80d72b7e8d0daa7c3bef971d7cd7cc36e92e96f35328de3bb757a3cb08c5edc0d4f979b8b9eba5d62e709bf8bc964cf55737d0480071122b424f1069c917eda9233f5c1db5d0d3cab3c4b88562628cce2c54968975016ad02ce4cd60c5d06fb6afdde055f5f0dd6d532481c73e8ff027b17c982087c96c96884e51b389c28d608f298fbcdcde5b2523f10dfeb0ffce44f1256acdf191a5673ea053e241ff9cde26412b4321c6e7cc5c3a312aa2ddff70cfe2022079c427726170caf502cd9b459a47605c35fdb02ad4f50e44976d74a9448147049af45dc3c6c349af8bfaad91a0ddb8a1dca5dfb3d740f9e9e52929854eb9479dba386a831f9f68ce4b6341cd0afd5788f03f84b86e8db0470420ae6aaedbe9174c782fe3a0326197828f0f71cba0dad30172d90622d313032116c685dd7c30ec9a1c6b2fa4430991416bd7f950d310061e745c90f962b9ea4def937299e5ded4d9448ed9ba2c7447c5855b3f628a0203bad0d3ec825f68a875a30786d66ae7ac91244d4e4b1c8681d76c27f14290d96c8be2f3d119fe8f65d037a3be6a4b7f8e987b163bdd33f646d3dc276bc0d69bf8c0a2088d13c8d4804fcea7e37d0340a5a4023789fb583e1d33a018dd6c378110f6c9388c64ddbee34e5251948bb452d2bfd8b07d037143bda8ca598e0c36b882586f5ca22bada21f354151fcb95b296bee9fb716f731e8629f8d6f8ad0f1cf8c8ed72b711451827c9fefabc174f1b25a25d94cedb719b4215c1034491a52173d48b72671867d47294d1b5eb66bff74da23330501ed28a4a164502f61df0e1a9f77abb727b000810ab4b13a06804c277dc8a14a18335252cf04c79a9989a2a6f60c2397f97b4d702efbf43450a2f92df0cde326fe9ddddecffd9b67beb3f8753ffd798811155a78080bf339d23c8f35c827d22d5b7e3bf8adfbb5bd83e020b20b61c570ad0c0f4e84b827ed75a34b68a05729a7cc43550dd8fe69553a63a996865e525cd114a1f626a19c3308c9536f89bd9196a583b4b475ebff2b1e3fbce0d1388df3edad571f6a596c0300008568178c07af658652bca718dac6b1719e752cf6fb7b0d4da2e1da7cc10529346cf8fa8f14dbdf1600ed16d35dc4a80324cbbc8c2d0a12c46212b7d5d46e70bc2fdd2df2441e66f6fefa09bab97c0079014f921bffdf1fed1060aaff2746ec73c5913486f5e3fcb29421c4c2cdd03f63edfba6af30b8e4504c913521af7cb4b69981e2085e3a7d23576d0370d5ddaa6ec25baeb04580303066419c7fc4f019e18526c5aa318013e317ef2f3f262b6ce6f852b6abb77746ef1194d3f5752ebaff357c850e0fcd32a3de233cbd4b0869c86e7b3ec7f2980337f2120921f2c025ffed5b19184d1f0f259198c10757f6f606eb49ce67fef758ee5ec395ace7ab482a5374ba3d517a48bd174ba840a73924ff990d71e7f5f0dea690cfee864e3399f13afab0551805f37720b675d8d2bbe2921cd1f857d392bf4b30506e6d695b1ad5a0847e1485b3e5b84eed52d7928e462aa4d1875ac0a4dbfae4aab43a20c121a3fe4718a5216720a0a9d344c5a80111b52f126b84a9817c3760a18196f4c387c9c7002d536180d1b738f4dcb44b44255a6d80c4e12f9e8929c2f960665b52f22998323a2621028b46b455143e57b487c0c6a9b1e17559c3bfbb2d976b22d0e139e269292ad0606ff5c568d3d640990520a19fb8421496c96f768d05eaf10558b81cfa40a983c1b5218da0dfe29dfc5c0a3b01d612f39fd4c8bf22347a05f78d8d00b48d925d9e9319b6ed03b3df9fc22c6403080d60894f23a99c9905360cd08c3d77d760ca9271efbb0d4cf9e8afbcad5bb5b40a48d878c0b6852f7fdf16a920941773636565f001a626c6f38b4ae1a04b4171770e876fcd08b81f5e05096a6ec6ae2c47faa99e18ead9cb6bafa780b777f84886bca931a295d45e205b06842d95d55a1c374e9bc3615be29428176f8907ae5438d5bdecae6cd00d75e703102e9ed9f7064e30ba1bfe02c7d1d78d1386a1e9ec17b253b2521b3b2fb63bb2092e2404b405442691c26472522f625ce7398b266a0d851aba292b953cf41a1ebb766fd63f1f4c32dd4539b6120f88c1f37bff8ab0c032edcb6095e38d31cb378ba7654030ef1e8607b4dcb9a524e2d324d3bdc0bc7dad93b0d69db1530cc4e31a355be186750043d4acabb4cf0f0f4732e2156aac2335e15da41d92b9a70226039968dbc0d121ca38327401145c330c4d822fb7ce544c877906f7743adda88d799cac1aefb4abfcebb50315e9ba4553e4ef49377d489a96c954f95f4746cb64149dff22e88da0938ecd3e4e1a09751b36e2684425f43267230c9c3b00d0dd1eae9161b7649a4f2bcc7c9bf947f755463fd20e094232d6e77a06de13baf83727aeed4f8d16b8ead972c2a9e422fb2506a8b7a25c7183488960af9ecb4d162370e17fa755ae65ae075da5760042e89b8c477261251384e7b1bf89088961c828b3f316d6ab2d3f994d6d751f00c8bc5044e090b416b6a420e9f31eda1ad057805cd69ab1d5fea624dbf7c97905dcbaf1e09edb175f09dbb6c00d9e037eebe001e0aa9f63b3004921048a96e5423a6a30474477da676ed8d89d7f25b930cd7560f92a60ce782f161534b40b4e5edc528d5d652452bf5a6664f6063c2be8c041e766c9487503ef44411240ff3f1236615e38c85989e528b7c31a51216825c29c68d9b917ac52222437c0723bc06e8d41036fbb4e7c57c970a3950870bdb84a1068deb5442283930a21b6ea26a7238a834871d0f28b4e4271f6690abf657233932ef3fcd7c5e99d2739df59","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
