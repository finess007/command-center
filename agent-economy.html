<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"419ef3b921481d05927a4e137258de30042fc1a162edf567514714f8019f4b825e9e00c212062c03667b32970e0a6fa4a8c82213cf577cb000c441a3116794a60014d188206e5acea6c206618cd01641a5a12bf50b62a7b659e69c1e888b90fba782c849cb8f416f68d01c0fecba2ecb0807a33fc241f309c0d2ccd37e0745fe1997e462fc199bf3360f7d1a20408760792ec965e9fa108606e91f93bc5f43d7fd30cf0b43d15309ba7416923c021a8c523245aa98556b7ca286d3c7ba9aeb49a3b944f16485eb677b60377e0e68bdd2be9ddc7bd9669dd42fcf1951501257e98754b51c6e2370fdf81d92c0b8ba28437c3a7634eb5fc5214ec4b8af19c5f47ca35bc080df2191ee07374fcb0d9f7224c5f007f41975aa9f18594f224ad8343596a9b5ac32cd76636ccf12d1a172abbecf8a1635994882cd7e515e1b4a257891804c68ff0302926944e1159edf1aa858db805902d876fa4240c9f1e9607724ec68f219389afb1ab8becdd90980ef6cd079b0701c7f415136efa4f953f6299f6431199df352a5b9b6f35156764d3a53d971c05f483ab4f586e57b3cd6c3cc6ed2413cf0fc42319ca75231cf337459026f3d70ccdb3fcc7ff0f9764b01cf3489506bab87109c3d26e73cfd81e7bb7f240c5a1c04dac6ce6b69b08161053d6f672b976eb4b1109de76165806f07a107066c5dc4ce7c37cac71dd3b57dd5c719e703518c7ddb1e52f9a671eb3e5a4293e185de068cd7e13410cbe354a1d018fbfbb14613200c4b8c97245d0c9fbd70003dfbca83445b99451e85bca70bbd66df00226f66b6936f3542c3923fa99a964e7d8ec5c5738e58e2fbdf2481eea21106a186206448ad3241d85f24cc100c4cef728d13a5d281bdfced790e69b9b3a65ad78deb1a8c34da090c238f00ec445eef567348ce0e8c5b97e0b1024c0f15d1682552f9c9515fafb3238769d25aeafd1648e093ec3a1fedf83d941c5b6996d5e6e6c3daa863e00a0c511b675bb77ccfe7991abbd84b53045429ab6ba6919a87468d45e252f8494c551a903d20f1215b409f4e6b6657f3d377702d1d804d7d58f757a24254d085657b034b58e7b9cfef35f69f2ae4e13291eb1ad324abe0675415e92b9a016ec5a72de4b42e1a4afc5aaec0cb124eb99f360633e589b0b9379196f484ab3717d83cc115061b6da535b600475e9ebbebde0e5f5882518060b7135e6010c34028917c2310e53d886d43af4ead31975aea41ca16361f259f042c3550c3bde1d0fa6a87701d25336a4e048663a71151eabeb868ad9515ce7fcba399b0a51a230140155369bc1a76bb1582ea74129a1aa34fbdff127eb08067da0ac98bfbaeea0ed50359e19ea7cdb53abea6ea065a20c0ed6bde10f8054381211b045252e08db6ad2d4f0f819290e6621fc9e686b2b6dda2d9e877645ceda0e899268b27a30dd7256dd7e4992578812859c10599823eef92b0bb477f022758217621b29bd329cc39a8b94d5934e431ee00c34b4c762e3f1147bc928fb916dcf4588022bb6bb3f110d09d89b38ccb2c9c4190dcb9ba5d89e70af75859c84d71c663ce506c87dbfacb4267f54a04042847799e3340e9e81b9ef9926ed68f29e8729cdae97bbab22b1fb2345c6cf95b8e8036c29a8ebbcc1666da841386c5a7d4a39f79e835e28bef043ee2a1cfe4722ecf02bd9315a75f12ba61a690a8a02c0b5411c99da515b084a8c0ce7a7df0e8045c96fa556dcebcb624bd7093063247474893f727ddb9937c5f18856f0cf625bbeea23301435fedcb12373ad602ad99cbefcbe895222a5ccb8b0809d5be9791f571a864ed70097a330397fdabfb8af09e6641d0c69b2dd8c3d8605398d6c72eca32d57e83228aeb2ffb5dac06cf05313405d679259822279205c4283e2aa31b56170ee61f66c00e73bb4390247481c13499e0b9548c52b2c1deea7197fa2de800cc5c1713a6dbe8ad1a3fb8d9c390f8ee25a7688664309f3bc43101ae3a676488bfc358008ccc6f73797c52f5456884c824db789bdd8018089d064336fbaf201ac6d33d6f752f2e5ed1814b873b1e60a40aa9b95649edadce50b5c4f2efb544bcfdcd87d1fa641ba899a43c8f6e1ec791d884e40665236e3cfdd88c139aa9451c5c1157955cfea7509cfa5d4b5ca4ee0e4581533820350839ffe07e07204f73fd829df239d6a45d1189bff0475258021068026178fd31278e00897ff18c31acc4370ffbdbc903b7889338fe84b4a6f4aa2c35ed842146a952c76e6888f18f24323b75307cbd9462faebc8ad089fa5d0ade2cc4971a81eceee68d1757ab29a346ab13027cf4e63d9a8ac412147aad4f1dd2524e5d2d871a6bee74f34293716641c5cada8f1bb9ae6b6926acc2e924cdca6d77c6e10b99cde029e211fde22bd87839b54e09382fac9cb3948fbe40c90159dcf96a82ca2e1edf2ba3d5845f9bad72269c8f5814e7335b955f0812ae4d2767e9f072f01bd856c0facfed42dbd76d5f1ade89cb6350f4f1c59f046d543fa96c81e30107b383671b9f40849a1c3bab0ef7ddda0040cdf9d970860ec5531764d5cf414d876cb2c57281f06f27823799c4f0d0ed9f4abbdb990526c84c21e7767c92a90d12c3c8858bb6bc5ad98a47b7099461dc6548d3125b86b31c6791c662e41b3d01c3da7b5a82883616913857f3422a4e3e8e2c6786d8852c6ca42ee1874a79c328663043dee3d18f4995e95410bf880d6d21d3bd8d247a601b093794dc8b852d15bd0a57005f9f2607d87256f4cd160157790af23778b6ec344d9e5ba03934960921848c804cd3de6f45bffc6ebf6660c87384f66619301cca0f54fb8b7027cb5eb43d854669b47de3cf221331e740ff4b2dcc95bd6b65eec8def0c40d3bebaab354f0db9b157cfa028df14682b4b49b3453b23da7b91973bb019f2c841fbcc33f02e99de4784b21a54a80bb6a5d0b9c4d366231071278782edc68ea6be31a2a0c4d62853af0e273cfac4743135cbc52efcfd90060c28e2ff1c3944e406defabffcb913974b37d1614fa994e43cf6bb0e520d664fcd273b9de6b69c0fd916505076a24d411742dd6e98f665276184f1f23a90d66a72bd7bb1512fdf636d7a326d721be3d7fd892576cb0b9602e6d2286e704bd02ef856c9b833879c0d280bc14a424108cf56374c4f092e0199d9a2636710412c4e3c3e38839ab2b0477fc773366dfc6e1347a37b8fdb727cf41da69641beb4b8c31a747d62a10bc5f161e2b6ab18157e357d19f7032c0959b659cd47b15ec4c9014bd73d949dfd548786140107097cd22e22e496adede08e339a129fa18bee306302fba14776851f70f5f70b3338d7ee2c1e2285fff226964d554e7d8554ac763ecbd5410003977bed4340b47f8fb0421a3069ad5ceb237d4292aa7a338a0eb173f4000c6a3686a860f3a57fa7ee564e40549aaf86251d1429c9d654e10870095e1ded8e0f47cedacb623a9f623b0756164b2a2c50c2fd521d2fa6eb69793bcd7f41c816673216859c00c0b2fefffcdde19c61876345f583b0d47ae2f3b90a5d3650dd57a5204221764c20046c378ecb9821661dff76e2f5e39613b0efa51d37eb120bd5ab790acbd157b8230d318a303292bdf16a871014354780020206d3c93b56c98a76901474802f4bf9be69114da528f6f912d223fa4462c9882cdf3b2102e9cfa1a89ce93f9b7ea10de587bee6f4a31e1b9e51862340db3a5b9d33c9789ff953317a3561b8a42c36c703d4c21969f6b92a7bad4d6acab1f643661c81b4c978283b67b2597d31e3af57ecd7dc58527b8c46704ded22645fe239934a3d673233a46a2952c297973f8b89e299e70ba80b841928613270c12e1182c93baad2c204a7b639cdd55f8d3163f6e57fe141ea7303398e3b78e0168c99c2ffad4172009834796a3bd0fe0d166f7ca352388950367c1ad190b739b3cfc0ac8fb5fc7bdcdc59d0207deaf53693c948f4d900c64786e379a3b8bddfb42e5ef2494a96373a9c960d99c81710f0f498964c1ae4e61537f802f7f73604267e32727d492d2ff9452c167839fb0dd5809c1592d2acf555b0f68f99fa0b6bfd1600858847648a63f666876c0333111dabf5a90370838839bc03f6c37093f13707bc6986c2383035cd453fb1dbe88b266924c3239d565234b26ff2f9672adbe103c7b16bfd0e1e1d972df35ba6f296e7cb8c6d2e99a418e4cea0d10c9718f2ada3d5ca2fc80b7c15bd9a5b1ea44a2e8bf512be040f65244c2995aeca13974b7bd7757853c0f7fc0853b67425fbd0bdb49bd89f361a9c306e5a4d54e66c5c688318bee716bfad8fa4c6ac3896d0089dc92cb51ac5236b2335b877f761c570d0b1658d66c091b741d3939ede7978ea7f88066fdbec195cf3ac682d1305459b8716eb2d4853af2603c0b5e3567a1ca11e6ec341295525efce931faa701c8ec1cc96b1b32800c77471097aaa784b044363ab556e6ba9cb64e6df5ba51da492e6d40f0e1e14018d3513286d618b13948073d68ae0997927d00c6d0a9c5ad2ab2a3aee320e71f60a48dbbc664c7253051a86befe6202ad79e3008ba79a6cf930c382cc18eb37e16e688eeea6a6d6b4b5c5bda836c8baa6507404ce20dd6b5efe39bd61a37507a108c18aba5135831df82a4f2d37d2f6f200e40a40abba9e9326464f1aba708fec30a0f9b43720cc3fd0ac359b6f41fb9775ecb50cae6b669c740be908136594d0dc5f915cc1a436bf60894e5b5c50ef9d6a2297b7db85ddb3e618e948561820a87b86a5ac9b952791f2abf1e420dc5cdfa6af02337635a27885f5fe93f3bc05c5d23e79d9c536b7f4b245d73919161852ebcdc07b74cd51f539bba31d700dd4712cac15b8edaf4596242cb9eab9aa23ede8840372a0dff2aead676128f46d258bae641299647b8134a09f2fe5be44fbfb51eb9342a8c50e90673446870b57ee695460f1f57d4de169e52390930e46f6ab03724cabe78646c1a0850c2e07b59f8775f689a17d752db8c026d33fc86f24a1ccfede8c4942d6926eff128b21cacc8499fcfcb9e7e470b2711c5b87cb1f0ef6b07201e1518b96dfc613ee8854c393ca377b219b1e36fc1c5e52160d1997325a73dae3986dd243984952f523e5102242903af6308393149e28285cc7a0d0aa9dccf72b1f6411021638bfe60bca91fb65be2fd37730de17a76b6268e2e7612ba32780abde59102e853c8974b2fdd556231459c37741a995f9aae08cff48442c9483f4578b523ad9d679115825e78dee7658e02ec7c9a3700f5b29dbd3289525271e5da4ffd4b69b3dad7d2739e294c3b07b46e29cc9baac95d3a170e9d8ce091ee4e48ec99bf8415ea679cd369dc71af3132d7b932ac554ab80dd77b303bff047e817ae4cb32ba48f1f9b52e29ac7a1dae0674fec8bcc109061c2a76cb88622c72f2009660388c9a0969d6b80ab9ed51b73f5cff82c8c79ca2cf0e08b0f2bfa1243350f604f3d91c13a5855a341227967c08f77a8f1c46c61a1798d2c142e1d16288d843bd2657c540f9987bf7b002658c6c96659d98c9ba720be536d0efa499f2779ace6f20c065d6a1f69c91599762eaa44e0fe1db19bf90c4185cda4b7b9ccf958f962b7b00a94d5d3af2daa5db5fd42ef09f3bfc46157cfd62903a48d868582efa5f440614ecef5511e81736918228ac397dddcfa7779690c343317e63b5a687760b0a3650aff24ace9a6c62e2e0270c1dd36e04ed97131ab6adb6514931681292f2f815565a80ce3d24eb3d7743406a95a69bdcd4debf18a8d42c39975f3955ef308d18ca8cfb3edae838c8ea62f4b9d6d1a43d6fd7cbf0e8e22e96a906b4e7473c0981ad6f077aed8b77e3aa508498899cad86d5616300563bd4e2cf77c0d32f7be49e0378a372fbf42a9cfdad7ac5b1939a37b5b8d5297d4c32703ec0fa733bb16fd8fca51b68983ff5bd18b1bf8f6fb3e80477ab72745e9b66658e48695d107a64c7542f66eb8b82c7dd17759a9eeb88d295fc5e8ca7b7926071c286653e861b31af358191ea9976ad20be25609b0b1efe7b852adf4550165f1fec6b5730a1ec8d4a87d5de71615acd3d37f624a981a3ce642b4e7b926f93e5aa8ba451fb781d6e09e52a7692183e2e58b40b0a11c9121f6ac0e36f44c0c03a56caac59f57f31f18d6a7a555c2cd799b3fd0f536f85fa0e2911553ae9ab5936557aca47a15a4d46cb42d22d0df11d4dd9558d0bfa2416686df33db641cce18396756f9ccc0319c930dc040913ab0f15a1516d0c5e490a79d9f9375bf75f1e62e967dea16935707970e401a18c4ec284e141cdcb10162d95c58aa00798adda3e3490482d97fa229a2228abdbd55ac04a324f3182463a54266d02b493663ebb213ec0a8af8b09a7493fb276a0a5b308f7dac8d1521ffa7b83f80ec05ec8841dd239a81453ba9c6e0c6ca81aaabe1b22e7019496dbc2e0ba50bfab353e1200c54e3f1b6be715303ccc6db5dbdb92035babd6dbc79581ae6b6d9555476a93053ec3601ac68cfd300253c5b040b658aa85490cdb2704865d1a260af4b024bfc6ef18f9c24ab51a05074ebbe69158e3dcf0077c5d90453c5d0cd09371cfdca38c9e42c2fd0b45958764e07527214517fbedecbf3cb2230f9cfad1a1c50393fbb378be74a1e93ac86041dd8764cc24332c94f0c2390d0d865df51f04e32214a7c5c2d58ae4f6a6f0abfb4f2062e304538f106e418e30b327514b309e645a99a6e5ecd7ee858aef54688fa048a78e96abeba64c7c790c4b24a0fc805af4c32629559d4d1fe7e74c9ae997429426c98138274456fbe028a60d929c4c048209081322709fdd41672d5fe494dc2d1e56c7e7a61587f4c4865dd17512b0533da70110ec14af3037274c8634f589746eae571f4e28ac12484efd17cb40ce338fc64010e794af428974c3c6ff1d92959bf4fa040c99d7c6aad9875cee89d39440060fb786d6e52bf58f96a90f4c087309643799646a862862070e3242cd7fc20b89fc6af5b0ac60cf81ba11df941dc5bff8542f587cfd1fc06f296e2b5f532dbcf88d51faf27936cde31d4e79542ea05bed1ac1ffe13a74729b7ef7fc9160a87226edc525e0a21a1d0c673767c7977596edadb592a81460547683b9d8c8855dc759ed79fb04cb93513d681c83238309f31dcc5d6de8f69c04b933cfc5891cce67dbfd7489c1b655754829e2f8bed8c69ea12e36c0dfa74b8d0704828810f44da3ae2d7fb1819e5286aed459db046d1686451d4534088d83f28fae84dbde3e4f5ef10cdb5897f5127e816373f779e2479963fe53464a31790d0ff171beca775dc2f255287bc86924cc55e5da6193e11f4967f0c626465c78202757d5e95f2e24a6d3330bb0741677dba6409edf4f7397f4ef64abe98316e14a63270364578eeb5ff1c87f72dcfb033a69aed35c69761f6a69abcf7d9bf43ef8544180b43884c985679910c05ee8e2b742c9f8695d45db60b8906d13d8a777d242fe64c481ba1540d0e88dfe04ebbeceba7b2920d824f5c3e06a0e526fe84f802bb55aa1442f70f8ffb424a9780aebb6cda232ad31d28bc3a5baef5d21329f8678ac6eb0e07a5c50886555199782243ec4c4987d7ec67ac7a877b07a767e8c694a644e058fdd70837cd5c6bb512a8a10f81c4d978f45c899b84c584620ce8a1bdd666fe6a04c6712b5bb133cb340c81ed774fe5fc3ea7007c5bd6d8e7889fb2c984dd747af8438f61b1b111eb434f8e91f2cfbb5bda4b6adbbec611482f27961b50a943d2dbcb269aee1e23535eac47ba2051b9c26e504c3fa72912a17038def060e9c17702ad44ead55099d57a8dbc0b8e25fb74c441d0f0b94e0a3fc9a229fc4f086f35fbf5f057899746c80a40363da9719ba672d23507f06e4bb5275df1c690b3bf9b461a78fa76dbe77b63bf9d4139cd75c40ee340c2e75ffffe9bd7bfadf3fcf0f94cab9c461ba2948b0df42ef3f407aa290d3bc41dabf081a13f1afc7703f52c5821895fc3b4447d18787c1ff98e0de0725e5f7d173391d769ceebc5e3e3cc39b45f9d3c998fbb91763525f09f3073526712b79164d4833cf1b1b665b0574c79a4dd5d806d3d701368c17e32b19f1a734f420a1b664dfed61f079135c326b6feec1643c5f5506d16860111c19563b32b9f2c98273b516f6486c6cdfdb333f4eb350185fd8b5d94b1d1f21caf675d88ff459b9b6dcb08fbe2c66f66e848c7c18462c130a0fe828fd0a99732830a4a2564f8f7d83f21edc88bc733c0e9b4136f906d77c2b663d3b5d5b9c532afe706361b0eb7804143ce2640965556d2f39e8d5f34c2fcaff0c5b59027fb234a8f219a6ecf216c41db844e3bac76cb22c9ba3ae6ab18307da8eaa61dc8bfd0020ccb875fbfc6a69ba1d542f8ea19007867fc913a5ef0e0ff3289fff4df109faa1f7e8f20850afcff321e69afe33710ec31e4a06be0296366f21ede7a1eb5e148e4ac619514562f9cfac0430049032b7da538fadac38432c231f76fcf63195fb80af2d6983cb9ccedb92e6389a4fe030dfe67517e554b622251aa49401969bcd7c99187b978b7782f557c6be5758b2f07b956c8d88d4c07028bbf92cd1dcc59329cca0d45f211b974a33a3c3813455358c5ed4480447e551c940d39644191af5965a5d1064a195aa7e41f94792086a7b891617e1631610762ad8491bc6d3a93f66a47951a22506abfa70cfd7aa1a652d9ce40188ee3aa46fe4cc3583f5520e4099811d9be3cb4ec8f752b59b3fe27776582ac319a77670ea25b1f69fb3ac5b993229d04e44e54bc88b58b96c498417f71f89c1527ee55ac28de21f73d5619f67b95931c03bfffeafdcb434a43baf22ba6f107fbf6feda5d9fd0bdf4b2bfd52ba22fc15dfac3b8dbfc32da566213521b92b97c0b34b97eced6b39c3ba606adeeb852c63a4d255546257bf8bfe04ddf73255db22f73c97885d3e08a1cecc780a2c462948d5da3d260ba68c52428586664d974f8c094f84d24a8667158f75c1289c9e494de05c6ba5b2a548e55d38f8b227bc03cee5cb8622ba89f8c47bb226484b04e91ad45cf51e2c0715f7e6659fedd021c94e79d6ccdc325baf822dd11cbfd15649b878e923132aaf44f282390f6c6192e746be3866435d35e7d8a8878f2a52948eae51bae7320fff2fe2ede6de749b506b5cbb642c22e92bc94d8c526280e319762fbe8b9531fbf9d28940905e68dd982d19c0596fd026721a076846d60401e6eaade80e08ee6ffd659205d45003d65d36c70dd6e1c0e2324b5ca2755a2432d5155904a317aca72fbb7a521e74f62af5be9732f5bce2eead867491d48e7d7a6e1a0a506bd9c4138be95d9034d44525eea47c56cb2c684a808bdb6035186711b0be35afcc24965e5f0ecdf762dd9c86453514a01b07b6ae709b8ed6c120dc2f0d97b6a9063823f3a66ec81b39545eaca4d7770641dfb3264809a50ae7f1236917ce826b8eb254cf7ea67a360d86b9358ea51cdecad78e87f10835f2be51f59339bec2e8bf810086fdd5fbfdb34782dc0e7357bf9ae7d2edd1d33ad2eb06bf051e302a10aa22359247d243f7935b00f62c9c3e6c57b7280c4752a10c306a294dc329ca0c96dabac4a0e331ef19403a23c444c105f6e8b86a373a677bdab90f700421820d45c31db6f08d2c1444c06c66622ad7e5e54f268b663e694224e91c23144784a1ae356fca87fef3ac6bde305a1b53e45b9f2a37afb66841d9c6561b68f0c45896538cb906164d7b8b5cf7e5c8ebfd6140404d06bc9e6fa9d4c55489cf4975867eb67b7b33e4fbd09e577e5851192ac7aaf55bc78f23cba82cbf07f5e0cdf17d0b68eda5010465d7970ed0ee26d6a09e2bc88d4479fa118b270c1fb31f76e747468f42b8de2616dc1b8658d4034b579945dbf5d014b062b667ba1092e665d011b331144c1dc99e027e17eeed682f6a24a22a7b7d01cc83d98dda9c3c1c6c17cda7d03f0c217a551279c4ad079321f881d117a90ce7074865623f0dd863f89e67fe60d413e6a70fe71b8ab61bdfc92244b44f1267ba7467940e6ce95339ae0de150076b48ce962932621fe56048177f430f786ded85c7ecb7e966fb810bd71d8ad7a18c6f4af68fb90854682c0396e8d6991eb544f91a33ace5d943ffe498f3dafe0f75f6c105f7acbc69d6cf78932bf398b4dd92b84d9873aed97240a61293d1289058dbba3096f90992c4e03baec4ec252e2d1a7f917884437e2a8ecaeb3c05e9a68c64a4a09faf70edccbf1f4f42dfed80c2b433e90c1141b02ee84c46344af3f769e2bac2f98f678da813da673ef6201d86568d67bb2378673e159f77cedd7d28a3b59f10d2dd4826050f9fa67e58ba48a34fd90d0df5c459106a639dc6ce77aec72bd48186d90329f7c206a1b633b5aedaf4cd879045dcb48082f56f50c6c8ce63f5e7fd800861cf38a3a2575ee6afd634869013c93f6710f503a57a3cd95152a9734f00c7b409fe316ea1abe77f09adffc38319e833d784b0bdafab9be6ca2a4909822bd1f890b853a4f1a842f92cb6ffa50a9cc260e755535e957a4e8edbdda162b2a098ced328f73d683fea9167dbdf7d80e34eaf2053e025e53fedf5237cdebc7ee1acf8b78df32bd662de42f27f28e0f13e0ed1cd5fd89ce2c8dd96a886ea387ef782b33572523b0f0f0fca8345900c5d0fd5d392775067ad5186db4aed55e697474dd989b338cf1934c10187861d19ff8c5a1b3037aa0f732373f88dab17ae87df0566466d0b92055d3bafd64eb191dfe36c08f7d0ce1194f982c8c509e37855ad594bcbb44c74e2eb605dab58df2777f0ae5901bd46ad982219d229ec124d78ea197997631bfeb2b0d657053a59eafb45222655bddbe16a9b54cf6c6d5e0c9a50d230cb312d1d303b83408dd2917044c20c51c543ae1b5442986ff94a3c340f92e548fe8c291db1652aa31f10c4f7c7e2d759215d43fb4a33adf3ebf47f436b6c44370382a605b321704f90ee042a6afe8ecb43be7e76a79a3343654a4f4959e5558cee47ebe80e4aa759d5f70671ff35404edca5e852a043ed86a3499bdab8dd10eb30f0ac4f5509c18174e95778c10840da8cb262156d52692a9324b9c4050ef3815d275c31b5c093694ed32de1192837edb2b5039fbdedafda26f4ed44362fae28f3b8d814f654a114d60d2dfcb78bb55a05d1fc5dc57c0aeb32fa80c7760c47deba9ea661175ee8e6185f5b2467fec95eacfa69a3ec265bba6a7bcbbf2fc785f648ed326c35790b1d7806d014318856ae3eb361b70dd2621bdadc4c68707f592c02ca20baf487177e605363527ae3506aa227545d5d7b1affb8a5bb8657007b6cd01377c667ac2194f7c5f3f185653f6b03fa159e900d7fefb853afd1614a4d6f7231fb553aa7dbfaa7af843190dc7e610d60dbb69c363e04a09910cad6520e49d8b58ba00cf9b641b6da2dc9b9973fcc362e3d60d6e17f3a841b51304030f5e1c61a232610e270d99895658b9e869c4d3da3054506347e8c6041a122445ec9afcce0352450d283bd71aba5b8213233808fc43c8c86ab0d05a740a97ef0795f4eb588f67a4a620521d16d02492e57334177e92f28bd31a9f90440bb9c2e9baa600efade61153fb839cddb101377ee8aae0284520d840d813e60c33838d8f9635fe5e6090660cb473a625d5eb6e9734109849e8b2c1b256dfe90e97d5154dc74607ae9cb876b0b82288a36d616abef8b347e4ed862ae9b6d57ca9e34eaca3cfa63995a0a269f76a49dd9433e7ba55cdff6627cb27a29fb23578e12305d68ee372657d4184bab109dd29c9d6aaac851e796213352093db7d6b28f754272865adf02ee07e1a6cfad17116a007903e9aece8d3deda11e8f5f4c14358c32981705699c80fea57a69cb18bb4ed6147b975372d8d3df37087a57971c0d8025e32e0cd3847f9eb5aa7a10e9e26aaf0949092c523e4dcf889b0c96cb42a46b29e04beb38fcb70da5f8340a0f3d06d0106ca8bc412b5dddf0d460a475336ffacb9c55720336892f79bc486cda4fc39a99b58f08d98d58e1d88c546f5a6ab77d48460e18cedcc300dea8bf27f9c3217e01c7378f662441eea3dad337de590212065be73c9687c3ff9cdd6d562d23b0ca21edce75c54549d6812477349914e3c6bd2e69e169a438283edd0f2663196525daa31b2ee1a3c237b519d128b47edd837525829743202c0081174a9feda45dd86a89230b15d0bbf5bb5008c9da9be26104d9377da3f6d2e8fbdb42ba74f738cb67908b4406b3fdf4fb77b8d19d16772ac96ca26ed09b82218094dd830aca757aca582057bce82937c8153cb260eb93dd3ee7180829f31588f388bafee50e8125b66d51d74c6b336aa01cd868a0bbad2e4f4a1853cfcd16435e19d6ad9c1b866616b537a474ad98f92df11c6f53d319e45e8f51845a45f92159d0b449dbbc0f59d79da864b66d756a65d5a9f31fa9a4dfaf3df9e36c66cdaeedb7f2ac9bf2231ef114c1b6a4c15632c90cf113629938b7c5318a7e3dc95c113767ddda77d25e2a61b12d4f721c9f43edef80ac5532d70f64f83e8a3ca8170a7a3cf2184222dc430b4c2986feafa4718aef901806f851410758147569e80c75b994466dd389c2d8e7730a0e2f4296fb5ee434ddb9fa640afd2f1f5469e117053869c8fc5e35d4e718f6bb37f73c017e5a9a512b67e3d327eae58ada2f159a14c7d6d06e7c07eeebe721ac9dcf799e5236901a7e736ae7aaf3caf3d6c4ae0a328adeddedfb51eb7e313f52943eae8168b5b5baa976beacab7c129fac415c5dc0e888cc9d375c529c707b047bbf03f8ab9b2edf517204c2857341202dc0944dbdfddc282772be9bc8d4287d59c8115c5b3862d55db2e08764af68685a6efd41e99bc69f0795a0683c68a6697942ee74f268e248d24b8b411ea4cd70a2031187c135fe57f0a3b6d7edfb0223dea03f258be53bd6627499dda5a87babfee008cc9d74a6418985e92758bf0baf5e290293961e7a1c5f2bce231ea02d2473a372744c52c729f861ddfeaf4da2433e779c27648c72cd300d38aa1a7e085635f10dd4477e146cc8b46a23420e7f2ad8021d29035424224f49b8f5e767d4e640b07bdf8469b28dbba66a1021cd76596801ea9b8c514801d872ccc81bda83e1dc40e0e435cb7080c5ba64f048df1855c18ca89416fb51bead6a47fb9330df1cc355be21123b44cb5d7b20c1bd9700d5fb52746a118926bca4322ca7ae3f88cd28248e4fe0828b0a81122d7d55909505003b205c053a8517608e0903bb35505b6853abf214a80fec065edb247089c56d445699fef6f02d5229ff3ad5e0f979e596f8faa8b84c0658300e4318698c30e25865fc365c16723bef323fc182ba9eb701f3c13ba791f8a8fe610f5c0af765e5a271a5e29c67685ab259d8957bc3b7d9a976ec116fe81f051f13dbf50c7d4b9d37614aeb700ab4ecf92cbea7e6a484d7240933f1abee354290293b77bc3bf8d73e3a9ccdfc921ac3cd3dbf3e5c0f33547cd20cb721704ac371a23980dda1321398c39d47e72699a5ff9df072639ef7844bf4ebadf6d24c06fe07e1cae7d6ab80e61fdd3d42bb2d095049e294d67ed6b7a2be0a3e3150780c1b3db4f6550d3cafc0874e4751dc7436bce2a0f4d1daa510573a9858d8d153fd0477d973b31ccd891f10e8ddba3d61ad7eb14d8536f1dcc0ad144ee3ad1984d6b565b9bb967a9b908f9ea17c8570e11994a3783721dbf0ddf715e36654d8302680e6b206d122bdf512d2a51755e25e86f76d66420b6dfd78a58b61b2a104deb345795e3e64e93b1c32a3b652ca3f59c55ca89a58dec4151a7716f7f7cf2d56e7bee52508fd56cabd8d8d70ec1cd8a090844d8c65067a091d67d3f38d4f3c5475c3754e58b4b2ae626d0e7895d42dbc042b0762af5a30062247f752e1a51b42d498869ef801ea58d26b1e2db91e9cb518fa9ce671127c8d997bca950860df5827d6352e08592583b204e311ea9e36914dc2c38f78c92280a51fbbcba83ca9679658fc7c0fd0e0d99820153120fd69f0055910107eda74d356b58b4c961ebb807671b350db4815bff6c11e1b9bef4327cc419772757585747a9200ecf23f7c90b44bc6450882988d0ed4eb6005f3ebf00fd2606fdbc26fad4b013e73852a8e84f1457c0f9adef5b22a77bd12f2af347e059fe4422e7ced46532048a557a4020c8e55b92b2b2e46855a6c8640b617cfd3f1d2be077f65da6470dbeede2cf2c3d47dc36bbe0f14569d9165d8772647fa77d9bc73927fcb128d9a10b7443b273dfce545a7e3edfc8ca9c8423410426042e5af0fe3d224f6ea613ed0e13d23ae4ee402bd7d8ed05eb74ecdfffa8c0cf2af8d77b3664122d20856fba60e235093b52d6afbf5469823b6cb4626dc8894f4d04f1f2d329887773f93f134469545dfdc69bfd95a00e7e83331525ef4847423c18acf66c9cdbd54896e2d6dff77c0ea69f67df42eb3f2b39fbd7fba0008d43f1f6266383061671968ee5b4b53dfc653446b7fc186c749e1c5a6186ac00910a3106252521200f806dada04490579b898c0f99e26be0fe7c79068e80a79b72977d1aaf835da870f77e575fca2b60797527cf627c4e4a5de4f661799b15e8b4e7f52d2f35879658b5f3e5217f3cff333c506ecdc89e8274b0a959e56817039bc5ac6afe7a556cefab3e7753cb627c859aaf0be18000ccec015573906515bf0a6b1ebc1c586f35a6dcea0e4cc8de75aa90c25017e76f02c297f06b4c54581b924138f77963be7df6372c55f1d21d9433c155485f95396c642b9be08f1cff2094c2ec0f87db4ccdb21d9b783edf651a7b30769980c69be2aede715362994ba5d913e24b31a7351f346d0244792327e089c2b3b16067d0c791e5d30536dbfdc1974728dd82747e89df92b0aa402171003d15f596423030d4a6051da9f2874df04e8d5631bfb3da351ff43403c37ecb222d686bc920d53ab3d015286bd027efc2cf6a8d279211225967a436bd731663e69b42edbd3e3ae6b89431cb19652c477805f9958e8f0b576ddf4846518bde0e6a488d6b40e1fa07ccddc0177dbc8c65d48beffe6cf86a73a2de04dae7241647858a6da9caba8f5b99220e7ab35248f9091b7d0abbc3fd08edd592fcfa9007b22d498b7e7edaae74325dffa0129fc9810491adbb6db41018ee176c5bf78099f396c8c5942c2737f62b9f0ce8ea059308ec55b6205bd0ce58672bbd739ff3121c1282504e97db86a441e9fec481663134fee59a5daf387e65b643be4d7a9bc328518aa8517a4caf355fbe08df0b27761b8d6454a82364a7a850e6ff0b9887c46489b98b08fb5004dd965c61a0e37725addbb644dea160eb3d610da85024dd11a9c6dbdcb2d6e9b1f9e2d34edfa068058a10b6f4d66367ed2b8b93f90c5f707ebe18fc51bbc3796714014282786899ab3d9b5a99a5758f4b42714a5e1c13ddbc0e62079ea9595c3b292789ac3efc22bd5608594a2d9311a11702d6b9a8e02d08c09947f872fa6ea80b0c44f4bd42f8f50974f233956b0e7ffdd3be997a5072e642c5a6bd401faa3b8ca7edc1bef0bcc4c08b11e8bd8ee90d63fb035cf1f212330a74dca3ae8c6639c6f7b070f57c34cf606c1550697c51b946cdcd65165e9907bcfddbbe70456adbdbca9a6e6f7d88a7a2c051e02ba211bcab1ebdf80e23e7a503430818395f0d2fdea780ca769e15122d5030df4c182a621b69a96fb90a092c997d8108f370912ae7931b740fc1136be99be6e44ae752c092d58f6d3fa2c25bfd9cb2b7dbf070314441ee77efd1aace4490d559c6d612704fbdd3a6bb0cbbeb1c2b1e07c0864d45be340e27333c0d961004a612dba7309c11245d18130d5d89b36d024d2fb080ea945be107fb620b62466e9b207c3a893456a1e4d1949cc9cf963b91ea1dbe6bb07f775f251623a9e9c3e01f5bbf287e626cd442ba0c68","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
