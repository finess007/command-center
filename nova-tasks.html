<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd5adae715a32cfc52c1338e67f6a72d80a6abe16469f674dcc02d7dbd8eaab3461f18d89ca34c3697af3035dc9347623c01319d47110c90afbc377a3467ee7e342ad5eccd9ae32377627d40cb1073f948edcc6dcb164cbea90fefedfc4eec3a7d958c71a1b23d0b808d386301c522b622cb711d1887cca79d825b32dc43797815408d55fc8a13ea6c93e01c52303942690e9fb19528a153a3c627a7f65bdeb672d57261c5352f394841964556dd70265aecd601fd44ecc6d3ecdfda2a8bec45fbb8d9140704716d40ea2c818111945e4583c71fed8258e7d018b4e0ed889582f57feb5bbb6f7a854e76904456d0306a29404a0d1e35ff765e84680ed1bcdb1b892a2e7dd86849a8e4703fe2e911757d3ebde48f0706a1ab4cc1fabc6a4d4fc05dcd134bd2e4e0b68bdc0b7f468b67208bbd2a7e69914bb3e33ef11aa8327ba6c05ad09bf7d2a1743a7a12e9170839e74f36721e85aa7cabef3286be500f2edd3a3951674d2c804a98956485424cd3b4b971ba7d1350f4666aa95914d66713cfd8397fbc67ef356aacd044144c9f15457d444ca716c069cc494b7e2655bc3e87b4382dd9ed890c9808882627bb06aac51f4b705b022191fb8ab1890aa8a49261d53533a308ee4b81aad6d0517a13f9a35abfeeb7bd7554b4db65395dad156423472de3b7d45cc3c13e73e290b493fcedab41b4e46244267925211be95baa21b6929925f9c4484f151070a37e184ef3ead181f32eedccdbdbbe0fd35e5eca225ca18eed8db642d759a53c2618f7b324e6e95b89403b2926015ef7b4e5665d71777b40d15ce5f0aa5629d665acc0193d719a03ca53a01649030573ff7729c1cf803c1052c260ec34d377605741dd581775207b75acb5faeda52dc614d6e71780c4e81da182269c15279bfbfdd448f4f7aa7a3a3ad7782886df06c9660f1bce2fcb691c1b3f83eaff8bfbc9e97d03078f18c5cb0a307a6449447e6e23d785f43f78ce0e6603b9fb97993bf641500d31ab62d51f1753d1d654a071a402d5f1a0149500600f9536e5e89364a1d08cb293cd6e3e2ff3b3aa854575e7a950b48d39dd91ebe6845618de4a4a6f92525607f8cb90824ff2d557490b3fed53a458c18fa4bd57d1329327a02040bad0117a54bdf6b13368d42ef4c2233c087eb818f67624ce9655f47187e464198c0069b6b55edee7b3eef506aa90c3d6e845dec3eab020be1acf7e861363571f7a8a47101b9522b60889b7ae4b0e810937ad27c042db6282f1997ab0faf5b1c3f78841b3a455b60c06954e7cd6284d1a9e3d2056a4b06e34ed86c0e5611611b390d71b6a0f7692f5779190fbe24b32d63f3bbecb7b8c186c90ca1bfcbc18db2d6020bff9a8c36bb67676c50c07b9fa3244cde77e8b118317820beda6f22a52ec26a8e0acb8e97b500a39ef3699da5f4bab4454ea473b70b691ac3c1eaac04baa6680c72f573658297fd9d08787e08d6262461ce05020daea61f0e465e58bb8dc4a42499d43912cce49f9585dca8a601454a75fc637379c93fd488956209a68e5cd3aeeefd1edeb7d05d92b7b00a6da29fb5c42d5409f08c50f0d61c183162cff04e91c334e4470fb22109809904806f42b4e2b7e11904f535b3d9d89f9f746b77e6b10b9d2f2b659b79569da69da65e7d1419c4475bc4a42a715784eab5d0b7906aec02d332ad94f1ae2fe6e0516d46e1189dda55a5081640bcdb0b1b41ee466aadf651935d588e0e747db322d65663c766a11b42c6473f4732b28e8ea54161db33f16c1d9f48b3fac332c1f54b571834900bc1b51983c6b3ce3c7eb8cedb42c56da9496f7c6c682674c747520832a400bba3f5049efa0ae99146eefe56f8a69442fed453448b0c6e9aa26a742186c4e15d8ba8242a64cd4cabc60b05177794ccb544c9fb028eba2cae3d52edefd789af4f3048f246fd41dc8e25c1b3be3dad4f99c6bc2cf96fff96a262692330ef0824f096573f57d7c2f3e52a3937bf37c1e9586a4af134c8f3635768decb7dc397f839f4316511d69bc2992a8563d0efbc30cf63fa962cbed93bb8a694763213ad8aa5a80a5c08fc8bccde62cd7b89814016281740a1e6090be366fd5f89346b676d1fcfc1ef4a53cd0e17878eb68db805f56136925ff01158833f940a9a5f3afaf6d5245aa76f5ea9dad167bb264a165cc7e574c1c097b9b93c6a9788b0abb6b44a51b9420a7e238cdf02a4c2aa1b8ba76ffa9fb6fce20ee23ad398cb68abb61ef1afbc40d2bbdd46dadcf78aa90363e7113aec1a824da8407f7d190be732bc7a92b73455926960cb3710d42b89dc58b2c315aac4e443fee4ee66841362be1ae9da24c00a2fa6b288f005bf08c5fdfb7c2766aea49900ac2a800d610b86b2b433d8d3dd7a5d38e93c2cc4408dce1f4cc45805e485c5857470ac96e66f18b30358be71ab133c6d188999660da1be12e2a7c292de733c926539543ba5265950e0f2e1790944d74eeef47f2e0642abe4067b650d4d3e7e07e20936cbc24b090c2ab11a31edbf3ab04b49b4ba05f4d79877bcb222522c6923c3bb3d4bc5343630697ba6b4b123356fb4bcaac865dc7addc36651e6519731aa8ba07f55fcb98125ac1f8b69bf4582f31d3ec9ddf85b7d19416f3a252e0799102de03e74b3c1c7ec04e3b245fb80bff8115119e436792505624bb5d5fc5da01937741d9640be7e9bc894ae0581b8667665af507a4b7e0f9fc375afc6662ba198e9f696123335818d6cdc85074af0b01dcbdc01618bd5a386167645d9f6c365dedf4195a06297527d2a4c71ba795594b81df3a8429bf459e450ddce4fe58c48f76a73269c69fc492bc8e918ba55ce359c7400461394808a413aaa4c8c287c6e05c1aa8be7b831905eb8f60b9b6a0a253ebbe7fdc596c9ed04ee15eaf438180d69ab7b2d917ef5f750b16aba17697fea6db9712a5d6c027f672dbde315563231c8b7c89e32ea57984e07a7ea0ff1cab88e412ad3aaa7d7a5e9582ffbbbd9e80a7d84f8945181d2c761a0b7f875cdb2170a31f9254e89e013260cff0830e71d9ff364466e0cb043dda5f959ed721f915cf48e5a76c4114d941d1f44c26309aaa99f900637eed5969722556c4693f611cab7c249eec80cfc946ed554d3a2b56330e667f6c6364c329d63ddd8c5e95c0229658a85cfb4655a17760d8a33960d5a85afcbbc436ddcde6c5d06fdb42eca02be32bc6728ad53c7a439ac900454239fa78738c3d8b874372c6667a12bac6d2f61b08e254372af197e63ae1177123b528449690231bee8db8fb4efc46f0467341b0a16ad6bf240cf6ca7ea9701d27c321086fd414f3d58531f0a7aaba118f5cbbd078ef69276617bc20a1246d7404a8645995f63f279921462e8050b4f5cd2a3e829854f87e50446bc0866146cc65e3a548af9334ca295b9acd720d7b817679dbafd3697b13c3266274b05a939195eb77b831d5fcb9c2f9c713a9821ecf89c66484ccd9e43ed1d3f564ca8488a9ac013f3d09549f23e642fb6c36f1d3e6b20fbc6549d8ae544144db8c3219dd0cd82b0cf40c2297ba8f798ec275f468fc0b47d6dda73ada80cf434efe946e82da978e1eaf22caeb057e228c2162732ea1f92c4e03fdd8a600d12c6267f7ed198617e897e4c0019bf1affde5748a734cd7c2d04590aeface29e160d5827ecac5cc0f514de841321ff71c7f0acaf528433f42814273401d5d45d39905604b9d99a31c6d4303d7fb2b1e2e72fd8125dbb764df30b7a776e32c5ff9e9daee2da6f64fade7ef5ce56c373ea9e0b87ef10d8d4c6f33d832cd7522d8bb2e4dacf59d64a6817861faea836e60e6e3289b5705edc61ec9a8733cdc835405300f6d1a3e223f2dd695c7108ec9f5db95261b7971bae002cc0215ec9cbf88ca0b9ce73621a2bee6f5bead6d85fde0ed069bb777b52df039b1345e930ae9287406cf7c4858d3dea99f45c731154b00823b6df4d55f3f3b0f2d535b3e790bc3b605ddca41b4eede50dea2f9f81ac13f83c980bd0b86f7212ef6ab065435f86cd621509f07962a4ddbde0dd8757c6f74aabb1bc8acf16a73f6fd543bfec4b1e3568658ff2c822b8d33769c8d61cc1355c39d2b33ddcfbcbcd04f1900b427a3e97e246629c6cb2f6792afa751a661baec9f0352ef5e3ded69111ec455312e7205bc25e125cc145d12595ecb8f8c16db66fd1bd0cdd10b3dd727272e209f1de9cd44e2d21d11ce12a740f02f9734cda403903bd94ceee5fbe9051f3f63da6f27a4f5fe3ac510cabc313edf781e5f0fe52be8eeb626b2329ff65094ba3a323baf25174d029068051bfe1245072ddf94be9299a69c42b34481a42b9b83f95d7311a6e09e8d059f33e33707163cddf552a1f9758339f748a7daeb92997ef31abcd7d45e033154c9d1400409c1a0441eaba62b10a06d4e9961aaea48392dcf66a5f49e514cb0087f0e6207c23c143ad41c67f030249e3d84a808a982a0535179f5fae68341b00c0751496df4e8f81ece85401b0ea3aa77c292eee348fe1ca13571f024dfcc72120d6c775e52982d8f180de72bfe0ea16025af39c157913b542c49e3bbde156fc0b8877dc9392d21b1c4ad76aedcd2a5992e75401754d2e37b7a1d963392001f1ab4567aa3638051f5594a2cc50f742b05ccbe3e6c0036fb4b78490ffb9fd4a4b7996c6621cf4d78b2865406b1195b854ddd8cc95e990bc1beb5aa601567a87fb4a5b946f277295a3f645c39a4837051f0e91ab30cb4e5d3ec3d5e054b92037e7d18383218ed84d0367c692e51055dac2c04c37045ecbe63b75afa6b83d29b9b733985767b0d799c1360704dc3ac5f10602303ba86bbe8ce5f865efb43b7b3c726148271ad9f5d06a7947bd4da5bc1d7cf2d9513a19bf95464cfeaefb30dc8581aabec7d08b7890eb300f8a3d84503f59d52f4f994b11069eb6920de0de3cc38a800eccc397bd31e8254afbda3285922db4ae07949974d21e5b16cc0b5e9fe38f190fc8e16e821c66a55fad2a061f1c4697126b50cebec6f859704c898977c32dbc249962070b17f3bba2c881783001ce54a465dad57b0e78d40ce551126ecfea2e3a1f6d24ab54bc2e65fca274cad235437db491bf20b9cccdbb7c66861d08283a43c9c257366ad240a3374447defcef6f02665f82deb6adc1cf41f143373c7f1f8492634c2793cc26d58d0f32ac074af6155afaad997242b410aa6b0a1ccf12a3bcc76e35993312bfcfdf4c73030c1ad70652fdc3e78a03aa9346a536406e809582ebdbf69f1a4f1d82f3f8be19bd2d27104456ce3ce9e2ed06d0d92560912f9ce6db4d8f877ec724b0fb3df0d76adc9b516d8c727037068f568001c1ce594588c995e5ddc6fc464494a9f0b1cc20f43b2b511fe725ca73eaeb1ef1df4921252cda5e71c55506846fabb284db4a5fa0073c77678b06e1336ac3edc68b09b03930db5d3754f44decad84e660ae5b302c80dfdd8b9be70fc8ad4ba3bc7181b01c73a14c52014bc103a82de78dd83a06eb6e00c124f11d2969474c8cb4ff2ca8186b87da2fc0326d8b232e29ad89281bd95d24b6f323d2c09d7af6a25b22c8d2fc0bc727803cef2d5a1e5fbed9ade9c67b307724b6a6ec507b5cd507835b0c2619ba0a917fcdfbf2aa0aaf0b268f7c97a56e607fd47350732d4ef45e633331e5e0b08e1655132f0a85aabea80bbf7220db24ca85f00148cc2cc134188b798ad90908d9a4cd891951b66f16eada1fcd9e676d1d01eb2befce9ce25b2565761a863ce22c6b2b2f09d73266b6af4650cb7469309800229ad7cfb330338b87fdfef71ea423df18521dfe0d7cc5fc1366ffcc349c88296c3a7bc24aacf9f7ed24404585536f05f7998c3dcd73a69dd88ce9800df66b5b9b5972bff33aca06aa35b999e65899b8ad4742d31c4fdad4156ee38933e535e1a2354443ad90132d5e285599b723cef34c3e5b9a3b5597a0d543346dcc4083fbd5b45fa23fcbfdac1fca7ff02d74f2b6b8c8991b9f402a4bb8d4c02a7599b82c33806be6bd1d85d7f6ce04b9ea297ed9f78fd18b29adf20093fb56a1bac865dbb3e8950f1b985e2e63a668e6aa9a11cb9877a207dd548e1eea0b04fd3a2c564873f19ae79d77cfb397c4e5585e36cda039367e8f103f9ae0b163a9d97244718892c60bee08b6c8ea52fb5763bff0c0b17d6df9c9ab542f92936d7d66c774b2fc05808d82526a07bd853fb1faf911bfc84e7f0798ee97439426e23aa9baea442272eceaae96eec03ef843aeccc845bf7841a947e0af30079605b9a91e73d5551ea76f5322baa00b8dd37b88414bfc571dec77e6ad925fcbfea24fe5a5ca89e3b32d71898268ca47df0ee9b275072e8c10e3e86a54e8e483b6339c9e24bdf720f7019ae0e19b221c8852a51117d4962d3062eb4fc6f83b3b56af4b4ed2ff14ed6f860598ff6b4d19f811a0895742de2434791fb249917f57ed60bd0ae9049996a30e8e716a5e90cb776a46f6a70ee275cfde5594a4d858c5d06abd44f78a1938667bd1668e54c0f45ce52b61d586807e441e99281904fa80cd6e64c29abe961aade2ac718e53fd843670a8a49b8a0d4794e36fe8fae12c83ba75fe484705243a9205223cdb181c13ece3babe8fc39f962aebac359d34a779137310f2147d9011d593ce4b858d27712622990e49705eb5ea39ec045a57cf1288fe348dabfa9e57f43ab531a3ba93efdded422b96335fa90b0f154e2942aebb884f16bc1bb8e1419c898fc8e5e01eaeb82171eb54fef486a5e9a28c8ba053144538c16b0bf7c20039c87ba80dad27c559a42446b660c1c37ff4a1fb49e119c06612153b535e9cd957664214033cbca3bf582c59c6b46908a46ac373c334951e6737c5e02886acf6b0bfbbbaeccad0815f3c917cc16e97412e4599e28dbbfe1e9a9d91e4e5fdb3eeb3a48db5bf06d9cf65f628a6c0c11c75b842e3281a6cba24dda19c06645ad83040539cee672e0cf372367e7170015fa0005a0e9eb79aa94c0a2b6737f0ad09ba3fb322011cb13b2081c00dd676abf9eef95a8a9beedb3f04af4bb241972a719a6bde4cd1ee27e438cb98ae353092bd6dae4f1362681516c55916c1a88e0b2f071c05efd53c53f9c4ff3911357de9fbffa63d9a32c317e6c50b3b296df88af0bf56f93a795fb731d3f7a234ec59cf787243fc7ef46c295a9b4e1136021dcb311d30dff8adbe1d259b31adaa7100ea782e0b4d5e48c000b51f7308f895fae8de0bdf77cf9e8d008123d15edc7de97fba5a68ad89a15929c48b5216774faeb8147c9942a0510de44284974e87ae1441ead762e047835da3560c9285e2dfc05216904a826bb36f4716d50ae9112a08ebe306c81d01a6fee1be6adedfa0aa99999800c1b8d165b17c46cf85c62e46ea49f75a01aa6afb32a13185010ef78634035f432e384c120a60c5e544d33645d65c6125fccb031f7b18a8000660d897c709fcb9e4534c96d314258c0ccec71d84b34b874ebd332daddc9fcdb7958111e951ff15cfdc788b503851fd4d31664cc6f98139859036bffbd6617437ff498f608254e228306bfd6482e13aa2f37f4e066337ccbae8027ae519384d74e151179da4463380fbb2431b4448cf2d6321c49bbea71e526df37c8684aeab155c36776369439f639991b7fe8123d663b406a14b8db730585fed3467684f3b70e11e6ebbb17074ac411279ae15f795cc1343201a1c82781a833cf45b0beac52e2dd2e7c762fbacbd8965afaf1c01848571487e2b209e7d434d26f7b1addd026d5d6e25436b6eda1ad762eb1bb650562d7a778cd1193f779658f3df5916c5c5a656598e02a7a79aa010b5ba88e37216857df5a4ebe250c24cd08c02d35b4524b618614171b92b116f13f66de2b43a388028c7120f479b5454fce827794aae21a0ef9f48c8f607920021d1d6c12c63b31e46bc4bd981c8aeb25e9c5f52b65c094ff389c2a5ef8e0bf1fb618842f48534fbb39a8db2505ee46d01636be23614f91f7a71c84b8141d31ca6e9726cdd03d2b3f30abb969ba0b93d359f6a604d95c08db1c7370959ba1481f995e7843ef1b65a18c5f0c4cc45bcab93b0bad12d91f1f684580945c2209b3e7791345e1e334e23a6626fa7c539d522242b12c9eccc6a8fe2c5b96e2897c92f61084f637d3591f22ed507e70bf7888f1ca2752f59add43671bd3f7c369d43e531e79331bf5e3c486dd2c768bde31e32d85741a0c8ecaf1500e5c9a192f22afaa57c937c782b8089683aae02e0f109814164d60c0f1a34e3d19315506679e5c8419ff4b822727f882ec4c55aea4e27035ce66fe8f49671f9c14678a88eceb30683d233537e27e1e42e96cbcd15f1fa6b0d7d0bf50b34124bc71f904e95d36de9c8636d4d61cf8259635066a4cc52a782ccf7a9828d809ac543a544167ea2d419d057d5c61cccc469e26f180657951c18c19580fa26484afcbecb943581b0b1490dce27007076731ad2a70bd12666f7039e77f15a862cfd7392c8b41b7962057117bccc773017d70d248ef1c524d344da8d548520de26cb3529525396e3c1e2b6eea99e50ab01aa1d03931563702653c8a653cb7b26988462cbdd27722876644125ed85ac6c27cd94e6d85df70e2d2b4830346b46af5b185ffe3ae25110f22f99df0b6a9bbe39b4a0cc13294203823f4536919f0598e1501eef1117cbf236be37b6069e3e70d88489006dd6156b06e4738e2ef0f0cc16dd2b76fb3605aa7d6e0e65ffdba2e8fbd9c3a678d223bd27eadb265f11b0206e20373ef004f50bd496dfe4840196fb660904f37df68caa70009492d3980458a940556b53a96af5cfba593881ae478642ea0d03d00518872181b238ddb6a52855515b2f0bb0e66d48fbbe27722dae6177cd0b392828cc3498631152399253ff3ed88711b9c2d639f93f2f6711acd21cc2b1fe8ef0c3d0e659e539d1942180d00e98b8ba7fec8cee0b841aa3b0df4161dea82c5d5918be99e9f0bf49f9f72fa1bf6d0151624a58bae390cae30050e40f87b1ef359624049166f6c70a0baa8c4e0f73528d30f324dd115e65f444d98e4a1c2b6cbd8a2b2f5272782481e645d0ea981ef19a7184e4bc3d802ec425f800072ee9a3f37703096971fba171c23e74edb404aedabb68bee0eca6d65af8adc684aed6e3c556e2cb914000a939ef7847bf4c2a797ec5e229707fd5069c0ad8484bfb5ddef4f36983968f8816f9610a0de50d7a5de0f8a74b350a071fe84bfe445d53b07db272dc4a1ff68d60e66024e46a6e77747f07c5e4de198c91226576a98005457bfdaefc1593017955398b20c845108419057198cf63af2b1e41ee7843721437c76bf28de757f469e1d7d96821c39c1f90d1d3f24ae4399103f10f385717cf03fa9678945c51428b5e152333d76fb9abd4869ba0c94b01e68df1bcc68376ae5ad0c50582e8ddf03464dcd4b31a95c02b3ca5c477cca21463d8d7a72ad395c14ba697c25ad3f35256d9356c7ed91c5cda369f939aca66f5bb0b69129caf6f2d1b8e565a2e7de226ebdc2885e9b2f3625761c831c025c3dde7fc531ffa8e471dfb2738af5442167d9dfb0baf267e680d4ad1946c2f100f121173e41bbc3dee73f94c01d6e165c4aac2a9fa238b466a69ba5c4aaa26adf9aba1a2adb3fc571c6986dc6d4398e75cc1e348630e2301bbf6c7ca26956c745953564659710ac41495d0ea4552675a292f8e8a8241734742e5cccad02da9a2981b702a296def0fe93aa85e0bdb59f332ef511cc2596c38a25a9b5b7548035f55d3c782b6f8327044ce985e46491f232cf5877c999abc126ccbc46f20195fd7b97672c06b828b2efac79b0ed17534440c154cc320890b969bc22c562222db3b81168dc47bcc147af03855f2c9789b1ab602afb9a25f67093992ec01439631b6e771e6c963246b054d514d531320bda7cc0481c359ff675a6a2992b2c6ccb9ec16ad97308ad4a661a2a9e29a027597611f297f4310c3829ad28ec5abbed53bf495aaa19e7a38b76dfdbfffcc0393daf14b7943805d97f7d593f29191febee6579c46fabc8a0b4b494d052681b730db400f5bc4211d94384998c4845d6ba79c09b25b1a16fa59d3c4ce4bbf2914a8c6d7fcc83ef01d917b5e58e9635fd383f559b5e88d10aa0068225755eb26a3df8f74293ae712aff0f10fcaf47a3728407020135fb0b84970aee06a7837cf3bca1a6f63b4636b2ea953ac7d9c6ffb2e3ad504b186119ece6908ad89ddfcdae42d400ca746594c18648da9813f3a21e27a8fa42ec6864c9d0afa66c6d9b0dc8511482f93142579bb8364082ffc77198b4aeed0b605db7de13505dce622d3d247bc96c70027f3e005bf2a858db7c28937d02ad3a4c5a5c11128e8cfa1989657cc86540f4d179bfe9e8fcaff2e35041794c1312444d0a198683db9c3cfef2ba4cadee2d4f8dadebb1280da1544cfcffb742d3f47f44b418914b419115586315b87b41018a3d9de4e86676e7df79dd4851e48cafdda00ddd0d4676f7c0feef62189780fd101bbf4436cb5b7d33970991fa913c0dbc1d78a3c15caadd35f904c4a643df04c223ef28802f1646d48a694b4fb8b62ee0c7d74abaea9fe89da5770fbabb428012231d486612962f443707eb0eaab0f12456a4919a53560c149dd860da6a79f1446428f837887d5e9469437edc87404ca04c0540cae05c637c49c17949decb5de076cef0da545b5d4d43663f4c51115e39d5616120c4a15ff1e8c41210009ce55eadf944e9dd50e7144260661b515c6484c95352f6d6815dd2bdbf2d8e5e153efaa05dd4aab8cb05d77bf981e88c8a563d3e3bdcf48589253177a5066b4adaa929be44a2bbd4fa47cf821b6180f24b1a91e392c580ef2548808054802801ba06bb25c5a52b6fc3c8b8bdfb33cb3d89b95ac89e7af50b4b2fa1051873490fd6b31259439ba8260edede8fe0413dfd6adcdd28c452c8df1e40f24ae3f94c72183910e3465d0db45cc3d5abcf74b46217cc519c3e633c3e76b64f35127301457eec9f1b6c01c44c6287cf2ea29a8806a6a18c308f2d1fd8dc177dbc1d40df3f7de68185dee865200ceef1926446ff429001fa2211fe1a7dc5b3e6f6bd1753ee3fe07b839ad4bcc9a3336408566bc191dba4f9a314afbb355f794611883fe1a6966ddb1d125257bbacc147b554cb8df0ba91e9d6374038ce5d63ed77ece7adb7c7f40fb3662e3fa99cd2f456be1dd0ae231e183f5678764977eba44d83967f6c2be16a8bef0d2f2fb85215a7c5c61e593c684069081b24217e5bfb4499f7350ef53381d83cf5b98233bfaff6900b4c0662e790a9512f9593acf6c4b9405cb1a800488b82e4911f6f481ec7e239a250aa5171f55145e02b891b33cae83568cc83333c0dbfd1afee17d935575ca060dc2b8ffcf68a73abac9d8918e027c5c3b32887db573555e330ba9cc5fc488be88a595e23c3cfdb3c081d9cab2707bdfcb874377ce8931b7a138943ae124c395e628a148367a2cc7a267b03c71641b9df2e5b1d1d978973fc9f111235dd95a47218a9d6bab29a7c04370df240d3b8422b60df898f1a3de132f9772d80b5010c4e9a3667a785e29457af398860982239d528f7c2e048f9f592ae8aeffa1f0e208f8c3adeeb035b829b0b0a33aad1cf199dcedb37dc4f21659c3bc2a4017467d8e07eb837203e0df2e1a230606ad4bda31c41a87ece34c5ddf8e0c2e8edf9a5cf0ca4e21bdf72770592426a3799d1437be607336fcf43a69324982df01b6c7024b1285d54b9b3553e8de08bedb9f37086d82cb3a49536cb79860eeb41bfa7d44ad358a44d8bcedb6229fdb564f8cc7aded9660b1532de730774d434b1561c925840aa8bc704f0bb3d7ac0ccbe3e1af85458fb3054e9e155e332604c6a69d569cc7455782d3a9b53c4012f09e9dc0e7263a98af48fe222e3cae817c511915936fd4eda67bceaf551a1b95167958269fb3abfffbe1d4b2a16eaa417b52917504075841453e9d8412c8c25a0583a2f5c2364c5802e709caba10418d0a98019af3f712f79605d0eacd898d0e4c01e25830e350dc6becc0b995220b92eefc0174da2b1ddce7797dd5f8148990594ae1b52ca222e958bab7edd3ae5be511f3a6423d823f324d4725d73f4c90ba3f18fa4b94d81085f70035da17a10b636fa5dc2311eeeedc15617ef0cfb82a032bb483ff0cb65311388cbfe9a6a4ca5b30b2d212841c716ad1be7decf8ce7ffee93db819ba7ed706c72cb3626f880a85124da6fe17f5f5df7c93bf205604ff8be67d9a4cda8f82b195d2c5ac4290c4929ba651738fa9f82a5433157a3f396edd8abd40b045d768dac18795adea05ca2e1244b52ddff00803628fba5db66f6176060c08826e82a05c47d6a2640de76df5f5e9029e337ecac597411f712dde6d75d6c164e4cd626789e0ce9a637c7a1725d74710243f48658652769605b52435c6ce36045b7b251ccc7268137c75afca34855c811c5a7a503329a2ae6ccae39d9de5d88f7194e1fd9483da70a2c763b41c355b8d1183d997379a90e02b07141cff0d802e3fe2f844e729ee3f6b2d19d3955409d0d7e8669377ed0201f43afb2a8c2b012022ae271e74cbd05995722b047f40fe2a8570510fb8d4ef7cf0f2be3a6401cf2a0b9bad047dc186c142d8a0edb72b5b10d5111b8cb03ac04f114098d4d1f222a60ece892529933902ff01fea6831a30b08213fd42e2857c7eff45f93dc19455650908d984a36876d64802e4ad47f0288c984de940120ab02e28452ef060a6c87923fc4107d9c5d43fee9b1d939c62237699c7f3bd2b5f3d55316decd340b07373c572c88d461f7ce817ea136093858db4d8182cbf5b5a3ac839d7ecc32f41eeac395029194b4a8961f822788df30fcfda17d21eebe5d0fb0cfbf03b311bde5eb912d6c610653024ccc612c6c920df9b008e91bf9bc2efd5d772c9cbf87f9fbb0210828f1d57bfc971c500529541aad8af46bef70c64ed1b858a957d0a8ba9e472af75bc7172b3fd74c263e5eb14ac44fc6a71703de45913c53ea09ff954e73378a3b5c1aca22efd15e7b7427d68564bda6d1bb85aa089a4263f16beb99c865d05351a2b8468f063498e8dc699832f7e0db25d62116c87e84cb81e48397fb64d60be8efd33ef8e173520c01d4b34d2e377610a58515e01172abdd8b29ef041dcfda4e07dee391eba05c7d026372ca46c9a7f1c5c9739e58cdc61d629df98445e759ba40a3c4f6eaf75394ca88cd5d6b93b9a8313da4524a7b01f439154c438602928f4278cd8f8ea5c40d3d89818c1d8185e2f01a598a8f209f3a67c80d0e18211ecf7a3679c7f94c968d3404172f07b22d20998954ea450e131f3b2efce602000889c8f0e5b7ceaefb99c96c8ea947bf39c881996b2c2455d2903df497a0fbab0d9b2cc5a20f94f0c5a88ed406f5871ff580ec027aa28a658c1796aa196062e7136861d66fb19cc28ef77c1753fa5701c0ff2b10f5d0425593cf069e396e99e641056c111a514e88e1e86fc73d6a76434b9925cea711e5f2f40bc13af417b117b5c46d2cdd5701eaaf397e80af0f1517173c82c5969627a32ee683109b029d0c0723eace9aa0f99365adf964cfb7bc5c83a6693d608d21d64dfd8f98169596783ae5903daa6eb6b879f7a639b93c713994d86e7e8f90b351646a358f28e8baf848a4a78b2da1d96ae7f183417f775c9cd1030ff6095f3d5a38254c96d55d637bdb7edf9808baf30d04c5c9d74c607d56a5e463e561df7e078ce689a8ddf039075affb1f95633dbbc3211d1045e11a2aaa52331835e6ad3346e2041eb9ebd1950e04a1d036d2227aad19da718186bc645598c9b55eacb5947e1662726a365442d9334b2aa4b5de9a3523b39c6c9fc3a00eb201cbc80647f24aa65c12464109447fe768c36258c4a9e8d37f509edb648b3c420870e09762919a94491dd4a965cbd6256fb53d126e342366b0f45c924840ee43ff949df16e8e40cddf072b402f222c1de8e69917afdc27e047e9ad9d13e9f6d0ab8f14f6d1994d5e68189f54396d32b013ae268b057d4a7744699dc0e76f02d1bf7fd072db9a48130b5a9173d3eee43df14eef2136b5baf36df412471acdc3d787efe51dcbeb463ecf9f8d228e731d3006a8191582b1eca92ea899ff65439bdfe9efb60e7f7a3523a347463c7c7fd09f647f0954fcc4a9aa1bbede028fea3c448a21e8176193e48f9345dd33650d78a987b8845eaeac0e7d598c0e832a2205cb8d4a137eca49675e25482db0d6767d799bc423348c9faf707c76a9f14d2900b5ee57c8dc69b9b9236af211903d651eeec880cdd580f3241b1b37b74b6247458b59ba1168a124d1c0c5197a48778ad3059415f90f8cfd8026af12f47b9d0e622750e10aab47689086d28e3d0b1a7e3679f728c563867cea21682754199f4c3a6bb354ca6f0149ffd61d9d60fe9ebb52eab00630124","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
