<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d1f01f659cfb82eb66ae1a13908c353d245c7f5d884276214e89f2518ab8141c7360dbcbfe570465c81d3802cc90659e0eb5be90a294aa04615576fefc651b956ed41a6649661014c7091f60497aef30e632007a62f845cfb0962bb04faf90e70bbff89b0f5123991b7fee9a0a95c2541c64fa6acf9755ce15bfd6549aed7d0ebee2ca20acddfeb008c914ee132b6f1d0220bf9826c098b73c10b103ee01ee00a4a6c43bc25db83fe86726dac1a1383c4d42b97d86f749da6b8c5d97dd71f478871fe6266d997511a923ba46b538e2d2adf175606323d517665b470fa14da41bbaec4ff74004377dc30f7d0ab9c13ffae87b7cb68ba38b3c54b35094be268fedb83415d43e325d1cb4b2e1e06dcaa586323da53deee49188c52ec08969e1d59abf210ed014f4db1a9a5d249ca67c2f1c3ee426d50e1943ebb563e026ffa07f7513639b2f7b3be6901a98447b97565f5df2c9044737b338b24dea4d7603c6377bc92c2dd07d9c48bae733a71ae755c7995054b16d348c71ff4915c91436529c4037025bc72021ca1247b4d06177f8f9ac61a765002164d058a77712221ab097db47d1ad8c1c7e3a8ce7d6048a1839ab570f6559b7a397a89f76f12ec711bce35f71d9a752d8225f9b7316ff1e83173b00c5d24a6a262090c63f752c823ff7958d51cf64a1f04e86239c24e7ab03bbb35d139c6baa8d30bb67f4e812ade3a97bc551dd05a60c30b6b666630f524544163112b3a409f27315aa27bb9c9f4d234505991ceb6e62e840955afb8c77fd1aefc6693b25d72cbe4d526c2002297d36d1125ea5998ef1ead4030b18f442a21c201d01bc9ed5eb264bc8be3741cc4e83c58ab798eae779be9c294a7949bbd7a428928cafa6896e0b1622537903f833596618b49eb1ae15d83efac52156e23a2a9677c2f91a16569538fc8af961edcc63838f9232c0f8a5b2c2e12773a1298fb58843f8e1d335d2c2db819ec5e1569bdf45733c8010f1169c681e6e21a7875f9445ef72bc85cc3559d02eff6e418700789fea45df411a5afe341137d06c7c75f14e4387b4b8fcc4f4bcc4e94908be474ff7304d884034775b285d7ae89a9ba4d22ccbd8af6870be82f840e317b5527ed154f843a1e0123e02fbc6752e985abc5e5373dcabbda7c9bf63b001bc6015107da8599095d4479ec1bb1bbe000d07d2d681978ed189071ab43930f0aae68299d604e412e9a5485baf4d5a8f1b4b2765e006343458e4a6b0b815f58407316464819a6ac6711ec1ebd0189c2504c1061b30e97297e20114bd0230d12474e7225b1f80abb2b132afd4012ab406595f9a04fd219666324979d57e935787a1b63a19463818bba300eb4afffe62985e819d82a6cc5b8293e35addcbda0b472c8be167dc9bbf95f31a96d22ac3d601ac358d707ff75af58a099f95e8f7845465678b8ff752f44d4ea7c1d43d1f2feb2870139314202f4a66e8ffd6136a940c2047030e61390a4617bc8484292ed3086ac95c7e4ab38f9a66643a6c91039c7643f9198edc78e3f78afc5506558e71eeb934e38958d19157941fc3b41201caf04f4779b8a2609171291067131ca15821fc6dd832f20b11b5a9b294aa28aa262146d140b2fdad013afcf23ae545005f20c4bede5b1905192afac1d2c298abae89be9c6b9673459a28b77f3fb4a920070d7adedf31a20ca179a2ac22cfebb290a43d991779ec8e5001fc8cdcd3de807f339e713a166655f3e1b66b0d89b8a84e77c3b947d8aac71d1082258b3c8f8e377d9a3264e4891b9065e79d7b222056b4fc360254a7adaad4a4c653dfe1e7a182efccec444d0b7789fc414b31aa07b58faf0e846c7631cec6350575f409580d0166c560854ec9a5c7d93af9f80e225e7645c29c1710205a5074581bf4aa557681f213ed3df5cb81f6560968a90e249dac057df3b01ca218334c32eb4ca4d6950e4b9d0c82f55952017cc63695e5a2569208900176166c23abb66287fd76e0073123ee42939f318e3ebd61903284f4370dd75a0748ad6adc7c12dc7e184218bd6a50a9374605be83920b90dc266519bdf463d6f3fe9357a908bcaea7b6a9253baf004c70284f343057d4d7199ae9cf410bc2d062c3dc05b9beb623fb34e99063abbae35021309d0caaf4a0f225d0958dc76fa12060c3e3a3a5a994d11bf3d378ef8f25f5ba09f80c546e69f39f5494ac3e7d874a010334a48f6c351aff26da7889120bf4adf92cb13c62bf1751f0815bb03e725dcfbd27ac6682af1ef5a2e4388366616dc6fc97e17222c3137cf7730e9d6b7eb1dad899294893988eab3f895d15573b9ac5d1758d0f678beaff15433836fa442a3ed812da5e3ee4648dbc5aefaa77b47289a8da5666bcee19abf1c29a6e68dbc09c7f552cc374da5c85682e8784b2856d221251965ffed8f49e7ad7d7172783a1b4afd30f03ce7e05575c31334db94972cd71fcfa1ee9da0883a13253a3cb350b7bdb0db9b2835ce0c0efa2b04b5b55a5e769c1e6888de041f00b30b08f643bc99276f428b4a7c35c423c9b7ed7485a413aad378b957e1bf4d9567e36767c04f624555b9ec6775b1a42db18a355b8c687fed4bac8e10e14023752f6c4256788a08b65865b61ffe47c74b9992f4cfa84a34f17bda9c9d406e28d19e2fd8f75931eceabe31903bb388dd9b14a5e2e41dce21569c2aee87c7980d8ee2e1e263d57fb6afce527b81e6491fb6a568d751731452f59eabfbed45d008f27d6b7ba7ce1bcdf14c00a67c0654590e09505719ed8ee5db302e0a0c7bad50e132e2e60124e250143c5b74b1a73062a34d96b49785d68d14174fb2e239bb3443455b8a03ff6e2df5bb9c4454ee560836dc76fbd04f288ca5bb776028373c9c64824661f2b3422e2fa8fcc71418b8969312de9a71315e46b4033c9ad3ce6fd82ff08e981b9b1690091a4b596f86b0230242a5677aea7a6281def966ad432625eaa99e1e2f28bd702fd3c440f1f49b93f253d8c61d135764c641dbbf36a5ce37e783421272a0fc0dfc99de966dbc5b5602f7732112aad2c9019e1e583ee4fa6d5f5dabea4fb4004804f0d7052806b56e482a469d118c7cbdffcdc9fc83a5f85bf6cde88c7e4f1fdddb0614f2229fb84fc64253af2e78e83cc6e1129b779cb9a8ec60dea38bc260803efbddac1119abf60ee3214fbfe5c366686519ca1adf7079bba589f08f9c0388b2bf1d3321bd1e79d8e563b00f13caf5316454b36b10bc79259623df94597c590c13936d6d4f9321aae65d6f564618a0982198916f8647af79a677dccda44d6d0147e11994e28a3e0ae71c7286dd2eb50c1d30070d1d84729baac7d2ab62ec86ea143a04129ace7e87f61c9d98ab19cb858f1843b94d55fa02caaa456009c94a64bd164446b40cc595090ec885f0a028b01786998258cc7ed20360c4378667dece5630e9471027151a2fa96127de32d6b5279b4464767eb4d3f4801c612c9368383e12acf42b71a28b0a82fd1e345a9d6b590ca92dd4f047926af4a5f18636e0112c9812bd2cfd99410147929a8fd57605a47e3d69e0bce2e3a8eae1d75aa0bad264b6e503d16fd226c440eb66af9ac76e15d9be34014b2db3cf40477eff9496c87f92b7d0aee8b55361bd90b98cb3b5f015cd4a851ba3b5ec0a4500ebfc0d589e994962d4133617fe28e862702dbb3195532ce24550023b1d095ce0e56cab38e79301504ca76b15d1a1451ab2bb48c286ddcf26df3cc43d2b218cd224c2f33f00d2f1f73e4225e612a1b23882ce619f10252286be55629b80091516518156aec3566f1a3d333a63800df522fa149217310c4d24f6e9bb571464d8117083ef7e72169c92d603252d9a2aa3dee0e52c2d7be30f9d12538e32a72219c4d35908c6be251cea493a82b055ae267baa7657565fdbbcb8b8b72cd9c674cf6e475639ee299e09c5d134a1307e1bf4be58a49c4919eb07bada44f81f903c22f7afbda5b9e63adbb1d30d4dd11281f4db92c96388fae6ebb2347830a0b7f9e8d9b9c525a3244e37adb19469364a955298f30a5ebdcda04b99e73bd32c3246eaf806fbf6a18b455e744c178b3bfdc9f0d330fcb6b7a0799ae10f4e3a0322e43b0be3251931f79e92f6e10cbc12c25e847d88e4af8275619b226c8ab461cd8eb86b0596bbae9fd0d0e4e32ff6be633cb911a8c20a34625d626d108f0afeffa1d3692ce4d123f51e9357f1afc46eb6cf5202bde199a3ff8d348ca30c2d1d0884c05bebbdf8ab2e4e6f9072e263620cec2eb349ead7d0f81182f3c1d97833e8c5b77489ac897c2c5164d57dd12f10c9debe4bfe845a90e668f25151923b3a129308e33ebf4d641675376f9463af9af1a54aebedcd9794e5cd2261aa9a0c186d094630d816436705db3580aa46e12334e37904d275be08379cc851ff6bd12695cdf12a7b8df41027a507cb5abbd659e1eef9c82176010baf048120bd87712b37e92b4335e7c052cf7a8f6b41a9da8cdee231cb84d832deb4883b2cc06bd3fef49bb02f8e6b6377a3979c0993b2beb2a636cce3e29dfc583429018a3e94ad1961100cd4c6117620f58178f7e91637d416153cdc6903577418eaf0b9f4ac73ab3de8d12b4843e1f2ecba53ee989cdf3563d99f72fa6271229b0a6547b76a07e7921a83e23d4c3455873498dbfc3b74ec19fd63a0f5eeb26de328de23e06ca6fb7af33d88437e2fa7d662027a2bb9a75594a8d0c8d9285cb9ad305650e09c894070e79d1acacaee024c917b3d6f4d516f86c6ea22185f86817501d8139dac76a08c66c3e55af0919e7848b9b51a15f9c59af52e2c52602097b9f5c0e3b5caeb778587377e36a1adbfa66004baeda95f8ce44046fef85ce76ff5bc9c970d98cc4080e5e9fa694706dac0f9150c1a4234caf3f1e18f3db04e748b950c22a54f520d2a0b292f96b3ca3897fd15984ac43ef9716907179d424706f75bbd9163b30b0a37a04d5968b71592836459e8e043915fc26ab14f222712c0a8ebdbd75ae6c56f47858bf3a20bf32cd0e6dbbffc5e5f88fb1c89b83be7f03fe6d1aef11728740bbbc92a2bcc5716479bda5f1dba3e4acc04b742455cbf574aa03e2a643b15d87065d23d41750bf6a02dc83fcbf672edda9460844f9e2a11ad2ff004250ef57c73e438d49b9acb2b948cd93cf42460afb05fc91567606180312a87a1906bcd744d6e6ce65a073fd8a35cc090e75833a5089098b3301364c60c144b79afc22b60fbf93e817ba9eceb451d90de5f09320946693eb9993c2dd9069dcf0e7c72fd644b7438cf6861452ea40d6072759a0342b92f3f7fc32c117135c62ac923a6023c81c9827593c3112cbf4a16533e5e4ea2e6fe8132adeb4247eea5af8479a8fd4ddf842b491ef13fd1284a30ebfc0d31c4ec546263d514c35e2550a286b24e587dada3603085f046652f01d40d5d9a34849c3b61f85aae039d2a846302179b14d1edac127dfe1ce7b09026e08f9f42f7182c980ad0d0d2d15dc49d256068b4e80bc6920db333911fe0e201b94b0e8b003a5293ec84956c4376c8ee292b42eb09255bb38eabee6f6a6ca74247cdaebd6b792a49a579438c96b589b08517d8e5bdfc26f33057befd522a152ca401c8928c45b6714c866cc90ea3a833c5a4e9fd48585efba966462461eb1f43c450f69c723a1d820d2b197cd5fb332842e02f80d6995802772f91ab28eece5c6348fb3ae36d20647dfe544b0a3046292ad6cd12aed9ea5dfef71b98391bc37bdb17afcc871fda208154cbc93d7c4f699144cc0aed4b7cd106365109750759b3a40f24610502fe4de1262bccb3b565b20348d80cc9fcb500e1e0aab30c7ac88d78a6020cfec4c6e8587aa1ac3b6ca65f49de4e8b836688337849324550953cc6cbef190ddbb69df53ff27d6bced1950aa33a0d43ad6ce82a58571409ac6c6788a6f8ca795bc31c342fae310556a475c267cc972bebeb78598afe19a0ccbf9534fa304693a48658847682bec51bdb102037dfdcbc6152a46e9964e4d4973c6078e2da3952fdb99be7b6b7a0ec53af037391507bcd8f63fa2f40d21dacd7d4dc4edfba9a9962de9f088ce61afb415ae22b0e16140974bbdf2d76b416fa18d497daa0b9b76d9083acd60038c525e9debd89d86c07858da827b73af62500b7fb3a7eea02bf0633e9281cf1f04e152f8a42c05593c0387c4d10f2563470d64cd69e7b65cbc4dfc51baa7e041d5dd280a838d4b0099b8ff648a869df5d2aab4df1a0efc7e1e082d5e7a4996bb664d578e341cbbeaee7e6526fa1a03d1bac94fd8a100e997b85961f1753c31e286bf40e8d73efb53617ce9621537814a44ca485a63447644ba1829c54f25396e1bf909529735e7c6071142997aa3dc37a9e6ffe683a76b8e0f3e2eaf317086d60630c9ff4e03f18da1312753c52d2edfaa6f81f680970744f60e65dbbd75b35e09ad33e59632370aa9e5452db924eccdb083b93d2803a25d60b3b36e0f1bd6aedfa9a5833a764b46001180f0477adfacea55e3b256eb75061225346ff7fd47fdfed40d02298255d4f77fbf6705b9fd0277ce3e10a5aa937d8a2ab62853358d0ca55b8ab7caed18b0d8c403f0b5a28a46850a978d4631a8bc820ee3614e867ec245b54ba5cea7ea91c9b990110e3d01c2bd15c7295269336372f42858c93de7c9ede476a164a81c8d7f06b5f31799c15786d0009373ad57994aa067ee421553de386d016d1865d5ae815fc34520ea7d7fc0367fc59eac63005d278f1db34b74d3ac98443e0e436f2dd00781093830257afce0259bdad846096604a343f454d22535119b97a1ba9668d65209c82e2e45f3df79c49f4bbf043839ed489e7853d48af8fd1aca794c472ea5ac8032f9fabd1b5db024e1e7a14e61d7304dd72387097352b454644846a7bd0ecfbe45702f9a087a60884bed1c27bd36ff8851df884dfdd1c6de6063f9dadf37467e3b51bbe5f7b14a0be7587bd7b76628e9102cbcbd1035e12c4b709dc34953342355665759278ed3e7ffd86203572f71a16d92b7e12ce9dc6811216c4f54e8795af68bbae9fdeac716afd8acee63db43aa21f72ce46d67a4b9e0a55a931f4d29841e69326fff28eb6098353c464ed6ee63d82db0c6fb02abbe981c8f2298a606bd4a0320e88b837d062fa3ceb5fd405e4b87a87238ea0426266a78b17c6f9a495f9cacd9abde81c3c6347af68e968f7dbd7cea81fb9f0d2371ec56ae642250b52069f75fc3270f46067542f85e3d7e767b490c8bec8cd962f229d5531be218433292a9da5694e1c5d1417120e566828f5b82ab19f811ac4db46933225471d37e035a10e5db18d5f6c472ee3fb4a13ca3e6d03e0ba18e2ee834e67925fa2019caf72da332c74e44ddbd59ae8e99a7fef201d3b4da160011747aea69c1450a1cb41e1976c5ec51f911a84e663b3c25ed9b98b8cc31ab1d4ee267c796b78ba546de3b728031fb452f56e728ec584d1d5683eda876bf8c93c1db862f52fa810a05e74bc2c4034f36e84c174f9e65020cdb41473f52dc3edbf9ea9cd55de64c9e714c86bd96dacc441bdd25a9111666d42c59e1191d05b2f9b02981dc2410d70d0310d118c85c2be036c73f95c5bbe6db675974e39fabc1032920260ec099bdc67bd064d28470e6f935e195000411d758096c31680646fd00f673e89675f1d7887f26a2379865a6c2d0bd5fbcf4557d5b7d9cecb6c486a97610fe6953705ffd44c360c519bbb7acb6af4436284cb11bdf8bb3f7e1127a60229a38acf387c94da4e5eac767bde23187b8c116afa9de819136e9cb77821fd895b85621d880a1feb29605196a3dd9c2597e9392a0a9cbf38aca6995d2dbb4d8c4eaaeba23e528ddb0640f9cb5b782dab1ab4a8d8004addb4727aa05bd2e38e90f70963561092e598c8e167726a418dc44f490530306a939f4c7e2f0a12dd57e425cb424e4c469699f5706a7d0e93e104b29e7f121c39164b55bb4af945a9e4f7204bb2bc95bf9d5491461a919824369b04185afbe34c2e7889a91fec5cfe62f3897d38d9882943bf377fdfb0ac4566703335ae815e9ed3a018d19178b927fe9b86cfaf3c57da97b9a0cdc6a89018d75ab4c997b5e84463e767a093065fcc1e9765f4afc28185a979ea8dc351c515bbcc718d3f436200f4e9175b74bf2c397761d490cc3be1590a11729401905d99cbc2dfacdb1ec52ed8bcbfcb1b121339467d8ebdac0f9973ee97b85b718d1fa44396ecb9dd292f2fd5b4556fff5ac39e41642d9d6a3266a897852a5acebf316e79055854908598d635d1b4e98359a5cb23152a6a15252522e4c2bd624ed918abd668207c1c94c1025629933cffc16cf8d49d7984f77ed05da89f275bd50260ee95c14239242fac14314d63c8aa05ae0b4bbe9311e88512bf4d5f2faca7fdf3d849a9d54fc476b2bb6b70f6efb49000fede0abcdb56b03ee805c3322f6581e6ff10dff37e620b903195db159156e0bebed30063acb22ece15daf47a830f65791927ea6a2ebec13be28c182e769a4157c8349f03e3792b721b26534d708713654c95997cbb82417b1678408003e7faf10e0bddeb1f97478dbdc52b2cbc8984d7fa1500902697e0fdc75d9ba98bbc99a7098dd33de17f6c3f7fbac1c880a62727c2d1c311d4b0662fb470484ba08cba8e497e33c685f1dd6879cf71e8e165807bf405d336456ed66b85024bc94d0633787d8a5abb9aee9ebf245eb61a66dd3aa0d364d9c0ae64a8ec324e54d68b08c4b6ea31cb314fe83052e6cdcf25e5ddb8275cd183c6c5db763a82041ba1706a4e26be917117dccddc03ad14e7f78cdd46f28432bc3337dd1a2374d4b85098dc96f3cb5aef730a22a984bf08b0b398f5324211f316ebf5435b577021eeb0f97f95cd9a3285719116a783c6970c255a51fd90a1af78eedec12f1a07150d0aac77fac61d2933c8d4bdb4748b806a63af7138e5ce4431fa74dfe459921c40b2b96cd578d96a55e1079d840e9b4c09b4b2a5991c01b3417eef64f8320debe173cdde7f2a4a3e0d54ce6dad5116eab6f0db9787f6dff7eab12ec2b90f546dc671fe81f0adec9ba7ed01cc700e96f463bd4250e0e6c5e210d1d2b068e26954bfefcac024c106aae619735695c8b953600c23d0215b4a04a4601e1769226db8825120dafc38ac7eddf648d5c7a12954e4e3175c5a180f3d86cbc799a150ba041e110273e3f41e642b1c8bfc36bd4266138a155d762242c386502bd496307c8fb3bcfedb717695f372b868c4dc3f085a20d2e13f3c45a71c562bb395bc279d282e689da6974a30642591746c8438c441d66176eca4d38897d41a1c7456375729e8292a5a2ceb8b1ddbb1a1df4cb6d3043a452c9647281ba6be70e02ed91847727e849e5f266a8b4c2c76c319c294b37d24d0f1790c9afca153d780b75eb83a64b95475a6041db76e1a0c0497a2f13ad4ba88519ed6918ba77050101fc6e5867bb695f8e1d20e7caba34ed08632a6861a7923e200f4ac614770a1009d42d905e95129dbf40d4e0655ee12dcd7803ca249b12f09a41a87ddeda3518f23bf42913ec7e606b39afb65ea32dc49a0fdba1dca775cc61405e40db52a5c7640f50b1f7b1e3c76ebd50bae1321751f3c4871ed4ab10cb3949f27e506463b69715218bb972a258490bbfb92c19abc3ddf4b2064e67d74072e8c8cd7457aac8815348137ea311ecb7ce03d682f670ed956442b9da2a46cd329536f7acad83162ddf3ae7aeeddb043828fbf7e21e9fd5c2c51fb322dc2f8af33ad69dd1befd2a63cd9290063899305fdfc51c61456146d5ada5707676d62bdf8355d3f7d8804a8efd2018a0319039c52d0cc4d760df86943ad4cda15f4c16d632c04358dba745806780828a2dd19b4bfeb11e9dacca66acd62e231e3f7c6cfac2cd1b57681a1e77bd7ddd7ee5f698678c327bbc8838fbc49047d60ede150cf73341e8a90f298a555e5afeb497552b2eba6f59093ea41ce0a6b74eff5cee9cbb6f2715f83e9668f5b5eb2b6cdf3fd6c86f85199022079addcecf200e5611ee92eb74f84e74c7e16c4bafebb62d9ff063c274060a40f2e7d23e1abdfaaca344a4864c1237124d625e988906b30476f8ca479c0d4e94f8b13239d88f0fc4c0803b9b0fa86a1d1fe292d7b4ecb5bde125844fcbf5504974d082220341e4a3ed309d9fa31aca88c4200708baeae6e6135c69e7eeb55903debeae03c7759813031cf763d2a8af34f324800119bcc9d4f569e8f62694d4fdccdc1a84ef0e468fcea22a52864e5bdf0dd750ce7520e8516c921ccdef2a08b6f1bd057dd0721d88563bfda239103ed9c4a97f66601d19b5b2fc96f7c0312ee3ded561bf2a9e860c228da6c6c3460edf5a9a24a9f86dd18427025283d8ac05702d286d6e61bd461fe1e5930a5821b2cc99373d6145712a4262fe2d8232e39bc486c662f94c5ff3ebe2e04b13e78cdf15c8784a5f5eafca34ee54f5543d063dec0a00aff4efd177ba8cbaf4ad7ee612d6a9236693f685b0ac2484cd1c38f663e32927524a3e7434989db032e2c2e34161dc81457845d8b03544c617f00ef9eede36f93029ba6fefab8938d0cea2250c85a467351b2b7c628eaa37e8356d17fafb1779ccab24dba9661b7020276d68d7cae0e1e90ad3859e0fc1fcc7f88ffc04b8a8766ca75e0c06e5ec859221a06afd794bf8108fb6e0c2937b605f1450daf3be1a49edcb236fea46c56a85ca9d0bc22050f6ba55d9a96ccae1f231e20b736e24f19a6f54901a76672437179ddc444cfad17d924f17c2b4aecfea7bda418a27d5b6b1fa1e67edb02b2e101e445cff99f05f1cdb37da957f22195aad983119b84ba55940cf8f5c419bb0075a7f462249237c96ee3ff12e393ed0504cbc3b508511c7ec66cee94c92312520f85c1714b2faf23b62afad416f5fc6f218239a95f0ec64fca5c9e4c99eefb4ced4b37c9048c8e8784b1cb150b0f5317fa44602b18347002fc784a93bfe8fabee3de7dd2c8ed4c5b5f07d990340a26d2f286bf5e9a90cd290fc6ab81fadc08b7e113512ecaa913adf12807dc1b1bec8b2ea483b361f0e5b8518db37b89f051d5cc7d48ac5ff1856c7804f6f020bd22a23d470ca5a55c548a76e0093ba311bfb881b99dcf17e23384eedce3e569ab8e604699c61f406a98914b7f1031aa81ac09ad653fa93e9796dc326e734750697408851a85730e003b9bbd966f762d0f6a64c56caf4e53d36f69f65ec38fe63fb539f0efea76cc01dabfc9521d2aba8e1321ac48a3d0b1248481053a765eee58d4ef77d2f65b6e2b0b42c42819d9f6777f45cb2f28878100b187e98db90f6f1dc0dbb819a86ee851af993f428d932c71ea995c7be23d42e28fb753c8620b68cac8a090dca4592508d5217538a02d1cd91fa167328dc069884ea9187591dfd2c6e620d5dca0a2fbfc42570f2ff09f9c87ee9acd8595a00699891d4972109667a60afb644778e3744e5603a495b919309f75e082e6c612ee9bad6504de45688e3d5c8481ec3194a2c04ea57a8865491650be779fe15dd68662198faeb9eaccf7a30a1fb664fc42647a63def68790d0b160ba0b527040f5487fe6414ef036c1cee83b53d478393e0b03662d73cb81364c2d11a4f6ed38b0bd3ff1b846be3c7915025b2bfaa375275e4fb7acafcba5176ee317c9f4e0270373626945778b64d6bd7aeae6500007795cac966e0c8e4cff1907531640cc41735c57c814cfe53194a1dca8bf3a207325398497a83e86897655fcd9816425d2dd4188c644a94c15d9e4d3812d5feafc1492a96e87f5874ee18302bbe481ca7afe89aa47f847e45071f681a45aeb23d8b2fc8dd661d67438055b5f0a3434d06b9417c0f9f1a87aac647f25dac9ac6b43e4ada58b3f993094a847b48df430659d31d68fce60dff58e65ebc3d699b224d2aff027b708ee30b53ec31d35ec17bca18b3fa3a7f057b7317a5236275ae2a15e2c165c2cdc31083497d55370d1b43299741231660f543394e77c8f935667bf67ba292293b734c0aa6f20a98cb0201d33d273a4892e8047f9e0c7669b1083c8bee1d51024050d25ea5f8b2d87c7e0afd6eadd16d23fe76b7a57c0df0a91f44b6f4993d091df326b3a181ad1b0dfbdd05d07e38a58aeacca52b4ff9472fc7ecbf43fb05e84d30486d2d5ad8fe52569b9a62c498d6d813e1f2a22d6c8094a591119d044bb2e5af62036cf36b59ea9795782839d5e4cf7fafe20bd3756a5561ea71769d602c7c235c7d69c054f2150e3aafe2a790a87fd148a80286d8593d8314550bafd7d29b8117ab6efdbe0894d19478ea6ac3982bda28bcd270ff627b2eeed2a885bd79adef0931dd39b37daad6523b8c5ee6f8a9f2373c8eb4e763161892d88065d0302b185ee8cd110be797277b01cb0cf76f560747189b19fd8c6d72d85886d1f678b9d25e7e4948ed05ef09b5b0e04f75cf29b7a4efae3eeee5a8f957da629cdbcb7a523cf879944cdb0b48f93f1d85cf6a62fb67dbdb892e42a9e23c25b097cdefad94b902b7a00d811e3f723945b9a7667050863add33547612af9195b49770e9cba1c872c948a4193c00aeff7858066074e0a6b2880d1ca46019c28280e4db86645a8acbe5fb868bef7cabf84b0ad423525398877d2a3ff66b553831da62c753b5a8376c006e8a216285882eb96057d3da562296881b1a9ea182cc4f72a0552d38711b34e7ef60c77f38324fa865fcc658183f55e5f45d46b2dab15d68b26c5e2e6c868bf00bb465c4201e2978f3b9e544a89028bea9896eef008796cd66324e13caa694d4a8040f5d6f6026c24fedf696cbdbcdca3993ef4878f072a3546783f97a37690094514d783b9b8a52f77a4cda848114ef8281ffddb1ce90a32489980713729151b91cb68a7651dce6edca48bee7d29eea0cd9191e4b28529b7a7c5d040317dbc88e47d25a44c56eb8e70e7f1574ec815616b6f3752d2bd8deb8a6b34f699db0f7ec4074da69df1ca6b8e271c3276b34660092fbb231cb9e5e0a80f5dad13ee6990f1d5e015ab3598dfd3b0b379a42dcc28874a7cfa18430d08c9679b43523bc15c08df9e3d390e88e742aa5885704126e2cb39372a923fca2039abdaec1ff212b3272afae757f260e92d3db18b7d51f152f86b21023156b76d534342fa46001aaba5ef779dbb1b026c4bf8a43d1ea7233d8a0218e274f84b1e78eb820d25dfa779175bd6c874410a74a6f24782d5a838c7c7205fcfac26b65ac9249c88ce7a05deec69e76ae561d84a4317abe5afbb4e5f5fcd9a11c2e2e6743516d1546e241d3c9415f140d5816a248edd13d68f305b1a24e7ad202c37190c44e5100c978629217399cd115a0c5ab2610265c99b281ab6ef81a4c2a8b994601cf6c2d5155e416d54cbcfa8a5c293f506b15cb18a3394c89e116d7996b597c1be544d173b31f430a7e4655310d2572c07a89291139ca65df91e0e077361a1b2dc74b195e6fa772b2781b295d7eb2ff72d21890e236db7cb8e9f2ffef49ec6ec5947a16e7598e2542fae7d422c4790cb9e6c5d58ec59f3c8897781da95bbd8fd23a8d22c8e1c87d3675a0989786c0b0bfad306d0e7d3b3b6012aaa7efe7bf87606d9baefb4021d5b4ebee5938f1ae6fc93c6a92af5c63313b3386a5b1a57c6696ae1457bfc2c06e90abf3b3de86e82a9f1f6ab860af6d102ed6312b53ab9c70380c4234aefe69f9863a2ba525e8fea5da2feb8a40d53477a45462e1183fc2e9a34fa563084dca31ed61e4d236e52fe919e56fe9df70279fd3b2c7c4dfcb9cc9b9b5226f2fc7c007af57bfe9908245ab9fb1c57ed2ce187f73cb7c9a24ae6214128049e6842456eee311b01a5a84d8852b76c94808689f7ebb35636950f0642fcfbafd42802ba8d144241eb7f7a379f7ecfef3d1e3f8f3c903abcea1300c9b618e08f945759e37e89e9c39cc8f0a89bdf9882bc57ff7fe462f71e04f11c690d7ae3c5b7de8350734beb1f777c59b89cc90f883f2c97dbc758a16354fa9eecfb45f3b3db6f9bb0246272b2e0c6feafb0307410c78b326527cf419a88d05aa34240008de5090fbbf2aec6c9cee010ffc5eb114ccecdda91053610e369cb331399d9cc97989b3b3d3a86ff6b80f813dd6208b0d8f6844ed2fba73c7960161652ef2e9573e52890980f3768513c3e6fc3e1cdee7dc230d8e140bf067cb416a9287fc36ad3ca4bb3ec3c5ca16ab098cba69ec235593c4604c91b3dc10a0ba93f4d2765bda1eda0cb653a59e656ef9d1bed3ddf2f175ff31aa6c01aa540a6201e9911bcd93b0b4e22b27badd0e0bdd2b0ef47ac2a2615085e6c13ce395b904ab49fbcbdb9c5529fc5d3d03eddaec4e9e92917c695aa1bde824500a6f4cfa1a2ac1cb6338482cd1ddb6114d6971b93d13419a2ee087a6d3dcbe12d6fc101bb43d981c24278ea1366140b3fe6df006a9ad8b45a70722fb16e61bc54c07d364d7305db38f49795c8805fc785eca29ce64ffd732dbc5f8062038d24799a2d95688ba18830bd44edb4d219df6f96495aedbb9552e1995d0706f67c4828686eaed7eefe501f12241c23988f919fc2c012614128a427ef28a1cc8183e56e7652085093c8545863d7c9d315bfda47b886f5ffaba0d4666d20444660c9814a9e795fbe0eb4a6dae9da966122581af39b374ec03bf424fc7fbd249333e62381e9755b5ea41cf0d56af88ac4aafdad79de1b0f43f4f508ff38ce974ed7464e1a28d4f18e1861ed20bf0c66fe5868894e2f2f42a60b20673e787df50dcda6223bc11742662a69f804601982c09237e7f426daf060b69a870ec6d0ed10f49f726af199c94977558a7175403d6c0e99a056a18ca37350b3ad903c1a7df19c2ddf94975875cff761163f5a8df095d09bd4f2c305749a1470826edff9419809e4b74ff4b8f969e98370a2771d6236037f8550010b8d5a22eb238117a06b4c080154fd328b40748689601087218c542e20ea959f22bd1d3c3ee3839c4cbbc2eea8a243bd651c2b1bd282ed83c44b8e3ca2ae342dcec8296f24665a567be81a77ce1c9fbf43c2a953ad255d067b8ff8e885eaf57dace77018541bfc75815e68dc10dc2d41532e5747a86360fc20f72d79b3511826d6845344310280487f7ed8ff7c2cbff1d8a3a005b4dbb3cc718a174018e33c2d4a305d262160a2a6c496ce097c15f4c834a0db4f2dab0fc66b2ab9715b787f25ef465281a870da4349fc86f4abd6e09b70ade4ca3b6da44c0ca1a22628bcd597f7ef626760dd6a4a5291d974a5da7fd9da1e369a7ec9655ef54fb3e74cc11ffba46ba9fafaa713f73e4e33a22db28104c87b2a26630e2e43cddb13719816bfb664c5f344597fb11785a0d66aafc0cc7972bcf87b6fc3c52d0c5b59c4a576817debe0bafafdc45a381dc87a7fcd4be3263fa1ac4a6cb29982a41a9ba8964f54e3eebe1afa3dff79819587981b9a8f35edd449343f7f1aaf86bdaf6ac30a66ba1e49ec324719563f175cbfad500634093d11d477ecd87cad12de230454494ddc167a91a96d66058cf201e9f1e995e8621e9c059497dd21a4915395e85f2b48f0b09ef3e5bd15cc2b1e8e0f17ec169eb196dda074e1c12cf31af9c54625b9a3c270ceabb9e68d4c42e9998d2ba7cc924b673f763b22440612c2346bf93b2941a73a16aad8a2b89e0c26b08c5349c46a6365df5b1e3fabfd9936f8af2ffa9b6ff522bbf958aa598e5dc10b21716403f5ced4d1d4a485a3d5e62d508db981aca882ec61cb73dac4b4d496c9bc15a7b02a3afd680d01528ef9b06117e7ac95080004d4fa1de997d45348f5944ea72cc375079257264eee2a4bdaf1d9e9e73b3b07a38d8b4cb81e55069c24715fe18c3cba0c156c71e59291496682f90fae56edde0f5b07520223e0d80474ea1f2f242218d37ce468a3debf147b1ad0655faaa986ad74a9e11f6ca96665749ece8644dc0a9e1eb7b204e56c4","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
