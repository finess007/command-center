<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"33414279376f7202ece0d6228cdffbbf597e0f147d82a4dc46e8cf2db4a5ea08ea040f8d025a9d8a8f989f42643841faaf17cd8a01043600829493c8ee9c894888aaebef76c4ae542a777d96e732c94b44db29eb53c8bc01455f797b8be07a92c47c6e33c640f3583a567c1ceb21d97b12dc7b7c30b23395d2389b2f881765ed798768808f4b1ccfea355aa6f9c15e6d3421c5f07703614903b65f990ebb6a726c093021c16eb205f271d4af69bcc5a4695d5d799015f8484ab3272e08deb9c95834da37fc7cf318aba26f30a662bf67db5e3c99c3341fc389b005cdb90a17e630b399227b665dbf04010c07c358aaddf67d0417e7a636122a3e7ba31ca873ce4ee31570b083018fac82984ffc10cc03492392940fca4257f91431043f4ea0adffa82c604ad5de32a247bf8d7685955dbe13f5338fa0bd4f2d5eb324c6a72b33ef56437680120eb73759d6ad3c574b2973d057b4933f505fb4fada365dfc3c81e64924f94ad35d595133aa4e3607985c23eb315ba03e3660af6130f75e3d760cf4d9f51ed297b75edc86e6d93db1498342e0ecdc3f3fcbea42af7eec614972c6a2e6e0385f3e8c754155d811a5760e4919f093acd17c7e05e6de2efa51dbf2333c3734f6c9c42a81112034a405345245c16b2822534f7782e10c156c553e1d8d4bd02a8c211387101aaa462c5d66a326b044e53e26b67bcff53af701cf05e2909bce143fdf6ef110f70a21d2d9c483e2c186b1acf5ff4a1965f0f18181d251430d1b5fe8c22ffb43dec31dcbb21dcab03e3a75186d2e3f533a096dd3eb1c25bcd483b945fd5485a84adf91de0b558befb11f05c0e19ebe4028795a5bd163b2485a697f8ec8fbbb8601bf51300857b6b1e1659e3c058b965a43e6016d61d3c8aebfea1b495081c5162ca88818f283be7b384e59a7f464e2d3b99375bd99addc6de75ef4f065906be9ec7b44d5641a7cb6a3a174659ea860c662c5de87c28cc7efba5f59812e0d4e0aa9050787f0763db9c00da1f2f411af1e4b789afeb5d0be0f840249f2a373a350dc366f9d850c25d35858288a282b4ee593d8c5a101fa914e2e6468d661f75439e3c42d922b1c080d66b3d4565e5e8d55c21e5a0cbe4bfc95f62dff075a31b62c983964f59618cc39898f98ba4776c8ae79b97eb1fd2d59ea655fdcb8f5021f1657fd9e56734874e589db55d5e90337ff9499bdf3393145aed5bd153c7df9f56325c88a9d1710396056df2db079e964db4d9c3905b98040a7b1c53a1298ec9bb0a91a08b2053242de9674976000353c956727d619ee3535e5ad91e7d7d8976c9ce93dab494f70016f093818dc7311e41aa3fe0565c5ce65a01753f4aaea6029727890d5020ff4bbebb9efd2bb22c8c6e96937d088d0787d68d7abf0489ad0047c621dd5a794e45687f05cddd4ee69c65d50a1ce6c10bfea6d77e2af2ddc0d3f2e3352522945da862d599ca54ca966772f4470bae2dac8764978f2e16f37ffa3d50c0f92a3bf5b4fea30bb308a850d68f8b511e2e9933408b860c40b9593872a40b303ae3ad13a27ac38c4901f5592d88ecc7260e35adc47cc8c1b104ee6014558362473c6b33d553485c18bd1a81a17807eed0e69515a18e2d8caca7d4b5624317661a570b42cec2002e5956898c7af934e2462920b176b0c836630d4b2e7d615847e8ef7fd3b5e88240a563e3723554414562a74dd0437cfe43ae95d12072ef30a50ebb808c3ce5538aa08b1939bfaf46091809b5a1b405818b3a2011226aca4c9e9680d4197629f420a660275e909986889cf6eac8892ad53659199ecdf890d71a78ab6248d204d81e4966718fccd001114527a5c17dd098df82b4118d1d1f276c50558c4051a765afc439cf3dea6fe3c9231c234f0074a32a05283fc33c1884a1406a4db3df24616ea22311b79c64f510427cb01f0a0dd66b556861f305ab16fc05f74f8d9ea52abcf6ac947f29366b998e2a36a26a3094a01a2fcd5091c648ac929e3ff9ed0b041dbdebd7edce4bbe3c708836d221b4ee0014b89148ed1b6430020a245dfbf499b9e652fdb7845a80b103767466c2bb69245b0aea038711ba03ac00d705ed6f8fed4652311e7b984f0e933ddfc0906cccb6ee383a5f2c6e65b8d5447e70e6aa83fceac8239a4876b5bcf561d9908b9e32b32b1fc22b8e1334c957d2f8bd564acc82e2c3efc07effab11c9337123ec0cddb0edffa642734e9136de66b4704284f2f9a6e8d054bb16c7febd805363170997312e35d0f5a5bc69ec2e25344a77e7f09336c0fdb5f6166dec676992b8edbffcfec0ef32edf9ccf87604df301e9d62b45fa63004e45f671353160a6d19b057eabd2ce8398e95cf2cd3a05802737ff492e96473c6294c2458dcac23e938e9b7339251edc4f9d430231072cf3a4506bbd4a13ace8719f871c846ee363171c42412339685861ff9fbbd94bbc402ed55d6bfe93e6f7a1851bb8298a230c9db7c51f496979e47ff6a8e75671da2c895f42c41727d142664f4489e547aade5afebd9daf27bd835a3bf0f0051863f9608758e3a455417242a6c4666ecacd49eb421cb324803df6a46330bda60a1461105230fb480b8ef4ae7743f1c35dfaa1eef26a043b955e426dc944377fd986f605a664029b726ec263718aab67d629f2cb7bac2154593d68aac67ab99629fdab2954e71d9867b9d0b1580ac08f39124876ef860ba81df14e9c59baab6540ef213e85d0e99efc69fc8ef0996f4e0a374d3fd4fc98aff6f53ae9152a35e60eba2a46ccbd16c15cddc3e939ff1786f85a4d90cc63627e411c4965c029aa5a7541b08d933a480741fd3150e43b8cf30e14189edfea712d915f86edb59dc38241e426730314ec295708463c3480784038c5d1b57c5ceb005eb5a311a504406bf63361e9534dc41dd2cfc1548a5117eb5d53f50a547868bf58eab5cfd225597dfa718790932e25fa2502d71885a34465a8266797eeb78fe45b9d480e975d549d64a2930abeb82978d7c77e9f44299724a148d31b89205469af5d023aa3790c7c13184fb533a5dcc8e5d2c41e0829b80d6bc4ba719b0132fb730f103c1a5fede690765f79bc097ce9f65a12ecbed2bc1e41ba46398b5120f4d16897347ae91bc167f7e593c252c03b0d713371f1a2d6cfe02b458236e24a81acd3b4a7f96d5f69f524aa67dd04613bba659d8786b83be8eb5d0654131eaeac4190a0abd074b4f37fe5200566f463dba6e8aea4362a2b91d50805c92b176b7458757becc8f36da2b7b711f4f76bfc8ad635e02dfa72732e4638d2860930d822844c3fe1ac90c5f4471dbbf8b93aa925cacd1f4676f20ad2b900f55e3d552b60f9693d1a92350a517b4bc04464d1ea352f9836e0c6afa7d43d4dd31c5f835191613a3055f5996ffe10b0e1a44b3d99d49ada30e46b5d0eb64dda7550b5c09eac2d5ea908868ae042df8e4d3e2c9b31a4dc5260e3213ce4cfa6baa060fe4c8754de2c0efee00add0dbfe0c631e68cee032efbd5539ae4428759ef20837efe274b75e9e4f714e34d5c1847bda56a1dc177148b3dede1d2d9369becf49c74dd803009f75ec5d7bc704c1aaa6a097a9af69c8e026db8694e651601a4ce01fde774dc7cb3e0bc589e4f1be448c58450465de9c888c7be2f5f97ff4337dc6294e7ad1a03204fdf36138e6a9b176c0dbb53affdd205cb1b2b10927fd0f12043dff7e2486ac9775b6e794b50ed84cced6146896da55598d5e50fb6f27a9c8e85f28e689a3caabefeb52a2a29ad85b12187c76e926e6438a09064553e990b4f5f6f5facd929c0bc9ac449f052644402f635f4dd80f499d22f0cff13abddee643594875e0ef1bdb468df971e1d50a5a478d68bd792b23da422d8fd757ebe9f8b1854d1b451a5f3ce10867a3e2f58ec0cb6714915d397d25ad8dcd35badf57c69a3908c9987e3afd5818b44e04f3a5aa8591d8ba122b7c5c908c72da269a6cf0087635963095ac02995eb540357d603e4a46ab9bca3355a5f90fff85bde24a81b8a74ae5a0de1035d431c11b9b62c3fd64e1fa86465b3e10cd27368ff2e9cf703ea9740406946ed81fc6dd509d1293c87cffa43787ff39907432703a11df561e775057ee5a5d00f13c2cac49067bc6717f25bf919a9eef161ea5aea620c0f2de5216abd263eef0522f436a2f2e007bcd40182d0f93edb2b11a9a2c8cfe94e59562871370c3a958e09689f323553a33fa1eb061c97347a755a0bef060787bbf0d58077a5d26421510185430aa127558798dc98106871036e8deb41754992808397b98a08a29211e73b70f90fa0c0f47c5b7b9477d715644bc9430186eca0ced2579da36ce145a8b408f519e390b4d8704216ce04c0177357d2436579b3e7626d968c693efdb067aa0defbdf2ab4ec30f3f9a9e27e157368278b0c320e8e86b013bd2e47540a111720c95b38f963c0c08708291da231d320ddebd18dba8ae409a3d53f886391475e008de992716e3511b80196c0da8bb11c7f12a8b30d6a443ebd348e4f6ff146514c604d1b6e40ba08dc9d5a127acd59a68e0b0e9208a143a56424cd1640d58aec19b11ff708026deef640b96e31f9f688118b44ce429f959ef6333486f395f1b7cf48cb14f83e559fcdecfc57e030fe527c0824eb02c109a785a54d4d73b9c8a8c29b8e9f7d99e83112906e809df913f9112145d7a12913dd5eaa36fba9fe6853d482ac8f7f1acfc6323bad31ee9c75254e3086255c59fde54135aedfce8cc7e4bd9d4e5e8808b4fe64b8c28c74bda46ec8c8dcafc97b82fd173126426d3714a4e9ed61141c11b800dff1009def830fe791a641d6960a4d7e00f84f36b0bd25d91344795e4dccfb7fdbc282e69b9f960f61168efa18607a0ba0d4c60eefae4458826893fe68fe04748208ed3c4c11699d7f6516684615536d5417b9f596c9e0f62e59814e05cc95c24c9a4a73c5c4a33d59c10a0e95c5c013ed44bf53329e469179488d796e770ce3bdf322334b1a3c4164db1c550e8e1d8444628727a7e7a9f14a10f121842579ba82696aa88ed50d010140532bdd8ee95397442a0d4705029eb92f5ed6d9050877c1745ae9ce74b078f5037ce365edf56a40fe60e54ce5cd10a083d852e538b3fc486d3c192f68e7466829fb6b401f2f6c9e39d6a9295fefbe61f5468c0ca7965c2a032b64bb0560cc0a4e82d425eca845382d6f6368620846b7f3d26f43db14c8ae018eab0754eaf9da4944b226d25e54b39832768532374ef5611478f38fe3cbb49d99e29810a75c77241b00fc4b397130607ed1fe1e94587aa920dd6dcef2fe71d1bf219b1498df8999d221c943f18790d145229b66b1cd50ef9a6f5949936343d2b6f2cdd1b41016466f9cdcd1af08afb73b6e1b020c8f904c7a47a8917ff7dd5dc33e8ae88ebd1293007389330b65bd075c78fac898639a1845800f1578487c5b8687765016d349b3ae530cdfe8e649c54ce07660d9d0eca9107cf854e07f3eb54384776cea981b2e4fbdb109f4c0717f6acf35de8417bed014a375ac9df30a7540f901ccf11da68ac9b14c0933153da6ba678e770d16cde49880e3fd150dbd3621f00fb99627fac3835d4190d0112c8eb97edd3aad4ad927c48b1a39a4bf04053200eb012fadd9c60bd6a68a53f1ac8133309c9105cd2775fd6760cd044c42c8f3340a609adb69a6d6e686f9114fabb6411452b55b964c4edd6678600c0cd3a370193e77fef23b80c1045d271b90f529b5e2d7ee4050eadc49976ca2ca4a98ff5994fac4780ac2273687dfa4e52dab60750a62b1a02b5f317894254ddaf7a10ae2099e4bc612af30956daee2065155d17a38afb6c138b4c614b584c8836f4890d59cabe8cb0c611f8f6328e378c95f34c6141856cbbcac744c840d93baa11c0a6e307f37cbe1c00c4ddf3ba25eadb00466b3bbb941f8c47b21b35a09d1f06551e23af4b04e7f41ae7d3a76caaea6c99453901365c0c05a46504f4e67dd9f89131c64a0bc7b6a5af90147ba68dd7f840dfd34ee3f64e4f4504069c171c33ae5ef11ce80ad1e6a51b1ff1e4b462ec5aeab842a104b369f5301a42c79a16fe1fc59b170697cadc3eaaf0df99706bbf1f6aa9425c12c4fecb8ef8300df6b7de8184d02abc4d4939415d039f7dd50c89000249b112438f916a2a67f37f5d43934dbb7ac3ecd673f01628e55343f26f3c604edccd4f30d86d5ec2b3544ef7ecb3dcc6a991cb8f1ffa3b58cf6b37bb9047d591c36e167d21cf9f5454b51eeb88efa149f7a7ee9f7aa8ab762a6f35b143a89636ac906b0b8c9cc0eed4886bc9e89679251d2bdde44c52d36638f73500d6fc2c5cf969046c38327951f6f3a9b88aab7209a017ee995c73ed1f058f0bbc9bfdb0b6c08e3dab22ad667684262c8cf811a3ca35242eb310ebd889502a5ff76ddef3adee31032d4b54ae25a146b3713aa1039fc29f2e1a0b1ad1ddc8850496d7202826e4e987e3cbe52e210aa3904e03fc7defe669a931f192d78ce3cf465276c09721a2be6945e529a45d751b81de236b1134f684c56a090881e62aea10640da1c5be4d580d3c3a414ff2476f198b4e8fda1aa9ad8902d193b8c6ea0cee5d7998e60b234b8d74a10a5b2f6cfd77ed174338a6641f80fb7f73cd69b511de4016982c307c7b793c625afba1af82d26a16ac42e298c1ede043a9e00f4542f1e2de9fd747a8f7a01737f7aeb183cb34c0fd4d28ba6841057fc9bcf642eec81ba5111802d882131bb27c3f10a67e1e676691b81853c2d8c845098f330617661b8a86ba8e4198ea49ee432ea6b10964fa43c17782ef339b3b68330285d285b32fc005f41c30440ee1cf885ed054cd52c45d54951c986a957b1c9c135235721595adfc1f46d59176ccfa139bf3a3f1ac96ac33f656a47717b68a8c84c75c81cb831a2d69a89d16c017a3df296a5c5d37fd99b8848af2f8f50e2dce66363846e05f2b017a280274a5d15ec4a661b0efd243e3a7a634e50e958a6d8d8c1939922196a6f29a45f144c5b109375b0bcb435c270d58976768a886bdcf9349cb6681ee60f85896ded02999eb17171730100be64ae265b1944736893acfe55874eea30ab93e833537c61718bf94d6b33fef54218b1796aeebb553fceee187203035e575674d6a9096a0ec8c9bb80a7ff5c05001332fe1724c84b7e0f4e85c3c694d0e0e825303f943b0040d93dd2d89f2574b092220c1e1009caabea0ac4ac28cfc6174ac3290e44f371ec7eff17fe3def200d9a46609a089e718676cb19ef58cfe088aafbfea6592371ea63db629475d48abcc7ee093984f213e5470c43f0e40f6892062a69948c2239068ddf22015ccdfc9d506d672459df350728f80304a15d41ae77150a9e71d348e76a7bede086479e17982f6904373e73057d71e8e25167f02d4b26942859d575a3ae9b6e688eec4ba430f989fb53e6b38d66199ac1eb8232b1ed7b509bb18a3380d1c360eed6f863808fc021568854e6f09c96c218d19f0e53f18bf34db7530cabb4cc94c6a74d885d5f2b2022ffc57ee59554e7343a3e11c31e293b00bfb14072d19a377d6eeba94991f092ac16e1946b4097416aee0fc76a1a665e7bc3d6d760ab52db6e72310866368f5128f61ad1535c0c42b07a7472036cbfc3f89f88e4fa077ca8f05ea7bd8c1bc9314fd46b8917ab8af65d050e88fbcc2943744ab82927cdba39af946f7751b8b4b2e1518d437d080097684c8a806c53af9207610eecccd7c2706a34c99dca5760a4769a3e12d0fe52778ed934b94300e1e817e11194cdbcdd9407233504f4deed840eea7fa7b984582ccc6dd45eaca0ed5f182ef6f733a949105f5ee499297eb19be635367e7d11d8ca557d58b00c2ebbfa9dc1cf5ebd3d8101aff04d180105342a3ebd1e4e0243b5a5fced5c24d225094c6ea03337e60ccd46b564df1cd81567bc7451e0d64a4ec93e350d2abd8247d98c21ea861cda78d22a9126fadf17f9e6fec05f1ed419149f0259c3859ab4ed960692b004fbecef673ff2c1765c6e692847ae48397b3431a47492e1c37dae22aa7a1aaaa9a4d7c112df4969dc2499c5ff20eabe3ca164f6600967531ccf5f023ce8f027a8ca86435ee5e38804b6e2a8603c18a6392c603c6a76d206ae53f5575236f412ab7f15b48b01b111005e61c1d4197a93c5ab0a5d7ef84d354a416db38a5dfc2472b46bce52c457d9d0ec090f68280aa2d3efc337a1397040460df7f9a967aa5df27dd22e3dedfc0df9af35cfadc8dd766b6ce5252d9399f6142bb60201c1fcf8e0d52c2d5c9e74d3534bb97864d985d6ee6a4d84f9b2388f7ad058b7334ce7580dbebe23f1acc6eda0158ab9514b3fe96f0c52a82d3d8a12db23966397d3344a4bbddab5c8d0b637d1034dfbd5ea0b0fe7eed4dbe73091fbd961ed46cf5c13ea1d85ec098c0ca0f9171ec1c6abb888dc8cd847b25f7ea5c0b4c7da1911c2d4047c6222c2986270f1bf9dfc4523909b0b48ce03f6e6269438c48353b1fde9715642f989890cbae1c2d288ec27a74941f7836e422be2086e962580022eca4e3acb0627c6518816d65db3a98484e2a26704eda156beae29e1dd032e845b9eaa185b6eb4edd0bff3f871eeeab7cc57d014ccb834e46fabc06e650278140f67446285493df0f1a15dcae0332676305b7b8e407a5b5e0cca9709b748209b2453c9ed9928a08ccdde40320711bfb777db7c2c28004b32ab64755f38b2af1e6058aa8c4afd433e33bf1b43b5c5bcb85d5459157572ce86484183590dd22ad4f71df47b1292893c9ef48015b77bf445775c6c7486b11d4b0881497438daf1a28b6d1e94628d720345502e377cf1c2808a3df79898d378f8f05b7f030bc0a494ac61b7ff63380c76fe7292ef845755261e83ae47a75fae48b3bad5354ea6c2929a5b5d73c2c24e617d5bb781250fb3b146b3340dd688f33dd59deeaf7e7804cd17952d7c0c37f90d872d56132623ce69ddd586e350e44df75b3b7b39f0db3c10153929de8ff0afec23f35b769d8222e729de37f2084d18256f005281bda43628379c14bdf10d9cf2018cc87b604cb4c142b46b4f1da2fba85d2ce347fcdb784510c27bd4c58a6cd493e5863d05d7dffb68c37c237eb3d000a9f4b54d510e882f2ae651f5277575310403013ae433076074dcd7fc4f36dc458d693617468ad5d876c8bad3c85c0af37b3f017e731688637748a2faca18e13068ae947bbe0c6187069ae0ba4946316e463655a6ffae03923dafbe94820c0be273f567cd0a36a99919e64f8d188409ec038dcadd353ab853f4ded828e2967a312e4ca572adc971b176d76c2c5b8b3ddc28a753cfa75507ac645532ffc17f87e2bf064e42dd3b5015760a9e692acb93791e7e296db6897d36f4dc87923386f42b986384c648f36346f7e7656d64d1a336bb57152d76c41fdc08a095cf466ea4f5bbc04c0276196c34ee74cd56e868a20d80359e01841d064f6f22b70ff0117280e4e34824aa0f6004ec62421b4b37ef8cc3a01a41666ebb0479b1c98cfee070bc4b32811836b507ac35d276f515f7c5c9c0df2b843a5036ad461018b102eac5df4b8f67cf2853f7c26ef392b5eddbdf85f613b2df2b6a8492f96f4c0ae8df1f1a3bc930625ef9e839217a3eef990944d2adb0528ca9401e9df927dc6b566a403e21220f10b0ed8845535465cc2fe88f332be8059a332b6b3b25e72b13ec67bff90c889be7da0aba8115e34023d2b12359d29e05d55f23e55586bcc6ea27b44d6c76ba1b676c26d8e3f603d6ff10f6f84ba7feff2f0bcb5c282c208f34b385d7c3c13bd1e14b57c0e9444f2423c6545c22408329264453727e7f3a917c7628ee1217239fec7db55cb800534af37bae69992c252e889f51a26c49912ecf45d5ea7bef21165d82d57a39338691eee3105711fab03f3985e7549724cd7bb814a15f3e51b67c4075b9c269725f50f6539262fdbb6d4f08b3048af98103206eff6b6f3f9b1ca8b54bd2802752362079edc6908ca4b3375ff723a8d7552b764d4046166e510760cf563040d1569210f2b626f235b0d9f0f79fb6fc18086b3ff3c156b19353d2b37a8b64073b6299f2e72abc265742b00037b2cff9b9807aab0075fabab1dee5132366d0029987c173b6012c908ed6ff281252552ea7d47d638ef116693a62a2f26757ee85615f78d1f3448f5d62d52523651f39841b9e6429b3bb204063bceffcc48413d1e1833cdf10304883baef8489d96c103f0909d71005964e57f78151b429724de84d2d6e035409f79ae156fc1bf07c6564f0b2f1d81e2da40204f655cb878343835e4d41c0e6975d892cc332f15cffdceceb2ef1c853c6c098056206e0a9dfef2147a0952a3816c3955103a82c782714054f4f90e251805750eae195671357ead0cb53d8fe445e5e53a7101676c890932f1b301bf1d7f35477b43c4507eb5ab48cfe9a20944d72bf26e756f9f51a7c77498810f65249bfc2eda95faf95143c39bd87ad562e3b7d4e078ba985b52c3db3a708d3d9fe0ce7f5fe6663380d5746891e4cd2ca09eb8f30ee6258d973824851576755598fdd3d829b3bfecbcbd404b62aa3e73df0cc12570afbfab20e0fbc545dcc31913546d726cdf58ef6c27180178ff2dc8d0de7f6a2840a57ba25b7903e5fe6d5f059900656351113aa0a6c99d87d8c69098a4eb83eeb728fa2c94a259265ca3dfdb60c6f6c9c239e4604f01208fd4de8633a519e80ed955c96d2729420dd5e31d2c4df9c605040f83e9ccbf0d06cbc97e4f558c7122227e24526580c0a37e42b15c0d6e3f4449bd5147756d1dbb90d86074b9b259f56d9473d003c87734698a51c7a367bf01b12d896513ac0d2056e0eb0500cf8a1fb1a93e95039f79ddb7515b131698070533834389f61597c644d32334c2154449c3cd8132e6a237de9a4edbb762ee133f4f7708bed329addb88bfc68ffb8dbde2670ed498142c3c68e6062adac794e8d34c15a8fd57f40926da6ca88fb4005c39915f9824e28ffcf3bfd7cc98240943f6b7faacf839e765eb2dae48f4395ef8ec1dc5fee385675a7c362938a832c685e47edf96594bbc3f52afe14fde9bae7b16ec4c7331ced936a0dac6c157bfcef56bb055109fd3ca04e57d7dcba311f68956cd90a7817b8eebab353f63ccbb3d2e03c35756bb786877fbbdea3bae9c60ace13e2b5f1281cc5a96e9632038a27566aaa1b185b835ccac16302b7c9ff8ecff4985117a441db950644b05bcdb8ea52807ba087eb3f493c920d85e70a9e59bf6cf5bc4b5aea2b13f1b45e067e925de8d0d3ba72e6532801c4a1d3059aa87187731c7886c024e372bd9e72aeebe4c963fb9d1971325e0e498048a95620a9d16ad3f16c4472cd21315a461d9a14907146064c3a6786cd0f32edd09bd02d83f9ef9e71a34c4c0ad311ee5727d4c59333600d093b8aba63f8a3259adeac7e88d78da958bf8620aff0ccdfdddc70c616a09a294acc6571b77c433bc280c2978d0e40a260824f256013900336ae284698c2e760ad22e5f5d34d5714c153a28659d070086d25cfdca560aea815518581f0e78b6aff6306a1754ac75e60e594968c4c55bc27f69e0189aa684f193db76b5b150a2b59fba6526f8879ef2a662472cb6a6d5395fcc66f24736f2c03d23c07bab55cedc7c02533de915b41715daa8d64449195aa4c946dd640358f080146022c52cbe2e67ebbd44200039638338df17d16eeb33a16a132fcff220fa6ba38349aaf7f311dcdc9505ed7a82d511549af66668d1ba3f0c5233b6ffa526a8b4bd6da16dc024c7f3689bab8acd8a67e2db36fb023a0bda99e4d827683442dd80dc45471c36ba6b3a1d42740ae1c55d68a45233dd5b3605168f14d708f19a6cbd689bce6686f43cff58e5d95f945f9c6a166a226b48aa9364d88bff8bbda00964810ab57d14bf61ab27ae54d1f7da0d820717fc632679dbca6c2e031f07098c88b3acc875a8f75efaeb3280cae85c5309baa57216e14566edc709d8083093d45133a289c16516dbeb61c8e70b64194146aca8d9cdcd5804a8a9f3ded08a4adbb3722558f0d854eae1b9e48b05a0048705b68b198bb65ea14470fcc0b79e9553c6284017bfe99eb7dba46bb727476c84be2ad84d6352b013e5291714f7ba13cff15d881f769ab8dbe9da5b4f9c8a92db990a5930d147d329d8000a41363434cc1fff50b380dc1c047ebae9b4e0583ebc2c1a37818cb8148639985d7d300e2049ee89c90b38fe354323c390c98235b5b1d634aedd734c78f45c152b12527f15c98970a2faad9314861eef2460bc44e7e1eb5f558a9813a3b293e5a5b25838d2bca90a186dd787f03ebab58646e8b4af62e36682fd14783f84db8254a8b1190b5f67fa1f3c8c0e4c6f9ddd218afa6aa35ab88e0772dd661f660fd4daae43b39886a4ee952f2587a521b946546454a0a7fddc5ba8ee893f1fec9d903b4b7e767a28adb6ba9c9ead9f8e3adeb1211b5c17a8dada8233b04180bc6b300b29292850543cfcd889d84916fd475233419251ab601e26d48938af85081111bdb0a15c128a5f9398200b4a072da4014874c4c5e6a457b01c1ad5bc67b41e84b66d3d2e37d1c65eda47f80fd624de36b88838b7c9415b8269ec571b9ef2d4a7c3bc9a60c01d0462dcc60bbfbee8198cf180d3b77c210600e7dba2236799fe92ffcc4543d149101ae0415f8d25f4d1155b91670a33d788cfa2e420f3c410d9fd775bc2c822ed64bacff7fae8479b4097e690fff44b7881067f871bd92ac73b459c064f41f5f354a5250131b643ed914efff2596e67c5a4be90a6bb68b6b0e40ac31e8ab4a4153bd94d4de6903d5c5f5983e2bcd69ff7182170479d03f20bc9839f027ef517ea4724026ca07da6323e4c6fc4ba4f3bcabaed0139b11c505ce0713ae881f5cf63096d1269205c80e89d8a41d845bb799d822499c531672f4590a291bdef3500ca236022371a101bce72cf6c49a5185c65ba4aaa15e3fed90615afba2f351c766208478ab47b8f6dabdd7b6bac0a3d59ea7da4a9ccbeda81b126d8833d26dca891e5432a354899ea823fab67c1d60cad38c21bd1adbf8c2d81b454e83f3ec7dd0a7b615b5b0c705e6a987c25bc095b28d46b0753e5f67dccf195b8690fb41ad9f5653a16051933ad9bfdee3dd4dadb13ffdbcda63b17df2753e7e1aef55d453f70061d691f7f48330064ef7a813640c5f8a2e680119fc085eee918409d5f4a52ceceaf90e7ac04ba752fd0db2fe206476325101316fb8ff711cd12be9765ef3f25c7fa5d21771f552678a0d8393eaaa11d73b000aa3b427f6e15bb2eb974f2671f40d0a32bf3340bec3fbc97e5a18709d685c4557eae062398fd35990131b60179da41c5f1f4821a1a6bf6b27c52ad963aac53bdf5419b97b90ec9a64a44a14874081524e59ce2ba3237e9a95410bfb090ea8c0976761b9f3efee11ec31a684a076132135a862ead1add06f407ed6c728be916a8d0fc09588df159b92bded149035168dec296df500a8d46780cd3a176e155c3c3572271f62210f94139ad6527c7037199e48b0a7e160fecb48ca1f46c239bed92eb4e5bca92cf713c258162507dc99fd1e491898a38f84fe50a9a1ae24fdc595ef9c0ff500e2e161842462f621b71d773c16d8dcf1c03fbd7d6765da9b5fd047b57f074264c9210493beba99a45bc5d7814224207db1726f2b6c982dc4bfc6da1a76625f3adb5e1957fee161ca464169bc55561a3c07e7ac535ef2407355e7530ad33af146c2dd1d4d9e92a838ab83f143e426561d74754496eb88e86a9cf6fbdcb37a9cfa96ccfe5a45e6a98f86324e0cd205eb71c8a204ddf230c07bda99ad2d8cd1acba142ab00af57c36110131c4a8f572317fdd013ed375a12a4d681f3cb5af024dd2be271dbbb1134050a4268e785f99112dda7340766e35270b1e69fbb995e9cf4d70fd4f340deee4df392a810eeb930c9ddd0594a7e981019c3e13dfd688d6983fc1cc9d1bc2778b7b1b8055501dc9633054f3063c75b470e9f0c2b163fdad491445e928ccf1fd3fce5e8f31e9eb0be95eea1cd188f909ae26aa9c4c67b90d12f5f90ae5fea8ce17501740bd180402576b1fb7a8241779738ff44ac07ff4d5a66e2eec3df6c6475ed1526668bb3739320208ed61b1a9ff7fab75ec1a9b538663461e7153e50b727899b06af21fef8df777d79e9a9d126688d63444d64f2211a4b5a390446333f28d2ea288d19c5c6af9fe0df5ca7b44d7b5dcd8c8a58ba480a3d5f906e3fbf6b4ce95fd51ef22a66576081459bac4236da4d2d38b30b61539acbca68b9af410e9cbfb0e0361849f476f4c5c65413ae41312431356462882da2627a52ae5e0f747f6e2dd2d13233f403823a740eeeca689cf6880beca1af90ac8661ac6a6992efc04c0bb00d10db642cd05c5f8519ca31ad48f9d2dea48312984bc5696eec","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
