<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"612c93ed9d0361fae64fc34ce03ef43f1338d839a1b49d03bb0cb3afa336347d5ba82fcd099a9d6f84902531b66ce0ff90b57910693307f2ef9de707f48aa3538da1a7267879b18a3404e0e97d4bd8126290910c8ea6d6ac95eabec8b9171b61d21307b6a5493ed49890744982ef370ea57c94bfa205a1b81d0ebfd8f17c01325e67b0448ec9cb0aa5ad290a283e93c59a858a9825c1c4064ab0a395a6e51e2c29d62d43a68a9e8941301c49997b7f79637a5729f9c95fad7ee51f9aa12cd03bd22b17963f5cf3b656d497bd343926d419690f7c9512aacd17f1df2c017ecfde62ecd5997715cba70ac39c7149c23464aa26e0a472a53e422f41228c5d69651cf808502dc789ad65d8a02e803955cdd0603e210c70e65eed7dce335e7daa4e3101dc6cc4f8b1a8609cfe8c3a36f4215146e3bb169c68d1bfa60f297df28417dcfa395d18f8dd9fde684eb4a269b5e402def1a07570002a7be10e1a8ec6fe636811462dd0d0cd5faa19159553bec4a3844185a08714e11d6b094aa321e58400cf9e5fa07464f36d17194538aa7639a97fad201db6166c8eba84897b9a8322fa554d781f453bb728c285dfeeb8d6f0f25c23610d77073606c2f9989cf443b42165dda98a340e73d159027937657155269ea583a49cb8f9f21ed7ceb747541ad76b633545938f7e701119d2ec44f3e4bf8cc676db398a4f1b16c4e1cb4db2613edbb163b8ac19901f3c9483c2c008c2c292ef2549ec86d7ef745d3b99cb0d3ad7f8eb5f9acd2d3f082dbafd90d99749578cd79e0840342bb7ef96e41e96e2b4e8ad76cdf7d5eb20656e1567316c050d4f5330f737d885cb6752123f6214baee6cc3aaf540b9b482cbeac1d29b331178c624ceac8f54aff8df2187ab5339c3ad79124177ac4f6dd807838c09ff229fb4b8cdca0160fe665ab28742819ed9905d57786befd34257f753f27c8c40fea14483ea25df15fb88b7467fd67dc671a864a00af507f1e561cbe5006014cd52f690508f25299a14c97b4683b04c327258f1520f74d69a185d8f5eb9a5e2954c9542dcce91235fdc615918dec010cf5be46c12ff27250147707bea70e57e31026ad5fd0bf9c95c912c93e639ce91bce6229a7105fd1de71fd8982b52326847e9ab5e08c7ce9c249ec3b779f26ed2b8e6f8f920e2949af6f3a0482f6f505bb4b7197abdee6eba93743804fe4d199485afaf6d2f5d987fe8556a0b73d4569ec5dac31b5a5b38835e39e70c9e38f6bedf2f579b9394be0632cbdf6fef70df2674b98482fcab070bb176a1110199ba5933fd9286210cb7cdad37138bedc933ce3a79094903b81eeee119f28cc7d7fe0ef352114c75d1ecd3ec7e9b19c8033ae51c77ba3189c0bccd252e3e14cf5a46dd85e9e98a21922b460770ae30fb4e70e3b800e9d06d4cf6b3d719e89bd79caef9120850d540197740b4e22cdf468b215aff85d6cc9460facf80d99f64c64f8ba556fc71dee876d559ca679320d1a73b11509a1b6b4c5e9600f236a3a89a3db1e2aac62a7c342391d72f949be21e925975cd44985ef1716c84a61b72b656b05ddc5c83f2d6bab5f1102e4160d6d7cc95c380f82050d512835964ea006b837c51fd9882580d7b3249299ca9b9ded0d16566af550467e474a9fb491983e58d5552224618c2700d809c8c3c7b7e741d1b0fea745c778d47e16bda288f79a3eb944a41143cc482f15c2e27a6aaba37e8de31a57b9eff80b06b7073cf7301604f28058a42f983208d5f740caac65dad7d1fe64d81a8629e6a776b8b13e532164e7bcbb9b17b4065618d3b26abb375b18407c07faa968147f8e638836ccbcafabde87abd79ab59683ecf12e7892b14900012dfbdf0393d9ad5362f1725d784632e0ed6623c53a6677d89a87b963f62d51eb73f970c0d4aa612737ee533521d890182efea393854094c9c20ff91376abfa8f5aed903774ec6ee43bff1362fc82427058094c9cf586ec6c1dbbcf6508552ae6c58052bea98eebb9d95e674ea61b2dddf2b4b48f1d7d5985af2e40e333b50298e95a982322f4672ba955c607e0d35abaa8690e5e87ec3cefa0d1eca7c075d13b7e226ed17e1269471df8f4019e59d41aa151059e4d4ca61fb8075a537b90b7285a3ee79e56f2bd8a432d67197c3e937fd99c3dcfc6145e21b5115131e4e914b559077c65a7318ca5a61c37ba5c2de211cfe88874b40b93a6354da074b3be232fcb304aaa355c2a355ce52b98fdd16e88b552042de4a8cfad52aa9ff503d8d8233b783645e5d37ad5000d971dc46f7c3fb5d1e2962a3466239a8062408facd4917b2e750c8764926eee1e245b6c2829ea1513b6ebc3502f8c8741cb9ce973b985c319ff0eb33dd5179ffeb30fff0aa1f9103b5e7f26b9c99e679762551f14e31f57367a5543f996c9097f373588c92d1f0f6699fdce7b68a28bcda6f0a828b0ac9e6aff1b1d8138aab30c9700ee25cb3b102bc68c233667aaed99da717f716271378d49cc519f78917a2344a0bc5a78c32cb0f15513d5db62daebaebf1b9c75e9f035b999c7d80bc293f55ad2bd8d5f5824e107c2a9a7306d074c5b6d189b682eb52b9cfcc22be41cc36ca5506bad6b2f99949bd978534d0a4e1775fecd4d45f5878b9ded315839158c437179e885be723ca22f4acc2f27bcb79671f3f75b681f0f20eb99cb8e6f9e76da61a8e3a9c79f10d0dc8412b6443df4731e7df1e4027fb0c27d8d7044c11a4035c1d117691c6811c8f53b46f4b40e83bcbeb1006ba4d4eacb9109808ceee883ae04cd5d75f123bd7b2cd44e14524ca2f428c76202875dffb7599dbaadf93905c51478a7ed90c57a438ae678b9ff19bb07f6ae93cdeae217ac4f9e7be40e5e1f4b1773499ce3ec2d97a3b096bad9d011e4635a699b820c21636cf49b76a142f2733f7828d6594a5ef530b9762aa32c99f0cf102e6b019ab4aef4fb903844a4e804eaba0132ab39ee6483a07bcd72b496c2b6b5d9ff31ceb73822e4a2282387e9005025f84af1978c0d91110e2268d42f5bf9c3ec41f06175e3bb9bfedd834165432e43d74bc45fe50d9f2fd482e758fb8b041cad74a6a1bb859b03259ba95d7e1173c95a28b645739b519e02230b23392f06051936899421a9d17427b10db652e0f5cbbd2f29ce0cc1855847b2fe46b7d10cef197d36c3efd0e57922dc520a899b1303ab0385008e8468a09f874f4137245d1c845ab48d4f37b7a01956605114ce485fd94b2aeb1b31a326a4c520e627f537fab94d9c0b19cc296736bae0e307d4a799d02b7c9c88f70ef98a3384d79f225476d11e772edd4ab5fef65dfc23301027746fae076cc2ea043bae42f2f38e3e0336ce912b8a4ba3211afcd836fe61efe7a83d49cdb4425571a32a97d507d5233ab8ff9509f5ea88ff9cb340d55263e89265f9171e68fdd4b8dffd60af2e70abb5d57cd3980130d7fdaeb1f9c7607248646b57b1ef62a98cc80ac973b441f3adef21d5bd98b84d323f1a90dd9438958fe510fe70c519ba1152ed9fc1780f05371f4dd371b9b37b3a021dcbada4e23a1f3f6f2e7cf45b606d5c753af37781dd170d0f3822fb3876615f4568992ed14dc96483196cbbc690049bfffa9017b3af56df791f21a59387bd9b57320339cfa9a33ccdcb7febf79c669a253f56f22f322a72a04320b746921b039c7309b0bf6ee75ffe5912ef7180bbb465eb205af736df1d9cbbe42c76a3ba8676d8cd93ad170d763c3b7b4a17e948305d40ba95275395aee35e75a0e89ad9ea40d0137267b810e53c933b470fcafb936a3f1b510ed12377b7d3f5a8cb155ba47db7b982794a8819757da7858f96b89c2e89d35766c89d8073f6c95daf6492fff5137af67cd14313ee70357217b824f40eaf172d4d858182d884ea464e06beab6de2eed44f1943cb7fbf2f2dd718d8a8b34589abb9f82228e53706feb4ce6c6c3bbe7e04293730faedd72f4661b3dea5fd2385b27719183942b1bb0adf0651b2e99fc28adac2e9ec1f3f03afb316918880f3efdf28e55a767e6a0d21ce178b580c6ab784ff28588253c9be9d72c0048e29c2f30fe111c4021b6cdf34803b39c6183c3169d52e85c1f8168683c56553e4ca67086a2c1fb3ac78784a9183a26ede0c46f731f3ee7e606918427685ad192c8963500cd89a46fdf6e59f0ecfaf127a644455ec1b9ed518b690bdfa922da79115c6b30928a316234c961d5ae05352aa80ae4fcf565fdbb29ef559d390b1985cdf6eae5cac35f79345ab743dae080d7d094084ed8e202b4c057030bc862ff1c4770fedb0a7885fd6bdee61f202adf18a9b5fe994ef7d4479635c0d0480273dee7f28929015bb2ddd9318f5f21c7ec37d306be87a76d5273185dc5a208620bc62c9db22ae87e9cea8559b226f61f456ff46ecff0db22c7cf0905901659af1165c99ff4a48d54ac1a2d12899c3dfae7305cb7a8401a21c12b52768c8bac370d5464ddc06f1a1206f16680a25c64b2c71bb01321e6caa0dde70583f546bcdd547dc894c538ffb90d94fa77101c73f0acb538e29df7d4889a74d12d718c931f7ceff78aefe765eebba1116743a1deaa739197ebc94e65a151f8cf25b01c3339c06efee0ebf8a16881869128d9ceee42528310ee6beb8d96e3c28f9fcedb3173ebc08a7bd3b8956a8acff8648f7fad1b2f28cf9185011a002c3cd37b910d9b4959da8226c3fd4647248cdf6be508161b4a99c500f6eae5965b49344b8eaf5983bd7adb9691355b18bdaa7beb48edc545000858fa023e5f5ccabb6f693331ecda5feb12863ccd068819ca6b4c0dac3ca18dfbcbabbe0067b65852340c7613b97ee232a271be706b730ae4a61ae3ef2027341a52d3a98e060d283c536f8fbfb03b46cdaa557e363ec506adb8f32abc5c9d72c036e42686f35ea805861e5486c139b581b1d39f7448f2c4d9896d6e37e9c6de4fac286995fd772d61701d7816a6ad4eaeadd59f0f5cac893e733aa4c86349a471bbaec44c077dc4044c8995bea4a555cdfac00b8708f4b282eab5a85cdad90cc7ecb47c5d48eff2993a18941bfb600d332cb9dcdac47a467ea2598d6beba17e2ec744175ce54b6c2c3a1fafd5e1b9548b407756f642aa7cb54589034056052ddff91704f5506fc86cb8e9605540ca6b74a6199efe39aebcaa28e6da920a6f45950a39b4fc09a20ce5e941bab103cf26ddc52ee2999c2ee93eac7ad3d348c13ccbf62c56b38c77e97c906b50e48c83f16c072acceb0e38ee3394a5566b6a0ca34b37b577ba12718da4a54a92ff366a4fc0931322fd344ff3ab134c813ecc541cac599a46267fa7734d1414a10d0b9dd31ee222859a98bf6ec09e014c8952ca29780a033fc107c04733f3b275666825744ba5f887f0dc06b98bb98329a6204ff3dd033585ff3c3f5419b29ec5e56d4374615c985793dc16e7f1ad2232e6c5f0c498cd1560e5f2be89c24b8229904d781e6d02b1f713628eb10670bb26dd506f2e546c581a93b682dee128cc0b1c130e958f5e003a6a8c9e5933efd8f1692cf83b3233af2a30bceb3e8287ffd0e8fb221e17a68f40faaf4942ebecb9ceff95a9646ed7f9d583df0acb6aabf4b2be4b9107c8f824d53a94f65e0ca1ab7b667decbed4ef83b33598c0fc30452aca4a8f0009acd8bdac9aed648e6860df1aaf5345f33d6c233afb4c9822ad62890116df3f57208d5bac73d54908f34aead3fc666cc1571a361f1ba271423ae77a928716f3646a8e629dd3dba8d042fcf5826377450a735f39613b0330ce3af1921e4a51b4f0be56253e13f6e1d8c861fe27e2c96060f3f3bdf5dc8b02570ee64939e1323ebb448a355c3b16341ac81813ae1c34be15fae459866bf7b858a3361257559499ef87ab29ae8f6bbf622fa81be954939a45c7d9a7dce488db26b93be384178f831892ad930317a9d726e29801d10989eb344b6a67f6ef11a977c50f8c52b9b092d2024767b1825a907409c99b80f90702c57e54b3cfd5209786e9975087b64898e0bfe5e29189723712c8bee500f5005a58b5396bda75327d4188b72f5963a0ecd30cceb9d123786c3d3516aae011142cc0074f60c7619791bfcb9ba888691e56b1c58c8b83a5bf15f403523c8d42c501eee7c4ca000b435c6294c5ff03a698e9c93f1b7183214cb5f2f7f0374a44983a47839434689f294003aa12a4f8d38791ce986d0449b41fb1baee27472b608f42de104258d5737fa24fea388af3a689ea3d2eb59a605605ca6c6b37fb77d37c19edf6b4e17a7eabb72144b0eaa74c6082d460585336cc6e7e151f84b03b3d243a52ab69d5e3dac1312813555bfc79abfabd8ea6424803f1d1dc4550c22ee04b3f93d1d63eb5ecd3c41a3e07aa0ecaa07c952613e6e6b4177f8765018bb5f8bc76abc5961389f72dfd5e9252cf136c2a7907668dfcf809921fd10ca83a5d6e5f73ac8b15655e63852622b806857dcc00a2994d4b89b0b6e8615250f79d1ec342441edf0a09808e829aceb3fc52c68f03c249739ea7cf293f93339900899eebfc15f7f616a84710949cf18c392b2447ebdb27027ee39fd182cfee584435734578a464ca2c7d7a138ca2d6f5123f964dfc5674001847e373c54de67c29c1995e829304221e67dcc1d33eff27a53e177a1e707a6eecce45cd76b1856ce4790553a96bc6b0719273c94981fb5ad860121be8db42977ffebca8e2dd9419d11de8357062098ff424e7730a4c89a252aff1123773cd0297c475e562fa3161a2c60b36e9d72b351b2f504c5d1d03bd4a0f79ec9994fd126922a26b280f37ef77bc83d52d2db95ac016426a65e8b779e944b10568c0e9a5b0e1ea9b5be27f34caee7680efe35cc9ee2252976df348fa312e39b5d66a6cce84626b223739239da2ecd0db28caad1ecc2c4527ce96180a316f2523bf99cee9332f42cc351980c8c3ec7bdc6ec89fa0099a3b2e9a3a28cfd7324251472b6bee383fb3c39436822cefa5a5f437f2728ae32e5ab3f262c26835915521d4ae26216c11edb382bfe05bc5f312b00eda8b4eab0f72c72d4e89f2ffc1ef7a2ddff8a5b65468e1b0b28e6821c0c5a12d3fea87ee60475246c4b57fb0273e737af7691a2944b0eb368078d25ad7965b245bf3e4ac9a36c94255edffde8fa0afe7cc810e97bc1442bd159200fa8d94acd196154cb480792fb4c61425a7f758e679ffb613e6cddf2c5dde46d4e39c35e055ec933fe0aa72d630f15a8a5ce2deb944e40ffc10abc811746a785933ee7e62787119ca9bec11957b9b227cedbc345830dd5ee27dbf49894e7fca2bec7d39f8311af285bf5ffbe20ebbb1ebbf2d811d6126ee6c2667d8ca505b3537fe6640e428cf6898636a61abf41b732c1ad088c17b59ebeb57e4bcb993af953dc374f950a9a5811699f38af9ae60a0601597f736a48572f440049b841258045dfb99722d84742329014cc3ac5c643af690235e770629cb1f4e77caf87b115c8efddd86d13d467139d4d9cc0b9a64eb395da44237cae956c468e91d72c249292d6660292ba9f53dbbec602dad6a0253a845c32eb7c3b57fec6043666e685684b647e7a83951f1d40308c0578a8d7733e6f1125f417ef1af0090600688205bd7bb6ce5ddf9e4e7bb65c13c3ed79fd6953f5dbfc556d2b64e283df25886897602fdb556191d8e937cfd63e769c86b990bd42dc1a65797e814a08e1f865d2d36800e2b9301d35e250e4b9b9599c076528bbef3f2c3d8e9013f7bcbbdabd7fa5884f012b6c2afc54e3782976276cbf6efa2cb4cb7d9ada823b14a265da78bdfe69d9858699d1cd64cfe03b95ba1c4400bfd71123aeea22504b03c45cb3e4a9fcaf82f13cf52a89294029ebfcd6d398996ef6421ac64df1c8ef8c1dba8333611210c95db2b9008081126d4ff29b2254cbe3339bc4348a665bc4e9025e76c8591c9b55b49164ea93831272c0ca697243cf3c429d264c463b141a4fe69ece488a7a515b509b839eccafedc28f926a30568cb7537026f2e82c97c6bf40f133d6db37be24840b00b293abf1c55126bd15df155a27f4ed0df3904c8f96af53eaf925e56528d9cfeaca5e21beab51604a9dae1937163cd893c540e64bc72661149339c6a45845fe77681738e96287a6831c667ab9234996a9f41adeaaf81099471cc026be10a39bf49d2be6beef2e7d823384470f39b86838f584edd43509f59912f5280b418b732c2d1050ede6f25faf4ca0113b2c64f9d2f0892fa5f79aac63874d0ff4ba5540c84fafe357e21a8104ed065d567a42c8147a31f149c24c8e34e2e283d86e407a534e3db40d86c586c21175c5a6704818e5a5e16ff5da7f8522cd3680da56c842f35ce9b1a15bbf90dfb1bc46de96ad1df0d695056bff7f58ae29dd1d37b8842198a2a079666c8880015fcd1ed79a28c222adedf32b6c8b17e183c1c8c5835fc66d438313ba3f4f48c65a096f35a7b69d435b70bd6c92d7c517ce07b0378f2489b8c4c7d1300eeeb77217fb9745a98306fb5103cb00bc111834ea96b23d3ac0f09a3266e0cf984ca37fff3bf6129b0542c3cf9eeb6b5cbac6728c5a5ec3702f54f1d6e1badaa3591f42fb18dc20a0bf4c20f41131cbf19b502eaeb75731735556022e9c938b378ccc55f9a51af8ba3f88108b38cc3987eea60d469f61f7dc9fcb4344832ff8f5fefc0dfd33ab7230f1b3587bd745ee16ecd3f64638cec66dd18c5ccac92a5270636332d3cbaaa53631685191480d95f83bf36c0957888210bb3c728dbd10134a84c3f2e783976450c860998e68eabb4be0ee626374623927365fd260a41d08be12cc009463910eb975947d1952836c582cea9ed76297401514fefe6c91016d0ddd577ff469aeaa3c3703f7182f7149d8cde6187566fe3f711e25de47c891a7a7ffd17867c9ad47921e44187662df2ee51d7fcac14002d5d5b414a019cf95a8e0a6558325353a68867dc427b3052b35985d2e6405c8c35ffd360f7e2217c23b8daed941d41408c35d48148f028ba05c701bbed831b073add61a97184307d449fae6889364668242845a2d53ecb33f930b30493399ee7f8116e619c1df3bfc5d43d6d14a4660eb1c4d0a10cd2fb63ad84fc4640f9dced6acf1dda6e929a7203c863519e7690329208839913b76d32fcdbad197a25b26ebdb0c890eb657bf8ce4d50fcfe1bf0533520039d55950f70a9c23f7cb9e1e576638caaf72cfc9677637048888b29c44a5471bdaff59ce3e32dbced2d3e9eca2ef5394da4d8e28903cad67d41c8f95f08ede769646a7d6ad671e8561b771297bf5a743a8a6def8a9c44cd6e7b3eb41250c8d904f38cbf871325c746b04d43203b30f169e51038fab98a7bd04b3a86f6b0b65e00abe9001ffdc6e4182c46023f33f2bc419b93b5ec14b1e0a123e6702fc8971c1864bc924efb9bf22617f000e69c85166871cfc4d0fd84b8c6c45d50d05e0233236862029ba7804a02ab648d02d5b240bbba8c48c20e193b6c370c793298dddcd17abfbebde584565d8161e50b67ff8483bef7c57d186237a8f7b59b0a8a0d7042e274840dd29fd51132619f5f7ed8f53cd07db8a94d8d70f6849f4a9e19cf6be18b521abb14d8c362ff546fbdfc58c0c3475e7d8e8a0d61ae6bb6ea6641c0d711a7c87fb32e2814e3441b486b2a21fca754fb7ea47af25387dd9eaa5163b79a860656313ee00c8c8b6df149f3437e233e8365ef21ed24697ff986bb28d8dda6d79af200bbfd678faace204e48e29ae5c2d12c9e861b99831bc1e75233f1ccf42fa45adf2afa21efb71e0c70160e115ebc59088d73695e513e54c0af7f067c30901c1d9f887f1effd2880a06bc09f8842fb7bc08e01b18a0f76f1d4f7682871cc107dff6020dde69a2e39a92f96767b9e3a352a622a71e23475200024d334cc0f0c0aeecbe3bfbb44b44fb049bf4b7fa22ede0f0e78e69b8f6070ab2d7d5151e4797c9b5cdf631b840f494ad2f3e83a6c3719627b279eef5e0ca0a44adce09f555834553b60ead29ac4d3831e5082e5b64e4f37b75b813afbec42767d808eb93c8afc827121bd8319dd4f5c381d1f4cc3e7520031c8c598cb268d7ba87e240b60f72eb69b5a2455e062c6bd9fd2c703b8b35fe40c399d8800d76bebc0f8a383927a2779778e87be7d2bc113eee91def3181cabeee6c088d9e968f87241d8cbacdcea76d5752c17ba60e0c82717891c11816a0271d6249a8604dab1edde79d613577fff04de2268261e81c96dc6fbcd3c613d8537bec6cefe93cbbabb0e6be7ccbe0b504b354c44e10076e2f30aec8b08f718ea2a87b67891894c1e8cc841fc08a6974f46a5149c1e493c5631433ba97562db42e7920713aad376c8b1157fca9e3b801c9961970d3dc51017d85cbae8f372867392152ececafcae4037dc6678add231ba3c53f646bbbc37c580d17d968aa9c280aadb3c516e541bee6373938429336ff9877ed2e27d4e6f358233d58e78cc1ab471027ed19877d56d467f51c868da42882938ff30f0d8bb38ce240095091bf35f14f31078f06a3c14a4662b05de50341babf067b96a8511d6b9d6e2fec3e7dc49eb65e4c38ca9b1011455b3eb2f0d97713df6c6d55e6e5bed9151ec995f9da48036d0ab3a6de7af604eaa75fc1e8479587e754a67c53decda490c4d21f5df8c20e091d3101860b3315912502ce78cb619ca6a45666bd6f21d65aa0068bb89d7c508dc0711e719725fee78978585aa04f75ab1ac31b78fb1a5c06af8b189e45060c6e5d55474938cc2299a136a1d16dfaafdbf3adcf24dc4734357971cd59d7944e1ef10884e93f605a766063ce68a094b526f1bd8cea0812ec43b38efb7d7e6239c652e8802d94830cadf183d8d8751e86cec35b5e6541de3579faf94e56416eda2ec7f30cd34faf57ba0f526f1f2efb7fe5cede4afd7c2d56369bfd2db3552244e89e1cd936f7b2496c386411912a94ad918f50192114c90153585e9a96787a840214fb3b19877991299c38cf1a08f6d968e235690d333b70d6640febba45575b8fafde5f515b99f0f72c9764dc446f06b351fec57ed9fbae767584b30361983f64d971e0d90c07016f54642cb760a1992fd44c8994a552bb309db3ebe2ef60099788918d7bfe412dcd5ea186cd8f1a5223a479acb8330a69853e36fb4cc526d0a5b738936a48caa370a1a77bfaa2215db125e97f9eda3a2f980423eca4d72c0f3be555dd461ff6bd0c4399af71f654d54b9aad80791d861ec2b00ba5b63c257e2dddd68aa1202bf087fd76ea0d6830d0309aa5e818d15d4fe6b272241f99b6568c17e044ba5827613f9ce2ad139bdb409152c79e9e1295e5c589ad52de7082224ae194b076bef7cf45a14f25b3f07042ce1e2fae16ea15538b7844a7f5717663568af184d8692a859935faa096b06038e1e6003beb122de3ea40f2cc31ba4ced77822d16e449a82e32d472dd599309a9b361017025cd73a0542cafcb20b0db65976240c7347d231bb93430a4ba018d38c8426c2ebdd72a42d781fc5acf1e8d29400cb931c7ecc2fa2eb25d5adb7dd4ad0be002371f9fbdb959b459f4eb89fb60510180c8eb0259fada3167b8aea445952f8091ac588d5beaa8f4ff9824ee2463e61081fee7f8dc49c2c0c4f0048a10d0269a015cc99b89cb4a5822fb9eb0472fae0ac795d47989183d8e5fce301c974eb5f0da561068368d0be84b94e9b32db8a1ad70f251c38e024dfcab3374fafc83017e21ff0a355b2f7336297609cbb1e6b9db9c068d68d443cff1acb9457c0553f2484739ec865d209ffbf547c955662c207c6e940e18b6e91ce76d18f8f35db214b52c46c607ffe5bdd76db31d5ee30eec67f5c18f9b34e91337a0bbc8c6714880654d61113e0354652819f6305553271d92128abb2a994e12c4165e1b2c778c6aa5874fb47635362d2b997aaee241b00f28f800c0accf98bee2b0f2b64ae95dfe94adc284ac40f500dd35ace0682d10181f36f368a65e171a4bbb67fa36a67d3d0d60438a0e9cade8128165f3d523b9592f7f404d7b6aa199896d4f78f4a972ad550b145d47d4aed58e0462677d54a3c2e73337ee69124483b374569eca39d2134e3c2eda2e306de53bacbd55b35b177885cbb9525c91e81007125847e75e9a8a895f7ef54715b5c8d2b260853be9e6497857f9948e5a487c2f4b24aa4e9bb44309df78336921131493ee37a3d7d43d61705a2ffa36a1efc50eb1a46b42db5517846daa0e9d5896162c5065175bb38be5f9dda284be7d8ec400a1016346a7c48b281aa19968c634c98b1b1d027fe3326493b261732b356b46a2f26e8bc9120d9475050d33ae6236cd561ff16de996486064b6faf624d5ea1e92cf9ef25d049023710b04c4966c6a862975d294a6017258ef8cf4fc55b055817cf2ef2b42bc27f4870bc72bc91d62da372470dff9a0db5d3704ce961f8f5bb071c3a4541014cabcdb613fcea5f81d3602fe974c3c244ad37b8afc8128cae4bdc766cd4580a6fe1ced40b3d68d0fe349b1496949e92b8bc647af7b32a6d421bb26101ab824b701e1dad696f29d5c97cbcf21361d38fb460c07c2424f2f84c19fcac645ff73fc5812c506a23b36e83d260c430ca244d9ce8c98cde8767fade4cbca824188f53efa9b36dfcc0ab73c1700c7b56592afa0a6b3f34e406d788e974daf17d12e421527925e0a796f9045282e78856eef9dff188a9ef11a70be4e99507643b48956fe0b9f0de6a1fc80aa3d38ed5ff0efc29226e91d0cfee07734ffe834cff98df58efdf8a5f8c4bff2eb211eed879e9c85477e985890ee0f8a666fb1447e3110e8ff4aeca29bc07e350ea212787064eaad19de129a7e76aaee8b1e66720c42123ac6a5984041b066cfcde5566bddb69f6eaa10dbff85d19a838997fabf8b90d14ea84b1f835e48ae97b4cabe22252edb437b3a6d8362e21fc83c5996a995bed55481d2a7d5744246fdc29ba79e274348268837467480178fdaf06823dba741ea677dc0667fe9a82738694d8cb0a26be7d25c9c0356372add45a569ceea45d3b3aff39abd21f18eff859af5a644609bfa8bb620102fd52d7ebfe39a5b44150175bfd2432f8aae6f20f7a6ef17db5470661d51b54e2d5caaa01c8e2adedf48fef823cf7782fdf539172f7fc22fb7ec406cb99a609ed23b2c7467129123a4034ffc0fe57d2d36da6bbe50028aeca14d788253e4451eb4964810febe9e30e2b7ec1791ee001b6f0b74a5c14bbe392b7e63d883f12f43c3de83c0001aa3f9328408106da1375ea3f62e2f4c08e2d7fab9eb566eb00857ee7a1c3f428fc49f1f78eb0febf77082ed52a17830dc74004fd17f3be1ba4db2cb518582ac67b46c84d05b84ae59634644127822383017e795c006513290b986b08e62ef9390ebc1ae207e8b4b3608aefd636165ca91a5fc76b6cae80ef47a253441e7f10361ffded764f4ac32bfb10636d7b44cb718f611bad76ebfb2afb6f0a4f4e1f411ff22aeca9d4cba2416d40b9eba9b5ebc4d1c7b76b82e4e5cb370eff1e727ff1c0680454afd94b791615ff296214997ae33ebb2177856bcd26640026c72bdc1437eb63b04fea846e6c059f63ea2fd07135c0fafc42a0bd60c99d8508341c7b319b21ddf5fc7bc0450c6de55e2c3999c860a6e7cfc73fe1ee1596e1b801ad45e8e717d989cfc627df79c606174784c345bb7553b31f2b505c27dfd1917e1b4361315a95acedee4e3cc5ef7c823bf5f5fff69c7a0a2e9cad24e3738fdc87844574da00a531ee5d966e04c0ad3bb120e343faf8fded4c4db6f3a6b67cf7ade0ee66ad39582ce551d34ee5ee52ed6c7056dafd328397583e5b59abdaeb93fd66281159e1aef77fb0261031581b5ae87683f6dfe4824e43836912abc5fbda687e1e47620a39315458b47cce80960ad3c79392eb61388a6cb5e2499b6678ece00f37a59f9f3c71e9832c87e97ec57e573fd4c3334b95c7af054df2730f1582702ce81327afbed689f19ca6dd5655f1252fd788180044d4109e6a4f8da1d386da3711d8f2e7e893eec611c898a72a902120aefb105ec1de2bea31d7d1f6e3f07f4bf5118697a3d79b3dc9b2ce9d92c045e643b46c9dbf0b4cce7d0f409d552498836fafeb72a3663a4f6a2a615f2172fdf7da830ea6270a048a5d21c338acb7d25cd9278ec7e98554fb8be663cb64a64fc52ead26b1d162ccf5b94bb2b137b0e5e0c49f58460cb169a8e42a4c8d7d066ad303d03983cfd74b17123c4c476a6e83d60eeea727cc3cd1c3d77c1b681984c906bcb4ed3379f9c9ff22fb7efd6878d40f57067eac310b107ff29f05295ea8feb9783df23c4265d687b8e99a375f84e33c6b7285b76a43ec50d9668f73c3c82111c1deaaa80b5be7eed450e0fc3e03699e433304400234abcc0706508b323a94f5ced2710a9e45939e34c41c579963ff86ddb097c7aa8c8c23cae37551308f4424870209869f771f17","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
