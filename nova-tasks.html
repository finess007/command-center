<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1611371d9769a6952bc9190afce2efe8c5df8631ee33c11306595d55dffcd2fc9630ee8bab686fb37e1a751b9c7db687d96ce1d6ba78cb7eb2be44e4b37611e3d6428df08fa36c77736b8671806a0a8e1617207c98a50590f774b0a033159f307ff857456bfdc82fba8c54f14e4e7974f2b60381b5d09ba00938df21a5f7cf867336c4f5f324dafc0b21070ca4c4ad022a9ddc444476cccbcfd7aa002fb5a2ff5aee9d1dd8681ad5b70a209681bbde697e17b9c6e66bb37155d322f99bfce368f25c3c36430e57751ce61b5cb4c89c6ef95fe74da19d7a77c29bd0cd8ed5068d46d676452b682dce2ebfbce5020754536bc8c27a41a50862b17f82fcfd145602894b852da5dd361a04102ca7aa913339af9d1b14569d1bca18666698163ff1f7f6c4a4d4a074e1be77256e33a2a07321dcbd8df2e54c499150d7beda0e5af218604986c8158811718bcad15a767728ac1fb1074b8a179d931cb88a1773d386db662dd2052b9d6aa090414ed3fcd7e66e625345f3204f9cbdd54461fa715590fe5e05bfc8707d036873c84485a7b922b3e0b1a83f48ecdc7b38d217f5045b578361e207479a6b9daa377241d36aff7b573793c77ce95eb4f7c9ad23d9f6c750c99ae4ba7de6c55861019c9c73d1e9793118edb26249dee79a14c83d6a92948a9743b4e0d9f370d6ffb145031d0d8f405385bf64405855b1aea1989caefc4f719fbe38238b92b78ddecf29cca4ceb393cbfe506a185c8b31f3940a7d405d77f3eb246f0c4b919a8d58ae11bf7eada6a0d999f3a5323877835ef8b825472246758124d0a3aa27cbd02bfa99751d88a577900c4a84fd72b3fbf85edc27f828f39eaf4898fbb5d6d570009df7046443c97d225aa1f5d9c44f505c794651bfed9abadd444d24878118e032f1e86d5e31f6da79aa5431457d2b8a68e435f5f9fb5c721201a76f8ee2563684e606afb74ba8de7851a62d192ff9175f76bec37d1e3125c3a1bef0303aa8b45a48ccc26323620dcbb773c9d969cd76d0e7db85ac54f8345c93fdce26a38a409066d119529054a802688a71b1b21837052b51673608f3b62e92c154c0ca913721bbfce6da81b1118c20639a37f9078584320a7daf70eee2fd5f1162f58835e0abda7b028e15e7e6d5ac9ebab7922f842417a1a48580ef080bb330ab8b258e6e2f0d21c068fe4895039f65d8ba3965760a98c50d32a39ff8b14b222b191905518c35ff823487f82c452a8c28114c932b578dfffb45eefcb6db8444f3cb65dfaf686db346544126d78342c43f805a8c111f06942eb53ed026403c0630e7a22fbca61ec2d3cb63229f6a2c0a5b45f6dbaa1904cb99a49ee8cdc655b7cbbd6d9d5a90b6ea18358a17a203b3f0106c84a81ef554281b55681f044c5904b0979c986b6afaad137452d06885b211827aa156642ba1c3b79d843149a43fbdff467c19e12b68d6d9216f5f0e9fb39cb0aba370cf7d5d8a10ad2e70142da0d1406aaab6a73a3a788b1e665391bd2038db782168634ac9b8b5a1591edc77fc8b052cc56e50772b8f32daa51fcdfa72f70fe145026926525ac4b0e3c16d6c2569ee1801a37d63461ec817dd0d46091d07c1d62b9d93259f2e7688fcdce160bc8aff87707dfb22d6b519cc3ade20aff31a35d955c343c693b2936d1364c8e4f61088a47aefee1b22b997e233b130c61952d76745fdabe2f2c5f2b7cbdc944b2063c9b8a30711151607cf3b0ceea8107c4e5b376cdebcd08cac2e35e94a00f258f9066b72d0d11a9fc72c5bcd08b14bb3c05887a18bb57aa798dbeb08a24b4b6d8635feb89a6f8ef2826e822d88b0c45104a9be39669186849c30537cd5892f3410753e2273ca0ad1b67eaf64ca8b3fb8555914dd9c2dc76d89cda4ccd71f31483328cf9b83fe9d88b0b288453c7deb5a6bdf9ebd22629eb7e42aec7577ae6a1328b6326b2d7a11a12c2856a4b1c6bf3e9fbc25f85026977b3b16174eb496d9708309dcae701b996cb1f09829caa818b1cbba624872f95b2b28964dbb92374a76dc31a19d49716a28a6f1df805c1ecc024488e23a2da80f02e2e5bf157ec2485af7d5ec4477ae1a5edde97f3bb7ecb40f322bd17604969bcf8098afea64a2e30221d9497cc53546270ab91aad297e00d5cb1e2dc6b5af2c199b237a2e466bc0b8f782c99d0c180f8ac88290569ca2c5e970c9d88f43078d9f2ad9d50e3d292081da1a9b7177e92269d8994364348a0aeb6aee1d8636868dbb7fb1d593cc1280e0e8aeeddff31d924a549dde8f2ffc35237c78fd4476640150a5f4641030336434d9fca6a2068b4c826b2ace4a996e3aa4f1b9f1aac84a9db1ef93416a6d93f1954b52b3228cb742e38e82607ccb8b97d3ad6a7d63ee5101c72b9e6787fbf4b38cb0c97db8c93d264fcaba29ddbc38c3dbcd65177e9823bd394ed1f63bd4a61c425793424c9cf0f0bf541c202897ff39e2097ab6a6019d872c348de5fbb83721279c868a0a9f6e0395bac07ced75d8e35f170247bb34d74173b05a172c59afb79750cd8458e2f44473290a7d146debf9acc8ec3df3dbdfb595070619ab3a6a5ba6b2066c78c4095788807ab282664772de8bd51838ceb6031647e73c17cd4102d2c8cf2d9a543b218111307a0e2ade2c0a0a8385a5bc1ee1bc3cc6ed5bfa5b00dfae85875214de35d30491d06c7ca843023af2f10e27caf9af41608cfff2117618590f453a751d8f47d7b4af44a20ea52389fdb2d10b21754698583927addbe83228d15389caa652db8cea6d3fbf45b262c3656ccefb66c8ca0338ca93e09b707707eb0ad8b224e74ffdda769879fff9480c629ed78f963a51f37fa8a19f802217887da57dbd723639c196422fe150ef5113e9e341622103da076b377c4aee1d77911b1eec95acc00435d4bb199c202c6917dca686f55839dcf17cfd252cd31e389438fa2ca3b8514fef2c4a42e56067d7e03c83d9f9c28f1a2229cc3cc680da8b3669f5fe582329f31b3f72b1551cbcffcf1471214aa354f691654f3817253fa30d3a5e5c390609b4d1b95c813ae45fe855d9b8096730445b0c66845d15ae6c389cc02c91f1bc0eb1e3357242cca41646fd82b518c6cc312965e5c74c26d0c6b9a6b776bbfb68f56fd2395c6c44937de63fcc7781ec93fb5ac87d776609c3f14309e2c8d770a01a70910cf0f35082fc4b889e69e82b61d0f264b1c4c106014d4a9fe9e44f44187c8259fc7e72154c8fb93b0619ed1f68488720e9b4a2093b5a21f582147ed362c3e9dd789baf8d82e402d359d7a35d6d3236b8ffae438045792c9a5d34556fa9544970d8f0780c8b9ec2e3ea29b3add09705836ae56fe73b82a7171c0c7fed3f24bbbcea6ae5dd3d199b157dcdc30a3109574df6ed623891a1d2cf20c28f3c009cb039893938afff1f101a5dd3a126f9efaa2774cfedb1384d84b99cdf3e06d381d19288d26cfa074b1172f8bb4d9d30a275beb703fe635a0f561e1b0a8c966615329bc6c17bdf549cf559e685eae8930a7f6cbf2ff66b27424fd7d9f89b810c4f1993f428135c23e3f3d38685e9021c37f44ba18b20a2f5a61fc91a93eb852411e3201965ab400f82da2f71f04c9de4beddd0e56d37fc30333f9302d91019276a6c4703fb8febf8f98c5d8db24db1f96db6f51b3525ebe59aa1fbf1f49835902bbbf572866e0f0e1c83f4102e7e51445a269fe431cd8d5fd4efe7cbb23f4c9e3235d9a64111eee02dacba61690c206da1d9e1a69bae53f09bf5f94d6862008c549c6e61867eda490ef6f9d7084efe911e37b27f80c8f89a86b352e7ec8edefd38b3643179e734ebd17ff15d5410fcd9e8142c5f051d1ded24cb34fa01e371387d60679ca9457fc07967834c65da4487649f1ae74a2ddefe0f2681d7f40baf31aac8caa6a9d2142ac22ddc16960e550b711edd068c5627613a581fd800667ba3d6c2c3bb0c07677127b36375cfe577e2b8c7a36a277173450306a07f24375274e1f57cec56efbc1398c1fd6f74ba162b6f7140960dcc00965848d8ee6ccd3c8e06219b7bd273474217b8970c02f807585e11bf906a27cb5611172bcaaa67b01c56892ac95998d6aecfee70a360cf6a1208938d06a5f587be477f5f5d6b85cc15c46ff029c65ca19ca0705c6c820dd931e8d715807c8b3fc0ae8465de3468ae6a43f7817bbbbaf19b76bcd94827b8a7c64107772363cd107a786d0118818e4fa1e5f5a8e262097cc408879d08681cd55241098ea8e95625245e4bd18a0c66118bd75fd6d669c9dd35fe9f3e3642494edbd94b77c055aa758ba7dfa467fd7e43b324c5f20e193a2d2589406b8eb47a6d9d116a841fa9f3e7dc88bb60cf21484e5d2bf453bd64587a5318114c72fb4091c8a91b134efd8940b786ec92359a99a16f8c091a94fe7bfa92fb89ecd9ce1d99c512e68d98c857f3eb708d9bb7ad615d83a32c80310da978c6ec0fc8c5f778e3f87e95a0670d1ba2b21b7280ebd226edabb2df1d1bf4dbcc1c0fe0d206939c10ff6dad8df14d846fc618a7b51c4a803863de34ed8b4ff1f1bfc2ed46fdd5c31a70542d921c4690e84419430f9ba618c124afcd294f9aa1136fd8fc61f90daf3e797d6a1905d82de8726151e38ba176637204ddfd486f5c3da4fc89f698dda8a10767ea18933cc5dd681fc62327e5020330cc6eeebad6c8f97df0c858742ad4cf69c2d71eec2b568f82954da7d447bd4b894571e2be1217850656b9884630c74d2562976265aad0f3724481e047cdf4a18f1967c19c86eabf94a89aa3ba72c1e8b4f7da2ca3b7c9a4866d7c4c3a67c152e98c078ede40dca3986522482a84f348324509588db47e9f4bd776320303007f009546d65f5b32686949e463ba5d513651e50a6cac6e4526e453105da5040874db15923fea17f9ac1a749247c3fb484a09cd217582b9c170c22ea9cd762e4542f245f15fe84bfd0b7f7b731dcde7297415bc0b77a1782c4b754920efb020c929161dec217a3ba086842b67c8fa45825e10a58641f3edc347176d95d91f0783e7fd4f718827a6d3414dc7fbb8e9e0e5d52b29f0830136173c0576df887d66d7787a4ba0cc4781f1c599572cba970be5369e3ee9f9938b2c286587f2652f5752ac15edc9fe4366f500f19d085bc07e88c6d45cace393eab7e4d88fddf3fc05e98af2024fa03c689cf80243cb918f96e0848a67ac9c6ca5cae5c457ecdfc4fc52c784dfaec10761bc0b8313750d5322417be92c23a42ab781d6a7c7c399483a584bd78ea2078ad6f6d13dfcce06ac9f955ffc5275f52b5e04f642981992136782824a9dd424251b59b542c083867e30bcca78cb8144544294cffc48550214b57d19149168432f1f370d983fba10c7b53ef28b358074d4a4420aef565a1a8ce5f8e289eeaa6a0ca46c7b2cf69d4f4ae34772f615b67015c35a2bdc1e8c2881841e911cba52c5b774b371fa96d68221cec7c4ff5bd1e7d787b9d115ba4d037f2a5e533eec1c1fe88c8e8f08238f852e60be23432899f77f35b0870f19d4d331963706456fd440770d8dfe09891984d808f912163abec0bd733ca61ce12ec27e5a64375a550f7af79730a1979f9669e41dba0c86ae17e99904adb142541bc6ceec383c3af4ed22f3a51e212c9156e671c00b2f8c5a32f42d0d985a3bd915c3fcc399acb95c7926f101640d477cf3fcd2efb0e09a75b933db654c91e9f31576840d5af39a7f1f6fe77d65af0bb09a8f43a2036f0643d1c5565211f4d6ae9e0d69ad0a7513e647deaa32e60b1c24b8449d44f5760d424a4a75e394559dff130b8972dd9695c6f17fa9f2312ebf6092ddad198f359871bf37ac26c3aee210b5d968530d0d047b00fa3b9de2c9531eb7f6c5489b2ab7e37a4f059358fd6a72407b6046215e83a396fdea5a1fb528c808c19148f486570c9c5c461cba4a211520cd9ebb5aeccc67e0b0c13dfadd84e6875b1c100481af79beb33e14724a8c9f0f486a14c1729fe3047a6a93ae984e7c8cf989401a77701c468debe4a6cd411318d8ef3d49678beeff06b7b1a7c272fde9e702b05feeed936c7d760557ab6a49eff14dbb36fc48025162735384a2fb95ff6d35e7ec1d508e50b1475f99f1b945878c4d3182f7a1329760db93ea38794389a1b24913a3ad14beaf350933efaaac7aef91634332fc6a9e99852d5b8ba5b6b3f21c0d38a7123b1adde69b98b645c75d49d8eba706a7626c7adad7ddb142fca0146f9a6c71f1f36adaf39ab8a21554bec00533646c79c5a8ca98a7fce034cb18f7e6f643dfc9ae9613169fb5425245ff6f6bc7f02f34a114f643f37f21a01215c9e171382546856542b8e794d3b1a6c8347b8d0c59f6454546e94cfbc32e058523ffea04ebb1f8e37d13c15b92bdbe0f18ed712b07882c607b2d63a3f1328bf0f1a7ae82f77af9c593cb3c82e7a0265980eadc1f2a6c0ab8e0eb1602c2fdbe307d5a0f39e6cac0fdf8290658fbe29760a8c48ce210d43e420ea076fb86fac9f08fc530af3df198a81f35ed2163fdf9fb9dbd7485da9b4dca9405479f837ad2d2609c595e1f9e362917e9cd600d757b6fbf151575a71cf8d679bc8d8e334556cea0aeb709c42f1188362f6205e826df6ba1ed1bfa8d6e2ec19967b414ea7e26e01955f64adc7cd0033cf7c0847ff7a56c9d57023684bb4ac51336997e2113c122ee0b02e91576e87cf003b60c56785ee2ef41bdf4d3693a44b83021ed1dbeee215121f8b27e2ba716fd6d7eacafa4ecadec73c4266a1f1ee952fdeda453c1d032124ff29126e946dd77931849db6602ce39b3c76e71ace3277d8c794ad1f0340be460b0d58d6879877c1d934e88eb310747486bf25908103253412f3552e133f7839f2e4131ce028efa55385261dac57c586345e17f397daf2c037fb39750449a300e791b75e65c78dfe23538a18ad71affcdc19df5d98996ba8e61ce2df0a7310fb80862dfedecf6e1969998afab9d4b73e96275b47b9c9e7263e51cfd51ada8f1f5d722af48fd7d2136a7327ae6bec87a90dbd1ea37c6fbea7d7fd1702bab346f6f7a008b8fac6ca175881430ea84b4935596a29dd546a1b80d4aff131b944a3a22381b049278766dd3b450c540d1e0ce0ed5d45239c307c4ac4a2a902e64d054b57899f99d44ddfd22b8e350c01da14f4662b9364e6113347c3c804e8b0014dfb57d0c8575efc62b2372d852b2f24520084c84752da52b4337e33db858dee010f50e5655004dd4828568a76a9814ec4ee802fbd5a608b3620016219f373c783f6669a4665f177b02008fd7f6e5a43c8b35dad4e53b7978d90e2980b705aab00b2a479024cdbaeb745b43b61a15db59c2a6a04db80f962cacdecf38ae1cc26d91a316fc2e056e7c2d39c2aa187f7c8c605d54544aaf72b5b7507e25a732c7c4e1629e0c20117145ddd8a506b159a8ad6f1f740aee0f77e3e5e799dbd69104220056b85ca89156948b45e4b9b7719812ae5f638de348f44b63fc05a1f30d78570da4daa3777ed03db49bc90f410bc5a71d259baec83a76a9b2fd0401ed232e88eebc07dad8cf98f5b1bb4e3e90e6b8548de1c9733358e29f019216413d8bef42384fc6d42dbea6ca8b0f348f45cb4327ef402aab8ca36ada4ef3f08b5c7a2dff278ba2ac3f39d4908cfd985cffd06ba8a4560403e13db09334f5e33d379d373454b06931c76a2349008bba8a1ce0a94bbdd0a2c64bb52898b71dfabb6b18ae81d2395b062066742787aed6ca427fd5909b989890145d1272e6efe735f0857259cc21bae5eeb64992481f05a767e5dc829cfbb925d69e83957c08576d8f62762c924b8b09a443e051776c3b79a373b62f9fb6df02e4e8a9bd3546f27b82354d14f4c22d60f4d9586f6b2c44f193b31a52caa4900de992842a289a10db64dad27512d96837f0761db4f2a24cde1bca89623aa4d718795d6d6cb58dc94f57b24719bf6433ac1923be91377ac88b757bea24fba5d187afce04bfed4570f11bf4636cc4ce1ce03b769c431a80de877933daf38111387dc6bff2168a38addbcbf6070b05498047319042e501c344269df6df3aca69133f936ef58e2b98ef7e954dc0df6ca8e33b99166ce57fad6b04f4fb3a52097070e5f882a5192766bdf8ea89d323de0540016862e5319352521a88368dc17be7b29e9198fefb5e7377d7910e66acf3c1a0fffa950cad47ea84f549aa5cfc0ff3d841d23121191883b7abbf2ef7411c9ecd914ab76ddc7452705974a1178bc27a6ab9cd010fea3e846ffd744695b4b50a0896c29e85800fb19df9007a74386449164d4c5f5fbb2fa6acaaed61c86bf6b90411c02fdd6b5544ba924458070104bede6bc0beb53e9dfe961ee1dfebb536ca558e60478311c75a0657b18e00a54c5168b25398c25ae0246a2f93da556e08e4f30f8038a941198872cfd4c3bcfb8a0c31e6f4877bbf038cfac51f95d17cbd578381d3714fbe1f0ceb23e9cb51c5a5b84b49c615a4b2ed7a46bfee941f0c5f44142d30efac609dff596217e625c59a237d655973c0799f20381ea75bef9cca477a00a4f42cad4ff28f872d79af6e03df52a522d14bc4f1ff1e9c40775c99dc72d049d37184a9d33777118b25ec5f7b56d762e624b24799a85f6d1d96bf58e8ed89aca9d239da3d7040ddac8bdfda39c710c6728913173f9d40843e1f87cd43b186603803636bd76563f60704e0e614b2c0d7c42d8771faa513864dd79c3f36adef8b92d5ac0dfeb2f4543a82a596bcbda0968f680babbd82f8de90560d1fb21dce2d56199bcf374806542d53bf29f5cc6d2319696a529d31a8c4469bc2e7bf8bf3b182270cb36210f3d7cd310f8c14112f8b0494fc3ded754f579ebec7569ba503b08dd62c9ea1e1ed8e138c952e75338eca4c7538bd3ade915874c51a5fe385628c432a04e231b569cd1d7017665e07545ae42402af93ad6dc3e78d0f923393b2f383a62ce8f4f06b8ad97df90b48e0375b6b2c87baefb47bfc8a09b9c2f0cdbe87a7e409b2d384b45fe8b16751c93a1d8a218121bcd798322352e1743678a5955fa1923958cea2c2c9115792a1d99712ae7a4d0f59685b7480e9cc0658ff6fc8507d0efb04745fb33a40734e7938ca657d4a61cff865ec90b2ab2aa0c067cc50dc7b43c0d63e91b4c82064e628b9fa127d0cbaef102b8dffdbbfc7e44c703a964fdf352cf96a8252c8cdfa0409d076348f2c09edb8c3328c651882e7c17d82d8b408dec7fbf1cf65331b8e4714ab434935305950db91d50080303c33d82dde6e6cd92f46a4c58697b8cccd07efbafd919e0f0d2d01d4f7052723e98c3aa4826470a9d332e4033736309f8b86f9ed7845909f4c4d609b769f3b3bcccaaa42d2ce369a4bbaf573704aef94c26d92ae165210d7a323af31538d4602df323226feeff7b013c3da6a68e3cee0b141b694ba64af7f48a0106f918a5c92a74f956efdc58da15400db85fdf5029b37a082252374f74f4908167acbe8864f88446db0d80e3e3431777b00ce4cced67fa253009ab7ac72617d2c533f388f0ea0d3659c6a49384bc83a995fc8664f5576852c30b96332303e892e7bd9d203418e11371b3e688925b6ee898fbd79a92186e364418c2066e7c53a723751c5bf0c16762ab078c36189818d5d321be7af35302ce10db872004fed1dda8b0810617364e37ba6ae22d565c28c9a6da41e17cd128f20eff948075e933005fad8d0b31fd9953cdd2fc740afa6991fa77703a720a7b338faadc228d73c29d768c59f0f14e50a8aa0335601242ed122679278f90118c9eb9fd3a8ecea330917e22f8da5fe3ef0044aaa8b687a4dd1d02809df56c4c2c4d9109904b8e3df629dc1c0884bd5ff9e983f8b680acca63fbd284c15e6c318bf28a1269987551635e3b43f0884256a76e37106c64b364a55e03c0bf293b1eceff06a6542f75ce47aba12ff229c1c8efb9af3242c8c85de196e9b3b15d3666550ecd9517ab1306edd627efb7d22113f6d90d4f284c7a844f63c92d9c499b757eba790b390ca39f5cef27dafebcd46162a64df107ed92a2de70c0683c08b79e1e61ca82fe3ac7ca2aa013e77c139a2b33e0f75a6f12d1612f04490de7488efa8c776cd538ee05792d4d48a5533b80c0b25cb766494918fa2400ed2749f979a554b12047af0dbe0067e9f3605e2ee7e691bbfb3ab82303f4ca7b0430d733f7181bcaa3ff8784a8e2a577ae08264d5fa9940d01f6c2c49088b02a9fda0eb6d8e4774bb044783909f9d5602a9c788b3eb05928aa72b229c6bb45d75e6604cb1d8b977da552751d97a3df22a717b99f81417c5d4f289549685070154889618d0c054838fd3a0da05d830832b2ea7eae054029eab5f14563771e62ab4bad5aa44bc6d5fd246e1f2d916f7da29cb68e7e451785639dad5d7d035d95f8004472ca2bc3df7d77a9bb348354f3b7b95c41bb22f679986f399d8c3b7617b882b5d508c107ea7528b95cb75123a1b7ae97123def3224238bf4fce01eb554fe4619e437fb506174c379a6bdf704750bc6208188301e9705e6735f854c9b697cc9f62de30d613da95fb9fa05a6e1f516182fe71c582a07541d6335abafc6752c86d1aae0fc1a76b815b48eeb3f6abf4e0c1f8e2f040f1560ee777d70eba69fd5f3c49b4f5cc9a0d8f777e239f7814c8c551d64259eed4ef9a21fc47378549c069f6c77ef9e76599f38cedadf3f9c2a3d2368c16d9a18e905e1f3d163fe49ffe3aaa68c7df66d4033a7c24d1de594e49a1d4441f7f090b2f8200a74e8e16d158c1fc3d440225e381dcbf7dc548a19b730d4179ab898ae7d90a9266e7e164aaf6e73cf59517950b1f7c09d41ac234dcb1811dfdcc3f5ca368680468ef65c36a9749c664ec7fd2f13708fb5d6ff82b19538abea8fb1d7499afe397f4ac8e603e1d423320bdbbee65642f94aa777046ce8880c826be86ad69da0cc780efdf75f4ff761241673bbdbb267ab732af946bc6e71ceb464fc1602e9b7a8ecccdd42de9b27b16123c7482ab3361c49b913256fa256ec8a8741fac456fa91ad81f7356b7ffc1ea6d13097c2bb2c4073f1bb3019d4e5c5d7dbd235341095afa954fc408e6b0505852972b56057a732bef895a0283a1b8a8fea17369a48269d793cbb364c5cdc131a070ab4c0d3b60066198025b4298443126a0b575559656f0f88611bb6c01be1c896752b03393b9d42eaf7cd424063f672bdf5daa2c18df714787b0d9d7fc8e9504ac058a868897f473ecc7cbd33cec91570a7733c5d686ea692bde5f112155928926f2ea972ccd68d6760dcea3fb684db579da5bf53204cbec82786ea633b006abf621184ddb319c41aa3d95766c767e92bcfe3241ddb8a71e2ca3b95b76ff97a76b1f6349e9ba988a1b3598117a5f5f3c3277f24d376e3843dce24e115d879b2b945c93082a7fbecca6c2d89f400b0c64072dc4a5b8a11509f70ca9dcb3a98d2362ac08836d0583196343c873f12f03a019b9ce89ad1ba528ff6a493781a9614b7d58fd81a8114054c7608438a8be59b6109f1a58ab9a407a849154ea8e568c6a609552e12b0b8770a78e335c89aa3329c775a5f2ba4fae6ffd6a6cfe70e29b31cc1be368ee00de08a02a0a1b86e6c3e0fa4734c123d97a64cb545c930667870590a6bc85bbf75d8a7d7864fb1b27ff3d4c6f260cb3c1d77c39bf83519e745783b2f9a06cddfa142ff9a36d25355d7091c55de9947bf457f086f619554f3248037d1c3bb605bbe0cbf99a39586db90813184151a7d0d4a05f17fe39de051697ebfde6640aee9bbe6b781f807acb6f12c67a2e03578a310864f8cc4e9fd832a5d9911984091425bfed56a7260a1dd76b316596c88c6fdd7cf864488565dd6d4ebd39efd7f6f13993b5606b7398cdd0f04fcbaaec7a38c3b9a671764bc100d42ebcb817f5eba155cabde4cd43e85d411166b3250c31b43082ba6ead88565994a8333ea52c0bdb1ff65d2b50d155babdf5e8f9fb2be6cc15acc070726397a2a118509108135351308db02234db448f05778feab01e44f731054453ec5694ae44e2bf1f0e6b5904a623e20400f1daf739649c49d9c8565e02facc60830af304dac3bbd8962856b2af209d20b1771bc2067f5666fc32a9b4a3ffc83b7fa56d8ee9f1afd939020eae6c86b65792e26c47a75c00e50d0aaa38f0e5c599e625e245c34cf2638cdae70099b3fc375bc6f7df14fdeacccc87283c67727ca1db98705e65e86a758b830b6458be27bb8c953066f6098c48775118703f6ebb731f8cf3a9c434807eee4dd27711ab34ea81e7b625efd7de73b3f8bc0f905bb3dd27bc788e9e3891cba8e6eab113fab5e4679a4eb243f3d648ab10f9b4a0d9e41286409633fedf428b5c27a974511e4501286d93b99de2c533ed44c8366c1a607ef1ead055df93fd76b74e5090be1b26da7a66bff3447a05b282d0d23ed224b620b62329dede653ffd4bb631e84a9c4112a2c108a9a0573c74853a95d07a25668df5e888d307f4cab38276eac9cc74b4c7df36c20a18acfa070566302eed34692ca1cfa15e9b56bea9f397c424d5cb358b7db53a391a41b6a38e40033969b1fb0c566d8f644aad1f48d97a657e5ccfba7618790badba01fdd464ea83eba5a51b172c71d828f3c304ac04218149c1bcc98403c9ea248f5c1da9f698af85b60e58947a161b659be378d7cb30415acf7a2506891afb624fe40f8aeeee39b55446bda4a766efc39807525391cc974f1aaa7178df67fa4790169557426b17815ed57791995d6ec9bf84b506e6e08a93929a858416d5f95430fe674e03ab99b7e1aa629a20672bd676b60955ba50c639741e5f55069e6d073f5f9e83f830753172408532cda08719c4376bcc8cf127021e415ce973101e4e16019f66eaf980f5fe060cf02c078769a027856125a7ffeaf439936380c1e30ca8a170d7abcb88338bf06c8bc6b61383235de2f0f805c5122b60cd93bfe5b481b53665136c36ecb0fb61ffb6807a0902ab6abb2be8e38171fe50e3555a82474e86b0c97df68a745b54b068a1ff371bf56b449e028c6782aeabf7872603d9df7b2330350c1383ccc1c21ece798b84f14b7742d3f18e44883d6e6606ec70a5272738efbf7255126b98b3d5c013f75c93f2e57b579a091c175992f2f94f2bc304ef88c45d1ba29d34d80ddf19233d66a3e6ea29b885fcfe860e990c4ac6acae6f8625ef620e96bef106c23d2803ee52230e6c4a2687f1c4b5cb7c72d2847e1cc27289c110772f29503b49c177596d3c0d6f1d0d02de3475647d08f65a8c9cd57f7f187d427a9940bc39aef4d6134f9203f9ad01b0ba0803a9815957677b99bfd4dc0a9adf7e2120b65f43fce6f510871781b0a7efa112055270673b32d67fb78248387912baad4d8514c70874e1f764739d88b60219d467b2618f640c64cfab03ae554ab94df2f2276550f625e8983e45e331d2fc1fc0ad97518e6cccd3b84a05bf525b6ca228a206955692184b8bfa7fdc0b79adfd21a93e1b48cd17e699abd527450f4ce91cd54309e92bcd6bc3aafcf01856fa94ecbc7786629dab6d8e1c654aa0fa15e34663690cae2692eb601e2aaeaa73238597588f3b1dc19f7b7cc0bfd35c6a4305f79d21bb631c49fb8a77c2df7b203bb274944adc999b663b9ccb1f0788c99be9800c2c63aafdd10b3c496a722a3fd2e3e45585998973c6778ff9609f327e147e9cb57cc8280e1d09b60a65d122317ccdb7c19f126b153fa403454d6f96c479eb8e642190043e7c3528f9f86d6b76a5e54815086337090d07d8a283b9d7b28a29d66f401c00e3d33e37b532ddf0a257d579065a1db3b40ca9b6f5b37b43de50b95c8faa113330994ec1b7d079da977b621606f69dcde6347ebac65b3236b05285fcaa476d54f779544b37c766a382e52855f532badb0d05e274458ebecb82d6604096f9347cc2fe65c8c45048cb8320214b6b3c7ee2aec0fcbfede9cf264f8fee82adf97984ad9052d5802394edb35303efc9ad67b83711ec541b0d00e61050e8ffbea3486790f376b47c78adb2039f6f206113c2e138a1f603e247f5a4f2d88389474454855a7580af75eb2bacbf45e7933cd830bdbb7d02077d599efe6337ae8ebaddd620fb5eb12029c399be838dc3a6fabb5706a2b2b2b41b7232b4114e75609d4c7e61f1dbf8eec67015b7bf033873623d8a48785c3c816dde1a575e88e318d1b629aa470afe62b758cdf9ce9900eab9cfa0edab2040f4c719cbe5267453b9498ed63254dfe8d0d85d94272ab0f204bff36bde96c0766897c0bc05111d7e87ede4a68accfb0471298315d84de3b084b81c3a5be92c960fe9d8f69c1ca30d4d7b972bb9a62b8722b2de103c511ef38c5eebee3be04aa3d9ceda300e09eaa93aae41125fc6550a40aaa126a1a7343cad41e430fa9f9b42ab9860053a77d4204f7be6239b5eb2eb593fe794f72d6829c8044af1","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
