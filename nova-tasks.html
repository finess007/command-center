<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2c9ae3fb9dbc1e08560b5ab7771276700f2fc2afe1b51cacd43f9e2664ac8241009dfc0d9d8642c0297175beb61a2a3488a72394d38ac93c5793faac7a2ca6932f04568b80039152e753c54508ad1592909afce020504396945d7d98551b4dd15faf0c2094c8b60aa4129537a50eccbb06f4b700868ac3f22d946d26cf3eee9ea4e632ba36f6a313d1656e0d08df7a4e2907340abd7b22ce14ff609a0ecd618069830181ec85842b2e8be437d0f140107f66ff01301c205533792a94130d3a1c4014568359687ac80830c3a83be5406702995aca810ceb0ba925b290254c52fd9b962e8cf117dd6f5c328ddc9672e8e3f1cc9e7b34203095bdb207f52766be08ac52dfc448c49f7968f94e27d853b3390e6d5edd6e2b027bd0cbfbd4d8e637625d299c6a236295608a2df01bd2543c5f7f65e58cf7578c58cb53e56303188678072e493e5f1ff15843b492366b0d60ed3240ce32b059de24ab4713be63a1e5d908927c39beb0c4df4406b37228d16d9716f12f6305738f5de9ba52b88b4db77034daa75d5d8bf391d4675f0cfcc9ec2e8c9e3816c2a96d858f7d182235a79be6043ed7741ec17c75170906fe9ef9b959aef217088b5593aef7e25aff0b6f6425fb844893a61799a4e65bf90d7b8c73c829a408d1dd24928871f505c8162086386a5b320f6349b60f36cda1cdf103d43538b0ea45732da1c79073b71336c5e055f375bec4fb679f4c246d00b468cfcf4b8e6c7f4014e675a75f767408c38ab7ce905c43333d5af14dfb2796dddfe50fa1d94049daadedf5430c438a5ee002cb93dc3d81d5743953fcd18bf23c5ca882f1f88586b1c082ed61ea2eea4a4f2f89a23668ee4f5d7e209eaee2b2bc4f3c1c86f79070a7e10ab8c253f064e35c140e011951f4cc908f4f4b57e6000df164610cc44e7f635b49fffe6f16c60a473af6071d2f2ad0fbd5d43e7ed606f36fc27778d450bb12168d1bd6f5810ddee68c8f0c224672860b531a31a5d44b2b436fac1a25c9009198eae179fbd91bd812d5b24875121367cbed050494f40438f714010605aa2268af26ce081d3a36cc1d261e2dba6db73845272b12e2d11224ab328cebe6a8e1bc8718d57e01cf251fc88deda250b2b7b7d26fde1fd584ccca1a7a6cc7045d31b3a5c016ac1cf616097e87c74a1fac5b473034d4733f43ee06d10f4e7d0584a54910d639eeb5b54dbd87507529cf3f9f25ec4877db6d43c42cb8da44c2e74d8e39e54889f4bdf98e3789885cca55aeda1ec504a55a98220c43676a573161dcc3a41cf889e760ec1c7513f7aca242112c0d4a8678443514a9c80043a0055742139abfb2a27cd572afe4b09bf2fcd2d0179b53072829afb4861c56acc399d60ba1f3cd132cf04fe226c203961c052685d29e41a73df20bcbf0115965d17a5b541b1283491bfee4b9494740cbd2b366dd0036f4d4469660a5e75c6bb3ff16541c646c384d4a75d8fca767af8d6f69423d3d29846562ac6a3ac7d27cc758b71bb0684bbbe2635285bc748cf82534fd4c7cd8b24c9252b4851d7643e74814a00535fcd4da48cb4266b140ab786933c4b67a9fc52e8d42b9cad5d7a48de45554f65803752f41ff69fbc65e22ee6ab42baa0e31917e1c0e5999a994172f955a5ec3db03e184cc79e6eff088697bf6be4de9c0182fcfcabbd6e169cce5903084144e16da38798c9d5c402ef3e3ea51bc35ed7cf01c9c3935f1d622277126ec2c4db7fe639d1eddd521116050e9bff22587ad43b94ea6961f72c8c1daa446691f943ee1e17b961c6bda886ce9ec84d3ab9dc83940b89677267f34d7ab2c0504d833ee6685206e1123ebd5351d77737b9a267136b8448c2dee5f0476a95da6d56cc894c0a496212a6c22d2085b48878aded4c85257095ffd4b3d0de53f0d5c669c95d097f1169dc12bfb86faad9a39e5e05c382d9e5f3e809a4730e7e92618cf7324adb664bfd331455f5d0fa8c864a137e2057248726be4b75c275c250a1e4a5434ac276bd5dfd7bb778ea4e62139deed4d42b240c80f15387250624a08c6bc62c3890288d8638bd3849beea0f80dd4f91bd9a1b7b9755d31b01fcc5a3ac5c694d54662a9ac77b54525d55aca30c198957d5089b8eaa3e4c2e5de6f318c7b282c7343c8ae3352a1c11dbd250e6eb38c8fcb371a0e091cade74e9296bd745f9485fb7353a4cdae3231f940547049ef72c60fe3e506bb7b7e6a0568b3a9e190b18a539382bc97547af434637a12bd97c75a00a004867129f84ae4dee28f1fea5444136bbb08bdf3400af4e628f2be7c10be5ea07723f26b1bc078dcca96d26771415e75c31e8d53efcfd7d6c9d52d176cbb1460f4e381baf38eb17fb12b8b17b7af9bb417e02b248473d62ffa4542449932742545cf5b0daf13d7b5f5a51a68495edfc829e6ce1ee1b7eab18f8048f494dc1bd5bbd0272abe61ef192e2d56d92db37cf58dac45fa438b794be3b871da6be4efe153bd8a63390c88085dc365d1baf2cf8a5f5d59870ffb2776e780a4c46bbf84a18562bc66bc041e7a6c327e05ff5af25eef8d170ec7bd4786af0dff4063312ab351529c8cc36ae0a73857c3df504895f01a995f21a38289534fbfe1d815cef758a21b6064c813e043241f59fee67280f9971706afa14e80a2640cd5477b1ed77ca677b44310f34e56cd5a2ec32418dcc7c1266d5fcd78121fcdc0d499ba059b80715c1ec188f5b258fce31fa8bdfd154fa2de79efbe28ea2fb12d4e02bcd16e29746648274a40fcbce3e0672d3d9f659e7c46cc42854b3bbe6b14ac88030497e15c73268b38bf3e22f2fc2b4c82c60375774ec5af4b9da94558d3068cafb447af58207e71157789090b2664c2e54d1db0d3a17f9f79a47a2c152593d8acca1b4914b0d71a0f92299d043c7fcfc91a632f96c38db344698b255b0637b7353a2e52b6c2697bf7aa802c38ae100c97a6d03e493ac6b99847395f9e1e2d9d49110b06d06665f6e8934c64b0618bb405d57866a77bab8f86b148986748c95bba30628dd960df295d837dd5792f1de2ce6c16acf43a41372f686ee16359da007e7673e10628fb380778d5c40f7ff5064688560ccf3c119c9c6a132e9634632e7d9a353f967d0f3fe6bd2ca6d6a0aef511210d9dae745e936b373f004da4d8abafd56bcc0bfb471e7e2fd68bf8764a1092a19015311d4b4766fc235a25478540d8af119ac131eb99e22e8273756845d83afc9c4d7ece2bfe0c3311731a16e48004a8e72d5c97b2dfd5a8d632c7b71f1d253f80ca8dcf47f54d9d85f3fae509ba88532eea01517d2e350c958599cf53dabcf44f279c116fddf09f81ebd29f3d5b8421bce337edb49ef380dd013dadf947a7b13d37dd10d365583273854ca262d51548640a9937bf6e643ab79bef7adc6ef829a6c48ef5b3089ab71b19bc2f6a29e245a4cdac52ec2458abd07c43c190875ffcc5b61600475be6f3da030300680f498d5627c5bbb282686b3e6e8b25a14df47f81a01b8d2b16ce9ab3871a67e08ae3b1d8e33c9aa60ecbcf097e180fdeae8bbc36655a9d983daacba3b63b7cc848ac7f3510cbcb0ba238af0dd33d67eb8e00d3fb287cc4536d6bf8f921151dd09e2ef07683c5b70d7478c5d9d4d820268d25f6f3f771687061c1d868f18f897ba152f8e2ce9d0498dcfb8189da3df93c32c8ddb3a301658c0228a7face595d9217842b7c6a9984918e6b9788a13898c605cbbf3abd6e27e06cc1ad2d1c9c38e589fa1951be9be4be433b6cb1a40ab451016dfc87916a3f44720b9cfa5509f0784a6bf3dc929ea348001d5c197c81ed8ed81f01bb7343d86e93aaf3d64f095ad3aa2b23ff76800b0200c4b5b848ddf389c46635f0d643ec4c0a6b4a82720bf60fa94c32c8a573d44d027d90ce91503b79a486ecb41c2df39c7caa75f53ced4d758ff18d8cdb389c2fa2f3ce4adb4371703a81896bfc76b03eca6df71aebf9a53d260c029939ac82c9a5613adb2e111939e7a5dcb310cbaebfb8d68674679e7a2101da357e22614ce5b8d0500ab23cdf0547880bf046bb3bae4aa77b71963bbc8431c67346e691180bcdc84278693c125740d81268ede5e2c01b8e226b666e0760c06980497f5dbd837b1fff7f7f171188f68460d8790f3f03dbb68bf6422f58c539edec22c80f2bf16485b2faa296b41396b6c9da8e7ce4149d84681ccc9a139d43874f99bae0cb7ae1e0dbf4a9cfef42a3c390be38373a211dcc4b999b4a29b5ed8e1b5692ec1721000358b2a27dde87c41bc3aba761ae4e001fd19d956ded3292508e9d687c37fbb41d18f082ff41ac1c7bcee6316ba50cde426bc5287e18b6800119a86a6db079abd241fd8d9e4520f50b140352d3502836b5922b31ac02400d5e6c33ff38a5adbcf44b2809539113c0ae8dd7064e671b38af1e0b1ce657dd41336aed360f84c0f5d30310d84617d99c68c61e37e727975190552b1c66a6e43b423463febb6abfe8f91158bb300329698d580caf71204f7a8c99a2ee511a3f42669c19ee51f18197a690198e0d2a21925ed5fcd4efaf702d0af2eeb96f78b585bdcafb0ff6417a692940b257a63a40c4874dacec4938715fde79274d1f6e731e5081b994c723eb53b45539370e95c4560d63b667db6475d71344e5334164ff855235c7558b7082b8a47886b40e4c43602a93e5103fcbc4cf87e53f1fa2a6f98512cdf81db25c1adcf853f634468243cbee4f8508b1cea85bff623195c8edf4726252165b9c1943ac4a9d6fa3076c0d712a138fe467ae948c950d047ce7fb1d46095cd857be1caf1f328dc217048666652839fc3f5c394935200a5832edb5c0e8de076d21ae06e98aaf14f2352b3a5c96ee336ab45c449c396ad7bcd4fd74c7c3350b4bc09fc6040a65803eb5b76d5656d4f4f1738d4497c44a95a267c2fd125b4ab8e686db1f3f72e5bc98bb22542afe5f0f1371dcd65078d624c85c6bbe2b17435e2e52855e897838e9ea8b6fb7dfe9cee7effccb5aff740de006682ce2aa7188b2769c7e97691107b00d2e3bca71276471a7ae8df4b309ae3ac249b50b3726807d1faced03244a000de69b736d72703b9fe05665a4a37c75db4050784a3752ec60deaa3b7d49f8f1313dbc784249cceef809b8005d272bda0f7c9c24d0d9f6140c38fa5b7e26f7247a00e0cc810eb826458f65ffbd93b97c026842b7d34c5640ee77b7ffce2656df59b9844f751eb30ab4c809061327a8c381f6e02ec3682edb5e4f7d1c5181a58546b8923b9e3421df24bc727d79b1fb76770301febab6390848ff252295ecd395e23a7e8e5c6e9d8f34ec481f5a2aa1e4596092af660d88490f9f7cf898c00e1d6c37c67dd5201424c75c207dd061c6d8cd0d222ce28bc07d181622c80af4d61919e68918513cb5e9780b0426f78d14533588ae00c71004a0665542cbf5965da9336b96b6d60a3279e895ce38c0072f0e6dd3fde8a3fba131d9deea383f9a22cfbdf6804bdef524bd86d62298712c2b5bf012186dd6d1e7de056d15eef40d2bc7cf45ffbb2b5c846f9003e5fa694a98a400a398ec71de25ad47e89a5e92117ef4a0236f7196d2ad513c988dd981cce7e798fed9b4c0f34da2a39c1928d495544e0efa6ba0b75eff8b71ba67bde65f1c99eef4fb649293a449df91b14b31df8b3cd06087b4a0b0d6cc59db008806bb6bf3330b9525126e9e10e5e64addaea8e3650ab11e940ec0bf17e835a71e3c92f26626a049f414572bf81ef43f5eae3fb56f54624c548f6643b8c3027857e80d85143608b5f1659180639f0ed91d6852e2bfd1693c4620bd4a40bf24f040b6dba804a775ee816b7ac4c585e49c1d3796c75c8da0b580b1980dadc13121a1d1befbb40100888439b63b57214fb8be15235c65e5ab286f4fc5b4cc9067522e079f240467b4027c7f582b7b1e81339d396e3d808d1b2adad28b6148c9f2789435bf42939cf245bf8597bf58e34cdd1bd3bc0db245f5cae9b0b335e3ccc6e3ce0ef254a4537d3fbcad65220f6844fc947303e02cc767d5688ab32b43e05b661bb1889502f43ab818e904530ace94c2ada078d46a28d6ec3fa55fba4413b20a41024e2811782d2be52c5856bd1b8c44c0a57f539f47b168ef007919f1c18f6033b1affde04c9fe93e3950465c666227314ae282aa0b3eb2f2b0b8f025dc0808830074bfb87f08aac793c2278c06cbad1d921e1cf098493130c638d9274e412acdc06a5f45b8ee85cbf2a17a3e3b111400c953721a0e2c816d49b014edf917e8aca1b4d5dcbff1399fca56bb6e28429715cc1659600528153efd333ab4325ad5703adbe193fcf9d3ccb02cc515f332d78617b3bea984827c73a21652309c5ec2b9f52219fd45ee2891cffb027c9acacd5569034256ed3745f17526a506b6e90839516ccdb3a411757ec2dc36454257ead71a3ecac2fbe9888e5f42446230f7d2638015c0cf3651e1b28e131ab7543440153224d9d6474688441acb806d28d0a96551973a6b0da5fc54e8d32ba18b37cca5223bbc463e0f8a655b39d91f291bbeec0c22e1fe5b797fe2b73c57b5139f2a6298795863707174b3939e8a8076887ac9ced857073053522a2517e0a451e5296f6ee24b071bbe6559525d2376e6e2919b0b1c3ba60b0877c4bfe9cb1f568e0706d60ec375f996b899f4313dc29ddd0f7a267b35e26bdb7631e03aa3c4937d7a0c2674e92458c6b222246ba12097d827a035af30625798c3830b8dc51d27d5bff2410a765975b72245307fb0a18e1ad55a1847dd5446780c962e8da67d5d20d8d8727d232cb12a13df1a9c0ae3ce88487b3388d2188a81776e5d22b78296fcf0d5510d80f346980f2f79306eaf2a44fb80da9ecff957c0cc09086a99f126a335a952ad2e93a95d99c763ee5f110602749266d6d29064997d9da6cbbbf82893b14c12640bce825a822f5fe780ff9bc52a0471d9065afd3f3778e11ee8ba5bbb4b8ebbbf8aed50bf836abb20a3a9c94ce45da5f7b9a8616f09886f259c90b88bf8b98f9b64d59de1b71b794a8203477a413489e13ea7e386521a14a5047c009bf143194606adbc95bfba9307df5865d149e7d88c8d733b99f7ee788112ff3bd6a38075757377bf197bf507a7c14adb1559862a68a7e247f2a0264fc1532e2806a8bb43436f12c2a3bba45cdeb740154cefe377840c913bfd13337c1824e38968e7cf533c0961eda994e41d3562b2ddc918837f11ee67bfdbe429ec1b3ff44f6a4e27c87b983d05fdb693cdb47f826ab40d36394c954e06d4a26865a421ca2b7d0dbf8013b3ee624dad78735894f98542e6773f019b5682576c833294c8fb9b5bf064c7a3ada3f2cf7fbc8e86a7cb9cb3b1c75c4a0f9f1c1d667e11c882ef2bc6aec80149d9f0fec1b1cf466df918715d3dde3a9d48572865043daf22eaf8f050a18d02ae498785a77d1639307d356435fe9aaa535ce4dbf80fbfd618ed1e81a5ee6c331e4783efb80832237d25d8b08ac2075d1d80876c22cf656500b0592d461833c654be92ee9c8ed654327e4f8f7a28b7233e601ad6a70c3b26032ade0eab13e4185ee0e09c921ac335e70f212d355592e1870cb6de4c4b3e06418f895b2936c28b0dd95f28846ad2ce2cf098532aa11463a956e1f4b1404f61d67d1f41849fee2bd26fe6fe8e17f0e65dabe4d8b7e75059da827e24ea5fffbcd9d324501cda390da4196ae9d0d1aab5f23ecc935ad6fb0e73ab0d54b36bc83a7cee8adfa47ba9bd626c1bbbca7cf1226f1c82f0c4e3765d68c83bd465d105eeaf6dc42988404426675f26d16e932fb19eaf34932e59f4abb9430c0eb1d29fe4b226058750eef0b44b5420c0a1f72b94ffc21a9c21df6098233e61be8df6cca8a1d9a4f24585d7dd7d5a03d6a70e9e970dba38bc6dac10645f97d5710ba71ba6eec613d9f2f7eeb747227d5d523b3da94de03982ca5f7da61c53869d206e3daa76df40876865ed2fda880200c7f9f3f45eb64cf927d1e6c7b0b1fbf34ac7cea6bae78b5d62c25443251c77f108375a0bf16b78a161dfab3cbebfcf47f70c75323f38d0ace436db9ffa547bcb150e94c258a5ab40980f6f490600cd064a4296961b8ae354e708580269412f65c2b8b42831d4f8847be50efd974c014f7dcb085397226a66379084de308254ac63cff12a511250f3e2f4bb02d1165fcb7c885cb8d90b627bbf234dc0e3d23d3393f2e24fd38ccea13ed45cc952405a66e47fec2ad09854b04dc12f9f872712a59de774cc429acd59c652404ff3c66d0a539a8174b953002a9542380dfc7427723362730395c4cc49bc9b0619e681bb49ac26f908b823bdbadc4910843ada03da52d8e3342deaad619ef56be35ed78affca0c4834ffe15fae07c35f9f0c56bc3297f5ca8f63d6bdd90f75741816353b394e6b65157802b929bc8bbde6396c4b954aec978e5af4292ba43f76b82764026c4e4c9e7c37f14a7d6a6d4ebc2612f835ee1edbc461d51d0df80f7fbda24dc90ce8cad6c6817b6b00f5d0694583405901bb230bc45f356853594fefc3a39ce63da8d8196d9eefb3c3b575c58dd6ad40aff20b873b6dbc8f6d790fe1be2b1c2920d64d2226f6ec3012e84932e958440c5d8f6d82b53601256ed62a4e1759084b521647e0ef3dca26fb1d21bac1c51129c3be139d60f759303ad657a05c202d923a696539d544b693f89c5b4ce05b74ae345bd7a14e911c7f3bca31b014e793f84aedc021374a8c156f6a6197697e267ef0852e48ab55a19b442ab3f60779b7704c5b1aa6f133761801320d13f0d3241b79809316425ed816d2dd8d4ce7757777fcf41afcf0dac3e7f26c730e841406d77db5795c7dc8975b646f60324666db46c75bca4ffffa27ca42d26ddf7dfa9e10553312cad634961eaff63e05989adf87301fc2fea04db51e3514ad28e902c1a10a9dcb33489c40ebf34cee38786a238dfade0b0e0fd2af374e5821d24c73761183580b319dd4dc558ef6b4c8ed2a50d8deb5374d579d7c1d7699eb3433dd95a3f5657aad302de5bc79f809141c82abd773d41e08d984bce00af8b92a9962a3545f40755914dd2dce050eb4e3325ccbfd6fd3e7f33862a1219c2e047f4d10c7574429f8a8a6c2c83eb2857eea2c33885e74cb26abf610b7c3c8786ad2c998bae1f54f17d1216ec66723bf6d28ad8f7c4ce03d010c1a1561ff6c72ea7708e329ea663eba6b0d7f94907777f0082c38d983bfd04b92e87e7557e4e6729879eed50d30372f2e820408b9c98429c14191a2dfcc9fa19cb2dedbe2333c1251b37cb2e349b1543d928e7b73267b7e2458a6ff43d47dc6c633f081d0ff7278d5c0fad7401b4c72ce5cfe8aa81360d301d3d958ba408c532f74cccd94d9f0c5e0aa4f518781ecafb816f887f3015fb3622b2d96c22b0f588c99f891126329bb36e4f64c6fbcf216d2f569ab47fdec9bec49fa4c45c39466d93149ec1a6282d3a0e208fabe06b79b3ba00174b19b928503139f5e75af00ddc2364c633d83676697d27215e1dc561591a9a743f689750f5152d717a5940aa3d346add97b54dc9738528da267e77499be62c4edf774eaeae916119b65d016e6400b7c31b5ad1c14c632673b6f032d1fe3cd9985193dc8676239e0482c9318c92e3afc5f30ca8431a39554d68bea2c500583f812e0d77685a43ef8fd00b20c6afe2eb2162eec84127320ca266f371b48e8cfdc17f98a8f756ace46914e4a4ca00b599c9e510f6b4d50f57ad5fad4867f888696ecde020b83c3f3e0b2695aa0d2ad10079b0688a48d51bd54f9adf2ec8aded6e7f327fcf2872f298052cba4c5c41f2207d94d9b27ef2578e17bb30f693c9e88ba426f5efed1586d8367678f2be1147c8342c9604bc0cee57f8912b4d31ccf972cf1619039167b607440ec429bb2949e6f6e1c3085d9305b5aec3602347bcca30770c9de4a67018714ee071843470516b3a497bd70b1767bd32fda4f0ba4e0ce02f3c93e3ee298bfb817814aa57b1cf0cda2ca4d86ad31178b9695e9b9a44f7c339b191d48e5239a02723cec11320d828c7c78527ca9f8b5ccbb24783d415d2f996038c5c0fbe7e24856566f47d55e496925e397ee1f3acceffe740d6e842e967c6efd619c966e6fc6f4a84e20881be3dbd0eecea09a8e8e752ec6dd523fea0e41e75eca76ff88a1e814ebc4e203371f92d03bf4789344af54206c072a9d86888fd6c97890c9b9816f988a8cd13ca9b4fb8d787a1488a08366460378b2d60d5904d5d86ebd03faab3b8e36813a8c29155d6c3f39fb7efa2f04978a5be2a1e39ba752748c0e8476d34b8e81eb701f342136784d837cb51d010e33db60d9170141639eaaa45399daa1e507707f5a3e8a6eaa4e4e3be1a89009b190b45dbcb31cac436a5dababa1b3bed17f088e73a93c3bf180220fdd0355ab899b221c1d4d849f59cebd5933d4e0493a6acb71c391b9d13e20b561756b4a83c67db56cc15955c254581bf528ea671c1da3a1a57bfd6823bc5b14aca7ff35bc305bcf43a55190d4a94b1107d82d541efc11bb5997c26e39abc4397668a3a7ef0f6d9b26afc4697389f58f2cae98776ac84744f7d2f4cda9d58ecebe743d486d26c5f8314cdf499dff6ab57e7b1ab694da760c80528d79ceb21387951d35033bd1981805784d68d4be9a720b74f0c875c1d547a3e91c9b04a3804bf05f44642d2f874130334f20f51b6f147a4f1915137b2d12150082cd685121e11fd350e4c31c072b8a48d3ec842132bc0ec1ef0ab137d096b2ed534e31fbdb46f194846bd533a8e11149bd07883922f24bbed43fd4b6f74df16b3acc26a24a25bc42516c880f7dc86cca3f623e0b1991540b2782ecfd4aefcd3d49ef67165f6de095502d6e47951ef6c5e7f21e4f7e533e8116e51bdca935467c3d3c1fe1d1cc414f88b783432c18688af434e8492f2bce4aed2ea542015aca35ecbc55b21d084341edec8f0cecca423d5b7359f076a53af4a520a6204cb45144313c8a5c3782f1a0fdc52b746876f5ec08d6352cf894d0bdff9c2d476700411a812678fbed5ed271d49e2076f7b2939f1963ec2ee0d64494f44d6279469ff6363996058ede56ea79e1f7c41e34dece96909eb56d9e0e2fbde881b03dfad6a08af34c099cfb9eccfd873bc3482d84517d3c275c9aa45f2d99e52530760b9ccfa55fe1f4b03712325e5455f8ba8b6772609417873b29982a95b5713f6cbb92ffa8a2623553c72bad77fc002f2c8068ae148033094b4f721726837c9984c2ea4bf50af85e1f438cf5fba5977dbe5d422fcb2c2a8556b23c84900520d112ca87736552cd3f56f678858a4e325e3201ecff970244794b441a8ecf87654cc248063ef5dc89290b08cdc6a949b9bd17a5a5bd3d0c90111412dc8d82fec4c4630011420d40189ebaefb7abc0b1ade9e5346022bb065702a5088cb9ca1bb4fe5f3bd8592cbdd3fe5180c935a3bc755792c23376a9088a80acc3c319bf6be0ad0a6e398db91a6e7d1e787beb1d4bbd4da91df1d4ef7b36e9e21c71678e5c44668bccf7a7dc30f1359264fdcec54440c6852739c2e9075057521c9c65ef605e811c6c9055f2c87f3ca862fa9672627baa30aed441f5f83986c02ae5d973d82a06ebbee60acb2f32e41de1dfe2bc548792734d543c846a1051fdcdb4a1cc09f33523b9e994b33ae4a150cc573434be44679759f8dbf6250babe7dc686ba05e1e0820fc6d9c7d73a77a3022a73e77c462a2c19d04dacdef0a5872464cf8ac855d6c4cbc4f8adbf8ec71ceb539d0fae99d1ed66a9820ed7bc9ea7a9a402530245ac07ba5d5dd1d9e86acbe5ca8c28f906412ba5d055356e73fb7e3409303128667518f662a5fc2dac0333b12bafbbb6f42aec6b355e118a4f5badb947d5163a7899b63981c489d63277fcb773a0a0b180a4bb54d67bde276de9450078d492a4d9b0c9c0a7769ffa4238491d6a03664876671de2b7616a7d79579b18c07bb2f23e383615a18a34bcfd1124f7b6741db635a953797b980dc79dc0946303e5f70780623353bad4cdfaff760493490673481a10d8fc17855d72b2b2845b87ea2d6d299a8a763ef9e6b9dc5b18c2b15321e460f2bfb8bf886f6b65f5cf5d0e8e40f189e1bdb200415b11e607eb89a25430cb020efa1f99fd9f4f3dc7b5f3f7d613dae6329a25de654855578d8d5d79e9d176f4c7b761e5478a4992c20fe721ec69ade48c5a613f0fe3b3233418eb493dde8c9ba4206377b525d8280a471a6a3f638cd0fc18f61c3c13b23b40e1df936e55afdf417e29804125d7df113ee6864b8cde00f6d52e3f1bd90cb6a997aa9ec948415993bd4e1eeca6f3dece5c5623a2b0014b4b9999c008995c2748e3daa8892a6a70f8bd5b34b103cdc8f001a53cb317cfa0d63285bc3c16f0bd6080ee043c7886937a7942e98841a54a8d3382f0f0b0477a74a729c719246c28fc34e96cdecdd97eba267e8de8b60d4931bbfbfe86712fa880f23a179bbe4458e7df56051920e8440a0e84cabfa49bb8ed562f94cca0d5a78129d660cc083edc05bad897066cbfe0d3a063dd7b399cce14f3a6ee4e3230298b26d9627f07b1056b80176f2a059de4d5a45a7ca19bf76d0e635708e43e9fd3283a647c9546a9ed1ba290c86f1b173b55b3b2a88133a0a61ff270bbc4983911f78c55ebd52582219ef14a019bda8f460863d5d5b6db058ad9aa5f6779c75824cc8ef320ad062c3ea8a1b06409f798536b00892f0574f74d424b8a90113342b69cd9d0a44769af27353c1594045226d7b0902b2cad0b62b767394323cf31c75ce6240b423a417a20d9e0d61f0452e361e37bfd49bb45f77c64d17b33a690d7fe35496278ee1f77289c7b67d9cb289fe1d51b31877944df3c8f67ab0e1c58339a6421e31f7ec43f4e42556e9111763f7dc0ffbc22eb554c1d31b9d61d8f65532a9a32d9bb6c0b3f748fc201d2fd4c6578b1a1b4489682c17ca4ea1e93fd0b457480cb813727e3dbdefe3bc1ab1f225868d04621cb8e03e98ca1174ad840443f81cdfecf227a5cd26a2a9715990aadf4095b828ef7008d62e628e6631cfeba125c10c2ef344254c8ace3c9dfc2863548b65f5ed9a8d9185cc5737fbc826726891c8c15d3f9e9a4f48e831819fc91bf26a53a74139b6c8ecbb669aca7d5ee0a68113b8cb48ac8b2ef39f221d907ebc417dad67fb2226b3c0ecde048f567d502fc33befeb1114b0dfc31ad4d182888ab1e4c9911b5c5ce783bdd433436d91966f91eda78e88164f14f4830c38eb7ba867d2f4e17e267e7b98d4ae281a443c30e6bb46247a143ae4e9a0a2be34afe4b8ff92870d45760080b5516278d70ee770c30bdd1cd5394300fe74c617bb7ddd15f76e6c969241f16e0ee29d8b9055497217a992356956b56fa2ab6071795cc4169b104965d6060ad177a2b19b7abf367a9d20c9a913927477bbe21c0f584d6fcca1c4d0ff3ce2aea1ae127ea681549368dfc33b386db2ba9a1307d8dd9211f8f3981da59bd414a909ec3d4d902a24f1c183796120c03db349bef711f2a51faf190c315c0ea454b725937c095e2b31555b4bfb8e0e228fb3a86f8d361e4bc5b7e5d14a37248600230413ee3887b89f075765dcce9143a3feedd5f8c097efa5b66b099a59a1505450c373f646d2f0d4a43f52c877837204641f5e9cdaf9a8010504c05e3839070785b09f41f285f5cc3d59650245e7c871a937550f4f95311437f14ad06f54c09eb8673a30b2f505bcfa448119da13c501394bef3fbf50a952defcbff240e8c8df0f4ae6af5065a54d3a38eb7a60a5826c096b694b408743d66a294d1eb1bb2f7c8aa66deaa637f8901426f061dc3e1546ae47efa6062744b874e0ca290e270cdeae0ffadc9ecc63451ef587c128c04394c9de2fcd2f189b977f990703dbbf5a586d1a4d71ea932b5047ade92ac93868eacd343e362e00f2c4650dff6621fa34eaa612be1f9333159c596ff46d546f710ad12f3a6db5589a69c65eb15c9334cbd192bd15f0df1c2696e97fc943fa695bf1c99be9270bcf821664b20f375c5c9111027a3de0c1989a53273ed1d108f5da8ae1f05f4bb43129c93afd22bbec03aa2e96caefeee88f5fa34d3659f9ae2e749edb02643266fffaf767a88cd82f5a28ae25ba9b0598297c4918c5fb72f2c009e8f8d04761b7df980a86d6db7ddc7f15012473acb0629cc5d04351ee773e3196a51c2f2ca8131dbea481a3716afe3e913b6d80db7c620377e0349c5e5c6eca7462088e55bf15780b846d1ea8ac72c0b04b3735d8d76f20d18a20185cb72b8a13f6f7e991ec4b91fc042d36829e884394a5ad154384fc84b248f7d1213edce1769e43aad6efe384adee43d52059f71bf78255226c4211262e6a465d2e8de10fe4d64cf2679715c86274d5a8ea6abed08c8f6e58f7711ceb34e3385bfb0e283f032aa3e3e0ac886c854c0c2b70","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
