<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"2f49a35695e4a77d7c6f32666787b2cf7878e88e5ed89216ecd4bdd3d4996ce33e460d65f563db0c5c667b49ae59300e1685872a1b8142e9971c878f21c84dd0211ad10cfadf5d6370edbb9c87370e314f8bf56827a45d9325fb6551f4aca9b127dd5c315ba53fb407b82858d86c27a3438d4e9cb318165e756128cfdc192dd8114bb8a543c4e5c889a3dae61fd3ce6da2d8165ae36d989ed92241ad5a1ea573327bd906fb5dec8f1d1dae863f48c3f29ef0d95b9417873530331e8a07ee2c316b64bc84a3de6ba778f199bc7607fb9949c7ce167dfa51175a2679c3337906bb77f2539d04df61344616562ec2613b0bce63b5866581e1225627b7efeb0256cd2ddbbf6ee8b68aa3f84c74a5bc22afee9b2b5909750413bc6c2f71a8afb58073c8cd3cfff55651ac953d59c9aaf174730e2678910842136d2a930d425b0b22e671d182942f0d020014fdea86df3d6c4a8db85d65657fae50e6f7db49c4d7ebaa4ac76ea24b025e29936c0126748739d1f721c133ff6354866f99ac19267da1e48fcbdd1684c34ff3cae4c84acfb4265e74235912aa9db5ba3497e58f5011dcd9329e9c05f6c277bc7ce9882789334c8a0e77e2dee5ecf02e07267d52371adc804fee4085e02ca82f09dd36a6f2d5d3367354bab95b226913f6ee12f792b05d5c5987db82bb5eed08b647edf2c8b41bcc2eef216f7d6c9d49e97f6de0b0a18f7db45184cd229b5f3722427f9a3eea309fa35191c35cd9745fc7204c93b5af1fea6182cbe7fdfdee9d4ba38598dfb3f74bf3c6e8495635966d62a0d1c101d7061727f3e7292eccae6ee78677e9863bd15b6c75a16feef6e624942bdeae3e1e1320aea0d33f2781af7abb7faa806d5d469488df87de137ee922c02f5e8221fb04beff918042e94774230ba3e9905b089882e60b01c5f0daa0d1ab9921a8f8339a831e2066cf3d802d1b743080a2a249a669926e697be4d11b47d83320c5e719d6f20d11ca565ddb4b0e1740bd195e31f86807f753caee10b209d42c6b227775610b9312276ad431f27a20ccd811a96db0b0a1787b20431585e8f43154ef9e3231bf56b679502fb61be087f062d29a39731ba004364283d8467efb0bea4edd055fde7f8ae017117098985ca7b63842974fa6c6456f9c9bca44255b209365ba83b0522c55b8cd2a507d69ab4551ce854031914aeb4880e4299ba77dde90d38a0161f07f82d02e5f0496c27d2cac37d05b8b20e3d2b060b939a2ba5d97e62da07be3c748e354720487fae0d9b4155b164a6ec46d20ec8b65c12d628c74a6714fa955881e1e25f6169d553a4f82df2d7185172fe0f0d345c6186695e443770dae034f721293741be1dea45ae9b5a66282e5406847c84fc143a74e9d68abec9e17c706dab03071900128adeec3364cf17763998aed84301d9a0d5790ca021c65c4643c68cc7cd5e825ee9e1126f1e6d730b43a6b3ff4fa86d68a26db2b9517ee1da552c94f6eb0bc3b5ffb455e07ccf4fdfacbb4fee74e687e2a83b4662c45c0ea5d05377318665108c451589560f907e5af4f80c85f897987c3a2722c86d316079e845813a116020161821d8d5fd4e4818c4ab8cfdd9b801f7e86aaf6ea002ce4ce6e3d475b75410c8d3a0637cabde36159faefcb62e3cf7dc7b3fbf9738fa93a1761bb3559cd83490feb2b0ffeb050e38ef3df42fdc73bbf2dab6d1c155e834def08ec374bb6c7e9b5d2e57771754c6c7f3c78bf20b973af993f8a87d21b111e494352a2d7040874bdb7c5b9aac6b085a8f8060e5384c676e194f98e889def78ebdfbc0fae08efdfc5702c14020519b0ff6feb18d256460a667639ce4a2bcc292135e0c4c62261b04e2e9c75e2e49ccc3c09595e92fee187895d01a667646fde4e95754f47d68900a8413a610df9d6643d90a8a84d1cd6c76f899261319a4d29da9da828fa8c86f666fa028271d50138d41001a6729984b245133d2a24579395f44fd80c825533f1fba1d79c07a38e11364766b1fbac0bac5ee8e3903cb1e5016538c59b3200f1be2776051e6acbaf32d2cf80be0fb2d2876f1db00936a3c21e913130a1b4c125a0ec38eb6ee30a51acb65e9856372d4f17c429cd78e2f678e5d160cb5f3a36ce0fa5bf7d6c9579ed380a45c092514adf88abb20d731ea938b3cfd857df7a076d32657443fefd81ab50852123ba9059c7a9badbdda25b1e248f228d2d8cebb1772f9e5579b22cfd6534899f917698cb86fafbc0afb831a34f58cd79edd8b8d30f6f94813a0561c666127bd98fb9082da7761ebee8a0b834105af708182675b495ca70732f482077827fe030701c41ef7c9cff215cf40e44a823ac7182f634d55abf60768e4a78f29db68158e603c01adb591b3ecc801711255297fde6546088e1134d74d78a4dacd3e752fe3d86c77007e8da24cdd29b3be851c169520ef49d986bb0cfe24a54f696d89ea30406981dc9a7fc3cb7881c1d5937c8493ca9f849527bef4e4a887dcfd01db91369e8f358436993d3a6004a61af01ccdf5996f3f36d5466662b0d9acb62cedd6a096fc8cada3966dd4aa2dd9b4d4100985727f5ab3ecbe555c45a48a81b6a43cd68a8b8fa6bf72c4f0fa46ce54d8afa249317839508c6881f74709064e97f644baf60d84ceaaf21c89a850a90d6d4b296bc1fc57c9d3f38d9faf950182f4b8f00de21b4d3d292b5b2bb14c532d47eef3f1206004e657ad8bdba4f975f9f149fb889bf55264e300fc4f82669252133c05e1e5d34b17705e86454eb195fcfe74692639f5ec5e16da069f95c5ced3fc486baeaac2f465942ef32f35d9778426810baa59577b14f715d28a38b828331e1c2bd2fe62851f7057f7d555df13b2175ce0f4185a5491707fc530603a33b02c7fb8688b471c18f2d89dfca46a560dbff30fd6b133d49812fa19c6dd4f9b61276065b299d3815f645b0b0a8c79283d15b34449e1f2f0584174a3467d03536ea488a0419c08ec7b0d9dc548f5ad350eacf31013ca82e798df03df2586447780191fe2cc0748eba7b405685eaef7c8902231905d4d3209e5e4f8ebe529f6b32eaf70ad4652d3930eb499bd738de57fbdce4028245165a9a4b87e07299a164d13bfcb928bbd9d608133440ac0356d4672995b284ebe9d92968a041b9ee9fc3723240c9bf66bfda48d4eccdd6be327f1f310a90bf3c65efd0b9a75fce5eda2d4f769f2353cf78942b598ed6b8c23ed6fe664c00603f2b80fd79139dfc45fc4e0682199e7530f3d7734fe9d55b81c64b06b52e55c201ca9d6d009739858c5e747becdb0ea28e3471616c700b054f6694e58ac39917fbf196c6f84bddc82328ff3946a21255d7e3e544fd5f702f466ddcc02586ad0294b296e1c8f1d05ca248b283a1655d40f0faf96912587af935341e6ba0ccf5a6f0948860f830cb566615c63480a71a5656191517a205f7f6a71c7a25da42145b307877f0b96314c09fe6c71777f1d8642221b4fc2363413d585ce92153ebc2b0a20f8e8b77f6443ea981a2ff0cc20815f358dd561cc4cca3b0531fb50a894283ff942d3845c2fc770d31371c05b1ffd1a448881b0fcc1e8ee1c63bcee54e9a1a448168544bba08270d43665772489ed0e63062023d626d391e1aa995a4f8d98a036c676982a36ba220cd8fcdc271f0ca474e19cf9431884a699a682bb567d592994b7181caa937383d8b93d07fa19ff0dba24e868cf16d91cff2a4d19d57960236bf1dd1d77539f6cd07f23fffa007104e84f5756295ed4b21c2e3ed34e538623e35061dacefee63e06b500274ff576830bf85317584e7986b57e0b06e7f2d528fec16cac5bd4bb475d21f7fb130275fff6e8f2ab638180831b3fcc2f532674c8331c40ae03c8ca8fde955d7d6ec6893cea30bb83fd68979a49cea2fff969d972d3ecca01bed6b02ba67b3124b60df5125eda068f04488e057260aa0e5d8fa8858920243b6ad6bc2bcb7c96c4989045d9e9960d37e5e4dd92221390ac1a7e456c3208373905e20366558dabbbde3100ac55cebb94dea6842d15b057e7461a57003dc75f0c0fc0a4c6ea1c403b21cb123a123f3f505c081fc75b2c3decffaa3bd015c43b0af305ec3e9682120d55e09bf46111ae2cc1a7b62b62adaf24a9ce6409be3d330db60c1783a79a5f621802003aff77a9c28f301b2ffda73677196a2cde8d93d937273d53d25058eca233d2b8b40e860b1f457d736c6e74608f71f95dc3a3d0c4c6ffc73f3f88b5c5aaef1af86d477854f6d956b8b7a5b150c08bdb067be80ec4e49e11cbe21e5d20a88adccdde698f722cc6af4ab0cc66665914f1c97eb9ca4f65c7b1255d8fa31e822c04a8594f0a1f900b37d5c3281f00aa1f8273b48da25fbfad0cc003fb5b0ed4e894c440f359e1255b10c0f2def085467995b5f2ed27848f993d2bf5d8ea2a3110480d9890f43981edbe1d402d2bf8107c5bcc7908603061933fb6cadb31138bcd533376303409b579f1374dceba79e1f8de5777b54b99ac7e9392d951c0f5ff3ccdb248bdf9e35f1ae1104e10c46cf70edf17e42d9884d6f357d002bdcd948a7972008a89b7817384d3d9a472d6676b54b484ae6b696a01e89b34b6e4221ee957af6d540b7816c311ce031f0cbd53153f602f3191d829a83f925b35459e6ec63da5d9e3a5575ffcd1afeac5d07d798020e7ff1e4f946b0a4c2fbe153baa6933a3cea073dd9b5ef8db6ae572f6a65ed1eb7bb0a8d025d9ee8454108074bc639186ea0c1126eafd076ccb6249d536b4ae057eda59c3e1892f039734b4e028c05f9a50ff6284cdd5fabf0a2ea3fe5d1803b63b4bcbcf0c3f04578cb56f2c68fb5662610a24dfc0ab2ea723a750906c5eba238f42ede84c04209ca5dba9ad8b8fc7f51ac174f0d236ffab5e532035ac02ae6cd43bc4667a40ad3c57ae7252def0d487cb3034cfdaa154557bfee0f855545f0093050be78d906b6d7430cd01bd448f3d92de12c67df2e11e972e4b248605ad669b4c3459f7baa8b9b064ad4ca39f2f51312b66a61e7d06bbba116896fa587703eb476b8e821b68047f381d54b634298d157fc932993e756b7b2438fcb9fe03fbbd3400affa5caaadab48527f14b7c5ba2ecdddb32fe09544d82747f2555b009ac704e37d02e758935237b23d2048bb4315a8262e303929f89316ab803af8ea123776b3e6bf485dc01a59120d96b112750dc433a355a46fcbb13116f38d4d5749c81edd75bb825c1a347e8e7357c8f00b5f267b812f99b74a4a8da9490ae397c6541d98e8bfcae3aeefe05b95ee9be5fad84922b84daf45a323fd7aa7e4262cba1c9d3b68604f77521133ffcc8669d2a9201ff8ddab1c4cfaffab08556c11825b4f1a837c2224e3b2e9bab13d29273fe8ce792997e01c3d18919e0ee9c3b3f0cd71364a3dc255ef3b283bbe153208e31d33410512ee5582772df4e85737be96f1e41c6e6be1059b55c2393160ae1c06e163476e459028e0bd73b0e2bfe57f1ac90953bcc4f9e57237856fb39a678eaa4b9769e48d73f544497ae46118ddb74fcd156f331cb46ee672749e0e3ec3df17a0377142004ba3afd0a4556a26f67d332db1b8643e07c3310e21386cb0a10e74512784829123b35250c1808e8e67050d9f6ad4b723e3f60e03dce66589c688ef25385c61715184f16d801f176e28badbc6aae40b9a8f5f6d08eacd0f509e0a65f27cbc465b3c76b3b9b6c571c16ebaf33c4cbd5d81728319bc0c9e9821546910ff05246122d45e5eefdcbb64509c37ae6e207535fea0bfe4f56eb61bd046dcf475a8dabff8d454cf382fa96e3f5d3c594887188989fad17dc437b8f0cb143585e18ccc798b20ffc1821fd8be8cf630f3ee8463016931e49e7f9c51eabdcc65e1807d8e14970f3a5620c753e7fd72ea4afde128123c273885b8ea9f2a17c318c0a75fa60721f361aa80351b7f29a3be91d3ee5b7d0cc7fa221c7f00847a7aed69dc1ef6229da75cca17f2f9e48a682b27df6f70e263b0ceb700f6a1a4754374e7e0165344a6584cf7739c44499e4bc391130c856febc708cddacefc27feb6e7422d8be5f009d04dd11b05b4c73c43494d3185181c2b752c94dd4ca3e62649f69fe3c2d3b61c973dd1987252adb54fe8ebda289fac4e05e70870c19ce076320971fdd1783315210b697b3835322f5037bef1326d752b3c72370f1c1ccaa6c98ee2ba07de53cdb47464c0635ed90a2dc4ae03643ca6cbc333128a2002e8427b799217faa7b0216fbdb33aa7288b93835713562522c84ca5aa5c47d0276c2072ad891fef930522027bc05caeda7c4cb61600a59a3afc568fcb3b38d598262400ec73007c5cf30bb5fd74c5958876379229da9d032c5fc006dc01458f3e647ec059cd9e893e545ff9e182f581fa29936fb43aabfebfda0f32d647be5e9c770a2cea54e3d528b36c62ce30a7df470e98e2b0e76840e98b6b00c679aa1cbf0c346c9cec02a0f0adc26b784f0346e7f6d74c8cfd4f6f987c7301b3b8de27f935b8400b0abafb180b38b51a70020e143b1bb1c368535ed5b45c09ac8cde8230d52fc98a14fb0d0fab73313d2feee93f5ac25fd541af21ca849f384c7e67cc58aa78a02ccf33b175e828bda0c050af9a2c6b49b3b843360aa8dacb382a0569a0c1e5fd6cca71474698b0336196291d272c20c5861ad602f92904a924ddb8e10323575d6a8a621e8b083d97cea9fccf9d4100fff8f3aaeec5740c07d61eec1c1dfa5ca42be380250e530d43f948a0a706d4be278a6f1a333b6e7ee7842cf2f9cec7ad5132cb2559048be0a42cc12e2fb46cc3f5d20241480b450eaebae91a554a6ef8623db792b31ac9bfe93b46327ba481decac3559096572c13c66b60fe7642862c4765f0c9c91c12a6f5a547f6d27b293a7475fd588fd8c7f18c5b4d2c77b7d8c34f7697a0138e6662769e96d61b9ead6b30699eadd8c2785d196119104eccd3188cee3c109a1b12cd154480ba05418cd06c6c5d5f0f8f39d72f2cdb221e54a990f91ed5a637fc28fcbd312bd6574ffd9922835f97767cc15c3b8a669a54f9f12527898d74217fdd585fa3e01cbb40e7c88e02bc774354e5747281de97bb9cb4813aaa66f8e3f05516673ac6df1d867d686c9a5a69de61dba666b3e767e5636e21cf4a7f3ccc4b178cc03fa629298f918a462164f32be571dfdcb09e1eb6be4c32e831939498a43213111db61dd6b227eb0db849f7858df428beffff00df3938bca58b490d6bd3e4cc27beeb385fcabe57d521e2f1f5e40a70cac25b60eaf6205a55dfccd3e8e7f236fa27a385912bd852d27fb354f3fbf7e1171acf42117ae538ef353130dbd7440fc1e14c8180549bd300651c9c9047bb32bf78eab6e322d5cb56e89673472e274814c11bd9aa7933cffde9da8e564d4a8d4ba339c7a09706a583af8d708f11771ef5d16b594d6e4d96d5416acd1a2c3a1bc98038265148e8d3de11f9125d5db250a8044ddb5c0ca33156ec788632c1b5cf720a397af5351b892ed16b41c8b24cd53bbe29110c8d1c79dbe6f65139664b71b4e1e1f69ae2f196ed1bb728e223ceb7f377f947944f50e6c0037d02c856e31f3cabfc9ecc880670aab0192ae86c54f0b3e7f097ca87d7d03b9b5f4fa88a4ff78d9c6c2c99ce8e5db95f036e5059fce0875d6e0f3756235fc02cbb16ad1d65071095dd828d97bfd8f0f5a403c9448e901c422cda615b34c62d6c4ca3055527eb02005d1e0fa9f85e2f371d44895fa07f091710aed0ee8d35886d9957bac5b759e823cf1b5df4e444220d253a43e5f6ee7a36af6bd223fa6bf993d725f876334b37a0865987e30280a65666afcea5c5a4a8b645d2fd43154cb7bc1c26ad3cdcc3c6a3a65fd47e49af79c41652a43767a8bc36f402c5959cef0fab9b3fa74e5e12740c11a584dbc6c384bb66377b35b71e1cbefc9b06ea19e873fd578eec1b97110da67668809314cd94a0f9c6074e5c772345a42e16c8ae37654b165ee54ed044fe3b4c73f457c56c3621ef479d955d93b7808a10e098b2bb7f1938f6362230dae4c1d71beaaea8b370c3dfb445f6a9d7dff81643a6c27e8fdb98e50de23510e47836161123b7b5d4e8342e3a28c52ad7736a4abb20f8b5b6d87dc22f3b9cb99fa39b697397841e9cdcd663ac4c6090bfc544ef3788661ad5167e7cf719d1d7708985cbb2a2bd735a60f97595e459a9ca5df90eebeda68de3ebd6713c22b5cdae8c95fad2096917687363a97c7117a2b9b25bf4528cc95c3843b96c90671558e5406a9532e069f4b41a54ada569b1e19e0a2a9e65329d56cab0cadb0727442a165f7cbccf1a7b5a19293571bd19dd763a39cf2a60f9f0ef4aedd6cb6ffcc3dec9158e3960acf9317bfa28eeb60d52c44265f995d8d9a9c89b135e3fa7a20f4567d429a6cdedbdff16b64c8098db425edc281700c6f77966f9c6eb61cde4dcd0a1517fc553562aa761a3c3c61ac6f169861ab7814398da3ef79a07e27c0f3368f96d70754350c75cf89d1b1e2d7611f49bb42985ae35d16dfe70a7d7b9a19b13740d82f92bebfb362984726329a0cdd0435491e03451f64604a6efc3206994f3c03be1351621f64bb613c62c25f164d7346615f208d659a27c0e5c4f5b5f3655b716f93fe19969476d8b2cd6ac47001666c35cec805c5e21a8f010a6fb1b4b9fb41b90d33c6aad6f5ae8d0714bddc70c329c16187fd60c9f463a91c6f4052e7872597e75841c6a9a899d44bb88c3a6c61c9feb81f2d5cf81e4e13807d122e7b3f00b98541772890a4cbb31fedaa60ddb54557a047f97090e5c5c0ae657be9a980a989fd34d8163f0102a8a7eb8ffb0e450e09b9055546486dbd2abd4d2347827a6e72299501b6b77fc6a993a3fd0265b6a14063fa510bef6453ecacfa223ac3ac5dba3700ca6a12ae550d8912cac2159979605045ab80ea40735985f5ac74884a6cbb8b1eb9fd045470bb36a6f582495cec40586034fa917e555c726dd6e33693d876e0027f6762d49d05f33a18d44c4626180157d4b699a11bed07be93d908a673f239fdc8c2365c3cb167839ee354eb1a70ab32f7db68e616baba826b81f8f7662f586cb4b7f2ee8b40f3d425cbe276ca978e720cf3d6587a41fbe11c11a26c193a0b2560294dce825ba46cd8e29435fa7d3d6d8540ef41e70b2d10c6c731876c0c2cfb124bec26bf215df5e7b814e6e1f97d0670ccb75da805b31b01d0114be2f4ab2491bc1c6aaa003571c186b2179176b8f4ca6411904824beaa69d038052a4321b1077ea9c3d5d954968c177b0a7de521886b95567367abfba380857f2c812da42664590862ef06655584589dd88a593408949c24869e13dd0fbbbb04bd5016fb47d499b4c5a25c20085a11d40e9154e2baf5e1374252673c1e3c8a904382449ccccf63a0e6f35b817663302650c3e09fd9f10c86455d1d2f2ff7d71932bcdaef3fbdc4380597b6f7821b7fa3aab4bc0f488b7751a61509652a61c1fadf90cdb627d4b6042918147450934f10127db0101ac1b47f02667e1aba7df12381b0e46109cdb5d0f1828a36163e9b8e42928198e82f42b878ca8abf38fe5db67dd4fdeb45b5f61b659a79886284414ec7bf697cb0fee2a93551412460e76293b57ba4ef269fe7e70968ffc8428947624fc1f4caa9d52f309eda3e27ae80efb47841ea30b953db34d44ac9dfd9fcdd25d8fdacfb6961c8d7f4a9d3e752168d05c88200fe93c5a408de7a95f2f713b7ef866cb4effa43e6b7a037c795ab3d16b46e1838b3e32f6607f0b5c679fed96d6e4b2969805b4d7d609e40cdf007158e4439c2bdf2be798166cdb981dbc539d5fa46e6a82eddb46323b6ced04bf0b2005652b10edb88715eb9535ad11b25bac27e85bedc36e1f68edb7ce301d117d6cb1029130839414d16aa18b960dba4519c8ece11597831b4a7659e2873c0d542d734b6201f2bee84750a43f57fd2047ed67555c215e3cf8d235e28732c9f8f8532ae48c9f3a84a2e8c8a60af57ed984512d9558d0dcc4a2bbaff085ef243146137e1c5387b8eda0760df2374a7c109b1fe147d812956e45a7522a69246eca77aeaf45b805877dfdc506d32c880055fb57cf331fbffadcdeb946de8059c95574435edfe3245384fe57a49f2c1d878e5ab78d8324b1467f2ff0106227adb85b178e6fa7feb657cd568e165524c05771c9c330bd3f2a02384ea867b5dcfdbb7ea2e4ede33c36d17b23a8284e79afb2f50ae54931d5ff0e20efa06def7560f91e249342bb0f57f2f8dc5036b084514bae24cca0f02399187928d741222c784754c63f37d422e1f0eb59b8db8ef000a9600bfdacfa803e3fabf47b1d6d1e532c81a1ef0b5b7c83638865b73160f98ee9d686502f92784527f0afc145f00f25e2411aa7ed6212785aff00be08f2844169626a5d0d158eefdd81b2872682aaa39efc141bf9257e997312a0fd5c4ca50142d34c627b83a824847d20d769da5f55e8f427d30bb7ec5438d49546f5e4f65fec9ec3d88ae2cfd431e85da6987159a50a71180f036d889772f6599305b6aff27b673f81c7c3445bf8c742383167f146cbc27857bb2c39df1f304d9435e46af4d8a36bdb51d0b96e30274fe9a4de62ec2b82217d9fbb6a6f5241768406cd7fe6b7b2ba938bfecaab5496ea06522e2a74554e61cf619db139a6d4aed706c4cd92b728b44948301f6f5624c99db918f48b099828f953c78e122a3031bec94755a169ba4dc8ffb89b59eef0836f348fdcca9164af00bee426a01eaa771597b671c090d889ac68764bdcc78b82258d27c316facf5b0c742bc13ee0f0fe9967e000353e16149aa979ff0242fb0f908452d6503500405618d091df007e29b15396059db0569b774fe405a299e2e845b8e0df303f0de739291609235622347c3368383f80dc9318664d169a7e767405d1921c535ce777a0a0863697a741c0e974b815424f72527b2311ead6bffb5e5373593898c020d1cc91b0c9b5e651c71a9ada2aeb27f91a5dfdf1bb033d7d13b08ba7cff7ce5c8715832a6593c27433a8daff6353fc80d8cf7fa926ca1e8c89884e4dc45b7c354060aa827e3fcc324aadfa10bca30414851f720cb2b7498c5c6290d7082dee42eaa384de086e116c7b9060918184bdd1b5e1baa1caec55553ab18257631d2e71ff8b023c8e14d96a2a808a4bd2c612b23f6a2158cd0705cba2badd747b96883155b7d9ff8001d916cba51e81de46d0da6d8dc0ea9dc0215a427ccb18149fd3f58b0301619c219aa597c7abf8897d133f35082058338da53f770adf28b26c8f6d9ab92ccb54caf76f2d23b7897f89016c057537d95570271d51eb34ac79d965039e44cb8205d8be5e23ca21a91dd54e6ec211dbf9a438fa30ce3866235aa2b31fa327c0959731e1f577fc36a7d4debc8589877f241c85caecfa738a37d35501bc34fb1ed7bd4b0dabb22efbaaa6463cb28a48843509d1614ca1241a9f84eb44407330953bc25b1c2679a12c3d26d2393c174cb486d1d8e5221b6eee56b3d0405565697b07fd73cd2c1f48aec489a089951b034812cfc3bed954d335854eef0d212a50b60ed95e64c1635b996b3f1df2777f677a4ff3491a25fc0f2fd908634292a7bb0439f1c2421e1ea099f65d9b679fc7de3e27f97059760cbac0112838dc5c98cbe8d3e451a7a4981e7a67e46797975c3ff6ecd482d82e13346fd234bbbbb85b1aafc5f8c40e54223fb637e4a8b3f8f2f222b2e00020aa1008ae44ca1dcc298c234d27da919564ad6c425d398dac442a0e46354c03ebcc6336ac5dc9bba30ed8ed38f6fe0a41e98d0d3010649e53ef01b3ebd10d623a3771ad35d82a2ce18e613cbeb4ed686d9e4700b2b2cd5a5ec7a0dfc319648dbe14c8349e63ea0d3e3e666cf144abe041e9578352ad42a2e65e89b4fbadcc4e6f64bf78f73cf623bc3e79bf8752d5a2d24f4bafc95b12448fdff38308cc5f06aeb0c380de10081e3c4e571dd44e9b0b5681201e275ec478501df636566f9dd158c9679220cd1388f842771502a57b13a6b143f65ffd5231b0f2adb54b8bc600f2548f473010a396038d90f5b018929ba88ad1d11f186e4f44051737eea3cdb590ce6fdd8f892f72390f92ac5e1dfeac5791262d02c8d2a0ff398a2f74218e57902f1f90d24c47f5b99f36a0043ffe50edeb0d6dd04f354014b4171f6b1829c1a2189ab6d3cae6db5bf34106b2de0a049a9c3e7c5c5aa3f6849611e96ce032d86724a5b44f1b31e6e24f229f6fefc585fe14181a541f2bd90c35304b985ad2c30102a614b7bab0262a33fdd514286ed0053199c03ec9f778e4630c8690c990f1bc0acac79a9b7cfc236a01ac380e20e5616a7ba22d4b40d74d6e98b8d722c7508bda88c02105242dc173220c3f92d4947438186012c37357976c51ba56024f08fff8d3943e02666ec7d48e35d54a117de28a4ccf47690d594414aa72d74eca7a48cf74eda431c4589b4e681f21ab9fac04a1f01e6e6e567491864880a53f5cd9cfaa8ebc051ea6ef7d576d000d229eafe7c66a1faad3ae047c66d37ae558d071c0c71940458f66070fef366455cd2e85a61c3e4bc28b606ca0762d2db44c841e12cbea7676b4ee61667eb82cefb8773b5133c19ef0e9737e1053da16ddb5302e8d58ed18d41e1bc76a57eb34ff261a3fecce92a3b100afdb515d84c6e63164672917139d48e8ac9385846e41045a8f8ac8f6bb3dd776428ad4c850a724cfaf3e54991cad16be9891aafad8e1af8fe551488b65c3c93c45bda764d4f366b266591b5cd3da31f149bab19bf6e33f4ddca9f772b324ce2395977b8b85e32ba18c4410d2a3e779727503a53fbd68e16d0d95aec153c59d2291c6fcfc1129677932d945287fee840ffea46ad833e4feb659c663c3df5548a2d1b7b56b5c6493a378fd51039d72a040b071bec1580042c087bc6931752ecc7968435d0ccd7ab1da162721fe0434b085b4fe7f52a714839d86ec419e5d7047b5aa901d10ccc2cbbe0191d103a15aaf844eae98573485e1eb42994537dab87e49fced8be13696feea84e535b326f49514a4da665d1289e5467ed5e16d9334ac3df5a14d29712f2af3678969aeb246b46f627b4ff4ed5fb03021eb77b6d0ffb478aa23027297433397023bcd518db7bfa1633bf187ab8bd9c64b4041fe6fdf564f30bc572dbe0fb43f49235660756eac72592933ca9f2db4ad51a9be5621b01f4a362b57ca0cb2b2f7f038327416fb15f2e49f434e0210f10c4db1e7fcbf1661c43ddcd8a90f927ccd7a3b614d304088ef9f963df88194a4ec64a5fc1e693b5de091055c689892b58dd9a1b60478157ccc8f01a497c73d71fda581e3916b51c71211bd77e8bd26adea1c5331171696fe1c574ba817a77e7db4d94f11d31c2b7eb1b763159554759efa221b2ebe7bdee6390e5e4f51109cc3b5bf3a008a3787156da609ec65f30fefe63fe6f1e058fc9ba6747f36d55fad85e5f6b638a0859396adac3a754f77ec655afcdd2ed2213f0c6c631f6e0b4c1b413d58ca43ef34bf845d3fbf5207cc683262113ad23a44cfbaad0fe37af578a7137c36968ee2ab00021eab4d1c1516030c61d738bf7cd8d636ae11b4c2859cdacc2baeb5605786209280d7376aef772c3da04b0f2f0e05ead77fc8993f37caac9f37a395ffe50928d982c1b1b66b3a9e3a79b92284481ed1db82a379484d59a8b6f88c25c07e396485c27e8dfc976b7a64a5d59d4d55d7757146ebac8b378d2af4a27fa71b8e2d59c7c006c7d7393aeb6383fac4e1da72f1bafc7c6ffe4b7a47ccecaa23d3f2874c96d711ab6944dc043cd3f9a07b3bdb4cc48c02a8179cf06493326aea65fb7ae889a26d6516f11d077feece5d557a39b269bdc854ad4b364ef0b67e19720c538067a2b438019ab9cf3c37bbbef86986f7bf1151ccee8a9efbd21f873efc2e6e76c74b5a94fbc7db53d1ce69d73d8d62b8f06b15757492d330519f53409b78ab4849f6a7f1df456ee6f57d163a2fc4bb938a262904298f9ab2f34c23f886d46b4a873ebfe657bfe8e7ab2413ce3b1a527a92571fd63bd7100222472319fa17c4e74de0463ab61f4536e1dd51f5f2eec7484bcc166fd83b3bd8e7792c08917edb3809bc8d57ef3140cb9f0e8356c22f7ab14b067ad4c89d0d1b8cd1031b07ec5b7e7a0abb2c469d26167eece47d03764d9a4cdf84008138ea19822f038c3b755ec05740f2325a6e4049f21bf8b7eb3a96956ea7ed1d9e248aaf63c2fa41aec36058417d29247f9698a365225b0db5c7bc5b43e708b8cffe7e456afb63c9d12ce61c5b60f2ceb976515c31e7617c3f4be4c38ba0076993283b7100f68f7e65cb573b0e8ddec842e232141be866311b1a44dd437f14a7e1f82bd9398f5a03ff9281482bdf8f6315add4f219814b67e31d291ee6d13bcad69fcb788bed403adfb60fbc332671b0988c30d5f2f0b","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
