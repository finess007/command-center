<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b2f36fd73aab32f8d194f569222d732111b280ca58eb134bb7f8156d12f191aaf31eca7f6c580beef4ee6d080cb2af49fc72eeaa42fb462e6d6ac9d6ef4286d625d2e4bda63d54349de3ea342f9edb3765aaca9e3df8b1b5974e1962d75e1807c8a02d7bf0ad83a8667887c121fd8557c202d281d60a5aaea11a799bcb6ed3d916b1583e83be410c6325094e8724a072828e6c65e17a1397b224d273940b1f3a38d46420634794de9f24a1aa1393fa3ea13984653115eee2719b16444fc2ecdeb4550900cd0793196cb271f5900c8a62734c2717cc8e4d48865bef7ea48c5e2326431f05bc8db5fc1cddad0d30cdf10c0b07e9acb2876c99ce9f9d2c779fabd10654f6c8cc8a5bfd8fbf47110bc42400c58fda1764542c0dba0712856aa83b4aa6f56dc5560a49d1282e3693fdad0c93a4d2f77b0c9ab7dbdc51a8d9c1b59d87d866c458c7b51885d68f84403abe13ecd1f018befdcb363bdbb5c38fe477726b7388a226fa554ad6e44ce0c4676ff7374ebd3cf06da373468779288514167a13fd79f6d5ad283b7a854996c2c359d0347d8fef259ba27348922a077134cfd6b555ac573e57528f4c01bd483db569aecf816165ac9a8ddf133aa3adf0d8249a20b39d3ca46fb6c4bf521a8fc729caaac5046e5b7470af30570859dfae379d3de20f00059eeebf7b3b3af4f57d7268d82ced3cc0081298a923078692e42f52ebdff939e468dbd0a2195ed9f0b9fb884845a0c6bd594a8cdf73e6489315e089b1b9e6e80c9c2be0a2b643663eaa2b38ea5164efd556f00eb18dba7be14b08d3cdd1a06a3f6e1acab28e0a1783bc7c862b0dce420bf8703fd34cab06617e0866bb3ab78c70955e27e8c2485ddfeb1f32a89aa218b19d6ea765cb3a6aff0e7ed2a60ffd073f2a653732ed6b3b6255e95d44d1d9baa55820a359b71ca70f989b1863337a5e7b061215ce8d6ff4b6191582635b57cb0df6113704761be92217714ffe50a8a125c5d220b5d8fc8f2c0430baf067c393d84b82c2403818ae6d4dee9dca2cb31d4c13ca4e3b3756756f1dd5d837acc050809b68f2d86bf005cd04f8cb20e26680cb237a7c47413408eced8f092d57933e0b1d74b6139ffc133b5d035179203f3ad986ceea00573f787afeb5377c04cd5ce48fec04e1e4ba1fc4da94842f3fe27af3d865b0ea05c3fb62ddb2412804550b1d008ad12aa5ab8fa730510273d9bad24a43490588b69f0f5a428d84f9e34cae2303dad806b2d95f660a68375cd036a08ccf2accbad9b809197b154256135c5675023a10934b331cb83b7a8df69ad1bcbb14d1f373e633734c57d0d0e8650ddc6265842bc61198b662191021e658358ca590018405c14380be204b40c5fa9ff0e5f2dc75624883142a0eac474a160649b14156dea46d541a548a4da400752b594f03bbec6ca2e984b1d6692796e5c49bbc45caf21818e2032df3db20507176bf57b66ee72c03d4e98b911e0f449eea7fb5812bd272793de04cf476b7362d2c56e5e909de69b8fd86feb1d2a25e8daf49a2b3f9b1d003ed121fdce2094893788a6399aa0357ede6c2c58800776df93eef05c11b8402b9ef84e39183b1e200d5dfbf72925a6850a73a18455a5171820e080b952d8599b1602109e05b4cfdaa61a4278b2571e336ec1ba52686f0b25abb4004acf8614b150b90d3590141f8def2ec8fdea75c25483122cc7981ccdf056b0a583ef320801a40499fd1ca2749bbb2450e028a72be74eacc58931e9e9a32434b23bf96ad78d22e41b4e456e1a70d4be0a9046fa959601b8c2d4ed10f0ae4e80b9a291423f17fa822ef41a427dcb0676187e0846a8060e2602ebde27b8bdc005b17ee9fdcde3b599d22b299d486a3157610a70e6b0d454a11e6782a4c997518aea4221cc1d7e0260868777fe77c02c85b844bc7fc7d4b958a1e284c0b03a0984391e8d5dfd52768b22e5dfa5590027ba3f521083acc18e56ad2bdd69b596b6aac7b0d5e85e7c87169e5e902aaa9922d4f8fa2bbd1db40df60f1e6f3bc985c3879b4613af6d698595c4407504819e0ab271754128defdef5fd29e4d32dbf80eced85ef9d8352002f39fd4a0384e7af7941a8167ff184e30dd6ffa85acef2739175a2c910dbe86e759b56dd056a76b04db7719493ce0ed8cac002069c43eb5f9bde10eac29e0d834c5c15f82767890455b97389913122e16b69e55385bb60546bb6ce1144c42d24ce5cf53e5fbe65bb6bc4050bae29917fcc7b66ebe2872ef4b8db8da93e9442e6bd9d85959ffd008a0a18e28165a16cd80091ff605ae716062b15f6001129e7c9ee699ac7ac12bbc210fe8552ed4bed2f93572300d15a27104f945a4de4bed733a08783d7faab4f1fce7ce9d8ae56cbdd73472440535d65ef4b409983a46020a122cc9a77eda07f868661c5521418d29d206d08aa19fb8b1372f2721a51d81630fd957530bda46604f70b2848e1e70d87c6c752a9cca08884dc8012bf26146ec42f1d03185b78a80687214a89073a85f49af21596ffdf86721b08d4fedcfec470d0f846e2992cf1acee28004ea2ded4a9856c19aa145face2f9ad0c95008f31a6d1c87671ca38f3f4d145da8436a14d53b4438c5110931137044ac44acbad173fb61ba8a0e38a0b105b568824d204cef5b65a755c5fc7418b67693998322368bd94c065d9b93fc1ff76d433b78a6fac40b661e9effdb2abb038d83cb73c143277ed439f3dcaf58e8cdaabcd4f5827e2bb738ad2e5285b592402a2747fe7366aae58a884a2df78aad57a1ded246e071edb2f7840521b0562adbb3a35e812c9d593b2ad06a57059fb2eee80709edf3eb9e95593c906b680b628b738220b4c9366def1299f5bc0bf2ba27b0d05ca39f518c942cbbd01968fca2ee0621d67dc24238e4282292baebe9b2ce75348707e5b99a2cb01c50d3dad6f8eae9c4abf914a4659f4c21e42fd6eb18f38476255b8d20cf6b094bf66883a17f1e8d57cc6808c442db5e9fd306c05b3a4f7eddd1fee2db6eb582a0cd8433cab913b221e505b76b5f2a3a71bf59dabcc68bfc28e0a6d5ee6df9e4aee70d60788c2116b577fc1a20343c8cb251ad7e146db1408fd961208ce600312a2cea667daffcaa5994a36b61cf80e0c14d9ebf31cf209d023d2ee6862f602ce45c80b20e2b9fab3f1465679d8d73e1eb773e3e4270498fab30c723b51eea689e78446318b292382c471f64555c9225beccd0e15078c935daca0f0c3f16a59f152df13d2b193166125829580088ec9f6bab6f237a1e57bb22eca17e6d903012876f9410338695135427f63915cc54cb332d349c88ff35a8c17e7ea93c046781530eb7b9ce71b627e96f7465babee549b4481a46e801e219b9101ba166bdde6d2efa1a1f27b21bc4d947e9a2e945234a6d3704ffecf2d67e367542a58a59540ab13b819a52c4819779304b43ba7c062910f6e067742d8d67489911903176664b9e75a6e821248169aa26cf356bb7c987563bb1b11dcd4a2764cf0c8dd7cc0b0ecebff39704129a2f761b98b91d4d867b6bb898a63d208d7d42c3a7373b1e6a6b73eb9115f5895532bf5512d3e16f100837f0b3cd3112e17d9e0800a07a46eff9cbee2fec0e12b529cb11285df5817f1ccdcc0413afb21d8e8a4cb261b724cb7c61db52b356a6a60c62cae9a84c54aea24c2bea9cf5b66298a9c0bd6c6ed778c75a88121c4272b837b79e6dfc54bfa7488fb0a609a93bc9e0a8e19c23ae6dbee7cf492500db1918e13cb1598ff4ab88e2514416b8936d4fdfa8da6a33da44dbeb5917c57ed8e99c96799a8a3bf98b78d1e47f8d79153fe8151d38e8ddbd739f1b28173dba6a076d723867b8413b5fc7814b6ee66abaab305963fcd07fcd1a7ef1ca7271f74f563270f918f545bb16c84be42d5b8eddb24bb6b594881effe8fdb285862ca0c139fa5720844c208fa9c52ee55612b333783e0814c9ac330e00f427201f9f7cc8efb3b895fed79392774e6d7eb7ae4b24a4da3a7c9edf34ad4c819f115d0d8d35161564033aabdad7bb24d1105b47e4ab3c434d3bdd2614c48168c3f51e988e3b6ef6efa3e1c1c445efe9ae9a41fbcb3449b9a4c2cae1e0955e1cf57c10d9e2bf4c6814bed4c02831484518c618678c041e5ffc9bdcb457c4f21608b0acafd18abd1c91d24855d2bc727316c54771061654722237073d8c4ae90a564d5cefd777a22360d783120747cbe26f9a8f2e7f9bf8e27b38e2b6fbaf4a936b5fb708ca5fa06853c83f1b6941f9a1e572d7f54f23df53abeb3c47cf05fa053ae6fe3a5e732935834a30f9de76ca104b69f85518bf033406b3554a5291604821034b7864b6b41dcff04e21c92b7830d2dd3b9cd864e92e3963e49f95534e742de9618124d24c73ce91a58c73c4ac19c444b8040c5e91cb4f392bb0fd01f7487d372c8d0ad540c399200809a982e5a42f8230e38be4ac197704c9efb5da99f1ea6686dcb3fbe2331f782d5e27c4dfea66b02cd78b3599faebef97699ce7e6dc544a887bf07968f1d6524319a09b0dad652a9a07f7468792ecbdee88196f01b728a84f5e40de97bd073225e7bb70156e7f5224e664f40bdb375b2f26fc11e13b3f00fdf53baa609ffee5f296ebcc85b1a4030400e6e700a6c0580701c5f85ba975c8c4ea508ff82c9cb20097abdb55cd69223c5316e51d60060f06632b39dc9cc3336d312ea6834e080145e294d466df4a3b523bf8596f1621cd46fd2cd166ce0db2929e8970f257066e3695df4b06ca4aa73d919bb8941eb97fe62973c2f48528a2221440c6d4be008b6121a6de7ecba31b4738cb210dc48e45e431bd97218bc4b59f5e352c3aaca4efb19125382a4291397fb771d9cf6230408f11facf0320c14fd3e21f0fc152d9b458819853140f35d0d636905315d1b89c3d37da4aa3999bb3899490ab29a5bf03cf5027037e32280cca364a814fbf19e4c3467f57d7150f7aa939831c96abf28dc9147585ee7a5c40414be62f37f42381d81fed363ef5591056af749e2a48782889629c0fc9246477e94334bd84f25061a980f590030729a5f993536c228d83f3657de3e028f3c92ffadfc80e4997bb2b17606f94b0e0e7f14e7e3471912156c425427c9fbfc9759ab861008eef7f4c0e8062bb8907d77d45e947476903ae1d622419d953fcef394e8e9d9871bfd90c389e0b7efb57ba02913828a2e245c2e29e6360fe0c582467f676ced485b69248f30c298ecc11981167d0e6e8ebd6014caa531f8a873737f5127c370ecddd1f01b340629d8db9bd6c476e1be0c469ba127dff44eda34fd2a14522edeb33a204953df053aba2dc9638fbbbfdfedc5a7655863f4c2bf4ada4917fe2b5aec59ba01fbe1153bf983485e5f2ae9a2b416744c83849ad1a72af5fcbe1ae0ed2244ba6cc6087895f2b02e549fc4b7da78b044fd80bbc828fa74e723bf3a868adffb683d1f095331285b267fec18b98a0aa37874acf4ac35690cc48043258b7697f61fe7a62160e23322ad29751a96b46737e4a865a81cc7f0b2f1e9047117cf2f5dd754f36daaf59c47e67fd963ec8e972854a65e769f140a1a796a2d86e2b5c630998acc4cb732838494c47476666e2cdd055d7cdb92432a2b4726008d7536cefb314144f8c932fbf734ed1a8da2765662ec8b56ee2a7ce3f13d18bdbb67368a8be3b0cc698ecefc3ab86e4a7ccaae42b3a537eb16e09b403f6b920a4b3b7136b90c3a39c373ced65344bf345fb050fd83e7cfb596b8c9f24bc3a86299406286062ccc1f0707ca9678f89346fa6feecca9aae6bc3381b8e9c009de71e5cfeb06a67069440bf7c3183ef46e26db39b2bc86dacaeed4708d1a7b474a95dc9ad62e2ffa07ca5532fddba99b1b053e57bd1a0d469668e00e80a9a3ccfa75c9c3dc7fdc9ef0e806c89b3349ce9a7e9c5bd2cecb8184446ab9d0de0e0a9473195323342eca2563f99a3f81656895f984f7db9b5d8fe00142456c79e26fc50ea2e92ab87b89eb287e55ecc7baa9ffbac06250e6ee1d4e5163645fb99eed94b43107c0df86a2b04a97588464f3773b1c16b4a950359e93bd0c93bdd4347fedf7d53f3b33d13128a3df9eef5e8c3cd280e7f94269b6004cccdb4fdd5f3b38f3fa564a08c7ec6627ec3a4b75b79cab870a69b2f0fa4132d999901ec8db9902c8c7fee2d18a81cea2f71ede296728c6cf10ed39d6b6f01b8ee79e95513471955f02cf8226b068e4bfc4ac3f9b7ec8878ffd90ea261c8418303c423867f319553fe25404aa68170975d609cf95426a856f8a6bac394692401a7d7de19e40a24d698dafbd27edd36c272f75d4616e87f9cf7dfd75095f10409cc115fb41ec0b44546d4821d8f377ac8faa6bb483f72c2048e636a7d2ffb17a1c5fab85a93752c0842492ad3e7f15ef658f7d4ded0d4561b8c7c69b45c0aa77a5340f8fd1d9a678a4530e6e0c08ecd698606b4823ac4aa7d24b6c494d3e6d212198f6f2a63a91966d85286615dfe66b9d4290c96edee6783545c470494ea3bdb1243d8fa66bc4548d15850c9536cfc09aa5a9beb2d9d1ca47833ed3e6299ceaa771cebe99bb4712d5dfa43972b54eaa0aaff6fa1bb85c4dbd6aa609c5dc2b7377ebb8beb1e51227b496dff1cc598d19cbe77d99b9929ae009bbb69d79d10efd2e01f2cebfa3decfbcde1acb2a2ff09dea6a50a022e9529fa3d2d90bd832522e39ae73a67bc7412c2056b058cb563a002c661ebb68bb392b65404c1d781136627d4872b7ff0120cdd698db183bdc50f2b3a8cae078d78f67449c0102915b95456240819772cd6627fd35634664222aa09432117f6e5cd11cb8fb22f81adf45390bccc24025d98904d388e1b7280e47c8ceea961c1f4d59d838f54138252c3c4c744ddc0277c90e413d82af8f106434218b36e738192ef330821fa22bc9f9c978d021c10140e8e85de466bd0ca92ae3e5421734f17c7e307c098fb63711dcb22e3caff32e5325986f1c04dbeb05204b497d85e6bafd910a88e4f2c4227bd865cfc81c6ea400fbc1a09e190f2603e051d7c30ccaf9e1acb3c6e9db6ec35caef06cb3ed5c80d51e0d9f1eae0967b62aa5a2768186bdba7442f2a1e294d78d4a2818307c74787704cceb8b32809c9f97d5544f47cbc4f85c4e6aa32637c2613b5f98292f87a114fcf607dfc30221a3122aacf6c4e95f793185b3e4bb899c4f61c2a9b12a0aed2b03d81db7d3ff50c43d677ee7eded183d9be829b9759644fc0c942ac6350a08237df382f627c5f2492d927da79ec2c82c08b44e5d80833a9231ef20075628a03d35ecb45efb774e12d7a6f900398a13eb69613021e6b4696ac802da84e1ad71c0d9aa9797e0bdd8b3a819a3cbfb61bd16b6023861ebab9ae79dadc087f3b415b4150ffc4eec719444730a9d1abd62ca8f699b5133955cf87a6c5e90b54a668405869f79624e4d599c77815b4c837e43cf20f54050e87628830719b9af5f841259a8f1ee810d8ff3b586503c0829274b5fee180cccd68f818f3bd573c7b9da2f5f36aece6d8a77174447abadf93b49528bd510979adf853e9de70e289e43597ce4a3a917d8c6dc09d137079351c8e2beb4715124ffd862e0224522024c44671b379408576b9f8f86b2d14aebc1a97e1250f2f678daee86ca31a03deddca35b624a115ec7f9435e285ecc42f5e9a73955a2c85eced8febd3021e24aa299cf68183e2a73095c1f965c4254f1e0243bf0e591cd99ddb6662595defea417c4f7cb69c9e5b151047f909684cf1215a21e7f183e2fbe46b74148782532a1e887979386cbc911968f7bbc2f7eb9ae985ec0b15ad32daeccebea1540801a8306430b72539e7846d6f96972a62fca2e06e18aca05b0d3176db152a2aa50b629d1011ee762756b713a9ac2ccb4df5353f43baba925850f36d1ef243de0aecbd9dd48d4ad0aafa8d9bc4a723aa3935d914270e468cceb30354d727b0c405c49112a039a7226c3f5ee8f1cfd212fc2e73c5f35fd1dd9e260a5c5d65f60686c89cbf06f4f58480bcbd10f0603a9c84746f9883f2d79e171af3de2542f5dff2dc599286e79ee6c60efccadf8b2e1f1e55dff45d7705973afab03a04aa946bf7ee801fd7d3d97f3e0aef3d0c3abf4cdd20f8fecfb9a1a26781e0bf1f852a4b9e48181dfe2af6cf4241a0c0bf68ca58f0a578416428f7c21f8df72dd03a4fa2a7f185ad9a01455d8fb6686cae841bd6a19e1f3cf35204694094f5f18fbbf231436e8169703867b85445b3609cc7c3daa364d2b2d2194f8fa8b0adcc67c78f6a67bfba1b71bf022913f5f6629bb9b69e9533449429eaed30f4baef5e6b1972726d5293412765730c3c56b3cf2105b367e7817f53c910deabd89acfc0e5a2b1b42415fd7e14ae1fb951898498b326ef20a98b86bb224cf65f9445144669f0e8e305f49f6392fa260db46318b25b011b8be4f235769eca432771c30f76841360076d18f098e251c708f2bbfc2091073a61882a059bec1cb49153561e4624bcce414323a0d173e35161a445d44cf0571014c06567e911781ed881be5b61b60df65a96b1d47af9de72267722fe81710e44d5894097fd775de880d36cf9067a88352ea4b00787f77c36a90bbaff90ff097a84aa78b87f5fe402ed07385e16a4116f4e5591543b37d3aa9ca19e8d23782a10fe0a39221641ee3befa87b291919233b3399a50cb10c5d59bd2aad8bc1c794e662bfb4bdc55cd06b6de7bf77fb3a02b38f0188d67662725423c0f62ac16bbf84d1ab738e356feefca8b899457acfd1b99b3765e568c91daba4b886c49f6db415956a4672da6a1851b1cf00fa9bb2e6a1a54e42102e3764dd0344d92566fbcdf1d0b541d24230c46c72d7d8464458383f7e78e9c4234e0abdfb2d9278af6bfad4cd23209a15d61539455fe90b9650f30a511e1e9976ac42e6ab96321f5ac2fc1e7cd3884f43be34f529731a345dd78dc360a4acee50676c256e6f5624791f6bcdd666018827cdae529dc61317dd2413cc37ba0faadd414ab7c501536354690564b057946f37411efd6753deca431bca3600ac0baf7280208c800e3a5536fe52014a8218fc4d86b9d370ed0a822a41fda537bd191438aa9b013e7cb4cfe2d7d6283f3dc328e078ecfda081a39d0859eb990319e93f8d00a2c825366d3e1bfc04480337150c3d3975a474779a5d81ae326309ad30e10146583fa0a32831c8bc0dd11030bb12581783d8db1314773916cbf5b9854d74dca4e89c6a265e0271c5731e61a4b858508fc322936dba8d94e17b37c310b60d2a80704578b548b1f6eeb9dff779103d8d10350676e2ed8eb654b207a6267aa2574e994ac027a97416fc6371838e2fdf2b65c9eeff07023730431449d111ebdff7e33f738b53a65b740b5fa25e4ffe1af0a309fb5a59d5ebad70c727dc89e7fb74f26d4e3e82ae9550af05d89a25b324b7844f118da3e706ecdf91697e20ee636cb3486ce0f8e42f3dd8296724d07bebb9841883f0dddae00d9a4b06ce8fb276e5097af5fd74f5631687ee50880a6b27d4066d15b15ce3b5d759f9f159b84ae55fbb1c1db99ccad8b0a43d0f1a99a69bb1539cbd4eda0d6b336a15d15a8afb74e506102cd2a4f613c8217b3ac16b5b409334436dcff84e98cac10115742d9a0a62dca7f0995b3d91671989019e6b02cd57618f2991fa80b41b9f098d2df381eda25538a1b03665f8ed3b87bb1defe7654670158c76d6108c5f23be93bd922f15bd2fa42101c6c00d7ffa2977d8911e1e37a1014db19e5d248f7c54d5ab39fd4704ce7f5d00e510eb9017f996468f99561ba782ecf1dc159bcad8f550e38eae5bfe0a21b21b3e7f357ab917f912b1d21b06938a0237d6f2274d105e66debc4379ef90944fda06fb33cfe60a7e45b5fe566f14557f04fd6bc8b430bb35945b18c4889b07c44e4a88847b72315fae0ef1b47847ca9390302b49601fde34e3288bec2813783674c186b4c42ebaf483490623a16dcc1479982bae418667fb2cd3c47699a3a7b730e3e9da0c7293bdca12803d51ab9ce94f278b94e2038404933bd2eb6cc230d45a9be907496b037104118b0765f41855cbe3db287c18cdf90c11f41457900cb36dfff701a70e3522a5e1c758bd4dc2f040572681cd23a49d16460dcbad7005a917385a01587606533fa980863fccaa26f3b856eb7706038c111dbc71dbf32d9b60ffb8645f5e7c126d088a6710188e9fd6ee51553d699cf1a52a223bea95565314d510885a71f2550862910650ecd6864c575d8b2e063b001cb383fb8ca234ee8ddf0d762503a33083df41d24fec632e2a0dfdd9f17efe42e533177e0feae7c5b0964e4114d6d3040a77a3e90aa44bdb0719cc8aaca42def4dfba1de410fb24d209b07c74604d1b68920e045963d688078519ac0c40066c59b65a4c42ab7cd5a39543ab92f2551bff0b900b51cf67a3b5826a3094ed0466b3c206787a3f993523c6588723045d28cf2dba82bc97eb4014bc76ba5bc70a66d4b09930770377dd72100d62035d81a2391055a3bff5f1319e0bee6757891aa9c5fdb8e0662580c000d9c4ce98b8bdab84bbf4eab10a96e87710d4b7df7497d0fa81a9ed950e0390194e6ca5e5391034ea82b28be8de7c061f6454cc25047e779188ed263dc614b9b9fdf879e37afe491492724f6fe7a832c8d5071536804911ecd167a0bd3c3d2b479eccff032f1c3aa2564924002d4623219f5c4a005632b692d9ccaaaf55e90df8c06ffeb164ebac440561546876404dfaff93042e07dda1bb961aa106baa13295dbdd677e1528eb100b5712612ffb4a732a037f1259184bc59b38ec009ceb728aa69fd82a29b334de9b23cda1522e78cf375a46859d8da798248cf36bfea938ec7feb9fe0d761939b429616d2950da4f7ac7c2a3fe46e73ff19cb929ae2c491f4a8be6a06c193c4443fc2c1d49df1e93b7b9433868a6e576b9e31b2a71ebcf6d8febea235b0ab08965deff3f800724b8c47166e6b71c1a631fd3ba5d69651da6f9b8cd7706e0fd6a40d267afba959fdc109b44750e5ce06eacd653576804b15109f6854d1768e440fc2a87328efc23c9956493035ca701eac12399683e34582a70195a8b7fc785fd994bcfdabf86988cc911b8c31ec8864ffc1487ccbaa412a34035b47d6d421eab32e763407a08cff00da6427c8a5563ab1b60a9e4125a37341465686d459b4b1e2115458e7abdde60c3ff907ccedc0fa302c8956285cc3dd146d639cdc13e4db25ac20bf922989f8a9f68f95b675b7e27eb87c0a577161041208d173ef13705745351669e3aead31ed43624e0ee8f28f7b8493fa62a3d130f25371e09c440d65566bba08fd5fa2b50263872762bd29cfdc9ac7b031d6f0db9868c4417d9d60bb8ebf46fd841076052dec7ebe923fb7f530ab4c5dfe1f73adce1976c4167fab95c8eb06fd2e3fee959ae70e6e5869e5575e54a4917644ecf5effec5cce132f7401b07bdc2c6fbcc9e35e6344db4213372a9ff17d48270853e260c4bd0a5e56253a4de00239a63ce619f085b70c7f4a6b00454d7e004b406c3cc13799c3e9b6376c920cd2ae215749c6b7bb0bddffb564b9ff12bde5038138f96d9270babca0fd1782a3512373a9ff25617c035437c978d848ab9c45bb1291bfa8fc78ac932f8b41c95292816401c0fb592935952942f4a50ad91b556f08ca8652f912f5b3f49ca49c0ec2c3f5aa4dfe3571643466a4b41216800f34967839092c9b5ccc102fa18358e4ef19774957b8c6591138c6b12c11950251d86c33b2e53c377435b0ad02545cd3e7548f6a3eb7c132e4f8a42b3be4bd07f61c6775d0eaa9cd385654e18e28e8c50e41cf92df76203140766e4855a62f1b898204429bb57db6622e06e8092c3a2bc462f6bc3eba4627112263a5ff68fe02039bd1f2385d53e06fc6388968581028d200a1425b201f72788d6f7177c1960085196a7817495c8e5f5f214c4fa0114ac7bff8c4ad2fb71644a63a00eeede0638a669dbad7477404a7c34f7b0356149ddd9e08a061c6c084bd76233afc675dc5b259246fb1121c74a061d97c7ee05583871d1bd9466c38fe31fd670a42006712227b18a7a2368d8d056feb6be21182f63a689734f2c41c1d347a156e15131210253f7863b22d999839a1694b90aeb8252eadb881379cf9a546fde21248e890b9eda05b6abc557fb0b61e8aaa6e9c898f5c5020406634adf534b3a8c3975330eff5a101d72162cc84544ea5d4dd359e24af39fa0a056ddaf041ae21658e01380888e0e9d20d3cc318a80be17aebd5cc0cf97a705375b30f7c49394313a98817e0b88b59ab3be46e0b0bf7bf69190ebbed500b3f7201b0a6e3fd7aea89e9392ea9e0a0a488d4727d8cca561b658d6aac7a9820d82d72025ab9c70777e9838d3ee928472a0282db82c287e3f906d563bd912e5cae7eb79344a515b337906b68cd9fa3b9ab7787ff091da11883bcf366275a78542157bc954430a5955299d7b62a53480f3e264689fb1c3cd51bdb4b247a246cd8ec1322099cdebcaf683d871df672d5eec7b0f3b2492c95be67dc8047aa37b1ca44079ae26834304aca1b2e54ad5702ada4bb336c18d857923f58055056f9caf5c3bbef7cc42a94d6bb73565d1a022b26db5eaff64056be7f607bba12cf128a0f7d05fea5a0ec369a56fd9e64bd37e5041b418d28726c000e4b28b23869c95cb76033b29f78dbab38d87b34ea2946c57c420b3822546511725551515e2980e0fad37522ff08b31b56443f0ac3fe7d8a4bfa0d8f6f3cd8a6a54580328bd198bdb67446ce5b5f0ff7946a19ccd3eece32119a51db9c93f9f28408178001e57a7aa719c1eac5995354ca456655b7573ee5a2e6d6e1626c1c6b4f32a1ef3cd386239a8928766231ab20af60f35d7f7cac16c89ef28e342cfe29dc33b78a494680aaab6235ea4fe0588dfc9ed23db8b54e1822b02050ac6e7e5d21662b5fa07a66c1a5f5c89a1933ff9c6b11475a474be5bbd7ec109abc66c2061eed53591d5ddd3b85594345bd1ca608572d9223c9a545fb66a6af268cdeac07753f6824e016904400c01f6999fd7f5b4c23edc22bfe801c06b742c4b9babe78c589a5cdb097d40c899ac32e8ff8deb4ae55818b96cfe27c8d4bcadf63c223179af9ca63b39cf8f256012067ad6216ce5d296b9ef03eac67077ed0b835c9e877e5388e8a9d46f1fe9d99d5631b3966f0e567e31d4ce644773d5ebfab68b56acf11ad6b49d8795d8838fa11f86c62a44a00632904e088ad6611aeae982aa5fd6b2d6220f3e673e520a584c80b002ad97fefeeadfb2ff07e6f0b50b4eb6dfb65c8740a5f615ef19d503eb5e7d987a34ac20d1f98e28ec0e6b7f1e683de2f16395aa41486a3a2e181a721b81599cd97ca2b216d2cf1d817c0951a91f747c20cedad5c6c0fa1ba707ad6411186597e69ce787fc30bca59e6793e5f1cee1ac3b93acf00d813f37b0ae222ba39907544672994cd222c7ebec9c7ecdf5ff93ebd4271a66e3a91b7f5455aea8899cfdbcfb67991c5f08c50e5bbe1daf88645c37786f664cdb63de208497ac4c8657227fe912400d544133dafc5df50f71ea7a2439b46485e362e875252cd2291aef344d862456a2c4541cc84d0810b37863fc6cf9bb0293dd677f6d4aebaafd1efba7566c6f8f8a4110e9966b270d77e8909c0bd194d61b1eadcbd8a0718af202d62733633f256bcc2fc710bcf424617643d9a81bdfa15aee87252e8909462756013ce4882c21e8af8dff271c4a71236e81255804bce38519f45fb631999c1463675e906803bba515223696d523122ac23d017cd7827c4fa077256475b38269a9a7ee33987e6d7da9110400874b421aecb393ecccef63463ca516ed6e18e4253521140031a3f6ace79a9c2a24547ffb0526f85ca417dd837353db7e06496abedb373fc74ef8fe45b86ad3ce8f345ddb99270646b3a82e16aef7528ec3ddc982315a18cc9b7b303a822e8e272b1cb6bfc71ef9ea60d24d31aae5e03d419603f1c3b1ea1bb3923fb2c4dde83115101135960f5f333b0d0a45beffc94c03f70278713b30771386d6714506ec3c6f144b8c58192486c283e0650d6d27976dbc5fc65bf0bf3c4c1e1fd4823c692bdfc64611173746630033d31521d185d6640329ad6168a8d749b4e1124952d94c01e699435568885efca204acc97dc00f44c95b54a78f5cc8dab83cc93ac3087e1b781b8693d1964a7aecc8019c27c650b3ec7544fe6003cf6eeb5508011062a5c5b10e12a5283f790dba3c2195eec550b6be949480968bb610cee3ff034562ca8d87a1a121d3bb45c666c4d7f3a5a2713d7e4884b3a5a2e0ae528aa3e612fc94cc4a77ab768f2732c6a6d45a98820626e948338ed2eb7e9b933564c02eaa20c60e521745f8b2094f9a71ca1c4d3b816e307dcd2b00f6b28b7a121b5b142695541e0a7e337a23","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
