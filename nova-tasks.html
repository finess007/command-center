<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1f9f388db323773cc0f88066efcd49ed3687b05089df554ebf2ce484d3db779f1ffac95023b7f854285363f1bfb16de993c2f61734fd6cedb5ff29f452c27bf7eca75dd4cfd8151a215417623de307bcf7d2d1e0503cd09803da0cbb25cf1e6f3783d7639ecf209c89df225d657b0dc888a08721237c251f955939c9c4ebd7a1e23745a62546f2f4a8ffefdd9d2309b7bbd0a6cd0142c0b3eb4112772069551ee66b62211e6b863778655c4e07120f44012aa09339c56ef21b3979be929fcd5d06b51d1a9cb188d1f25c14157c1c621bc3cc6e4c01d382d89ed600dda9bb4e342c799db302066eec38863e9ac3e43f4dd93d43c81be0236faf828344293bc3d1cf94848005e5d42d2c90bdd8299772645d448c8382768b548bbe7ab259d1dcce9958e15c79bd2548b5cda6a00f02114676459252975d64c1beea7dcbb8ef3f4c82f01f8902bd8beeb20d5fc734aacc2b0dde156aa257261ee11a3bcc79fdf9452942747b9fd4b1cb1755e4771a88bee8fc073335bb511736c09829fe4f1f1eea7fb6c48aa44b53ed082e26fce3d5435373991f3580d350c67cb25ebd1c8e8b1ece0179dc61e384243c0e28b90ff16684486b2d971e7305994023536c15e002d36f8b9cdaa85d507d7073bd7fd0927d0a2c4d59d425607a50f71afbf2bf7eb77906f01ce26d5c7e1ba2e8f7457e1006b450ed75354aa1416b8dc6977832e19b672e09bc9fc46e473c068f76b4c246a4663bf6e22c91c83270c424f0c690aa89cb8375c1f72107aa809a671f44069fd7da3e32460c1a7ba5e44e577de7e8a481905c4934589fb3a4925a32f6fb007e578819a0c4bf78ec7cb0bd3f10de35e8eef8ef1fe79991aa5ecda91a7fd166b5184da526322bfdc83d776f21118cce54b65df93191ef85da2a250ff566ecb7439d9aad7805c3ee87ab786833e81b262d71a040a16ae0cd13de0ce9d922eac5c11b87201d44c7b4b6acf13478cb0a62081034191f7a90f1f9975d925d92ec30a5eb5ea000378c2d556a34db0ec98b1dbc7db6ef91a66036142bf08c55e66ba26f929022b475561bb39ded3fb25a9c8374e85e3f3bbb2584737feb014447b1d04e5f8acc3868dfa05d07bb77a1a29c4ea6942cd490e82e1bfedad2978f52e0eb27c01f02b866ebf01a2c241b196974b7489ea04c5cfa95e7502940714646c94224d5a58678847eb11d7f54596b2e27f20f3a6430b1928b86519877ef3febd734b724bc091aaa2ebee3b53748dd0f520a2a2413017891f0c4ecf15d03fbd9b22dfad1ebdb164feb19d8e8f931a642a7be7e7efbed8b5b540ffa7edd7cb46efad6f9a228b5ff095f373e4674011535fd8f29f7c4c5344c631e97bc59dd5d6a4400b14ff73af40e68673392c28086bb1c89d3fc9b9bc02b730620adbbaf21c06e471b8ec040b4eb5f33868fa54d9e2abcb201fcc0a38ff599879fc1e6efc0039897168f3c2d0bfeab25df8fb9651b3e322f62c3ca6ae1b689efef0eb39fc0270b1fcc764cf66e8944286af8ceddb1b7acacaed8645b07385880da94b3f09043e244d4b2fb1795963063462391fa9cd55e42f5d077ac0a92f7f8706327336cf6b85f45ef7c13a21c65fa17327831ca44d46584da637c1da3b1bb5c5e7dd86bf80da421b5f0f9701bb5d620bc6e69eed05632a6e4c1051c01106e24c3fcb6ca19277d7e5c5c1540ba1482949af4fbc45502890c4c2188455f95565a2b312bf40a19e409c91fbcba88f8655bbd0dcc003e9c049af51233018a0a2b7b8147e7e673414dabbe87a423ed783d609566c60742bd1f7caad6963d54e8aef83b97fa7798367df1ffb97d303b4e22cc6a84934772ff04f8d7c0e3d39e4268936a5d8663cc9e2a742773587ffaa19bc1eca226c0af053192e922467613c53d2de650e7d4de4eb1710745f11082c2a5175f8c3b5d2db0148050ea3ff6339b1448dc419fd21ef5647eeb1d395271a1fdab3ef96d6fabe1949a87ee07ac2e2c4f932c4a85f1677c9c71657b816e48305ec7326d073f18c4f07e9cca3bbd98017edba5e182080ab16bef5f928ff130abcdb56cbdfd60d49c7a59e9b21ac7e069afac29f0c707ff51b53e7922b7b4baa00c80a7be21ca64885a36aaad4743e3c13db0b5e4f95e4605d80433b498b08d2f2ff58bd9a3b39d5f4a819921cb13e2eb9b01a4d62254d7d221f44b7efbc852dd8ee3a79801f82405365ef8ad75b009c4d3458d0f6d9d2a1615bde80be0facee8f166ffb28b14dec770025a5ef1a584327e53bcfa774504b4215453bec842f9a1c81dc7ac61e28ff41143eaac32384b53709de47c785b32d256404c2d0b5d5cd7e6465f860ea17ab257ffbebe050866ac238b34bb261d3402a7debda67b19047fd503d16683ca03dfd3f455006401e74caa7779798be050db42790bd7c6f9265b26ca859f45b8531307477783a2457b643baf01c2ea2239bf772122d2fcdb272baf0fe0ddbe7cd9acd08afc33fd277de7c3fed4ab7e88db9d9f2dddff9e52e498a935634d31fe456b860dc7cb249a0c13a8d4e74293b79d5cb56b340d7ceeeef8e0d748e23688d164129b68ef584e91ba7e8da4ff4f54b3285a61a295b81bf71776e0a97a4b00765116701b130698a1b3fe6c6ec41b94262c10b5fcb39e4ec7ef7945dad4a6ec41c0021f53cbb586192f6a2468f13a470c2477141cfceb90902aade55a4872523c51ef377b10d8a0388a576695209bd7e804868c6f3bebcad39f8abf3d05c397976c33e3d2bcc584b0d69157a580fdcacd04041898a31d86e686742dacc30cf5ad6bd8785ef4754a4fa9f449d68c02b656b99f357553f68648dd2fcc23632561cb07a6cc207ec81d934a2f34ab29da4c80a7af5cb72644386ab0916b93aca6f63921be64f90a5c7cbaed617bf581903cac72e92222e4fef247f888b21e5c0b5a0556d357f88503c39884f34b902811e82a424b3eb6e662a2d37a4f939096272b1b4334005be243d0174cb3cc9013e482a8929a464a5e303b3c6be0ed714f46f76511d1146e3ec8cf1488cdcf5c96e68f75437551f6f1edd412142a0ffb346e0d4f8c089532b5027e0302a8a29def4a187666303c0ee9584d51beb80dd1d9e010740746e75f76435b3303bb8f6dff77a4bfb2127eb6805a42546531b15b0495bf0d8968059e0165f5e8bead649c0fa18c618b883be632bd6a6642d55c65419ddea1df2de1b70d15e3f9bcfceef007813efbb03bb1ec1a98b60636b86d1be5f76226e32e6e87663d65c407e6820fc410a88c9781f0573033b331030587a6297f69950919ad20cd02ceedd3894ea3a7f64cb973762dfd109b1e530aa0dda8bee222377659a4e58f904d5c8f13d4e9e8fc2e488ce333ebeec253e2296a48e23f21c485e14793dcd78716b515d1a88076c30b392a4066bb7af98f0ad823ab3f2625a7582e0e29591a372000e065f304517e2837f685c139a113b52f36358e50107fc300d543073a7d3b6ff4e2ad4c0e72702f5a35925d595f69c61f3b1cf504a6906e49cb3fb5b0bd3b42e0689b15258317ea0aac6820c6879e6fe78915c38c17ad0b9f48d19700511d53d44530b143bd107a63d51a23af83a2a0630bdae0027b21256916e70d0aa81b1c3493b49e91f31c542387ffcf5430696a0be2ac705b7f72c3fc6971fad19755d8732b85a737be709920ab397f4dab592fb7cc7d5e5560716ec8d2ffa862962dd644a8981ab3dcb34ef546d514aeb25007ff7817d8103d6e372a2f3fe3fc9261262eb19a9c4807e3ee1fe3b1b24277d1eb30b108ce7ce52cc583159ea45a4d87c9aad09361c8e93dea3b2e6a62a7a53dde48b2685610b79a9f51a5e528e19db1b2f22f326b3c980b13e5160a326191822f44f755adb46366e93b45fd33a94e0aca20a4b40018520ab1101bce89abb566ee8fc7f3c02a8eddf8794cbcdf4445df582e35807a33d1eb03120f6de642f99547e04b80b374d379a5b9b4d5873a12898ee283e26dc9538273ce2fa462dc6fec417711cfefb302fdf0044752fde2a9cbc646e9e0447e375d2f8d08a82b869b090e02b25e6abeacc17cddbb5ae0d10380ca75a3885818bb8d07b6fde1e35cad45653221bec07adb23b3bcaa3f7317b9d9313580b06c6acd205a72017ad6927801d1fa41d46167c25d91c8c85fa7416bff6cb6a6ae2eba8d92b580dc3058cf091db00a8c604dcf257bdfd27e16f583f3f239e286dbca12bdeb596d71d7ca6a06edd56e913ed640eca40542d56e751728adf5dbc6c8ccdab07f9b8112846989532ad3cc6bdcdb9f14040b968389339456a3afcb12c005114892c68ccaf6fad8daed57fc9c056a3c222aea9c281a15287f680fb62e70a215edf9f78be08b0cccb4ab5cdf00a7e5663712eab7b295398d643b48f444155e725487c07d851821abf60890dbe8c616ddc31b696e7f30c6ec560e7a4e9fafab9ad090e4c8658dfc4d6ae2e3a61f26844755ce5733218219c133326609605a3e1174d4a7e874787e287b65f92aca6bd4ccb77fdb286d3bb200bd8f52401da6605e2fb749314ad7879d5ec99a4988eebef9aa8d3a449732d32ced57c8ea0b8f184d13f55c304b6072f8e06fad3f8defed1c65ee3d19833f131535a390416c15d73dfb82ad3e246da5d75974030c0071aba31e9bf4cf8bcfca7b96b1a60c302131999ef2b4ddb105fa93de522854477d7507284621a23e547c04b3b9ace84ae0a529de8dd1c8aef5f6796bf2faea71d7737f5083d7952fd7ef0a22318ee091c74024c373fcb5deb30d654f994ee97eb999a82a4d629336e776f4ec00d373b26d94b58455226e9da079e642acf9d01906bfe4a5e731deb45356731593a9c08a2b8153fe7a1b27087312eb79d47bec27190feabf14c3c1fffd2a86c65f80fe3701784ef618f4bdd7d794a791079d9b62cfaca1740c23ac732e8150516ad6d9f520af28546ff2cdcbedd856966a5330fadcd2ddf755e7dcc654c680b05383779240c3a52b959033eba06eca7c3e2e92e068c0c53292516c06e8246e16836253e9d969d33db7d495c5a5d70d514c7a848d1a255f443d4a1c9941dfef2df6dd884e355863e4a34cbd13f19ec920c757f0b18d8b247e232c44409f5081e074981ae54abc7feabf68f1039aeae229ab812787fdac26b103a1e2133a15a75c103b68062eeda1ad322faebdc535450772804fbd2a4f34a82b353d0fe6de8b755186c63beb3110fc5a732747292b4703405a4808adced7adc50aa8043dd19bcd9069bc3a673dc4a27441db9d55020b2ce7c64f6dc17d80e1065f8e98359c17c872c4e9398eafb75d7ccb6f07e5230bf31bb8b38e58c65fbdbcd07c6d29e336f0ab2d9b09dfab2a13f0fd49ca4c9a8fdd411114462a7aa7b0efdd0dbfb1d81c90b082eac8aba2180f88036a8630753a975a5cdc387ff1ab706fc9316b2b5a7cfdb5b94007eb7737079e27373bdb1567006bfa3696b81a892ce78f81a910f0b8bf3a3d699a0d515ef8e4b1529754918cdf06ae9c7953ead10893c8b4c1952f31249a2c9a72db62f9857c39c2c5959211d9cb48c9107c354f564e73acb02d61c11ea4a99d47af9b80379441943df6f367819d2618b6ad15ba3125aaa4f13f90abf8d3e3f3592d61dea6624b2a0ed7a4537815ca6cc2dd16f61cd5eae74dba653838a6984cb1cbf446693c7cf2f0480419ddd2d5204850c71d4e8293bfa4cf38d2dab4a5334a21b64d7b26641cb45e6a7c17896e322633c3620d716cbf8bae39f2be17bd344ef72a17bf6fa398da7bf8e309e05df13bf34bdd3cf687f0afd5bbe17e737f9527a3f98f7684d4b4acac4dd87726d74fc5c194e13095b042a68bbb686cf63033914d354ca3887537cda9517dbf2583c0658a35d30a9d8fbcf613d2f9b350570104f7ac1bb1637e21845d8ca38562c42ae4f987605811c139034c541bf1012a18eeb8fa5df345f7a87a89f47905c71ff9ea42b974eb1081fe0646bafcb37e66b0b31a0bf577d5258b280f24eb5662dfca3242d4e8d036add0965f2526d608857dc4c48ca971b9528b11a6fee2b0851757fcb3d68229d2692e0086c4d8e3ff13b11dc2665eb4e3a06285fb8c66240a85876a3563c322787f2f39169b5fa8561314f6c2e19665dbad1d37cd1188447dd1e20b5919d2044bccb6163d65b2749e7aabea49253d482e25630ec57f9192a22becd22e7f6c2f95fe173da8e6b9233c2bc8a220e029715050df55e14d6af9ae54aa9d8af4d4ab57e4bfe14d6f6342326062ea350f92e1a93367902e7ea872d0dbb2ed2cef624d27d18ae338e06a6e1959a35ea3ec6cad5eccda09dd785035f3eb29d339b7230801880da013faf6369f435720c19b79535794ee482c51efd4d6a7fb2c5a6bfd87055a3281291b978ca9e477a573d6dbad8617b0197c974d75c3a2c8a0f6541b997fec61d1c6e95d7179ef079fc92f53bc08b1c1fcf04fd8d625bab81f1ffe3b4f5031f3b7955efcb396dae559b20d5bff768da73f0ea31a31072ed5b65bb4084bba438d15422668c1fa91affe542e02898981fafb7012ecede82efb2e976360aff819ee778b1d9447a36e8d9cba627fe83ec5223b4f9e9e2915d1bb23e3e868a1acb5b592a30fa60a8af4111e1cdf0a61705af8927c7c36b650c74b51843c3fc42a592d7c4f21f9f66c0faf159cb976f9b77c95a5ce0da577fcbb6b352ae86c866b312c0726b687d4bc8e6b29d53842c788361d71b1b2d38671470160d43ccf944fea13293ae210c71e3c34b8f3b234a2aa8a72139050781a5adc6877d6f5dca8874528a8bdba487b07065deabdab908965cb1deb8f22ee417183d85946d5117518d1367cb53d68be5ea5ef16cd15352fd522254357fcce468348b0353bea0fe856cb06dfbabcf18e3f8838a70ade6038cff7a602cdc9fd26bf6ef0645b050e83fccd71ee1b44c883b73cd34f42bce014968b020b2af3680f7450c7c339fbeb29165e592176f1be631a41bbfbac0e0363f28a793cc8ccbaba0c0b4060f9a4ea199a068748e3882845f92e791101ce99f1e54f027fb4be7faa29b1588656093964cc426bbf77afe7af7d8f8aca4d04c0b759b07458ce300b9325c89acadd80f4eb11ce10ff7202e327524c3d73d8cfe1643a3467b5c3b97a026c1e4f76142848b6422e2de684a1dc7a96c66b9f3426293922a8420d9d4c834cea962140ad5556ae1c8a0f8c9b0af4c3fe2b85cdcb821f2047ee0a1a54f8084e0b242ed0d2d04e98394e8acbfb100dc18426fc9e7ff8d38dfcd80525091d04742bc847e0dd76e5f912bff446cb0184b18faf4c0f5c128deadecdbd4461bdc1d1b6e316b34f35a0d7ed32db043bb0e1ec07269d7a9ee9928fc249a3ebac5d170f141a55ab4b47b5282cbb02a164877727b7b56ed0a1762478ad0e6114ef0bf0652105afa3f131267e617fb121c02e30ef99a8d105316eda90fb405ee9268dd4373f2cc9871989bea1d751f5c1244c7e72340a6ad404a8fd56d14da0612ca9acf3c745db718dff07a3f2363abfb01cc6d8d07cf09faa0c199cf3f9123a5cc9a0169f8477dbd63dd621fb7c8b32039328fa11bf2a10fcb5cbc4aa951c43896332f34400b2d45e48098420eab0cf6164167c23233e9fc3c3c3f2d59154e07c45a7a1ac5922f4a9c9255e82009418f824b52e344305c9f16d333c4761f2d50855ac083d4855c60821f4442494f099773610022b20477080a899371ce18ce39ac8aa0eedfb8f46a9adca4d2d4331a5fe229f5fc0ac7d2ebaafa8cb2456a16fdd4fd45b223d0b7dc838708f510b7547945e7a64e2ca6567d1052804f74312a9db898a9276f9af3c325dc4af8bd9edebaf3b91738c7ab83e4853f9422f67383f8a3c4206b372ee02ac673e2659a634fc80c8cb1f659fe1a29d409ff4cb3979398cebbbc538ff3a30fb02aef53a4bd46f1236a5d99a87ae4b2b1af9cdaf175e37fc05374f3a5d0659287920b40ca4a96f93faf8adf1544f7eaf280047dbe6f95bb890f186078115081f4eee9ed7516c2563085335387eca2220ddf28fe34e089782f0cb1ab66c850cb6830c8de02e21f5acef0c4d7a82c6c17b7a1bcbd22a3e46608af508d724a1739063aa3451236d3b0e70ad24a8adedf006823e5de6601a2e89a900907e6080d68378f057240693458dedb2b8281d8df73a4feb2a1faf72b069134aadc95fe311b668a0471a1e147b097d82984e745b4a1ab7b8d4dec6c0507bff429b393c70dc8df2b0d8ab9443706c12b8c6251e3c81df20ec57b09bfb9d62718e85d5c7fa43fad9e91508aad1e80d153048fc09dd86503dda8ba676e01f8d9e05b779b2602b22f987ca9fb45e23a5c8787039f7d8a7f71b97e7419bf18d88e9b63266ef2f3349b5542723b367c5ece3deffa4a4b583d119f24fa9a7c17d4ac394b3be084398f47fd7d431a2cf61d8474dad47715c76cf24f42dd6e81260f5ecd600259b5c1c8411f0405579b6e640ac6f00e681cb9baea0f6ccd4e5af291eadb757283e1925cc9a96bc5206b95c181c305861de1437326aadd857b8edc3e3aadb4fd6f78634794446149d0e7044b7b502f90778f2d7c163f4c799d9432026348e0bf10e19db51bfd394723317567f70d5bcf8a4afef73b7f6e6658ec3d0c59a09df3d8caefcf6f67ba1725a75e4b9e4acd53c00bbc75159ff41d0cff5a35993fc71a5bfeebb1f0b856c41d02ac9cf3c52ed10663e532a3522ef589f43124dfb25dd941eb66ef52691fe37d751a0c75e60dcac5355e9e57bafb221f9c417c7fe5b22ea4e524e60e4ffde1e862605adf37fcb457b05dc422c718b8c6bd97b3884888cfbe1425e8cae6e990568ccababcbdaa290d2406092ff26df66c95838f396d90d53d0cb3d70dc32b4ec464b3c74727a52cd2170dd97bccc562fc3267440cd5f24ba4467f60b9d5e0771e55237950df78843b615804e55aca009b0da622d32968e861c771f42b2b4c2846b88501cab25e4c91bbc188c190594cc46c768cc605cb1286686aa6ec3b205558b94d4e0a9870fba56b48db323c70e0308f9554641e0416295fcf789b2dcfba29578235975da544ee93d5101d7c681b2a9b5e559806aba28d39de357a36fdecda6677ccf5a901d6f701bf3b5e53d071cd7d7f8f25308bf4dbb97fa27d6cb3dcaf6baf8645be6c58cc4098b74486ec3d11ab5413b00eeb4cfb26b822b3e90a175b9818f9109c1f46267efa9ad039b752928234c69b62ca4fca2d76cc53e19e398d538bb38af465defcf15e66db91357af322cba882c2d503e8d4d93268e7e34928f79c375fd58c78c4f19c2481b3c5b5faaf45c49eca6e456b6b795626a3c82881bf21083fdb54ace2d323a14cd41e352b40b4a2139e440b4ca7c71d9662ea2ed6c1e255d9e237de87815a3125e07874fe83584187c0f40e329efe3c9887a56fdfe15773146b4c48821fdb02cefd85a47461fb5494d1e9f7b2b6325d4be575394767248f6bd99686e07f2f0d315658fd929a79c58cb313bcfa5900e1158bf3aceda712d00aa0c4435871dd44f4b93dd6f96495be519a1c73a5c03c0f569633cad2aed673c770c3378ef45fc114980f6d3aeb7422de9c2cfef42b55081b3e5199d93add5274059bb9b105807116ad0aca53ca1c02f78c68d8a309a970c4c2775a0e15628248e04fd275be96a43cf48b931c2a6468ed15424c8461281b4e69d2fa1afa7e7178927abbc7cd1a93693b97b606c5027f26373fa4f98911854ab170f9013acbafb5e752326bd481cf672e4b269104cc037cdc7b669855b63c3bcd50a72a9a9d2681fddb3d7b33b9ad3d4909f0196bb20c90e93fc00b4077c06861ec7ccdac72ed1b7a9a434f6941691c1551e61bdd981a9fedd3feab5561be3a5887641528b8b4452600ff6ec422438df5fb6f1eaa9199552799fead5818992232528dddb329023494b1b649011e6b647d51379abf30db3e6c73da77e973f7b452d27ef0af03076c4a48a73d1a96e360c9c47035ebbe6b3e1eca7e88449684ecc76e8cb13d76c7855bd6701f84310692a0c37f6a1cbebc894bb3b91d1c077cad2757269d30d208f8d26a274c1ead1b3105142707a538ab256a5b9cfe591797d712965b630b4334eba3d289d020958028c8d48c859889f82966c71f413aa80c567c0c64af6c80927aebc31986d1ff83165fd6a3b6c828a3818df515b592d92fae79df55d21a639b5fbccc65ccaf02f587eec11869f9a38e1ef54db9ac6be0269ba1d06d16515bd08a655a23d7f54858bd709f9652afff91ac6e5e709b5d4050eaf2333c6111764b072fde881a4139a2dbf876512f558c11cac81b693fa863e78c482b3962160b5b2c2a2c54d4479f66543d422b742ee4432a3d479aac2a6227e24a62de1ad8d4e9b41ec88e6122dfc1484a383a6bfe37ec4e42e4ff18e146c71b91205b7020d5369725455d20064207d4e5ff351edc91be1f8e66e08109682360e9c4ea5a5c08b0ef83f97600c0bd6dfcaedade79ffe6b00f2a6d74ac599021a0596fb2acada18753e4cad6c229313a39bfdadeca656cf65fd7055b73a49dfe7631df07292e9af68586f3404dadd0da9db21200f3fd0886e95afc4655ce55730f6be48c39b12cbcebf2d9b0f4b21c2dbb841f008e412189778f81c8a7fbd7e81f620780cdc3e30a29d02d02ab0941a5e271606577b66e2bd8fb430ee53a44c47587d0a77651da3afe262907695e26f57f6067b00a7749b16382a406cef04b9d61f94ffcd143ab01b66474c3ad1aa23585704243781df77fbaa47967e075771d0de6a78dc87a15d7ea3c36a6b7f5d1fa980bad47e9c38fa9ee5393578e62dc9b8d81fc5350d9743f22983a9844a06b6a3d55e6656c81af35feaf531ecc359bca9586e57624c82037917198ddd96d545e1295bb9763c4b47d48540849ef99191734dab6e732d01208e5b3b5090735465e9f3d2a2c8f0c303852db8fd0798db810516058834fb5838704f95c8fe347896a19d2a334ab9f0288210ed04e11baa964cdb3c69c0c9fd02af6b0493571d873e57a38e337d7c649449f0fa797ab6819d9bfeba4d2313050ae21ae05fab7f425a62eb5d9d615a728f91ec0d65e016c21beb4f02f35b14cef71cebfee4704398bac51e216b3b122eca9b93184e6b979e53e5de2113df5fa878807d0ce007263ce044a16fa41b5a4bc28e01dcd4e88694a1219d9a4c8bd5b1a758bf5093c110a4f694abaf81a136429f1b29964b800a26e1a305f1d9ecf5b80b8556bbc678e76cdaf71304b5d5e832132a904523a6927328b04734b491cbb5ce3013928c4d4566778cc5ee83f113e09384fe347f4f113598ab1d106dea93a0b37a38a6b6a01ab7cab9ad429d0377613662d55c9d31cce35f68fecd8df58b32680284d1173d69ed2eb3d056373002f0c01cc248911b57a9fad17d44b2dee1ecdba76fe36a2b1672472150e159ab989bcdd3730c9c66375f58f657b3f5e426d6932fe524d1295a023474ccdac75064823dabf383f18fd3104915e03f49c896a907f5f44cef8c1a3e0749a0a0ad6a1dfb87815399b65a6ba9497ebe6600ba16b5310151f528be1e18b2800978cd7f2e3deca7aaf27996f07de012f028e0000c2e0275869a82b75d09be4d9177c4c5e7d8f370daf813cc07e566fd267cc6c3e9b0aaaef670c4a0e564bf9d3fcf321d02bf999368a31ffe9db0b1ba520bde7eb2a3c8a31012226efd9c1763aad3f544a40744123f22a52e69874202ece0cb62605f5042cf4115a851f013d06fb0bb4d136fae248a2ed6516d1fd0e1a36b0f1743eca30e3416cc48218777edde66e7368b96cdabea7ea9667c61b7181e4bb7564811dec3f43afd20fbee94a9c814fbbbabc839c7f84621eb989a96c29fda99adfae1086ec1c6a1c44ec8c56e6b1ac611aafc1c771427e359a83921efb09eb4c15ca60db611f3600c92cad4788779ca0d003f0fbbabac15b91f535895e3fd7a72d37126b9e34491b9da4cb21f05ade8e74297b5192b32abc29b2dbedcb8c405bb6efaf079f59c65725747e501ea6fdfa939e789e345a0c11758bbbcede31c49a8bc109e1233fc9abb13ed39086f7eaec5d881a60e41f911f20bda7e8f4c5cedc6aecb3200c19a6b5b4c652978994387151545cc903648e7a18e805d975f9d92a9ff9914e44f732b58b31d937405c07955efabb35fa3554a290095cc53849729e96ee2ee1ffd810fa2b3ade377020363352cadfa0cbfc78a291a44755e29d90da79cf9b15ab3e3d0285c81dbb1c188029ffecc2f297c643bac607b96370f3cf34d267b80c20fd2335ed80b1253139d6252eee06db8f787b75b8011080806e940a554e6be703da199d6e9d251c584cafcaf4579c14d65dec6babf029ff3c37ff87bd70b35be347a2e50a8006a46d6d5b5eabcd733a292df57e4eff8df92693d67a0b98730a11959e0eda6cd407f98c6f957a12e3bd0b4694dfecb7b77e669d4fb7e47f3b4767cef798fc92d5cc4774b3445e2e2b3c21f93ed6eb53389f086944e3a6f2ee0d69e4cf011c65450eb9d4eaeefaeab125d122dde0378aabc8af6c029c40d831952f3d27cb3d0e0a0f4c084cf2969316a37f64d6c7f5bc76baab554d884f1cc789eacebaedd3f7e3a3a7d531e512cf68824624c751ab0a08b796575eb4d1ab7a9bb86e7fb7178fac3c68d25f35acf6182f9f4adf5737e2f30e2f3da7683d4ba5ad0229996d8f42dfa1923900ecfa2ec7eb4e9c0e6119266c7c321ab5aa11cabd858ac85493f0a7c413f105369ed299327993ac037b810b64b9040dab166d03dc4d0c8a8096a7ba622baa68a6af09a0cfdf15e425e7a9de258804393db2b8a2c92c32a39152c2ea6df5bde963b5d1911dcb55a0f31dbf8fbb0daa4137b4d7ccbbdf9120b76c83476a4ecf2901a2ad551d68a6f3772551133ef59a74f7d2b9d1970ec19c25abfdd6c2c28d6188081a75d3cc5f28f3e50a23099d7e432b4bac7f68b57da7910e6ddc9baf7d3713640fd4053814c9f85b35aae36556a51f442a81aa64f61591314b57d8fb345840590fbe12352b8ddac80fdcb122403d89cb905181a00be27cf89eaf0e10fa5691ce74fbc5215367b608aa49fa895876e52995e870ab4f52b048d6f954de6fa896112344802f845b966a69207cf86259b7ee03a894780c8d7aea61037a31410416616fe0fefe5aee90a0d78be41a71e043ededc28e58bfe09ad319177c91fe1b1516ecf8ca0ba2997dc50ee682a180b661c40c5e303960d2ca0f35eb88c56c9e3be7ca81bfb122b536182d0659bd2600ebdbf48c261eb98f264bfedb8c0c40032f8304b3cdf78fc3aceeb722974aff52332c0c90617535837ddbb48693353f054aced36b1435e3b6afeca578966c48c2cfbab102c32b3a76d74f0206a2438b9d697b58f21165a57edb2ee52ef1e4852096f2db5b8f2b9241cb75f4fc0d56371906b750f97e0f8873362ec8f48aabb4cabcdc34559755713d3e1ec7ae6e3a589570c82636227767e88cb9ede8ff22724b378728fb2117a779d65148ba0fbabf0daf4e71faa1f8d7d54dbbd9a01c12e49f1faa3eb1276bf2384d55b919ec3d2f6354ebbea2122fc96015fd5b811028e73200b1a577f82bc4fea20e9510ebe2bbb22695e04a039aa627e2f45c97da42754254f446493d2b8976759da73feec210ffbf3c921896259aad5d9446bde107326c4ab6787adfcfc556717abc84b5b0e3eb468dcbff0222f5a13429a44cb85291452887c4b54a0dac48deac72d08b955177187152dd836197607dafff998bd44b2698d62787c57ce492886e879297bab03c5f52f7e8aa98e35196b9c9262de7358459ba8ce2657c0e48bda4097c65ccb33dbd28d5bc2878a8b7ceada04aae643234db6d11e8f2dd5f579922a202879c789eefd94442a2bbe4d6fefb961bcedc423a3cc4cb3ad969aebadc49a2caa5de026974cc7dbade499fc7172e68507c3990275c44b5dcde5602975c05ac12f0982e3e3b060b65f2540c271893a144f797cf0d6dde636c10d02e94e2810edf625ae7b2303f14c2355de7ef74918ba908507fc1e8087b2d8795c77a260ac676051076c9de4ffc468654c93df0ac3468931b0387924332a8672d92147b24c1dbea3e7fcd4b970b92457e6195ff95a98ca27739b897cf419f02ffcadf9e8ab4449b5ca574f6769d7d63a6a25f7c3dbb9a4949c1ca95f453d22c3de70554ed0d44c65fda3781a12c1a744d8c4e59d44f2439669817e4615ee8fab2be231e7724bb641cc3a182cc853e7d532e5d4028409903590106a6bb593c0949226996b1f60e018ce1cf1cbeb0b6b077000bcedc56bad4fe4768169f2d65e3a794ee891043fac4f8e917d8b75b8ad9103a10ab6e273b8bea20955c83b92af1b9d203366a8cc5c956c6f0d9edf7ff42d7c6e59ccfac54f922034e68fd9185dc1ee7ced8ee8419478c4b8b4ab8cc46b1a932136eb5e0d58aefd38b39f8d1e77258ccec7df","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
