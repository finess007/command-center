<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a2f2086847e1fb3431ce4f841e34fdd970cfc45e5245c242cb6745a18ee2b7b84424186e275458fb6863c65f36f10416604d0f165eb293fb9a4f922584fd44c0d480167b8bcbdfd3fd6a9ab74824e4eb86dd07a74ee557aa8fb964b004af0fe1cee0549b9a869d1a970536f3788c65145322ec8c0e458280a3a3ad2f97a7e844e28f157d434bdc7e48310321b54b1a5bc1ea34c168153dba0f1d3c822d8b3b3c75441aecea0a7456d622453380c386ac25ad695835fa9eca1d53df5fcb6eb4880b820cae1ab877276ffb7e2103ed5f246c3c83eac0008a16c53f81e7376ad41d709df8d1e6a934700baf0ccedc190b03387af376c39b6f6e1854a34533f2b7d670955b93713d057d7b05f18d88264c5c9d4e0b587a03b05cd38df38f0ed047f553dbbcb9ec261c5dd5af9f7832d0e6b65b5cf541269d164065dc76c0ed01d6ede9b4c1c0d684eab88f93fd33795f4c577f2150a5cc43f2f950172eba53524137929bcbb48481f3870fd87d8f318551599a674af1ef00e84ddda9af3a9caf6c535ed7e6a182264c36abb88df2205acd01c2c7b5da4f1ec09bbc905263e2b1f9e73deb8aa4ca4b3b640d8939aa0993d82c170a05846b115e3a86951f9a96b3f6b19b571464d3774f81942e0b05a6a8caf9c147c9bde5c066316c9d6ee4b3075ad4bb848f0648bd09b7c40fc23b603218f8acc0cca5b09369b431156891770f741627065173690f801204b40ef96d50b91d186a1e613311e9dfa5fcf607e8b81675bc9502c8b0c2545ea45fd635b446e09263ba82e5b920c71757ade1bd5bc4680e4057caf2ecafe8cd5c7678eb4dc6d796d375b9497f3e69c27800e8777838ff3d660a172ab935f6499ae8176b4f253dfb7eaf7188af4ad870ef854ea0d2edd045a71be655c8552599c38bee93e19afea69ad776b0c1167a1490522ec41a63e578e21f02832aba8e731915da15a319f229a39ba8a794156e5659843d3a48b670985d6cdc22940382b44968297379711dc1173466bfda5798b5e37b024c3d74b96314b2d1bb930846c2b1dce35d3a5e741a713384fb408662f08474aeef84127865b80216fd36381e5145cf411c7bfdb122677cde36d307e2f5a4bc11d134a28076d5b27b0d3648cca551d701ccd6c427169e79d22f7ab00d51f3854d8648df5635c01577e13efe335b744ef01c5f29d770d3d1541d6f7f87c42dd399c3d1a341a503e94962226fcbc4d31e7a7ba7f9fd9ecbd3b0c8e3e337432aea429b645b3d5a41e1e27694fb0f0fe98750236d75dcf1aa50825842a2fb685a6c85a55352ce535e4e4119dff8ba9bf57dce714814fff293c1362cee55c115bfc261c128edf3c88de201af65a115e50f41416dd4542896ff2a28fded011bef7a7d661f8453e7338e60c7b8ebf35aa9e03479b856b27dc0cafb25653ed0aec6b1ca74266aca7b48a8650f2211b573ed014deac30229e8b98a9c285a0957cdca834e06d7972926d0efe64ef43cf78dce2b578abdbea11dbd0be0edc4b563556fe20aee633d18ad8febc46c9992ad9fc6870a212adc9227dffec0ec0ef5c81cfc917edd808ebdfc3315b7f7b6d77f41dee5ec8e29e6e90293c9a502e3910b386257e957e6cca765bd3edfbb5b10d3d3bec2e22e5e677c6885b3117ebf48ea8ecc26231540cc9fb50bb24673a0a9b9a380fad21c29f506895733e8731ea9329c5a4bafa5ad5b16ca678e281ff1756d2c6dc321bb862ccb709b52eb4a74d363d54fb0179433336396813944c714982741428f14873a06e7ea5aa5eafaaf6c1f43ccfd133c9a374700eba40007b7082f2794abd2fc3317678ba9ab0c032d231d1cd4a1c92004cb0a85a5b9712695b6c9201ef5bad9d3f7a79adf390a59edb41044772f6b57ca0f35b984e85586a5e6a578db3305923a2ba342aebc63025d7c7dd13dcce019d156103f83eaa999cb735aa32da6389df04c62fc30e59cc9e803b9338b8d9c8a3169e05da5775d43cba4bac79384548ae247a9e1af92bd661397a35afa50c4cee43836803cba66c592a52ce19cafcf29f8bc46d8a1d7fa8115ea904df85117ad004ed951d7e4383dc5bf5a905b4b35c8611e183c319e0455ea42e0384d78ea50f4795807d9ab4137cc7a279bfa94564398ee98c5f209a62cfe44f3712c111b85af631034f5b0ce0307f89aaa029d90b37fdbcd33896107a3189fc387a75a7280b03d0459f425a6acbae1388aebab58345cb63f359d67e56dc067e9cccb3644b92d37e40924d933ce2306a97e72a2985df74b4a6705ff04afe124a5c6b2725a1a62fc00dae112de36585fbfb6dd1d2b88cef6e94b50a1f0276f3e71d560128a7c62933281a3b7c0385c3193c7afd5c6fe51d9d4ada8f8606d27181ee63ccffacaf631e5b02b2cfd8141f95e72be1c2374b904a264f9407d6e221a9e80d3df111bd7a106242cacbf39646ce33b4f7ee092999cd508904becc8b93c6373558e0b46415a9e001d5f8a770091970bd1056f568ffb118972d543525abbfe63922064229fb628197cb0a74bd581e6d0c948ec78ce3136a144d72bb645bf5b18b74cf48755435c50d7881cee19bd0aea15ef56f32893b9185a1c8ff31b6639590618e03ff0eb00e8ccfafd457f327d75bcb1eec93c5660846c616de5758aeeafbec47258eb91b20ccf46ff3d142201105fcbba73e9e72c8da548e7b752b5e8d0d3e1f29d9f5a50dd5f6573052233c58fc077d7ed3634d7c3b455467a5b0f6234e6dea7cc9a7add312467fadbda7954c420077a602f619a758f5f16fb0274875f4eea8c4179e72a8658d02e6051cb8a54d74a433ee64eb89b6af0bc98703b09748068325adabd16c42b9fa5515cbfdb83ec7db9c54a7949c0e9ddef2e4e7cae41859aa81b18370fae6cdc975b41cbb2a6d92dfdb79aa45e80fd5c0e4b18c4c90ca099ad33fe9b0b7e4d0890bd1e48020ed88819687f5ef3ac7cc1e8b1394b42913400d50beb741d82118b6e3acaacc19a6b880991f53b1cb560cbcf360c042cec9f39e2e0b742f32b2b8790b94b74cf2c60a5f5e49c73cc237b0ad0d64c9d2dee01eb7986930bb1d97de7d6e5b8f60b6b170f91618781dacab26c4ea0af03e75d00439c62906be22ea824df47fd1ce8948405b5b9711ed5f0e643a9643c24f2dde6acd665e53dd424a65115ed4dcb92f53a958bc7947d07673a76e97e9d7fbd1795882a357c2d5d5e5b112f245a8aa9602a5d824bbcee7f9b22d522b921cd93e4fb552d5919880d7b38e744a64b8d1eef0dcb98726b474cb371a99a4aeb9438d28284565f443a6dfd05de63bf06cde5d77b6a31efac22d59af017eaf1900ba10b009d9903b411b356d225d57a2149522eafd6f0c00e3f5ce8fe1189f9d8c70a9357456d87edf8c760b7506baffe6cd4d9e8bb19346f442320e369d5bc5a57342bbc1c5643438fb4017dbb1f99748e3f5121b2da1da1125402843ede89df376ab328b47427663fcd4bcec283b6df63f61e62e2e272bb74a29d78b02db95c527c77ab7b32d7739a7365e48351999b630709a34e5019dbb73e2d95191adcb7e3c15300a5fcc5bc877f3bfdaefec8c1d6370eb5e5ddabe46fa1008a73a3c78eb803afb13a58d266a59e88d1821fb0b263abc65c1aed6f115e3a03e83f332917cdaae3b69ecd3ba3acdd5f9fb53ec1dd5262d1cfc7273e67e120913d4bc997c4f489d4cce0d20ad7c627a63fb943ae6f2c58d04e23e5c1b8c05e7729a4408abe5061c40fe2069a6dd8c631564e2c2672bf51cede94dba2cf9802bf51a791cfe7d201090e8dcc7e84dabe825840379b0e8a4d14494128d2dbc9563f378146792ae78f8097538d6c37d32ea17420379459264526cfc579a3a37f3cf5512bf4ddf9f5f1b3fc4395ff53be5f466d32bf7605f87ec80a7d29847270873e855d36cec293a635da007f81e3d502cc0185de002bb893e276ac8bab4e638efadfdbfd0ca5e8a942bc3bb6c82e5c1675b95eca367deb99ac7dc1df7609fb9a7453fe7242cbe776e61d0b1cd79ee456301b485d63794a3a0740c8595697261888ea10e3df9bc024523ddb06c380504e536ae59483b0e98b06dd54093fc152ae44f508763cfe1aec24262caf1d6087d86885d0d7f26fe50fa0beac1a50930c401e028eb4f2588ea7a5662e42dea1da4b40c4c375937bc47f2f5d456adf9dd1f21983d36a1838448de567156ae23b6dafa6d5cedbe8f2bc343614781d95e66a1cebb30ed1e15caa1c69448460cab0167a73d0aa74b18967c78701433dc7509f2103fda68991d1387b7dc50ba9781ea70c8d7eb51c130bc32ce04e6dbf98929cbc789e94878087ba7495e80aca73c6b4db17c8d360e91f3ce69ed808464fd6a4d31b471eecc9a140033dfb8899e88fad5250cb977feab7496ed5300da089bf4dd3ae24ff44443c3e07d27519e4890a11f02a78f9dd7e28004121439be8e77c457236f3612c878270dbff7524b629136cba7bd27b5e9fb6ed2ee2faf70a409f2d493f411e26dc4132c144dbd4f1bc886cfe82fbc44e279056f96e7edd934fbf5a45c8549a422e3a5362662fa9903ae72ac36abb0c5ec0abf5ab7e292ecfccdccbfd22b4a0909b290ebc26de17736e315e1b3575f35a357b7127ef992dea4920bed5e42354b327af5c2ac5d3481a0e19e28dc77b0e7b1ed5699a31fd08ef1b74d499efccffcdfd698c3b8a71a41580b1e77f82ea1b0dc034b9d9454b2c4c4ea0e6110259dc69c8a9421db49ae2f3666374cae23f928c740e2c815836a6b1dfebb8ab02f2c6ad7d6e7621f877ce067bdc2d219d15f7c0523df96340accb14d4dfbe252683b793fc8d819bb149d733594ce45a4489c92e74f0c096a573c9878acfb69d92968bad9c2eba5c3965b3c11ce66939d0bc091d6aa9b796cec6e66dd1d14505b7fe407b8e30fbab947f2dd17ce21123e63389e74efc8ccefe8f528d2ab04358c14db5f5a06c876583a598803c4086608290d045ffc03205cee7a5fd1615f1ef4c7761a9c8359f20392c2e980dbed2df5111ffabcbffaa2313aebb9ec5761ab7b3084b9f2a340b9ff0039ca779fd8e45bcd149edab5ed17eded596622499c23acf96b877f9d9f17d0b8ad79d1011189e1c4546068ab7c1edc6ae067185c981470e92e06efc4f0c485334cbcd34268bbd4e54ef61e774c5171cbaad98966c5ee360d9cf6424ef32b7783e691b1a8f9079cc0c3c30e467eb076e9143c1b2ae74e82d5f0a7dfe638603424b85489bf2a29b71eaba3c73bdaddf1a383ff23575c70093e0a97e39d99b6edee2f95581df95967ec4259dbbbe5abf4ff1e3fe32b1506d59b53305c4bbcae5a42e343b445a4e375ce0094def6491fe6aa4f0b9cea9ac4e3716652d7a2efc93fc0d28da85a53d03999100371e770ab2cf4930433534e9cf6491d9ef8176a3d5c0b5438df15651f8f13d91d11bfdfcade5321b5a487bafa74a1add28f486b2142c8bf7ef131d3ddf101900cc1cf6ce56813c313e735b9870e310d28f432f1265195f2de5fede28da94e35358a10ee8e9880e860647da322f46a170e7474b09a142671c1308fd47ef726b1175bbcca0d31bcae0ebefb99bb5c15d870d9871bca5648ce7602d659745517ff0d26e224ea68128ec95c824ccdaa0b76c0f7541513bd8e31bb54b128cff1454eff65c940fbb56b55fa138a5f9220045b7e3c80491cf65bdb69ca750d54e2db06148bb94a3b76f532ddc43f357ecb1414b5fd29655ec9d4b95182cfc5fccd1df81b837e4dfcc949e50e89d05f1ce7c9da1d0636a5a5f200490dc991e3949d525ed5258f9ff15d9809edeb3c68761367039d7b3d65be503d38532015f00603daef467d0ffd1f521a1912437b8ee41e1b65b3940b9762bf4ecc19d95e01845be0ec1f03bcb11c1bf9e72d405c5a2aadb0f1733f5088bd718abae60627b6e9b5835c268d62f9ea7f31cfb69103de2c7f712d9af1cf0589e0565e812f7d85a46e7456cba4a9d28b0239bd2f762a856cce95286275e6dddac5e6d77ee9cf7cfebcb889c4da5bc1d4649a1cbd15ed60ef30168ed09683f7bf86d3756181d1b5afc3db50a3c4af2521effb387e5c782c6cbb1973127844aa7c574e1c58b7f968b43272042f093029f7ee6168680a1053dbf538d819e994082d42eef3e2e3b464d2e9fbae9effb48b8b63c25de9583760d5c21b7f5ccf6f9667373eb5b1c6f9ff90e4c17fdac1e689f61f33effc9387d80b942946e978cd4f5e24165f1516a154d7e8f81d52f492b61139a1483e67797a117c3d25b70c44539f6424f590818b5103a7d2fb466787eb691e16381a8284b4ab640f4c089c0964ee2a5ae94500c5406a5e0193efa2495e7dfc64f78623bf16496a14393795ab5d22dcc71970519c304013bdf9f0bb8a59e3181ba4b6aa8e9c96fb63e6e31c758a44971102640d8ffa4732677080798d5f668ff2e9ce99b3d0fc0157e833fc3a6624776f7f55d95ab10150026ed2ff7a9a7601d356948771e35860a63c5151f370d8c3a8e06fda6501586e4340f97eabd8c6621c17d1796b1807d824d666750753151826ab83d650bdbcb3bf22bf116688685aba06a6af57991c3d843e29b9fbca7bc3184fd49c5f21d24a44f83aad26ad2f196b2a7938c09579352c6b2d6797fab9c167ad212c7baecee462406114424ff92afeecc0356a7a2e08156b039cb4dcfb7baebdae01a7ffddd4f7382610e3b11a9cc09198ae2acc1ccfb61042c9d35cd9d483e20db483e2ac83fa6aa6d14bc987bd7746da305938219e904845afa1296c5595e0354d4b5d91bab3409e76acf803914f0a08c145ac2e8884d526328256d476dcc810abc2320a793df6b6899d51c732a8e17f0997d2dad382507f08752da8deb39cfb6061c9b7240fe91ce9b2aee3380129eb2b7cc989409ecaa1b272dbe47280a07db54e26b831eaf452beb0094fa74b611125a47c73a2918cee0c4a40e54fb105a60e6d398d273c50c1d2425b79953c178cd761e4b0a1e3dc7df358d3c61e19ec0e3218e52f202dfc2a5d2fe2c13f5239d5106e36880c833fc11a9759c1f336777f1e86dc80f4b3a263b445dd586c94b29cdf3ee54a29f7488b19beb409e62c283478856af5d6e47291db4ce703ebf4162e8db3345ac180048d532c484180494cbfc7ef9c727ed1a3ad923ed56fd7bec313818bf4213d374b1d64f1a14d21f55ae92c104f53e6aa9d5dddf1d40febcf67147077cac5ad4a5e6a614c3e58b8a44c1fb4059a0107b5852cd8e1ebc8e7e7e6465549c478eacf14b3850dbd7a8c10ab26afba1754ff55dbe4f3b57448c87e1d0fcfedfcc4b5d2d7556ac5398b22c2b4514b5d5ce8f2511bf21cf9620b3389a32d920dc09ede3dcaccc813300d781bcaba567c8ecee82efb611f4ddb2c979cab867bdd08dbd62975a1b40ca7359db7faca0906db58ee6f4b41b5cdd332aea34e6e6a82b317cde4a9132dda67571b133f0a139223277f9a4048af1a3f89e7621f4f111d6ce5e17eb7cfd655c06a1f27cf6cd5f051d8b67aae4f4a24f9110ec5d62f44def4f98384a9d6fb47af73e4ab19bb94c5f41cca182abd17aa9367b6696b74a8ef123627f08c0c67fcaedf9b359ec4128a48109d43539a19de571fbc4e8865ca1d354dce83faa3027495f0b515f0580a24fe322f89bf11189725968418d951af468567aabe32473af8276e1f2add3c47ad8af2f30643a042fd26eb8498eb144547e40ed34a7053678388e8d9dca02b2c5c6d91e41b88c1e96d29e6d2451227f61b1f87de2f748f44a521cdbd4a96afb743914e392a9473541ddd4b5949ab6df08f5c4693a25efb56f223dccfa266f9181776af6f85ef904747a276658f3b72e4560284bb65ea273b0e77385e10e99b67c08e74aeb8473e9365c2bff5b75d262c0da2f9534b9c075c50f035fec302b4b764f9cd15619fd07b93e048f4b01428e43fc8c91bb6d6bbb7a98ea4d6c237472a46e1b44f079b331acf7a9bcafa02a36cdf4c18e507e1154bc379e8982bd5bde61c43687580fe8ac62c26748c84145b400ca7d00399829698eb76d18189ac09844dbfc5a6e74ca6a5e3aa223d868a779598eee291a113775ea15fca907f76f8e11d3eaef7b6ce5883cafe729c769874d1d68f32ef710c1e9b93ec48cddc895aca4dc6c495c709963d13b2a87e696d918e015f9fb31cd35a91211858056acef6955a45fb7d4cdff868bc5de6b5e104f98bbc983e6bb73b3e4665ec7716b1dcef2fa03142427c4aaf17a5824b48bf572633807979a26407ea8ffdcce7ecc54aa27f79f04878c451ce9759e84e70ccfb4ae715847564b4336eb7579e71bd4880e9bdfe7b3de283aa314deac2ed4552a25085cc574ee7c91d2492497515ea28958e866b2f39076a6696bdbc28a55e6706420d4da8766b5bdacb283a2be1200a45351b1f24a3729b479ff26487ef22d4e3a6a2e3573a772d13019a59e8a7524c799621bdc9ec0a3f8df1da13d31c4b659b8779220e08ac9b33ba8859ccd76903704ca21e018e72a14cccfab8b8ce125fe7e997b3f04cec57b83697b7154469ec96883e3b481a50786b977a47ea6cf3025d347d275d6401d8faaaa33dfb98d8268a19418062404cd058ea60f09ab8dc3230847680c6fc64e6841583ff6e9bdba0bcf34e605414a524ee01979911856751fef35f002e0e50040c05c9df4ba370a53965180c6afabf3ee685ef80120f1d1adeb7d710898d6e033d2da18c08ff9432a1d9292925b85ba2e33980ad91526b0832831482ad9b1cb8df231104fbe536c00f41fc5907235bd99f155acf7b5e1a9d81167e43f74c83e2fedb95645e1fe7c0d600ff21d922410e17f36693b167ff386bdd2679a1d764553cd141bfffc04f0f02cb18035a5036f27bb75d402287046c4afdbe72d2b2347b8bd79b40986a0a8e67ce80c240d35bca95b55afe4c89f022152a51b1b379b78225cb21e2fc9577163eb748b2cf1e111f84ec74f0f5c54495485dd81cfb0d68f4c4b1510a3036cb6ee9e9b5a8f937335321c3168ebcc796270ae7ef7f826b38132565a42472e2e1b5756f41d027617abe81d5f3fdd1a3c5de081e0e82e4ff19df1966cd6d07de3eb3cb8d811f21d454a0387c1f52245864dde597756126234b622c157e0f4d2bf5c3f84a769ad6ca1b0a51db912ec496729d25046e461188e38a64f23989d6a656fd703e887cab46a51dbff04a51da3b9790cf1808c111152c66e1f620bfe09134e852ca6903329fc42c7eec1cf6c39430442da85e16ea1e39fe0cd033efeea86bbb0a5fc9b28513947ab0cb7e097a90f31cfd8826902b6bb92d6e912a9650736c241c2a0cb3d0405dbcbe9aa8a1a5dfce83e3f67fad4a4389ae190ecf68ccbaac9935661ae9380c409f2c0f8fba58c5279789de22441e73c129cb8246d83f8051242e62f244ae52e32deeb5efeac3c75e976d8c3951f259c00d724e19fc3e318748c876ffa523e24c53bba529400ac2d62e6c04ad64b475cc846f96c51636bacdb764ad3e3a30f475f868b4a2b98a00d30410ce056fe7694f2fd777c2b582eaa088059b36cb64937356d7ff330fd5c1968896d46af60c24fb265a62ed7147e1a1b65631d634ecf1a6135fc3f9cd15504adfc359d156ad5c0202d77090adda9e89c7aa24faa350c81c23e6b14103e1c849e8837237791e11dcb72fddbaeb3e7c18e4d4fd59ae4628e00c9e49e5b851ddecb52991b9d944f283be564e3d1665ccf2d30118e7b6f62b714ee37bcddd17e39d17188fba66214c17668fb88661d5a127cd2c8bb6427fbae4e9071f98cc46611fc4e69dd8bc0c5bbf4d15a86e2ea809f465408c338c25e64dec28f6c0b8b12ac0a2ac095cd334832f4690b9103ebf537354a8d57f645efad1ed10069104f34a6fcd155c5b7d614024d7cf6b12c65ffcf66ab7dca611e1ea0972c189928add6fabfbb19c71e0fc31043e269412588b72b08d1e04850c490f1d89ef64f0ee1a208e60b8424ae25b967821bb2a6a0fe1e7b78d2b2b426929cb327edf154f396e569b61ea72889519f7141aeb6b7b2f940dfcb8b7c5ce06bd149b0a624257b73cc5349076f07681d4aa16f4842467d4df2c51fa39b3e3629f073add33b534a28e0fb7a9f5d967b85b737c2d6a63e466c3b35f0fe64c3330b7182ef4713be23856365ed4c17909ed5265b49130f5101acf02f95c410c2e30f5c6904e275e83afee6db5dd70bb03a2d0937206d5937b5e97d1a413042bbcddaeed847e2ff8fe55942703ba05e200ad8a39fd00c8b2127bcaf95d8538a405621970b8a339d3cb0852630dd309aa0f959db38f8e976f2e6953932c2569da0d66a7345cde6adf753d0847b409d847dab79490bfea9cdf53f0cf877fd63ff2b997a417063132f1ba4f2de4d5b710024339f3f27c5bc48e3caeb1c329ad360434ec9758b3388aca4be5b4d796c155ca0bffa3936655ef34ce0aa0ee2ed4918c96ae18018b04f328163be14495c66bf7df32d252b93b9da2dfc23fc3be9c5a0a7e2a005068059d1aefdb152ec7464ed606c9fc0b2ffec017dff4188a936ca46970d9e66f50e40f6409a9d99b20b48e041829c686ab660ba55dc7f8bd91871b3e38ef859bbd6303aadeeb086eb6d697746a19b301e1105ed55f3e8903217116fc061af1d93acb3dd1ff91df749fb7ee3fb876636c8ed734786ffcaf007f48f0e003efe42acc36d92ec298d5306668e90c8b5e49ade21b1b3b838cb623dcfdf0e82f1f06889a75a7704e9e24d3f0576a1baa7d197b5abfa50e9ed611c3b4bd97bcaff343824d31fb668a4a5ffa9b1a8e99b221f85482db5563bde2650c4deff00a5bfe6f79456eadc5917668ab41747860e60abe6b1c60793417ca7fc3bc9caa1e6096455a5f26dfb6f06d0e4ca0d6f2f7db291aed1d569ec8b5d60f50304ba2b506b53804084b50d5f7a64658693d0a091d4a8e841ee4141d00865b68ae288f36d3872d597ec94eee73a9eece2e215114d14ae7ea5eaac107a88f99537e36c69282a82af39cf0a3c3ea4aa83c52ce9d3311627fc51361d139c1fb0cf175665c4c80fa84d8223d4c90e72a1417e29647e7e987f6d2e5e95d1a1083957eddd7b23ee9fa53f8c633502f02c736f3975f1d911be0c6d76e7dba380a4026e20f186423069c65a51f03635dc5024d17a6e10fa2ec719f2e0743e5d4b6a10e6975b47cdfc8abed45b2bd1287f2885ac75e5f846b20ec4bc9e361c9dab2ecf9a018a7f15fd17a8bdd5f4d7b807483f2603fbba757a26c076067f76514a4d4940083966d12423a0bf84b8e83c9ef05473d36b2c903c466ce87177934a7beba2244e0d9b4fd870db6d27e12e26fcf37f090fda13834993bf9cae044565c3c6de3e91753ca7d8621874e3c7425d766b75a78cb31e55c29b95179bb1756cc9ebf872caa46232b7a222807e69e318934236d0043d7bb8ebc27d80f927a0f3bcc9b7dc7109b8a2aeeca7c7707481cc96d2401a3b6bd5657a9ee45619d75e205a157724ef6ae40ddc928a5942bd2336fa9694b049e6f93cf5e907fbdc28fd0d9f8b7edc187952f2b6636a163e8e11872a8ab6c6d39cf9a8d5f93e897e657fe6053c147f1659a040f93d0dfcb5c9bcc8835d045a3bd8362b185d508c2e8669f47d27704ad432f10bb99553b8faebb01db477c9ab06742404a0ecf359ccc6ef7941d81bcf7237fec5fb511bedc2ef8b7b6c338ebc93b8772548f241a7ad74fa2beebef8b16706f6fb6cacaffb54176c0384d681bb14e07aa5c3d8f3800f07fba8908774431d01c9c1d65b330884bb4d6da28b0e8948fd918760b42ea787cd7a35bf127f42474469c7a352dc00ccaea18834ee1706931a0e04ce5155fafebffc94d88f9dd71506a81be90acf8597177732e425f5c7960d4f139e066ad54ec2c60528ca9625dd334207842af0dd77cc15a11daf2a495fcf18829491f394614280b5090db8f0726e7d85feca9645088807cfb555ec19752cad32a54fa5aea438f8fa3a8d8930194706888e89df93c42303b4459e67b4d147fcf3138bb8aaf396e7d0f2c6f990b87746ae09e7832ac32c2678c7d1ecb131517e54494730dab19f8dbe1f0cc409a271dbbc95aa4ef6cfcdf3c1517b34172a555d913d3c6b6f4ae350dcc1dda4a8faf58bb7f4c30929971654066555ed91dc921150044ef98b6c15de9ac141807d2c0d0711e40c7d61f3564212e5f004cf94c9356e278af66d55e25d46dcb6c51654678a5c50566233ac6e8249e47ce2460dbc735782ca6df727e7c9a75c7744d291272e37cfddd53521debe7de7b30de88f9a70233e0034c308ef1d19e8f4320f6eaa796811c41ba320ce55acfc7edc9d7b30ac5950e49dd051ffb46e22fee429957ba8170bd9a76d2ea23bcaeba97659b13a84aaa1bb7b72d5aefa302c939cb46ee88958fafaf217a0017844cdb3e199bbc7e5d6a01c95158f0291bf2a8db8c7032e6a34aeccf1b2da80148530ad921c90086b7f8e2f5c910e2c40db1ab6476dfd49745bd6cdfe358d7a94c6638a4b7a5fc2043c62b3fd87bf8c3ff2150b5023c61ccfe4c0c5000c6f51672725dde72a118628c64da5ae739ba0ff95d913d54969dd99c1cd8d8ba1818b1bd04c7691fde2827a48a0f989cc4373d655a7ca1fcca87e10eca1a3c46876b8840cd72b1912992e60a56d07804dd8c7d37f3e7a2b17a92c833d3afb0f809a7032061bdecf8ec021f69633184dd61a36597cf5207f8a507bffb5705644df2a160100eafb47bf4e371ef2807a22ced72be78483e4007d4139649acbc93fcca95c3173575550083766c2f79a8072cf197919f021d8175b92789ef9ecf6ad60d45e356d361bd756a971262d94552269565e983492e6a81096c783cd3f76c24e3f487b6d844feca86d5c17a0dcdc9a05aa97c2b6132d74204b7bc2746b835968f2a855f9d2e2ca9b348e5d4f3595e310b54262dc778327ed0f62abbe751713341fd9283296b68bd164ddb229c34e8fa60dfc47c3e84ed2f0ec1996f7c6daacf4d3b6095eee7c7bf4512cb90779ba070ee0cfb620e64de8f9db564a29054166493daed0c469a3daeec5caf84eaeb07a9a41b268c16811cdff2ebf735711987c1b8e886bdbbce817227bd90d1650643b7c83a8fef8883605021c6da8ebbf810f515f452ebb5a09459f1037a0c4f7a16d3a1ddb9a8a803ab42ec7ab6c247a9ee424fa0ea3fd916cb6ffbb2a2e887752cc839ffa7c368458f1d6b52c2bbe3b8a26abfd3f72049ff04da515b7ad21d23bdc85da4bc617da286a7e67a27255e2aaa6e7bb5e29264680876cbab448d32e8ea9de3a22b697d96dd35d4da811665efee3948d60013057cca68844c61cd0060305101e65893f1182bb9c5d3ff49ac156a7ee45064b42625bc34f59a670c0fc2714bbde9c4094c30dd3a96a5d74e2f5aa9a6451a16efdd4b4bedbdceb1c8c0c5cf57d889ff015360ca5d41caad6759c1e7b7bda53258c7f0d960ff603b549be837605922cdaa697e73718bb7401b2778c0801fa985f37e24fdf06610b48fbac43134a3a0a07c0d31706b0fd370b9d510a1d8c37d48d6888774cec4eec81ed443dc5fd6cee4d7fb77e771d5f162d4bff1849e5c49e4b7e90b2a50989e043f7318eb18f4f9e6d0dcad81c8bd01f9f6f43701f7d2da3e6a81aa805584accef6cf3ee4c8a28814d68951b911ad63ff10a2274539fcd973aec7abc8e96e24080cf18a99138269140cea2545a394426cfa930a5355b8ea290f03a2b00f4239c27439b0dca088cf328eb10aba534ce47f91e0e01f1e53f7873a93845afcfeb9a580dc78538ee30b602dae2fd5808ce7dd8012da443ff9c8361ce1baa80a07d49517a7416fdca882562829a3e464da55c6fbb55fbd1c4f0ab8c4c2e4770306537adbc369fc316ef9fb4dfd666bf7da4e74fff5d3c89c630d7a6c86fdb761ed71dfcbef8d4900eb5fee30b201b0f84551d1fcf1016301b0b54267d7e66a11b3fc31e9eff48a1cb012bbb4f993890a8eb742efd60ac57b4f8ae0c4e6e28f683732e723ec8a9ba0f22a59451f9768c945eaae412037e0acb330629e4f2600537a00ee0060ef68f231c708b3dd9e68e76dc6f8db70873aa680e7feffc0d4df24006c999f46e575c1a5888e2b839b204902961a2b70b78425faaca2ef3bf407c767d64fad91b1630be37576e0c768417adc52de254227c8e4e4496c3e9aa786bdff98f0f08d40e5032c2d2de15d1f924a5c57de1e880248f077265c8daa077b765f4c711d4f53d59cc92b25d2254f79749480d9d59fe72d5e2ef6e7c5d4313d683ffd18df476a2d186d9ef1717fd8e5332aa746874f773fd2a48b7d2c702165e7649ff47967860f0963a04a78516b0a573a1e8e4a57d4adf50ee12628616e8ad98a0ae1f05e82b64292cd59107cc438ede7c9752341e2fc81f174edfbb9647e1ccdb492066f33722c6e837b0dc370cc4baf9bf37ec1cd61fa86ccc54","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
