<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e7aa90f676ee5b2b579ac4f5369d6b5617219ac1a7d97e444e8eb5cb1264a5d5a0fa7c420f4213d4984a97a361829111d67baff8ec94cbd3c599b581c9ad760acedfffbc9229e564d73adc402518869a52b1706581a035d1b0b286f0fe51f55b9ffdce7d1eefdc3d8bd4f9ce68f668e9b56e5877a1201a0d0335f3670339430e3945f9511dae8f511f1c648baf632c1c8596544c9d61d60084e81a466cb4318ef449ec25a1008f1f2a2cab5efa34ee13b76d8d26af85ee8bf99f577ef0c1296a657bfbc6ae9f50632682ee503562d8ade176e8c8a58949f5bf4df4a08755543a791da64b93f2560eeea0c8c1bb7e5601dc91a7ce767edbd4d3c8d294bf56e2c8cdb22bdff2a22199ee4df4f42cc9066982cdb3f7275a77037b52f14ec76208bce6f782adaad02b6e98078d86167746effa7dda1eb73814c457f34df131dfab3a267c41cdb15d132cf7edfb36b6ed4afb7c1e51f269d16f735edf944a6c50c9f090081eaccf13fdc5c6f2a4a2ca0ad23622bb272a51a671e26f4a839394aff30745f6b1358156794ab83be320d8cebf10a2297ad19d84daf9e393d7c97c73507601c6e44b150ef39ec846582fb1f20aca69c7f2198352d8b1701c62a68a71fda27c30fecee40b1bbf359da3bafe29a6aae435386fe17b56d1e486fc172b8057a910a65d96f8ca4ba2c8432161dbe177921a01c516a599328586a95baf650910a275b0f13751978cf8824ef02179af036c6cce4402bc8beb187ad6308b2041e37e1df26b406410249a3087204e8b6bf8e84c9b97eddf369037fa6c62914eba74b44a523e3766fb865058604ef31ddc2c50ceedbdfaec97cb0690cf8bad63f3cf680119d1b01f18d14de1c3120b1c430cd742ff039ac57ce84c9b1f6ee34b32c563024e5be4298d9f341e5cee8ef889c2305618b46bdb5f129abf97abf4809229f1b4bf4f1d9024ba6500ac9e5226ce41910efbf9f97a2a67543c5c3970327d6341f59e283fd60cb95fb21dbf7b39c640cbf6cafc908db0ada455ad6dd34615bcfed4e9a4d655fa3815b452c2ecf26503fe91f60bc735c1e0721130e206c688493d7ddbfafbd1422a7adfadbceb9968849e50ad515b755bbb2899232bdc0c04cc20f6f05fcbe128ba9dd0e23056fc5693389b7b67a12ab8b8ad8906898634e9665cb6c2538e0d8b977effe228ea879199688e592234e1348e7ac8e265bef3b46bc3210ff0bc6fd93945f7fcd1a6844349c8f49e02dce691c2a1b83090809ddacd310a94cf9bfa3cb23059abeebe2e045dd0b4f25cc0fe5a5543ffbb15670540136e3bad35c4215fe6a15e94d3ed74d4c906a04ae54b4e823ec5647d767e9443b1606d37e36161400825ea0681e6a3883d6851be43cff4afc8bcefca318ba9533534a2bc23a8390e9963c719c2be6c88838d5f1f71a0327fd167f602aa3e4069dc9fa7d369ed321e833aa9bada408134a73a1147a65390c0d26badcab851943608f97c6f10e69133e485c85f07731f385a9cad6b450279803a3dbdb47b2502210e8bdb72a834d6b7726f08122a28b75073af13bd3f4a110fc9f79dd691bed869b035d07a7deb4145036402f4beadcf098583c1a1b90f57ea1ef915a2a264e155bb177fbc6d6378a8957d92434a933d597d4471f3c0a63c5d276d9de3b62c062c546a013e9b1246f6c8deeeb1baac81462ae70517dde5bd9d67ee8692d699bf13be20f01d5e27067ba6dd1461c5092f1fae5a78409f0a34bdd91fd8122caaf9961eaeadfe50dc402ff1fb1f9a349897a75692beac63b660a0709585612e11776f8126f5c0ded0808c4e90def08eb2ab8ea0dda6ce06ce7ff536a14b31401d1ee6e59aaa7e8f2323d92a26c08f0f057f4f9e3198c9db28216daf3f493528cf45539aae07a81983691e83fb04ba7038caad5d0a4761ca945858b37d035c53d009cae3d3927b899dc561afe4c57a9e5ec176a45a2de738365257210aca7125a4cb6dc8056cb829e2053f57978fbc0f10090bc3fb84687172643993bfc287c6c5fb8998c4f7607c5f3aa1622cb1da7d783dd656e4fd1195029472f5b4b4d1921f67fcda22a7b02d10b2975e6d2028d7c823036baf465fd1593039c71ca6cb4f75be93b455b0d43cac02cc99455f1072b1be5d570cfba1d55cbe2ee650f338664e7f1e095e90bbcdc06685c8828448704775022549abef6c04433f24706016f112ea7d88d87ad08a2674cf7c01253dc2139a00bff1731acdac76fcc37d0f7c225faa6e2ad78b3c8acb7e7393cac14a3e4f80522bf92a9d762faedbc042f4be2061c48c10d30d82b9bad23f5accb269c1ddee4e50a9381734183769fd4f65128fa5ee79e52daf9e8af26aac37c6393d994e4c9aefd2e603d61a5b7a2b902f5894f2951c72ee74cb3c94e45da78215f06445bbbc07d195fd38b6406f472575c4861e6ab797fbd40794fec1a850a226dcbaf70cd975e7709fdfd2e7b2125a43449cc110170447f13b9d3a4ac3f7a8efde4674422b7820a76f5d366acc66bc3a43edb9c35b5e0902251a490ee0ebe8131c8351af4e6be65ffd449dd4fafd0408f8194cfacc9c55cd3cbc21c6911a87014058a5956898d0a96651a9cc3d099ee2f1d142ea6ed289568fd1a28ed24733f26900a51b2e74a86384ef7bbba42cc3bac11d12ee6b0180334bec9c6b8e49651007289d27a8809341b390d13b11919883624a23a9b3a5eb94f13d54a713784db03912e5240a1005583cf0368dcb029c008f7a656ba36acf7698cdbfa64aa80903156632e6d9a80faf1a2c69008e19873af362ae96a0b45877316fce56457da649cc4d1c7d2ce180e46cabde11767537ea4f8ddf0eb6d89f155441d5a651bd7dbf4cc6cd978f3566a64320a2abaf0723a73a87afa8989a3161715cf2f8014a6765ad736f2aaa33c83b3699d81bb7cf40c5efacb2f3c090dbe93121c5fc7477f7fdb3a70f755f0dd95fe783ac312cacb9316919e7d820c4078382b2f4a157ae49967b58c7b96a5e0cdac810d1e9fcb18897f95dfed343a817a96bcd06be2089bfc3fa883e26b665c3e6b943b6859df23dfa7a986996316c4edca8d8c5dced6cba6f3de40a5ebfe1ebc8b2e385d1fce9339d6ef4144ef2c4a4dede7d182eef1f27681a6549867f35a834d893d6db3758c4f6179ff37def7cda069a7d9b761a2baf5c84bb5fcf320d7d1b3c29b3a749b05cf6996cee23122568a9630358128c9392d9d4b7716815e5a0eefc64b88e183ba4f711962d3ba15e4ce1be683f78c15eb5d8dab7aaddb5de267f5b20de893c6c05768171844dce444851dc26d36d4c1e20f66e513e3560b62a8793a6e4b7f7dc236809b50d0657972cb9fcb0bd829543eea8842a4e1fd8fea8880f43334d47930d23fd54fd1a0c07d6878b6abbb85864d48e23a0529a4b070bcaca37237802339d36d2094dee7dc387dc7836c6c0ddd9a52794428f4fdc7138c7f297548d198cd65c9ea8b7bbd617dc3121f110c78deaee5f8df140b85bff716b9dfa0fbdba48c3cf944cd692179c2be2bf591bb82de54421c259bde175aa687f1628d27496f738023be3ec63ad650d3227f09e7f109d9244501c54988632aa7429bf1d1f5eac60af33789e8fa0b80682ba08fc32c0e393e2f464e442d26bc483387d658951c04dff073c34dd83f8e3a21a7de8924d21188a793537aef17ba677c26693ae84f0ce61f42efc24ed3a9ae072881f432fea9b94b801148e074a3a715e807b8d240d7c4c1629f8296d2becce8e9e6d480b36a2484e21ff4877c538b8271910e51c97b443429bfd44d81036f6317a4ebbf5183f511d0f2e55e401462ddfaa4011f0689e6c1efb38eff7dd18f8230da94f588b8d73cd721962b094ab3328517518cd92b642e8782922b5b481f1b3e5835ff3abaaa970a53b28fbfa9896ccec118efdb1dcc625fec700388f5089b0b19dd3fc67187fbf4e416bd8a2d39916fc01e5238cde7361e3561af365f563fb8fc415a89d8d04853cd5b404564c1de9a0e3f384a06ffbf882bce451d04cfca43c55068401b6ec4108b8c2011dbd8f9336560e4999566b4e5dfb6ba43a208686e1d09b5d5d4a341f43742e1f779861399b86fe95ac816959c5604df15b66dad9f5ec1968e2a8a21b70af739a4c3eb192861c1b04909d7071ec20505233c801ec2819cd98a370a7441e6de0a1889291a1b1c62f067725c88f1fc89e5dcffc1bf51edd76a2d60840b858ffd4e52dda6cc79fe8743568d932c6979b787ec1583804c3248ebbacfeda865137d3816e05bab2fec8f6cc0e75bb7b658dc45e7bd945136ead8b100b9479cb54835f64aa517a4e1bdbbc11d824bb0a5ee1a169fe4ed04546c493ccb6d4b40635c9129478e59bf5b5a725a09d6e96015443db07ef5c3b411b14d89578a3668f2c24e4b44e3aed37d68081a0451abf86182bb4ae6473828be4e1ad3d5ec807ab07b62cacb17a7f5a8b1152c0c2162faf1916b303fb1fd43df352367578ea9e820defdc32c55b32814c4c556981a60045327ae99f2168402854c7b3638258d75882593f48178448d5cb18176008eef02c199298ccb1bc43af4b3a488f7b6acc0add5f2f5a9d90940af7d1458ea11258a6803cd2d2854e950728c09c2796c0ba96c7e8c528c9430655fd6206c55a2909509f00eda683a1430e802522e783ab5b1775be7481fb996bd14172989d0d769db6e56c699f803faa44500bd75305a785fd4454961a42afeaa3aab6dae26f5832f149c789d73cb42248bbd9f98d56a3c573aa83f58364c14d725024788f57b53174658641a329a3ce5157714f6bd0e18a512c3c18cd72dddd1ebc05e8c70e7a5fc0e18d975be992897b0fe4dee42708fcef9493114e31b8d36a0cf7d0c7df832ce5e6542bb01e0d38354819e15620ca1db4f3181e9f48c59b3e345bde5636c5bb098aaff4b569dc03e1fa13ef8468670b8a010689d445d1e3dfb41c1d7b5bcbbd150a40a24cea225dbadf43f3b7817158fdce172ae7b2ede86b2491c93e58d8956b2870551c5eafee46af520d65360b1c3bd19662fc5418484b1f6347fd7a3fc117497be7b36591998c0889e1e8a0dd16bdf9c442561e7e5e11247b6d9a234a8d721a0c54ea4ade59c22e6ba77d16a8cd1143a285a3868fcba6ec174bcbbda42c5b67e78e15210d9d3a2a293b82d9fbb999f3da1ffa74c50d1de2251b400df083d17674a96a93f83faddbfc394ee46ec7409ddfebe180160407ba77293efe7717d0896e0877705f275fa06ca444b2af7688a8bbb4b98ebff5f5c8097380ebbdf6760141e67dc7a683c8fb2b56d05d203223b42e6fb86e527e1403d09366563003fd5d3d746c178990389dcd4be55fe4f719abfc7b1c66ddfd75bde1cbca4af618f07b812db5301e76da6f1610e732aed3d0c7c7b98ccee8d7b734c1a2c3360073c80c21db73edd51b9b50421739156e48617442fe13c3a489574170c0725ca09e95bffc2721e715f581dee7bff7e8761f8c9c662bcb2ec31c7b2b498cf0125aac6ca74c6c66e9ec883bb489cf83b91fbac3ec640f9434681a20d4fb0c181701acbae4bc977ac188d3f8a5221707427fcd56abf0f9072542c805ea1febe18894dfd70513bf9c318ac236ba62ca167b1472fb609fb1f48f3dacfceed0e6055a85c5bc647ec620ac08a51061791f84320a9f6fd2c121ceb9294179847b85301d66964f3cccec0dec679b4a05be35ee466844b38bd1d9646e52d09ec33cced904c1e2a433438e111a5f6a804139dbcd390d80f068ca25da570ca02c4b0bd5d45fb7dbca0edcde0e599b2d5b24e94764d06a67ea17a288acd9942e65478f9c1821cf40fb90909f8311bd3927f02623c3ac621ce2f8f2d27af81113eb6673c05ebaf281aff8d36ef7ff0fb95484262f3f2e659d99146cedff67d8b37420d90f6fac63362ee7b2a101b802f59f5cb8b9e768dc2df8407d5a97c5f4611ee372faaa5fd5668091405d5c1139ef125c81a49111ac56827c3150c843c5212ded5608a1ebe516fd6c2db5d77e67207256f2d4b50ed3637c5d40491e6f8685fcb0a5668c29cc016e614a2afc995d95ec8ccb955c62de1a8e82c779a5f3a311275fe582efff31bcbedd036b673d174f4325562bb5f5f31f75702beeae2aa85fcacab473457ffe537bc7a681b4dd995e6fd21e503217a994d3e8917abf25c02fc56cb449c68a985379d6783425263f56eabc3648afe562f1eda1459e81036b0d73c4d4a076bcf1c50a608bc762c7712cb97d4c4af8fb7e9898376b4b75a435d7d1635517c868bde5aeb506d847316615161b0bb128651c2f43f7f26df99cd96be3e064b01e8e47c014d69d6597238f1a4c8d8da77ee05a8d834bb3b182c0f49634fcd532f4347fe6bf52c30c19973fdc9d0230c0e29ab55b83dc1247e6431469759be259d2cb43ceb70e6b48a89e04e45ba50fa4641ef1e9d41bd5e2584e2823006a65247b7c55d7f25573df965e818f8d1e87b4b5fe7e43191dc95e33fe3421a25f252408bca09079599d8d471964bbf4401b7244f6a8878a6dd92b16eb55993e42260520d19724cacbb333441523e6dca3cc36079df8928ed21184aa6d4d8ec51f11613d896288c517bc6238052686cc9156a5fedf3683aeceb199f5cd88827c0ecddf2d0ce9e775d24d06eb4fc5fdc384196e143dc1e053b573958c96698b366b86dcc52beb445870cb8f96f96fd0fc1a97e08061178277e8bb03582d39dfd470952e83c475e2726ee4c2754270b3a59d8540f9ce6b91dcfda9acca4f986bbc0823acb35773a5a3de58f2a13bdf2f6030c0e020cfa30d35f2d4bc640b8959e738c090f7d7e965629cb9b6003fc44502b97b558f852b55a643eb7a6ac6c0f9f4562bfb51f5b215d3533e502d359ed81b0c394cadb304b47064653390e62293fcd8450ccf93e39e325c48f30d00f934474d15627246f2f999ff4262b578b6d580a4d1ac72bf98601f74c6d9eebf8f6e160c21190a3245da8da43a9a714c80f7f2c734c1ff5b98923e224c3004edccad107169eaf35096950f458759155e3859be7ab561a5a5c8897d56b2725c90d98141851ae6eea53526bf36dbc731ba79237449e519b8b5afa1493d407f507138d83456b82f8af30e199e0f8862dd71a14269cb344027910552ab379b08f6603b26514389cb2214a1b3ad4af52700f57c6f0e3f5f003c5ef8356e54d56fafa858232c807f0bd9e9b9320ccc762842459058dc8c5fc6fae05baea10dbfe802c8ad19c5c6974315940f4aa321bfd18d341ce7ef765fc6e8a2d906bb823144f7acdc7eefa96f1abf30829b8ba166c71545faf8fe963b67f6ce38dfcabef3cc2014cba7c09dbfa27c14152ee8d1502fd229565c3fede45cb1b8afca69b5d2e7c580ba4cf445a000b91f9db4db9abbba15e9ca28f895cf1814b7ab25be7af7daa70451544afbbf5c433c718b3f9a2c792055187be5da89b1f9fc0029c97679513ca8a32445d18a24ef45c8b01ccf1f67276e85164fe2dd70c016938ed1bb6ca7ac8da99c0031af0371c3ccaafe5d0ee64c401e4ea297ce2784703fbd989507522f4f858cdeebe6a0220fe5021fab855a7de5b0fa48c10bd805881c083eced19d90f16c7e782a9671070e72a39969653d6b21cb74ad5cf9e5a9e393edbf3f6e026dde647e0e5fa4f3ec441b8ba81b78c2b214840c48d550793b0f1926cf6b17dac51d8abc0261265352e82d7a2806be2698c9a2824a042ef8e067f7143f20df8dbddd980fc1fd086e444b7102cab1eefae2143449ec70c3a810881bd6a6322bb4a1506a5236868cd0e7ca3ce52afa5b2dd197b7153d8beade18987dd9172a4fb5c96bce397ee5df548d0f485846b1ee06d7c52c3b38d79934a317222307d607d7770f15fec8aa192277eba503f34a267ac9f981c9fd0916360463ddb7817185ec2a6e1d3554e9ce79777a8d1a3824b6ec01f55ead87ee050c31581aae091f83b75be9b6cf446e372bdb2da3d6d6c12901116dbe007b80f1102df416d305a9202aa574e517f8df0cad3d4171f28c686b0f1129340a176cdd47439678a0a946231f85a741294eb3fa08d57f52c95c1a9b85c0312a9bc97da9d86d7561ae38f1fbc6388ce60138049e8ae17559f6d407e3ac57c62bdf071ef1cee69d8bb8ca161fc29d2a23d2d4bd9664136f4589ff5a70523c205ae8c020604626c2327686ad4b3a99b067482912f87e6d8c50515d1d3c1af47796877597dc25d9343c15ac9bd9614e890ba4b76ac653c36593c0c2e17f7bc22576d8e7f78e06ab05423b1234fd3bc4927f7eab6d95a87cb3f24313354c361f3af14a680013990335f3b1e557ae3a63b833897307ad0caa70944c7eda7283b34421ca1c4591a02ce1e9db850cf35176f2c88a3d97f1624107a8072a884a30d71bdde4afaf36258d284c48e8d9881ab1265b8c6a8c3bfa57c6da4052c612a77415dacc3049e196d6940afa9a989a9ae9c56d01e263dc1f983a8b849cb19d08060493e395be825a555ca97aebad7f47b6b924a3331c7f9bd2f7dff0e752428933e8a170f09d98e49b9c87e29ff749d75b1e3166fdd08dc5d9d4ba01823b52f29d4ed74107b435f02715e9094d76509a3ad672e971268926ad0a7aff8d1f149707435876cbfcc6660b004ffeabc996734e1e439a1204d3bf1be20efb5576e09fa665f9e60b6b7f2f58547610dc3df55fd78caba15a167bc40234bff98a256c152b4d536e75e797034ce551cd0a9eade57357b33252c2e3e24ece313a36ddf42e0c1a02a71b0569579d0cb74569b35727bb6aebfe1a2fdc0ffe71d5e3d80da2fb150736a01df98d05aca725e3e69d1e5e8846c87b686bb682283dc0b345ca59a1170e99707b66b54592dbd81184507abe8d18b6c8f5f16eeb8de3637c05517060bea57615e2aefa0d14f55b855cb88115b5ccb8f933b5c852179d15c3abbaee65411813e2516c6b5bc76fbbd78bc7e55e8b7dd3483cd6be55c8a09bc4b2fe0f2f1ae043fd4d6cb8848ed6cab30ee2633c878e726026a15757d743d8b1c53fafa83931ba8745c65cb17a92fec9bc41b80fa3c952e54d8977973cb7b3bcd124370765456b6d918e779e85ed4d853beaf81ca2cb0a255c8a50a54375e5cf2fdf6af90ac4a392cf4fd476853684d8175f9ba59229cce73adff48945eb53b73f4a216665563c6d62326eb7a3a2461dab52beb7b08639481361bba42fd25621083ccdd416d106944caf5dd50141b36c771b0729eb7faf13158d6401a16eca546d015cbebb1ee8b2f1ff7be55c4ef90c401da8f5bcd92b77019e3c17def57e6ccd4bad08273acf256126cf035fb0f689089db0132a77fc245e3dc6ddf42f1217a8a2c58ced9854c4737aff5e30ff281bea55603312510f45d028e439d4611c33a7a124332c3f4d6661142966c434849aa492dfa940ab6fecb7fa1d1f59e40783fc6b20445947b8701142e2f1720361fe4dc3af7b4642ea564f765bc7a6cf154808873f4f1ce78a2ed5605a0c75852d5f10b17d8d0c8b65068c6122e3efce25c1fa931b49974c1ed77021ef3bca315906b76a6f0a130f2c9d05f7812a7667af6af45b92fab83053a25c1f1b20de59df9d11e600c77bc780756d148a249cdefccc38eb2914babc1e47a6ad4d9b9cd888d5d1d7787c1da843a0c1494ab08fa54fa375a43f144cfdd38a22e475c2979e30753efe17b9dac078449554babc1a357732140f36d0604391bb1fd4efd36557fceeb56c7440fcc39857f0352f6edd4ee4a7b663f7fd26f23b2d3023d6e730d0ed137c93d1ae22b43803f4f3a1bf00b13b4919c8470806df1e95c2a482c35669fb7deea934d7759b0167c02d15309a39b06459789e8b7496aee9b08743ff4bf85e42b48a68d00070df06e80a29bf7939947dbaaf9b806ff6d2770c2c2a5d8d7eda0f77b4ad7a59a6898d7d762ed747039e3d53e32d82d6fb743ae8f46d1a50067104d52b94e757146904cb551575bac6c52a9d824a96017acfc17e0f3e824e50aacbf0a927a1da5512bf4397882abd32d1122180ff8c4fabf53ebee816bd2762c04f1267c9eb79fd760ab0c55f533a12a27af88180ac7237c10d3e489fa51402badac9fce0e763535172d6b478aa460342ba6b81c5290a42b56f6511bd273643c3de77ba5ffe2c49618379e7ee78b19c19e1ec68d3fce1fa50fffc6d2f6345c8f5e0dc932308661858884fe60e5c6c0b5d04d2d6e51fcc63c7f31c57d37ea8dededc250b71128ac31e13cebfe1d6f6d31aa4c8ea510c787a92542e94197ac4a599ca1cc6babb72b792272ea93f062e5fdf625f7a943cbda0abf37360ba52b476e24f1b5b93ac6afd4535fd59e50274ea90a8a6c8b68c447238dee501ad0b4f28cb3ab9783c7d91f29e7ad2b67073e4c1324ec710389b3c23a9185f1546edbb88ef94a1e0ccebfbb669b4f796da577fa33617c1961cc67eb44c22ee07d877e44e97545619ffbac7f4f0423c26753676b10c111b44233d17bb883ac637476bc46aa3a12fbaa932b4ad58980a381e9807268396f865c38659220efcc7770314d454472312bb5455976ef6fc06ac03f08afd59396b47c9885ed0e06e160345db323e044f75cc0e7f12e526df1d25c3f8e616e4c63e7cdb4e02993ef20f0aa00cae3d4bad98d46e7a0b6c98ee6eb6f49f35a87ba4e56a8fd2d8f802e7acaec3dc419b9ae2f3c083aa376e09523b1ee19dbce896a63f4856e71f928cd92fe69a0dcf2c3254460abb186ad77e1ca3d0347caee627f610aa57a8e51a12caab8bbbd76ba996467b78d424dfcecbc3705bbbcd101dc8da691bf505654294a9ac2d6186521487531ea147f54418a1a82f025357855be698410b4e9f48e6ee826ac659bf5580a6c4871ef069d70f80aae2b28ab5d69b1cfeb99e0b278ea8f57284003231f4e3caef9a4cbf6e73a1d212695bcdbc5f973ff04fa7c5bbc976bcaeb3c9866efe1a0c9eb2de30ed572f53c1cdba44591591b607ff3f6a57d970f576f7451309f1130ee59782de4cbb176410d815378c450ea228eb3aa0ecf180a2b2760cc841f275ce0e0d3b99711190d961cb4becf5cbb513a92a498bf1137d9edb79fe02720f163e44cee79a6327df396dc4d1b9ec21a2dc8859cbb01b2f6c5f1add5791c71b01d31dab19f587cccfd1a3404c8aa226fa84fc8dfa5baea98a6d81f9c909c65b247176ac44eb2e4364f88274e80281c72b88b786ae8b974098923a97c6e61c7f1888de766ef5657409790c53796875757fbecc7df3e831dda438df7c8040ddb55c3ffb143ba0f6134e2be98aff60e742d415db19ac9d2259ddd1a38ff457876523970f7b3c92c92928f063c6c2bbd942491efd018652c396651cb52c893527f49591eb2989ed859f3b01e1187dd2983ea323b350bcefd806ebe1ffdea0dec94698091d4313cf03f1355367a246295effa750d0daf06b710dd7a944864b40733ef68b350d9e3f8945e54c7390dcce488c0758c7c51f3bf455c8a693d7bebb05cb1e3b1db9280d4fa026639e98bf0af23cad535b410c83b9cfe25138dfb6fb579d472ec2d53ac1f0e0dfea47b76b4e3d73cbf38e97669c40cd009a826fb6c309c62c90e47d608cf3483ddb9dda110c2410dc01f7faa87746800b4f33b8c54494c32b72ea99c69fb36f83764e9e7134c975234acfb73b973ed9785fb7bd4059efede71e9393973fabb533f676b3adaa40d93e9e532292befc989a0e6bd36ef8f13fd29b0e42a674abe1725e5bb515f342847f4f3066c5d6e9891f5fb0a459ccf9ca29acf5995b6f353c08ba6459695a30adee4cf19178f214297776235260ce359a10d5c56e1d89c60cd25628d80ec6832c1736bfe37184fcebb23ddd57fbd96caf2bfd2af6d89ae14e947fa3eedfe88e8a82183c522b2d8ccb8323718cef6c0efc060bb120eacedc91d5de84b40a396732f941dadfe773aab6dd5720d7210aec118bacfa80c0047fb7a5078b3988f4e8834013b69735354bb1915719c31b9a24f449e2a6973cc9468aa734da4825b4ab23e5a6efdad195bd6ca2b20b8b427f5df77a053a1e321ff379b85f2d166756ddf41d6d97ea27e97dbcb015adbeb3134ace2cfe41f587534823eb32e027031b99ae98a8ff61c86e0108d465bdc62916d8a8e0ae01a014325a90ab7a0f8c825b14e8fee8b046dc543989bbf10fabfb2b2d429c6d7ff2d9922cdd570d3373adfa171f9ae4fedc276652809eadfd82e3adeb90a873f66461d51a4359b8eeefa2a6ba1a34b3247c4910f10ff2789a094d4b63e2a7856dff53691219b08f62af385e8f67aba2298b2a71665c746161d2b324c4d23813cd04e879746fd0650ef2d59ee0317c3917ec97f785ef21e58083f6811a40b4be1e39d460e89f9aba73be6d06716313aef5faae75b5b9bd0c8d9bf379a420e061248e5d6f252ce533276a64addf05704058c879abafee9cdf5f568f6fdd4620647372b095d13ffa23e7d3540685cf70a8b61478d9f1585b094cce65a3ad9a78aa69c57da78edbdca8f415b50700e533888696164eb5b77c42291019dd728468137ea62a525331482a5eeb899656b5151736dd374650acc58f9131e42bc8c5683588a46bd156991d09b7e4c0bf0174913ef3ec3276e136719e60a79ef7013cb16ded6c605f4b27140ce927558668cef422790a43ee05e9ee708ef2a410f7f853ba366101cb14e6864a5d07da04d8ac97bb34174fce4edb7f4aae665c25bac194f52dcc592ab4e9fd2df5f25202395aa52971e6b44b5f235b5188323402fde74483343f2fb1ff6395ab409d8248f4fc869d094edf89c8dd849595e090eef2651e8cc68a93e482fb071d0834915f4e004777521c84911c3bc61751351a09fef731539ca88be3af2cb58cc5ef8562519032b08c13eb09bfe0d1ee72f0c6df424fef167c194d28841e0ff234690d087f40769581ab04fe2a2f245003cf0f8bac41ccf5991860fd81d851c2ccabc17d39af6c1a56f7cbd7a98a27d65219de058a277bd558043ce6ebef4c5c639f2fb0d1351f8844cca7ca9e9c1de007dc72f1bfac175623d72e74525666f95f8c30cf1f357e5b8e1c425d46868061a23a6415bc06e17f43e8b258fd17a1969dddab9fca5d45ce83c7125fec8833c820bbf3f1b4b3c55e5360f5200398299ab5474882e5c6ac60825ce65c791b794ede7fe4214a049643b21d42b81f4fe02ae5593390140e2cfda15d3ce7e2784253c25c72f36ea27333489d4b47af1fccb4bd1392c39c810bea9fdb90a4dceed8c867c8d0e5eb1c282f2395c9f1a9262086eff64e40e14df20476ddab49968ff694054cae4a70491f8cfa60cc786db224db1f22890d62d1c8fb278192b4988a7a583179f749bd34c02317bf079ff57427c62abf85c44109e45c372712f92842f368cf603549e2ac672c534978b0bcf0d4d69ba2a10e209c31ee8cd89c43eb6dcbb1cc4537d88b908df0184cfb5c889c61563672aa55bb2586afe57099e611c0ff253da96eff66aa337e41b2972412c2d43d3f97bbc09717cc7793912217d19b80af6e3b89ff22f7d0b5fa9d4117135b1748191b8025ab095b8787c9185e8076bfb5862f8c538f814efbdf7c507abd41eb4fe8f5acff432681b760d8d8a89e45a1350c65ad57e586735caffe87afcf32b6d56f760b74dca318c231d495dd66895c5303a25a9bcf0c13a47a88e5c1060c3d68ae0bd3abdb6af8c8770f0a1c723c29c612b2d6aee767e78a6453bfa2e23403ddd33b021ce16dcb9c520071bec9eb7d27a5f2bf32ad7bbea3891deea02004891249e05ed7704cea6f8ba0a488629848164c718e1e4327e64639564de4475ff02cbc5963bd1c399b42aec458d27b22b740fa27e3a444e680a39e9252c299d62e817f4e47e45d1a3e78d9faa7e44e0c3153bc79b35a42ef90febbb7a8322155ba32a262414431e122edf672e3dffa0fa532ca728be29bdd2c0ca247aed52084681a379a11cb6f6ce52da666ba25cb435b0b553edcaee8c498c7c72bb0b954261bb7e94a2a267682e65002f9ed8b143271906c909c71e43f58b6b01928ff88490391d0ea782545b91a96dccaad094895ae865e812d36fef3faa60e2573613ba442cc2366f8ae6870d0899a1405201d5029b07d4b947626d5ef2a56c0ae169eff6324975ef54b3df5162ae561fb0e58df6b7fbcbaa1e29a3c00a9ba4c228de43be8dcfc6121f9f8398033bf51cd1b0c45c29532e21f1508ea4048c4ed3c6a966e9b8cfc43e2d88254b86d166582aa078d293934c9b13c04ba4054b85cd11e57d5040a8f80eb0f129fd677e26203e79f025c4470426fab05d506e94615602c6b908c91942ca95d3b9e722077950614f3424819f822e4c5a0aa7fdcc6b63d9be9183f8c208bc065ed7ab1e9bde30423a3dc3136af356e76f391e2d5fad1ad123b075cc926af2b73a23f6355f0a7c3bb9cc5ba803b3c3ed9c1fa1f77ab95fa4e9bfef7b2","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
