<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"96a19c9ee0c40ed7083c63d6e06014877a900b9a69c7c3a0bb6b3f8b6c919c6a0a9b533f25ff7dca82d37106031decab9b17de079d919962e3266e3ecb5a52411156702fcb95bab170ca049bcf8cc7862cae5a1961ee567e17ef881574c6a48f635718315cbc1ab83cdd0ffef00411e2ab70339ab800aa97c31f291b83d8b6f07eb694ec7104f2d802022ade7baed4f7a3382a66837e4d15d321de6a78e96163c64588d5ed2861d8c574ecac2919b8323be2e866ba933541baaa708da3e52e0a10f0053446c927a869e2a3f5239e21be008be9890be16242c379bcf1bb60a3d3dd2f420cc43db107c0644205a7c31cd2aafe27e853f471c8f27098a89dada20d78f967032b4348dfb4dc6dbf72fa93b80968b826f4bd1605b9f50ab80112699b4067d80c85733e491729d2fa5283fffa10c8476099ad6c17fbcfa6e880d0917d11bf38db1ba3c072744e460367ec8cc8d6cb54a85dd1a177c97ed86eee5861807caed3feed0ab0bcf84adf014601082c1c0ad11e41223f8dbc2386d18867e2c189c5791ad1463dc92977848bcd33563d7e8b21d3f7ba0a375629f0ae390bdd79b3e3aead160310967a62aa626b58cf62898c2024074e0be76d3b81203301427867d610ce3519b9ff65cc8faa1adcbbf13c4732c0dfa84a077f13a79941a2d4dccc40ef80dd820d4fc9a791bb7ea2e092c1291ae3c84c81ead214e4fcabc5183e7c0b4263ec7932f056e0824ddcdee0c043096db62f6012ab2fab8f656b5d8c8b2e84a3313545418bbe4c9789b5dcb4d323df463285d96005192116df7d7d7d92d47b6280858ef6b10861ca72e02a71022dced47a8de2a8959b9a5daa103fada466159b14265a7ddceb9974fe55ca12d285d06aad42f1ed2d4911c71d0a5fadc9c94980a3c6c89b34c4909606dcf295c28c3e35f8e73119294f708dc581e040150ac0c7c0505f5f2f19e7a181a8fe2e41b672633feb74c970306aee984c4a11af51cb31d8e9aa5a514576069925b3a435cbd6284f39fe21e6ddeabb603f799cf9e6d377b7e81f82c70f7439ec7a92df425b4ca4eb83a21c62e4708442f4c2ffedeaa5e58152066c3bc77c8966e900f2aa94c2d59ceefaac256cc5cb4d47a95a542b6823eac3511387f31c74f8963fff49e445c97207224f8480bf461d930334d924ccb7446410e7a67d9a118b987ec6e9af8b95408610cef0947b8de35227c928de6bbe1df57504b07faddb8fc774f53b3714a9f25919aae64b0b1437660c53983c606f672c0dc5dd408e228be348b3f89e43d252aae09c01a4edeb09a7b7b309dca12938033fa60d5bd5b8d20f86945f305eb6a6521690e81bc548f62756e25eb8f00cf4cda40685a3843d99d124c207ac40ad98571b816152ebc5a937c9ae0c1b51795392a928ca738ebbf7287cd6fe9af0b30e6625543440ce6e4978f93c48a86c6c5399c970a5283e186d148ff7a6cae2a320c48f06f626fca43362e960a734f41f34853aa390863e1ccc8d687bed42c262c78a077de15bd2cf4d45631015290aa916ab536ee7311029bb40927a31649ef1c450a001b51b4919f717772500b06cad1ae72129debe1140f98abbbd51c6b140b5de3ceb19e6820924ad218fa3078a084f238dfcf4392ad526fac4048fdb8e81f037bb79efde274c4b6ebca8e869275604fd71758327cd7072591059973e2c43ef365cf156f601388bf39ea986fe08c45f7d950f82896a0b0022fd927969342cb8daa7a6a007abb748a90afc4a39c8eea237b9d3479826b3e661f29b08e38eb7d388b55cb768d02ce08da91037fc59a8954da94dbd3e796a93daadb37f103143cb55486c27c89d30790cf817065bb57ea5e9ff634a132f72e9a1ad48570c29c3a95c2e668c69db17be049e5e692fa14be80d2cbfd35aa1fae2452bd738b31f4208804242d8caaab0a9f5fa2b35bc1dadd470e3f3af99586cef1287fd5a25546159fd8072430680623a300cf557369c851f14f7d179df7b6917386baa2ff365f8c324a2c4c199b60d78ee6a20bb83b17d7823299b3d1ad84b030be963b9eee44e91b0a6849229449f0287f8aacc63ff9bf982300bb775fa3f2ff2270878f1a3017634c81d6ea88de842271f959652cc50acf23016ce98dd0ca73af190bdb1bb12c1f9e786ad8afae1f7228ff3033e73eda8ab86f7e3bea72a37e08869bafd35b4fd4fa1dd64a1e7cd34f3a2ea29af0ddd6ba70a279df5ef22f434c21a1478eb33a99722dc09981fdc675e47cea1f9ea02170c9d00af59800966dd98544267179e4e4107456f412a06dafe06bd432b9ede2d3330f4dd4feddf487e3518b86e08663376757159bb710a62be966d5e3260bad43aadf6715464dfa7c7baa52424cf28d3125e356333e46366a66430cca9c9a38ca24f668e00b142e02b99a06413cbca146ba377109bea6b5236eab227dfef4c49e764f111c27cafdeb8e20d06e9ccadc59658f91e99b77dab16a6a53804690cb0ba1787a7f954086aeb7319aee103916b46e9e7da3c3b05b53d153a92ae6e644c08fa9801a1286fd6db4e59730e8b2bc702654bc5015dbd3992808b57332b920cb988d49b6dd8030c192ef830dabc604e74e10aacf59c5cf9395dcfeecdde0d0da9d857f931438a832ac5300ed2fad46a6d0abc0318fc4c571fd5846018f0719a2055930840d53846c6e61634a737baa7835e513c4a0c0989bcea87cc08df7a9ea96441f7e1733d42c9a71d814094b211f9844b3c66c3965b7fbe4a473b6a04064ac9337cfa20a43feefb2652073571494a0a3539480e32f0feab699c65b4767ca5f35c012db2b16fb9a6a9379ef12cf4047c281e3d5e522065c512636326321fa8e48a88bc8ce1fd964eee68c8b3f3ad6393261504eeaf7431dc42bd2437cde86ba4c67ebc840ea8d9d345c86e8b4e700296a2d24d08fa6a3c264f1b231b539979b7323b67bca7cfc6e00f4d57429f06a64d028b7fb01eb45cf476a1f3ce15a405f253818a135c3ea9265d17cd6c5ec73aab9189af436d1e8287cc3b3074a7dadf3ea106ec6082de7e729c72eea443290cb1eebe8c0722947b282c0128d99b3df1cbe45ac08766b70d1b179664eb9e2df962e3a0b34d6d827969783ab22ec4394137b64d0578252421eed719a33c5893a7fe40caad5ef75f85097efc68368a0f85019d83245bf6c8ba217973c34ee9e104488130a9118b399b82b7522a5240b5988c5db7fdaf8e3e50d6fca9b5743a64e958aa2f38cc19f4492f6764fce5554391244cca3394c5e51d25850181c506a3d40964111bffd80bc054be242b06e536843114cf9cd80939165778b32215ebc201ec2f1fb428d081e72fce70076abdfd62752ea77e827fde00b01246974a67f03aff8a4853bc8bd7b897b2c4690395c09be4e9209d4d9977c07fa4a85088884e6265f2901db905ea2f1515e00e764fb7af9409061b5edc0522addb11bb1e23fb58d5a6ecd5ae6a5e10730bb6b1254a9e48b8dc23a95041ab5af026b679bc84543dafa935ed0f095eb453f5de776d9b809b159bf227e71a7dbd1137b7ca238f7e3c25c20c7584d5097c97705ac8957e3dddf4c12e047f6bf59d8df04187c7eb2a32e7ed105257373ccc33c3c195489c7f3d01da682ea58e05bf772ce55bc3391a0630ede34ea0a4062db7ce94db117b71a98c67bd9046801cc74bc2a35ce194b021cd3a7e28a717946c15f37dba916534a251873eec1e0501370f0ee4fe5cd69fdb7aaab19413a172f114994b7633ea37b65b5333b74de429706599dcf516c394a6ced0ab32f8db32a5d097f236d696a7c4fdff03580abc38851854391f5a019b39a5fc415dee61a88112da09eece899a2830247ad624a631af329c3e49bc3c3ec951456b13b23c656c78e2f78c531b56e86bf85fac66808a9e68fd6d3ca734a6919b2ece51ed56c70ee3ec2482471129a29c4e4ecdb6a6e00c77620c972b48e13cdb674a38a49602f108dbbb60ec8ab75855130f079ef715492d152d9706428eeab3df410994c1cfd5ebc3685e746e5985a805cd02975701ec2fe532b21f3bd88660e14db0bd79b85d461424fec76dd697aaac7f4d8579039f60cc50a88e758bf0acf244d767cbe26fc2715365c74c3acff3fdfcbac9b73a40aff80b32a83354557894e70ae30bb9f172bbe566fa885708d060cddfa2ef08f1738bad1f16c5bacc36833a4f3f7ecc13c563d247181963f4eb8eac46aeb8d993fcb3727f02899f99ee2041f33100c429c6f54d6452ff0c7e0866dd82c4768a70b035cad1b672769b6582dbd3ea2d15472403f434fd21b5d06add2251c1856b42527174dd941a033d90be2b204d76b179f8abc303e28a6a466b5d1f79d6e0113092b598f4780168010e046b923469d480ea712c861dd41fa00546f174e840b05a5ec7c3a4c66ae4dd752036ef30a51d52a20717aa5040a8124197908ba6714e1fb037438b9d8bb96e8ef2f7c139fbf44d233b83b7a6e6aad939aab6da393c8db5b0653677bdb032fb318bec1f893b156ce73b1a4879db14fd065b7d30229493e5c29fc1ea9ab68d447709118f719b7176978ee770baaff3bf28ba9e12459f017e0623e60c0fad7d2d92cc2a7b69f63b95e895ebfe40daf3480ad6aeb6a508adca82b45502e8546e891d924f9e97929ad8ad4e6ee0eefd91920686803b084840b889407b9df944acc3bc304c96bfb93e56f701f8d6ebd48a57f5070795afc49b9ee2565ac03a9336aea804544745882e17daec0b7bd78f4afea54d6b00da675d47791c1d5e3a21cbf4e0e5a2095303bdf4313f1f235417780bf10559b4c72fc024caeb0b302d6d5e69f2bbe6c19db90a577688ad2d7442812ad1c1ebf444493a1ef5620ecd0909d814f3cfb7f6a9ff76ae18b361aa74d6deb2bc0149483d8c34514ddcf952beb5317e9441ff2493e025bb8153b734f1797791f04196af259250c2f88e892186492c4719c8939609ec4398fd951f0926c3fdb53de192f4fbdda6f25702eae8b44bc17b6a3c7f804ded99fbfbca9373705f7de7fbcd4dab58e9c1b594bb1a81959bc9e74ba806c6dafd1e3f69e9fa6db5361ba27eba9388a5f5b1dfb32e13bd978b61418fedd7e0b4af383bb1c366f1bbfdb6684dbd1f2d41f69c049a30e383e74705362c5aa769aa3392874f808932c5936b6f01d20741ba6aa686d5bab8767dbaeb02376787c45e9e62e4f0c55a1b832820e1e982daa1c9ee8e854696dc509cef49ad14df6e3126c5410ad68693b707f04ecc18afb6069621911e1dfaf2b98c1e1f0dc636c71ea305fa42552236bbef12661544f1de77ec5592cb830b05e0a3649c7e7281354a18b39aee375979a7dda4f795e00f0ce1c701e3ed17bfb597c70e0dd61f272e029f8152a902e59c099c3e0b672011bec2553995eeeaef583e2809a5c3a15561bd77867286bc94897048ed5852dfd6fb013203825baa98311fa400a5e87744c83cb838b671755b7abbe69a7209bd880ba6cb51130a95e6c693abb1b5f0d8b653e84f49ed6573e6e25c142317bdf4081635ed8b6f22f5cebbd2db25c10e3311dfbbcb5a51c2df79920d10d87d636702967f6932ffc94fb888b9ec0e8cee68ac88904e69503bea77157843e1db8fc4adc523643981688a9c5b91850d084e6fd21114e3488d5c877220d317c35e72740b40aae41b8bb7c4406b629ca07cd47a9c22eb468cb8e2dd8c6a89bbc2e4ac9d44f5dac42a2c9864bd03fe3b7a8bc4d3fc88a8e64ab666888924c41471b2834e51f4e4f62e19c52f86d10d951600c344d6403e0d3f992d4c663150a26d018cec6727fd2c8860a9ea2f9c88e8d09b41acd9674230d98680f1aa084adb495f3d506a7104202916d569594f07f802639a12a4236bdcf22b4a287938ba3d4451077be1bf7c916183ce1140ebc0cfe1876b479c6d7906b6414f6e6f5e09418ce11cce21255038c9022805dff268a039b3d186718f5b1ac8481914096bb45124e3f9ca5cebfe4e5c1fea0234e70d442894ee95449adf5a86d1c517871adebf15ea665ed8e02b6bbdfc43efe6c7614cfc7ade57daa9c01c91969413fc71878ce72a068aeedc6d06ca41f9d5de156dee03494fe85791cf4d44fad9443c793b99a7d3ea0d2574f500f2830953d67598b198b0fc3262fc0cd2c04d49e5fe3fcca83b5482fe9372fb7d287faae507e4c08f9b66c2e74f9246536cd19d0bfa3101103d7bf7ce095bf212570c5dc7abaef5dfec98d34bb9dc56a156cd06c76794101b0b71bf95e5fce68f54d64fbaf45facf1bc31563c02adff7ff1da5d3663558c9963db391753aca1f332625cc1750e59cb3778a1f491111297482300c7e450ceabba653fa8a1b5c3a017162475505037c303a5a4ed2608d510c11e95b56e4e4b8ff095b16010495c3f585a1f96736789130f098b2042574be794889a28c388450b44473f79f3feba79bd47b36eac945179cf34fcbb8c5aabe84f4c4b34c634f4414f9c3096834644cb4025f9ffa26c64dd41140e50ce49de5843a9baf2a385129674625437e41688384c562f4827841e5309f878f276fa36d41d0ddc265f27f5f43bd055898eb218c2334b819ab2ecbcec2f77cca376c44e663abcffcebf6533c57d3cc76d31db21bd83333b7da0c328d9ca777c13687d0431fa2a6b3011e2fd9d4d36dde89d6dca678eb1b0d8b7d51090d5704ee9b1fc435e9a3b591fadc80b91e9b46142f9395f6f5d939186bdd40ba4cca718a47d1040ac869474fe9eb9da75706943fa8871f1c55d3899860fa6ec128501fa907a8e8f6b289ac6e4f6c945c3ac50df551ef48969ecc2faeb5641c7943f511fa15737a841a43944b97e293296804146b95c058e3fcc92c36fc449abb1802958361f279be306d7b4fedcd125150c602bf219d6b142355aa204f40e11652e67d2fda0a0e499d5e15f816e0b27ef659b37e515079137d456b8c869689084d02b8342d784e1bc6b0b81fb2cb6bb7d90cce7d6071e5825530db83767c6603ca5bbf66a35236ef9e73271bc01792bb8e1324bd5bd01a300cb7a7f7fc403c5838804abee40e54642b0e3714cfefdbe4d475ee3612a11eb7f34579e38ecfb60ad086452f430a61e57b63f1dcf592b20e427aaedd28883bf5c7e30fbdbaf8a2b328db80da18c78737a0101b5b1b5425b378dd08c6d2c1a8a14fa32bb8a93da615297a0d32b9692b197f76c91d5d40ac18972601846cdbec693d423535db513f030330adc9ac59ca7f3df93210b5b0507d51b9712290201a14e416a84cf17c5e182a7d27f599ac6837c7c1cf9da4f8f13a75800b729438e2e616da15f64ce76a596b078f9ce98de4af7e2f855c52962e77fb82f92ff3ebf02c0980b312f895b33e5c68aab4f5d8ac2ef066640946d85c0c9ed4b53944a66fb4d111eaddce75342e6bb2b49de6d78d01fd407d3516f609aa3c58a3fb5ad9ecff5c1ad6977c5ece2a30dc63f66b1940e07bc1c0558085569ed3bd6f4fc1cef9c8f9c837075ea8abaf64077487b5b1c9bc3c91052ad7826ebecf112282b8a3c251f72ae0769558802354d803cef8b6158b33146a1b0eab50822e05807e6a8551653942c05ce163a33c4bdc14727337e1f199d3f5d75f3cbc292e350615347d278e94f0db99a3aa50f6a992f8552c6e863a84262b3fdf4d69a34b8923420264d276a19c9fecfe794312b4f66b08b89b1356a942d6aff9fbc439e9c75d207491c2063a7353765da80f9619b66cb8d059ec07540468bc214884809c7cdbd081b1e90eb3a9da41d16bbd5aa16ee56bdbd5c66c1090d45e2254b000f3792504986a80623b028fabd886df9e670efe34fa01f48f4fe17cac5f1ea7c0b2ace18085469f891ed3546af6d26a374b7466cbbf25605dc3f3a136567b42ec71ac46fc0f585808186c7d89be89480e48feea8e99d910a06c999cb8c2adfecfedfa7fb92769e7213236287e554f030c649115708cf931893b318bb7598762895ac8e051d54f4c930c0b5a33377c6dc99e0d9f0f68e77c71361328c71fd4fc52762aac8020434b67675bd4a14f43b2966ab9a35f1a80b61ff04e4042779c170773bf9f93258009f78684f09173139ddfd3ec73e996bad2a373b59cf0d60bcdf98d78bae235ca4ccb6c4b3dbbd0374ea3794e38d5aea76dd431714deeec768a6374df9aea3e281d94d7485c157bfceba829126857d9ed88647663965e70447456e8f7e0ccfa4a29e68981440d98df9cf32055d4f135d1e71b232ec9592a792cc54fc6349e403069ceb0415b393c2d72c7a6238ebcdd3dd97e675960ec09b785ddc1a375965016f45b27cfedde30beefd805e45e5cc989dc5704d65625b336dc612bb7a5ddd1a936d24a5d55c118da525f271fdd8e4811dd58a76896e070169a17f548c7700f8da0b66258fdadd362b7590d219f138627717c6a4fd70ab5c75d0a9304b39f9ffb7eb1bd003b72424e47bbe3af0f0fed5cd57edff2e7a4e9d4767535e6ff181e05d5d24636afb840e97ce5905775aa8abc190762ab68b8fd0f90d4ed8347dc1ecd66f604d980b713039d981b2af4389adca43657849148ab55e5451aff4655640760056437cf2f00fa265f9f969edcfd541e7a3f19116b71b78ba578aefe1f81a895ec555519b58d840343bcc68ceea56a02b29a2b961d29589da5bc9c6243e2a4a713180354a4ec719c815be5287feb4cef218f7e328b5dbb8b12e570f24a4bb2eaea6cdafa2e7faee849215c4d706c5df3508456cd92c6f6425202b47b5c6052ad886acf63d037ece9ab89a1b9125e57f6ca50bfa8e22cb77f76df5809eef227a04b551e12008e060ffc3f7e0778ea3cba8ecebf43b7e0d0179b43e8d2b3b6f0db003c421f77b1397abaebf3912556872fc7add9329bf6b76f0aa6ea2631194da2de757a6620f000eb0f6f76ee7f367f7c65d9b7abea65d45fd660049fd6a719ef44e4085cc510d5f31932e15c061b6188ccad69c49c42c5a2345c535ed7c27a40abe9f73f53df9dfe6b45d311bc9ada1a0b812bb49b81848c66020217f211b46bfce8ae3c1f609055c03bea58464c16bbc6818c063c6cc08f31ed996c2cbc1290b0e7f0bf45833c6f7051360840aa32dabec2d3e18c34a526508897f8c496cbdc8892671784969948c316e4df591b940aa680492bc029ba7531ccd273c5e29abaa24f1e0a4002fc92827e4ca9ed39d132c084b26ecb5aff506a6cb67a90807c3813a75ae79d34c7d44d2b60a49ad77e464d782c1e92bc471c1dd6a0253c4f69357adaeb4ee84ce916047482aec666bfc4663c286a89209e857a52fef0dd06c4bf038f451fda2724d55581489d655ceaf8c0d4cfb5138f27d7c5350ec24d9b8a625a3216e84468ca94b06b16433eb2bbd3ac207d802fdfa2d99990ff4f1b05193d2e3d117615c257ba99ee1c220d4f5ebc98334a5b4685009b488994806108cc15fd1c1a7db375b5a8e71ba57da3ee6df89fb06ccbfaa06475d046154dfbba2a9d990808226482105a7584290a1bd0b2a174d7ad94628751943dccb7dc4f6ef2e96410abddcaecfc3c3ae0b9bc9aad371fb2a7c69a5ad759e00eaedc8e9ba58937c3f11a466062f4e9fd4562192df63384df1c3279e92c081046ba87a59a66cf63e7569dc14221dc867cc0a91aedc2470f9f520a3c8e33cbee1052efd088548cd427b81bc9587db6ebe9be0a26cfcfe7d6940d56bb35245600389452e170abf6fb651135c5a62ac09c13d78abb02257a644f2733f813be08c58633190915aa62cf4b4af67ca04447cd22565ca5624518a42bbc1af9dd58cc1bafb0a1a9afbe06e029a1a21ac02335821947183037e818f50634c585451326c879bd8d12d202513ebee299185995d3136ab1a0209d01efc2e01d4fa413bfaefdba7c12f418bbe6774590d8d7fe183cdeb5f7fc67733e6748418bdd54ea87d6d04e7996eab3ad0b85002d00a2d59a7ef9112a4d588ea9e0075a261ba1b0a22a0f28aeb2274565ab9d207546e01b14778e11d01edce22766a6563b1d7bf64c163d615e451ceb610410654473e22a5c5d500d1b8ed8179935bfab05fce22cdbab3dcfd4d2d5f23143d3ef38a7af650fe9ade6c67ac6ae10d5bd3d67ed0c69d5203c455318990200fa20a6a38d9237b467e05d04f11c63ed9d852ee1b2ca49cfb1022597556467291fa80768450bdeaab715d51bf6160605b9f1abf2da4862ed25ba311092e675b21f669ca4cb93963ceca16ee7d46ef37701832b250f5c1e34ba7c71637683aec18e66b0def35b6cdd6a33e01ba1aa67974d3aefb4b675133c102a7ead1874ab85d324f86ee06d0d71e270d0e99417962f367591d20bc55b3bfdd5ea7f6941c81d46ca706ab69b53930ef89c48f65685d14cca21ae1a531f1d1aae1acc9394cfd46c62c7276f5eac8b34c3b776369b5dd85368c302a9ebbeee6aaa87edf577fd8ebc8ce44ee106b0004631f0c65235b6acf5abe916280169bac9fcc9562fcad121283c8feb510231c73318ea86de8d5dd25c22b9d0571c466f710e34e019c10f187ffd6cbf52c75fd8d5254a61b060d39e0cf6b5df3dbf2286879f2be8dbfa06c343268ae6a4fd32b60c1e7dfa188173126d510fec07940758aebbfdeb3492114fd70222d10410504fce01321f9ef1962c7842356c43e323654709bd5199081462cb683d28f8973631a39abf83b1158d477ff3e26a94a6fba1a88fca5111548d73d51b53b255f453115d02ca3570a5ed5f334127112fe4aee992748bb5a713ad13f322f34e992806df960c96347448edf5b1d9c735721d0a62f38b5688c12f0057d2033a5d6b79a622af6c6e1c14a1b042ced1d70ddcdaa3de1ec5a106235a43e4711ecb86ab1479ccf1e212643d1fee7f0712b05b3cc38c7e30a2c90a3a851815ad7dc21abbc263232cc48a77ef3b54a90e4a4d771f1feaa31b408e4cdcd728c23d5e22848043635c62ebfd5f63dede0853bbc0c057290bc82169f0f5e077ef1bf03f677b4863f9fb9c73e91a4c0a4357f9778cf8ac8c3a0bfb9a21651b2e52ccba161511489a17e525780c74e74de59c9c692a2d94ac9eddc0d41b217487212bf11581a34eb563936c3399af60ffa462fccaea41a553a27b09227913fcbcc9ee16495c659e543a62fac018e079e873c81d36ae47a82db7a4798a62239d9385bac8f36224481e7cc77a07dbbca4b8956dd418d470627c4bbd4a803aaa5a5215f0af32e8429939fdf476b595170a5e6fc1404baa4da7f693b03c3aaaed6a04ea083f3e22b9f64eccef79430990565dbe8792ac0ab639692f4cb32fb900f613feab3d4d3a0c6dbefedb7080f7cbf4708ad864b39d5aba174f94cab84fded74a0bab4de097a769e4e1fea1bea949426f257ae9ae1bd159889c790439ed588025b472721b5babe723e4eb065190db89334964eb3a4dbba1880db12ff2625d1c404a47e709085de5618d19b260615e28398ecd43a3ab19af1db7fe76ecb2b8f7f098e6ece68f0a9f046c3eb71e59bc6af2d7c34c8eb40fd7b93066e60e2ec46967b8b92689f5971de04162a3dfa2ce1389c83dcaaa9a22835666cc9d4f064a5c17e47167d7bc144e7479b26af1a935743bc5e3806afbb5ce1537944ca1ab4d1e039e3876c7dd5cac7f406fc462e77ac33e4d03508ddca785177f154d768ac10e3acf8e7daf7093db9e0ecafc4d0bc457970b9d09a88e77d532b2c072eb629ede67b01bd6cd8db5d7c83694a1c1b4331c27948d2d39fec8c5e06c01eea7d87cf66a3e4b32d553d89f164c4cb59ebd0994aa3c081522aee712c1120c83abc18cb663c7f3dbc5ff9f36013eb588d43e399582f28527201c94ffee61103fecb5ec002e4f33fb942815f3ada1115b75637c92549dba76374dd71404dec8727769d806667b54e3eb0cd466de10f9b777b20b5744b09dbd5dad6e402456c661c51c9c1d4d83c75b745254813616b767ce25bc093af05300283310e837d94f6939e2a116ac0cd01dab79eb4b559141d599fe720e81922f5c22ea4ce2dc023676a1a9b747c309b6701328774e0eeb15be19a9ff881556574cc4483714fb5e15a3a86fd7938daab7a999599468de9d0cf4e2cd65941a3b114cce9e5b8ecab9144d85e5c00320d9f1f8d653749efd5567ad8c4f4b89e0cae567565a566076bd4eb098f4b095ba682d0e1494729aa082ccdc454e4a3a95db0e2717f8108dcb3a741445e14bb5ac623da03dddaaa757cdd02189a2974390c67e71bc78d86922df19a44245e83de164cce3441d2aa0043d44b6ec9c15b5896938215cd8eb99bd30728066ce7cf3c636ae5890cf0f31551a8df310fb7f9160b44faa839a5b6309595d8ae238c3b7ae149374774472f52a96ef793e7935e15b986692ed1b4a76ef2676573542e6c01464d1e66aa11ed99862e2b5cbb86ae1067e7cae6be3b4cb04d715c41bb2b85f28320be12aab13c5bc64983e050f996a6da524152600bf04604d2b28c76fc6fba561ecb92476a76f72188a62eb08dbb85e1b6a8069b21005f7bd38ae4a2d2a4e06323a55691565a7ad00dd0eb0ba5c5eb5d2beea0cfd969470548e3eb380706121d8760dd5e3e7107575b7aea3a14bdef1746829971a9f9ca018463e97fa27443753005602721e89f0119850e874ca7ef8fb90294d9a66520c10d0c946d3aefd02d2d642fc9789b17956505e4df82c33fe41d7edbc19d7c5b57a7fbf8cc796a36f249e93e6dfe770c6fc1ed9d740a333beba4d8e09fa826e99b9491922d5fbbf79bccb0c4943a46cfabe0ed78db77451db82b5d00c8517e1fe6b2beb30f85f70f3a10ab5c6e183fd914ddea3cf4985779e0fd7de6630ea36ed1ea5b124c097825c3cd246d879730e05db3adffb99c3c2933a106dc278bb44a77617aa1bee27656cc9d9e7aed6aa883c21f04ee71b00c0189345aa54e5e8b157bda2d3efa1ee9457a37f3c024f4f2c6fcd1b9e4d3660eef349473cdc7964c4e2a12a045b5b03ad92963484748e48d5a4378c0d10ab550b555470426041cb263ddf828037383fddb82fdc650255d9cd4d74a70fd429ad5caae2a672633254c54f248373886b0c626c438fd08ea039d30f8ed6af6616f0f0945a570f298f671d89d79583dd39f4c65c2a7319a45f9531ff64abbbd5ee90cf70c0960245bc880c7b2d8898be223954f7e816c3fbeee4e13c1b67248db21eeae5f5936839ce5645a7f1119a85ed05643ceb5b84dc5ebfba28e6cc69e2d21c6c39adbb57fd6ebb0347781bd23868e1c81ff0b1bcbe1c19d924b0b3e34d799e6a555dc35f17f48f2cf06f4d9f5286b57e49e94e03358c40df1c304ad3d79b2dbc0577e7537382cda10dc7982181984f9b3d65cfde02fcc26e9a7f6db146ffdc1e2d3b3c441bdae48cb552060de90c6ef241416bfccc45cd1e0e520effbebd9a22134c858dbddac97887234bc010fc624d75c8bfa5cdd2a65fd4fc0e9268ddf593888bfb8b6f657bd7586529538eb19f18424de94fd8dac604dc91834dbb3f4daf69b98993c6a82b8e51bce837ac0d9eb46856f2269d2072729fa4e92c147885bf34b301d5fb951c35125e0ee6b8574bd16e69b070cf6f3da7c04c2bc3bce3003f76de696887eddbc25af2bf02402169e8cf00e2fb1c92f835e3dc30361fb21791529f63d762599e86bce38c98cba6bb3c86c3fe63f5e1dcab131ef6f996dd064c9fdbceedfdee18d8da6808bd8ea48f334258002049e1bbe7f4456489932c9f3c6de5b95b42053e430192b8bea50ab1044252778a15098f57753053f7df0b8bbcdeadcf1a1d2fee01f245f7249fde9ce9afe0fecd9c6e7e5a1b2cdec60ab0349ea4272d12aeff2825e59914e82eba7b3afa522cfbacf0b3ded71efa411fa2492b9aca98d5709b70272e161e00879b9fc7205b918f689b7443b52f3cbda946d43f7c8e2f5420fc91c28e26a6f05ef5a55762e002522d74e09405de5bd5759751b60fa520e75daaad13cd0f81a9cd222b6a083c74b82d001d7606dd8e78a8a1c587f5d2d4a7371480454d4d26d14a11c4f7b247e474332b88ba5537d6fc8d389157d1ec375a438efd30196c323cfd3155b739ac3fa92e406bb65ccc3259a451eceeec04e3726ac9bbf3d4e9d93ae38a1ccfbba5f7001bbe80a4a92af62a6ae53db38a408adc65861f98c91938fe758862d26d55a079520d842a7b44608e68aa2edab6f1f54655998744df724ab86acf14e294cc0d36f4123589174aaa391a2004a6efb852505bbd77c7456b5d67fb0d8d9387a4850adde2ea642d51dc570aa20f1baf91383c8a3d29ee6893f2bbf430064a98ad5f8745b55ecc0e6026fc09c8d69c393e8726e54f9ae4341829001a4a5d1a4ec24edaad860942bf4a760ab0385564dada1a80c585923f229c8e42f2e23b3b3a591acb1d6d8da1a3a964a47205f0fde1dee475e5325853f321b727ce24ab951dc47d42cc887dbeb32723c631d0b42496ab58e6cd2b2e81fd156705e","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
