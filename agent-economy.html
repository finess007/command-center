<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"29c25ac90d2952ae64979744becd2ec2be5fd69e5d88f36715dd61e4b9110b91858de1ba6f6a91e45ade1992312e991eda3e1c80c0e0def0650d25233e150203c652572643bac02ab98415610f88ea4030e5dadc02938d8ec297e42d66914bfd0e71997268f8ddb7ca14836be8770cbd58e8add917fb3b1af5f87738f0c59565361f73119f32f241bedaf62dc9b6ceb1339a10d1e179bae45e1e075eb673440d6851327add5af081f28178bf591f17111ff7acaab885e65cefef4ddf7901bf90da488f6ad46603ed28d09cac9b86be2c2637120167d68d543f1f5b89fe09c8f6b0f61ce036aa7c8b1bf1953ef019a5208a4ca19f5895c952879e7d56f5a9d0af48085d2dbf790cb14f42394d062e6b6b9c22dec252278adcefdc468c53f688cfce6b423c34390286919e72dd87218d72a5a3dd993979879314524896285fc111cc7292960ed1e38f8746a3d6380d741dfed891d55475e8e6bddb7858839f04d014bd7a7617da04ba1d46ddc9ef9d9184dbce46631f435978c352034b060af8a6a5e465411ca69ab109d33a81be179517528ee8d3c92ab5a57d62953881be6d120625a6691f68a711d3ff46862dd719cfac3ce864c55808ec6a47bf60a912f3ef11bd1f1cc890d7061e0155b9e9a0ae15fff15000384dcae1b59dd3415f436420806ee611fb852709f4b1fc530acdffd4690fea5e2419d21410bb66951e93508e479e33bc6faab3b785cd27cf8a52f7fcc24bb6b72eb1ded71383a68c32828fdac853e7c1ca4206854faf2ce5affce42f7a64076ca6b03fb9c878b9a195bba3aba600e48e951a09c79c831cc103eb341ca22006ae1ccb8e231330ba9709ad862061f19583a2425975399fdcb827384dbcf9377ff22f28b889a69c460f6a7ea7949d76873c1927649eb38728a72e8a757ec0d72fc9bbbabf42437596b7ec50110811091830b357304901071dfb5ff5a6e49ae48bc97518d0c40ac50920827286b84b5998ce4e216724a08924930742f67a8f65eeeb8839287913db0a7111a952e55325b95f9144625042b7c9dff47b11b00fbc0e4c21dfcf6de96a6863f7a8ad81e3f12f985bdb1b71a3794ab8306a13d3532e3f570bf945351e63d87e8f55f5fb2ae28100e0ab217539918084669addbc35232adc464a892696abb8c83d2cb1f7393cccd7e773f93460423c19883cfb812bc63c147e52c22e2f9a8072aa868f792447933f4abf0ffff6369f8203025f5f58a3308af9198c78b98610e18ba7b7f76c291aaeae2c9c276cbf2a870fc64a96df08773219782579ba939248a68b7c7fd7f2674cad67f9648f8bbc082acae617e01df13acc2b0ac7789ded396b18d536ec2cff1e04f833c249f14359e09642468df925a0eb283863aacd90bf660aa239e7bcfcdf6262afc8c335df6b5af2ffbeb8e850a87e29072bcec2bd53cf836ce9152399dcf27740037e131227d7755d9a3679b3803fa3756347bb171b14f8f33392268dd2e97fa07a463881161ebb591d229a185e6550fb444a88dfb54aa0f5ec56f9620b33135ccbeaf57928cad49fa2f4a4169f33bd26f3588dc1fdde7bcb943b757b796353638d6659c2fd3e23095bc7fb7d31b45022d8bad040dd6ef767fee33ab61adcbbcb8c48e2e24bce63ec2514a9f37ce264f202203b7a0c3680c079fb8258cb1c841e14a75141051e282ec7e53dbefc047b76a785ca7716737aa77cca8036795bcc5a9a73cd91b3c7aded2ec4efad81443f8295eafcb95f5744784a14c707a3ed9a5408b3e0b4c610da6ebb4aa2fa70276c516d1908dd9125a0c9dca002f64847e970efac53287dab3ebac6c4def301c0a771342c3d605d881ea5e7a904a4a40a396ecb1f3a9273648c820b9ff09bcf67726a5b3179362c8c53d998b05d9f3dd01fc090f965e1b6b3c10c181aa8baf290f101f97482bd6bd7e94b361b85aa969532e33460a762a30cf2e22760baedf0d7b0deaa1d36ca67d8fc6422b347bc8beca605c44deddfc8d950dbb3bf667d3183c313ec966d1baef9eaa8d37fd12420c49105a214e7c6e056851e94789a2934098b7fdc2e19c6fd433fa2787a24f18a854e50c5571e71e704741c2f5a68a334fe2d223ee6be2f27b77eface5766eeef285b1797ec59ebacc37a394ac8e535209e07a723e04c5f4e9176476202e95240344e70d9a9e641016e43123deaa4403427108fd4223dbd219819036af62e36ecab3c359c80ce7c88b5d246df02ba2f39b82fa01b22cd61e8f38d53127e01d785c622d26f918e5332a8a6a4be1a6441dc3cd449e383b94709ac40ecde953ddbc90c5e996009d499ba50ca5a2dea5c5cbf3d9777b3089c526b63450cd2e185a584f00c2a6578c6297984b889996828a15ade76ad33e5711e5badd4df6677d3c07906abf879cd496787b2d0cd79382edeae71823f3ef6bef8e9a8efa198388e1131ea62eaf684856c9e315c83a45fffee1889d0112c539988de5714850686ea331d393dafca3ccea40f546293e2c3415320d8cc287852f5a10d6c4849be5329b0db185d4eaf39e8c8d6a2f1309533d92e9db7d94f82c62f07255c3008f73b40c6861ecb9db81d2cbb443127c099bf9de7c83a6693cf37041d84f8a7f0ad3a626288d6085b946f712d9f2e3ad970acca2df793aabe80fb6314aafd04f36c0838d04418d6bc03094ff4e5b37d79ab7b2762b458fcf9c540c991f38f174642fb57f8b13c9f0befee6904d75bf50e069f2890781571b43c6a6859f98751d259b6319a87e7e971a8c322456059da751cfb37545f20cc84bbdd0503f8e2e775d565206bc6b882c280b6dceed63773bc7a253adb268bf7776edef234d1637b5bb5ad7312715b20bd84ca6362ebdeeeca3738cf9643817add8e496121198363eea5de4bb9b90fdb8c6574512de068042b544c1300dc80eeac19f7cb450799e81b12c134f9c30936a1d75c7f37aee3622290b05b4a7efeb370d16cba6d0300f3ba2c3411153d85cf22d1d51a151bcc69edd53eaf84a273c882366dd4bee1489b8126be9901ecaf10a0443519f943326bccaf904766541424c78ee6c98428b605c95bc093a72ec14e658ad9d22ea3ceed3718d30138af664f541b7c26c75bcfff7091cbd473ee05bc246fac5fe174ad954933e8f536274d8190157fb9c10613726d2a85a21ed385a406e5fd7daf99bfbd27bae1f0a70e24a3e0d043b6c1bd8285ad5b9cf77f0ecba5dc11d3656d811f79ce953486e877b3a9b2f071a8d6e8d08344f9dcd25bf9676c68ab1d65c3b644328d87652de478af5ddc5382b2d5eea73455f6d31b2d5ffcbd53b191685edd7ed2b378fd76e3509ad1b69adaf5f226ec168cc9e3cc4076b4f52953fd76f50ebd648f3a25c340c5dfe0ccfa9a190ad9c919478dc6afb5a6196568fec607ab4286ae17370291ceb53346de032bf1d7f31d690385152713b726dbd85b46baec128e8f8874cf7bf63a44384b0000c7270ba074931998f5aedf4a9a4577b6ccc13d7bf56382395ba8801fa5ee1fc23cdf66b6965d2db479cd4873226d5bd81f675e67013ea5c94b468726e69dfdc819da38d7f4f67c7882c3e418728349abf2c8890a4a56425f185641435c12441ed0f67c4820fcb34e56a4c2c6fdb6cd463a38a612f47597bde7e4d39cf950f26cae11cad70c48b1beb80da811e090abb0c48eece92453a5f4b448624328935ef3469051a67ee7f6d717addefdb11d410799e74f0c0c6b545b47251add2e2ebc23ef2ca7b47dfe47a39f71d6a95a9db60968780fddf91bb306eb628d4a66a6287d6d6838bebd9585b01488d24fbf886d0347cacb650f485f7ca48a331d87d776dc875b207bee4876cb06378b19a948e3cd067841af5e50752b90cccea4bace4f87424d4a7056c92414111a40038bb20595c6b2ef6e7c7fc45cfab0a4d8a99e5689f6f747b3f3dc86dfdf50f9ef2f8f0d0ad411f50f78466dc74379213f9b4bbfda650ade2a701f44a35cf9c81e3b2a5957426ea95758bfb77d13dbcc0785a7bf145a5084e0ba493010209badd5d84d21138120a1432f99f51a39ae98bd26e41498b0310f66d26f03752c76b85061a6ed55cff013dc7246813bcc68d78239382445364e1db0618e3db5325fab1bc1cf96ab0f2003b0b8f720b43e408af2fe09f1a1b8a1bb74d4ef99cbcd41c67dd354d162938b06d67d23292d1fcc699ac237361633515d1a9132d791ddd7568d2a10cf5b3f8103262170652946a0a073e232309f71ec877208589991f4e999dec390d45c4842d6d47a45c6327e7c8ed05ddadf4aa11ee368d5a56a94c9b0ef2a6da6cd54c18f7251a376f38febf906047a3eca47b828e2e945d1bb6c388fd6f7f3d504128a3f274f724dfa557670709f4653ea333367c24ce58908f6efe10307443609837fd20b8918eca147b2edea0cb8f43dfdf46f69fb906f3894db10021bf3dc5997740f8605d5492c6505613840fd719dfc2c961baa89ba09ac0e45f500e95dd9002cd912db74ffa8f163f46266031cf3bbd0a49157c01db942396cbf2a178db9740dfe6f542528865c4b50d8d730aa1e88299e5ce69d7116ff747ccb45ead254fd8ac035fba620bd60a31ec953eb360557d1773d37ba37b0400eeaea42ed1a5068e7725c4666954cea7f5cd3cfc1d4e1f6c5d45e338b8afbcffcf9313e99cba7a1118dbae2bf97359be1730467773a103a519acc928ce2ac6a93790897afa642400de6c614ea6b5265fbd5dff4c19b6de0ce0eb460d448427f0c13a3e0b444386254b5011c090c45d5f6cbd452cd326059e15213e35c466c7d7592f7752ddd03bc6e3c52d68bcffbb1d34a33a83ff2554e15af115449116dacbbeba18c5adde5648cdc1cffd344b2a70e75e012cf690e2c69524f848725976251d425f41667bb2d9797d1a0589f6076d8baf784e65dee4abf2b62604d39a1e78a4a670c216de3e30556d264954ed8e9d3c8bf9678591dfa0c917af0bf6efcdd7619793521b391effea9fefb3adafc5582cf83a31da9f526fb55e07f8f9d703445b2fd2c0aa43850c5c2b1ff3919873da865af4537a096aeeceef2da259602a04c4f436455294bfc7b93b680db9408f3b767baf03da262b74889a81fd12c8456fa4b3e4e2a7f83b860df189b66a063c5eb5ab6ab7eb5a6c282b6c9232f72b043428def39b6a85c824e6c1966683c6cc1eb43c29e0e437d6a911d4f7084daa2057d5897d4ddf1a2ad8736e2f05e531b71011ed221564007c440cbb46ec0a47a07e02014742679ee68adf30a47f9a409f22d5ccce7cc7b9535764a30b47678f407d7be63e4a96e284ca38524a659fde4e054862f15ecfa7c63ecc58f2f893aeca43d22337656545aa793ef24d09198841a243847470a39db27f42d9f6510c0b208dded773d814b66d3a12a5b66e883a1d2d070d869de4554617dbb247cea7b42624741e04420eaedee1a6b0ed66a525fba08f7a703aec239e38c3932128b8e786cd12ce3ff985de34761d9fc52595f83971db6430f41fc3f68b6a3a5a73a54a80c117314aa3782975e16e94bc023250c475a6fa43adb9b29daba8948aa6c016ac7530261bbf98d3b239f4b17ee555c54bffda6b1f4bf14252ab1a36bbff07d8610682760f66be1f24aded1807a5ae62b9924c53cd52f89330b62ff1095525f23735ab367a22f4e69891003c2aed87aece23a86cdb7cbd362d48a98eb0d3dc65b9dc12e1c491c4d89482fb4b1c2877ade31d3eddcbd6614b463fcd4cfd79f72cf9d58a7bbe4a2129ccf3aa8d125ddca3a1dbacf4afadf6b798579a11749808d5b6402f4ec01a1d1296e1fc37aa7bbd8fcbc31d304feabca2b89561023e01af60e413809755321c3500a14200de9c005212c1841d23159692adf566f79c6583f9342dc098da8816b52ed56c2a90bc769f4cf086ccd93481e2ff00c7b89ad5edf38a9e9679473885f3aa382f2be6f5342ba32582ab44f10a72d8e2d1b70af32a2ecb48d5827e704ffae00153bf9530678a44af936b4ea1ca8c1c78f8ad16b8e95a8ae197cb28c962c36c7d33b1e7e205ed5b20782150d7f6bd6a4892a1d0af2b4e1fe930643a24054deed23daf97eba7f29f01aeac383cad64783c3e786da307b474af342ff18c30d69b336af2aa6484254493ed1feb23f25293b0946b9192ba25f3e5db7dc3e0b26b0ec38969dfced9898060b102f6c57031c9fa3355feecb9639a8d4ac9722019bd45a2aa4a230a43b704f3451668e1a8e022672769a7face5cbaa85025241321b952d12f961815d51e05a013e5e60af021bf3b191efecf31d44627c47c7d3c0bd3ada8e0628aa0d4f519725ca1a695a7666628419d1540f1c9e1ea5809904b4fbebdf816e978115399183748f3ee0817b37869be2e6246f0e2e1e9eebb7693f6e295d40fd9ecf25cb27b455f6953e1432dcb7b41ba0174d2aa7bb1bd903bbd0a9c3b1343cefa38d1f541c8909e7ed0451f9a36a47d54da22793577c4bd16d151b67d1ad8b8d16aecafff39b2723a25fc08fc4e7729f816c90e1e79b50648cacff294ba8f300531b3b5f613d3eae1e3e92e157b3e61a159e10bcb8e9a7a9dd36ae032a53f89d895103efcffcebb3467b11bba034c9c7b70812a0b8bfdba05599c87e3f94f266221926eba3dd655ec650c870b51765dd53df5d810293e370fa70d391356d9fb8c89fc445daa0a231a3a8073425b8f9f74fe8842e50b48e2f8492bf84b00b90ae7cc49cc396eade14435400c475192c0d0e8d383707a715c8729442987e7b8bc7bd54dde0713848f1c9d6d2c6e3e405a1c31b43b9c1effc827b6065be711f6c41a076d03f37872e0bec524113c2af9cb643851aad43cccc2fa69f3674a457222f2e105fba3598865072c3d36b50cfa4fd66cd2e78dff1f81099a4f0c8cb09f002762d13479169ae7659478e69bc737b1bbdca4beaa18c2afa3bd41f1871c061658a979e6fa03f415d89b3ea1e2a0fb93936ebfba231db2660d3872ad1c1efdd1b0dcc54ff183ca76def25e974364f0169d9fbae6afdd73c6247a0b046742b31c86e8e8bff7306b3b06179546f40cfa981c72a3c96f5319a9c8b69a86f17ac8de90e455260e6a3b86b5b6657fd00572f88b0ae9e2afdcd1461e59920b40aa654cec608d01e91b8a3f6d0f98f9bae784c60c971c54a8ab5a3319f4d945a258f86d12f98b0cfdd3ec5a8580556149f9e737fad2c64e531336e89e9003a10d055cf68f8399dc75e1cb29f8e940d577ee40bbc0256c8b7c84e859748b02827232e7eb65b6d66de4e761bf762c8f314b7cb999a5819699c683a9c03a3d29dd6da1ecb9ffeeff625a7ac4e740fe53927c0e603d478fd58842fd30a5b3e70e9ca475c587a43db3c9a08f131a0df74d97a7fc8f0b12937866225b7a7cc590bdb464aef5782d8bb2cdd18748dc30b2f3eed86bf5747546ee18d77949958267d10e3cf842e35b92bd655e3eec468b5c31aad1e77a0b07b65c67140b8b7a8694cfe77445f7e7f677c2b4106d0567ad3ea65df1d2b1b365b48c81c96023b026e65fce9e7543ff4e8f14837463728e7a0aa240332091ddc5a6b1a229a4a478f77c76dbd2507780dfdc4047c51c1b54bc0b09fb656be5ba7879641c63e46ca64fa776ae9265564c1eb88bc94b43b5936cd55573e048977f3055da889f5bbd59472f0b63d2a878a93d9dc9f3ce74f32f9c2041e007e88f3dde3da2bbd3ce0baf6b28c71bc9d65fc1672e2852696803bbc5dfdb6269fcd8f2d1c42aeb702b0b1cc83a0c681762f4f1555b581a71d32d8a5e6b7b399babef3ea651f0e2a8cdef450268cb09fd4c1b6241ecc811516e304d6132c8bc4f27afe6b8f3cc3d1fcee9cd25c14f5fcd639dd1bf180f38aff1ae37dddb3a999875012568a48a03eb77f4871a99ebfb8db792009d01ce6fc145ba86bfbf09554db7a4cf16801771b85dc93cc6ee91fa0f7a4290fe3dccc30bff67e1840356f90cfd8539ec4202693d6a6b5b2da8f734b90f52c8260690e8f65e72f4919a6a474074dc2ccb173e3298296bfa53ee13551494a4ffb6b901dc37e7bf0447ad83ea960478637bbc2403d06ee975a7c0efe1d22da64e8063c48e3020bab1ec68b36806e9f186fb244929c53d5b2d648661c2ecd01603d528fb95ecaabc3b929f52d88287eb185ee8edd36910702b22cec0b682e440b26cc05193ac39574e14eb0b4bc4405b5ca3b9c259de8765a8effe7d2c8b39afaa06e63825410b1fe6532ad0cc768379cae39d8d207b163f8c7c3bb28a6a64748528b8514fe19d8c606757a192c019aaad7e2e44969522e94212a4c01eace9da1dbf717e38f40d79f1aa1d60bd67f7e09dec4e3bae5aa8dd68b1b69fc6d42002dbff3917138260086b3c1d61c589a0c2cba6db99785bc56e0293a7308e277e937b39f4c88b8a42de3e4261db494eeaeb2d162199ad71e86f480453d4b1f4f39d0059e428bef7db139a7adc689345251deb2aa8bb9417a143306015663339c6d1030643c6ac57edd6b373133e2e18e4e2d5c398b799995f47fa8238270c72c24c78e11f03c113c5eeed11801c9410c7607b237687642e32c7ca189141abe2dd37e0c4e7ccaa7c33d99e4eb7ebd19489211f07860fe02a42102117a4e34702bd4e392761a68da72943f0dda89f44dfaf42819588f09d7cf097f7db99107f56e903852ef30b96621c9432e45bfac2246142d9d6f74b407b6f9b0de3456709f43a7d53b919725a0278aea906d6b4a1afe0291b959117c7d24aa996b151aca2755a66b969907df478738c1dca50f776cf10d14ccc009fed3beadf95affafa75573ee1373003afe63caa89ab75516c8ea65c0ff96c3ab160030fc92fc8acd6d4e1bd06dae11aee416291cf6445485bd94f0e23e96f0b49e5d4689456544e20cb264a73a8251b697c4348fc016b7c3dc0c64c713157564feb7566db12d1cdd5d3d81581ddd12d7c4222f35dd85d53b9fca869298b5ccf53b1ec2f2eb1064cf873efa82ee87df38f54eb58ad85a1d244f57238bf0f1d484779f13f1f2b67c6b28239a3a7e3ce5dfe85687bc96dfc7540e90e660cb05186812e3627f06c4d393e3a6f4eecdaf3339a5c0e9146e0cf1192acd96c49b8acf8687ea7cd1f7c74420937fc007f363ef25e8de7a8ddf7051212255215b306a0aa20a6005ec18ce6df42837344aa6424f432c00c430faf619a02d457e498c17470730ea310d646d9c13d9ced3bfce2fba4cd39d56ac7b6fd9aa3deb97f30da279f3ca6b2db022f05a9a30576574de88cfc57d7e956b2af5b30bb4493c0ba2eb36679cad1371f3a79dbca863754e20d9a612e7ee7e5ed8376b5f61e1c36ccf6e2d324c086e8d58443ff87893daebccc7265facc9688625b70e827202fdfc1ea8fdaed84f5bc86681acacffad5a436568ebaa3b0d96ed7fa3fb2324ba9597157833d138be744f2d0df8bff42b339016c9ad5fe340da3f6203b614dddc531074f0de13b86ccbf1150b145ae51c9e8131823b70db12b0a235f6dfadf1c4d96e46b04e5b80688ca79551e1bf67354786a27a1f89e31b82d300097397b2e4e89e5fd4266ef4b90fcbdc5da6354419ce5c9506bcbdc7ee5d24e5e16d71fa8118683c658704fce54993241ce6cabcb10a9902605afa44e0239782a11b9d9939ceb9d9e0851d9b9dcfb03ccc405f3763f052031d4c0913362441041d73408fd6d004f16b805f7cb1966a2c68fe25b6078e02f2f82af761dc173e9228e9c1d478a4f767edf502a6990c1553de8c42c0596f206e817a5fcbf4a211cc26737bde7b96f05b81499ca752c4f7c4da74ba8c78f9a2a7f24925d318a49deec325f0ae74a439a98de36c2447fa22be52b838697fabaed2e8222c845c53c0a677da83e0433d2dee4fbf4a42b8061bd65145b0a32af10eface55774eff09714d18033a195048102107539f5d92168cbd20e173c8f0ae070c2c927d4d44bc61fcac5347f872bf6220bb9af13f04eab2a5cb89bec656a947274b15bd8ce5599fc6c0055b446668dfe3e54529d40959e2b3c5264b43a44e9989cd2b12ec855a2ded6d4a86d505774bf748ff42fff8072fef56dcc35f89f6aae48083ecddb8fb50a0e231fc714fc9b663349300140c7dbe90e21c5175a24d45f235695fa37a41883ea82548d703f7dd3c5645e84d7c7fd291c1c1a308a03ede0a48e5c5772c1d19eb64bc37fb8985341881c55f4aac161f727e667c9f95c26864569993f7ae8534d19f4f821746b78fe935db230609286bb3105ec89ed14ef3517db8cf727f692ef30149dec2c060ba1b95282acb0c37be2009a721d91b17f32749f0806dc22b0f1b749640316527903cec36e58309ac25458e2cc32c746c23d2caa66d4cfba2f4f86ae7c0979da99ad583c86f55acddb37e7fb8472d7f3d06a0c0354d2c14c368e64658fb36e8e4c908d3023dfc8aba05f4370f2f8b54109adeb6000283d8e16c2bfd18771f5965bf2d5d5dbbe0b62e7a1ba6b8b5294249ff930d1a334db7a26f1b710511b40504d0570d55e97fea1a521494dc9b5ea91747cdfde7eac3d3793469fdc0f68d107d01c7a0bd80973f31761fe706f7b0624aaa3ebe142d8debb3af36c8efa378867d89ffc258cd05e00dd7030079d0e090ed7ded563c2aba18ed38917796571ab1daefaafaa05c46178b6162a676b4495623268240b4c13e6d441d6e8889fc045866aa83b5ee3ced823002df7e3d0caea93303d0b3fe147bb3f38892cd2a76baff1daee1a75b4edb1f0230baa6316d2a1d938d141daf1539cd8a33174ce112000ab0dc9c9e7e935f9dc2a9fe956f7766357334f8d36a895e9c40a600c0428dada0d055a698647f553fd6fb9206138e7b994cd4f8184d845749a6d2be565ce699ad559899ae8f7c510fdb14c87eb7c2a7ade44f3045a1ff2c9ff6a5741892bceb2360ddb3f98b13d19d259af0c43c754aef158e6bdb4ca87dd01443d23210b5ade27ca35dae9cb66759d00ec9a87853ca56188d98527ed6f93ffb73054f69abcfc1165778e7ecbf77ad9b782d78e1d55c87c67eb2d4d050aa670a52b7aac69fbcb49c13698e1127fea7612a246413c11e6533067e82ec8d09b9a8dd368a28e042fcd1df38bc0f5c2838a38dd6f06f1a9fea10c9cbbe9f9eb25f0fa6df7330aa7bbdbd65cd6aae12367985568e337b5a63d2b555cb406b5ea98570dba8ee448f1c844a069967fc5788210c32de11dc8d31a6eb3581702fda59bff10bce0aa6c8f045573ff84109e0bbdf14d1658b97031b9dc781a46f192746cf652a52a01217ebc5245d0e012fb7518a59a4ed4d3709c3e75cd88748030ec1050c6d4345884935ed92e7082e35fdd07812563e8d01b826f3af10249ae62400c176310b17e1bd88095103b9933064a3c077cdf8e978911f8283880662ddba89a85944e0055f11bc1b74dcb2c92219f4b5f10e8c7dab9d85fb266c0e5577eb6466b87f52af737d48c3b53b0615655c0327dddf734cbdd92cc028c3a9cf043056c39b5566d8c3856286cbfe7593362b59668b03e655d6de16c188f62fb6ed4f61c2546e5611d9ae9b1e78fb3123d8b0079404f421fd3b21d1c3b37b6060d40c01c230e863d087559baf24862b964a26f8c90d0efdeaadab09be1187e6f08bc74cc3c60407af00209e20b009d905c797a8f9ce2c70759e5851a773e148209a18499ca0930bf0667667466496a7aeb41a93dd03ef9d118f185e9ea3c5f6daf0825a38cc3c2c4f2539518a32f106147b46cfe88e3ef3395cdb52d78e23dfd7775c97c8f124d454b15e4e401a29caebe66c22fb259b54b8720ae1d5a5418504abae53317d1d3cb0ea835abad33c5d909b5e5b739d80876658e8c816e9da10a55dafb4df3899bd0820cbfe3d131d7454b31603c0f5b64d05e2c142d3dbc1a590c2db4d1d801cbda04fb67d667a55f30a00165b25d4c725ba71c75266d56f95fc0fe85fce94e041b86f7ef58ea45b8c09bfc1296092bc783449336e76006cbaf2b26ce143d0cdbf0774adb723fc83a3e1d48d0cfa802c817a0297b0b2ba16edefd1a098e6662200f11d68dd56a3efbbc21b594b2b1fc2c9cf577ea2d6a180cea07fbbcf2c6ad86325046ea8b12393c8f25dd58250226755ad8186018402239c0de979ccd1800d068e18de761521397b857f98d7c9836668638883c6227dae7ab71b51d86024f6bfc202ba13497e1f5cc5bac7bb577700422975a5fd47c874ba90e17447d4e73ffd4f96d83ef12db89b149b11aef8e24a40e866daf86a2cb0ce627f2122a5796a9c1069cac4cb534097db7586f1952b72ff36a806801e61f413ae97198b3b74db4e979c73a9abf2b789d52d79cafcde780e765e20e7adc838ad202a9e1eb87bd7ff8603ed34d81c608bc32d38e484430949c4218328c51c37f8a50788d48e0202b96628a0de2ced26699bbedcc0479ef6e23c9a6e65cb4374856d7596bf6661e25e071c06b8241b116bed4466bd8c77bf1a2bed0e7dab64285a00eca84b104a33e5001c0c4267c1ed719790046c8091832d34bccc76b82149a79f23dc35cc146ff255f7bc813e3e186859769d0a51af86b73c76783e5aacef675450652b20369859c05eb1739e3dfbbddbf9ba59e0746eb32859457e40307e057ff3e4fe04b4cf4ec6a9c133ed507f2832d28bef5098c301be2b3a65436f518946f617940c6311a56d5316093645a557fce9a458fca75dcc0b79011d850bd51e91471d552c4d73cc4e769775175fe8029b8348953d9e90a35cbcb53534330899974acefe252aaab22e5bec8f5d25d5e842609a39668303e55a52e04ecefe09b98a4a3864931d242871bc765c419ef923bb572291ac0ac536b2725edd3344822dd14f65af724912ceb1d46876b836fc87f44b866a8370e540c330656750a4efe30266143f8711c7e3bb05c0e7c1c9d9c15fb59cdc6dff54da51fd67de857996f43d406aa6990ad44c98f770a65fc8270d6960770da33e702c745d9a106dd8cccf93d36bd35db96ca4be79b974984ba79febd9333e45120126777d1de463279094d89fcf7158356078cadf9b8e35be7b237329ea7d6cbbc74afede6612d9d4a0bbacd397c2531961f228e52538facbd2f01b3f848a1566da2926d08592ca340be19238fb00c2d73024de3e1435f6339ed4f2025b3c38c13902f1af85454e9d46a2a50316fa52c7d9653d8e04a90dbb16a6056d4e129ae5a207a1d3bcc1fc7064f4575e063c66e95917373a653a878e86f74067f9f87dcca68e18daeb382bb566dcdf886a2131175a0cd68bdd8a77a68449fb2d27bfd075d4adf2f132c6cbdef1548d9564f9cfc29e060e4e805f14343f7087ab395fd8b7596fbcfb83d61b091bb8a06b0def48f7597079b4ba737485227be36ce994df7a237307fa4132934b1a515344b0cd49e7a48d87dd1bff877c6150b9e7129537190b0c89c0b0b3eecbcb45ada4dab2a6b3d685816103c6fe026a6a73510bb71b2b099a5d99ce9ce5176e0b5bade0583c80ce4d4eb980c4fc2901ec8fa683d95ee29e570f2c94626898df1ca264ab438696c5d8ef745d3b2a77ef2f8543842db7a5bcdd9bdc19fa0229740395e01a9f8e63fa1341d6f448c5542d8326e9721612755d88a7723f980793b7eddce25228e010ad0d6264035389de38b9e340dc9f1d55845aa501cf4defbe328c1ec6221dd34ff393a1bd39656fe58d392b51b4ef222ba5d839118e46bf5bfe759331ffd151f31497e1340c92fd98777b7734b911d2d2498da965f9f74aec76464476200eb0e5b4f295c156a250a87fc0c1b06432fe443049b283156ca3d0baab992f4256536b9afa5140f41d37817354925de1de20f0fe1b351f7ee8764747b1f893dd4d71297e1c4beed0148296f45771d42900d680a65a257d10262c99607b73601eb55ed6c9676226c18307736f226b2cf5578dedaca05beb03f1a3a07b172d3e83ec3a979fa3168f08afd256bbce95a93853a50be7fa03102d6bfb7d1d2cb75d94d1e92121bc044036e51d0d3900702cae3db7702326c7107b967da9c991941b7b001c5318e1efc9e5842cb629a87189a65491a61014b6da56d06c2e885b1325631cc3a6e5a643366b84708a2656c5aac34f91f6cec008890fe3febd63dbb7689aa0f1bc76e6407be1421b75b9dde63b7040e25f70a97657e91b06b0cdf25fa19952be138df7ff9b57c7cc743a53c5fc3b3675e9278c099e3f793a601aae21a740c0f993d4b9bc7f75143500358e7a10f2909d04ba01ffd5bed2cf4ebee8512ebb3179a63371a720279591cba2edab9925fc30a23b6289c2baea499c3983abc32abce9a1872048a26d2f01ca4894dee88d230138016a87b29f94ea78b442ec2a2c4ce2bf26eecd439cb50c0e4663131532bbf73236dbf0760e3edd81bff43f3d4b2c4447521e3f8f3030537757c4b39a269724167f0aa4943bbc4f888f8bc98cd2f5402648064731659a07c3356d3f92f929386f4bdbe3939040b35edaeebeac0bc67331072f695dc3fca7da141d02977b244a84b3723034a406bc833437ba8ae8dbd661ac5c4c8837166849fa3f3a3ea45174bcf42a56e0f3be9b4cbdf6197a076dec83ebc59ed4d8bd50e741b7a8c8aa6b6b79de49fd468fb1cfe9369af26a6fdbe1768d2c79a057b2d36086c1b511323b2bb3191b4ae852398ab56cf1b60d0432646ae1c46825a08df72e2124e85f3e9f50b8d0d5f3f088fde6b70b44c423f1cf0fb42ef036e0e1dab33f9d98ebce65a90b511fb34db02acd6b540bc842fd7c1f398facad7f45cedb98e3bc7ec27f1bdebb9dd076c3c176f0b40543078e35f8318fc7048aa1a681f8dc366a12ee4721bd040a3350b355024991e6a8b7d15ff6a75bc995d06df66f8466fdad2c55ad5ed13f2552382d293e88a3ac7308be6243da60504e7f1142a3ccd58688297181ba38fba19cfce08a07c8fc0a98c07fec527f1d040479e72a6524720e1d1c1912d815507b3ce878d700beac9327f0f761d2d4eb7691927bba70cbda0efec3c02126d0fe75fd7f6327a5f7500e5a9792bf6e7111067c631f05efccb3fc74a96ff42c57fed1be51c20c6b1cc3bdb9cb2802d08819b99404bcc87e388789b660981f7b106e8be622d0a01921e29582e6d04cbd476d657a65909236bff7bb6a27e2a3daaf695c5d79c82d730bbbc97ee11252f62578b6b8d4a3f390814fb6ba0fd8f0981b22e76e08504b3bcb19157e35eb7e5fb6901f957ad352d6f3f0a29457d34196464bf8146e28df8c538f247d309ad11fbf58d3b4f9a3b992b56e28a8a95aa6ad02af46b1b432c8fbab3280e3aa79cb604f33db28cb4b8f0b3520f2948b101ca8e2490f787794f2675aa226ee173bb7328e3f79e616bbd23cf997fe52688940c1cce05e657b175495b8e4a2d496fec19e9555713df942ce86f9c4b71d3ff810c32e8ff1a54202daa39a2743b95da4c90283642f23545516575d201703ce3ef2c9a8700fa88115bd09add2de4165de855dc58b4c1a78f53ca8300ac6fd1d791dcbac23d0451017dd3b042d698f6c07c9ae3433de93fc44f46145adac95a9e2699d88b940ae10beb4cd28e6cb9480a9568c5ddafd82af7d976cf69372ccb2cd7170462e676fe5201f7df2b63e41e58582d3213a9a9bda8f833a76177d05daf1c832dedf31179671e83bbd30ff8d345b5b4e1391a93e1c79aa7873de28beca0f76562540f1cdaf9de66d942fffd967946b70e7506a064d3f5c160b0b460a255ee30e1119ddcbfe169d99387c5bde56c2494977307ce55897ee51a8db58c0b460fa720c8d4a3506cb6827865ffd7851530e119586a16d67886649c83c0d0da800a481447dbb45f2d71527abd019e4aa2bbaa57d88f6704381ce35fe9f606353cd6be8f8002c694814bff645500a14e22589ec58cd2343afc03404291691a9b02f393797cfbab01a4a1d87c6ea7a96edc2715e7ee8d727441ba2d7994bba2d01a6fee3edb2","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
