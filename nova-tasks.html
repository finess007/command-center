<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"35f4762376c79d95fc07d71aa012aaab38e8da2ee6fe081f9686b8bf61332e2d4041b0dbbb7df09840c35a6c39a2cee26b81daf55792d00fa2f3a4d0916591be19adf056373e1c48437d0079a0db32f015b9ee2831b1e18cb997bde2c57895d7a743b7ebc8409d47b354c82453e28f3ddabbdb8a334c4b02aa07f8c39c595973544d2c940a2657441755e130a8338df0c84265a033ffbd2ea753d13cebf896c1d22bbaf76f644058b5e3caa2459a7563ee231f1bfef26e8b286769c29ad17758b7f8313e716fca3dedc3343f1a7df4deee697b3ff1d3a1437c283b2da5b88be298750661ab9e780d5225eb3912fdf82fb6694861cd03cf10165c1fd7932bd5a5589f2e18ac3bfcc6de5dc1e2226119a7253bccf1d9e11ccf8d0c5fa8a660dfe24c04eb2a00d3c4f9762c24b0c56cb4a85b9914313f3758dc01992d2655d168b873d48b6441571e87b46d8c57b4c46f3f7105d69bb4564b20acf6cbce720ee6061709d94e8f9bee492b0b12209019a69071d036b8f4c6ed36f00af01418d5f7ce0a191bc816bb57db28b286dcd982fdcef4b66fa57da047cbe689264e8c54c8df5e46ab6203a856dc7e8783d683d5fa2ee082736e35e3b0019784150a5ced7ea80a88729e110573270e5ccd982a9e344f99a066d581b629acbe69102ad8cc782e943e4a00bb7454af60e075c80e819cb47fa60ae6c6b5853e7d41e6bada16928e07aaf999fcab047722c7fb0033e42434b44a5d6491e15b68cb37a34fe94a138a159b35726410bcecdad94556ace28811f63b3c257e00d23e88f613b6d77ccf5c704393b3eea0d30dd81610a3c627072424ed8109bfc563a10645fc2627aaafcef8f5f34c4f4242111bea57aca3ac80e10d0d89eed14dea1433b5b832a5ac61ba9948448bb88a5bb4367cfa9fa23a05f11d03c1430427dd6c1094a9084ae960541bc9477d077fd7c65f2932822ac3b3c61187fed673941b1f297baf689f26f3bc3119da4709ed36175103f8763a7717631a4785336100c51adfa3448ccaec6a82b57e5c5c860035a064dc42c2d91ad24b9e8da24d8f08e41e76d9eff83c2fd7380d492f9844a936026ca766cff401d9ea0b4e5684972cd06eefd395ed29b4d1dcbc12dc9eee3dd9c1240ffbc63bbcfd59b2efd0a2d1adeb231ea508e0e355e087d6e6457eef8b25d49f9f53854dd54b26eda0aaeb47cefac7d516783bcd99056ceb1d02eca1ca20f6dced5d529e3e7f6367bfc08912b7a62d5b414b801ba0c094de3cc1a21c0b12d482be3f8d39cbb1224ca82d39f6fea1afbe6783a2d894fc92c0a382515a617b719a79ddb37ad6b4208cbc395f10f8dfbaa28f4bb791ec5a6b0764f0654af449f1935ff647f235b61e6f392c72f7e7303b399ec58f0113c9e04cfde6e666e21d3f2123304331c6cd990359a88fe3189ee30066b88d491b3dc58d8174f36b896a40ee620fec5c01bb5d0ed70f64babf36d590024be566a663b31ab7da4695cb92e4ac0c99dac83a6cf50d76b3f831921ac02d8902b528091f9d1d3b535aecc8093999ec8a33d1e6cdd3f799a7f72d9bd16eeee6a1a5d3fa9b9d318eece8975204fc1d2b3b2bc0727629779a9577e048af484e8fafb4910ce444993b3f351afe299c20e16c1b0faaf78021334c8915e7c3475fb15c327eb5f2b82eb716c68bdf58e6e1b6cc9460eaadd2c7b3d43b1119f6af72cac8d38104fec20dcc92df5e648f5209910ea4e308861d5f2f36c9eb2e549606a878fed3ad8c67316353f0fb4656fde5f05380a1f7fc62b15692cd0fd8342f6205dc307bae5809d8750f6fe951d9eabe5d6ca2749c58558a5699da4af0911874accb1c061331af7ad91a7f47b06281c9c3789fc621f8c64b13e8591868495abaa8b18e629e6e45ab241e11bae666f3f8b36b9ae4ad07f250d7ab127c73fe8051ea0f87e34f0f4153e175fb96e6d8f94147a18a85d0d286680a49fb9e666a740cb64555280fb3c4af900583d3371fe29c6375f4e7a64e9df04c3ad4b8f1b9e29c81d2dada66ec9df76bf3433308dc0cab19d8babb817eb7ef3c3c1651cb59e5a287d76fa648d02250e58070db659003118222f2cf1045943ed1c373654f8c1a8f7a166af970e9d57483b403e3252417c1d7b779ab04bdb1a94071d621b10f931090d9d117fd6f92e84bf92c3a05de4553aabe5321431a54578199a54abe6c128aac8ae2f0b1ce5b17664256f57277a1409bf720ae35274e25c12629a6b2ed1ac542cccef2752caaf377640bce596ee205e54f6960891d8746645ae4577fdb6c9c7abf86b1c4c389973ac68ebcc9d8cbac8d154eebbd6175ae735ac84112fce40d8a9f81935dfb3c83063d02db775241c83e217a86b8023dd931c24ad267fc7a98df17e6af8dd22eb6f2c7397c64ba96118db446c163d2fb1acb1405a33fb08ebbaf94cf7c481378cf6b88e51502cb0358127a7da1bbc313581b9e64f487af4f1d7c34fd4fa89f920a8a6c10cd1e41c90026b81d3086d83524dbeb62149cc98e00c24d01f414b77214f854b86426e564e70b5b28f1cc943ef2a7a2a0512523ffd06285c20f56261895b4f77773cd41c1b1eafeba7595f5b06a5ddf235b86e2719bcc3f6c2a2b6a938fe2f368b7e5995259325347613729b97b0171c2a246411eacbe03c473efad2be8e5c2242356dd0f7d50a4c8d295aecccdff3702329d8922d7392c7381346a4fe6df010398e36997a989e6afee509e1fdaae31af2a1ae03caa2756f44b4587def8590039c8bd6c55b87162d06a5409fb964c40cb4377dec57414f5d10f16dc43a1078472100fd51530dfdc6ca18fedfbced3cdd3155df3922e07a1b77668c71719500707d9f72c19d94500f23110ff8311f3c935cd7b535f9aeb17c0fa35455fe58d4618efd00462ff02c4b3d4f06ea2739b957697de62e212094fe0bb1dca92b3009510cbd218b19d414b3b9b3cb1bdef05bfacd8e41ddce5dbd9ec2ce0ee1cbca0d5888056f69fc419aa5436c19a7f02447b0d44b06a9653fc2d13cfc7a943c31be53870a9f23cd2e368a12cede812830fa52f354869d86553e88c05cb4b4ddd09c00bfb9742fa1b354f595dacb9f2574bc2ee5c4335af66780e3beb16c7be01fd17b589e707645d6ac8f635ea489975fcadc882a7dcb1f4420268b541ef619ce4d38d92aaba5d42df14f5cf065e2670baa6cd32c9d11e0bae977b5237e67b9a8e6c6bcd1da7cf95f4cd7ae92aeb6b3f5fb12f6960bc0778e4f898b8bc54d71901227acc6e3a6fd6dcc3214afcc35fb3984bdecc1cee4c7f4ac949c7b95f1bb1da1e2b97539202ca03b9b3f6e61ba0a4efd74ac85b1843200114466d6ec668eb1eff793e69f93c093a57ab7bfce84cb1dd5d87a1a00766446a4872f761795648b4a78895f9891d0875cb6b051f56e4a55aa3c927dfee6039394bc9a0996cbfce28d4a1c47a4ccd2c30f05c211607e7ce9068673db76a96d3cc4a2e0fbd8e6f7d1c37c46dc6b64e0b3a492bf533aa0eea2ea20fab245cc7a7564aeeaa76889a3b842d0c5ec9782286954de055cd0a749789024aa6aa59c529d877436e5af891ddb42563933e1dc38f415adb6dce91983e4c1f4c16c5a6c1aade7bec28fbfd8c5ae98c5fd2720ff7d88c4d2635580fce4af12919f538eeb71feaeb2951ab00a1d93bd32151c76efebb118fd5e2a07d36113296889b31ac1a11c9a466fec1281b7f83cbb291eb462dead27ee3ae5d6df6564bd49898a6f25970d8ac2660fb3c73371eda19aeef26c5a6c49b76b644dbf54f38a5befbd2a500cc92515823ccff75eca8010e72319b43427636ca848c5826d3e08cdea8bc6b06dc7275b331f78a590c23c76d49b08b1c739df1613a34744f38e6ab71120f9321e6963477cdb2a9968de940110a02a103cd377db447f8ffb0089345191cfea8c856a5b3b053a229e55dfb0e7df1c4ff41a59dfda76d150c202c659774e86e7fd391ab6647129138c3b037bf4dc7aa43613b8198cd9acb6dac7ca4c88f66842cb9d9e5365d30466f01a6cb9dfe1c20aa089ae44652d0e774fffb81cff1c2c66733cf4db0cac60febe23839c463e89e9aa557989ab3a9ab846ef97f1c0fa5e077185d1b8edf8845b4ca1064dc518afec506bab99c7adc01796320f5929977f12044ebebebc1a089df0609568ff0d8df9c28d38d2dc9d350327527a645cdb1beda77ea5aa9793725814d57d7a21150a2e648d3fa9337cb672978d0917d06d6bd45cb3ae2310b461cd4ef54cbfd9c3cab55e4b443ee20eb5fc4320e71bbca4549fc7d98a1d82015c7571fed4e4950bd0b77c97815584eb3c5179746b012bbf51264348ea3c4bb0a405dc0f5d1e69ebe4496a1a3bbb23db6b2997debbcd2b0d5734d3ad0cf3fa0401c2d09338733910c680c4628fb41a39087b72ae6ade34f47b66e39215aafdb67fb41ea29bfd63ed2673fe106952f78d671078061f3865a3a3e6c3692d7b848e0b5ec4570b4657ce33aa59ee189c8348b27d784fd7291f821e3f6a4fd8a22702817fc82fa12ce1f67e29c942ae006d52fc3c728b3808203fff84397ba061dc57ae165382534427572853ee0c2786f75c4e43dc8154134bf10793024237ea595edac551a71366a5818fd3fea08d3972e9587527592770545d01f19fd475b092ba26c544c55056113f4bcc0ecf6d2fd2fecfe3d3ba3b8aa622dfd670b44b6d941ff6bbec23cce93a2a01f82bc48bea71cacc0caa962500181b02a521887a65340c1107824e5981896eaae58e095ae2098b7166f37aa93cbee4aa4a844da573063bcf7368d1e2e6334d3f7d9e74dd2c4f69cdd9a276f6db8efbf8ead30c71bc78d38274de9a70fa8ee34dcb0a95652ff38e9fa7eea2aeea58deafce2a800c5adf672ec6e9cd49cc7fe086d05d55547f78c2bb76827f32efe37a4986245c8a74f2bdf5a675ba58928811952a2d25442c9652c4214b860a1f6b36ccc83b6e14f4725d38ab1f90bd0c5cabcff708d124c226fdd61e17cbc038497b5441b1d0523cf14008e9f6b8cb53835c6440767711e7f01ee954a235d082af0661fc623cd37d59b0c6c31690b3bebbb1bc68d08d089e2f130311116e3533e3dfa58d3fee45e7695dbc9e23901cd075fef76c6cb6c78013600ac10999e875482f2ee044ccf0e2508e39831745e44b1f6717808363f4d55eb2fc064fc0576dd8c88f0745b9e5dde3d50c02e8ad156dbe9f34aaef6a8ad78a3fd31c153f7c5e5258c89a7dbb00351e96a6044d8ee40eeecde9675ff7b56098cd5fbffea09fd3782dbaaf66e8ba71bb87d1db3b985c4c9bf873cc996e22cfa30f24d53c96f6b62eba37c6c43e3a12b801deeebaa6d5a112480a851ab7c69521019bb7f1d4e3374a185f0b4495a32a76b17734b12bf4402a39975d54bec55fded1392eee325fe03c73fee5525eb9ba08da4a5ef01d6bc60f7a49df0c1e7a00618de780515a98873d01599b5085bf3478a0fbd0899db5de3415d8712a7bcc16539b6c65e96affc7dc591ed6668678ed561f14d4ac55d3cfafdf25415da1642b84739e6b6ceb640740a54e47a04e41b3fe29a40f03b37035cbc52b05c87bd06d9e61909cc279046502cc9962a2c802a94d3fa1f5ab982c6a447089dc31b2398c7cd2f3cf8af5d1b5780b379a95c29172b228708ef715a8c25071ba3fe3f38ad369920aed739705c7e2b6abf70ecd183926c75ae0893648e34d8d68aca21dd30aa44a38615f197111c444b4a9e4cc7f79dbcae5dd1bcc68c8c4f88526e8b8e74aa70f79a9e634181fb84f6d1148ae0114aa2f83d8445b7b42e3cf7b8595d24edc229f2a5db43003cd98f8aceac55cdcfe49cb038c390d6c59b816e8cd793f8799b040ddf599ec15e92f1ab6bc75ab3db92991cac5ea14395bcc0801ef12366aba8ca0a16bd2de6394157a4401c04cbe56957727b6920629f996d014a386cb152793eb678d54afc44011a94a124c2e5810febc77d6ddec1b933b24a37f396ea0b3d1f79566fc508915f96d0d12c407910976d81ddc6cb0452cfa051bb9c6e6e8194ec4f3d3e9dac68251b9c46256b727e2e01d64e7d2073f4b369d1bf04a4387e07f56f767194ac89384c1f6e6ee51946328d7e6719042c5e994a94df0e729047a0736a67d3a9095b907f9192b5ff071129609381283ceba889b7872a3f4b5c1db0f0e38970f38e34620c38f1f8f3810fdf45e6bd87f42b2c431b13a03db73ca89fa1c4896d6f12cb3b36cd48fb6f999db1108ef86503c3dfad0367dc24a0fef463f2937969604567d864748513ec20e4225d6419f2c75ab3f61fe02190b1916074b2460c7646f33505193a348044f382856c54a843b72317d28d606062757bc61d922bf94586dcc8c63a46a990d1cf1747619b358dfa2d6bdc2b97efe33e6b2b8c21c1b655b7adc68cf0fbb5f7ead093436c03710fa0bac3dc0444c1248672e36ce8fdd36ae8ab19d7263d748c2701ab121d0c1550d4950f1600fd4b25c505bde125d20ca6802511015a8b70d2c593b7db1bff7f4e2e78612251aff7aa817921762c27fddfe3e008f7de81b7a72f54dc8db6b5b33b6cbc8b8d1356fa39f91419cb0602ab099b447a85c5ad35af7b4b60a5fe4e6600e838c7550464992c7d57ae84f756e4b5cdf202a5548ab049278d42f0b6f2d16de2473d897d39677d83e488f0f07e7b22da9c6db416c9c488bf9650955f065064500a41d72acbd3b2df7e4c8f037d678ac10787e7d7f62b16c5ca1d965d2b87ee683e89c238b51212ea2bc0e5b2401fbb6fa13a8355b22ead593b30831b5cfd4c6b9df75bffd35f068922940247faebb8b94afc119550461d7cd72a9d0f39378a8829ddeead579b5b88537fc00fbd2ee9695556962740cf7df4cba55209ab09249777a6f235ebb23fd740f461ad1bfd780b7ee38e23248e6c200a2850800369cd90cba0290d7e5fe76cd5f0fd7a3c5f91b8d8c4dd026a4e5541b9c60e6638c82402781e2d4da29bdab7a9c7c5d296f37c382215023ecee150bb6fe17993d62ef9c7c6c30753d39bf4face34b62ccc6e2d683449534eaab4491df7acbec49421aad78cd2bee99b3819d98b0a8a3a0943ca915393e2d8ea39b15cea0429bc9fa2ca97f863ab0b11195c3599d1914e90ad4f27537f4e094bafbee8087db35134e48da4fa020b93a5c7417124ddd35967c20d2f758e7639ea4d6ba26eb8ab1db2714fd67bc0531f9ed4cc4a9ab5d9e8a3cd266f4c2f5160fa7e743a42535c12d05e0134aafacaa878760206bda676f8902c79a849fd1258c3102cbe8d6fe40062e384b1b6272e2c2e288e6c0efd97efbec0f3def9e1b888a9028d89551b8266d359316774218fc984f5ee6676a89745a7766279356581cf61e4685f3ab54ace851260f8a242f8c36046e48f14796c66891688643a6f640ef6a9abf631f9a0c5bd9acb45d330be80c3bdec41095fe70c3e6b9dac605a744927496ac569840375922a4643af1894da236db27e843720f81e5ff5d3da806185edf9d756c23e36ff475822f65a17a0ea61f7238960423052f36e46e21bbbaef9dd6aa52cc945d55397aa0d02825cf59b569fc4af23bf67aeacee8de8b25337954274e1fa3d21ca10b992f7769ee0bbea0bd2f478a719d2780c89668f3c3aa5caa1abc44e4bd8442199e53a816888d342aefe490c4ec200b789afc5c949d4b0b49b69a1c7e04d2af44bc2d6725d884baaefd8d8bfc8074e8640042881fe5f1d9c1d00b9373cd3a99cfe7e75bcb337067f5534f596661fa6ba6f3b4b97ae32bb89da785b9790e800eaaedb0225be7c9e972d2f7f202efffbdb2fbfc5ab079228c500a4e75e005971516540a0dbdd5ff74c6ad630a768c4f326c2ffe92d514854647a0361b0b77edb8dcaaf3079fec6719f4b84476eee62f9c231d4ed880296a3d290b69895407f745929021c2837f87767de8fa4cd11e42736da154ffe7513d9a1b9d0ec1c329001412770392ec5191648fe41b8472487c719756216ad671ea5b05e697da1dc00da4d8a94daa6246d67df18bbd4c98eacf9c756eaa5f1f5fa56bd2867012107846a0a2e39c41f50d1861927c62130a6d7bbab76919eeef4c3603701974f580a3033f9b8ad23cd8ac724c210e0e053ebafba06e862dde869f9be923b59691e5924b2b1fc1e73ca51126044d55eb44784a042d0129f4b7c9375464d5d6e3a99b5c985a47f6ba09dd48d1f221fb23ead99191495c87eecf66a8494fb102cd16544ffbed24fcc0fddb4007b32dbe1c3f6ef20fd70abc862af8814d8384504311410b41e281ba3e8f2294cea8c92fa117540908a5260c9eba6631269a4d6c6bdc8aa576a5f6e16099660a3124cb5109002a5269b47b39772e89c8f934087e5bd3f7173de3f5bc151adb7a73c3c3b1eabe720a0694839b35f285423b203f87bdade2828e1a902c5c51daceac7a1854d58758f39b024d617662ccaa1347b332d9dfcd21c8f9e249a894fb4a97868d8240277c5e0e17eddb4160faa6deb92939aa791c1fd126002fb09742e49b9649f651bb0dac370e9b1155c979e62d5b2d6a3138a8118c0cb484731ddb086f8b91e4623eb5dae1d08b0c3cf4c4df253f2a209d2fd04bafc6dcfdbecb3ece3ae8a5ad6164baa4db39a113b664b331b3212e2368014e4fb1c640f1b9a5821ef9b0154b402c8c58f267f3f2a89fd9274cffd1cea6f2b3b23bbc044abd4121a79b14a957e22e1e302afef0fc4ff225ec7ceb332ee3a0fe07b83ebc4c1c795ce6ba82f54ca73e2ccb2a842537e8b0dfb5b554f2b2111dffd0ca612e7c8b4c6fe4f86dc69af19c51c4a9bb6a7d04bfc45a298a7dd4bac9145e91607f3c41346ccd061f6ee38fcaf022ede83a717e30f7f6ddcd4f4169d246c5a74f16f8c9db4f3d77260498b75602fba494769494a63ee11bf6c1039290eec92b82fac90024c9f5201d7f4fe50e33c4430c7102e5d05e09807a80d2a70a540e9c03124351ebbddca42f861223d41cd754cec6e1f7563f1aa092e0659c9602c1ce105584e5c3e5ea7582c5266582495c104195a71559e119ce5791acd3554c93678764d5dc34c27ac0e7644fe0cfb6cd0dfaa7b470f0f42995888220b76c969bd9955362eee4d46785595810054cf2f1ee96b688a58cd4d70baf73a11bbd2ce4304ca94645e968774dc4e3e5cea04dd01cf7d35e52c1ce23953d3cd483e1c0b7244fe293596baea7dd6db9d63ae6939e36e599cc47ba044beca0ca6152b81639151e98151d4f8d0e3900c69049e26c94f7ed84f200b692d4a245f0bf461f42c14d7eb53a2c57e9bfa38a89f46500a8a308d3498c1bf43147a29e5567e11cb5b03c9fcab6497373e5d7dc1ceba40cc7574a2ae68e5e36c4a65336c8d955e9e1ad1cae3939f2c50e867db812682f057c80da87b2427b01c13dd9bbc69847f69189a8f7cef4c23de95e91f892344366c047f124247c96aaeb20341c1732a82e8ddb6c3cbb4476e4b5e9cafe97ae462a9f1938a54ceac7ccd7ee2153484cb66e7e1e1179b7bdd92dbc02ee7bddc1afc8908136eb562c68544243b07569b70885e0bb9eaf19379f8ba87f18599914b6149b5e8d8f83cd841ddffbbee2f8d2b402386be0af2bbf01fe5d78b05f2ecbf1e036f390934f2c46caf116c7ce77e4acb660a550ad5188ddc52000dc30c47acf76ef7585a20ea3c33fbb53bd79c505327420e7f26e8ea1b25094745ae99a5cd17a55f42af8b75b0312f4219f4fbbb8a972e21f34adca0c3a73ca0378ed7787736011aaa9a79f4933e0c7f8fe976e9055d19c74361b239b373d6aeb7e6e02dc93b9c92f4bb4638ed1154ca244464bd7527e16b966c3ffbe39905632a863d845bc06449cb899b866cd274133bb8ab5f6715679ed67bef92e316fcb14a751c55a5f271426715ba80400857e9e5a8caf028f781143a5d740a84c904e26f799edcd94bdc27f752f1edcebc329524908a0298dfa9f6b6cc58dc8d0e646a4c3db902774b723931dedb4d279692eed924f9f9fce6d8cd4b3b18809041d984d3ed47dc501132a7cb6dab2c15e604c0be68614e3b0581a70a0d844ef6283a7235576632e65cd0028adb04ac187219d08759e06f5eb6787310035081524c44219fa30660f820049771947fe69451ceae90b97219caf9d0f982fd03bfeaf180bfc5e3f4aff428bdcdb8f130abd4bc496b00b411fd1296a3375cf878f5d46c77043ea7d3505fd43a06ad413738ed843f694c76ae13b2cee12963cd7259162bb31a87015c7ef56155394234e24c101d881bcd73c73689e0219508d5994fdbfdb021d8fa19703029b7c1c0a0b566050d5e4dfb19a31a5cd9759441156670e36d7e0bb4b83862a961554fcde4ec12d5cf61b634201abf6e3b09b72fd4c6f79ce5a0060490ee64dfec526069b8deec8879711da5922c7e524457b91f9afcf6ec3aa12e17fe7bc114e437302b2d53c18053fb07ac6e3e122045e3e5f603d5844e36c2c82216261ce2d51781d221f9f8965e9d983deb71403406042f93319d15d6163afc0f06495d6bacf3568ec368cec8f24eec3194ef3f18370a360c34971e52a4c2f2636270edb4abcc4494b77d65fda0cc7b3b31e183009e19c5921bba10963336c8950cf67b3605b148aa6c6eac17525b46f9ae4d8b99866b3692bcf00130bb91d77982d3cdf4450610dceb6f843019428c54122679eda4bec2b6b58d16d1341a99bc12d7e7fbf7b22270226e8afec3746b3af428236ab4ad374f77c87874950353c777ab0e920df748b2a848dc6b16627b39be68e80ce36d03cd279684b2ce22a86538049fe3524b79e107ec30b089a99fe3ca88533e27d1f206db7faa4f58389d1738431dc4f603b24cbb39288ed4e8a34d05837b3d7d05e14d1160d75c6cf46b7df05eb133dc5ba289a4ec80cd8e2ac9b5429d2b5bb96b9f01606fe894ebeda1071554c09c0a32612b3cfdd8c83920aa5f7674a608903492cfc5436691ee3ab62abeb06105d7a8e68de927d2c008ba11ecaf609a560a630aa88c7c7b4669a2ce5343c0ebfcdacfc24c7eb2fe2b8336cd85c51d4c043ec41e4f93b51e487bf4cf58d1a47c9e631098cf861c2256c5e6aeffe7e71abf436d1805e13eabba4358a86cb1919017919766ebd5392070a91fcb63499b788decd7e02166f09f01432823dea477ac4eb8fef2b277b91f82f28062f9a2cad65c8206abe31d5ab5f04118eeac886b497e452afa679a7931b688e3ed6702e10d7a8935228daeb474841d57ade2cb2d27c9590ce5b18e18945ea39bd80e1e6a32c202cd63b1cdb8c289a4a556932d581daa81c534e08292f39c95579171bf8be3a5655518353612961372e939e23aa7751d938d9cfa4573903fd2d673bd5cf1a9c889c3f0435a28823af23ba096266a50f26b67bca77539d7a688ffde2197f0bc7c091669e3e5388960020d889f8327fa23e2574da9840b1d7a9719c3aaa29ac21eae9a039a86f15a30fee4e8f818ed1668e846481690d574e86a750a5b6e51e081ad2a1cc0f1a4147a7165a45993db960b70715cdb7d4ad27b68c6243f70c31bfa445a301815c2e21c155ab0bf90dfd239491a5418f053aa42ae5f1d31b1285c85f0fc577fa90b8e074ec91eb22927afbfd9386c1dde9d56834fe2d3748c4c17a32ac2b126e645616cdd236165e12cfb5d0ab2a5dd7bcdf0af507e2eb9ec2ee5e48e5770630ab76540f0298d72841dff692b1628a36622b50f7713e836e3d23d4eb456d832327ed78ec890cb7b06a455c83ae7886049cadb26100505722306eb056b043710334b125c8af09f0ef4a80dd14a419771b2d8b2970e2d4eac76a79a7130cc242d3c68adf55811366c868003a2fb285184963fcb3561755179a3af34d67f931d5b2d02afc9ee9273af2c085625e420748ce70ccc09800fa187c808cd088cd9773a58b3dbc2e3af8fea9f868827021c53055dd66fbdc3c64f058e0b7bb814be4b1143c8cac9e4aad89e917f73f04296b6f0b07c247a2e0236c4b27cb1312e37f3b1f98afdde976338603523c78ba9103db9a6ad2c8b4b3ccbfb3e7fe441bd64c5281142186f9722fe4052bfc2f7f534cbad988325d83ed54bbed45a368d3aac2c8d40c6936e4678190ba2e8207a6de6384031eb20eabf4b3106a2f4c1487546408f721dd456b0870a748664d42ecdf6cfdb2fc500dde528c2a5ef3f27a2b883bf8b4af76a7668414b90e004577cedd69262b1d5643cd4592c10dae7d89d3076e8b9f9b2eccac8c56f17667e63871a340603aacccc6740faa6a31bb8677b62a4c20027fe4d6a495fb6b61a086b05e9da9c87bec3aba258ed3c3a4ee12f0559a1d8d3a1a64b6ccd2627b311842ed04efd18965be240735214132db5b4c90bdafe810afe02f99904eef8f65c486e70638db1c43840fb26b2cef8b3eda7b65a789fad6891f3745b5040a987fd4e3ba3c1119c3ccb4fa80fba825ddfa1ce5e4588ab6505e44cd1ef1c44090048e980831f79e1032d465c03ed93cfdaed2e43bb03503693fb7a964295fc4de7d348a7a6f95c8df4d39c33c3b035d6b5d122a0b8289efbfdb9cc90572ca48ab275b34dc465480db64740f86da21f856368fb7d2131949c952b4aa1f9635ee7367d840ae7f821dd18da6034d701996a1487872a1c6af7725efe43a2563cbf4b5daa8107b8ec1df3db64f5ac5a6d2143e95180c2013f7532c69100068908258b46dc1c5495ac4d9740bf9c549bc4d57b07d9addc1f3d474f9cf1b9087350e6e88c2cf1b4e6676ac61126e3d939e8aa4d6190caafb2aeca7cefb564075713e1443674129197f47e7133394cc6d7f1f8ee551b5f4871931597ebfaad71572dc0289eb8afafa16c138bf619b0688ec839b81d9a3da288e0c3caafa84d528669ff0deaeaa223a043217760510b8e05ee171b8e69db5da622f88ad8ee21e60096aa537f24459bb5dcc813ad2ede81fdf570f848691fec9aef9f978683323b1ea2124d54b8d930bb5769806b3ef9adc5f04f6740db614d88919ca9485a5b86f1d4692ae701005e4f456deabc54ea7cf95e33b2ad7dd7689193c65e1b438930db18dddf816d92a693e9904d81f5dea93eb566b823e47c8005d71fe1287087771e98c2cbeef6d4bb3715c12867119848965e6897513a9bd2c239af37c725673f8a8a2f5ce098345fa18698f10c9a383a977bfa059ada59715903f15ad6f6729cb62d322030fabf23ba8fa42f7d69a3105732a0e552485097af2998555129d4f634ff15c74f2e8adf382efccfd320403e007ed02375f705a1f84cc82f880dfc320ef28e0e3e34263bb41b834b919deaa494ca1cbff7e8c3ef5d4314871860b76bc6f8ea99cf749b2a59ae3ba9d636eb71aa771b5d2fe7dbee9c7ff9575b4837a8d03f99980ed6a88f268b6a630b1d4a66143084a3bcc2daca4d05c3cb664179d0298bf44d0aa3a90652d8528f9bf67097a2c652d27f994c1b5d858ac76a732e51afb60981885b3b3b9dbead877d543eaf4fe351ded7c6903fac01073da129d7373461f1820daf56a084b00bfabaf7afd801046e69fede2d5a098fdd0b07548b62ec06f0105ac355bc553fafd466ed47686b897caad8180cf52b0b0d1b43440d5069d9423cf09c69a688debb5fdb984d2baf1b60feec17d7f609317f3be9439bdf5a1812133b14962a429af5a7794b62340ac722b7c489049f5293f9fdb7697465a2a410cb8861cfc80c7c7058f6fc758b9e78a2c25f940aac4fe6e40afae3f7645fd19aa21d6743bf659a5f4c64550d8c0f3015d0d6728be92ed240c9fa3b927ba9218d4e2a558823bf9455fbe19ad4ce58fac784599bbc072030bff84fe81f2fbadfa36ef13705e19766814ed624333d46f8281cbef214e78faf9289f54428b7972ceaaaa8026dea6bfd51e4727dfadfe7ce43624ce810e001a075d03928e75417a1cf6b8238fb7bc762da8870a1114c7251a258d9ad5f21bd049aced96f62eeb077c118d1bb83a41fc491229d211f1bea1d347ee0a9edd51f6f4935d530aad8e35c8c90777f62a5701983c1a4ea3af551cac3bb9558b9d99ca7d00ae7f0cff79423682bf2b8866d785cc0a63a1e4408fd6c4d6dc3d520917442f43e2f1f5a68e319f9226764a90905ebd8f23e151224a36402530baf46b759a75bc4edf8654eceff731f2e4f4fc3a8d7cd3083ad3298f06d18fad58a5b7887690afeee0935c0337aefccc08423b23559cbfc3ea584bb1db00530f425e9dc9f8a4f05c2cddbaac1e6753926e8603c42e018bff5897f6faffe5281c1dcabe19135b0f4331c05488d867b0e614a91dd4899c1de64b869af7ffd35aef5763f501f59190924d0bc5a1023836931b58d7cf92c717dac7ef503e5307b813fac555b3e5342da242920a59f9099de1e37f8e1087e5761d13ef749de93846e55f0320162d137cb03f10a3ad478848ef1b159f450b3eb610670a041d5321e83abc9495f42cada13605a295c128fa6","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
