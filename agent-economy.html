<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a4b5aca6b3e9a1b5ac47931c5c37718f1fb4e6a3c1f54abe7d2c5b9140bbf9e60d6874c0f0412a9ea6d742bb6b8ad771746852a69f7df016f46487efc034fe7f8849a3ec120b991db4e30540af6db6ac1a169d7afe6be86cd115bd4bfe245b787c88642c05a1d697d785955b7503aee2572dff0bbfd70d49105efb0d4d450fce86f87c4b200210128a0aa1523254bf334dcab570db834623a4573c3c058c897c69890af9d50470a8b03dcba262efca1338b2208a93a0cbe487bb673d08f3b929098a068c9b41271e5c04d49dfb053f97aa8b6bd7379e2a23ed502c6a915e2f79f393b07a7c0bfd1a6e6baf496c90f96dfe692e5951d3f396580fb2b4be71c5fbd43cec30aeb77eaa8a502b93ec056edc48bdcc53956e732345395f11ff434f54686d886dd33faa497db7d2eb3c65b16a53513bbb485cd79f7a4ed59fcef5fe822a759609f1d14245bb65520bcc883a38e159ae0f40488e7b59ade7e97cba2ce646aa953f6605acb9235691bda7e05725980360cd11ae472c21498f7b4c8bf4a19bfdd61f9aa5ce109a203cea86f72f75ad85c8b32a43ad28fd6ba1012a166c9e474f02988577b2b14ab23cb5a36c0721115a52214440e39826b69e35b291ec70b6f5be0060b2878eacf912a2eb6544ec4bccf458334ecbed7c8b1a826fe151cbf7e97723db21069211440fe7a4b0506d16cd2ef44565d3d221cd0db11ef95ec9fdedc70f671f2312305ebdf57aa0518445e2f6760ce886acf098603ac45b0823b2bd84dbd67825bd0169036b60b182d716a2301aad56ca487d0b4b2cc5a0a9d72fb370bb4ab6a4376f12913598c89be48da771e0361dc703e557babf00d12c41bc5f485f5129a9ca74cea095140dcfba8e3d3d7503bd76f873191ea4a859d063e6fd6b250e5d104224c89e97013bda8b0bd32ecfca068f398a6e99eb4c5cccf0f533a25fd594e6bf8a5007fad35dd619732e076b0933daf3c05451d76bb623542b602fea963647e9d46d17b53936b7ba8cb51f2d207dac5cd18549f6ca849002012c29645f5e197c393a9d6722c7f85ba561ca59277bcc936fce23155f99e0deb1335f91a652dbc1e6ced541c9bb6a297e6c081ec71638ecbdf312f8f56851a34f40cd3505a16ea3215722e64eafde61aeb5d150fcbfb6f84748cee0f05a144bba35cfe603d57bb0d21cd70f5915200fc5fcfda2fcdaddd97db141cfe0826317c3ce931426d25cd7f199c8012483165f0c6eba4a98095dc1cea8183a9630ed33553b7443fd1929127310e5064df1f33e580fcecdbe8e8bb792d5a3e0cb019d1fb29bfbb8effbc9c20300d7b13776a5c051cc801ef42b775405f767b4a986d707228558b3bf98bfa838094cc2a3c9937e31fd71f3c68f778597961795fe0c80ce428ac3fe1dada92cad212a02e4a173919b5e622f494314ed78dccebe8174cbb6bbf734726438c457262010dfacd24d9e114ccb0c6cbd7339f06d8533e5b37ca500dd15a284800bb1199180d1aa9fa224f172b8a4113bc63c388f4a63d00cb155fd69e497a2ea7a4ae81dcd12da7a36e0f4e4caf9e200d9fbb44e5c972787e2a91d867414aee09aca20885ce9a8790d5ce9fe1f2d81abc9826f85fdff3be148c2c241b308c072978bba6975ded44d1fe75ea19d3b15431b3cdbd06dd187ee257bdc768986f94c84055c1363f788e3227a0f3a268433824273898b36aaad0d66fcf8fbe6bfffc26f0a300497427a4f6916048d1e5ebf651d7981cd808b32225c05256544622a432d547a0835eeae68cc40095b626c4a7dafa7b5099a770d79836ceae9e63b3c416e74e71ab43d26f4748c344066beb688e7a74f62be3c08169ef42293ee90836bb2a6285611455cb61f24b1826e2cdab732de6d65dc264bc066389709c38784dcd7b8d96262606b0cdb83981cef88f4ce2ffb8d678537a4eacc866b78fe7d231d730de61bf8ad98feddbd862da6692ca1cf85915595796a9c6b45774daf430736eda23df714979c0846be08d50a4cb5c4e4ad784a263d853b234ad046a0bb5abc6571691c25218a84fe75500dd15d2b3f78a694b4908045e7d12b641890e56196ddb29455ddfe1d8828e3836ceaf1b6cb4668d5e241daa2500b0cf13bd8b1b96228eea0305275d09bfa6eaddb8b45c9c41f70d847022918034b225587b3913a086277d321520f7fc4ec1e7fe02f850a502ae347c88eb30000d7c221df7f33e0a7f176a502ece84a0aedc5ea7553e9b6686b6dc5abbd1f64ad61408a5877bb7566caba5c16af32fbd67fa61c13d8c10f840a2edfac2a8ff84fcf32ab9e78b5935e67824db5a6b62b7bd6f25327ef85d5015f0cf15a021e359556cc1c10b988841d6f106dcfb10d98cecce932aaf548d1044f46f515b8a3e269fe317535624c4eb7a58a8ce811b2276aacecf4668063435272c90e9890315e2c29817040a92b221d32820a949ce5c3813552ed8ebc72c67e79e614ffdf5268262988f3ed6c197dab133f64ffbc301fa83555057724e46dae2ec9a6bbecf02d25c54aa224cc5b81b929d17a5c6148c50bd1528b503827c3bd8e78fcec0096983ca942b48cf4e322d6438875b3721f6d0ba710add472b3ea9f70f6e812c937b43425f6cc1c3db33ea8e4022bd50749186f9594d07fc54f6226e9d8ce3ede755d6b8ab7de35e88fb71ea9f526c099475b45d0409c24205e228437d560858af00fa9dd7e8f982251b092f0070a137b92a786c26dd459fe387779ae6dfd00f278aeb42e8a1e60f88284b5aefc8c596cc52645ba35daec38542e8f525399d16b811e566042771ca2d91e92d8f18749ccb01529ac3634071b1e47fd53278232a2467b0779b5a575bd8fd51b04218c1db34e2eefec5c909d3912e628866e1c793f04708625cf817ad6054effa1b5a4b2acebdbe8e0d5646d2358a5f44e8c15d4fa59b94319c70b563001cffe2d0f87a3a7d8587c65bd109bb2b22c24e4bc9ce3c4962772b56d836493e44cb2304495f343b0af8cc98591b5f7544b62c592a311c16c9e5baeb4473a2d297b55b7273c934ac89b73bc913bae58550e883b5bfd9ceb6e34aa00303a1796038398d06b7d14a2348e4c7b67cdec80b8fa84d552e00d0d800db32f4a9e442f685e4a333d7e359cc6cb812fba30222e16aa5b1073ad6568302c3a0526d8c2e493720d71b6971cb2dc8102a81c7796b348f0c2cd8473ef1d9646fb247fa0521388f8daafea23a768fb652e1f3f9e7b43debb4ee8f5d6f45302601225ea5b20683670aa119d24386c20dfd92d9083f0f533845335c615be9d8bb5cb35846f3d46990044eb6b5fa3601c71be069d98ebc1e66c69b43843165647af5e390834fba8a8958bcef4687e7f3e6c1d774bace0a3d719aab61e3c9f7c90246ef01e0fc41f04a09815a70494311416bd0a2df08f5527687b2b95359341906038cce1de623d761de2d7d5bf98d56fc33b1f1c7971d6a0f85cb07cdd1f45c645b4d9a0b90102e3feb965ea659abd05940f354ee466d4fc17c7c02fd800d9bacf584b995c36cb915b5a30d68c4660d44fbf601d54ac021983b851003246098d4fb401909b15a062b51fdb681fbfcc3489a9e70262ac77686ba3118137a5a2fb99a9eaa51c2971cb3874541b6e169babfacebf18d99ec2e2fdcf1fb79faf269844d0755253a3bcd4421931e082a89d1dbe4a2783ca5e9a6519ab439ed4a704f1594de7a4bd470a340769500489ccab73e63d26f9096f7a86bd6dbef41dedf62bea5dbc02cca7695add62a1c3d2328503c75e89cdbecaab1b006c075f2523110798a37162a1cf686e8e36fcff0250fbc99849896b8e76c54f2ff8d02b1927548004a30ca75f089c34a6f54c82f837e1454a5e95b7944a700403d8217c57f5e25963371f204e8c1369ee715fd039e11fdb33ccaf22b4d108b257394b43c7227c643bd6a41b6efd67045e519dc61b8d0ecce0ba322fafdd865e30c055d453c7d00d7be3bc98316c41873effc9f2c1cd288e80e17dbf7698fade88c30198f5c0e0f45e78de893f0036fae779226b1e250617549b8bef092f4537de6cd9d6009614544424136cc4e3bdb547c1e041745ee9e7762ad7ecac784bfdf87cecd7356437cf3c9fc4d206e2743a02c5f7cbb27fbcf0f377d64b6446bc3fbcbb9e9f59152f28f99208701db355174f5545c27fb1e663dd65b5ce6e1de643b84e054748da7108da93f705b4d21a40d9037a3d3b13a5084025504e2a8c322a9fa879026a892e82db39d283bd80da4d812039d2070b2ca4fac5f3fe1e44b0726ba4482ce391f2c9e58426a94d6e878c0b34108c1c32f53c549ca2e0cd16c47482df3bd9d91bdc1f6fcebad299b3ab2572f91a24be1458400bd336c17e2c35733aa1d005f377cf3405e097bd5fd2d81e5fd65da5ecd7d82259fe5485c6d27b27ae7a1dcad9a27348e2705c0a2682f84f0d5009bb28e23d066baf3b1b40a5afb7109c63edeea9937ee77e38d3120364579da7fd243beb68025c0c33db2174a1faff1c5af8b62a8e7600bd8e5c223202b03b061e44b73e6dbb157b12e9736190531963e84045aa07cfa1c829a4a29279b18b1c1b7e79b5f79a610e6de4a7a07895286b4fb752afa14d6e64259a1f1f49100cf37fb6d316ec2444e0dd7c403647ffb377e02e4020ca469bec1ef750de818570a99f29ad44934ec516979f95fba995d17aa1c32094cfd5cc7b2cdc43f82e47cae0ebc4312c5efcdff8e6e5265dec4ed5dd9223bf19f8459208457ad821409985c1da432e1724179a618d9c08fd046d66bc1d9e919f325c2982a57764c793fcee7904428dffb7aaffdaa9d5af9d49327b91ac00256faef95065bbd802e615a15afc1e8a0341bbd0cb4e165fc7380511687d0f8a113e0df1d0d44730caa77a9116131b0b6fe9a6851d5252c45e8c592f52f1c5466917a8f8f3852ce3987cdc7553222f693a2f3bf117882f57967e087e85de9587dbc38f24eaf844fcf9982fe27ff797d0e490de47d3625b2b0f4eef1521052d93c3d0d0a8201f11ae96fa67f8da5314236180bbfb5541e69ca468a82e0d51bac0e64660ba32b0a1d897a114814b5d4335926e9580b25e306b9643beac9df5bc6a6fd0295d0c9a0a8cd245f18943308dfb90404e01ca679e43c73871c28e2412bdf4740e77be12f59adc1b11f826a3cd878ea1e257b53cd7ef6a5c8a72f9791c00428eee51f6cea6bfdda2e97c7a7e77ced9f391e40d4f58394b3d269f1f09f163b3549b54536e6ea01952e181c0516c2263f01c0c52246b52a1196db9e281a2a728381423d33ce02d0da6e29b5bcae8f43abb7b0d6d95c3940a5ee724a438da9c5b1a435085aec8939fb0106feeae3945df99cb7be6b992942edad714df2c25b87fc24811f565f8aa7abc537c146fa3e65b537f3f78303c3b12fd724ba8c60782abe55752ea4c887a8de9f5bd9c04d7229aecc5ae81a386c17363e594ffacbb81835749f9b95aa38148a584d68c1205123e651b8e3921cfa98304824543d671f99a0e9de080bbc9555054bb1e62163a4973de056209f1fc11bd002cd9ace2752ee437f6050ff5325814f1e962193cdeec49b2a626b75554c9059615a000005d504d1497af6e0159ab32a8bb6119502f232ff5765dea2bf4d311e1f65cc44d988269ae503621a3e42a26b028ac0223bc80a72260f418effb238c07fb653706944de7a31e59410c0a6c9f13721beab2abe8ca903a125f4b264cc6dd120ea81ee48d5c6252f61859605a41fe4780dcddb3cb8df472dd38a07e0ef38de98b6fde015d160fa3fbba3a2ff191dab4403a20f184fa3534081f46abdb20816c427de560efaae12fcf86bb3f27c318935c468a96937a916cd91b52537f63843db862cde417766df2ebe1e831411b55ca7f0f782023d2a33b7cf0d5336dbec086675c1a30d0eb494fafe422d08cbc0e898668d4731cbb259f3bb045b69e6455dacdf2e5729de26a5d32fa516e17200731adf07c9a81faa04d7d40a4faf8c9c932bdb3e687c0438c32fcea6f93681cb569738ca09d166c8ff471c99ab2df93c915dc3c3aeefdd132612419aa6684821e76aebdc1381f21c7d78335cf37af213ca0f9e7a1c7822cd887814ce768c7daee25194f3c18936d8aa1ab2b60e022f6af2651ab29a5b713004aab44f0ef79f7bcdce9e7e2631082457e043eebf786db22906083ee3a91fd57e58238223d01fc5f66ef9f7cec3542e36188d02688b800a6d389f8aba91756ec07ffcf8857ca3a7be7972ab1de3873f4eb47773196c3b97dafb13e22176d16ea4586c57dec9e11b4a67ffd909c7e95ee2d2d60836ae15862a6476bf18cb71a34e9be940b587328e253071b47c40cfa4c282de43d08672b7f658640220cf280d4588b445ff2b13a81eddff89fc9e65313ae3074a6591945c79705d9fbe12b996b062fbadf06a4a2d49084071b315abd4c6bde6abfb356022f004f2374fdde26783729756b8d99d9ad03f4f7d908101707d7c70aeafc7c112796b862c5c40bacf86584b08ecf20833ccc0fbf87a44ad313fcc3951d8a76e71b8e7fce58154882fbe21e7e3a25430192ab844704ab7c89c8c5ae12a4a97e4cf06987b2562bf7e7363a3beb9d9d15bc47537a5c568ca3683ef591125b53a2df665c1a8cb98617413f6218e8411ccd96770bc833db13ac946562b01ffd3fc9d173523ea4061968b998888abcba279f4c045f8f425d7945e5d5615296757c73b58fcde8cc9df2464ef0125809a533ae164d65b9ce88d881509a5f5135e83f9eb4128ae9fbedcd6be48f9fd268a1c28e5ed173af87a4e3f6e5700a89744d8ee5441c55f1ba541eea3b02a40810c930faebf29a5f011f550101084576091f72fed8369bd01aebbbd3e58099f8cb54e5dce390fb575ceff4a959805feb9a7cd7772fe570f5750682877453fd7cc6d24fc884aae6dada99bf2ae2aaa5fc6bc3fb1ac412d84c384b4e58dbd34a088dcb33e074a95008cd6bab16a017513d8517b6608275379c2b9c5d244b9ea834895024a7905332dbb7655e1685a142afeb409c942079c3d5f3603169f45fe6b3361a51818668e1e4599d5620d63164d8ccc5bf7c1fb32c7bbe03b702d54c0cfcebac66fe3fde8590f54ef8051725cee6297015f2ad42c1f07e925e6613a283e54bb495975745dd76845ca78366fc667a67dd077206338fbaffa1717725ca1c88308be59d033c3ce8137e2ee8aabdfe691e636cf58f94d15cd824633697709007483d0d799ca80b31b6f83a6fa753ddcf27f13bf8da52353c91eed1d7141aadd97cc966fa9a6018bb79aeaab9536809884807a44b47aafa6b165898e54e519b91664a4e13582232e2e8ded03ee7304aff0eaa5cd26ec379c7300b4d99504d6b7481baa23074916be77928ea461834b09e277da8841a223731ce65b3bdf3dc997fe153daccfbf65f1c0854e859e20f8293619a2a34d37f0501f4c859f4317430871ae2433b9e313a1afa0e42910bd36724a7df86a8b950a182cabda47136ea2cc04e1090fe4367e6dce7f2d0bd5db635aa4717f4cbbc876acc195c9a9e048c510aeac0aee0a6c3f51b50b2060d42800b7ba29fc6926fdc5b9352b430ac69e0b18ba359c382d686142c279e42992042d4378d5196988eeab112c61595d5377e3b746caf952059fbb67427b5e9db71b47f11b80ca506f0d7a1a8f148ee13daa2e55b5646fb063ce65d3e0a7ae3218f36b7a065a2b4601bd533e34ffa78924c2d06749a5e807740d4ab0a60dd193073d6aa10066c8f4b496567c234b1c8a37208a4c43674131c4006d1dfceaff1d41a05a9ffc4d82016be4f197c2b89068d18572b9354399941a102530950ce06260ab2dddaabb6aca340fb839393e35fd8143de1a848d1986ad0bb32fa019bf2d0cf2516fa611a0e6f08a75d5db30c5e907ba64b10d8ec34f42ef77150c1067e8448a9595f3a58da36e9d3f23ae1a9c211d771720500950d91c91cab59653ca5267607ed6bfecec5bd5bf09d69f234af3fb77dcd08500dd2835f70c900b1f6be2fb03f0dc4f65330fa6303b808e6e6f69ff8ed2ceb8b811a1dc2e4847e13ae141913382e2d51bd7f32e91b7965345486bb9513cd30b09e48aceb39ed07bb513bcfaa498a2eb6471e96331f6fcc1df6c310e82cb29d8a810eec9bdb0c386a17492d930a3b0e811f93ab6bf04f9e61bd235e3304badf1dbf24e95c4e6c4f6257d50f096f0f91ab071ef60ec62254135ac3ede354676baf41e7405a9711f37288895c86b331b53dc752acd97773362a69057200fef11753ab9a140035f5d61b329d229888cd8bb2858db2bc3c1e25a6d5ce521f08af50994c21eca4c7502084e9c72907680fd6e5c3079a296cc4f3badfc69655b10a7fe6e0597d7f9d550af9e92e51b9f3e2e45df56b8f4a0bbcb570e04de4180405128cc45a13fbaf62ce6a4e0e26a3017be801f47e1b0714c9d7747e34f846929882a17b043aa246ed90ebc874b469ff63b5cc17c784b66f455810db5e30363e6eae1086f4751efa5729bf7bdf51db0b7d452edf70cb2f1eed00cd8a9bf0f4b1b9edba0c75bb6e42c04ed95a258f1456ca5520aa6c2d1f308baa78d9542d604482f7ae0e24e79e0942d607cf7659dc264b784dd5c006d141b63eebed2c059658f936054b299adb4d77b92df568053fbf008400a4c318f8887c0dfaf70fa4c4bdc48284c92af38332f82409fbf49069506d390c4a517eef408da9cfe491ae371240856fcc7b4101cf9f36cd7a8b80ab8f885dbcda5301932ecfd9c462697d06d4e9d409533f518961bf3081ff30d3c0f75fea98888346a2619bc687488b9c313591ffe634f4c7a2552f2b25fdf3a7b1f4c18fe061ef0853ba85bdbe6ff48f27c8b55f91c55894e3936bb74b74f4abb80048b38b8f71a004993a1710d1b463067b827cb28fa74ad42116679487c6f2b75a8640bb98dc8ec951b2a211dcd4e3a39e347272bba604b8e5d0b882b3fdfad812fbc57c9eb30a332a088322ecee9b5da251140eea8da8491d30406be6e2242b78f240705269b5c36c2d50d05f2b4d394071be0f5b17c8232c2afa89af755259e736a2eee637d18891066bab64eddaa27a38363006f561b934d1f9345799106efa8cea1da11528ef88984aea07e56794f7e18acb7169cee2ccb44e95ec806b4af9aa4494b4efd2a696c4653e4a2d5b2c58a904c301be12ea60e280c5efedbc9368a043e3dded265d9883683d1f61c165a643fa528b1124f5b9ebf4d8f74b94f04edb0a041fb4e43293634c2b40ea7155de30664d2c02e69e9f79a340d799926b1a2f6b90ebc7c42fcb8fbda1c0e64296ac25b3bd67ba66c14642cc59a99aa8ac193cb5f1285f94305b19027d9440a4425e10b3d3c23e442de44ed7f0bb70d943600ddbe8fdb949a25c40df87d1f4012e2dd017ca43a54b99c37fe2c3bb2a55f7ce3723be39a765e40f90aace6b9cb01e8082b7e5510067c80a5016c262c0af1717535ed3e8d5fac5904123038bc8a8e1b7adb01a7eb282fb19d8e6499943e02f0bbf3e95f3a472e13b4897b6c08c364167cdf769b1d64d837f679b2ea17f03f746cc20537d4c412b5ce6272b391fc8ff4737310985c2026091229f7bd95a547dd3121617b65d53db429abd1f870a1eb884d7d7c5add100e5b7b51c9bdf083fcf0f03123e67099880b7249b5b3ca694bc14a0f792f72d1b764c899fee37af4218d07f0ca0d4170e8d406f8f85c773c986e3d91620ccdff3be2155bf38708ea9f7a959c7eed30b198d11560e88646d0b6e17db16d1a3a268c376d6cbd9710f1649a242566b372b761e65af159bae8c24beca652a3d7ee4d7006ec0e5abade50667b9cd744d9311c03cb799ef08c7c26701b787e9aeafadeb63f4871a13e995ad9b237fd778929ce2e91410d9cd2abf91bd068254b78b3818a0d8dfde9713faabc4f7f85fa9af5be966590469d333b5809af6a2988dccd7d9832a8b0edd365ea68e403c9243ea4350c873656f9abe70e5b4227e862e65ae6e73394bf868c7c70ce6081c4f29ea951ed30a90e2f3589826cbc72753f4c240874c0f5f3146abf9df19513f25a2d3e36782bdac29fa581c153bff5f824bf996cc2696b227d6abb818433299701b5c4abda7675a7b924e025180b327fda9b54dbdfd19ef14cf2a037b4e30f53ddd203a73f2e6ca7ac0ece80280369329eb9f868117ec46f8c604d99ce7d1fec0268824a7244f78c6da895160e83221db26536782b590c1cd46d72a2c5a4c84e4fa79d24c0316d43bb4d63d436dd08b40762bce84291b4e5853b26990b4633a33b2f92c25fad561e5390caef2509d1dc03c94a03fd6d03972e2bd5c0c4cfd30fd072ba46867f837746bd8612e70473e1007f7fc076f8dcef781fed8602f19f373daa2db206deee28d284843799a9b089324a4d23713de1601ef1fe1c9500ff74cf9e9c1f7d7cb4d1c3dcd1903d4a49dd81c1f96ba0cc408a427e7bd008ea8eeb50915a4c8cec72960eb2d2414825f4204e1379dbb131837ac7a545cfe76f4bd8fe73fbc496d8a35466656eda27ba4e1e13ee0e53f412128eb6f596fe12e21e481c094310579201f938e8a9c7b4221d65ca8c693df0c2419d100af674254a5ba3a95fec3f92d7f46441ae4b9f0451452c0076f2e89031861866b71003406ce6f82e452b48ccfdc2b75e8b191771916ef3361c703e7e6b823d6846dbd82b7648aa0bccfd3505ff1d794b98947f21942399371cf82b718ca3d83c946fbe6c97c09e19287d3bf6eba29edf71559754e71406b294c8c80577f7b38bf99342addb2abc0b6474765823f00d52b35d9e070ad275e0c68d1ba44fa5789f489d19d92a4a07b5bb3f31e75c93cb6ecfd6bbe7db0032347fa48263485665dc69c985f6728c183705304edc8c9c7ac7db8382bc8012ee3aa4540e843873e7ab8063c0ed01d9151ba427babcf0c4903b3c16111b100a25447201abc0d2d877c5c21cf9c4ed5fa2235c1a606edc80fb31a1a540a6ac0d76b2fd70bd66f775aa42eff121e7f52d2b5fbcf5d8d300d47a0fc9d0b41c2a5399093969b03a3a8dd02f93cee1f54652185ba0dc7e99ca22e70d66e62287c5920a2cc65b3d7d638b5fa3336a58d5c3895d6cd22d9226f9810d77550891d3298f500986ccd3588bbf2c29fb3b88fee447c18815fc7318f8049270a5432bf1ca9f1e939f8b60b4fb4e6bfc50dba5de257349ee84ef826d295685768cefa9ecfef542850beb53315d506395cb6c831d12e1b011d37760814fbd91cc89cfc8aea20ce3c551214e1bd1f285d0158929dd4be227c453d04ed27579fcb7108f6db1440d4abc1ce7f61b8ce060b88dd3d82dc8db506345fc0f44b4ec3350133590f3c124e3318acd06c1e736e3b0184f1b9211c2542c807c78ceaaa8239f0be42ebeab557a6914d1d8141731fa77bbe9b9877a0a8faf73e0482acb468c7f2d09a9886a8ece86fd32752cf029d819ad25ea639318fe1486191c993ed2c07b21655e9e07b5c31863499175f36bcfd1652dfe0b79678d99326f403ccf581d95e2e415d2ef059af2f0be417b023ca02da2dd80cfe94c9d6a40aef3d6551859cac27bfd2809b68cd77b82a8eb491c4986e16142c8c93393edc1ea969c2dfcb9f36e0dab94d5e82ab7f16f922600d85fda71e78fbae195ac2305f3b01f30dab09bbf7569fd5bd91e17232017fd13aeeb2a07a5c21c862666e8e6ba03708feba5eb9ef11b9c6a840faa6441046f3bf8bf713d7d6ac5ff39a26c72c609512cbcd49364136dc1c8cc32cc5a2d16c9b4615c178d216c91f32f0ad3f7cd758ae5ca0951ad839465ecb1a5852694680223d0b69d29c0342431d0c2dce232dc6fc7575ad65558efd3ca3cebf0ff1c50ec01111a9069dad3f53d9bbc2717e7a97793472c577d174fa7e68b64588131bbf9a3968f1590ac7041c60df4fff40a0d1045d579c6bb22e65ddbe84a5c36e63c6ef84f2377f7fad44d778c464d5bef72647093631af58f77287cbc44156e1dd6a09abf46771ae3a55bb2121a01f1af037932a9973da86bd21485f7177590babbb3f8afd8d8750805b9480a0d867bcc8fe5b705ce6648dd938e13d488d2651a3075b8ddde9d1af6524f5a2c7c23baa5ea7f7e33e570f7d067013304be417c6f3e6ecfdeb1b520cabd5b44caaa748a414e824ecb5d34cbbccb0bda9ea2ff71b5bcce12cc1342c324b96b53c033197d32658f09c63efb036e1af210f197cddb26b5aabecad60b50bfc2f52ee292821792cdf2c08f6c4e0a08b87d23feff8f60be565811b5730bb831de084eac8646c226ea38be1786e917c88e4cfd521834429d694586734993390da90c11d5ccc059c23a2633232c82e1b8cdce4a81c6c1fff57650587e4b9467694342ced47f71d2129874db2658ea4a7bde342223832c9f400b03c4f164f8f658079960220069abdfc397df09d7e630c15334dd1ec9af2b1b7500ada033ed507063e0be88e6ef66ed4f9e396292cb825f7d8e177535b3b5c11fee28c0953450ebd5aad593831dec452d21df8108340a7c102721850024f54256b6e62723444d7eba7fbe1c716b7d63b13ec43696632705322ddc0d2cffec296952aae37305fd963051ee137ce5da5c07b6ef6519321758bdc5c0e1af933327e5560e497b6ccee1589331fbba60318b120aa9cfcc41e94fefacbe77dd995e05e1e1e630f3d5d14b410c04b355a742276778b6cc66b42812b293e6ef25fbcd46de638803ff0f6ef76f690773b53243b08a1830925aa18b7cd7cd972e1daba1d2e59470c45d526cd7ef834ed8e687940cf099cebc9aaf6821784ea61edf7d2ee1514e87e381654b9dc1cf93fbe2b8c95755d9032207bf8a0cdb7bc3f6b502a75e79f62fe2aa98e49f20f3554bd800b2dcac4431d860887a06a82bcc202cd22124679c3e94619accef193ba3a259a21f98624d3c177c14473a6286439798ff5edcbe39c5f8c275b283b93cb6ccc98fc90e39ae5d7aea740c82db00429fbb5fa3b328d6d5a526c4899333b28d349788dfd0e72751b3661d5c236077e261720589c4f51e38d1d72a7c1ed066246c999722c4cd8022901772b90ce5b43c9f615085c9faef12c0ec5a4debaded0b6f85cab5e6979df506e9828e64767a17f8cdadc7eed6876da7f607a25ed8e1175cbb9498f168c2f8c26329adba6d9405731fa98fd37375e67635c36af5c84da0228a2528527148fef88aa4c0f1041e3f0112dafe37b340402185a7f84e33051ac2a6e756619a9f70c5dbf0b23d566e4eef8c5bffe69475c1fd807feef92cecc79ef59af3688285860a9d45ac55ce441ac72e49fc3b26e7621b530a901838aa2ac8e6e5504293a6d8ad0efdf7059aacce051aecca4603738c13e166e2fe08e80222da9915113e74048c3130818a46862b6b77b940531ee6635463bbd779e08054a43192718bd844525674522fb3c8b9c50578f1e84f33675c18fac6d7c5bb400a828c042e7f8496050fbad339b8683995d4ecd6c026401ba90505141e226e0c04c9f326dd6a0d4bf89f71879efef507b810fef64d2e1d8c7a561f7a249eb4f14d32e431a899e120524b6e8cf87feab22dd9f27c9a8598054c098c3f08201d50b31649a5a2d1f32de5ca01d30a18528fd79fdd7631ad319d58d2377a56fabdc283ba93586a79084d44d38659e7584ad54a81f2298cb1915e62bd10c1612a2bbdeecbeda7e05d04ae807488466bc0d7609fdcc74cf97b8f2d982be62034a85348d96b63c919db0cf74c7052ce5631ecd5bd7a1c9acc5e74d4d9b6c451ba135d1c7fc46654359f1f025db71ba88a973b8c3982b6286127ec537db70611d2e01ed4d58d6b7f225be9f2d7ea7858a8ff45297fd54e08a1e0859476038f784979ff4390772ac52a07982399333b4a2d5689c087d6432b9dd2d33d434266c403d1bec890421523e8bf0b3db21595bfb5eeb459e731fae9c8870ff1746ba51e4c453cb185b856a9306c297aeb87e53c5a0e4223b50e664605dcfe6b9b893c255e932b753d031a79991c5020b52450e1eef67563da7acb8d3b337ab912757776e25c86bd696c741e3c0459469afc4fb59e156e75f13970d66a08854b15d825ab22d3b9ec7611dbbc69888a73fe1340463da6a64a38c7b9c90fcfec672836d8df24f047551b5cca3b60ae4a784e8a6817bd5e5e36e85aabbe301f78f095471e9e8e52cbdb4eeb1a5562ec767c980dc0385699bf3da414dec6638619aedf7d60b49093345df02cc24be85493c001ec9181a4c2e3de3191a29758377f3d0205668424c3eb17df4de147ba6a239e8b2613472cfbffa9ed8723c1612541cb059fd5579e40df18d1494415536c28bc548703aa78964e071fffa743d97915fc114eaae662eda3dc2ed2c6a30d9ce1b565a4a2d0a66d73eb7afeded1502514ed32e7485ec828f35674828d19a36d31351f58f6b44c08e9ce8cb87994df015f96eded47e1604b16ff2467e4ca37183c98059d600de3e442cdfae006cb9d6ba4f51d2eb3d5b5c7bf54533851c9d31cfe35e55a0cdb727ff9c539a49947ce45fba4f2069394d013201bca2b62bc54cf7b77dd2529eac7732dbdd1b7aad5799c99d3a939409bfe99658dfdb84f745e7aa00e8d9925791dfacc330fd2e066239f3ce0cd41119e4efc27d731b8cf24189d708017996a7c785fa506fafa4f0500473479d16b8e3f2c959cc00477666f2ba3947fae1a4ac3baac7c83c891c1309f69967a4e8283d985abf0481159ae7d60ee25788bc08ed6768bfe1281ab0c5b7decb97cd89a9512107e947b132a3ec975fdd7f687540f5634a10cc7932d5ce0d99aac904b56b7bf380dd939b7fec2371fbe5ac536c141845be3be689d2db3948f9c6ddd010ab87df9366d428ed17d51c78b2b9ce03dbed93af7a162a755593c543b9371604c82e890aba5d0f083cdb5f704dc022a72491e741572a312fab42e99e8cd5b7a6e186c2090f3100dc54ee242ee917ca643d75e99a2524fbe61885f614986e5e6396a9bfa13a9c4f48bd02ef75431a5842592f4aed9ff8a26e48439d4e612a4e1448b4477bb1c51f3f88ab600ba918253ef36868f402348c87f7567a3df49159a1e030368c75f4cdfa719a1047b107ab077bc79b5fd6ad3d5bcdc84905ae6a3dec61288000e57a6937903bfa1cb26027266abb7122e03eb49479feccbff82caf9d9fce45facf5fd014c2c69882d5a9328f94bd0459768f201a84d51d641c9c5d197aefeae7dae44c6792257b695ba39b16ca9ec25d67d6f7dbb9d22320eae5a2b2d9fdaa0e41cbdd4179bd125b004b60283f5da69a1bea58b1a87b693cbd40b30f1359c61f5339fc77d0c784d58541577f34ca018c4f733e2d2cd548b86d9917f8b61c70a7bada4c93d0b7363185e2fe1eff1a6316683938673d1d7f20ed936220d1b745dc08057df5e519464948e0d1075674e96032335d147fda2a3bd52550f04faaf3f07b05859a82ecc0e327dbcc3586676d731a7ba4d132d956ad0c173a04fe1339da0ca006465fa819503d21f7414e8e135a118528a4100eb4768f70cb853c8a5f0bbd7592e4364726430dcebfb222528a575445d9768261729ed80277ce26484832b88a0b5d350b24edc9786c46a257c9a7e7fb5bd14ac991d55dce735ad62678042f5924339ac3dcbda0e9b0c23f1a0af16f59779e1a06179c2815eda04c7bd7435146dc417007ab83a9180b754e594985a4e806b94feed01bf91b91b1ee35d6a216951f87df5b15be3c49ea7b1644ff591d703aee55622652682a80a4f6a67b0576fac42f35cf9dab4ff94a4448943d03ffd5fa5213738a194a8dfde3d90c13ee32d2828eebe11437271f4db512bea6d1f23be14f62a0b34cfb104bb414b37614df645b8f5eb6dd5d290e8ea15b282af893667793096bdd72cd453a5b9c690cf404dcfb437b0bd64ae59a977b9046795372104253e8d3fff7fca8","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
