<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"02ceb3af499a6acd872cef67ead470cd917eb937b26700fd18a6a0b19bf4cf7b91df6c0ded2d0cc45497b0ac62f43168c79558346f5dce6a04a99b97b48929d9ccd358df72935a1049e02767425c20566092bd8a48ef9228603a38a0885d1c15ef9ef856497234b1cf9eba0453b17af81cd4ea855b400c5e7d423662e82308757f41739e499172d8be343f714b215dba565e5a6d32013e2ac277ed7dc925e1981b61ba21be05d695b7b8acb5f265a3c4ffe5a22f9058ac40f028522cd1d5f733b6ea6a41e7d9d7d5a46847f0133cf6aee13c8114be3863f2c970c8ac7c3759437177d690fd0433808e161587b788ca7defb4657d3d6a70af7dae7af2b6904ea73724268e0222527c80f9b30b6263d773f744793e20d1d9cc6dbfdb9bbbef2e24fdd49b00cb1d786b1d7bb163a601c09fd3d9768feaf24e64e815978990a35bcbf0fb5837358c24a3e7d8e62d8714c153e3771de1091e2613a0cd679f4aa8a99ea88a9ee6bd73b416d6375e4651c206abff9e8a0dfbbedfe6e077eba74dc5b667658b7301757c830c95843b9a21e3be7316a37b8855616fc6f5ea7d2b9856e2c2ffa3d2de5fa7582afd090036fbffeffb5bbd6cfbf749d2b3e2808e2a63ebce02e8433e8993a16472de6f4246c81a091335242cf4c7de31f69083b7dea8c8e58d5459a3b00f4194826ff0380c2295228648661fe98f2fd81cff95a265a4d2599d99c9783540037787839ccd831330cc4a7b1d541499dcf0f8d719b001716b4ce854bf056b5575c6673c045dba1a307844f3ac55ac00ea1f89ef42f00495270b2ad1d89af80f78c283e1ce0a628407cd499c78bfa9a144440b027b1f0835b4a7e8631a42e7eb0fb37e529e79505b6095ce25e84bb83924a010cf5b754463fdef83f261cf969e03dfc6fa5fc101fb61a651929a9404fc62391eac027fa6514fe635be637273ea9aae667891a7926a501514aeae7d458a3052d3c41327ffc9bd751e7c59ac24adb039ba1dde9ef804712775df6b06939f6132f09ca2821dbec2edf6d3bf13af9809b77afdd59b538aa0a318245d82eeb3ae17962c61ce975e2efe5c6811a1a463449ba394d4f8709042e6236233f420b114ba1aecf879a8737c3771cff659cb76f51fc592d937ad665a2c4addf92bfcb25a4b73266041a41424cab8962a7d4d22eeb4f8f69e2b1611af8d09b75c5f836a09585f0307b393ccc27b93d24f94f98d17255660c1c5f2707fec30e2b1aeaefe03950f3eb8451e5b60782838ef8646dfde5b492bfdb95505ec12d896495127ecfba30228a8a5767cecca2fb88e9ba2c4b272a91d2b48e89dff47d9ab0481f4e4799bbc193d2c6e9942bbb8b301a0636f55de97da74c2e803d1f78474af8ce5825d5e137cdb099e37a70022859ea2ef32e6583bcf5640474b29dfa8bbf3cffd7c7a1579707c7038c9fac01251c2a0c367ac5599ca781266ef131e9bccb60a5baa7e0a034045dc1c1728ac92e3ee7dc1db2d2516ce23747b15d2c3d719dbb70b9857576868078bf86ea2d8a2fdfd766acdecbb42e01dfbb241f780332437a0d71988f1e394e02d49e11a1e7c1989f7eff1c331553fce672b3de97dc53e52ba6dd31b95ab813a97b7eea2e9b4d20b0a36e82cf9fbee84203fd1413c310c6196a8f83d0a2e0bbeca65da521970573b108cb18ffb05f0a4c3ce8011508d2e0f7bc85613df216000228966fd683c523828ecfcfa58f6685cef04b30e93c2da96b977f87d0060009c42eebef8113a24c81c27f82004cc82fcb2eb7b76c72f1afb89fa84747af6ffa2d30a77c30138a66e5eb083b3503a257c8652c7c7a2b883d2bcb5d352e0cb08b097ca5eca391beefee643e9524597d8f419b7720b3fb1dfe722cb2fe1bfe1ff2c81bf9c8c70c7b2579edbefed38e3fe557131478486e73604f9d3963e9c7ec3f2f7075e95935fabad408da58bcdc5b60732e6e8dca0eb81f013c07d3ee01b2c070e7b80b6bcf3ff23244222ef13c5d4a12fca74cba289e5ee5ed2ca9b4259eca06ff5bd16a1af614b13e6e10cb31665f2c048e7c59579e0e29c2663d8522dcf0a4516d4876977685206fd2769a2913c7e5b773d0e13aba3b326048b7ba5d316c4ae7ff4f89af2b80df9db05f1ee2a2825e8ec8ccca8587f4372cb0c157c30b93de1fedff6917fce2d6505b7f13fcf12aa1a3823a95902ff87177fd6137101419865bccd21b13fb533a49c1907c6149c0b70c721397a1c211d7c33ccea24699ade17d64a478b200cbd8bea9be38cd1636ee1c686174741bb729e8f49b90691bf2ea563b69b1ff9b105d684fe082872dc30d6be9002862980b329d933f37ee5c55f0aa98d76b35e170f2581de73d63ce5f97b089736c32307eeea49db777016b86adcfe2f0dba6cf12bb4eb7b56edc46dab93a6cd8c175f824f74fbaeafbbfb287c7002a621bdb3bbc8958fe895b8102e8e14a88f149e85c867c65bc65232c5bac4c34258bc8ee31d49f79c285e4012ef21fbc0703d9c2f5e7a50f6802722ac8a85542d7ce31bb18a3a2c2ddb69cdbe48d5046e91278be84037f66db7b78a54e16bb3f9bce70f094a3df3d19eb449d070d1a3c32de3b30adf0b929e043e058bf56419edf1488a1f075ccbfa524abfeac5b2840c56dd04b2adac3a4fdbc2c57aecd989fe2337257e74b614680ca1da58b3dba4cee6bc8157ada924daf931ac8a9f56b0f74811008a6d1c6107434be7035f13cbc37e8fbd0e03de3da6d1f44edd7a7031a3331701a01d934c60a25ff5b9a8ab5071da13b273be462a220d46cf012cfbeb0ee429f4c42b613d538bc78521f291057d42d19a637e9f004f184a574d020a10552b8c360acef9f45567e4c6e6ee5984faa4573c634f8c069dc47f420a0b92cdd7e7ee61c4cf89ab51051aff788026d0d33ac67664ceb5190268786a3dcc50068e8a6611c5c11e3503ee40ab62f561b28ac88fa65603a946f5454e3b6053a4e5f49cc33dd23b6b1cbdf63981a0cd3a585a7360bdde716764b15dc0bea1cbb2f0fbc6250d8e5ef18690fd8fd14d7141313f0575f52829c6432083ad5232daedcccb07d725b612c011d80a3e1f544400e30d0620048fa8952fb041c70e696e4e063601cf16a7270b4e8ef97dad869ea2359c21e6867f0db0ab92202e8a893a40c9a4517d0651aa0511ac0941f6b46067559551b702a54563951bff7e6ffe8b522fb210dfffbc9bc8c51b8b91e19a959f4c0c50126a85f97c1f38630c476d44363b3cd11115106fa8f8b8fc3c655ee3033d612558ffa7a2290087e541c6c049118577e745fefb86038ab4720d8cd0c77bea5358c022d277f9d37be529eaecbd7da8e9d431b2f5fda721d79bb7b96ab2c60e2b671a779509d82c4404403a1ebf80a810e5b18738c94863246a256c83b6a74c50f7f87071acce44cc1275372ab155156d9ac07993b5b96c843ac80a612267caa65fdb5e312a4a8bc1b6d463da4dc4e12b52cc169dc7c38bf440c8863fcada6257792db71718a85be8613d704da1582e017a86c8698e075bba4fe356ffb09e2d9dd3632b1013a617c970f5f36bf00ab7e61127fc88589559b32b25483bd6a5b9adb303dfd164088de22bbe266a4ae9fcfc2063341d663191bafd484ebb744786e18d78bc30211cc679ed461e7143dbe26a81c3f5b53068cc045fdde2436ca93bf8dfd84a473302a340cc789e3d5f1a60b5b5355331fe0f180ea1a7f0bf01133c4ece3ec505bd59c76c67bbca8f6c2e5dce8beb783c2a38c44d055548c43fe326a19946991a1f88b08bbb94ad701e5ece129848a902562b30f4ae5ec2584465942fc5d8c4e65e8e3d178ca919a61455202fed5f787e9705c30c949676a72921754e50b28b6ca1e7e5f8a646c38eddf59e16efdd83a15514d3a4ca6fc8f1cfa2690abf9c01d217dfa5a8bcbffdcbd3de38765398629f28fee2df2c7495c6dffa6db0e2ca72916fcd3b4848e433f754e51db436896e3b9390c7ea6b9b388c170fda0fc4572f6ba1def24f7853941aa80c824a61a5d53f0f2fb85eacb605580e42e84f32106f2c5b4055b6d4fc0ce6c59e50cde7dd80a342a440aef24af6bb2d058ecb54b21b707087c075e1edf18e08b77a859936a54c9e09d5177554d9bd84f93200b8b8a83bb56464b36938bb170049dd19e6ea0fc08a3cff457e79b5a372c211988549505d4c4901134ce157b307d188e312898f12ae9f9d14effeefda551d8351ddb2bdbba791d7747b685782581739102beb6d2235e8531d7730bd7ca490d8c47dd0db4d2afc0129d103f36a1fb4e8dfc6110319648042f1363012a5a6166554466548baa9a72c76921596e5482769a8562cc65afbd0213e1f66404b7485696eed1157af7f57f4da5d8b1e7778e00294d48d0f1158ddd7a6406b6239cf929ea1c3deaada8fc5d17d67133a6c469c502d907eb47cc6423ae88601ad0ca7d47cad2abb7807c4aaf55c95997ea85cfe3951912c2459601bbf9c7d06e64defe97eea45a1abd75435e20f4ade1cb7d9a6fb358f5d5cdfa8257d31378fb03b3e6ffbbdef46b65e191fcfc0413b5badd04382601283752d0780b9ed78131f866ecbb5b07195eb38791bb535a20d7af70630134fc20f3da799f88a46f940160b46497039e3d8c2dd7d495db7d58bb0d13bcdeafb8e99833f457c89e5985e5cb2c3c7e848858527368efadfac3242c7b533b2da8ebf104b9331d6a601a7192f27ab5c9d915be403242ae85fef278b25cdb0a1767524b5b04eacb0c793544e4f37d13b5d515c89b6cc3db5e61071663a625c96e2413744e15005784c918dde34123f9539df1ffa27c72188d436fa5fb647e9269d71e624cb07958ff578b437a53f639cf32bd6c8c5cd03762a4f889d8f1d513a21919b881e2b3c0aa9b3469aad3eb5de485d35d73c18f83d9007823cbe91b6c57d774cf7f26424407029a550f50d72612d0c50dac25567131432ae8d9129b5f8d741e45212f4936f306adc390a59d335c4f115d50178f1acb59428e6cdbe54b7110302dd6a0725c2bfc2f7fbe9ca8926e7f139c0b225871c16426435aadb72587326e6d436ec422c433a580b292c4d7d8b541c47f7405e0e710bcc429a43291a7d74bf9e4ca68efd1138e04380ee8adc14fe98b9e7b88993c0f3947fe92b6265e7b7871360af7d6947192398f701842b1aa98fc4d57c8ba565aaa0060f1d799bc0bf7e4796df356595c50dd180581a0df304051a52b334f9d9a00e7e5452a650b0d814dffd4bfa8f92e7b2ab77a424b45bb8229fb09336f75193d2dd724c4d8298c620278ae2c61a1a359edcd4cafd8e60a4e67432fad0073c413d44d74b577527aa1de93291df7b8296d8641fea3a15c018b86b77ec2ef27b263cbbb08d5a6f707f6c8395e802814990a9fe1707d3bd7a8702ffb01cfbc7201f7bd236d7a1d37a0aeb4e9090078e48dfe1cec653cdbdbd6cc2ac8d0cdf81bc59a9b5f5e6d683f9c689e5860e22bfb3805961df735b316f41e012fc79b703ed99d905d280267d1c130cd0fee77fc298c2dad6af02e9056aec8f0a925de31af0ed5a17441b52466aff0ae8451d6fc8a46852db0a4724b7f83f8ebb17d858cec69f673713163829adae3b8e56bf6d1795ec3c4caff64158e2d99180562fd774e9e67f23e1a6c421e2ce47f313703b58b082cf4756c61de17d739aa6fe2a313bb3b5932b7da8e2390c514cae88f6a47fab986045341e8166be942fedf0727f4ef960a5083487d91bec4374a24f8d452ee6680b65db84e8d4e264cc69cd16bc01e52787b36452bb2ad2635976a6acd36cab650fead395b630aa4a15cc1285f9805ad45cf9dc9410a0dcd5eb9edc1544152fb5412fc3fe7d82ac2a336c0656f05069184b2085e94191b334467967efbcac847feee0ba323dd263818754639455cd7134251f4d2efea635f11007f80db3f2b7cced3cff3cfd5c78057b345677a89d49306759fde475f331cfeb1bccc2afc1cdd9b5c8ab81646a47189829625ca4e5b9c566dde2c2a0be7af70933cb5d3f0242e2afead13ae45a926e4e22755984be66bd04a2fa1199bb997825e0bf7b6b13a4ae48da4cef0adaff0fee99b0546f4d50dddaa403b988dfffad7f029f794e36e6c5ba90a721a824b714a109d5c52c8d9904e8f778e4b5b570ccba5d7863ed9748b45d8857c36e94e68bb160576125bad924bcecb9fc7cf636c1e178b2b4eb29d587ef5dc1758eecbd2362b0b31855aad18d082af022505b9316a85c9fa7bbd8de891d31447bb7f0269e4431789c4f90937e38fbd101a2f3bd8308c2f809ea1515385f7d3c035b3a8d1d5d803586d4fc62706d6dea3e216c34c402010488ab249b5eb223f0e7a29bfd95a5ac0104eecd0fda1bca32f9808968b5c726f4f338afce73484b471e8cf7d5a8536045ff35ce31e57e9b956ddfec3594fa1291503737cb50ef88a8bd2d78f905e9c7d93d28aeae94644160c917d282ddc4cc1ccb168cfe1eb5668478725cdb1064d366600c6e5380e0fde1e6b5e3c5bf616a467986c1fc532d344c42cf9471720ed2e6834be5c7a50547f8a75e18339a3b9bf5114a06a1abaf5717688b488b125c03da56ac8751c246d5d0a3dec7135665491bfeac885a7fc4b0490d4c3eab466d340dcfc208a73b16156b29621193c005f5fd571fd6b186fd41f000659d74cef24fc13293b67197f444d44f2a8b133826c30153d48d755c964cea40da7ed91b412a8afbab45462fc5a185d9ba1427616939178e77349c85d89b22f5d4ec29075e0f6e2d54added2bbd04f6eb3e2def6fd29d4e4188d10867d91e8f44cad0052bb9a8f408ac33f9f3e3b483c2259aca96915299b1d578176d437a899af4e00ed48881a3932916937db81a589af97f7b3a536686a36079024c9c307241e0e33e7fca989efb479229b26038ae69e474049ff860821223392be9b990c59df36012e8415b50cfb4baa240e0bb1712e1193b4b10aeb492a88e6179a000dd192b0dd941b7e898390c92bbcfdc1ebfde7d1adb7ca78480f944c4403080066e564e3760a816ae5ddd8d9ab1ad5469a6e0cb2c4bef6cb5d9842b0f0aa3031dfcd55b1da842f2798bcf2c3be6718a8ace99252c1f2aa8ccce92d1f351e8fabd23adc244d56557c882e58d83ccadbcae425c4b6b98c1f814c8ecf176774b7f7aa42b6b8f6b33cb4e8b9679ea022222667d23a140b202de194d37afc8d7469e5022d86261f7f142ce1d1eade145d9e31f55afafe471e437b1fb11ec088669f705ad04b8994cc56ee5d26627629b6e58b1b9783b926ef1cbcfcf8f6bb0544e97f69df0c8ddc99d5ff12367952441f0e6446b5197b0a77e9a3aaac1483fe308d8c773134e3419853c44286ac7695d60e25a42d3ee698fae9e4afcec9992ff00f210f1b78133a3ae600ffa43a3cd59ac9578128ed1bed8d31c2ff3d863c7e179770d171b88c32830a1ae6358f4a7d33d0a3070a4d43e08e05637dbaef9420c36c733507c3ecc8f51bb3ac3f0069a04309a40f31db46939c4c294dbe3826c648a0ad44e8a43e7d1ade443d50157804dcaa7eb76c42c549e4f0f799e2f03a1c6d5760f38fec39fce5a54ebf84907ae15733e60d03b544c987e1ee4308154afa0506015c579e3c525c10403e4c56595217e514c85d3d78651e6c6dbc91f56cc955b3c76916855fbb5e50c14edcfec44aaec9bab792c586cf5c5fa261c062fc1ebde47da988e2140057a7dea4901e4963a11ffa2e74192894ba1fe398f2d70206de8b696473aa42edce86ff7207b9292d96935b81631c562c31ae180b7f5828aaed07c0b58e8580e4c78599330f6969064edd17982d6f22912365611dd907d92b351a7a127b69d3821e25bc46df68deb6941ff447f923fc13dda8da586aef804693f0cac050f5a622432141de8bb8f47d1ff6fe7242ef32ec66e779a4a41f4ecb631de34abcc38f9a495f5a5fcaf76f19a344502b9979d759b75fa29633504ea6358e568982d9105452b5d067431541dc7f2dafdd7e58c30138efc49606616ea99bf38fcf927667c7fa41ab2f8d6a08c6a02dc7b60156e8790a024ed564ec38ece87e2d17d478157bb6f761d1550335f327534ec252e3f1352ab2bbbb743ff0c350b350e3172d7b5e7c62db6e8b5a1d6ba779394074d2e10078d1aa582d2612dae4cdbf2fe3e37c7b19dcfae7bfd069baef1628be7ab660680f89670f058cc38d5db2431296793be72cf88610dd81d07fde88f4c457e3c3f23d0968b6e4ad2c6faebf840f15c4b2636624120b21a5dd027fa0f1489bcf243877e1b6679f5862f09dd374ce8578c6d8b2342135654193659b27c137f910802f0345a15d524c16d105e3e91965e28c1abf123de1207795f98a9cacd451f415f81809f64cf4474823d99854d2304888ea7fbba1d2d95205704320055e2f69d8d748c229b7a75a63771189bbdeebc8396ac4d77b170a959a1106f962874c9522bc3bbb09bdc86c827598d91c32439ba590d3d0f47fa2a052b5e034018748950413902ed748134660cd3ff30cc9d212de0326ab3d17b8189ae711785df1d6f45c8a6d98729ba18f0b0e2bfe7171f6a71093ba4d3bbc03a5093ab4f602ee9de5049ee6db7585ad1b6f50e7d7a8ab5f80f80cf7df11fe00ed04c762fe209fcacd3bdaeca3bcbd39f92b7d1c59228a3f2e84ca8ea8cb705375b3b49047a14fc9a7f20efbdfaf9dd51cf50024919fb671f23a51b4f374fff51fc853be9d4f1c93758f02852b65cc0656710637e074c08c9504ff6355aa478973a41dfbb4bb6b035ccd37afbf090b7576737412282a2a6e1df443f4b4268c752da2910ace27559e776deb285e2968ac75bd3589959c76cc9fc65516f78867effe5f08358d7a386661be4d4c64f3f29571472b33faaf4efa567a2c10a928f0649735e8873cc36aa490ed82688c1c8ae6fbdd90760c194bb25117ac738239b36f6aeb5cfb7c5baab45f317c9d2340061c174de94cd234d60468302d5449e64fa7ce279d58d04ae6173a0d637a5f5c53630c9c4c63f57281a2eb5e9685a6da2044f091300192abc453a47b11925c746b24290bc511f51040f780974d33edf1c2980ca16ae73cfe9afb71f705521892b59cf286cf1bd5a9024d3284b7d3e06876a4c940520b49779c7b0eda892a4162aaa3dbc71ddb641bc19feca967e8e15016ee689f0d2bb789aed3030b315647ff5066d37a72ed816bc1a77165c70e5dda142acc0d8007974f8edcfb760f31b44cf7eeafca430f7658f843bfc35906e920c1e79595f5db0c78101422b8bf51abb1f405fbca166db4734b93c4892dfd80a9d4041b2c6a9128aef957263008ab65a89e60c4b8d23c255327b7a4c516d9888bbb1075c526af61768312914bad9df5bc54ba3a55eed1b0beb0a5d8bd37cec2735ce0109ef14a1f1f5ff1eb46e620383e5d16614e9c01dc572d123caf6af1bb76a2fc2a1492ab3c519f08a7ff05dfd0c3d6380ea2cf4bc55fba3157fe9a2c7ae1b826306f70a6012d5cbe17c57ab7e7b6fab13382eee36b3c327b8419f3cd6fd1b7826f9599e17653560017620d3d39f10f688da54767c980d806aea9e4706132e14a6c6575b34e3d64e36a2245fb49e28bbc029cbe53c9092f9dd1f9faa86874ba5d95ef70374e44a70ae7d240822448ea7b6ba86b9ddde642495fbfaab93659a51e41d44ae3fcd6d8ea3dacd325ad5983040b44483e149b1ab98b84ae2fc68747cb9166dbedbf85a3297db2a02d5cd4656d1a822b320a7c9ef6eeeb773b5225fb030c1f62bc13ad71e4dda8d6ac18cbfff5c2883240a2e036f397a4abf5c90c012b2400624aaf0db55fbe8180bba07bf1fe9148a79e09f854b9b077c01e92d87ee25fe38b2635ed4a9e4d9bef276818faf2db694a1f60e2d882c972a7dcb96829eaf2681ebf0d96351a3a65bcc22c42caecd11ea76a0e35d283282aeab54d431d4ce822fb54d6b9ccade46c7076aeac51f08a3a2f26f0cc58320014d97a863ddbac195bfa16850c57249aec538c7a3f254a699d638031bcee5649906c71b3ea3917ad5b05c9f8773d517f1e49e089be6cf18bf82047140415560840cc6ff89cdaee86ce91a6e0d18a94da7619cbed2865b7809379c80663fcd620465ae0d763fe889150138e91ed00d692fcc3b262d1d3c691b3ccef9e2a1714493925adaf2614f11f8363fc3edbc68c6f9a65123385ebfbbb05e4affe37968ebf086a6a0ecdc97dd1b34ce72ed3a23a61c3e8975aed442783a8ba8dfda66838c3b5c868c81f30c23f00ee97a75638cb87733ba00f75b800e773fe0e53756fc62d491c21dab3b8e6206105e45e1d90233c3331efe9a74087f6c99a400e0f175e523c7773ca74269b097d9c81fc2f04103446802af044aaa7cd042a87caae55a7ab6a8ac9cb4d3030549438bf0339b7ec7ad3fa4fc7b100c48727637cbd5987314e8c58542d4d17e644334d9160c0b3e5c579bc44effd67faa314e35ebed417918a4a56c21515c9d5f37c527fe7aa4ce37ac326975b6d56ead187face6d2a62351b69a1b85a9b1eecc42fab614f80bbaccbf1d22cbf79937f156efcc3311a5d67be70193c7e589aac5fa37e25170f89a74ad87b04040d7a0aa5e6fcb64dcbae20d1670665eb0a4b724953a8ea3c7a58772c34cd58833d54bcbffb80cf4e35d79bfe0e84f72294f4326000035f24aae2e1ac6d6ddd95f10a00ad9d040aee43e17192ec15f56ad8b6b73b9e991739f1adff5223a1ede1f283a3c079a5bff41391f15e2b7ab862e741b57971db316882071c04ff360fcd364a6dc56fc89a5d37ba30e728536d6ed9ce34cdb007ca343869d87b529de9971e59be6ed057f55906b31a1a0e4ac7a7d198b2689c0cec2cc9bced24d586e01629eb1160c4bbe2ff430c5b1ad249c43acbcf934e0b489dc84562a68369ca818a6f2a05786875890d6b7fb96c9dc232546112f05fe202e24344f493f9fe1cfe3d7e206355c17ebc07fb767405fd2ad7fec89e3eac0c1d14446d1e50a4c6a435a7ff8a667cfea61a33a702695ffb4fc8453134f287cc187fbcd0e0e2ea48bd2cb745c9388f3d44a1cf2d2502272cac11cb4e8c2a4bcb676109c966e8daab2da7a64bfee04cb14fba2e5c3bec0b034dc5824faf7f96d655a6800b2b73dbac73e71d9f60525f9932517a74cc684bb61ab657ce04e4c88b3c79f93753a669608d3412dafdc7405c92b0bf271a7e409f6959cd65523f13486a2bb27f11614a4faac2af44f4ab733b59b98105d393b6a14ec2c782316968b5ad4b83239419266322ccd84ebe5ef49f1c6ec888b9b9de971808bf36aafc216fdd65089b2639a601935e7e9f3039614dd9327845a918f8713fd4e24fee4150dce2b255ba041ee9173786beb5c1048c439de0d60e5c40288ed56938e827a68db4691f4569229c5aaede72dd14a306d83b17a587abccb499cf34512e1fc6e39e477d9e99258324c3a46d3b423280e42b106ec74ca1a337b7ed71e64d9390c8699bb0a9f44f0b20dccfc3041dd56f9653a1c87777aa363337334f8f6f31d52537371b0b3bea094d5069a9226399d6d35546ed18a0a257b81c92c3faa0ed298e768f73f708a5e7516127c8520c8f68ec0a68546cf3eab4b2d5a4e137d566ff8028e6d2ef14fcadae55903159ce154a657c82acb667a2173ac78880765bed74e214b909ce4428651a90bae56844a7d23f66eff72c98b45906d529e65086aa3a7f6bec362356ae9c00e66883182ea7807727703178d885cd770da611c3c3e008bee8937033ae87d21025c9640f6380123be4aa186b5ad8d0be92f78a40dbc378be97967929b9661aaddec3145ecc92097da3a1c4d54dcaabcfe05f096b62867ee5443b8a2b682211a547ba9ea02684611c9ca52280cd21d20096639c19dda011d039e652f3459fde3858a3e58bc249f6e495f0a6cca2ad157f22105d83909276298c7c300ae686cb4941eae3d03833d43d178749b8f4dd340f6fad50dfe4b70ff63276bd66bd4943120baf23d9419bc401e288fe8a0b733406f93c041b4dd96f63302854999d9a18fbe819c9d4a1f0d11f6c71348f2612c68ca39b528825b7a15465cfc51b0f99029a0bbfcc3dde90d9e0081b75d2132e5fc3e071a1c1cae0449cc72900893f35e74f6b46176f0b37be6cda16bfbe434165e5e89ebe02c46967ac72c084ba16609b04604dfc0ef08b469ce2fe62ba0c14c6d908197909d6a90317d7885e95ffc8e09bf26163cd3d080492e8c97cd2d4ba3f34e7765ce84fb506bd67bcc57408596646eeb55c098821569e6cba25a30aa999c09d5e5a228ce1c0462e0e64700e5a4cf20ded71887ffe5c40d1ed9d6ac69ab5f52fe750e04ba2eecad1078d9f2e8296893058c6c87282216d36c7fd5ed60b1687e1459c26f5462ee36449b607d717f48637e389c0091e524792bb8bbace8a16cacc0c755b38cecf62b7646f165adebf8d54b08a8108fee7cfdf0e78131488542a8c2cd3481b477d7273e1a2f9b6f01495b29e2401580c07eacfa9a75a8caad64aa3a47d1e7131c82a039a41ed9659b18f668b6d4750478d3fcfc6c538ade06e2d2af901e3d694ccd95701aa2a9575bea2eaa27d1bfdf2d9878d548b42295b8094c689e63cf2e99888071e308995c6a05f6cf81fee04afe9a42608898e5cc25e8541416d91a5b0d8f75e26782ba98c22ddd8361f713fbca254d81dba5beda9aa4030d2c5d3f1a5fd4884cfd1bd4d91f11d639712edf8ea63472fe8197d6819fc8aac9516d67b9d67cafe2e5e67ba0b23efe40086147b2ada7469222941f9af7b3329c21e8b46f5e26ff8c7c85006d992f2947a33ef49c1f4d16670483b377f71fff9d1de551863d20a6d5ac88588abb2bb3051cb7cd1252e2236ca6619f58dea23959042859889186c976662ffa7bbf987e30e5ef819887a30f331c711b8af92353b389ca4e5f707f5c50f407adc0dc79a0d0eee1ff1a9990752890988ab8452e12d65c53ebffcb3b6b47afe5739408e5b3244e839ae4afa63a426311ee2d0424756b1c71b9805e2baad2812b098c50c5ee368d18eddc945a4fdb4d0c21601464560fb88c1ddaa485af20bc777deb44774582c303288bf6f3b39707f699239b63a45097147567da0f4692d90449d42fa30137fc0bb58e4705bdbfeeb18f3fb61b2d513cd55a37a8afb099e056ca74695c17c87fc79a66bedb37fdfe7444cd06500418d1b41ccb73fe79e70f9fcd18cdcc8f5e95a241062e8da3eb9f33cbd0ed1f8beb68ec4585aedc443b40bee751c95f10434eac4f31996e534f266e1b45d319cd436128408c57ef6a8a7bb00e2bf8bfeabbe90b3d449331ff6484fcf9b776ccdfb3c9289db5a4bd5fb89bfb540b24ebca2df624cf1067f1a0fff5b589b187dbd960c25625c81dfed391c10c89155070d2186f21ba4d179493f6bfaef24054e6062c7dd8f74421e208c4df4dac1bc5b85ce14ea81b57752dc921c496bc72ceb82662cd98c809a269876a881be6ee00fbbb997aa92881928a8aa0bfef253e83068dfb9a38fa0c118690a7be9e72e12f00a94b4b7bb3be674f8239cbbe8e3497f709ff83aabb1e4e3d8b399a36b96c3d1073c55f40dda8646a78ac9d547faa7df8443dae53039b4109e103c6fd35b5cc8769c5e4fa2eefc0af73c1c9b52bfe8e9177314685eea4c2530cf4b8df1142a76c6dacaf9f6af752005da9bafece7868b8ef5a79c9d8474d9eefeb4d4becfae6a7d253697275b7305782f08feeee9776dc07d1772d6c3eacd117b7073ea2e73aa865fed7ca55419a0ae1a81d3ed95ece000773aa0d92f0fb6effa6b1483b8d73125abb18c933a830aa425db19a30b128e1f448bb6520f5e7dafd87739dafff9e1ca63e861c33e6e1341795a8cfed874fcd4ae0d246dc10068dbfec0d8a506b88f78f407987d18773193f9a21defd8008f521fc9881fb75a4a12e08b7dfd264bb5febb693b3f752b35c7786f5cddc73d68a9ed700bd3fe46f21c38355ad1c92dcb376bf508faeb432d28d9e3b3f61c7b81098d2391640ee404c782e7eec9a4eac28b8de0adb5d42e19449938bdab793be352ede0bd8e70318d30b6bf3685530cd69146c179fba1bfa941d1b918e184cb0d36d216d2d4d9a69393407bbbd938f86d1366ba1c1290075e2d8beed4814284bc541984e6ef487f9b2a27f5364068cb4fb0797e17f78208485cbe53c24205b2854d5d917c9595be7c12215d2a3ff5093b49abdca6b51467d5e4eb9501121c77b918d4cafe1718851d9d5c4a1efffde3488ff895614050ac0750885154635d268c53d2a5418818414987c0d041b80a5a41e57937570531687685731017704e9bd6752c49bb4e7600c94e08d7047fc3c43342b9b5439bffac7dc04b0a75fc4e9df1eb2967ca8a07ca549c7689330e1c3755944ce67b45e995da5a9cf163e92c11828b52b0c265d5f09493ed8f3e15fed22f025eae3a2d9376672783e67a18c335c33986f317563a3931627ba663ff591db7c405771f1d0a59524d94313c6404df798423c0c8a83b8a04da6038a85d4258793f96c7793cd30d003aaa26f5cd174ae0cdc792a92a4bc99acdf1ce1be2a880e750442c3a3a2dc0c637e2604c32b3789edd1313071b48ef83cd0d1bd38ae142c68ec6fe5bff71115f1562c18e604ad27af30a355088400ef5120a8eaa8255e1b38d77c20998d25480730b4787160ca34c5cd370e3ef7f92f3041f9e2c854fb6502d21fdec4967e375cb5b0388de9d8bb8ba21dc5cf514bdd28cd052306c0914fcd2e2a3598ccdf372fa3f8b5f66027338bc09b76c646bdc12b43395cd6fc7b53318a4177d0a2cfbf923a2e753350c64f06d1d21010c9232758767061a29a6d4b3e207d7620dfbf2ea1513bad4d6dde55ee551b76e27e4d7458d41b0d155178ca7923203d648221815fb06254760f984531ab161d650715c0cedc95c302b5d299ea5a4a9a62a7cd13120aa979fc0105d75251c1011821fa83304c9bce3b7f0ffc3bbe12b179169f05a1a3998f3584e0dff9aaaaec4956d7a7006df63b4adffcf0cea195d5044e3c349a73b924789f5914f566b68e87f6b81bc9fdac680fb13a27d7850c868ff90d132093bf41ce3d2a253e1afd7c1011a57d2e29afe9552e9c53f6729454128f399799acd6416fd3502cab9501b73902bb3441d701e52d13d2fe8bc046a46b8394c89eabc501aac515fdd532fd6dc86cc478ca2fa70bbd400dc136d9b585aec2eefec623edfb47707bddf4b3b61443771edd12929a942e3e15567ffb039036f3d618866aa0f44f28e5b094b2d81e63372c0b96912f228543ba69e15f7e527eeab002c9cc5e5d9f4a4d368ebf5a5df6fcdc0239e5d2121087fb4c0eaffd338cd33eab068a9864f4d98ca6156d913c9af0ebfbf2a2dda72b09a7bd1bd4eb0da09f0b99acabe996e7cf28baadcd52862b15eec1ea660c83a5adbafdca08d473d1ff3afad113d3c8b157c562cbfbf0c727697e662698e4278edffe8357ccc07ecf567e67d4b4c32a663781592d9bf947c5e6e899a7bbd167cd970cac44c6dfcd310119536b51b94a950e809617c8dc583718f549754117ae02252ae8f8133b534e75914a950aa697b5985290dec661698a30d3d4fb1ce93e03ae1599cf5e71c87b23c9799b4d4eca9082b476691800446fd16f2fc698881bd34f1d73b3dc4a39b0e4476da00f7bc01d0b9d0c1bb1ae79a1d246184f6743cd3d948835b62e635239efe668364f9dc931a70da17babb49acbb01e42900c826bf7536be79e0662feddce635fcb561682ef82c3978ed948adc232eba086728ac1aeb58af7f6d0c454c51fc7c94cedba642318842c949d8956fe18743a178a248335f05f7ed26ecc7cecc547c23a743eca28f4c6572ff39f00d951af1cf02e4cd11a47e861497132432b3cb755a44998c5c4be85fda755637dd2c2e7ad35021f29ae56f73a12400a10e7650f62032","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
