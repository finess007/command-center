<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9fa2520df4b25499b8dcf606dbb3b457de2ff6f5597c78ab1a744528264aaf1bd8c7b6bcfe64ecccafb63d11e5290347a96ddfd87bb1f274748b93bbd45d6134c2d2ae7be64d046a5d521b08035480b83c680fb0b9238d276835c5c5faa5b485f3a26dd7cdaf80ae48884835cd7c5f1a1826f68d7ad4594148a77f03ee0752b888c418bf8e3189dbb24564bb0d66bc956ec068193b462abddeda71409bd3f7b807c38481d4a42be1b0a0a299fa4e093fcd71e395ed4604165c9e4b98398d5d92401eea33eaf3cc564425db2fd841c0e0b9cc86cece69c4a7043d94bb1b2f56deb6d0603a560f7a4a2d413b8c6ed8338393151534a4a77aaa0d7bbc48d98df5fd599adb7c09ece53adf7bf496f68bad0ea72bc4020b977f455785a0456d8e62608fe1014c51f50aea684fb297d2eff8750ebffc906779f1c6565e2875c633902d0294aac2982f55c824f2021b63897a85d621d00bb72d44ad0a52eeec98c9ad685b981dc6a357bede340dc8e817acd767ca87d352beb1dade54005e5b69c656c8cc069c2bf4a0452199ed8ff61c89efdf9a6b5d2ac83f1ec52c900cfbc6405d6142faebaef7da2c3cd3e8676bb9c7e9ce64c3bcb3574b8b7b559352699325bbb54823eb8845e157e51bd94595d372d768d2e12e46a8e79e269fe72b78341bf61fb0ce2762c55c0da521600bb7ed80a5c6c100884a66db53b3f625f73368b1f57db02c236f171f7082054f025e45769a26a3048ce99aab68e11f9638e6334498b2376d7602a3abdab2846284f8126a23742236fb740d20cb668477b6e5291e65aaaad207eca2c9c154a8fc026dac21639b44efe289627efb789d09ddacc1fc183a90d87d57a416bbb95fb4b9e635bd9e02a74ea2adcd87cdd48ac6e362c476253e2d9b251b1b127fd4df67c7fedf9e7c92d79f34e856bab4c97e5c562744cfce61b1d5379d34a0b0b7571397ce34fcced0d2526e7de96b6babaf629481c11893eb7b2d4537d25a38fd28727b7c739e80afd7e40b1ecc44e1815f9fba734e92c35e49d2855c6305f5a3fb019441198c914bba62cfc144d490024cb8854c6f3db5a9079a80c7218b46b13d16df483f6735508701ff6a0fb7297a3ff1bb58d513a9d4e551ed256ef5cf3fb487a92cc991d272220adcd8a63fa1a6c7c6b9b5ec283dcbea4040151825765a56c5752d589cc28756f1494af2d0bbcc7ae1722d3c3f9c698f29e58d287d98fa70196fac200ec03fef5ce632b02bf6b3ac78d16fa01dfe6b5671cc96c791c20d35f3117c8a718b481ba1e22c3c75955718eb340d119d116d3dda30f4628fdd42518cf615e17381bd538100b92befc9b449419ff73bfb4cca188f3b1b7676ebd03a2d2a14a34b5eb988653138d0014b8a493f5936df77aedf4317477a2b0e4b937e621caebcb70d2afe2f5d717e1ee3736046872db52343f176dd16ce3ee86ac2877c2b34d1dd3ecc1ef46d423dadc2c0729a543c8c52a55c48e9a5a20b80bdff9f6daf82ea9aa4a203519e37a37a638b82f60fab1720678869d9575f8987e2091e342dec8adeb7d59259716c0e736376254995d43c7d48729a4a028d4abb66ce7e77b1a580760210d86c98ef00081acece41bd76e7b475efdbb6ed4c47df9fcd4d4c3d14b9f3ede33b8de4d28c3bd750e755335c90c1a90e2e446056f7c66c01a2aab694e0b125eb314cc502503723304c412cdcd4f5cc50b093cb75f02ca92f64e0a67bad7367e6bfcc28ab20bad2404eab70d0e8913f0a0a700e3a18eeedd8118d911ade3c3accfe3beab44f30d89882f0a9e85dcddb223920c910a448e1c0bae3ea321583ab3fd96b2540a9b50c251cd6d829f6348f5d6751b6580854b8e1c0342cac682a4d7a6fad53fa8952251bcb671b614d311fac1ffd561a7b413a70b62756d40551f9e0b642856a6f3ef18b4b66696c287ff9dd78ae21b0495262d813b26e5dc8d498a5ac57e2ad74a38d2b31d7d05612b39b00e5c0873ae79303a20730c9188d7a32a6813ec752d0d7b261952ff10ba940beee14d6d25e5024597da8f61f1cc98bf31b8ed2977e9e4c8989dd120d2fbc00fb2779ed4593e079d6bedc46898c1322d489bc34acc8a7607b7ff7220831ab142e620ac044cc802db3523c5607920e2792a8c867fd3ec794bed696a3e56e71bca28aa54e697b42ce6f30d8a9638445b244947aff0347945b9ace68f4f2bfa0cee540dc62e6f2e70a8c3c0556716a558b709552bd423905cb834bb098a56cdc7ec6aec35c06151897ae55f01b421536b870a03264ca93ae4e53c9c52274bf8bd35984a9dcce137f0fa0ef1575308d2997f2ef28f94c861476e804077941f65de0b99f45f9f7464f34a9c3a15ad1c3f6f748e828938a5a84a7ac5c0e230e37649fe538469b23450218dbcc1235f71331c87eac148d04ab20ed2a737ea66b88cb46dd7c83f0a51f347c9362a8cc46f63902b01c85b03481bcf7e92309e2072c7f47829a9e61431a6d9010c9e68fdabe438c6e2f4773a5b3cf2943398f4f7b717c02cc17c55a211eef8c4a58b8391a62cbdf70cc229e97b143aa35961e24cbfa5782079b67ee823c55dd68e88690b3f41a3f14ec961d1a6fe6eea49e59da1f01ecc83822d4a0cbfcdbded7865e7d11a7d33e025940fee83a5b57b773fe1ddc358dbf12a424642322e37cd59f56a71c3ada2b096501749c0a73ef957fcfe604888e720f079f0eb374b7a59a5234f8adad615d28657d1ba7cb87ba725db7cc92221d245306eb4e96fdbe05d0c04f2ef44a8f57b0654c73e9b5c0e8e2dbbacc5c0825582d590a415579495ab9833be7d481fc17d230f342a3c2e8e01dd0c0b46ed15c845bcd01f29efa4310a7b9f7d913fbbc17bde03db42dc66ebcee0adee1f16da7c2eec93cdefaa747b49060ef9fbf8620be375a245b604c7aeb21f64ce00635a6c3b7a07504545909a9ba7364a0df05274cf8161b2979b2b8a4b19ac3947e501aa95fd4fd55f8b65646a63f0a3e1cff5d6c2768336943124f7a349cf13da8dbe53d1577955b15a55ef155af86c0672bb32d46c25c4c6710b7fddeeab47aae6588966ce05c99a65095e72d0c6e513a121e21a6449a739a6bf7bf867bed295f6c8b24cb43968cfdb40cb1acbba50af99a45b8c690d45b475b0f50de1da631fb88fe8891fdf0bd2568132216788e7926371d5f426140985c716b5a875c6e0aed5f85717c2201e5f18936d111cdbf441ed2ee30bc0d14ba350e596ab777e02d6c96510450eb8fb53ba1a7b6667764740e7005306c01510a60f14e83016e6789a761461f51b1cfcb6a3339b0027f6908237fa3dc4008efffadc3eac4e18455344b96e725c6522b7f68747c0e88950e9ffb95674805203258feae13073704612086fbd3dd263c49db61fcbc5b0d90887f8f61ad2f5e1977e63fc0e1ebe8c8f91b34bb864a447831d76448d43226e209985754d143b7b946c1d8aea22f38c9e6fedb6734db07cf5c29ad39132b95a1faf0240045b6f9e49e9ac981a5a6659349efaba74bb5479b786ffc64caba37267ef3b1eb988b07c4d39bcf8dd4f6031dcc0e5dd469c009f5165f97723a5ceac4b2fe14c326b4be9ded4f03c2f27f35d71b276d5af46a0348afbd932b7551bb6899b9b36cbf45feeea4e50985cd38e74ef1e9412c37cc41b0642a87ba690061c64ae0d12f5752ead9a5da8d1622bca7fee72d1824d1304e2816af23ad3bf84883f37a83bd47709f05a920933f11fa5006d3b15bc8390ebfbb61054509af0e2697b7f49fb67a4218ab8db49d84485b484e0520c85fc692d82d05e6c559ad25c162c264e68d3d784b6f8817b646ad9ea77aeb2151bc57c79ee9570fff19554870619fa8082ffe9e0419d6b31a2ab15b84f8285183652dd6fc0d0174649f609805c63f5b30a86ba6804804e90feb4279c6da100bff45abc2db335970cbfb81c2d364b30fe39f45c3c8695c46078de2d74cf5f722eea707f1fa3ba08515bf6c3ae3d8f8706fb1cb6155893e56b53594200db63457d114c20844a97986ea784aa04cc683f6e4afc6139f9785a1b6560e2ca5aa9f5fcb0c52b1d57979d915106a1a0be58d2afe59b621235d3e0f1cc8a48e9b655015d280b41d7287f9653ea6c3b4895cf7db8512424b0a0f40908dd251fa405e8d4a48c444797101d4b6d800e626342ae62c6d97693330cb2c28288d8508c425a25d60837f05c61b6bc1462b4b0e6fc3fd759f7be840eaea34eeac02edc46062d405dea2affe7a33e4625dfc9fd591787d05880837e63795499933640172ce87af2661fabad5094f8456a23d47e1998c4923948e1d9b2d8c3e17e71a431b04fd33d663b085253c46484e0139cfca3e5a4205c028a9a198f813b07b91c35b77ad026f74b4c9dc4978d8fdfef55a5f2b455123321333f65b41df992e017135cb275f549f56192ca09479b9e35b440adf62980a6ceb04f4f422a86d0eebc7eebe91f9e3635fa9b84680563e373bacadac6dbcf66677dbdbd701d23001c9c646a8344255458ed909ec6c0f1851593b172ecbf5bdc7584bacfaaaba8896f5645821b37912c217e463fb9bf7f3c12842d12a45389c8c3c24025aec371b5d48c949241ee8905cb60501cc74f8194f6c1662691cf03c59eac5c2fb27416dad9b9dc6a6d46ba7595b1f401a2ddaeda0eba9d7c622d982ae3096bfb46275d9724b36d81665e6e85763509dbf88c83bb41409161d1c52a791761b13f31d50a7ed70b96669f786e3d7cbbc347ecbc491b8226448c5bdc6bd082415b0cda68d6333e835aa3aef9aa73e101bbc36633a94ed55c64e3de53e5b51a35547d2ef2878bf28d65392432024e5179aff7582f0fb634904a2a85105450b34bea790378671dd0c09ab798ce5e0091f2d80b4bd9ac7d6ce40df1ea05007ee0bcbd54145f584317575720aa7de67652470092a7088793114c7296244cebfec0c3e99805b37114ed6a7e33be488a1e04b645dfd476df3a9812977d80790ac1227eb3f9b736c2e70b036192944726fb277496b22f28e818e3916c8e381311ad047e3e8d6bebf5a1a8b60786feef05e3fe0bb6a4d7200ae73f94e609aa4d23ced29aff8fc78121726115593fde696c3492fa7b12fe3d79ac1cbf5cfdb24df958e2a168d6da5d3d74009582cd9bedf2633c6983891e5d4259c288c18d440c4398f3d9e606a18526be674d946a1f029ecbc8932b338b857fbee06936690b210a4f70f8b3532d3e8a1f3c23fff4e73b1ebc57f8f97d26e6825814f2dd7870ad825368b1ebbafcaca73ff74e917cfda6f17e4e5db1758fab1ffe0a6932119bbaa71958d91f58cf72a971b75baaffeb1b63c3c2396e9420bbe910c220c2add941b3f7306972eb1106dc980e6f672f2418184509e5d9967489516bd181bc44f1dede81179987c91c824c3461f2eab3c06a544911fb09c86271c6bc169c2aec25d675e27b6a7fd75c6750089d46dd74137c81d710cdb7d608a3d500c59e9d30957b12e1676ec3ad3e78a5745f20c7b87626c1005bd392c1da523e34d8d3094a84666ab8df50dccc7eeca775b5d66d9abd4f8283be0a88c9777b5adcd8c4cca314f2514d412b58f1dd41844464fd4f120b9a77944fd3c269989073e33b7ea553c45cbaca427d19ade8a3e6cbea5125f93eec31805f83dc005fe47daa9dc66676e920994fe9c9acc398657194dfacf810d5e2a649ff1116e9fec7a898ae4ea97cc3d451f7d391959f25c9ab8eba422098eed1687abd3bb37248314891d69e93bf2b6afec5b90930642912e52a889ac324d80ab42456893cb70f096476f43fce98970a37e523bfce80a4320d23510eb0be1e6d859c81783fc344fbcb83ee40d00d37d6e299c3de1730e76eb5f1e13653aa924a994d7c635ea3cff11afcadb8df7e204a4eced86f2e212579e4715e63397859a159f2ad10c831ae2067c7a91f19f2dc12531dc63bbc051002ab6da3ac891c79e821a93ca84264bfe1fd5d56991cf4617bf8ad74d563a177828feae6243e4b9b4af1a2d8ab1ed9ce9a23fce7f8910f4aacd3a3981740bd931002502798bb28e5a43424f9de7cc4b464964cb4b8c0688b10e0801ee825b74127c9b0a0d0335a6eafdabe49ea01be472df04df551dd572293f62702ca2bc76619c578e3ac037589c8f5a4a3984287dc7a415b49cc0de0d0acdf16eaf84f1a1a4befd93353513d3876ada02eae754a1225b5602e58257373b6e16801c4dfab11e26d169cb558467ebd44785ec43fc6b2f6f2b9781ad2e4f930914de37232c18fc8f7f9f2a19681aab653e7881b2b85937f2d5185a77374c2d5541455787e363bcfeabee7b6ffacc1b334be9d2ded1d6da3386f680e4b3bcc9b8513695e7c59d791ced6070f9387e4d336a90004efe59b569a9d50c47eb434e2f9b0ac80f60f13439a927867f81c570a76d6ddcc2f692ce7d7d1ec767593f135b64a1f00992c32385a2d109788f24660fe9fbdb97c5846624099d376ffd68167a247864a794f71e401c6fe543f3799d57b3af7fa10842d594214043548dda8c1dc54cd8f827810ea28192716c0fa81808703a50f5054f22d9cfd0fced8168ee66e0a5a3327a097f24f2c8e51d7260a46618620eb15ab6f7ae8dd884242194527cbb34526d5bd6982010b68a054ee28cdabba508b6850a54ab2e6c06f7947416c4c55dd1753de8873cb909cc987f46e8918b82c276c1240b1de62f35d154abc61f1fc18eaec7142f6292ca369a73858f90035d13b25f8bd4b9682f39b4544d51c7f08c7076356d3626e3a704e8e5337891dfb27b1862e10556cab1ae69a460c0726f950c1e4933f4fe637fd829bae32933554be25ded0ca5fd3afd10b5da1a27216c017b81fbd83684f1f451fc22ef27d4aa99aadce333a3ebe1deb3122a6cab21da7ea149722e67b086f48859ce730aa68f0aa67117653f148924a67757c47ae4ae1fb89f261e6caf3920305470d4c8233c59a0cd44dec7b075132af647362631e669b2452f9bbb168967f958e7a61e629d5e05c53bcf60248e6b33e96701431c615b3d18bf16c4fa3689d17f59271e725befb4ecd26dfe3f27de164043bb57fc455f36781918a8598b24da050bfbb0ad52a173f1b21f1486aa2978e7de73ff3e8484a3e14125a9736bccc60d66b8cadffe4305d275f19c0bce1a87bd51340f29dcd9991dbab816757d25211c4c6d70398f6de9eea265df743c6118895aa9055d65d70b6730f9e890ac73a0d051fcecde72066a380243f9c538e1ee0b50b3d1b947f8f7c9690a27b5de5a64a09a9c16da192bb9fb132c67d3ec1896f986b1d3e6c84c3995da73bfa40997233b1b06b8fda7583ce927f866507f32d22e0d811588fb92b0dfe0b4cf20e7124bd1b71a749b47b3a55e618f7f6ea35bef9b18788f0f86bcd96a7e0ceb1ad5e788ad8092adfe0e6842edeb823d9efd41c45506547cc15c021b734cb1dea6f0f9ef8fd3bd38fffd50dc411ce53387a60c681f2e03c0cd2b9a4046682911f9481f582dfd4baf32aed8eabe967b10fdcfeabcec87a3da00a5e74c7430dcee788c0632d33eb91eb1fc4cabb0d3627a30bb56454ca62d9f6bdca458f0e84f0070a260fc7a1bc6aeaf293c6aeb921885715cd23fcfa9d11eadbacb342bab1d929e2e7c059bbda1e8a7ef39b3d9284352524e6031cedb13799acb20ae644ea6b9aa5238e00bba5bc9953353f312e212b1ef901b7de4247b18979c271e181ab1415f02fb12829998f810e319bfc0c3e1c17e652686a371ad6b91037e85d0326195a80e08a766a497968bb25390bd45395c8f5cf2525bb69fa4b3388e45fd1c9ecf32cf94728ba375a70253a35657fc93e37aa4404b59b34037fafc3d9acf19fa281d1c2ac7ff3af636f37885f9d4f81e48457729fb81140efdecb85e7409c67e15d0faf4410541ad25d9b57c0fa06866cc0401f3332c3770b501b8f9144caab585c8b094070b218fe8fd851758562c78488ff751d6657e5de969fc26f4dca3610e0878d88b711d0cd75f68816b762ed41552e6d9404049a29da53b3a2162c731774b149aeae6facd6167eb870025095f11500fce34ab505176638fc6d03ad6adf76b46606cac9338f2b71dff395ed07efe0e9c1659e966ada44b0efaf42318d11714e0b1fd746db10a4d0b7926c20db63880079dc03e2869f94ed885ec21b909114c022278ecaecba1bfe70c2424870c43abfa3034912e20080784f7d9d31bcca4d1ac1c51ad5a026b178678bbade0d9f2f252932bca13eed11b50cc2e374c4a0a6cd2d77eb72b961f814be23c7c0f8913224c027b4493acb00b9421c3b0bc212322579a1c6d8e8d7bf9a960b35d70640a1627f33edc15212d208874642e3fd5d3b5d4a5bce6135eb3b59a2f524bce493c5b0ae4cdfbdec87ab8eb7468777a0b4a4bb30f61fad505bf86d69ed433e5e1418998df45e13a6bb5b5c43c04ad30406c3d770a4166f54205f19e44c8246050cedc06b75c12ca22c9426ca2c0abcbfbfcc91dd8ba49bcd0ef3321724a8cf5c8be85030684d60587e06036e9ff6f8d8e4d87a571693ec967e20c268245295ea13bf04d41d51813120fe1268183cd753ff8006fd82d0a16058481e555f7ca6b35ef995f76924ba6b5f3d391922ca1bb011df36b109cf9bda7f3199c31e1b1328b178ca65f222d772949a4e66f49fd356b58586cd96306f45c640d03b9cfa693560301f7999d684fba42bc02be1ba72cdbe6b9af0fed5d315ef7fc4983439ab3e87528b904470d3056fdca730c4bdaf5c7620ebf626754dea1a67209d2aeb272bf6b9ba06af7b0a90d5b0595416a49c4d367577eb9ac58bccc7b49fe6a425478e50476defdd33bc0262d1d2c19d2e939e261ce6351fd2508eb960fb882f6b79c2a704367099ef45c42e60936403edef87ed35c251ee43f23249296deb30dc67c6f950c01dc392f076172ae6b14798b15d4106abc57a21d2454d125c78b20711b6bcc956e93084a00b02bc3af1136aecfee91848e82b6812180284f7ef71a423a2462b6f242efaf1543409c002da17b3bafd123b9d386509666b581015406b5baae25f3790b29856e6244ef445d660a9f3554f163f102ab206dbc3df8f22cbeb389e55937f85f3303b3bd92a879c08496f3acbbadc83e9b9968127019b2813bc34e1dc23cc7f319124d5571d6dafebfc46423f03e1f7e76a13eb42e7c232c6a4c5c18cfa60e1fcb3abea62923f8dff0adbcde555e8f118834d9b2b3aadc69975118229bfecdb532451a6b9c2e205c12667b625df5ba0af872256f726611b2a39a9ee163a039bdc13390bfc6473e8404bae55edca1f37329574092eb4f48a38065b7c444e7b9cc48fbec86895424afb5158cb869163bb86694844bfc30ac304ab67efae8fcbcbd84196b82a7de06c562eb16303032acd2c453fc152651c31f7e4fd720e982152efdf86cdf0a4d3a7ed2174708afacb1c145e46ba176b469d941a7c513e5f3aa30539230e42af448566ed998253dad5bfad6647b45739351beb6bf5cde604d694505a780b41a4f2505cc04db912a270adfd773e6fc7892152f01837e149063b8202e9cbc31150e60419ab6652b70619fcdd8eb32595ca9b86602cf518624738858024a936f927c8b003e635109031fceda3bda79dae9c62b5f49b22051527bf58e714c4212337ebb9f9f02f6bf612c1acbebdd49a8bcf029bffd4a36ff77f81542223a5bb56d28f347d31dbd994e6fccc6523fff882c997595315e5a09e0fd5f3ab703990a13d1671757c3ccfefff02a48b034e6ea056d4d054681b5fc0ae4d747fb86ab1b3dedcfa9787eaa5cd559697a30f76a951cb0f14ec3caeea4e62af756250a1a2b506cc6e5be07dff52731fb8af21cf8b76ddbf6d69272466afb9009104a461eacf2d4caf9b24eb82fc3e658d3a2798b17defe5fdab74c2dc9733a6988cddc2011d4c364af9f58ee1fb6393b04e9e0acc969b870a8c94732dda9118b87587c5dd30ed5de965a9275cacfacdaf11a081d653d7c45763eb8ac33b4a34df1520a2c67e014d049744c72e5bab96d3a3c68e80f028dbd7e069547ec3a25bd644b6f1f51e2f99c684f90ecb93a6d51e5352b31230e4b69206e7f5a0d4013cd72456697d2b5f0da4f29c54df523d02fe750cbd303b6c2dbce11ec7973d3af290d5bc0742648eb59fa31bdc5f73b0728d6c889fe62223f358bcf5fe925db1bd93b6c21bb93fdba7fba41528c5ac3a42b2e428ff69a56ae0fe4ca279a2c96e8c77501af52f95a7c787c84a40b2e310b37da2e5364216ebda663e70d2c79d774018aaac7164b3a11446991c408d5c889167d55242c77a53ed36ac0e6a2fe76707a6c8f50e12dd27fdeac8368938fac22a324d0e3b9ef37ffe739f867825069522355c37a82e66bf07647bf600a9ae9cf7f79dfe84a0725d7d630f949249451f4368799123dce7de996383cede662f80d2b6c4da8053c8aced65b8f6d3f7bce04d26f74bd7f5f362ad051440b77075e62aceca946a437518a4555c6376659b9fe79898095262112b5598551a70018847945479f4b0a89f9b903dcf8c28ec9142c792bcb8b4285d36047b6e2ab1a9e396170d736353e48c53ac1a20e34f2e8d7ce026a1df9e7380488ad09e000e0aedaf5755044a4c8774e226045707317c468c7e342bb529534ab80fa2c581908d9271d045af8979d9e7620068a8ab0cf098dd1a0f9c81cabb91a1b0d9cc26848d60587e99db79f25c9068bcd53249c3edf31d8ba92798eb1b69d0cbe0a3ba6e7e34510838c6d0d6fe6edb753a154178b581a516d921b451999b11d43e84e81899d3156aeab139aeac765fec29b48ba6d9d1df9d32a3c08ffc6f9960193215dce8c16f04084cc858e8569d4e219b22de919236e31cfec17d04e31981e7d96df660f2421d78a433678e1cec512fdb87eb2d5a295c0d60ae0af810c98aa4d9adad0e29cf016ae6bfce0f91c7a227e922f0df1114a3015a96539f95f127ec2f61393d5731d3843f6a5b3462c3ce49746c32bca2eec2f71e04916c6f938403b41c73b7ac94cde5afcc35c23d3bd7b4f2709307ce8c4774f0263241bbdd73d34bdafcb587dac2c71a3a8fc4ac5195bae9bb3d733a994242fe35f37a53842004161d809e09404dc4138b6d3a16c5cd5054cbeb2b45cfda5920db67091f91ba1dcf7349ef995e47d6d0241f0e0f67fb615ecb51df009f0bbeadd05930cd8d080d6af0aa87130591d023a4b6d75382b4cde4284c1b9d8bca4cb43efeb67c6c080a70b0e0eee89c74e56dcadd5026bbcb1ef2080082372bf5b523296b96ad050a952c789141aa7632dec5f193e01b4fd1cd49da1d5f45dd0d966c80a28dd9d31efff38dd8a91b8255893477dd207b84665c481fdceb432a5300117dd655f48e8198e938668abc66c7cba88d8102ad1767300b7a1ceabd2fa24efb71d24326637f9f13f53bb5bd99dc94422489b658f2991e0b7ac241f4c1768948ca632bda447751f55e94b14d7565c81e213168823867f55db7152c8acccc8ff3a79a430b8787735186c277a84abf490680ac34c66041a6470e638b9b762e5a62190c88ba817a4b7d1b4a72e6ba061899e05ffd07c1620dc38fc89c43106f2d207a782bea47527714dcf9bb68b04088b55917ad71cfd2dc9ccd93232101289944cd732998b10fd181dd159708ef8d40e7f6d93c46210e83d107b46bd47302313b388af78c3fb031af2edeccd7445422abf8eaffb41ac7e8e167a1e39061ce7d4340e94c6f6e8743702361dc91e1f114f36d92dbdb93efe477b4125a018234b9bb06eff5c56b41c965db20858484a9acf4e51a1f9d52c55eea657baf9f891edae109fc00acfe8e86e103ce71fd726180f5b3d394f23bc5f73b4ea3ded0c63a076d8a875510e7d6d41643a5387c2a9427d85a0a44e81a73040f2022f83b7f3e83e4b46d410247bdfc6a83cb1f4e2de1baf024fe4b1f7aaa5af9c9cf8d7b85383fc98ffd6a3a7b65d9dcf921e80f634640e16e633feafc8141702d92fc3489527985cb1fa4d9aba35af063a2926a2c80ce2709ee16138145e87e167e0e3cd30840a4bc66378a950a8ed4e041d5cb26b0be33659bb6c9a85a56a3182a6cf4ddb5ca4477fda3e2af8830bc008237e94b2ae251c25af7dcce76b97f91d83d5543bc3ac2691ccf539337c5c3f1f3c72c3b311f09ecd696818f41ba22bdf864ef57043f570e52b8fdcd9cf5021518c5b8ad1ededff3db1fd8b1a67d3987de9b2d675f1334bb4cf0d18b3a50c1c7c9444f0e18bad6a0c2273049d064f92d1e04dab3cc0c1a22cac3a499b2e28179278144c4c543ff60fbb1f8e268b6243b32e81cf679a35fd0b5011a2a953daf81c4b566e037627c0d431fe40db867723c35008cc6b6cbd5595dc7144b84bc1fc74aba366eb044666635e150c013a2c6abc354c6b7b36c8e99e4a6c577d3b10a6740c8cb65476d457f18aab36721ad96dd43ecaf0f39d5197e4b6875b1a0b9e7ff46691d00b839b582f76d23c88c6643f0b7efa0731348d2f43a040fe6205a648a628500a700287a4fd15f16b5fd4ad1c6c60a33d9d52b0972642887a97493c18c6bc5d74967ec60c058128131835b27885fe5942208ab59da58ca2d7a3b2eea1222ce7332544b7cf895217273aed9ad3bbe4bd4581aa47bdb03bc218254ccb291af22ec50319924321c04c25a8985549f332ef95dd40660018be768efb9062c0ab91fe7c0ea3443e9c4cf508eedd9b357e4726495efd9c2b56bb1f3f275c094bf8f3b85c5abc87089439ada3e66d5a7a088431a782cfbc33a9b3ea10d378fe19885a16bd832975ebe175941c0fc0ba4d02c89ae96be72c5074766f93bbcd021f50a7ad11d1faf08534b8213fe405dd25ddb0a00d23656e1db80ada23ce5bea267baf8898ffdc9594f0142e8add9f16ec4625a036befa8c36cf215990a66a324960bb4c811f805320a2febd4e22fe8baec4451ea07c26a03ce46a71eaf55045085ae85da3035f80b40a6e5b76ffe77581efc3fb610976e7452547fbbe7163bc97cd0b29a0f8fa3de5ea02b597b6a0277c729d11580c3aa883a9ac93f6d5977773fe2fa7e060088812edfb45da2a4b7097955474f08e1d816f14d9f3d8b69d9a7d1806c6235a33f4583d181812eba50be927afad7b51033830910351997986e6a23b353085cf8eae73542de9d73551122d89446e24486a2f278046c8af1140aab1502ab5809d2895873165122f97af29864176a1ee4a7c8b81b987a79a5ed8804e9e61534afd00e02de8d1c816f8f3c7c8cb21ea1f2263514b95eac69d155f3ce823a34cf646f2595cef444d0832f04095556be07c9a02a5ca8876d0a75621a6ab3d3561f9abc08e223f25ec0921c1fbfd49335bc9045455a6a4362c076b5ae1511c57b1a2fe979de347a06cb4617a5db6de41e9c4474d5b93996d807446b65381692c146da4efa8365b5c1e8004bef629fb6fb221f8013c83e76d94655cd909de490ec7c94033c55dff1917f97f5945bb36eb4a4dcdeb07fb15b08a0a5e5ca56e46b544a56dcb13b5f15f54870edd9ce13fc12baff25d77b60e290f68850f82c36de38523b535db0ac5f8858ac1ef5ef319a757da3fde5acbdd2ac258f97adb51dd3d1aa4ef03b73ac6b66668ce144f00fbfed917d54ab470722750d68e29270e7b6e79158eb23bccfbde6f769ccaf30962bd63dd8ae2cb350ff0f5317c1ebacc82b8d79ad280ef9fecbb5adbd00e0218a5f2d3c13b890a2ac178b8239a2142d16226b0a2413cb40ebbe0a2f6a9d15db5ca6a6a4b9bc5a5f049a02f33e26fad6c72f38b9e017076a2ecdcb7b381a4397a26845fbb1eaa42ddd350b40d8fdf5bf23a4df2b2fbecb2a30fed74c7c956027831310fbadc43cdfaeab3b8ab93d67fede2139ce043508cc6be9163a72cd6eac19e099a9dd33f0ada3671f51941593c8fa3b1efdcdebc9ec5658dfc014194923c193c3f4776e8659b1d07b1b5963223b4408798c3a5a25d55b6439f161f6d1b8c454335af19b4a8cd56189dc310a6ee0a2c57d2545fdb203ff87a68471dd65c033b885ab2d34f6138b42f28ada880ebf9ed7d707c3cf5f01d6f8ab717de4f6fc203b48f1a7dde3bda2e51fda0c0f1a16ecda5936c7a33f445ed86d9463b8c566bf2761980e56998efab26a7a6bfd3f924397f32cbe71e394aa735a353bd8995c12a37d56a80dfdbe4a9e5b7cf97756a4b9cbc8d3aae64c436653e6bf6af8772c5388c023da493f5054382a5dba5116f7a7972f3bc096572ea1ab6018e3962287c199f3d9084583f3247dd6e34dbf240dd6b973774cec53b6158eca063fdeba950120beb2ec4bd9a8c2d37b6d6557f67fa6854a0a8cf70cb0d254c5d7acf8b726503426134c53ba7ea8f95b9df33cfe7258b953ff5569d422966329051e3605c8bde4c53169f06217e132652c4b91a5af4045c084ac4b6e23c564e206cc5c470e734969990c21df0ab87acc543be8236d5ff8bb7315031209b6900b2ab161dc73129ec4f246f9846ca7581e703e41c7712aa1e9c131c4f5048db1733502cac87392481837c16796e2f277e712c4c5c40a37f1c1f734ecf962320165dbf1d0b2ffd937c8bc6e41736cdf4ea05e0d1d7493a6a1d13775efbf7256db18ffc37fa329200069c5e8c295b9b7074c9141696bd8e29a3204745c4ddee5b1fe4400ce0ef391ebfdcff3c0960f06af0da9e897abeaa3911bb4601960fc56b4c21a15be16e003e93658e4cb64c55ce7343b78f26f47b55306f311d4820b5ceff51139ad0ee6a3311239b8d65f11567b69fb7aeefe6f46c647dcbe17d44518c6a3846d65dc9fb2a4fe26272fafbe31e84b3a088eafc8b46edfc9617df1fdff4b49b194a3d19d848088ae101ce308fa2bf1b6e148b894a3661da7aa5ee1c926d477ffb65f5fb7d2c5b5d6a0524d9fc1ecca80f14fdae7589f4a7de8508b089176e25d4136fd175766ec8701dc0da5796a70640246ca725e2e7f86bf42722d43392788bde77051826040569efc35bd18a66b4bc96886258d16f9408bc310d459a7d438c3c61be5058a3dba0b94a108d39e5346541f196dca0d3abff4245571b921e318e2fee7daeb4d6e414152d59c68af84f8c4e3a7cc4b1029fed357f1dabf5b3644d0328e304c8df3d7e2417aa2295197a7006c60f3ff72f6c07073455d18914daccc7e182767c54b9cfda0a58740f4640a17f4b0f5c3a831fc8c6b99c7c30b07eb92e62b89b5320c3754d28ea814f31f5240678e4752d25785d56473cabc7aa05d89ff74af4a45e44603d7483eb6109c53c4e831f54d458ef62643abc3b2d0fcf09b555ce6a26fcae54f30fd904a344d3bb27098971c9bc65e40493e220129862e821c98b08fea1d3c62e55db73ba9e0266ec1d759532d3c3c381c7b7fed68da9547193bc453c9d69470efd831c4273ceca5e6114ad70a426c75d42b0fa9d507a11585a3b85d1812234a6072cf84d1a1fd1b2933c7970781c9cc4c2f27e443964fa4f7a3398db014079ef62317c20b8a896fb883ca1b7f414c1c690e2196ffd82e509907873f2caedd375981a32737c073210793bb2be8669a388f85f9368d812c66b662a587f301ea2680258fec6339bead8b126ad4e6b1141fd4ab8861c05ee57842bed86da7637f1b22ab6b88efcae1619540d9ff88c7895afaf3adef8fff31260bf22877cbf37f6d7e33c83a33a95d4133085574581df1424a14bf0640311c8e68458c2607d70c7c42542b1f18fb5043bd44693b1a5178e3f0d9c722307298251c63068d884d8e850d12e1b91df2707fa605899fb5bdd5a0a1b5ff0f505610d2f3fb770d1f851a7b662ae373f13d290696058679bd6983e133fa1ca297add2025109b582ab5c63303bbb2bb3fed92dacb34cf62530222f8527343dd6e4b4621002f2dfdbdbebd6335ab7bb63eb3b55752c596194487984d08368363dbee4f676d6ac33869c11e","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
