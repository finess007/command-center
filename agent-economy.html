<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"fd2eb79e7bb89dedc273dc424720a002e3ed140f2a45054fb8d2bea3fbb51fcc5a3feab24a7d3dd55d8ac30928e2514f16de622b114acf53d85fcc08ed50d552f91d584f66c7b040b80b334c9bee7ad8eef7b8679ab05f342887a542c8fb51422b059461f392a55c1925543fa435c96bbeb808c030d288f1a682f48bfa34b5d481ddc3c3b69fa7069d3efd9ea7d225d832b5297b5336a425f81031a54adbc5e4fb45597193ea17d38cc023f63dc1a1a4e4a8d302b4cb2f8010ed52a626efc1b9a19c2286124a149eb44000ea71f39cdd5009c2bed32080623ec12b6393074b219364383bcf851700837560a35ba620a173fb3e98cdcc80b94a5a088ea589cc00be66d94fe40c2cdf7c738bfbaa8f86adc6137e597b5ebb27a9788256c881a4acbed0dd838779f083e21293f5fb72662fabfda57e0760bcff6d97b2559d05533b265277d3d7d9e0b277429d7fd879806d624a133af443dc976f1b4080b31586109e11a9358e1c50a6790dc6a5fe239102ffa91b81e6175d286d12db453265a06106848cb9ed1daea877804064462ac3eed6a61968e289c60f63bc1adc8521879bad6eeba1d2b214c20a9c46abaffbaf4ef1d485bc1ff8cddf3f9b844a9b49e083e64fe0db969c664e0d7949c70520dce1bd07fc3aef2eba34810e95548e08a1969d4eb474ac46623e1aedd06b7aff552e60e7ec1a6d6f88b1e3f858934074f3a90e778d3aa102975170ca78d81d8c290b8e2e7ec95be92c38b7451db9188b62c0f35b94c17291e10d174882c8f360f1c9244701613c97b12bc21a77afec0f70601ed398f6adbe74f31385663c95cfad02b6ea4189d09bd3f840aaa588c59d5079dc7d9ddef78970331fcff469ed9e46f0e59b23b62de495ffac2f46fc9bdf3712275577d449991cea9d529018f67ccd6f60dde7dd20cab8706e051a689daced9f439671b63e6730eaef17ab7318e54f0ee633d41b82a08f8e4e8061d6bfb328431783a220db84baeab65db48a8d705b1ce3ac9555dd97d4030e53a12bc38cc06e64a58a038bf526d29d477c45260d461abb7537f87b12dc63369a48178d5f36f21a6b33b6cf42130aa2b19c9fcf5187b6c5995e1309f865df65f15db17bad68946e8643901e8830f6b45da8fcf6da9fc69712c81e4b32d0f1ba17dfd66043e0099b7a99adf970267be1ca31361fb81607f46b3e5545973b3b60e45898a3e67b78b964aa12f5927f5591d94ce7d3430d605de08dd95e663068ea2a1ad0e66199e719c55509a3c23bc920ad4075f41ad9c4ed5558e040e65646d642e24c43e505ef8535db361104d325de03e940aa37215209cf30595541d3704883412935b7e9d262d7a7e97ce414ea90d7bd1ec3229b64ac765e6db9aba7e2583e2782575f0f9620a0f5f10a4543adc5282ec4f1c9c292fc7bf8830f0ef8fd50ba78d141283735e37b95532a4df765c63d82ca52cd00605641e0e6dd297bf7d25c9ed9ad5ae61b1e5127ad8398afa5ccc519407187e0433c69aec6eb4863a75f2a22d637ecb37dd994a80bf786bd59d7a1252179ac99c2a50ba05cc90f6b1faffbaac6fd13c33c3e5c871a5a60b0df214b8a2531d252263657847b3e4e5b91d8c42c791a9b1b5cf80eaf61e09b76a0cacaa62634a72223ebf79894342dd72cda51626b5c8fec6078b31d77a9e3b813b207ec6a17fd8575217051b9d34408d92a95e3e76330474e07886557c27fcbc6e369eeaf237a089247b91b97747373dda740f62b4274f4435c04f0b9639f50544ed09c9646c11da06d7c9fa652e47cf589587b8c97cc98cf6d932ad2cecf319c8148a3badbff606d51db4b71b4de3d825fc3247de1c7bd476c1cdd3a98e45db37f530610121b085ec7dc10965b06d309338b7322370fc176d3705ca255152e0eeaae05ac83d9a3baeb23fce0cbf6c61366d933e17ea561f15acedc632dadb467474361edc5752841b6fdde7467acafc8dcca4f78fe63e92ea1b63352d622a396872db9a4a7b560d95d8ac43656e519a9041942326cc5ec9643916e1045fe8e24d6b1b54c1104bd7a8cdf41b8700a68792d2a040e99d69c99f971f921cb9ddec960b2fab1bfcb5841ee43cbb5e6947a045592b59cf206bb8470879068fb3cdca3d5455184c607cfacc0173507cae7fa01a5b1e22d0a1a6409bb52d170d6237bd7c34ed1f2c985c9a1f56a71f81347864c9ffd4470f610375b124e0ec0a88e436ddb79d0d7f0a72279559cf94a6de7d635a97301505c340c81f7c7b820309f6f6feea65be43831ad6b43c80c3ce7260164abc2519e8b6f48bba0469186e252ce2654b6066ce29007efda83d4e598157f0039cc15e44898fd337c14c89aa5aa967369cc185df9926f18837261305603460d9a86834f1b0d48bf977c61960732df8984e0a9a467f2a1b0c276f3a8e675eae0a6a7916fcc3e698c716b491455db7221f96bff315a8e6e7eb4e2f3b76f096d5b7bf94f2260d11a00f9368383d9f151b3faf6ce25290b6063455fce8dd2a632d6142fdd3f8885b83af55981e8166853c767a427dbfa82b8902100882e6a7bb525c96b3c189116c4a907b62d980a6310078aaf2b450b2c2560241a87d1cf41742bb8817fe87f7b2aa34856b1ff3b01f264e9f6b2bc9471003174c6e39811256d1cd403927732dcdad8de0bcc60c65f0a4376b648f4393701e4229137621b9aab6f8b7682f514e83024bbc5d47615a47a93762067ef1ca600aa705da87e4490af22ee434f0ae45937929a5dd1b9c12f37cdd2564b73183d7d3117ab62e0b3f3db49055a1c1c4684cde6fbbb6407d8c6021574ba581ce862520a8a75a550d80f66f29dececd8406e66ba52bab5db47ddd7d7d1fe8cbc39f092d3d9396ce7712492811ea403bb343efce05f39928f221a899bb4d15ce97f519aa4d86175b2be3adb8b805efec161f84929ff9b5ddf93c995e35648e9f26647937363a6905f29039a77e6d6b75585c9975f916ee5ce9c32e9ba19cb98ae255b9ece69b5f67cb1339b7da2c741e483627e98990122668590bc597e8b21621e89ef184522bb935c38c1306353b456dfa06a922d3b77fbe0917db6a72e2408c5880463a9343a5dc7f63c86e2d6165b638a521ef3e730f1ad8b6d81d2096dd2883387dab03b18329347f1f139f6a31b4b1d99c51286ad2a82630217b93f72db3cc30c4158de01aed060e76471e000b251571fd08240b1eaf2a2adad67d2bf52abdb486e8537c9497d8bb56312a0bf00f0e8fc69d1ae4de46dd9875692614e21831cb6e1b2b59ec655e942e52a3bd6cd4844da65169a1e948ba53fd639e5d77b1335fadc69d2122460bc5fdfa94352beb7851a4e15bd60dbac66c5e6be7cb62323001fc75c9737fbe1ebb3ee5da801813890e59a8dee762e8064cb729760912cb494773c9036060199d7eabcd995336d8bafda300ae2ac5ff738a96407c9581a02655d7bc2fa1e50eaa61e5df816f08908d77dfe1ea1dc3853e74d8b5fca2b909a07ca685e9c701fd1e1878e9abe18ea92ac922bb08d053656b70ab9f76af4bb26ff366fa8474283c1bc11cc9f0a2bd00d65a44d56a4dedfca0100dd53f8980aa9432026b98fe4b7473a5d552ef9e18c654805abbfa8c82d36f68a847fa8582d277b16ebea97b4129d3001c0e76ad2bdd6bf04d629ec32e110b7e15321b3cd0728b3238412c2f74cbc42aa2698a3f7c2b5899194b8b05e0dea8bc0a27fa4b9da8b902814d429c189464c0409a899d86d6ddc0456905e969c4dec86b87a2d0815a0738b2e7e7b56ad7f89ee04da3064006156f2a6ecb0c0ac623af1a2e15c2109635680a0b486cfbd58773dac33febcf073738cf31d942e979570dcb6b15035ecb4d1d4a63ed5339614108d98a7aadd3aa8ec1e9a2064c66b748f3b1a28286ae51f1851861da209c84089a64c3ee8afea330ef79c7356db6211e3d1b811e5a52818d57fa7f88a8ed1209b95defea60a8c867acecc88722119443077b645f130b057520854d07e0d7b2d0b08b49512567486e142b0441b7369dcd1121468f36a19cc99a1dcc9af7953d6332736e43a96c08bf6b927254fa1138e9a4256f7830ea15bb5ca20c50ae29024b5214780007a16ff1153ee65c52e42808555b0e110c06d66c6d2070ae096a99c823ab625fc9712823c62f3be9e812beb596943efcb7f1a3851155bf16c6cd919ddf551ef708749702ce3b3af4cca097ebc8997f7cd7614e9c1fccf4d97a15ca5b06a74256bd17f9fecc555a455558b8f14be4132d2e37325f27896477db31b9d7d37d49d43d08f950eedce376ddeb3672e969db0eb57593ad1205b2c75ac8158082854316ad5b41d629b2d861de113aa4b8363215f4d5053e1d845321452e6ebe0f903351fee5556a02d34d0b8cc495e4996356c56be5c19a1a246fd33ad5ce1b778714a0610cdfefed69dc24c85ae6035e6e623df01fca9ce13f2faf6fc5161f675a64bd8f4765524187b1b3b9f222f82d8b42f16168b99831242292c3668647058d0662788267d9c2c989378bf42a7d172545cc12bba80c757b6610466c98be65931fc9269f5557fe3e06eb5a5887d71b83367fa80903e49a7e4d076d536cbcdf9a9bf90a104e72896ab52c031a0484f3ab3aab62461777533fc072661c0fd3f9572b86ae246bdd44063e912aa9b7a7423127d2720f8c2d5c10a45e9091f34a5fa49363786b40a09529894b71baf50fa2ccf0daa7373e3d23e60afe04f5bebd0946680e940f3706f9f9287c6347a00844e8790db479f7b3f292afe00d5d0da3477f22b0c48094ed0b16fa796555997491a4cb0729c2ec9909f66f13d98a450eab0cd3880d16f8c41eb450f253acd9a34d14c5b0dc3c9d5731622f446001784d9fa86d0b303fb1b13a229e311b665fc1ff35298efd5cf0e5eaeffad8e07061f6c155f7d3153cae981f480a9de9fb26ac71621cada8b87b04759d3fff9f67ae6be7af3b144cb6dafa71bf9d0c4215e4a8e9d07a00d0ba123d84737f4851e64c3fa210688b8c88227cd27d9330c0133c2f35ee4e9d4616e0c9181b16b08aa35f2368f84c23fabaeae0fd722f99500ac455ab3ffbbaddd5e842bbe9eb71f1ed1f3a03276c748d27ebbb336a4f54021d920d0e4c96f10d4fbc1af65ed8aeafc3a1c5279e75c4b580f16a47a95ad3c3928f8b9f28d4d4b181dfaa0cc6a4d39393bb8bc7f9ed59f7e3f8922963d5b14d25741c0a7137448a5c0e20702d151aa63bf2016a0a2b2e66b39d7845d7254a70c9f306835a8a2cc87010fc7910b7e5c4969be2d4ef72e5dc8e6a8e286df493338638c7a91f0b9340f64c09a8cd009e5eafd9671fa906eee7b30067ffc50113c5f1f8003ad49570542c1e07c9f2abf97d46a58cfc312bc2b6982c85e7489b6843ab01703202f641f4e668958887529b12e1f0223ccc6a172bae0b697feb2d6be48a93734c024bddd3a917898fc5410c0c135245dfba168d83671cb99b60c393f49260d9b6334c5ac5a17fd846298b9c77d2cff978613f2465762d7522df330e4b0f64cda60f231bfec70762d0f47d894ad6dd54eb9d8f07e7429beb6be3c2b3ffe2ea1d51ccb7b6afdf3052d92a2e2a2e28e4fdcdaf33a83c57de5dd814601a1ef380de300068feac40f4492f064ce24ad549ce9f03d5661a77536b1c07992aa3462162327737ae0165a8088f9aab68f7f783860756016702b9a9ce7a20e34673dd7d7fe06e9f5ba8dcab7e7054f7330792ddef69ab3466f25236f4d6a21b56372818d0e39deda86067b357b59d29024c716c1f87c8d1e4b7e3a8debdec7544cbf0392935f1a3a3412eef587c1cafbd1b271e8201ea0480a73d7f1c12fa52f9790a1ff63712e2f8f25f115cfbc64dc6cc3663ea2631b14f0219b899e39a0506449a19fa70a2e3e19eac4cb5cd72fb267e591f34e112e8c707c7364a090cf3ee59888a0537a19d4f6d6ff79253ec96ffbd5eba95ec5adc7c618be40317dca0cb7f99be9c9b57de33bcbff1de0296d603ec595f4cb95d1ff330c0a2fa6c0628505c87f2dfabdcf52290f306758c9a2074a6815ab69369cde5e3d3e1e5fab49d95cdcd55adb547fa4530e70313f6a0c564178b83f7083cb1c83ff68879c721ef7baf513588ef201edd1e5f1f015a9e75a2bbcc29526b01997db364915c681ad72e8492c93cff727080a712b800529b386480c7747f72a6f934b54d4af7e6939981e4c4a012b545eafb4e1d18d9c926144fe93c5983e0eca23388af1052b9c1ff0b5e3593dec8e5bba9c4b27c1a5125e6f7172bbddd6eaf5dec1853c71bde8a69bc489e17ce5cd6520ea3b94286c4b68af08805e3d5409edf70f3bf20b50702221846d601ac6129d0a964e679229baf37476be356da3bf5841c2dbe91c9c8582c4430bafba7d4bf19a902c44ddcfcbbefcceb7f5466f687f656694424ce7f793e67db76fd7939804797578d35753bbaabd573227ab2cbfde54a0402fb5b0508a1142c54fc4555c30c1afb7082bbb45b3b85ec41249118afbc42a3e901a1165bf601950061fd412963f9d336e12d79db07aada3b5c609816d90c15373e5d8ec49eab85a110e8301c2560919bae084f680c787638181948e66562173275c065ac915e52faee235077206079378368738d98fcd209425361a7b35086e13c390aac4debd5aa929650081178fd0e50381f08883adf3f0e4f3b80b4652468a1ba85e2a8ed0d56f43a56518da37a69968ed55ea705a7ec860d0b43f4459cfb7f364138bf31524345cdce64bdae04a0b2450f2f63443f73db77f685c1eb3002db9daa2d8567e2262e058fb037b8eab96a2ed9e78ed1b5d678dc2816160cc2e19c58ee6e9f1b4245456fc16af71b55aeb533213e727d894b1546129797fc8b817c690a7791eaacfdbf54c2c9f890a5f9c96879e8e8e190ef80287cab7aed9a89c4675510f583ec3d28987b71d38f2d2a616b30acf52f3bcc25e1dc69beff784862a88850a1b90e02e221d6b8ed999402405ccdd73e537507530a522b1c7d8e37911f085f5acc42005b88e59a23fecf2d2c7d7492e15b098d4dadc62d4435624248a040553bad637644db7c75ee8b61a03d384c1244f64aebdc47fd6abb65574e8a10979c4cd0f08e982f2e1739b812a13004f0ec9b6f3f8a398fabee0a2f1fc3ebb19e2651646d92be3459dfa219cc7ef6c703748220404f78af4a62db97a7cb27d2563c8015b430b22f7ae4ade2c5dbfe9a54a3e2c2190cf7142c22c24cd0c1ec619bf0a7911830decadd5071035acef0967c23c4591c5546e27e0c2f15e72ad8cec6da60023d61ac441678892077d9c997b1e013759beb6c4a3ad06ea13945a237e2315c3c8d16e7855e7a60b16f8129ebe70b8c227fc32425d7c99ee5090b247260546ad25560a4bdcf8ffd6d07008884bfa35064ac97d133334c244fd31664687da34189d661ebb6de7f288477d2ee8a52617346f69d18b3382ea9becdf656eda7511deab8b5a7e7e1ee51493bc25cda4690652563eb30a4d480dc83a83d531f0dcb775c7b5bdf0e6cccd202d5e3dde2af18e28dbd8d2d1d049f86bb4c2a3b212b24271be62693996a394e377e0ca1349228742dd68ca2dab1f8891cca3bf3d0f8ee151d438e8bd7b9fdeceb8aea9b914337c56c835b907c1ba04baacb4eda4adad056f78e446f405b4cd0841f791262030b9a01c6e3e5577012d694161037902aa0aadc151a7cb1936a7637663ba49b7849aed84d106392bfbcc100a1b6c5a4e000c350c5767968c4a4c206d5a71cb3530ac7f60b049189e69c1fa7693df8c083c309219f0948036e9154a19aae10070072b0f201b4b42314dd2b66acbb79cc56104d033d11ff43752685fa37fd5df74009c42d943d23264a492ac29d0737b8ebf1bef14afa6c2ab4bec199c502aa44fea6b1db8265cc9df58ce8a7e575ff473f11a99f253eff7ca76b4709d9e727435ca46fb51da596f2df939631c730bfcbf18abddaf496e04fe398a7bba7206698ba2a65a5d2521167c65af5e07d8aca4fa2f9d9019eb090604902cbd8379f6923120e70ead1fcd420acf43b4f0e6213681ac55710b9a755b0ab9fc0c1cdc0779c7c803d7adfbdb9d0593b7a2e68c8efb8c5a09fea340b98b14fdfefd6a1291eadabb3f04d91be5cae404944b7b2780796c1ceeaff6b670225227c2a67bc990451dcf3eae1ef18091bbd4aae6cd4fbc16b50dce486460ddc8f5d01c16ca0aa17fd15766c80060b2b58d19c0ac68a3cca044c3dbcac0963f6a7e4c2194cac8e6e2d1a23e8d03bd4396fa66ff2dae24eb8ec2e25ef6371abba94c2867bf4af94a68c2d6b06895cacb0dca7047527d50ba7b1f697c34c745ed6012583a2a8d8364653441dedc3731fff7e22d37594f08526badba279cd7b429f300851d3301c759ddfdc83c4ca2f9accad5a1dadfb3f8227c2df65f9d4d4e480c9e3142362812492240d24ec0a2b5f1bc22f2450dd6cefb73a487d9e443bdd85a99ed55a2dd0180ad8ed0995cdcdca871f0bfa4c4784dc9a5035d5669e57a2ae360c746389b0d7c24aa1b3d35b7ae67f4be1796e20f7648de6fe25872a0cd999f5d77e4f53a0e6f1f786825268ae6a3d94322b0a1a29f73ac3ecae3f04dbc1af379538ab86ea3459321ea63568dfad387416156c7c56cd0e5ca989c13c5066bd33a21618ca298486c1ad2abcab121b77e82e909c6bca481341d20df2c0161a249f871b89981dee3363227a268f6f2180c4b838cb6b8188e22f947c9d7c740b175f95ffe3bd537a98e155194d727c033a5b687d10c5a62c953af6d461a1148164f64112bf19df7ceb75d6ca5c211d6bbf8ad7041e9e8b93b7f39e6d09ee1fa4e7ea3e769d499ac61d2978fe76559be4ceff1aacf9c830ca51b4370f0c973ac3ac41be3bc7c42903e2055d9cde0dfbe6885dc29cf52eb7ea5979d3a77cb10098a66267b12b7264fbb05692b950a5eac3a29b0f3205488f674d9b6e4e6f9b3514b29872577b7c76ea90d76178a731684873918ee74f75439ca14acb2b8619cb538a45dbfde5ae04e4e99ba49e8dcd7fdd01800bb5eb22e498f2a43774939e6c0d7cd5f36f49cf87dd8b1f16a97751c4a0957e56fd6d2aa743dca78f637b16dd4419ca945fdf1095aab399f9ca41cf55ad2d680c6a7a494429f540e435a9d16e8ca1c6f5c955f21dd13b41fca8309f3df5ce44d8e3e4e1500244e8f112c365a589f80a3b069d613dac44a5b56cea910e4553ca61ba1c9470fb817c8b6341127e6d37d32c76df6df2038cb0ad7f9f88db91248cbfca9c8040d4443807f328d6246faceb32e38d4a8415149c67c7b19e14d04e2ac16a90ff3fea397f1a896c1b03534a04bd1f5e3f6a099b621c625b1e263b0dc194fd6d75e53ce5d8768c4005ba1b32db5e08434c2e02e3eef34372d35ef67159e3f8a5f1c183cf0ed600e2ec069d0dc35e72f610791c91617be0a0bbe8a7cb059f244c43ef8c87e8d6dc4751af10545842aebfb8fb8d7a85dda1e4b526b10030a0d6e864dd1cce40c32cec8fd29f581b6bda2611531201f42c463d5be2618e78c4bf94bf84c832802e93fb657ae1de731ff2ab140825dfb2d3b4f8c3fe21456c86d79a7afb694c57e955b28a29bab7fa8369192d3397b8f7baa50f6f9eea048a0bba73ca083d915652dd0f7a4833d669272cbba7306fd7dd9c45e3fc5bfcd76049a0a12fc5ded56840e20c0fe2b55c722d3840991d78ee438faeaab8a4bd846e5056e334fb67e260512ddb8cac3d89bc793f7948cc0d936ec9af31e5a810d4117d589ea2aa3f6177b54ce9440165c1f5e5856e159bd78c31e8bb08c110690ba09fa4a5757b555630fd3ea39d9830e18ace337db71dda29d36912a015a37863f0fa8093c59569858ebeaada2643c02dc159b066a2db4aa6976a65a91c5cc4af2b1b2ca79ce5b8b4775de00a13bff4b58bf48c799745b8c919d52166129f135073b8e229f4c9b187b2456e897148fd3234efe57e5d3e5645467f95d377283969d8b8d5e44829c018f9ec59e1b40617be64564e7a6036c820cf3e45c100fa50f62d22af128a63c0074806608df59b09467f75fd253cb6ee2d68f58f95d155250f5cbd46cf7ae92dd6c73ce1450a447d83581155ac87a8553b6a4e20325489e653691d413495c29ff5ea20b2cdb3074f3044116c65bf9743df30f4610f8370a39ef9175b23620ae070c91cd37f7c68c04b4e640d623b1e9834239277dcce652d17b3884385eb0ce07554b125ed930546a588e68afc8a81c9541afb9d97f2248235fb60476dbcb8770134e0fd69b910010dc3b12c38f60717f7c91e9bce942c542e08657cb6d5e994f4a340f87364cf8dc92d217f17711ce27ab596f9f3c85c8a055f09ab4b8c1e82af5c8b12d16ba1b0254d48ec353d0f73f97524c218eae64e4296033480a4dd67c7f63151d4740f0d3cc16170d10eb46278276b4aa628455c4b339af0a9c77b263ae654a5b0e53d35f49f89dc1204aa00cbd784acf43e1e19b5fe9be4bc1200cc795cc05a3c675b0ec1ae3296f4d3de28d07df6e2dff0f6337251cc9ac5b88e5c12430544145b39a6fb5ed2e138f6a36e6ac68068fd77952da4e29906909baf9e88fe83b09cfe153388e6cc0fb290fdfe64ac027823e22ae3a6d176da2c909f07a3304a29cbccc3cb0ec7b554b2a8405490fe0f7753b659e1215dbb922e4fd835a32a2331b3272821cf545698727f18e90dba58fa2183751aae07c0cdb2d526c656faf6c0fd60d917b8cd0494faf326c2681fedeae527d3cefd8d0b082898f6761351cd0f79d492f16ee6a5b451f5f761b3508c832a8fe301cdcede9dacc05e678b8a9443c89b5e8d0839d6b599ea610778133f406401907192dc712c755046851cac6aea3cbafb2359ae5edfbffdf338593e75a3de421198f8f204e472d981b2ba8a4e50c303a7358bf189c7cd298f67b96572215ccae289d4189ca002280207427bb2980cd3b3cf542e3ed78dd51738a8574bbf8bf9eac52372d8a4c187895ebf2e9d1bd7d7a6c195fc674fbeb64c428d3362c35094b7aef425ab21f0e61846c5b7c7ee63cd402a3c4783f7b10c13116a2c1965943d41ec9be66db812956f26f3f5e8cc62d2ab35c08b179b956422480ca58d332c3e0408a3af92192e5b59f63e4ed421782545c9bd57c39afef04b600c431fc0ce744fe8d911e4188aca33a4fc06cb9d065218e19e67dfd6d0322639396c9c452f7f3958a2a74dc0a294578b3d777aad6e2dabd8eff016b4e5db5fd31bd92c75f386ee565a7afdcd15910b560a5b724c93e0f9d20f389fe5371b576659be3e988e0217130972ce844de83270788d67b94579f88f1abcab57bcf5c7ca1e90e52a43a9acb037a517fbbddfa5664e6ebfc7b8e03169303de669c4eeffcf2f4c28a45587730e28996a862940a361bd3918107c9be052ec348378de0989373d373d2a1992280fb7d3b148b760e6ac425762b4cb8b905c74516225b53bb6500cc7323814d5aa8a0fbbe060f268e47e94554ebe9320ecf45f5066e4718657893c15994f2bdb95cffe052e0cfaae8c9cbcb0d7a56788ccdefe00e52720aa150d0d5371390993a0f43abb6b2e404cdb0aebab157a421462ee28be5bacc49e063cf82efd84c6514b52d6db65b9db3a039af359a269e7432df34bbad5f953e6b012fa6ae8d1aa7b30adbddbe45e91fe9486fb768a7fc445881aac84018bef3023aaa022cb4fa7d6be459acf2a233ba35aafb9f1009c86edd356b07100dc9ed470bd912428185177c232c7ad8984b5b1edaedbeb74117caddfc74a5b7cbc6605ca9d11b90ae63496eaf721be4a0a9a24a96ece0fb2141423770450bb180a96d2ecc06aa638b9cc88260383d57baa32d32fb4833502270c31e4947b331e9f07ad456b73c19162ef9ddc70dc4ddd16292cd35dc8f2d86d471c24823d8faa414442f0a8059d16f2ead287f1df819f908ecceb54a4c4d19af31733c4943f0f88d889248f53596ef6ef86c0767c4603a5fb1adb4a4aad6a7af103e386787b1c2b9d0d799d6b6cb606e7123a262dbc733cd7f6dca7c8e5ae830467a6eba96cf754cf51635cd0e0f0edece2f26354a7f6beb08089f5e98e0c2550e31674e3f85eba952a83b9bff7eb5db0d25acad5859c36cdd7ba2dd314dcc483620c262d2da4545f69268195de00eb48be82c5b2abbeaff6adbc2e0c3f8d597a6b944f08dce3342471e0472d1a861c7cafd0643ef258c36fa620b2c897a16cb6c0b7ca72695af44c92b50dc65c74cfa5fa02d2c5c5b25c6617d630ff6b387827a14cccaeff0732fda11f70df7e3afbe35f08034149eef8011d72e76af268becf8992fb9bdcde9931cb42659cdf84ec53cc0232d1fa97ac6201bd99a8fafaff16c8922c9c94e6dc7b3dc4c8adc9058330c0f24d35c4e1fb945e3a6ab8304d3378c44d6f0195d8fb01e0f71805870d10802105b308e41d270c3515f2aff8f375701bf6b8335626461acecdb9a851395fb44f00d1448a1f8681a8d19618c66b37c0c9c9db3f9aa9aa75afe45ae52d4a039942149ddb41ab43b67c478f972f24bc73062207ea6a9dd1e5dd66f1f9079621c876ebaeb4077d3e87ecfa69678f876f38f17f1f2115df5fe92f40ec026de4292ff69f7324d3adf399dc4e663a765f2d3aafc14fe382e550253e4f9e801db7435c5eed8b3fa99661497e5c1522424cf8980d45659f801e23543c6b49f2a054ad8679b0aea0f490df5ca9d4df9d6e1341f6ca8d5e1c48f1a59b82aa5f05cee21d95235613329c8ed363791b717b638b1cb869b0240325447f513bc6b4ddf0bad35cb58b0b2cdee0dce6b1b49f9365a2b53f52457852b440c4e9ad0cbb61b51f0a40c22d92d27705d38541868a07f52c88957e692e3b0133121b88f004a261eb036c8ec91d98ccdf2c557a49404b544e5dd79434953a9d3bdc0841b0ff31cabe6285502ecf6f1d066b1071453405b3556f636b7e365e029868cc9a8ecaf86673159589660bad886eabebb4a5ddbdcf504f6e139948fd1a4f12c0673ad8576c73786c5c8270cc015ae46ebbf99c7ecbc56abd20369ff383287f788dff9323856f3117b2558973e1bd5e913c6e0ee25e67312927359f7f0a780516279fd7d0975d6b334488b4908491f47f45884e29a289c817f77968b30f56578fcc434b9136e57895427695e93ee34eca75115c786ad30497e4288e71e2163c558963d35f501c5b1f47b470317af94ef620cc833bf843727dd0a47c54c91117580c65e2483fb6b6b6cee8c02937a697937a992ddb15b0d8b61a58337bd124614985202887dd0951c6838db911f54f2276feb92fc28cc2dbc1d46e5ead41f0c4a7dddfa3718e2aa4e04805041fb93016e3fbacf3a06f793f4eb87a1ce27e38372b34150f3318c77f38046c3351e7174bc71357206fd75e4dff20a6ef1b06d78fc92658b74c6909d1fc0dcde3fb915bbcbf34b29ce311ab0962b9d4e2237278c096559f7e769bc625ed8a9757dd62eadb73e3f04e24bf365d13ff195d00d5be53fec4dc748b99fc0337c9c348fe964dd074cac509a9f2d1a87cee326c3c7cd2ea8785e13dc09c03e9ed34a2c8f6d73b7ccff3554799720f3f11ed0424642abfd4fd129af69ea69fc54b74f7a5ba39403b73aed59896a95e6d1dcf4b2726a4b514cc26efbce67fd5cfe907b381a0acc1469050171f9dc4074d83cdd197a0e8518c5fefcd404c7b45ffb57a37975ecfdf8ec385df1c90f6899c50b03a7b71442d997d37d4c58d965d5c6abfc1f3c7281b3ce82147dd0e87ecec2f55beb96230359acb183976678fedf4633e2110d8dc2576ac5766d690c1fdc2eebe1f07a079ba42afafbfcded56c2c896552926f539b50eaba1afefb61d5707c0d7c36bc9394ff8b61b61513f91bb21defe30fb74ea62234c29c6cfd27bbe193b0abac9ca2fcfd93ca5a2d05cd85de0bbce4847cd1ebef27dc432f3fe3d695855671939eb98567b138b375dd58dfdf4e849caed83bfd9adecf05edb46b809845551e765262a60900298895b1052b95848f52228d59f4a07aa8a0d86b050f997aa34aa3381f70da726318d03ee988cc07cf3c191c16e602789f420acd9953f73807fffac86e2c051123aa721e53f6059bf1fe46bc789b5913e1046b74061b8c5481f06e0fd4fd97c38e8b25fd07f8ecf9cfb81c86fb085d4a3532e1765cfb6302d2a8d3796dc6efecf934948480c894f4bce03aac1b4a8773618d397e5ed25acbc2c41c45ee64c586c1b204017126dd65883772e1febffc707b6db9677d00504018f0d006bf16419e42b19e5bd37afd2b9cd235e2c627b27225b0a6bf7dba34350b727b80c722e58c2d4dff3e91b80b07d449b1744568e6a8fc9920fa4dcc199779eeb51fb9e5a64fa35e7ab3035dc73103c44ccab72ceb4e5591e7caaa8e69a6fbac2e7324536cbf275400ae7f9b4d9d5688744e49e3cc8c19f8cf7fa1a1da9d9c74b5ef7f78690e0d273cb5222f87fced2479db19eac84f6f4ef648504b4ad1dc84f8284a3438bcb2e99668b889377de6d3c83f889c6e20b3072a0d3fedd0d5bbdbbd8624b77765561a61f4e58af59f511daf78d49b062dbc32a4defb9f4d81779bef0e9a9299ac600662209732db7cf0ecba1acd8abe0d3cb6233a23438c7da72b16335e418f6cbe7a93d039b812df84a358f025d3fb0a6585bfd5d16030964f3a27052230512036776f586f0094ed0c8d11d9d8a56239dabcd48420f37eaebab5fda0a78061d047c4afd3747d80ba6e5de95a405263f2d360cfb006788a2cf76cd3ee14f07fdcef8a33e283b8a5621bb8346b1d5304ccd31b264cfed9f3d25842420fc5ba90bba72f54b661c2ad4a043ed283d5491a835203dc7e3a59c217ec0e11955eecd84c06b4cb2d22650c782e35fc1f224b33b4adaaac328a5b42979983f7d8b1fd1a6a751a091feb4780ac634fc0c4c5a0b746692b03e489d927ce47448988ee2e0b25cccca8a1c7a37c966e0ae7471113aa741aa01dabd42e9c568f1a674dd87b85611fd95ea1e059cf31a68393a492e25123612bbd5a249bd0c68df585e1e46a5a127fa1a8ec2c76e827dbfebd200ceabeb0542fa996eab29d0634a99e271348bc093e1ceb68002c0658fdb1ded38833c56c3d9ffbab355bd17e6eec465497df14119ba6e5761563f3e28196893a8c56b68fb45fc89bf42eeefe7322bc3a9fa094565773381636587a9babdc05c46f383ef4ec75d6fcf4564c4db4fb20d50811c7e90f41d15009d7ddf196383fdfd6fc68ff77a1122f71febd7d278544f574b16b98af24b0d2e208760730290c4e073426e7524346ca96986aa716757d5d0c5f4c2cb44358ebd611462d5869041f7485abb9fafbb4a903a4748f1b2669e2c7678725570b097c49512aa586f4b9cb19ad908cec977300ba9b6ce13b67f6e664d4b77cafd28ece7b4881962ffdd2432775178cbfec90111c52911be64c063d22539e36af680451a3c7ffa82ee5e68b25be72ec2ac79878d7a06a2096e8646e0686ea19fe883af9b5214c012be52cd39e2b970b6f801d84b42faf09b54a53f16ba511f5f96c9c029eef38d3ffb93bf0f10913a207c380adaf83f34c46575e5e092564c5c3ff7480ef15f10d878dc557b2a0725a0c5aafb744a2aa718eecafa2a468433e763e5b34dcd719eceb00bfa673b593df08c72792e947a11c374fc19236478052cdfae3f902c69ba3ddce5fc03f09c99fe3a58ffa70751041cae2fad6297ae5278a70c922abcff79a811c4ce5e1fdaf74172d659132caca2f35b744ac00a0fdaf9247659e63975ca672478029db0d307de12819938447f8ca97a516d628b90bc46c5260ef0211681138f94c5340ec2f1782c31958db5b4bdff478b74daf33657c34d5970412a404ece4c52f573f3e1f616dbb5a9ba6bbb20a0021cf2be84a15423c18cc9176523c3fa03587de1c630391b8f5e7158ddf5e38","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
