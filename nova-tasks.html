<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f31fb1ae39b2c5ec56fcf781e85b952c2826d7759c0d49f59c7f2552065afc2c174ff5761a032d5d9500640a5d8f5009cda57e21592760c96cd19c7a97bcdd3641b56e47fb1a9ce786827ab1907e9b8cc12a22ac0773d715ebc1d040431c74b5f59d3c973cad117b00a99462bd852b57bf61eaacfe78dc9314ef9bf2439642de1b044d501d11af021cac63ea51abfd6e1ed73a3dacada0fc4f4fa24287d553d821b0cf8b89e39194138ab6394802af12c966f15473c6dc7216ac6dd1d14c9095520afd283e0c0abd90032f2d619e3464a58be40e92bef5f896703c8af4bdafa2750b0d46059a73f214e7b9f51625de247975d9781606d7dd2eb6c71a8e17c7e5c64f6a0dafa8d105b9d1f05bca202e20eafdc08b8189ee4472fc80d94ba3187340ff150e27b2282d600c92e4470432be19b142dbc39e6c809243335d471fe263234c87a7720ac1d8cc1cf682dbdba3d76c1c7bccee625031eeeb338215a2490080c6293ee3ef0bf4f31607b493cea342d1d85bc6845823f8e1bfda96de0e02c5f17c24176b8dcf732f3fcbf01e9090d72fa7cb20b5e76574c6a5b64698eceb054813d3f180d22570f41305678c8a986a67707481846597f104041499d7898aecb6a10d95ae6ff463d25a2f8b6f8ccc999d0e5e739715fbd008e5ee435f4e8d003a654c148cb0e4741488a2d75a29a4b5b12637d21f7015f7c64fa25ffb9d06f485430464eaf7674a9642eb2faac838910dbfa3e9cf7f5a0c375559621807f266ea5f80a537845f9ce615e8de70570024a10d65036181c818ad36de1edb2445f613cfb0a01d8f201b537167ce872633683115e3c46eaf2e398cbfe317c3af3015dd997db803eaa2c80bcd50ef6f65541bf7d5790dc6f52a72f8f32ce2ca3dc0d5e1c448449c84e4b9bfc91e37e9c205a232d053ef35aca161a07245c66622a1a8d6398d0d88a39075912c4e42cee157ae9f2c1042149203c55ae8e0ef9fb103f3ac50935f3b3df4d938c7f35f98ea8e21972dd36de785042be22319ff0bb07d9927f912d9e6abf3213cfd705328a5fa24ce91a54fdac72106245be6478adb8c5796fdfa93d5f8f06580f5e334b940897fca3672732cf7b7d8b5952f1dfb4d311a0f95cf4cd532e46ad5462ea88f346acd48fc81b5366ce45108bcc5e909fce28ec34f02f52eed3b2dfe60bac9f6ca9187cc9a64486c6c0f3d8286122e8d2c884b84c3dfc3c0ac9fde0c91e085e8c251ed3feada00435e7dc6a6428df1cd91de068e29e34f87aa948b5dcebde3348c22e0b4cdb0e92d0b04bb5ac1c5260a4336b025c4da90b61730bb7a0005e897038b51d0614978af888de0e62ce60d251e3c8d94d9bdbafe20a634ab39a45b6ff936dee1c8c52a61fe5d38ef52f7bd851513253e562aefdd9a640bfde96ba85949e856aa0165f4891d2f3371bde0b0fccf6e271d6873868f5089b408b72c2965f51f3a68f15e385d1980ad428d2b011224609406910a693308791603400391716cd418e3be17114e2a1431ab5b89f46aea71fb2ea30ba6603764f9dbeb642382bfef075c60f093c81ae08a6dcb056ccf381bc7c33def7c0a82892a83964867bcbb3fa346de55cab099e0c24a3bec3a6ec648691f961474e1216a82438a413fa49e7de8def63dba5ae0653a82c16d794e690692fc54db74c0718f2000cd83fd5d212ee83eaed3750800ebb51ebf5aa14b4d18e63c08d4a8a69509ae5abcdfeeaaf4efe4120d7bf270ba8eb6f04c9a7c74d6186fa0f8b842c184928dfc30dc57cbe6e0723a8329edb3aff77ca2916561616bc1923dc9fe8cbedb06a6a8ed14f61d632d2dea632055751a0c39b73d7afc385f1430441f9c92ac2bf9cc1155f92b2b757a8393be0184e6786fed7226661f76e7b1380a65da2ffedf206b49440985fa0797c4438cbd96f43c657a51f988d544951ef17e21617d2fbfb2176e8559aaa49e9d50ca4aaf4226d6acce6f919b95f698fcec72fdc450dc1df1f71cb71737f539de10f55c9c5ea3d1bc2e91f07e50b4dca3bd67b8929a0dbaa5ee35d1019cb1be47c9654ed4679e258d3396bef687099c894c2a05036b27c33295e58bf2c609246326d386ded1611af99c5428313db5cb819e60ae1cb81472ad5eafc27967f282df2e6db513b22fd6cd7ef7fd216133828b007268f34dd44952a292e33432a267e3158293c7a7582293da677e0f98c74418c65e53c3135365e2845221cc7a721ce17d76e8b896ef687d15079268b6c91d64066332c85b6655acb4ba7bb0c65d6cc950d6a477778a52a082710c6449efb8b982a16cf087346e5c05c563f1768ede80e37aff22c812d8a9b3539a4ffb8ff4f2801f886aba28aaf79a4391d22b7d349598166c5f80f454884e34eb73e037b4d9899de1aab971e5ef0a76942d705fd8d60d14ee76786edda8e06157c847767240c9b5e906b120ff9bd622c7096b44e25b0409d0dda88e5af22ae152f02cdf0a01f587794c1ffb4d02c57de563622f55cb0c37733bde7e05e588854bbf6a08d4420692f6fdb61c4df7c5d1c6c2163457d5c35b2289e6fd852673200b3cb30d26db3fe45c202d5db47a1e80c34c99e2cb4ecdeffb04af3e0e38858d21b286e33e51b45d401865efcf38f63f50d3bd77b126efa83fd67ad2800dc948f78362084cb48fea179e48684c68702e82fc9383a3d437d1c5d2895b8a0426473d6d5134e03e125e4ba363e3cd54e0475d0a3b82bed78c5bf4dbd69d0f727f6bf20dfc8267740045fb849e567ba5f40753da1d976f1e6167f316017f1b80c4bfe5f7cba044b8283c7c7c138626dd53ef8b63e86c4bf90964d3006baf0f561d85f34c1d2f3eeebdd1e8504a9d2b2879c36bfdf17f896261284bc1a0f3b09962029096faa39a97e8956e68c3cab0ed8dff578dde8f36d84ca554f5ca87c877ad18090674be0b9f845f7696d4da1cc8ddb55ecb125d9afdc418c77d9ab4b2be4611deef5f193c0bb85514c394998970b36bcf6f334e62721cbc1418606df44e61358d23892a30a1dabc3d5d45382a84a72f3b6965305a2b16e9e64cad3bbd41f62415433ef2b1a1da2998bce7773cf3b597ebe9230775604e28653196692c330c0bf503520a1069fb6ae2662f3a90bfd7a2b85918e3ad4cbcec81ef6aaa74da40e7cfb5f8b8e378200616ba68027b828b7c35eba495089400e186034df759978debc9be4440d00f658348a84f739abc9a48561636079caac71cc2c3ed47b0d16086f4d50e10fcae6581777d02b7d8e54f7d99c449d4272f14f33c80be1fa0f8bca0f665de425f1055cf810594db42442e9ccb8856e2742ad842da864356d4e3e759ac3549b87258895f7f21e35c625e444ffd1d26559514101dc1aa489cbf35b47a6efa861f4f9d62a30ad20f8c4684371136ea1ca09b85b0c2182be160bffee1947968ed638a7b740b625a2ef1b893065475752cc4f9d732f92d95ddd15e9584449a6887f882a7efcac9167d5aa6e1e4083b8bd1caa49fb1cfff3703ed42bd85532d0e06f484a65b8654ff1fb95370e752fdf1db109d39051c664531a2e27193f8864ef2a145c2d29438fd7ecc28d4cbd546ff376c2bb8272950cbc0db1b9936a070a71f578a5f4623736c79cf559e7ec7a91a334afbc1e8a3b0e0395d2826506a076f61d4e1cfc50515539c647e005451edad4f4a3d5a0ecb84a7c82f5e371d93594fe11870875e376aaaf46c4070ca56cebeb8dfd614c5702001f38c9e5c05847fd6d33a163ec0c5acc0ed2dec891d084c57a6d9e6cf63bebde7dbd9ac1dace2a17c2e594140d354b0600b009635307b1f12fb904638a94ef3b482cfa2fc1b0b8454484c984d216979bcdc4bf23dbfb01e7ee4d10cbbbd95bc224f92bfdfb16a72b0991448033883990c76e8275ff0cdc8ebe475c2129cd182a35da2a2e030efd9d8098dd6401e1a04d50051e0681ed740ae876e1b345b30033cc1aabfb57d0a0f60202c805657bdd3525b43013b65b8fcf3684c4faf14910c31e0eb16dabeae00eb85f7ceb1feb65a405539017c132918f7cc0c2e3226347e08f693783fe0cc0742ef57e4106561e419fcd0de3ca8ae15a5f73815351474a485896db83466013809568a381664f12bd96d8a94e7fd013148f8e74b038b7fec5985743008e0fc7bcc25543b91b8502a26c5a49486e484b0f9fc87cca4bf2cbe488997175c2e1fe8f31703cbc7c32a832fd8b92f57102a5f23b5f725b65812ae426db9b0b40f346d6f96c447b6afe934bd620903a4909649e2d3be11445d2eb0a7dee6e0ec1f6a8238ed667da69ed7cd1e5b6c1ae3588666cf240fe04a6c9a421d88cad5e521f8bd651305ef8fb27aa807d1272204358d87c75c44be9474c8997d3a3fb8ecbe68b4818bb865655711608b742d60dbeaf6fa9fbf99e9db1e0161d48d82f6ef00ac6675b1ff38a74ea05675969e81dc5f9fa4cb8c3c2473214989c960b31def178b314a13203ec2e96c0e2590f4afd932a3f062911fd049fddf152f6a29622a5ff729e81dbe91491d8418700f502593941a5b3d5d53e9eaad5ad62f6c792057721bd5d74c1747f3e89fa20653350cc28faf0875ca11b7f7243117e8b9f4ee4f04afaae989fb76fb28b6e6e1af42900c6d71155fdbb0e851e58ddb454e3969e36c819c76fd6a0552d1f58ce55020b1a567133d22145b2f3b7b25296dd8435cd82658be6eef79941a22dc863fed31e3306ad586cec6353a13bf50f493eb047bf322e3060801d6a5d10035184d98cd0eb8bf3cdfaa8b797549084014f6557e904037fd53e2e8d581235dd1c8d62179b86c115e62fac011c854ac907da5da05db14a4982ac3a3925e28fb90ef9c8086d36690b0e41bfa2a4b6520debb1149f7cc7b38b70ce7965d87b44c945f45b87a0877392434573d183d9ee4333ba54a16fd70dc6b4024eb72f6c4da07a5ef2dee49b3af9377e942fc6c9bf1b79bcadc6cedc4cb730ac9f176ee792a7b9d9e26b67fa53c0ffefea0ef78f038b7b9924d2f4d976584e28fdb143569f5820587aa0218beea2871c122b745d8d2f34f0b691b6330dbff8c405b3060a9af47fcfa0597365d51368a7ab63c8c15aa82cdf35a415324b635bc7397d3395e36538e65d486d621b97e3471302fa161f130f8302420afbb2dc44f3ff3b94017dcfb94a7ff0d7df5fb51e7ef1d570181c2f549dee0a53aa1e6bebd6ff98cba407726d8b370d2ec80f559e1ca772470d9dcdbcedf0e0a063d12eae67ac84f6799297d7a886075baf2fe86472347cae12efc6eafbd2f5ddb4b3aa6c2f6234c8588ade7c555870272906f8490af049bd36b45594cea97f17519b5b7df0950664a5185ff76bd8c487905cf08496c128351a395e17106bb6fc9be1392ff16787d92491e48a7486c7f46558bee0f2d267018b612d11ae710848b6c5d4b61193ce754528c14aa936519629a6abd77f2a2f2c32caac1b4c2e8a76604ecf2bf376ac356c4387c4520ba4d2573174ec658649c299d95ef999dd9554ca7fa53793ecd94f4bc806bc71cf2b8aef08b3700133d3256895f703b2fbfec4784115cdd0960da67b65fc18d096aa8594da1217e4d5b7dd745ec69a669b41d5618cf1dd73984adabfd1e05769f27b3458dcc6d154de70b08ec03138f4c5a0ed8af58b1c887b720b204f6b36ca5799eae28df47108eb26d5751cffdc80dfdec7a0cdf107d226b41d99436461a0afeb84b37d6b20250ffa0f247fa363bae424b066e50f3ba574819f319079ef09768c8c4c9de64450522c40064165e3880a755548fd939e0d82f4f7e0adfad0889d424b24c3494d52b126949ddfbd8e1e36d6f1063e7a1f931177e6ed0d9c28d801eac296cb40be1eb24c7c5640f8061c5c260970f38fa75af11633a9794cd6a912883d4a8a8e6fa3a9d2dc8aa4f503c27c545eed23b2548e5fce20dd2c579e2b5df4c0ac4e47f1c810d8deceb9142eab2b2d05de51e1cc83e9201f66f150ad0967ed379efad53c1e4bf77dd5a94d74015c9b73627a4b03c30c3e7f44777d6e17c93b209888e0ff084bb02d098bac4aba5d8645abfb127f5e2ed4c9eb1ec843acd6982d0f53ba9bbe849f9c719b8a6e7c8991dcc60458e0f3f3eac2f99ee9ec69b01cab4873b15d2ae4d14ccd8558dcb1371323e3969be160842028a9ae16a8a180777b7889c6bad39a8d48f6dbce5e472b00f94b5ff9b30a1fbff3abeecc35674aea595060bde0e0f6ee0b67d30cb23784f979bebe283ec5cc97f2d8c67489afc21017d043917effbe194fb8c2d2dc2d67d7dfbe4e054dd901b364f6ea8cea525f0876a69043e22b1d139ff24c5337b11f88111c3b4dce82b37e2f2e7c06ba903e214777cf8d1bf01d0a00ae1fb90da1e36b1d05020991987b754abfd2e03f9030a1fbe5694d740b6ccc50b2abb9e8b980eef705822c0441eda001fa21d4ce165da65dd3e1dd872a12a4008b899f4c288da01344504cecfa5d08c0f5b242f8c343482050989a3de5562e0fcb25502f4fd6be5c30d0d2fa7ef6d4dd8bb7bf3f08d78d46cb997f9bb0c2606c1eb58732b25ebc8c605d1a0bee9a4d96ea6f0109d9668a82a8d1fb38e5d85ae6e54c5738ba3790a1f86fd3874a862d8505a4dbaf3c203a93a2d98b2dc95c90c66a001cc5e980794b94f61ad8d8db56288115b952458d9541f972537cdb9f86758881c6fa059302cd0b3f514e63f93f4ec1a03df92159d8e5cd85dc0f7f3f8439f2f2129799393a11c5b2ab8013dff4258b85f515d8b9794e5a14e3b9e9a3c654a72f7b9e735bb8baaf441517c6c52d9c2ac51651a36f0fbcac6da384a92c1458d337c8453c93218e9e405f62728f513adfb0d37d1ec75292f205138dbedc9975d19b4ab20483ecec2fea257cc9c8ff0fd3a547819e4fce4898dc27649bf0f83126acf03ba74993d7b271ab9a614100bb52266c4a8c1e5f4a1a96d013ea65f11e34cfb20f52830c48d5fe102c8eba7d5ef49c1174246874e157d64899f405febda0aacda4b4b31ac03d60e4b04b2c371262802a057f47bae5a68db973d57e854ba4b6a423ecd49407df2eb90f81cb4aee2c7f0b96d385b01095e3ba3f16b887b4768e495bb2cf3a57028aee4a1081d089652383b828d609aac749869c27e7a5c17e89e562406dac793071c782f39035e4fa69b3f1670672a971580fefbad5f945a2b74f210c16a320c93aae1cd283308808c4a45bdc257d59754744b59ea39d146797372cbaa93332c624070eaf75ad4b1813a029163f035f9082bc386425353811634e25ebf21a5100a6273da804935c6702d0c21adff53f93a0363e9187f1c52293a696d5113dc1590332f369154d378e0359dee3b56ffa4d29f4894f8b603d8111091bbcb074c3efdf956f93d4161ac4aa071609b480df41c8a05feec0436214baf79b1c221d7b56f05fcabf36222fd9ad7f5898c23906dc1ce58cfae70036fd15843b60f4542484d27d7a0a3c1189c67e7966ec358eee70c80934e135445a74b9f0151d72300d108fef6ceba407bac16c08745938a183943267b74f5381d82878cd49f0ae31f59f90d7e16e75d610d78cee9f0da8e262f0a1349db9cd55323cf8206dcbb08c0c4b0288302b0fca028ee3afcdd256d48cc1b45bba1f4063c3c195d8114ede534a4d97b84a4e1c76aa500934e7464ebc383ab6e5b640f19247c28041f0283375cb8234403a976dc7920489e6264193db5652b858af673f8a985ed45b560315cb228b02fd1abd679236a1617d5545c7421f7d5e4820c26d01d6bdf4225ff672dbc384757fc90769c178b867c0a0f1dada0d904612fcf1ed729e542c99f9888eaef0b22f315efb3bba32d96d3e01ad2f006b51ee76a9ccd19b3b1bf73d01e7624afed6df77eaa86159bdb48fe2d39c136facae7e641d4024dcd503497cbed1824329de5b78a53ee78f8ab2f2e84cfa394504d4a478fa31cf0bc104e9f32f4c79eac68f85ba94ebe76b87d963fb7aaf55643e49d0b4eacdc606bce80968aaf6ea4f2b12c38112bbf77d618c521416ecb3e4809bb7d8c03d70288a8b381ae5166fa088c0eb1efbf941a209a972ec3f7dc30eeed99ac1aee107d41126c83b51ce04dbaa51d8f012cc2129194bb024183230681d84a1bf8d92efb1e03d53cdd15150276ee5640e7588fb325c98202439a81de9b266baf0bb0300a9859abdf071c6e65750852cf9a9085a8aafc8368398492f53c5a7af85b8c1b090f7551072356704df5382ebc4c429056003fc6c28e0becbc66e6f8dffe2d027ef538ea7b79c7cc4b15d589bd49a95763589ff7e5530e8e24ed06f7d9366d752070120f729ed8cbe8b8f9d661f740e6a5bb59b11188684e299821e96654fc72ffca786c634d43b8035011a21016eb3934d72e9faaec58695d106567da62c2070a8abfa02f9aa1fa2a668e02248f1e5e1a246e28aa97d75919fe5f9e084bad728bf93a10e0317f22fa06a873daf59ebfd1ac0003ee436b2c62bf02c441d85e6586f9094406805a07318805e1aff0d7c09df577df7b9e107bac6b2f2d2895813e89214064f38c4aa45a6a679a9f58f500f3fb40b949bb436aada02a36aa417356e835ce82f3ebafe01e339b68d1e9aab9fa934691ebef18e10b6be0c94a4f52552289fbaaa49fa132a0a5fc09f426dfd851a85d01d2124755f5d56a52ceb1b26b4ff241c3a5c9ff58fc3150760fb62a941f22cdc3f568931b258e188a5ba37980c17362605fee85bc3111360001327518d17320a347851b63f54d0406e9519609f447e1ff1cc6f6d33eabb91ded6ef6f0ef73a10512c4344f70d961125d11f427bbf6ab914f6edabbcddebd125b3a748b54de2cb8448ff32eb75d366924f511aaa24ec375e1c7e8e0e5e2c3439c0237e94b31f8313ad42971b6af7b1ef6eb15bb1f3ddc27ef70717ef068f86115da1b7f7bde00780b3d21075b0deff57ae823f81b9d7782018c1daea6bd4d0d8c8f99479c53360cb12e5c494470c02b2ce48fe7d5d0257019b95b89c375fc7f71432b1d7138ae5994ab3f6d6c2bb3ac8c79dd5e8329d5710575ed6bd94657ed9ef471727894158f603f4ba92e79ab49ff353ec3a0e03c392b8a943e17a20dbfe34c98524a4b241d162501b8131385431cfc9a37437f5469b0dbe22a7384d875b4e88a821393f475038f417ef2265023b9e6b84641ee65614d475a24b1c7b509aa21714c4f52a9670eed751b5bd7c454df154c246161fec2a5c12299be6920956097f7f2b3bb90b934093c1743d4146be5c13d19c2b33fc5839e6ad5a57be19d675266a630f400be944ad168540cbf2d5a61c3d4bc3ff683492dcbc8ae9dd619198f792c773b1d2cc4a975bd8d615e3de352d65af4e6425635dcd659b18d12c59b0aa0709e492b0ca69540129e1c349556cfbcb363bcb5d081f6ad5dd3a7cd9e1dfb55b8a65912af0a612223a9bbd0dd95a9f93ae374981312fdb297330f530927fd4bff512649f1f51615407bd0c5b009afc625828b51bb20a19ff390b1ed4693f5ecc16619f821402e0e634ca30896ef7d0a87a9abedb9661d5aed8ad63a05b3c02c30e546a16593ec8ca77a3cd052533740839b34ff558db0cb60b6e0db98007b76317f92bfe757546a7b712aab4041d27b97ab2a8f80fd2b171708461b8df70893ce81a3f372747d6f73694e6b1fdbfee8d9ba6558add340ffb4fc06dedaa7d2b156f954914726688225e25b3ef4ac266c6be077abb4ad52519aab38824f621082d4b2496bf4f17f3da7675fc43406ea8ee0cc8b6c371e2a2ae452f8c6a70dcbcef656571c913c7e4ecbeb8a40a3f7f7dad467912c342543285e106a521d77c0237f7edfdaa5894e02dd373161a2d2487b2c8d8755db342688c8b877977252d2f643889e82957fa18e4211af003d9ac1dfae8affa0b507757f61882c1b44691be3dc1f02925edc9ab563ef2b97d17052432fe1b6c74b96e738af268e8faf82b14d60b2b07b9e3b3ec5b244ea410c2fd7e2fd2d6dc5619dc29a8ed3f3b746c2a4dc568dff21f9713eb5229b344a35405504af4949cd3a367ee33762422f4d8cc7dc17e8e26ab44d285129f660b8ef03958f5fa96a738152d94df808bd85f452ca36a3009ce0b04e8c86475d6d11b0db8ce6b3c75eaf879304b38cc84593c4e5058f20384df6fc83a16b8d5496a322087ef28a7b9a7610c5e190bd7153dd14e2c1f14d7aea2e9b8338aaf0d205e88b2257273b15fa686193752aa9f8f41b23243bc941fb59b4a3efd6dca7b64ccad66e20ccf1bdeb7c91b30c78ad6919b5d4ed4dfd34d7fbcea85724ee4abf06033ae72fccf462c747a8612a203c75999e467009acf9de0dc8a1161d25f489fafdba7d1f20c4c149b579c8c8c736150c04ac6298782ed1dccdd9a202bbe33fbaeaf8ec004cab84d0ff95ff2d078c6a7b39aceb90d13f98659906b3195d7ae536d2cf02c67c6f05894964d28849bd19869ae20b82cd9634cd534dc577ddebd91b22ed75e7dfe90e8123f1f5bd14d719a7be619d03ac403ced6f0f4a6ec20a60a70b3453dfd29fe008ac576e174cb5e5f8a7f03178b70a542b04e6964c6378127560d6acd783eb6861612bac7cce9b6777b7259e05443f3ecd92fc6195913052816636e43e0f82d5978612aa775ceaf0910487979a40c9b3402b3bc0306d3e6068f88e0fca41cbc77bbbf422d3b06507ae1bfc627cf863b301a7b7a941889e11fcb90116b7bd4c53924f4274fe029e8f527a5a6e0a99606ece9204778fabe5328be41c3b78b4c448067cdfcf94e7252676ec8c418953121e765d5e10ba3ee0a7438a22e5dafa7fcafa91857390a090488914fa29a5313a71d4b359a38109afbf121b6daa430d0da0edfce2b94328f01bc4894839c979055a5e5fcee4f07d1c7418f717f6cc51f5f81cb9177284b4e948b65fc5f615547908c079bcb07a9936427af12cbd319e2100abe8b9a77006012dd933c7690ae1e70192f78a15eac70c8cdebfba92b9c558125d86f0e68b36d9612fc3167d1fbe4b5b57834f28b127bc4bba57fc62e10e2cf9d9795886a97f7802ca2c076c13c7d375003ef2d65a58db5da970e474ab295694ff6d2a79d545ffb76cbc1ca333d01708e25f047a7898335598ac981e430785f14fc6c014a8f4c0a04bba327610a0d3b441e3a56e5a92d32a9b02e9d09854f2fcd98830812911289acfea86e8f1f53d5f94801bcdabdaa23ad7f9af225bca080938bff89228632e1b29a0dfa7710894c308d17f6687bddc1bffc1e73a177fbc3908de1b32264d85eca477efe68300e2c169ecd7a222e9106ee2b77f2cc36ce21289051e7a9fc4929747a9f1d0660090effec5278c6986cda01e89bd66fb8d6d40e11544b70b85603b4348ac8b5401d7123871d0193ff1c7a356774e6f86e9563b2bcae900fe22f69511f17f45d3106281526c9396be524e1e825265c08094f0823e5c91ca26502cdbe688d9f718bdff67170c7b395bc92165977e7bec66dc57fb6094f2fdfe83020d192518fe7db79219c42a41643c927c545d08d58ca36f59d5c21c89cca4cc5a3fe066e581de3cbf0ba7ad25a800184898d64a0400884461c5136f587d9e40c9303bd254c42d4cfd32b2578da7afef88f53c8fa9ae57d6a694e335e3c49f8d93c3d6b2ce258fc2a428c821f6ff991eac771725c20613a01140e10e227cc54908368e6c3fac6795dbe9bc486adb52b773eae1f2e12126a29fbfee602ece1daecf7ec3ee0090df16640c6e653769d4d7d09149ed468c8303c7945858f0add8a9f86c58663dd32e03024bb75c9fb8cbcd96daa7251963a4549428c435562cb738582e6dc6d70696181a8e0706b74041b0c7c1ab90c828ded80e017c9f3217a1f04557e41deb5d175d4923933c869162b4edc18c4c51e827dc357c9be1700391ebd14dc0478a8dff78adc5ee562af48348ed76020fcedfb3ce90fa5f9d5d93abd9e48f4f155db04f250a3bd23c04d0de52200741fc23c55ef9c45682247f028cffa8b7f53dfe6998636d22e2547896222de338ed768e535f93e861d385c3309d622daf48078e1b13033ebfe049e8206020ee524393702e64e4d22b2d7954d08df1d20d8aa5d3f2c9bd7ed0a3e2a829869f06586d964d03132ce14f5d7ee8e4ca9fd009669904e65c69f6f9eac3db809ff925f0f0b491c7bed393a17edf51c19dc41c190fead8d72d6d2a09e30405573d09831c4756a86b7a2037d4504238635d675ea77bb9a3370bad3c166354e695ddff4ea525bb962dde7e47eaa2ecbef05da90be7e4eac3c12e3018dad5c2e0e2bf059c3625436d1c5a4140f65660c347d8b5a3654e498e2ffa7fccffb19475dfe6aef2a1255f56dca76da6a0478ab91b947e1d0997b48dd267b2575254993cea070f3214b477e1d1756a0898bde839f53804fe12d6a6a3ee4a255f15f71f0daa1b4598c4312bdbe39625dd6b51b6b6ed096fd38a04f99de4e2299389f1949b3ae47fa85ea26b31e65b4831591168ea2144dab19fdd4e17b406ea229e94aa2812ebe79b37ce73b7fb4de08e6e7a75780b7e0949dfd67538ac0222c639d66b274843e62b6dcfe562c302dddf33a252a7a72d2c12118427c5314dc77fd3c8d5186718797935877c18c22d3f9e7f92dda96297fb59cdc4b2a89ade30a285fbfd9c1e00ed8cc0cb174bb0022ccbda197b75865fb04b26ad9533b4bbee1f54e8025103b8889ab6e27a8c8ece1180e0f60fc948491e06769bbe487dd024266aad3181b8db6b66da7299b8885006a96fc779671f3e0e72c91f59f8a36af763f13f6d20054206ee75f96eff68893ef330168acec66ec168aca0dec5c33aecc0f660b21d6a04a473e6a1054e1957f4ad63dd9f02b6d85db15f49654a8d043657cd2018bc812baf470ceef3ba2270f96aeb20834ed8affea9e20ce7e060f73e1623df93f4314f537dec7e2ffbbac6a15ac46cd75462da39e38806c43c0b2127bfe9a7433057ff52fb3fa7bb01db6badde9fee51b3ad68c5129a74e83af351658a844eca13dd004c5d77a7a91ec2134d71ba1af632687f0572ae778b8036f2c0879fede3c6efddb2617604b5c2f11b1b2282f5f1c73472efa1f6ce3993c710d1d0ea9ea40f44d66485c6fd529598f2daa7e26ec0e82e88b06faeefc819654a59baa1f79b4330eebde552a2eec530924d8331fae41ff4a46d50340d90e23c7cff0edbd0392e186859be418b5044fbe5ca9527acc4e23de6ff417e63651fa06390595492c50baf8f7e4d39a890aad177f7832cb781fe815702cddae77f4338f105bab53e92261267563d046b3aaed112c707eb55f0eab22b251863ed893b7eeabd6f774330db6328b98860f96e3914a505fb5be78dff2c7ee21f78e678785bea6eb35ac6e07229a0c79f3b83f6a633c0fe1b9507d983d02aad52e85d6a680811704704a84f76ab621b095ff1bdcb064054a0096bc99261bcae7766a0922ac751c558439b173741945f537ce2bb17f841fc7bb9acdd034d46e408a1dbd20f3e6a7f6ec054a50c020636f9ec29faa5fd6b32a5e5a28b1d92432d4255148745a0656bc4e2a49f296222768f1612d806033369db2e2f3b85309efa0866714e3b7e70ce4518d3323881e40a32a9a5cd814fdf1db023bd5e884487ee1bfb4312228cddff48144443f1572168b321d9b40ae810983f87988b52864e46faa23af0bca0359eca049c766f0b2fa275aab577e9d024be14a86f2d08febaf67c0ca85b98a2ce0ccc8ab3b6650f26abf1f05cea24a11cbfbb15eb203e35985e1860c2a426d37f7480643c1b6c9f0a722498bef8f590a5274104069a0d535a72c03e41ae49de32e8c375161f480b6f25f535f62daea1bd504e3ca801fdd7a3811c04d45cdeffc0ada78831a12dd7ebd7f6735228a748a1afc5c9021d71cc12c684c2a65c7f9a5dbc6628f087af07c0c80497573059815fdc2eea21d0b1348b60527de676dafb4a25dc88b05bf82abbfb37003b17ed752eb6a2f6743d26e23084a56a0a67ce6cd40e66760444ff8487562dbb10af35e3de556de0bc067419e0539c0110bcdb9a29929fa33576841bc3b32e8dd921beb08f69a0cc39df380f50be48ddaaa4bc5fc6ce7fcdefe5621c76d1c1ecb48aa75fb5ba739a24baa808082eb5fccb9456bb8ff9a4152082af43edd121a0cf812bdfe43213ad7796443f024517530585d0c9b90e9473e12833f7c2e8431f3958d33b3271ab13af222bd73a50ff4b374ff3d03a408425c81eb974e150eb22351ff13ae4391555b99f50211b1d270788b901f9b61127984643ce050a1540a6ca4b79dc6fb9ab7c61256ec9c5c1ba41e008f006b50c298666bf7ddb4c78e8f84ba1e540b5f7f6ff66f818bcf5f30b6314b9d90579283736c1015c5928635bef8e836a65bed0f96ff9ec7683deec7a317d6b1799bae433b5e591c132a961e050e3deed6df571446f056a6339bf7652ee247198c8f390aea4e651145d","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
