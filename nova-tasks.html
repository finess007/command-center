<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"a7bdb51dc979a8ba1be26cb90a14f82fdbf2931924dcef7935a73cc28629c33e0bcf7635ddf6ec784d56d026661f09826f8c4a4338bf5dccbaca69cd24d2e00148aee763a42c121875b00781e52340ddd55034f79985cdffd143c09e87d646d6390098ad5e38b87399a5eadf846fa5f45eda150468300590f88bb2594b069fc90ac33a10154bc55046409d0f2347fa6efd4c92c625fef1f4f4950782450b7bb431b4324c252e8e172712dd0bed149483ec4c52df26e60b2f31672984e4b3e31dc2d9dbf76a81f8b481fd925652e51274bf20f9ca4abbb188cb900ba4813ee28496b87d69bfe1c58c529865f70955d042471108fa7f292bf31e88abe47b222645f7d724671340c22d30f827501c3da3b63b7bc750c9e176735482f3d62245fcbb9de79a4210d373e6fa356159d9166115c77a683c2c2872823f533c61bdcc09bbf33d46693f6a53ec4ab47abdee42e15e8c3bee7c5cbc3e01fa4c7a9bfe8444a886176b6b659cce2da2ca3080ad669e222706959c307e1230711fec16c547bf1b9dc35f16e395ebc23d38cd8bb36563e1cd7059cd0fd8d23d7eeb142b7e91954966284616ed32eb559da0afe7c5e7bc864d061531db04ac03abbcef614975f90f9add9941b1c2064f95cfdfb3b0e96d8e1db93eb8c15c0c6b54bfc881c5f9c8d2e129a0d89651505a66782cde636aee7200f856f64e392d5508f03fdd41104158b625d18c4b89b709ba8bc075697c87fb4065efb295b085832c272428c11fa4eec7ea229a868347418ac6bcb693e14dd832d0d55ae2a01ff348ecd8085135b231cfd559f47569e00a716d618096e07d8a45ac14671d54bc65ae13cb9f1c43411456449ad09e89afa26ebddde52aefcd2414ef429256b84d50e469a640702fe714381b157a13291298ae55e8e2ae9a7bae82dc578458a5fce69d5aa91ca1525d39807e006867ef079e64f52985baa21b8d700f42a2360df2c88769e51904eb5f6b3036c0dfbf585afaab38b5d0463cbdb4fa6be284c8e9d322c516a44ce188eec1e8558e4422d19e6c31d165bdd845d5974579468da36ec249bdc053464a3b7531604e83368317999e0f795f99680063664d81097204256e4d43be6123eb15f28fc7a986029fe5f7eb48fa307a893a2cfd36f0bee1c0e6d4272a1bfb4e728dd55bff3a5d370ee7547e72c3d4990ef66ce861bc7da706add380f8cfd923e6483ab0ce45b3d655477ae85c56fa613021e5ebd8f1c8bc913eed19b0b2ca26ec5543cde8acdbbcb17960ea2541b5d0bb088366d29ba23970e3d61dc0b216deeccaad407db9f1d511ba507c2d646aa9d4bcabcc8324216349c3f3c651dea98f0eb7107d336eec685e17f98bf77fe63fa62b14703092e6a6d18363beb51fd2234acfb8ebeab7ad91578e68ebce3559605f3f157a6078a8866968dc16d74b2de3b750aaf7b3f96984723f6595481606b3177c7bb1eda46a9c1cc05d1d697eed3bb0f4b08aea3a6e30fd6671be44315b77e0773048e220486e1596ba7c64722c56b7c9a5e834e306553ed4b97fb7c91660dc2569f5021cf496126c2c0be9b462a674a08421f503a83f0d1cd2ffb66a4187b9d349be2654021bd5731a8d366fe769fde0ecbfcb322e6cdd8e253d6d888f9f2668fc88f490bb813c695ad5d9e5db2124da8a2f4c21300d23c8e12bb95cf1bed17bb3452abc17ccd6d630a54cb5b406cf61cc8f676a15acc32c429a0e0cfb243179c162027223bcb799ad9d89a5202886011bcca747887c3785b87f52887df9c89a86da5d6069c4859d843b5f55f2a8103c4a3b4cb8751471c718ddea77a6a95577861509b5b00117eb744c1d04ec408cc8101e627629b332b9bb21d6dfb16d34e594fd49218bbcd0d66b8e3c59f2daf90811e750350be605031c6dc84646feb7988dd967d0131e1b28cf5e834df67bc51f4229f2bcf6ba2f9a97a4adc83fa261a1c8a00bfc14734e5b827226ee2608b58d91686ea114d3e21c6bb2ced89e8b6b5f369545e394124fad871f5c1abdb95dba1fd415d8620b77e8f3643ce4b561f9123a4582f433d21162dd67a4416bfeeeb94595e81e893f69fedd6abf740a623c386d195c58b152092d2f6bdac78f5a5c64c0bd53a2f516331c608b7eab03251604d7caa9c5cc64a8edea4356cfd7f314a8997218c14616112dd6238f068d70f93f711e385bfe49eda3ac3cc4edd0b7decd42155e8e6441e6e920c67acdbe9ed47d9a1a1c604623de75b9c83c9a63454c1737616556b99ecfc1b7d0b917ff7780b69865485d076faf7c672f091cf6898f0eb5972cf40afc1b45d161f3a6d70a681267974b5d6009062a53dbddd326ae0cc680f4092af396c3a345c192e880bdf94303dd0b34c7772ac0241fd30204c787d3e86a598fc76205327ef614bae34b0f678af521c3971d5fe3aa48d6da3e92f2bfaf29c3b9e3d8d3746164074dc4260e5a0ea57ba6d14bc706f28ac731412de829d3aa6dce965c1d675ff4d69112429933761ce8d8e244fa909ad42efd6f6f452c885422593a5372ed458d8502a8a74bd9d38775ea167e626fa085c7fd0922bcf41dc1e98594ea6b37fc4e82dbb14362e6758535f329f1db03ba02efe5fe5e625e67b4905dfd54d3c76dee4274af368fb4c1e911b8b37ffd23234e12658cd146fb62554e4503674e5a3d1a55b155509383cd25d6cec176e66411a474ea4af8315fc42950ddebddb94fb81416ac93e9b124a33774fdee9091d7d437bbaece663dfb289b6d8d606a5ea6bab7f74ba0db026f0da2827cb8946262396c1d973ed468de19f28916bf99c2d985b9136e0f8206ddb298d140267cb4ee6e659d847091f63fb4882c91d7d8c37e5e1828ce2dcc437415616282479bac6e4f892efea56de4de478583bd84d7f4cbdad6d16d7c260d36d47b8ea79640d89d3ffd3f77cf1c6dc0eae28dd2b0ff266a6b6f71232a9033043a35d725cf33488f7f9fc4a3fa3594bc083f5572a502c54e01bcdb8b294449877651e68ba52c7e17f2522a413fc75eb7e87625ba482b1e78eddc46780a73dab8f6b7c9c6cee69eaa1e477dbf05ba047c7aff9b4396b800b5053180b18f8985b4def9d5c8b228121c10806bc284c30ba3046fa6f47e5e9d087ea6d10853450f1c2c1f120fde3d7b9e569700b325de74c29a9698b44beac87bf649fb6d359501684d4622df375c155e290fa05bd13c980191b4d02b042f501ee718442898d2f0268630767ab50424ccde28b9702d6ba57efd19f2943977624b99f5b28e452f0f888fe9538c6a1c7dc9b0d6cb73a05460e0e23f3fe6d244990c35f70cf8d32add12199ac413f93c14efdf509e4c25926fdcd3cbda15cf319fcbf54d018034d380c333ade6e1b380544df002bf78d95bf676d52cc77b95c1992743b48f17d9fad5409c8f62df3061bcf7249a256092fb4aba596fce4e2d5fd62a3bf31adcfe065d61c4187e29abb639a4ab5ca96a04991241f43d209c0701cbe6fc27dc87385973d52094f0d6d118f57af640e5ef14cfa7df7fe06cd2f4f91c3f36eee864c32add366d3afce657021496b019d651b203e82f5fc452c3a873e725a9a534ceb4feaac99031762451a01c62a548c80710f3753e55e219f6f1ed148e46ffc4b162046f5f9cffe87967d9b06d7db6edd9d2441792ed7ef798dbaca91fe49c7ab5c6d8f098e58fde32636dbf5781e9b0b9e4ab5c39b42f0f3df8d3ef7faf944b6ee199a418abe8f974d9e48da3ad4d9f685dabb0a79f223f5f52147a2011539607afef24ce446a16d451b91ef9238b53eb4c19aed45bf223900bdc1bba4d24ae4f052b5d1dfb63830462c4d7e2662f0ce7e9a441b43ba90bac3ae350ad16b89b9b701953c5efa40025628757697ebc63aca71585dd8b4bbc9b52aa6791486005a5caddf33cfa0f7f2e305797d4c2bad62e33e6838323028c11158531dd7bffb0d047d1619ac83d865c20ea3c930078e6fed297ddda8f2aed8ed32e7feb92ad3bb76048b7d067fa7bffd5c2477ee228a42985401716309996514cb9cf11d181578e7769e8cabb93363fcc77ada8dd8e6512cb1b676c0a0b450018140fc6a7c1ffab9aba7e1f65fc3153e59498dd18277140cf2bbfb19c3ee1aa7717adadb63bbb74a0968d03749f3e4582ee94b1eeda10c684dbf4932c736a217bd0783e6f4e9a8cd64e7bc72d8590fb0e668a9b4bd03e99c56c17ee72b0f827811c236b25c34c88ae68fdda6f3bbd3e5fe6d6fb01431676f944ee71964acb5daa0c02b81b8aacde2492b6fcb98fd94416d63287d4d71958cb61ed11be7df502880ba5ebaf47dbe73f0fa871e5c20f1c9cf528871acccd7aaf10a20914ce321f4e60aecb9e25106840f5361f7d459c54eb8a0bac31588c0a28bed4727bdd73cdecac606b9a240737ccf83ccacecdf15df6433fbc2d48f72930acc1860dab9ea9bb42db0c1215eba293d54e830990f755dbc159fc3160e968fac53303f9da00df521c6f9a654f3d74bdf6ac6b1eeb06bd81ffc13eafaa7da2f122284bcdb5551f3bbfd7691ae5fc49f85389b7be1ba84555e1d2972eb24850a8928176f229e08260c450d2bb04ab42c21a6177fd0cf4494c3e91bc230c51a3774d3aec7d76048c9f6f2c63b105a4a2d92791d52c7e3d72f03fa911afa2865904d4f118a581eecba8e758c1078cc224a2dadf6da81e63b5336b3c8995d6a47d8b7e26eb8511aa2cb60f6ffe01cf76a61e5a31c72bfe6d6e0b5c3bbfb70015cbfc2c19247079c5405cfb25b4ac51e520e90a7685eb14c9f3616ea0a60c45e1e90d34c26aa582d7b382ca9e31ef58afb8a8d79daf7ebcf1108e9ef61bb11973ae837a5836a5792fa2febf0514b25c44d30914751a214e78b6e2f07de350bb7d8e2aac5195d41559930925b485e1d669aa6a26f514f216f65f8491ebacf83dd8b50481807671f5f8a36f5fad39f915455ce68c288b2655b6cb3348d9c493a9ebd3957566787ab4f32cd4e363b9cd2d9da45c827aafac2f2602437108fda67def711042cb6de60ddfb1deb91cc30d997ad2e0c21bd2c391e99e8a854b1b72718e5dd1cd6a91a8ebc8e82e5f371651b2bc44f748ec1063dd9217848d525664122b6c8b354c433a02b3d7326d472ab778974561d22f7a7d5f61c4fcec03650a815785bb6482c9a3793fc0b253dbcc1013d0151aa9339d9bd6e96a42ae9ae9c39cb0dc4caecc9ef885e7cfc6d86bfa2e4465752828cf96d50da297052897c8e15f353fb33750cf68d6db709f1241e1281c005caf3965cb3e5c2fc9217aae77385905304c927268883e4c9a942c998d44dc230e6668605c0b0608fd98b0426651e0ce6d2fcc120bd79bf78261d07fe357cc86b4ffd9fab2511a4f858515df84eddc6989452025cb753daefca9f4cbc265603e85a5f930e52fc43d76d5d52464ccbbabb599a78851af97d929078ae0e7e86a5c3f7b7860fc2498d70f568fb6ad17777db3e743e677a0189cfd6b618cd51cdd8e8b007c3d8de49b4011e5ff50e872b3cb3026aad99cd8fe1184a77c9141c397224a2ce9cee580ee2ae7f5fd8e0b19b8cd48749bd30b25e090960ba080f64b45a59ff17e240037ecd360065fc5a7a454561ed1dccc06f25bf38c46aa8b2e2e44b1692785b39f880c58834f15b7cda04d84708b2871c2c559cf19be8886836d04f28061aeb6775b6ebcbc94068f8dd1ff6985d85b9b96b48af58e82db1ed2d720a32ab0a264f63a09e9ce92d2a00aa3f3b025e025fd79fb5afb385b9e0099811cb531bd163c66b5fee46799580c6a3a7e5d9a52f890aec0d5759dd16103d6276f80054dafbff0e88afabd415356848dbaf16e438168f3b07d5726cd8134f43fe45d0ada0f2a4a8b013c9a0057e47441ba85780d53134cf64f794a2fb83da8f802c4253b677b16c23c59ef9b958587b1d4238d8767f7714180a746c400085e30fa22604909689efbdf7b96f58fd85b08a7972ab2cada586ae1c254fda392e355b896966b4c354761cad9d93f0c58c5782593ea957db9dccaddf09acd359016a7af3b8307e31f85248b259954e6e627bd7b05a29190d8cf0844b6761c7f58cd881e5af3d8cca83af5914d19ac9ea25eb872ee63dff771a5cf53c06f9219cd857f2c84a98fa8dbb3f6de8f21508e15747d953ea2f6b2b7c595d61dcf7520a8aceb100b1a2140eb9423d71326a0bea073712c30fd4c67d24aba88def07b11cc39d962ab75ad779a8f7bd682b74d4025bba90a76db9e88f77a3dcffa8058437a937e6780c3d4a34a9e42c3cdb055ebc426e68b89947709ce7b97ddf124150353e3cc9ff789834834ab37a04e095ff6f6c5f26fd8ee594ba2a7a4f09666d73952857969b8b064e5141a9c4ed02ed54b1cccd887d5c47f7089201776d63468cf514f0bcbb68aa1ba5f59ca81fef516925bc5e55017e817ab8d31108cc1a955382f0f961a2b989fc432cf6129d8ca669b0f6b8d65fbc579d9688ade228c586448f08b8a37be72f8e8bb036a7ab504673199ebe5816d37dc98500d571d0f42c84db212a3e8eb64a2bcfa146e24ea7a29f2c2a178d3e9af688df4d2a48c82adebf82dab83da8f4324199d0a8489a53add45203b606a1334bac5c1955ace3dc78f04646f6523000c5342d9cc166038091eae39ef99139f7126792b3903c24343db72d715ffefa29d7e0b3383dbf4b062e5ccb19845fcf7cd916563619dd989238513e77faa93085e624ec1da3d4a502cad31c11bb5139fef441b826f6e2af3ab723eba65b87204d0f9dc596fee9cdf747c9b934e669149846a840b638ed0829085aad714acd1f0be4eb1a7ebd4d749f1cea97d533f6f1ea571823c7b658150112208190c26bfc77bde45f37c214720cc7119fa26b6a9e57d61ef320b5758398d2b73858c9e4a2703b2f9e2d8f901802645572f7da921f78dd85c5c5ae5861910585821f4f25fb7a78afcaf0d02644ad982dda338070cd327f5d933ecea578ada162af220db0beb834a1761ab28b55779e372b9acb4c51b51491957758808788f917e8c756821537f88a6aa1637fc38c7f175e764932ccd1b2a7a0113abcd3c4be90d2ea60cfb112d817f117c83aa6760eda9ab5313552c31b2fe2961eda6ac95cb147f6a3cf77392c391d0c4e8eded06dcb3394fccbf1ecc5f47d0866c01e26195f9367931e7204450574b0262159e13ee8c3ce1bcbc722c852f3e3fce23972b64ddc2c9f42982041c77b990b8f6a46ca090595d4cb005d77ba7de488b8aea7607d74f31572c8c0ad677181a448ce44c5e2a2a302cc1bec229a93f468ac6d0e7baffd428edd5dbd7a4556d19a6e5310ed5cdf815a26bf0ccc832b49731ec998cc5800c22ade2ece5dfe831c0a8e6a60580c7607b85eee0d4a662b76bcc71085377acb721f6847a3b1f8f19d31cfb3ca6cda1ad76f8cf58c90ddac474cfb6091904b903f71274d3920fe23e3a152982619e386f7beda8c53eb050b7a5447bbe6773b0874a76397f48cae8f2c2d60fe6bdaeda98a81d826d2a0ff76c2c53707870d04ba116bdeca0a34a7deac626e17b5b63c2f0430d08ff9612e34938501077afe418426c15f663f69dba78daf33885aa0f7438c4c08adfe7c285a0b9947c50888a8fd5e10364d9b4da0fed3d9b0a7c8e009ef457b961eb9d6af9afa027c4686a03f142e0da9e4e20ca1040c273cb657214b3339046434e09e901546e3f487527274b79a47c26f9ab9e080445a64a519a2bd883898018a58672864bc15b0b526eb5af4bd9b22550959276c1c9e722b184fbc1de55965c5eb6ac36b23a0023fa8e985bab6d810f81e480682ffe5f244964ecc36717854312a6606d93cf8b4d527c14a0ffd1d745baff5e22e4b9feb3f8d013e6bf7152c4044f2daa805d4be8bb8bf6d93e34d85fb339dac7f6208578446312492f9cb2a87fb9ada512baaf3d53bf294e5d68203ceee73421dc7654183fb3929f771fce75b502bc0f04db8284ea7a8a472f55951428ae76f0bdb3488194cf68eda1d86d1a8c0212ed064ae3f452d1a17cf00bdfc0dda0d11f98009e405dbfb9f49df0f678a4627655c5dcc87919c5984933b1a4d785fd1fe4d3703197434cbb83a7a9d3ffbcc96458d8a109a6a7ce161dc2fad128dad051dbcb36f520519e36e0f95274dbebd8fe8d8fc8324e9b43dc5536d5b8b38b1605d62fa1bb62fe18ba33b01682f84315475f944d43ca58e2f6e2e12913f03d6b0cd629f4508901621cb53a155b921452fc72b240aa9a9ccf19a7e518b2e6fff8c0e9be6255c7a8611dc4699117186f12ac1e47b84a0bf2124bc3257ea4af2903d7b4f5029db1d476f9317a85628080e7c7fdf80100b5aa3945df18f0abd7918932e68d8f75cdf55fdd8a2f4f08ea622a5b268153ff4a9bba287386e285ecfbd70f7b8886600af188e58408370294c6cd8e91b70fee6bc9e1c54f3722e6d073b3e4d570ed062c084fb3d925357e7bc594f1be34485a6b4978c38185ced7d0acc83312efb9466d8fc06d11b400d3b2ac2ca4babbf3eb489c4c36a595f0ef90522119be9241e1ded02397038e6321233122677915b966989dcd1fd664a9adca8a485447f1cbfec8a76fceac86f384c934ec69a67b10a1498145e1b5e8f169f1b96e7a84b0d728532f43dd395cd2fbc5306571cae7d1f2a5652add4d5efbfcc4047ae4f79f8da7f27086c0d3d585c32cbbf6b07152162fe378d63193f8fae3ca6817c010f56bcfb65dd64cb900950f181716b9b6c778ea23a413ceaec4ea462d56dd54fe16f846465b5fd723332eb5a45d2ce8397d3558b058a2bd50463b50b8985c480378ce69e76ca192b906b4b550ef36a643ce10d1cdde9215c7d6ed785f6e9e6e925a613995f111621c67ad61bfa635955c9e5a28f12b8edadfa4a0140ac00d5140d5eb6386d319a1e8566effbdef899fd585ff6365c9569427e4f4e65116f2ef8767249453c9a62fe0b8659cc7e8f779ce942a59a1846653452a47730b200b2d4c11214229e240afb1bafa35d8cb19039b6947fb1ab53966667bcb18f3dea62375d2264905a5132433cbf092d7b04b432febb155f38188c95e19e5b27c278b3856d5fd5d910f5a0ebb6323c978563d264cdc59dbcbb0e2d5987cd64268654e35474609227584fd6431934ad1c7e1af644cd859de64864e6fd17fd330cb384adcd9b56d36df420a437ea2e5d8df65c06a7b3e89ffd842fff4a350b668dfbac32c8feccaa3a6112790a75828c1809c02e89b141cd3d3802666cd6c7458f433acdbab8b1c025178d2029c67fbaf6bbba6b95edd9722b1d797cb56647cd696fe99ba8b199d237168c66044d6971c81fd153cae645e36193b416f8ea616c575261c22d95d14f383ada1ce55c675c7bd096bddeea2d30ca5ad33801baf4cb1db8d986061370f75f99cd6b5a799b8219463661f596f673fc43520c36cc25aae673777a71883c4d8a285d9351174e49107d4158fb0dcd1ac147c45920cb7a6e6719765d098c7a3b0e1568d803116606a2c8f2b297e90f4534b171998bdf4fe765c6fd560005596d23ba119a6f08ca30172f2f1d671c61573af46e5d8c844a12d1872b1351120a44899e482fce547f3a21d3971222f09609048ed151514d08d9d96651b6d87a3705868cc543318cd6bf673277a97ed3f4ac042ece25dc925ac95a0b81b62b60f2d3b981ae43fb6a1d452c3294de6e651abb60cc4181f581d897df943753f316ee61c38805e2aeeba670c038a5e1a32a424881d1068e703a124f9b5f095fea2e864986ed23c135c7356a7d7de4769bc469800484ec321edcfc10c4cc08474dedb8b7277ed827481a1b865e195fcb854cfb9b22a13bf5e32d5d8d14a6526842da841aa85273dcb25551d5ef51f699cf24a50393b438b53be3d6fe0c6bb9d27034046a147b68be0c65532490185eb42fd664268fe0fdd2b61f0e000a940277df1f48e5b7313b65a65d24e73a34b252a61017d8411a2a68696cdd71f478f754e71dc83bf3fd09e0a18f2f691f27335433bf8b2ffcadb79c86c80f3e37ca781b6fdb35f3bddfbfc0cc6ff4d91b762441fee08b6b24b837ce45372946b44f862c458fb51d7d042234de1ca2c051988cee0e036db31197362d388260060fb9ae1aea88317f0411209a11cdf34ea9232b67d0ef2ac7685a8cee12782f6096b707b0b70de7d40cebd6e5b7dc91fa36a359421443db6f7c9cbc497bca2c46ac4a30ac73a26bdd87749571c95f609b1ef2623604aab7f09da4c7be4af37ee71b672f3c9a941184c9c8e35edbf08e27f62df8593fbf949cf4bddaee1f1d84abd4632283536b657d0923daae65efd8bafa460721fa37c4a9ed85b11e65e69e7909d8c37cfe82566f8d68f634fbe7e7a18dd6129067ce2e12bf8c2c200f36ebc1285a73e5fad626f308c5318d9d6157971ceb71a72e061a3fb9194c1eb330ba5aecdcbda7439c9e12cd0053c4efd9fc16dcfb55cb98b587978c611fb1a988b13917306c5de85d7646dc13e3e4ad162d24e6af005deb912eedb997288e8625638d16c14259518760f0d1af386040f5626b1d34b420a41e3d59319cebfb911bbf6e6d63efda292b54d74bfc2c1782fe69b7ede93f102feab2c4b703a260ba043b01bc6251a0dbf80c7db3605a618777bcdf79381e46279869d76e2aab81c57c7146e6bfbd5ee7fa3571cd0d04acb961cbd8e969cf14bc2081616365c4ddb20bc6879090a0109c905c75fcb858316d278523a78eba03e8f537e74f64a6814c6966a2de4c9cdc1681fd0d3fb74e7dad7fde03905f9b1d853a9af67a69aa6d0398410143efdf9d59c57d9436937ae0cceb5084ddcd391701ee9e52f5da18464a68b5f9e9a59b8e03649edbd8e28261ee56b8421b641825dc607a0ad5b9e2af732300bf594db643b369eeb2a2674b3870ebf8fa178a7d119b0bf0a35112a7d9559ac7059d90e6c1a91ab3d28405a7f10603837097e250f477e042e4cc80aea40ad15bd4f4ee35eb39e56639ab71b890f8461935bc4f77c25db54f96149e12e54b0e1788ee6d321ff124b8b8883ea689ac6a29e2ea6100e828e568b4ce5539003cf05f2a7f6b1d2965463e56be584f3875a9546490bfbc1007c9f77c5e9928386bf6bfdfabab1cea6d82177a7c219ad48a0c1b7ef85ca3b103f6a1f4d8602f08caa67747691a2e242b8b885e7a8842482a895dc4424c182b8ce15a93fec13278dd2f442da6e67320e187d773e022980a08ec5e65cc960aae93aea5fcc51eef6dc5f00f4cbb984ab8adcbd4883df652a1a13dd4788316755968c5e4d4edc9f4b7e30433dd3d9fcdacaf657954462e1253dc81d33f4a46c1325edf20f0b2e57560d0cb2a26f50e85415ef0e64c29d8feac4613400f7a0aa529a47ebad1ecc07c45c7b93ab943d43b6573c4268c34d67a23a6ff1d1e679bfeff808a0050a795a08f01aa68e454e61a98e690f8544a6949cde5473c320b4e94aff097c7a965c23116cda7418415b27b1a9646123573afd26452b024fef166a06e5dcd0d99a7c83cf3a69c4d5ee1f1cafea51c959f099fb091e426e822419d7a7e294c1ca205150288a2bb6b8e245d8030672134d9dac4529caaf635820e5e352b30a6c85c458fdffa631c101b6ad054cbd17a2584d854c0c4e297ae5e44cec6810d0d6cf48a2c6a8aa5b0e490e4f0cd19d6480be868e9609cb8bbfa8a4e0a077bf9788145d3f874abc8fcb1286dfd47f79a31e4996584eae1f310f4e5dc5014cdc07cdb8c63293aa2d1d3e890c5fe703a48fda9ee879c8f8b59d78c65eb40a6d514b963b76186ad20a14572add4cd64bd77a017000912d0a4e9da998cb2c9c121c2e129295a2805134d718bbc803e81633b90093c9ea49592a50d58eb3b31fdebe28f5c52fb9328bda4cacd467af14148e1e7c86e522bc58545be5c0f32d3bd0cf6031dcd3a0c310e601f969a2b0960ffecf8899bed81760c116d38b3538b45e4014600529ce46ec25b671f0adaf593f87aef89096b378cd5b0ecb68e2bcb6f93b959703b7c4b442689c2164eae6d1689cf6d00b33ceb9fc5c3f7bc6bb3ae1b4ac4a0c9676a5ef4451662412af08e32a1d8090ed284b2e18adb92e37b8f507e9c5fce82123b67392d2565d207b6344f370f79a9a813505498b9edcf0b9879e54be3b2ce1657fca6c96e0fbf4085f6dd25c3a00676e0cdfe5deafb7cc7f55ee722056098514af061e511647edaca8e238986c6f9d14154cfb6f9e3321293a68f014aa1f221eaf889b78ac0f228faa9e7c9767c63252377cf5fca642fafc2bd384d86dfe03eddd5e462715c2312bd0f93068a0550cbb9fb330b47b9cf57796baadb359ff4f339e03a5971f87b51883752a1f6391998cdfb7276e9f369edd1c7b2ff7d488ce50b728931385dfdc280a60ee349183570af7033cae2d30ecf3d30258e5770c57fc81321a8c9f11d017e401d3ce3c090018dc31bdf8f48c0ca06721eca952a6b4c49ab62a3864f79215e74674e7c00147186ca8086be9f24e2f6eeb730a7c60e91b06b4e25ff85d30c9509a39c8df5adab8d8f3ac5999c162a30a87b8bba03ff4f9070170086220f1a6292d97ac6e83ad7dd4f8c622c66b78a1e5a2fe9876708f7a61139b02a3f9d772b5bda761402faa5a6099c6fb6dfbad4b48aeaa8837a8501a614faf409cb8b24855cbde0821218c9d0e4209fd31d6930f515e4c51d5bd89e2fe2a2334fa848bd467c45330b0766704a1d3c6f2abc87e51d2b0964dc46b9e1926247f6c5c8131cdc1c07ad8284155529e6f871f2d06d32c58ac8173abf67c6e6ae32fb2c95b40941ff69eb248836458ff8acfe1d8ffed2c06154159e4219a456175e130754d6de6443e7374c3652c2138b08cb01e598abdcf7667059faad3662f51ddb4c059c8c9a3699ae704a91482a4622f6d36a3d87318405ace6ecc3cf345292341789b2867dd7a87cd5a13d953e70c7f06d4e8bbd4c274966e8b9d19f971b079b549c00e214de3056b57f829c14c6bae557578eccd52b8e57b88361198525357611ceb84d2fe0d7c437f385635015f032bcf156144c0e7ed3bf163ef38ee404c4c7a84e394d6459d7825f75273b0c00db1fc83845505d74914915154878419557eba4f9e416b31d5a6eec144eadf8a8255a08d37b7463ef3728a6c523c3f0a040f0bf112c8ba359162fa0f5f17d569faffd23912185c1648a23a4c13228f6f8aa085316f279d8579a8d9c870366e8e998a077550dfc0956fd54f556f84850960306d25652906662fc1f20bd527d38253b6b8f04067ca6fde6a4f2326a413d903975fc465b4abb566103d5b13fb8339bdaac06b32b4b7116b563231b63d4cc5d2b84c38fe42493b8b4d340f241be86256a28e483a29667d2991c2aecb1d3725d10f2d1cb85bd554ac900e9a43c7dcdcd41cbe7e0389fb45313bb6217a1b3c1c7ab8763d7ffe0a49d35d0d770d5d50777a17716b9ae03ef73a73a3801f9103f5882daacc6f5d69fdcd2b0c782b832e2f7be6e02921c57b1977684224f66028bb5d5fc04f08f21ef3ca8c61150be4b5b357f25f5e2dbf64fad62f866f9829b82b0329aa852fa1ce70d5e5fe4c015c03918964059b9969f9713953a75587b740a4e3ba22162771094565efb7cb42d242fd274c9ea7b7b3a57c7b24b5f702c61b94e4f4f4da2a93544398bfc43e4ee7050e32d19103e2f1a2f570fe4fa5c705301ea7ec814bad53c68edf8b72be2e66c86e17286510ea297cd6686e0d7706dd7d0ea67f8ecb6c8751ef54e947864f3ac2dab9f5183ca8829d510185cfa1daf62ae338ed32fccecf99d6f572891633c8a4bb24d075ffd5e7cf93c51b27c8d25fe998dbcf4dd642e6b89c78f70c16646b1ac47004b95b04f712b1be43bce348e6536c9ba8cbccf845ba96026e3200fe53ca8c185f1653521539dbbb15403c6cf0f4afce133b7608441c591af770567aacb862b6ae701931b5ed4ff5c95ad87826105dfa672e60bfb9e0a6a50826ce8f42528fa04c3b7b44b3856d5abede42dde8508ea13a268248dd167aeaa0b15eddbe807d2c1d32a69ceba08a1666eccba6d2c89505a92709d57172d4656e0f46173f50da4eb880263aa009ab30e8c9ce454b05f19905c57f96e5d2fac7a31cc245796560fe2bf1d8afe9a8bfbce82cd6c76aeb7fb1d1e92a9966677bf6fcfc80d152578fa9427e0fc183c7ea51d6654d78357240b410fe75e02c53ba2bc41cf41a28751ed01e4ace5d77dff1a461aa313269b7b5e15894ac8dae5545a5f21b6a2e6596d801c77fb40e06b9108046a54db714734d035ed01783dc8a50157463dfdb314d5624a1a5eab12b9bd03cd62fa7ae556a6eabb59ed0e3e55fab6f6a4141bae57d5273c7d00c2752e2433c6b5d8a86103194fbc4fb9d9797462d0c65afca64e7cc64cd06845b1e9f6eaa889b92e6c72b99c0e126a4efe36a1698c892218bad6e7aabd3d03800d813868c888256d71d44c8","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
