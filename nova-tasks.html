<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4017499f902c7dd879f68bc2542faf25fabf899da7159bfc1e0ea47529e2d65e900bb53885d0fb018287be2ded7240759271247ed611ac28b69065f2a7b39eb94c241401d7d52927b18ec16d32d504bc4aac86939e7347102ce2e88048d2315a40d23b2b0bf8148774d207b7509affccd9b85b61b4f306840f102e39211b5f13621c73252dc58bb72186b74baf13c3dc810c0f7c15b132065cac83be626a8e79882af702edc3eb400f7cad54c1add2ce22c388709ab177037c24b4e0edc484424cb016f65d12b9bda7a5efb8d42f94959b2117d4059d381e17cf4a4f840e1d4536ef54455fb7692d5672a8830363a2c5172cf669592dba66c759a68b393dd616ecbbc2787b8d0303ec23cb0af8b672ed4438e9ffbc497341378d912ee4389f146c2fae85605589cb5f64929ec0d1e0becc76c09a681200bb0c0f85878544405ac529eebbcd5a7b8b76da0453e87457be6996461aa88e556883a167b0e2af996b8ee0a11db204a5129bdcbaf7d95e26a4308fa3ae3002feed200ba067ee711bfcca261d353e214ff13123cdbcb42a6e362d0d536da01eb3b1c250a1df74cd1aba8b9210de64dda252b8e7c68e841bee64d1e3ccb89f051ecfcbe9a724dd0712e3b776058cc9ab1adf48e6423620b93d77916a9369c72b04d2d1de850add857d30106f32e820e17a6aad64cfaae133293b829a8249c6b08ba459c815c3f7f97dda311f301ab08067a1d75c73c7685b9681096df4b4661f7c68b0756f38b7ab3554c6effbdb40b6d58d941ce4f415605fd3634c89a257222be078b4a6f8d3c8591b5568035d304011a176c1fb36ffb4a577dc893919bb71bb0c48f92fc8deffb1577cbf4772ea041af058e752ca7f207e3099e4d136922e4bc1fd42f812a8e9ce7688a8fb754a5bf4fd9082b030bd7b0d8aff93ebfae9b7d1c5bc8a37a1145e15ce05735fcb2ec8661f91d02be4a37415ac832453e05135196064493dcba82acbbb127e18be5f290755672064a9ae99aabc96ecb5e9187ba8e7040be9f31d1284adbaa3abeeaeb14d22c78f47e61588d1a2119e5d2504583a8face76ec6277e396bbddc73103d893292fc3822e0f5b2a888534b0355e615262533fde8464ff516cf89f67f246547cc22b475141d10d5adfeb0c4be87e8c4d2f194e9cacfe1aeee1e32b2c9ee5e82459cbdab0cc66766dbf0c23f1ab095558410e9a3d8ad5f1d22730053ae9b1f88694be88112b1749b22b73915117247fb08cf42b853143cdb7fce7b9142ef2e05f1b4597263a4c507060c14df1cfa22accd5ab34ca8a1b7d557c0b507ba26c8cae1c52476b21a89fbe5dcbcc3ce9a3d3efa5755b5a04db41eb94eeedc9de24f9484345e13637b6f29a9f9111f66e28204bbfa8f2aaf38f70e7d22aa529e16bdfd199241530fc934d52081423d9e335007d809755d2d2a672b631b725f7351f7fcc035689e4a87867fcf29f832cdc258d65c0647faa2b492758d6b1a809cde1a822236368f17209e84a92f4f5ed4b646f45a9a5bb0e06bee58a56565bf8beb323b6337f31f7191900d688341767d84cd69d19f7913f45b2abd1048b0499e6518debd4f8c80772c8839cf6c3e3119c8ff4613f5fd1f716bdbbab5c19c7f11f94b5f8c229defdd31f4e625f2dd876e96a3b8de086ab300cccc4ffce30edcdc7b03bca7c55410f76e51e81923f1e744cf1034defb1d600c8610259005349a1c68ecd999b032eda906b1752c5cf7455452f3373614c3a1162ce382d4aad3deb3fd563c8a1a5f506fc1999b427decb8aed5dcf3cb237a09725454f566246689c02a08b5a3ef6c84dffdfca6035178bd0b5cd0f66f0f7564eb0019389aa448ba7a372d1fcc399384367ac4d258559e7d79a917a0329bc8898087fbda902f2d7c5244a226d3cd3d019f8c4b10268b2c4740ec9883594bd2efdfcb07e20dbf49312984931b1c6ae3a3e2280532c3f47240cdae2f0cddb9995bc53349242a2bf482e892dd2c63b237bd527ef03b8c05927bd7352affe8b9c771cc55572dcceb86e42b3a441ac3b6da71e2c6afe4e4fa5ce7a9ad24dc061d4a5a67cbea73b1885a285875cbd197c06fba383eda3f7e48366d958b3684e6bfbcfc0313ef335bef383f58ee1075405051f5ff79f666cab33a67bd479c774bbe1b47a358cf8fab395c6a3aa76fd707346f0383aff6e974292ecab19e6657a4190e48a927fa4ade0d0d2c2ae7f13697f76773f588480c47bc2ccb552f568009b078880b57c5ef7177738f7766d5998742a7458d35be2838c01c00e53c9e4ffe58c110e442d4c073b27aeb9b3777c4c4bff773f66ffc7311ff3341cd6c8840349ae12d131a1e805045aa449cc6678203918dd4daaa9868655e07211f5a091deea30ea10226a599fe799b5d5992ca1226b271eacf6d21226d76105ede9a5730e2c875575879177ac64e42ef027c711537071dd07750b64285f8e7a84dbf72eab9e9ba3c8369655dee412cb686cdd429f024f28497e8759f480503fd1e444c39b6806e2de8abad98c8685c697055fff430c96314b16f9ceb514eaaac7caedcd0eb2fa01e7842567a876b2219e53bc9e2e1a2cf19da59c75dfd19e20db06db70271f426bbb0d7072dfe0ce0b68116058801b0fd01ae165348b7beac45db95d365f6f6a157b087a65052ab0b94543dbab1e4dff74e73a1c1f438f559d5a5c8f077ae1df48aa68f73f990409186b9eb8df773cbc4f9f8998a8d6945e84da877b4c98590fca6c6b567d8088154e5ed363eeed682aa86760b27e6bf7854c01502c905df3c35f85338b52c1ab92c782794e456ad09cba9a682412b54ca626654fe84e39b44863adabe81aad9f56c074f69c69c3ded50812cc0a21be6c063bb32076c688d7d951d76114040b83535c02dcb85db4d97bb7b75d45ccfea56aac12ff2a33a5463510a805e6920a0f1fe5c6662fefafbff7f257abb00463759bd5228b6feac182fff3e9e805453535ce1624256c93a2d0822435ecfb86d213b213e5c97400c990d0ed374f6164381e27d525ea3563d36dacb88c6842fb99999fd0c6303def11d6c8842faca51ee27e11e7e47193e8345fc4a68e67105cf41b739ff0e817cd94ce81cf5ade544b9bcb5b94a18bad9dd67218339710094144dbda02d5e071556394b2ad759c058db6ee2cfdc752b41e7a565f893f41da2d9a9c1528f4c326b8101e75f9e2e79e5daa0690f19d3b27b1e5c55df04c608274ecd1b5417667dfb8f05c47fec67522db0a8e3d0eab696d4cadbbed10c17d71d7619b72f9178a5bc73fcfcf50e665102639b9ed42951d2dd6fa18ad65f57d771f860fdcf7414d147b7256cef6c7b58b5106637f674253a9f10c1294aa21f18a9c6a4316883d1d32f62a7ceacbe5b53f3c209c9cbffe68df1753ccea9e2796ad7339044ea6e53c62d566f1678ea82e757348b1a88a6de904620c117d38e9b262774933fd2b2548bd09ae01cb3eb754dbede059fe270bab937d6dc349bb7c7fdda992e0e72b9be35d30c0ca0a113d2d3ae1ee0de911c0216c74c9f0114257e436fc5223279923ee33b1262096c6bebd8fc788991ba014f23e60647e03aad1e2bd43b2654f0b590a5607e8fff6be0bde2fb8aaa830a2863111068dadd1a4da0cb26aa16dbeb09e43f10d848a49f5bfe86b3c6d6556a6f7dba1484d4f14e3ee9b7d8266b3f46bd358b255b6c1b8418ab68a696c0916402312fdc622f5b660e82f757daeb84aa124b121995aab5959d90e6acf0d4786ba4610e1c5d0f04ec00bfe30cf411c1f8b20882a3ba1bc37e3611df22a77dda7deaea3f2713def2a0bfe1cb0c6ece7a85e093226b5c07cd0bd34deed44615f8f8c3212724b9971dcb6f2a06b440f41c8e100cdcf350383cc6d469f5e8d61d464f62539bc839de7da4c065ccc06ae635d5e23d1f042520a65d6b9cd7f72fbde9519cb4fbb6754f357a4871263f31b05edc35950920e0d121aabacaf1943a8f3b57b84a4b8928a7fec752e2042888c7dc1fc5ee99b0d200617aa86f14cf7bbe55ff7b9c88fac9816b098fc59463fd99d4ac8aa57d363644974c4d159da1af0b3d723432d517ed42cdc2cb13cd067be85446bdf55aaa0bc9d06dfafe7440d206352d4b93446438c8d9a8d185d25a05cda32d068d23a6955bec37dece2ec1f33c2086517265893cba70f88bb4d8598cb3fd7c6dae494686fb3d782ec54a888f753d1761b33531c72538e8adc0bed0677e94337931ac0b7dfcb935f84580bbafcd6e515a576e09fb301d1424f8d5de624fc2f4b277110ff643c4c8e636ab7d0a907cc2f90b67a0c125de38a2d97c2ebab7a6bd697d6a025dc3aef97c72a42b24e56e3384b83c8e2f0c3b6e957676bd56d54516ad48eca3003f196a3b715175d181a408478252b6ef098ff6d84c3ca0abf8ce79207ceb94be59b6c5d949d139997a6610553740762d484188efb6cd014772173e62baeddf5d0910357433e2ab195bd395058f965fcf5385dba2b5c802a9ff3fe507fb2a4b2b80a81c4ffb8219de994ce6e9c46764b58f8145feffa099e7af356132b986a36a0b9d2b8ec25034f32e9b2e6f80dd73b714533afc2b62ce7b7e404a9007ecfa93f05a73028c4b0c96f28f9d7655081bcc03e5077e4726528d2ba836a78f1353a4456e81c352f303230d042969df3fc4b5cfe8788b6e5132364d305a6b8f3e51a9719d5439c4362ec8798ca08ddc538da6e8a5b4cc361061b094560ee14c7377e1d7b6e9d5cc66031b71fb349f2a083953396936e2eaa750f789035574096468a4d9ecbf8678d79c2166939e60df4441fb82d99521803c9b1ec15829eba1e0f64562cd7d623cfe1573e0b6a75a4494e75797b5111870b949ecd44095eba53d2aa424d31d01d4d11ee13a0335683a80eef06b1f9634a5144d2c99f5f059611091d183aac857e4537c7a5578ba0fc634394533e3ad1c7d676b0107632009e9fd112f07a30ed202916f6f2aefd8279bc4dfc71fca29c7bf413e2e6c7be85ed075087a37fd88948e044a690ffb77fed7528a3d2d63b679326cfe0fb53dd0b0af6cda48c9dd6d3db2001e5e6fe80b4f26d339f41540a9f7537d96cf6c18727ebc50f8154a68f6809ffbe282783a7d84d5bafc87af0005d46e9de604f742fb6b2fb156a18bd29a8ecdf5bc11bbae2aa66f6b85f055365413d7db3a8cfe4c3c5382654889cdf438a22f76716eb849a08d8bf41c44d5d844aee604330c8433b29e3e80e965d3bed5a45e16265f2b8426c2b59d2ae37fc625f5c0cbf8a471fe2c31869633c8d31c1b4d681dd92116baa60f0e53ac450db3429bbbaad05f2698fc30c6efde7ada85726988f61a20bb0836994c3ace7da6a891597d8eb8a045ee9e7768b71f7a3cb4d20914078f0b86cc8bf1a874c443ec38e75c04d75c7a6ba3a39c66fbb9f8d3e9185e6604994824caf2188d94900347595e219d169ee5300e59464e5c49fc88e2e2f624c165ed2fdf6447996b987d1a9344da40de39a5c3b9bf80c425735cbbf77fe9b157c6370edbffd52d5b257f2e783c8b5cd04a74714eb5f531227a77cac76fadad420f519d6847034e1f20c562d6e6c20e8177690ec100cbdf5adf029cdbb474f82424b8950e1f19a7c9a19480c046001c7dbd8963652c3dee190120743a7e302d56b75277ba39bd2168780588d9f6c059a49b02112a2a0de7559d4ba697077543f2071f0cdcbe294eb13989297b51e761bacf9cb8954e6082249aa42387842a6a341536724d90d59217080d4f0b5491813f8a54bdd38aa34e08b8e8588147186ad20099c5be614ab81ccbc6cb05cf0d5f9cf8b3b434be24743a374420e21f88d140a40584a01775ceee87bd50274cf50ce493c555e1218cd7f9faf6066bee7c8c79d9c63906c681f11104343e9a6b4328d73efa96d16f95b9ff03a207386a0919e44dff12c043c016b4c986613a489a0b474172e7fe919bd3c71b07b83e5a57795224244d5adbc96ffede4b5c08a8e49bad8b024fae52466136d9237d2eb86d4092c6a4f64555cb9a00826d892f38c57bc20505b75708de79c405ba955db40b08d1644cb4cd5e4d86f56b5a09fd11f1bbac661c6ae865be019a23a2fe3bef62092b5cd52a2d0b3e77d158b4e19b7619e47b3cab1b8ce644739244162eda04bf37e5fb5f68723f19470694059ee6419c812efb28873d2c7cc257001b9edef51ce0b179df74e132ae76a44b5b832f94f93d8f9d793ee52652a37c1f5e89679176e641b7b9212dab99a03498f8c7f1ec80eb7d331ece6f0a827771775e2b0dc8c7ec4494b50c2e346addcf4ea75a342ce3bf9762661a9274ab78276eb3a33fef47e4050f4b0d168b121be0b6beb9aaaa01d0ddec95c333048a4af1f6bfe4dea7b72605377c2d6dfb7ea054833775ecb4bea79cd673c7e5a13d1adabd6bc3218c4a462da18a068635335640ae4618d2f73d944723ff3bf43978c9bb1e380d5c89df4e5cbfa7c3dc2782e0f4af87675e7ea59bc893a8c01652c9e80e0d6d449a5b97219df65c7a395f595ba7bd2efa856b9b69a39b3e86d46db2f696b8afb7eb2984f6eefd1131090808459db6808835cb1432ed46e0cb1ec9c933d0aaf125e5aae438030173c67aa45f26d312ffaea0f1a8bf73dcd9d64c127773916a6a4f90250ce160fd7c8c5483e813d48356d6112b823c56e4e4b9e8d87ec209a865f64a247cc848fe3cbdd82d340aa46c073c504f48f9698797c51f49c9d3e8d6918f4cca5b2bd848a8f3441c45d4dc79cd432f17359e4fe6168925ac65b9571ca80bb399a2cedda3ee4f22c0cfd25d1d56004df5f2cd8e20012a05e08eb5243c345d1915c4b5f81cf2062f1cf6233102b8e801fc053ea7cdf8de3fe71b1ed29b954d6221d9eff1ca1893fa389dd5b538f3e6336ff7a419bcdbc44fe3a25a9ddea88ff7d27ca1582880772421d665e3d2d45b9c8f1d7dbeded4b55faeefa33353a932596e35464825720465e15e10f817ae99737857be66647fc49ab13c0abe2cf123234bd2e1c675bd33225daa975235fdcf21450c41d700eb4fddb1535d59f676efb7d3d40f5799b5aa1f58c097fafe34dd9a24d539ab587cade25b3b40b4a6a4e7274b30fd57edf9a841ef2630146539f0ff25bf46ff7c0a836657c4953d1669f2bcc9196505c7ce10d286c51cf55ecbc6f746c0c9fa433ee16e65728d55850c30b2b1e60c9e9a0760cbb9855af864a425c2462dca9e46a0ff4f8a30f02496556a943f435874ecb703ef444e348d48ac9e315a6bcdfa7505976b2322641649b6df6cc14e51c0bdbbeabcd3a6cdec79bb482286784ac222e2969b92d4506b4cc9d8ff0891a32d6757e1eaac4daf9fa38fd509f1cfb8b7528e30878d6d54699adbacbc43bd31edd968711759241de79b5293aaba52722e1784c98c30e9d292f358a8f2fa245c85e916f980f595794f7a5a420892e32070ed1b863f80e4f9ddfc5fed674d19124c7f35b4ccc3e64cd3347d16eef872d9a774394cf1a3e0cdb618a56ddafbc0ce89c1147f44af33177c78e2b3b30371b0e670b244efe49bcf5e64577a2d4973b400bc2f63cdc7eeb2bac64238466e6708d42aae58b7455db470c6a6ed5ac17482c541fb0b6bd350a02f23c370211888e68a54fb888e376e964f7c31874749257dc189aeb3220f6f526f224c3438d44d15be712ed221ea404648a84a9a3551c35b1afd94cdd9c2c9116530c540fb1da2ab3f2af9562d6c595871b309cc16e985d21cebf82649be209e572aac3f911e866564e1a5a40ca4a994bd761cc01a5d01dbeb4f579db070ab9418d0e775332146b84acb083422772722af9cb83306c3e406762bc21a6f70513893e948436fa13fec0afddce3593130189c6fe429632f309177425b52ea12af973d231dbeb246aef434f3ccd4fba2b1e27990cb02ea05ce3408f92864412d3f0c1868b540f8e93abc7894d8523a4646ece62270d98b0d327de34508fb979d8bfe28cf1e1499c14342cd54a57b499ff14c013502dc8df6ec198c0a40e6148f137398620df32a56cce5d505de0589c64d38a2be7514d6da246b61d2ff6bb3bb4c662879648cdd17dfbffa83eab074180114b97394b0ef4e4ab98ea4784a1411c295ee36ee073224ae7c41eed588a56c855aba4f4e2c6b20dc0d3b12538cdcc2ef1de202f5b22b6f3076bc6e410024e39baa4cd2e64001b9a4e0c08582b2ec510da1f8c40cc5cefa6c02c5c71d12ba57af19d99724b48d80756a68d6951515344a5aa63a59a81dd2975ca4159e71ef3b5f280f6788188f137b7dbe8d9230ae003af0929519060ccda855051b8518fd760bbb8ae0d6d5021af21c0bae15c3a3b481ceb6d18c9c1f9f8cf0bcd8b812aee30563fc24d3b5316c0bfdf7c3de45322317da049334e7f62f6b20835134065a6a07bda5cc851caa750953180d71f1959a3f27fbdd596664c622be3bc28622c67df275ac9f7f78bfaafa63f41e6e49ff8ff7877303caf35fa5a0c6518481166d64563845c232491e10b56bd9d6135db2bb49df479898b1119e6a47d2e244a0423c8210d2ce9c1b40ee8f02e2e4d1d65602ff82f1f66b606e1a0e6563637cd377b1d92972bbf9d22f4c654b413f4233ddbaace15e6e030f71c289986f1adc9c5de8d9c2064eccdfbe312e8b4eb63ed2623140b9f56e02a0d14930ef1a6e2510acf7e6c5312509158b31ffc68c4f04a6fb182767186d1c9a66865408f61cbe923972919cfc8052775dd7788db25465458d626d16aa7728fdda5351237fd3780c66f2984f156c7eb3fe88b22d1e0fc53b06e758ff48fb2a3c3d23c2d447f678e3f2ba128398252f93c41220dce1cf604dd33757f282354e737324f62717d5b82419049d82bf008bdee92b8a63a0811de53e4b2f78ccc86af4bb2164c6817eaea3c927f02fe40a6314e17019236edeada3822e464481f56b7717c9a327497b1663ad7e6d42a863a2a68c065e6bc892bc5f8604b32309a801fbf57d786369fa363e0588819b0cca0e16127da2a1c2f96be724d85a23389e48d16cde5b60de25c88b5a7575c809121ca9ad6f4dc68d42309b608a493e97789a88005f45b2c1d5a8b21149f63e40ba959846611ec3f2445f2ce2601f02ee1840fdb559de758f487cc6c447a782cb7c1ed551aeaec9dc97417fb009be1c862cdaac2a586462249e287eaf19f438eabed9754eda4e422fd1518b5b98ffaac559b7043b8ec03d940f5e3c627137707a09583c1a96512027de14096f494f5fb7154d99e2bddbd118975ffc52d5000ca7014609fc3623f3e06c59222adeaf39631132ba042a8047ea6dda646865d030966b6c055b9ecfa8bc258d777ff16049e0dc580c20615c002fe8ee89a746968468ea9a2df31e2ae43849a1f6a6cbb043bf4fda015950a8ce11afb16ddc060df2d232817b18b1d637ec9656f15ec78a0c1be0d039450335a57aa12157967d4b6ac2ee6035c931ac8cb108102c1eb2592c656ed1d45f8140edd06954df75156ad41c5651f21ba840770f050d6e647281ce6c7648d76c4f2b15ceca92447a48edc48ccf1c863f0366590f9957115d2aead4ab21ddf5d7be97107932fee0b9069e1ea446a1f7c164c3b4981f57382a3b27fc3c13eb19518b46d19fa4e07c2bd77e6c3b1200aabfb2d92442f09476260f6dd1180b2fcbd5aa6ae2f2667648a9b07c743b5f0e572353cc1e74bedc760ff0245e7a3e3762f41477d11f2a447075099f5b46d0bd07508e198f53763012afc2a32a3aad0306983582f6608213616aa785da90a86d805b18de22184a2406f9b08cada819c6337e2d131baf47f2b0e8e9d90bade73b67faa2c1e82f2b014df798182696ef63415ff69b194efea50735b2d6b9b002fb7daf56e625218885125775bc86c4a74623c2b17d0f08994a5b9f76d732e71a07fff999f114a1a24f9e8de2283206ed45e9772198ece4bb737c321a9eb87266f05a19e19c1ef30a0144e1506232ac2ee5527b6dbcf1892118331e8563f1e4c2a46de241e8f3369f00ede450155a8cedfdc1316a710341185332829af92508d824cc6c84f5d6c79e037ffabfa3c9cf4af22e29343118be2a5fab7b727f33d2086f8bd30223a21a832fbf03194757c8aff8028e1ad1e67128ac3808744b31eaaa42451b2bf0965a69537891858c587d94126742032cfae7c73a6102303ef23d4f1e528db856c10405988d9729dac7a96d0ca49456e33429dba91fc1ea2b55feeacef5700499469f9d66840134b81a8b06bc2e6895b62890e2ac022b58218a55a2a62cd42fd183397d9d267dbd8000210354095d151136c02b0fef5b840fa930d2c89c2ab4bd5eb9c3f553cb52a8884eb71a7bba9293719605bff836482106094e60b934f5e9d753bf7bb3090e7877834b699f691206128cd1574785c571413da157c34aff32ed134a14500371b8f8f8e2ef78e831c1db1cc488928d648d15fda75510475c05925bfec8388937ff1fb0ba65545e29e66c1dc78ffa95d4b537bd7b0e9fd056ce8e59513a06a1af8a0bd0e7e57fbb1323be61d07c1a394a351c12f3560f88ffe95a686025175b4113cf8593f77e9be480a1d7064bcf5e4966e8f1f77bbc3bd8a7ca4f3374520531844cd1e736335ccb2ccab6ef7cea56a38a86d52f9af569d13ff7ce349eb47a0dc935a052b226b41197b44ea37af88613dcee76d45a837a9d229ddfdcd3ac002ec26bb6181913b13d9da45e5c32e12d1ad42bd7ba735de20fffc38d83eb1fb5438326eae6b2c482207e90e6ce62c3cbe4c8902c1c875848ac82490cf9c4e7fcfa8db5a45e62a02f4331c98aab7a9fddf6015f24f04d659af797d53096e307b54bde7354962edfebb72f871554d65b361acc4f87d9b5140043431a90abac1105cd5b16c493eae449749fbea9e84c7fda59113eaf6f201046a7fc432120489e5fe916b2d427816c41b2affb5bbfb790b95f252f0616818a66aa251accc07ac41182dd4b261d422dc55b23bc8131c8f3571e6514970977288be893b0396e0ca2040eac49260ea17169276ea763858b1d56d187b26c5c11bac9b959b219600615639ba4f9f8a5ffc95d5372271d884288036fa3414c34c94181a857242535ebf07c5a49d234a6dfc12d649929c5104369e5e2beb00b32f8dc1f8195bd64c110f3b584726152cdf938b673e0b0859152f88814666ede28beb0405c2d16d62cf599984c75a39193ca897c51d09e146ec1a59a59d88ea7d5ef3e144ef037a694c59a26b4804e1a9c7b9aff1d3e4e58606381f3e34c37e35e951cefa34158a3e2a823fd2bdc2fb9d5f7f706384f48d91be3cf0010e3b31674611c8f403bdab86179c8b78b6e60064c788e97952d585ed8c2568c76f304d57df1cafe6e85e4d790610cf4a8392340fe4bcfd4bb2c098bfe743b08cd83623ed1cbca6a55bf21a4b17c53c8dd0fdc79d744d70669fe8b055950ab24721a47444ec2e3ff678a7ac57753dfe5dcae6a7be5e64ccfb4e12c3162de782357b094a6375e08a1039a0c2f7871284318291f000b16a30e0280b1cbde4a313fcb9a0afe55635af5fd3a1f9f8b1290ece03906d676f127b7ab59e1a91c1bd7ae268dcf5f2c21dfb5125b99d7a1fc4d675d6f8a26cb27cc442e7a5cfa3e6f61eb80c5eb01368f214b5071b9b77aa1eb5774669924d0ceb73126d14bb3ab6dd5c9eb2acc7ef7ccc873bf3ea1e5f08b3fc8b0a46bf5430f448834d344b8b084c44f4c12994eebc86505eec65d110f605954a867a7ce18d44461aaadb94377b3499b52a040c4f3170ff553d1f4ca23ee74b2ac7224cd8e3b46a966a633bb58f18b5248b7db3cca1e2109b2bbfc6769059473aa587085596c324c9eb5876e357a03a506732d0a3947cce20d8a1e4de200d8d8134b4f2bb1cc5d595773b76de937138f06ce3fbb69ef6eb777760fed627cf13c91363ad58523883691741cff975a95ed14f770ce0aa0b6dca63a5d996ed3585e2b18c3dcb2bcb1ebbf7f64c88f0fa416c1a50927c301bbf925d90658fb75d6aa8b166444bbc93eaad8340b79845d232d68df0f8ecfdf79cb14c6b85798813474eb30249ba2cc79c51a6730236cfeb7105489c4974092fea4e26d633387b261ea70c581affe1f5ba77c6737b4a0cfd658cee2d720bb9a78339b3ea4438f469456b3089093d648cafbc94b55076922132b0be0671451a73565731950cfe8d92cd78f4dfaf9997b4d01b639eeb4713c6b8d2b8bf3c09a6dfa24857c25304fcae50aa654bf293efb0755662d48b78134e419e94077cd60ff2bd0f9954cbc422f494e70637ffaf88b4a12da2f0b4607a1435dfa57dee3be299adbbbf46c093cf04cf90f3ae0ed9859b6918424f83a437ce8cf9d3cc01c140af63c9864f861fe3a2df232dcc07699bc8833531493036cfb6557ffac5d2db70bac0bc529aa73e971e582fbf1145adec720505d420625385815f40e126a1326f6463df38a69e521927fa901c1341771c1dc6480531656d08866a7828f5d6b9b051b861ddbf48e5dcea00b25c65ef14ae8de9900e5f14fd23bb9756bbd8fa843c4d5c0400ef80f38b2e176d99809bca3278c061849f0017529c56e09e83ba030fa262cf3b77e452bff4fbdc01739fc21693befbd5012cabeb6ad5ed9e51502be29a3aff206a3a31fc75d813cc9af6960fe1df3de00a2720e1cc3c5ebe65efaeaff80d9acd3aa6cc227dfb1a603543b9cde5ef49b595393f0e12aefb3af6693840d89789f556b0f020a509d2117a28275fb9665ef44d1178c9ebb1e0f35933e4497dd8611fad6cdb403498b889a5f47cbe594cd533f5212c2c38949cb5eb192ebbba1a336ffacccf38aa7d0549e168a5d56857cabbba336b4f834e0ff488fb4e24115a0c947cb4c3866e2f8ae1896947ae5a6a00ecf3005278ff8150dd9038cb9681f10a44c57c47ededaf6de7a36a2e90e83d20183b3c208771dca484bc8bd0a375ec8f1178cbe53ff66c5921917071ad92301890c579f66fd02ff21f2a5869a2689c67c5b120332062f3a1116a855fd68b12fa0839b6f80c6fbaff1d1026dad3489de5914bdf462b3a86cda77211ee5bd7dde4db6137d8b6b2e52fb83daf9e1a2c17147996a7ed28f2b7fba6887e374817464c7f410346c6ca1f5193991ccdce9c19c431a7affb1882f57f004e0b2500c6f42464c45e18135b3c0e9294e43d5f170e70797040bb82c5c9fc7072adc02ede3fb94a3f1fc26b7142a4f630d9fd177fe15ca4a4c43593a8e44cc4c40cc5ae2c3ee6d17492a3b8a262ff3f8137afbf2fd4c99229fd832fe7c03462d694b3725a9e1279792a90be86421a01d599d1bfa3bf0df4b0ac207fd87c5fdb8443dfaf4fa6cdfffda1d0b3c0f1d2c17f12884711deaac573dbf91ef95e6b374b6bb6d847bde8957b141f9389979bf92a95bc3f67da7c4df678e8cbbcae328f8108a76101dc5865e80c9d37124063343b40092deacaf270a4a360d4ec6b4584e65154b2f5bf82d431959e8b0569aaf1fd3a8cdf7c3fee90e8e3ad38edc401338512805fc960779dfdca1958d0006dbd6beddefe53efd42d770d49f993b479116ba72ac10d6c88c26062855669811832feab55aa3fdf6a58aea88de4a7dc659a8a88051848b524308bb27e85fa930de6e36077ee978ef130c1831500d7c172620aa60cb442478793e4b9caca696672372d51663310ded68249b424d74e231f39b0ebd8813bc6ab514c596aa85301cfc0befbc588df5dc482ebddc22eebcbf63934d160d18374bd59149d503c2dcb980cb270556b5d7a74d66e8b08af1306ad7ab88e5725daae95ce11535abbf71cef9b0ffd5b0dda4c7e71a371282188617e91d9961b23b53ead980f1b5f4f12135e4abf8a482a672330442f9326fefc59ba6649d45687f6c9e449364c1f0b93198a424a9bb22723f58cc6948cb1dbf956d0e8a8a49135217005f803ffad20c9d6fb5c06f7d284f553e5b012c7b4bb6e8ad4a2bab20806977f81e94b8e99a238f9ba87ce473381befaa97f56853c7190be9ad54f07e8cd7ab74954d50a4a33fffa4f4dfb5d3277080b1cc75d5da678eb9d283d301162d452b638c09a097b107d9e4e80354bf00d9593ff6f191624da13cd15c05f21b6ff782948752677aeb401204b60dee088f8d31d54558b44d3428fae83704d1461db7112f52d5d58bee655430f5bc9363dbfcdb3770a551758b549e707c143b8f7d4c45345e05f29a85fa68c26cadd1793dda395d9bd5466520d48385b58bf87f2cf21f26af42a42b48c5e8067ac323eac47ca515b866da217f4b710804e783ea5812aa68a3d1fef91ae5d1000f512650ae8a7ac38fa25da729e4c6584352025e035a4be06020080f4a5a7b48df4a5a90d5df30aa26e0b9c879aa34e70b648697a8bbce9b8da3b108f4170663957285f24f4f234f9ed28ba96ade9772ea739f5ddee4b9c8cb140a79434d8e86b29d46859d023b17c64c930af21d36e3","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
