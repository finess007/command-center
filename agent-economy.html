<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"0e4f69b5965e9e7d405dc8f7f6955b9bb1fbb6502a91199e01ce68fc19c21aa14a031aa7e47b9df0d40d826a795f5e8674ce48310ce889e901d402f4f024f01c567f81cb458d1f38fae377b1eb880fce21919a0707da31cbc33124a5a9239f367f4ba47d39453d02201322c304c4d2f12ef2942e4d6e121907d1b8e7bba88985e2208180bc7ad958a43c44f5a4b2c361f999eecd5b461a940de394fc65561d5bc7601aeaa6decbf92a60aef99cb22ed91f0541c99ebbf4b11efab35730c3b8f04c3fd02ae285fa33bbdf6ac7c334d778fe72f4b927e3d8be68034f6b73e6e6457624d09d4736c56bb8071b71939fb4a9547266266e307d75ddcb96ce469588d2da9795223c7926af47f2b3fa619c289bfdde26496a6266e7413b7e1cd277b78e0d35d8ae38978270ca696c971abc0561817b0f2528ae8dd1114f7ee3c9095719b81c8422ef16d4c398ea1ec7c9838bf3ba8f9b0d65c84fb7fe5a0fdd43f67828d70355bfa0777384a59d2adcc72eaa59b27cd3a7842c0b0cb0ab97aa01fd5ef62169320497af0e5c5cf00ea573ba068997a8c1cfec097e51400b406f3a1cb7ef011e58a52163e658e565c991b133aa159d381127e18235865abbfdebf79eff2f2ae7e167d17a8f12bf7c223f60ba6d2a93f44b25cbb1b3c8b86e0f41bebe582d059de75f743be31f51481ccb1308779afc3ff3ff650d5fc7048ae0ba6eaad97ee44fe77d5de7ee6bd80ca1ed6e03a79da0720ed10c795b6a514f0fce4e6824e7add249cb8020ea2b6bb4e51f1b1becac4fcc87dc75355fdda3bd52f26fe4d99b7734433b5b99503780e2b0d37bd2779cba5a04f24813293edb6dc44db766b2144bc3aebb5dc39aa410608513f065cb1bda5ea942102e9168c9ffcc3af38b59cc3934799a82ee445c7e00213bd45280d21e77387dcd924a6fa7c399dd9678c426fd9b0c158716cecaa87b086af268a55f62f076f4cada68a65ff25c5eb0ad71db5b45a1f268d899c1a016870ea56e4bd5f5bc7d2626e2b93804b060badb6d6bf02eed86b3ff9a8299e9ec12b189856b7519f9381417e5049e257d432ba6c5e0d7aa0c6ba8c03abd4ef778e9d6e4cf6cdaa2ef24918b8ccce13ee2c4cdcf8d147eebb87e8febcc53397c72cb6feefd8a8b9da21ce1069359e57649061d91c04814b92e0bbee17112713b33afc5bc6206cf27f60a1aa470c7f548a1e9efe9a0bdcc81560a0dfed63067808797f30cf649ae0012d93474183c2c4c06ae42fe511cbdd8a9ef922ee302ab6a95d53e0809da279caec29d1c08fbd9ed0154f94c0c3d844b28c4bcd0b347f2093e565d9c2471a8bcfe951d396143e0c5d3235de17c0f9b747581d88cc93eb417ff80d24a8206ab5ec93b5b7f687e5438a8cdca6a0c8c0edf5af7aa722d52681f5286fe48b7211ee595ac9f00e6817caf9561bbe609e219932e12282fb50e51e5277950beefa275e3c25ff1bc4fa1fa2906ac116c2c56cef21bf8a9abd55c2b2ec814bac861c875fe99237d21c6a6067594a1c3ab915a6cb144919d5adcb4b2ca5ab93f239bae322aad1aeb52d926b27f53497656ce45125c08951268f3b718c5288dab18a28f018a160d26acc98ca34dfe7cf7362b98eaaddb1ec6a80625a85a88acde94c944ecb2d1e5dff614be7764f2b6808f1648a816c59561d469e6fccd50a2a4ea9bdba4d59f207fa2d03a24f14bbd9005cc2e0cdde3be579e4e7cd3cf0c0db46f9b8cc9d8331495384d93e104e32a7cfff6a735136e81aee5aa8260189762d7d1fb2d47a858183a12fcb6daadf295d3618020ee8c52a1fd0e846fb493f572be83464d07ce5d29480bc674a1583bb219f28e600813b26c9e2586740cba340aaebea98aafd50333cc4ddbcbdc8f6ceb1933f0c66c87b4c17a47bba316e95e6500214b44acfb3bb09c5ae6a635e8e1764829eed8b7033f33c6666322e6ca6d915a11d1075393b5ed648c19ae9e7c98be1c7feb9489a832a2708228bbba1d1e1910ea085306684e873604ce7592b352fd4d384428f6b892d8169c6da7bba5e4178ad9b8b8e499f5c5103842cbbf0b35a72b3c3f6ef2f01e0507c40ad30bfc492d3bf052370ea87294e889793378dabf6107903203f6918e692eeb0c9e41955bf40c37297a490a96c514d633a46db1cb0e3513166d791b93b6d16a7b8e20f3fdf67a9b2e2ffe1716044320db1661ae219cd8b5ec6d8047825a6e4bb00b20849a01041d95fa15958b9cde96861a32f235d978b4f357404291f145523db2b62132966801efa6a8d74c7943a1d550c3ab652657e33fb7dc72d26046693e2a6d4086a60f22514e89b2e2aa167bd20e20e331e88588dc35ace66144e0eee3d35510e5d935bea3e9c51f46723d3b13386fdfe1dc63d58523804f66925c872a74a45d6ffb922191374d7899e6c03c95370020e8ac1d2101be26ea31bbb06394b9a883bc966ebd629a69610e8d0b3b760bd63bb28c370240e880b739ccb0c83e570f8bee69e4506658fdb6a72e64da4448fe1701516bc9b3eb0d43d1ae7e93b248e2739af38f597d77e600239a4c7c4cfd6a68b533e51d8be5736ab7a81dd437f670c14afb3f802ea97a80039e629eab339dc538203e39a7ddb961aa745465c8e6b5d7770398b54140aaf8268cdf35d18348017723954b4b52e50020eedc86298e2292b410da4b69f454816a098dcc78b2eb9936d35d545b3106d06ed5671d3ea325adf22fa08171de08579649becc500babfc966a27b9ea389d3238d239757d0383c61b2211a237da66f522cb63750ac43a4dc213b9e8eb82bb99cd5a5fe5cfe80108a000fbf31013f91d9dff43953d6db93d51b983d94ee6ec69b77a4b17f086e895ebc8e9c45f6b7a03098a77cd569a98663cd07ff905c88f9bb9e3aba4724f26000f3c541ba77a14de56162f303decdeb63bb0271365d2c546675e758606e3b507d09223969947c426d20da3f1c0b9e1da5ae18b2786e37451400556549500b50550075a1252d896580e5adff1e3b88e902ac4dc89891b5dc1627fa7d1bdd2d403d8a13dba095a959670bf35079c38f7486c12ae82dffa9372122115740cad9fed71afbe7b30ec70c394735c6f000f9ba5ae5cb21007add81c604b31e6a95886be4fb491ad48b071afe2496d676e1cce395d241b576257b363896e3ae6035b532a80c2882fb768d53937456cc98628d270202c57d88303535d850eb41e76b2091885ab2720c09890bfb3ee5c8aa998b8c3044800e2c7d11f169b810d30d227dbf2154f7bde91de88227004d992e44778c137175d1aa28e0f5f1396aa672149e4b1bbdfcd5f22683e3922c0b939da2e3a69fe0139fedeafbe9f0c2f45cf88200fa0ad70d607c54e9e86dce79f214ecb743af4636859a3ac110f4e54520a3b13364622c2c97d286c2a601acade7be7672bda558acdd6bfab20161c2068fa3045e7b859a7c440791fd314cf4a734daff126a505f4a6c21e6c66806cbc6c29e16b3cfe4b8397d39a767debb76a7da9c1b5d4d7c643b6198d50b86f1083d62bcbd17227d821ba0d8a2e8706e9ace9bcca35454460bed22857c7279e0c298bcd4968592f9c47da2c965cdfb4d88e5e27e5b5e6742c2eb89cff43aee9c793ba0b6f520e91cc7b919cadfce1703ceda5ad5fbf1dcf4d7c334d0c034a8e73af51105e86139ddf37233c4684c0e8ca0b35cfb54bbc175778b1e9867a61f3ef3b4699be304c74705cb2a84c2c9aeae3630eb98097dab647ee150c2f7648a3267346707b3c62977a2ec3d6dd6c19353c9ec225b5a2b5762b8f0668fa0fd609d915574100387b8de70bebfb7221fe6bf75ebb4dfd59f17179eaa56eb7e22c56e19004a471da4cf07a19c686b8f82aab0473b27f67031e2899d0957d09164aea341385d416eb2a931a47b1302531968ccce112f5080f9190d3365798d9a14fc3834ffe9b9d568794440a1cf78c70139b2ec6626560ba13b64d8e337e7009afb49766612f3dda57b1c5dbdb2513b42d85b9c68b670fcc064130aabd5f455a6e5f4ae387a2921b41eee11a5e716f2a2920c259da7fed9d764e0b56338b19cddc4e9d8dd7810b841074d313245e1702297941f1b8ac1767cc66e2adc06969e05135dc43d04ff09594bcbb8f06337d839ac98c3831feccf3f6eab43c0859aff558ecea86c0b9d36c3cc6a8266244db022569ced88e50440ca15ed997fc6757325cab4ef1cee469c746f998959d926a3611ef72ccc3c68a85efc6198c07a72dc9c79744c49236a763fcdb54bb4b8a3c4b200f28ae57867d48fd20d40771d43b13e7a3044ce4b25db94c85bf593074b057dfd198bdd1dd59952f6600552ef318417bc852f2a24498aa710a99c120b1e6a90e5048d394bfe2edbeee2c0266768182d397eba827174561949166f9ad1ed1fb0ad8f9b1d18f90f47ef1989ea4442a8249d65684aaee9e7bea18b758f8a3e396b2a31ba85945064bd49feafb2ca60dadcc566bd9a1a2aaf8d78def9860d416ec98547acb116715838f2820428d06766404a3547eb96b42c7a8ee2bba6a92e4fef13f22347eab2198896dd16ae5176252fd7b3e8b912fcdf47b16e0122848a09c0b47c25bcb59fbd45ecb9c64e015441ee751c0d4827d04277cc70e7822229715dc322d0fe79f659b2674febf0af0aed2c56bc103f1845c3fd0b6af78c0ab054b1686287b77b0bb4157c18a29536999015d1f81ecf5a0c8403157dfbfa3c6fe13fada54c6e4a7a9c169f6dfdc4cbe572ff6c9c377b850e92ee0c468e38cbb595213120ca19fb2e536320414248fefd2c3ee0b6d10323f1371f6b2e10a6863ffa16a24ae6dda67f55c4ccb47e339b38a8370d877704f8f7e4518208a2ec60e9a311fa1c81e7da5813e7356dfbc10c0758dfb8546dbb756b25afe99a05f14a39b132cba87fa8de30c53fa663b030e2a8a6d20974d0b4d31bf6522fcfdcac359e590ef1c6f18d286692f748358900ce7275a16cfab76cf0ee68fba9c91683f7f78951b143c6501a3583e3f427dc39eb0353ed467466614ab2b879ba71e9fb491d0a208bd4eddb8d3cffb5722fe4158a99b14f4189cff49f1a11b17a64b17607ed6737b609a66153585bcd8453d7b33a032e5c65bd0da06801500aa2ce8905e380e8158c11ab731248de1e8fe5199d91a2809ef93d69b9eed9c67fa21cdd09865177eca71514c55018571e56462bd5d5776e46a857d936597c80c8399e82deb41c9fc95dc88865ba79675f5a1ef426a4e9cd8c520bddc989db76f4d6b9dffe3fc66d3e77ecd085d2f053cf6813767f40ea19c1d698c2174ecaec7226658ca2af99dc3b92d5b8490b1d0e23d03c27e0703a4c573b5a6f7a289c2cb658e6e7f4c683845a22c8eebae3993c1e3db886c9635972df6d98165912c3907befb98fef7e51bd86ed26b115cae1bc356841b7a2253c88cdcff6a2afa054556b5c156fbcdf797168106d21c665467c18c34b975dd0b1e6d2a8172e49b7e61746bb181846f63a43c803cde857e8d78c2289c87be8b9ce533a5cd2278d9c51926299017c86732c411ea84c30bf991ced37732c61155a40f859a12df5424b3fbcbb64fd306c87c454c28b09de41662232974debfc588dd0dd5c3c9c40ee96b24a5a87275f16b0ed5cdb8f700edd1e3eefba9c10a8a6f9767bdd3e166088107f677eb79123e6e9ed685bcb62b711c77b9e1ea149861d47fdc7a693447c29290e0d3afdbe841316b4e734dcdf9988040f5bedd0f80cce485a0a772130056f42c559067810ab170bfea0fba4b4fad0b245fac9620f47a49f49c3c035ff80f1929c6520e8ec956b7afb96a80d4d10e4b11b5af1f82775418b9dc730559d64e0af32278c0134c3673903772944d92da28f20dab5b4c3e6d819fa7f6da30d069505f82c779f936a3c4ecefdae7e2b947bdaaa225d75465b366b90e0ca72b72f8f031ee52ff935e4f7a8d01e76b946c3ff8cb40a82565374324cec09262c908c0cb056685e97008ff43f442ef19b4d7f6eca4c3b12c3f1a61c5366b5d5badc046b9136fb327b1a7d93a53199b762ced1f94c057ddad2fdc6732d4e7066e1a0680a3525f783b194bd6de3b72d5a3726f7dba68169f34e2f1e843ffec21baeb41831c1c49e952f47d213e8a65f5da83f110d7280dab5b259bef9d0ac813aab351110aaa56e76aafb2f28d642ce2c7fd151a3fd74dc8d93226d45786a90e89fb727c1699dd4695e33863eec505ba95f984169d886ca52ecd1a91ebe997b40096270a1ccd54f6a3c14c9ca1a474d4607bb8fd868d6e048560fbb6acad5d400ff87ad1e14fc9669fd1ce33cccc94dd988dd48fe2ba6e3f107d92bb0525b5e01841baf66d871f8491044cd7360b33e3f1fda1b6664cb25014754acf2866e0624e447b625b31d6a9ff85a024b99539d19dd7952e2d849027c2bcaa64079a29c439c7aae5c84fcd29f551a3112fc8b9a4e0caa192113cdbdc63b0b0106503f101c5b480ba6de1d814913343fa705fe9ee63a3f21d04cc3896a286af7768098e0b4aa3c158a60910381ee1993fb2c2e3ca8936d83bd0d314f0ce808dbf8578cfc8a5498da5b5dbbe8752d8dabe3e2246d513bbc9543fc220f38a7dbd37658631d85fce6bd60d485ddc1651541081c4e2ad444a7b5a320af64e2ca422da2d5f8fb9a9b114548dfbbc1089daa95f7c1c5516c28730296bf1879a70f69c6a8aaa818879a4fd727b0f8fa3df34ce95b51d122b38f821b580e0d24a219d8bb1833bb7928b76f9e7d03ec9086e6d72125f4833a1c2a744a3b2370d6ae14f7f637bfb68b7d697b38d737c7b5969aa799493b60486ed385a7d35549eebf1b4137cc9ac84cdbd314f4c2bf5df0ec3038e2b497ec8fd67e6d5b7808f74e21281256fc66947bd35d40dc360369f10a5b53d390799e9421774a26a3e8ecb7cf40d4cee783508a09e9bbee3c211b6ff272f08ba213433daf1bd4905b2e461496c2114f6f5ea860ff851454db2945a7f651c39ea6d0026c47b7ad16a005550d69b8cb20a81bd836e2222f4b38b5787f50b6bf48ed58a9dc461765f9f1c657f9c3154924e71c475817792d857eafc62fbd535b39654246af6039f679f6b38a196496245ecc0779f2a5f58701de8418e3a72ebb20b5030db998c463ca956b68c7f681ec1d5865bce1b785672b4d7ab3a5582caed1ac06fa2ae3ef5e2cc6558a2cee87748814b7496e0380b87a677c826964909e9efc71ff9fa3c8a9a81f5a95b03ffa11e2beea78770b92d2c09f68f2a6b4116c9ae2ed209e1157aa68a8c0ae04cd3c75182b190c90e8325bfaec5d67536f5db65aeb8393d4592f400dbda276f82cda7f36325c09edf04d417b1ea56068fe330a0d5c6ce96c8d9d1cd3c729f39d8c8a55e9466a9ce42d7d938cafea89012cf98b3be0eb5212b6917fff415f9161e5a48cebf4dd507cbde75bfe53954c86494101557847fe78258dbe4a1c6da4ff252ab80cfc7baf3d67d39ddfceae05b4ca37df14883b842550b12fc1f1c516521c25b651e3ced0237999e07a400e6232d37da3ea4ecb8d7f34ff113454e2684e404e5d5887b98fdcac2fb8e6d72b332a7d92376c33b2ce20a1da4a0edac4a234f21be09873936d094d6336d04c52e5077e4435c3385ff31306cccf9c5d9fd513b9ebb86bd05c4e0fa12172f8a70415ac4571f70e8f6b3bf93f0560b67076898aaffe0be6c12e6bf7eb76147a42f4d64ec8cf217f3eec449d179be768da4b3116d3122bb9da6781676ab77fe962775b0808548fd37f2bd7b8336336f720fdb3a8a577641668ce58766fa9872ec50322988584704713a1d52443725c5721c899e9565a9b29367700b4ea6138c20e26afe936ce65e9b28668bdbcd0ffdd2d1bee0fde698f9fe1667d43675fc02ae1f1cd1929a1c2852f10c39d8d200b0615f13b790a0fae4eaf66c0d2cae2f27deef80685ac60a8f5a39859ce85e2fd6a99123da073285a3ef2921b4db4e5d76f34356f993d18051f45687fa28b4b098c1b32a480b29a316438c535b4aa9c50632bb0c9956587caa5a9429e22d265f3c8d80324821dad9fe3ff032730ff0a96a04d29d4c84e1f6c036444be5f24951c88d447c6f83215a82d984688b9d8327c6590ee85fd0b72e06334609abdf9da7180780f1cdffc2ce3fea2b666d66c930f57e97c2c7a3d23bb24e4321d3ee5786d03e23f53f85e50d6e7c481c2b6450357b76a7ecb8dd12e8fe833f1cec3984ffde45703e570fbad7c0d530e7c51796e4fd3ed7787a55011837d4e677c6ec450c701931f4fbb23b80a08c0c4f52f06cf164211f591c36451b862bdd8e8189939c47b776a60a67e43252e4ebeceaa7352ae899d419093fd1762814d2b0047c787cf326a5efef8318b94080a04b4ffd0abc8cbbad3e8d8d1f7335dc9fc7a3ba6f85d3f92a4caeb7f9f2b714f10d43913726ac54a6439195b4feef19ecc8dd6160e9054b4597d092d4f4db8dca408f85db181c1aa7bee25be2997beeede9f7202106e78ca26ccdbc8951671063c96dce299798c0ee899ed2e08f2202723de3a6593c98d9e58b8257ae763bd334b1de26e70942dc7f45227079e75e03ae6a9493462253d53d207fef705ffa81302a25a39d5ea7b6d5c0117d615202f078a739631d6cbb62e1d2070aa6780d4b0408a3f7d58ed3a75e7b9f7d9927cdad23dbd5177e7873b806b0aefcc6c5c0381fc90dd8d593b952c131fe91194d45417993ecfb06298f8d23cb14823580c8b85043222d34c1869e891c06456112354b7f611ef653bc3832898f67672348170e00a8ef012de5c4c8c0def05177ce4945bc81c76c988335aa5bb7aae79ccd8b716c1487a98a13dbcc287642d4c1e026b3cbc0eaf25aa0010c31c07d751b087b3dfb1398db70e3c0494e7fc3c1e42069bca0a6c0b29cb783bac9ca1180b00ae7e14d965ae2d3ab54af26b9652d035cb6f80caa1ce0b52ee2a20574c6e50cf14b3cfb0cd674532e51dff7cf90305fd2033c24ccea0dadce502caacdcf972db70c92787a41775703b9bff3ad3a9b2f3c8d9e35c9c166d9d69e9fa3c0ea1eedcfa632b0791aca7a0a2a9d7ff7553c8057b040ce35f7c43db3152117de513785090c304165577f2b7be3b7b92740209be4616eb72c670b0f4c76577ded8939c10330c7625e35645e44e84c2e419652139b78b5d66fff8f9ac932ebea5a22e1b42009ed5db1ca08688f5dc3a8e04057ce35a9a1ee7bb8e1d3795fe5975a1823628ebf0e5bc6359bbdb135d567c2688bca44e2e6fb0a770fc2c7752ce81813d34ea19efcff05dfe23054cdf7fb6dc71e7d508497cfbf9408641045df71553b55a2798065e6900089abdce5ea7d452d2f7944a270ea7db555ccd5ee3e6d4b4c8d6ddaa1b032220c91f2fd53d7cd393a83210168164e22fee8cd50bc9193fe5d891e2be897e4285526719efd8b6a8fb96454a84570790e78d5a4edf2c8c5c4aca32db4f1161eca53f219e5d3b574accb53b1b387bcf8faf324b2fd4840cf1e6468a833df7647fe35736c9ef1d709ed724de3c704c0158d7b1395d48d4b99c040aa6b248d91c8ec96f5db7a1b31f5117dd70b314ba2e33718a7dc515fd312e6d3edb34af0cc6e4d88e819292c5f34729a9e616121cf5a8ab7382121b1d595e48b6b55783504a7c5f034b8fc3d1868a09820b24648b8160eb3126e7d51252c5e2e6edc7dbbb3ce7f0b65c142a496380f14f40968acd7fddec8e6ba8d09a230325d1d1d4acb36550c176db4e712c7b440d9b6fa5d773e8d59946353c0d41dd0d3a15eac0e6d97840494759e477abaa4cffcaf29e4e77c5d72cd7dac558d46bd6843c818ee501efeab391d19a991d157d5a058e2dabcf39828483e51bdd46593d44bfead1d141d56197a69b76a91897253bde147862edbf1f46956ab7b2a280847c5b14c2192c2f4f6ba30dc2ea60463bb66df493c2e2556c7c3b2dae31f4d5d42c03ac1b6c3dd084edfd128ff291881a2f31c1249c4b35f61041b3e463281ad961fa285d69da17757485c7a20e96d36fb9c1bec1cda81f5cff0f35e8de5b8a662f4e8d20bca0853dd5f38aeb110af670c2310f4fac517eed8982ca69d27656b72b9acc53640b7a010f376b689e940526c15d55bc8ed86e464b49beec6b9995ee159030f86fd791142d0443404452ffc90a1246327fdcc5f2c937d11d6898e2b1b0c8d2f219c8533ff04266f3a1c26a17bba7d2a0864c8e01049c66c4e86c46960cf5d2e6b64272b6e9abfe75fa180402f3ba9b72c4521538c1d6b81ad92e2ce790b13fa8fed2b22d30444a0f8308688bca5bd69691d5263a3dad8937a590111a65162361ba9cd20553438b4824a28784032cb36eda9e4b67c5840f2120b7d975f98d387b2dd8ff32cd0b3956e4aa1c4221938924ca6d5764ab21266ac85cd385b605622496aa595104461df3fbcddbd99b86a43709c1e0402ee1097e6375268cfd7994cf0410478e04f16fc7d75421e5f76f0d6eaa17a1e3f7950ba93d1922ec5b2632f779d8c8eb16def731a050675d9fdf489cca67d59ebdba719a8c45e354b5df5e96d57cdf687e87fbfd44702f9a095fc95cb71852c36b74342ad61a4ad4005abc8090e09ae07269359a1460ff69f047bf00d7f834466bed5ec2b4fe0e002b142be77c56167bb50271ccea68fab94ae520937ba50dfa876a07562daaa046ad9f2f8e7f580d0c7aa4765332c077ae29093ead74f23f2f1f8c3d3ac8ba693f4889856242f7c549f8fe45385db3e30e19b4457e4dc851f2f2b284d495671f88660a022746a97234189034f1db1c0c5b1ecf8ce00e928797de51cf1a0c7ae2f2a9e0c1a86783764b9e5b7f32498be456e3e6553c865e08ba1da2a4ea156d6d68e5eed3d27175877a35f635e32c04f5def1c80a3f1292e220581ac4368c3c53da51330696f7f09ab97e9e3279d90558bdd410d1b6c96dd904a65a02b62baf26db7054701d7ea19471141fef598f91deea5b4e675922dc5be1494597ea3be659ee4e0ff2e68c02a80d20aceae21ee1af99243ee463b310d2625eabdab0d0d9f9832f86275e6f84efa4aa968623a808f50c8adc91d506874800ba3060dc636002d40f24367596976e2d73c0523cee0700458a439da0b0640b0e95f73f7aad0afe118edcc8fad7381eea6b000dfb50f82e8ee94c748f15ef3ba977c795de5ca9448101ac64b936865d0a9aa44b7240a5b4bd26b6f09de12618356bd5bbe2c992f647e5222b182103948618fdee72cec795ef9885238cd72cca3eb1a14eff98c5604de033e4b3459565b13f5009d08d49c3fb811d528db7f8bac6ec778f698e5163f4854e42fca2a97a4eb89713b1acaf882855789c1840c66db1fcb23c890813c9aae1e84a1de7a50760249cb2e1e77ad597d08232e18998e4da6cc70ba95e110cb959f119fa3f13c45a3d6bed220bf1579ad3edae5d52f6c3581bd918633dc1c49f8a65c167dc1e800f9531ad1a54b777ba3f836f2fa340e0884631bb13fc0d3d9e03aed4407a9c5e36bd16622d2dc6a533b906a9cc2968efdc6f365858d743753af88746910418a2f5a708be243743892c4a93c673dbd30d27511ba609d67b1a3e783f49972f253f561e21e8eafac228328227b8f31b8045c9867c86c6f4211bb45397f747cacaef4316e23d5c72cf0ace677b04607d8123af9ab7ebfa53ad8a6b8a05ef2ddf6e7a09cec75cde638ea5ed59b632c45d6726f21902a3cb48e7ae7a1ea67af91ef714fac24cdc164d79ab30438754c5be63dd5dd30e2d7d8fb5eae73832df08160a623610650820eec0476ec951e60f9c4d90de7da3e316c4c7632567274ff7379b3de2f1bfc0cdec7bb938887ff4586aa4bf51dffc1f146c09fd54c533590e7f8b5b709f5a0e656fb59ff57b97459d5febe7d575c3d2d9b890dae593fb5b8b29f83e9eccc4fb6145c00b42b7c0a05b095e27a8c863ada987661610b8ce3ed95db82b5c6f635556dcffd050550146135e0f6f8960eee64f0237620c69ac686224a246508665bd6998f1c4f7049d9e557039db3db5ae2c95143c0c81a29c9dc8cebfcc3175f9fd1544bb8e7bc17f9573758bb1bde9d965ea550c40fc300b5cd207f67ce1e2994871d853662022af2d9ce714f4fabfeedc677cdc6695f32c36013b699c18589856b59ee3ef6d4e4501b81cd51c3bea20c8737f447688d07514920fddc0ffe90d3e4b42e086591908daa1b2ae77e66b271868d45cfbc4875cc04b0251eef136fbd5299c5cdf3057bf16260b48ef8a4a4fe3c505ae81379c6bac047aa31e224c66391c70aa3e277e3edbe56164dbed66c47212b2eabe8c2e8bb24981b31835d21d30b29e37dda3cd58c5bdebf7a9bb15abc3589e07f375b3aae3c9f5ec6e69525334175b2a6f61135dc2bb351e139392161212d144f3e8c8d7c76a0d397a004dae0fcecc4993f3367daec316125dc167b44eba4c1be64f55f3de9cb381cefe4e1fd07a258ef7cedd72811f81e8bccd8b07573224929cdf88a86b25fc3272c2d085f0f80ef6f07788e68d5114c3a6b0cd4909ddb19bdc6ab37b67eece7c290fd7a3ebe07ad58b24dacbfd613a6f22b13c2776d1cfc2409c5c434afa76ca4b772443790a5929fc43c77bdfe234a908a273aa0245c77c025c7a8e8a7f23d8a3b0bed38cb0fbd9245f020ff644e2070965f1d29509cc7606987adf9cf73c218d5b205619d3f94030af3ad7a949ca8ba957b48ae51f1eaecb565939ae8d536fa64c51b5848c8ce48fa38be441e66f63445799dad4b13836e603d0cc51882691bc08690e82921fea309e9f550814d0686458f827382d850a743dc108c82212c0f485bc6e4aa6e9592701d9078c5b72eed3d3bc436eff4213943ab532f247943b8a698be1f36512afd6378e1017b7de9ef6430386f9d70668750666020b4fb7a8d646a15308599f2217253ec5e5331875e75697b07ea1a34aec8f45062b59ef8c7f6cb0f2f198935661d139e9e42d74c57cc8043491f74a6b67ac7d5b5026c48c64303e5d5c5fabd408a3f266f9048844debc6a39e08f0d2b3dd906544fbbe209895b8e06ae28006db109fc5a46bf2cbf6786928705183de31a1fcbe2e5e3fd9eac3b5b5e9281e747b2c2db1a65b37ab5c221bf466685752aa10de978e8471a3384fdb1b01e537b660c707567d0a2734590becd711fc4126acb8b9bffcbd9f58fc0958348be11782856ef6c0a63f775ccdd8bf48839e5d17ca2b15abd5e7b32b6c46ad083ccd814b262dcf41625045cf388c60b2bb42526387de4477d1c6ec442623e2b66685d1a1ddd3911d7b33316750a0e0bfbe73a030d530d218097fcbf08aa959c68b4ee30903eb6b588cdffbe04ce42645fc5b92b53a0a57d5b04ca3abe5d5b62c2706bcceded39a91ead3e4de7ef15eddccc96729de13efd5dea778cee1de8b0132506e631515932c9ef05b3aee7bfce0887affd591d77065b32600c64dfca468ddc5b0b8e0c5b11f8a1b6a53f92428195cfd1eca8cd506b4db513092df7203d8b947c20a9c3822dc36fc8578f37dc4086c1ab18852ca3ecd6eafa0f5501d527d2081cf1c37fcbb80b566dd3fdf31c474cdeb7ec0ba8e8b9f64b02ab5a2e0de14a8577f91d2246c4f44bf034a715c4e8b000459ab32a08b6a4d902e5aa69118648a52598726a1b9ed625523a20d5c0011ab6589bd87ffd6141b4c1c82a7a41805ea570782a6dc2d4d444bb14c829f5d8ce54e0969d377363389a61fc96eafbee04125c93c176ae615e97e8e61759c3ad423a2eba6bed1e3dc6c58a52e9cf8be06347f734633ab6f21eee18d972b28d94c6e388ada50d45f190897c9a3a7e51c7bba22e13325c52c23f3aea8db29e9dfb4534a7f60bcfeec9af556168cef43b5740b2d71a63b7d975542faaf672516d72e03528faf3dd6a89af53b6dc69b6bae001d8a2b94ca3846077e86364a74dea44337df06307413d1b0ff4d038320d169618ff71bb65e7a78e4dde40e6ba54a115ff876bd8897d39aeedb2af8e976b75b36c2a4b64bc2fcf3387d40cd8b9575457006310989a015e0da707ea5794e8658aaa609eb3aa05901ae447774d6f4e71c4299be02db7a86469a5d8a108f9f84877e0d3e6b60081b6dd943c69b7ec4edcbaff9027f1f2a7a53e8ae364e7804b01fd860cae60915297b8e791903b48e8389a3f66ee581c9f48e0316d1bfff669553cb47b1d1507ef507c8211d7c9fc5c87e254b2c1d39bdd7d5c67dc74609a5472c3de8f315f98a3b4b473bf421c2a76712b0fb7ee76570587aa47d633ac50257310e04de3de163308eb11b0f9c61d4982d6539315aa5fd43e85c104005bc457a3e244468f6cc0e2a060b76097c907d87f1e3e440f05d179ae907b83e3e4ddbe39cb6faeb8b69ea179d4c572bc3481a99cd4e5bef1bc20f93d9cc28f61abcdfca86bee1816861c5ec686750f027da7b861d2cd2dcd2d1f4a468dbc5e2c043f6d841ca3be0c1786db7d6ba16f370395a368ef51b852c86977e50a1e271e9f41e2a8815a70fdfdc9b0470fb6f4d8d63789e413b62a876e659e9854757a34baf77f3a1882db48d2537a35ca2f44858c850a4c3e972c5e2a3f8759547d388a5deb2dbfc105ae1e7a3a764f7a1b1e153e55f40889aad4a5c41e3898615d73c6ad377b7afea2d73ea04bc855656e59079deab36e03e8b1919c6733a714a6b83e064fb3025a50a6c33ccab1715a1b83d936a0fb424c172749b22f11d41d95dd9ebebb30a8a89c8bc3831620051c90935b1bbf07d2415c72f9af874db4ddee7689820409c79ff1a413c096a00a210c0b49d5a697e89a3f64853cdd162bb84efc69ca2f30552f54949d9cbaaf749b6ee9cbc9d9fab9f24110e919cc4240cebe37979e5223869183698e0b94473dde6a8ffa03528a955e40c2fa2a5e3f6adb1cec93c735be3c963663d91e9378993892ba67ac67b69cf4e2fded22fc2def737082a75a906532b8e305a93ed179552799d6ca1a48d5b8bc1abcc5d9121fda784ff1062b2f9e130bd352fbea0f15d08f0fe12d8667c3317e90d13953a89fd07fd23d932f3b68f6b432acf0a2201924d4917c6bf0c889b48268c9a43fa5bd0eaba66629307ab654cd578c40e6a2a43a8f32340af00e42e2bd0af84481da66d92e5a48f0c8fa102ddbdcf0578704f6809f669a1c7bf08b0e02af10c0857e5bfd0676544eb7e89023a1d2c1e5a5c624ad345d67a6df246d9f49f5b39d87628c6a7d2b9a482d171898d4af90e0eb6a636638b0960454b1b7086ccc567ce1f5ca02216e22a44ac75bd2e096230bbab0743e1281275e5b9dcf9e091ca83205ee9eb1e1671d63c53b0123dc1deed8bf32ad606cf8a1302109efea6bb7df3207861e212dbc294f52653738ee5cbfdfeb5d6262e7292d1de8d714356801d804c6e502d7d41b817b6e923a56f5e673ddcbf8940c74efccb652816f462b20de76e1b51092483c99ab308269fc5d83c20e4f8afe4daf01383082728ea0f9acd8e4c2425da29b8bc4a5287102ab188f5017b0ea20c37188e820b4948bb6a0187ea65fc0c430d2f6352b7b14296445a73440e0df705cb9d06a41ea6053ac963cc358eadbc0bc3cc248dfaf3b6ca32f50fb25d6da15394f23d9990d8442d9244bfcee0a6b08b1821d8f64fea05f6bf875b3cd3b1397e296a8d68c1d41ca504fc3341168efee4aef5314a80aee8bbc086c9f9b1c799bb373131e9ac42afc566d26332a5366eb5660c64ce744a11230f15c83764270bf4f641e09d79570e0203676b605b35fafc7c1bc10586c58de89f80cab51ec3e6e1b74d94bc00eff6d76d40487d31753466664de069e5e9273fc5411012b8c7f204c316994b30df21108896f455d08ce8c781b40a7f02f6a61a711e2a825f7dbad2afca805f5afde40f50b029ba8708b9fcc762918f891b1798a907bd98bb4fb159387cd57cd93b4fa7af43612c821384a05b3ab0582333a586ebff6775","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
