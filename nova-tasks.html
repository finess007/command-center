<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5c819b4be2e4c1731147753fd31014f0d912f04cbfb2d92087ba2c7aa9359304903b0be4749f8460226665b583f61c56eedc035e5df81eb77581039e283ec3a8821ae317d14f20cd2d0f8953768fd52d2dc6f2ad8e60c995535d5300fb6bffac65be9761101c8d84a0eaa4c4cd55b78df3b30c17c0cbfabff3820d6323974e136d886919a9fa1648122ca0bf7e937997d8c9aab17018d6a537beb89f6461f380b6e984dc44a3e23bba93bd429e0e56673ea0c273dd1ed4fe9611e6a1242c62b33d8314940868dff9e82f970349f885482d22a5c49c5557fcf089368dc4a123a2c40b728d3868813e29b9570f01fd95057de62f4773c2353339b5f303c02194ac236c0a029c9b2efe0e78523680ba2833f8608c2d0fe801ace77e14e4bc09ab5fe6c2af3fdac38d828aec69327c0239965b4ae4e31a5be295dfc243b7fcf3264bbeb114c587d47f743601682ea3fa9dea8b095d83936501e4c1261d6b65d86899b2562bc56a92c1dbeef70eaadf1d7affd73774ecd5814199deb05ebff7593218696319dca5be02c64e5140c304cb3effb0aff0fd3eb842152d6eef57ad338e0694630690cf4f24c18f0bdc5a62767201436acfddfa9e809caa60718f6ed31240d895d8cb5054f93d68579873221e68804fbc71468f9e7da8795052b4c5206c3f74ee9d06d2d37393c03260a1e16715a54531b9ef31652f725777093458292c125406b951d2ca82381b751a73d561e0301d43a6a3cfa0e33615bc48e98c3c89ce2249c202caca3f4bc5cba66dd464df43b542d4eab5308063ebe2bb4918f0f60aa3dcebe92a83f22c786d455df9f93844fe7f17d8ccf2aa747d670f074a3c44159e1922fd6ac083277358067bd1f5de29196ec2462a22d3d0efaa3452b2a7c3d1b05da9237faef50ef5b9681e6a93bb1a0ca276dcd1e33bd6c355f4db5ebbc7f3a7bd94ee0d4c74652b2bc17e7a7f46b1af162e19a1e36e13ad3517f3101c43708a5e1d68cf9aaf40a90e1122c08028c37440a682d4d6de77685bd9e4f72344a71904b01e2ac798416edb595b365dacfb5292df4a07b3132bce4501c0dcf9ab6ca588e8a2bbfb250d08523e03cf9e8cca3d114b21b735095f503d9e3f59ae6ffed6a9862e994f546cb02c335ed58c89041cbb3b2533d9a10c03e642a09f14f21c54460b11a431090baac99a5e5af96fc7c83cb70aa9ef0c73c3b94a411352de7b510ced73197432c06b0cc232c32aa5fc04afa52ffcb265b53bbd9279f96a24f4d9a1faa47eaabe8d094729c1e86013cc1bc64d5dc42dff476a44fea1029b8b0c59f99bd88946d27040744207bc18bed9c383af59f4d1eeca368e85d0c8ab580ffcccf6b1197cde5f55033dfac8e03bd925aab5d12abed0ef6d89d254198f861be82b0f73010b1dcd596acd139987ecac0408a4fadfab0d8c0703167c63b9767b49584eb5dcf9698aff919a039bf369bb549e322a8764bac118d264b8ab4ed1ce4fbbbb2df62817524a14e93ab9bc50a333bb4328eee26b94c8a2a1a64a5df0ef57248267611e1db69833b81d4cb2d438e29d0357d7a81ca88d4dc838f1fc32d9fb32086c649ba12f4f07c6fbf79e6f4f19b9492e740c865894467d7272c2c8f82d60ae7ad4681ed744649b7e532f89c321d57df31cb69b000877194ec389a7b069ba97381a78a9e3784971e35102f617094f014727a2f54177a7229a9117ffb933733c846b0c7286ae56ba7ce3944ad3911d96affcbbb2eb5af061538552233c1d6d2ee935c6c1277a5a6d8167dcb8ef18a1672c092922a1d616304f4df0941c2e496ea408059f56136e5b665771361207818a57939d6a486723961d4966ccf63a22fc1e10c592e84c34cd280801f4f94bb12dd7ed38f249c35b3d17a1b3cf0937b753c469d2a3ed47b20f04ce373de9d239ba5177cfa27be685b5ab460a5d15d1e4bde4cdc034e86135a9065de626af89e772363abeac18a564ffcc4da9ef18334c718bd2f60d78554182f46e416449c78591a78a10a737a9351e2a60e643836685938fedfaba3145c5487a2f50977c59ea87318300f0132125242f51c46c3342b8f23b3f2f89030d5c8bafeb339af8f56868d7bcbc8dca63ffb8483213c44f1db9b431d86ab5e562fec4b4d0a75aca2b7ef48c00b40b3155744ded449f6835969f0d44568803a068cfd92cb5595de6e0806e5df45aa4538d72a9a45f41845ff03e3588bd8e85c0e1c034c3492aa503e3d13d0c4696d05027fb85ac6dfaa0fa5dd522326d555ee35e0763d1ca508dbf34446ae90e40ae7473ae13d5a19e8c09af46acf58950adb52bf3dc83dc13733c6415b325ac495964028a99934e6bc5519e11bfaf8619fac1d6ea4c476124ee77892fd6285233e2d9dfb384e0ebdd31515c31fcce1753497934e3c6fd70a68e539645530e2c6b944c1d44926b2ea148bf37fba4489d56c02832f470f7e58a459551393fa82acb6204e375f1ba1d60157a83fd430ca9777f5043fde12cd432fd0b974f9d9d7253c81da0a87e3c7955460d05389b6de927b3084b3a42f18f757df6d1e8d9b544911e948ac0fa89e2e6f742204d320a4826b4f1be25b9f3c834ca55e87a722d31448c577b9cefc33fe89670fded1bcca1b00b7e9be9694340a51739e59f33c4ec43685231d2409f634fe5dfcc626be103df1579a528476ca17f381300c602961e1a5564358e93ef8d2536e46d3eff54fc18b9cb33ce6a197eaf931bd9b281d23c9f306440682bf5242a45d7ca9dfd30a07131a4695cb2464f34f8ae7933878cfb82950f39182e1a30c7289063c06e7f95f7222c291593d5ab7dd5c41cf9d6571f2d75c18f7fc2fb1bc40490020a5f621539f9d73db13a001847710e2826f261949d46846010258949d590dc8d899f0aa18d799e6d35e9f0045f5075e76b2e40d0f67d0352e6e38ac2dffd8bf4a3f3425e12afc779a3b3197c1f3d8d7b2fdb094c0031c9e367c80f45ac0e71d258ea977219a8510e0535007dbd48863e15b4465c028bfbd4340329a284b5cba7689f06861574e1e417dfb55d33e8a0fda6748384a99786aed9ddf43e01d1a98ff256ed8abbf4eb7774b8b722fe5d3ced9ad80fbbd142436c88f692ee748edecb84dbbdd8a63ae0b1089778743c58ac404c6c14eaa094292e191479bf4e3a6f6e86201f7a723a625f5ff769a8a6125c1b301cc0555648a06a7005f1f69c001b9eaed91e39c86ea9b9847d40153a898845488abd07e61622775cd5917764701afca962301ec199bcd97c7b5bd47d9be2740d06d4aaa58da59358f1246a30200971e738cf177a1b10b7d32104d9200986ae93c5b25f60895b0851363b541cbe93414775f39692625904ecbf1c5306bba6bc59459c203bce0d92e6de6a756a0042205dbf8c2204da59a3a9f38d120a05b47876c4cf5827e11174aaf63dda65cd0b6446351241a457488ef9c27fc04b4b650141aee8091383b0d231a82e4d41587d2b72e664f1999d81bdc479a9ee444a2aef21d024fd30f7e79e959bc5bd381ec1990f7a23253e60d7238e8191969525fd339814172e7bdb74970f8ab2993ba98454e000449de4c42fb57e45fe362395a0462bf9ec574e191e60690188f461577d46f3ca2593e1160425b28cc90990fa0d3bf0c319d4e643e56aef152de35ecff50f3699e47afff9d0f14dcb1e2694394d6fa534fcf886e262f96a6f53f2d158f2f7e62d06a7761b9ae9d499cd9968a2b4830fa6c0a960324759a75af19d5750ec4c967d4b3636642786c265204be30dee549fb618f445e03fafb5b290cb82def87ce4851cedd6930db8da9b15aff26d9a7cca899b34d6c643384ce9688bb8726076a7ca61801040a50b5e78d6ee7e63f32d901a7356988af87952048edd9f4f3fd75573801048615608471f6e57b5f124271a426570b477d13c3c368651ec14b79566abb092d926084df0fbbbd4cc56906e9b18dbe9c437d7e35c5cf489291007cb76331e0f51e6ac9de1df12927817c23d47372171dcb5faf46fe54c529402d8807998be03d42cf27e91302bf5f45f050c384cdae748a97e693772563967cd7c8602ac4f94f87503ea347ef30a67c213038b6cf2dca1f09b0f2122381b549ac42ad4407a58f74651c88b4bebbf9c0fa84b33e8dec0a615d9c44cf860769cc998380540c27b39a8cffd0675794ae1fb543ec33bd37bb1125f023949e2bc77079d36b45865dfe6a118055d5fc4309f4ad596ca1afa42a5aa468b0deadf722635141ac72ebbfca859630641c64cbf6b545d6ace204c441ea7094d20489e7ecdfb42cff08e00483bb4ad7534d72c6a69b76cf2df1973132aea3c45b4c1e25b852000a821c71fe06ddedb2f580bf2359ba7b713bb1dac828b901237e857bffd9870ae3d3d401dd3da18a6daf8bf5e96ebfecff2f156e7f135e2ab491884fef20e50bf2a0b6353eb0fa3f1678288b9649f4062651930d93479d0d7bb1ac7d43763a59658b27beb119d05ce01048a5e1c259b9f2959d26228f4ce7af03ff252c11523f52ddf8f5512a9775d6467bd9eecb60234d68588f89e76e3cb8d77dac6acba2cf2c0620aec12af03546f6c22786bfaf21b0455577994cd5f8ee29a6d945fccd81871aac82b6749571057104f9e824a1ea9ef213506372f4a3369ddc02ad551fbc20730bd43f8cb7b3535dde072e69949e63dc1233c4c64d17cdccfc320b867d76188ff9907011232c33354663d1fd8d3d25d0a7f486a751f75c04b6b3ddf439b13b659201b13f5f8db1c9b9fab1e9387549f4c683b9f4f185a74d7c4297278fca0daf700d76a42c1f5bf35312483c7ba1fd5c5b0132c636c83d0a3db61b4c7165a69290dc7ac2a8b06b7a68df461c73faf011f02d60f636ccf4c84a3cecd2e7964426e0683f73b8bbffc0b901ef18cb059d7c5ca2662cba45f427a3e1b3f9653d440f63f06072b2bec9ed2886895e75f942ebe1a12cd7b0676fd72cf377a3a2ede111efccd23e5a316d0e7769f8bae0282e137325267cc1c542c26f8e88a8ccbb2c3495434025538bd821a1346cec09a4463099d6ae0b19f91d574970f26d0917ecf6ba82dec85e17991bacf1ff0db9cc119ef7a1710f033d9164f4676941aa74d5de1eb815a57fbd1d110e86d02fe419bd4fd19cba7a696dfa92c07d67d14c2ece1bdb216588878bf790a30cf6fa418d3a5475ac66d77ffa79596660e12d0002a1d3700b05db4976e6cc13cb1b9f31df2d74e7edd3777e7944520f366acce2e1218e6501673613f52295b8f1c164759e77bb140e9519fd90dff4b10fe03e3e4dd10a3013c17869525067a1d2aa789efafa45c0d377d793284448c891a5f28b0985f1148b96b2f85dd1e5cba1ce114c208c293df2d973a1cae93ddd8004f7a4e6575fd82da76fa72efedd021bc1cd7964421c0950e86d900a511f071cf461a0309ace945895d4fdcdb321a0bb09c9e7584eabd28ae857510dc4271c39ab69f2c3e23602ef3aa4917edb0295a70d9fb20fc95e584090df387351b9aea3b2406efe9f8084f3558f07ea15b757700890c36faadfe97a94ff59fb85c0b9f3daaec3f7d53bdfb953bf1dc6bee07aa27fbb412da3a5d1399f76c2cf35c72e914ec368af4cbb19a120441df24d8370738b73b172dd3f58a4343bc70fe9b2706a4317584a5f7697f3f125797b01765955a5744d32481ff0909f8842ff18d27f47c0c878e9f77cf7a483546b18982827a583d1f9d6e3be0351207b0743c67032a0234f44b503dc997c7adcb95a737805172d49e083ca476441e2d4e8dcbc4929e0e87533fcaaed987a91aa505b2b53af03bfa8ef9cc3415d373837fe4fa4cd70d192d8fa42ef9d4d6d887379d1e9f0df89522aa74529e9c9a9e0956653665429dae2b838482584d490eee64b94b809ac132f2eec3d1f087ca0500325f112783598431bf29418a13e1707cc2e06a8f19232620364e3f69bc0965598ccc2209f77afd17656ad814da9856ef2360d3f52adeb9dbe629620132189b7f0b85ad47ef773f2aecd1f65217e4649a481cc25d6557ed53f1fdef30a3cee93195ae1f5f71ee657590af75f9325a360f23adf6587792eeb899e4a235539cd2cf4199d2cfbcd1320483c1f2e324f8964739a23814499de3bcb55278fb96e1c29047ecce9325da9053147b82e0341c2d48a1eabdbf05b4ac71db1da85a7608f55b6099466b3ae6052f26c8d30504d5c4aecef3c0bf8d76dd49b43536eaea0f45a7aa7f8fff50f66f6537f2408f144eb275a6341476b6c338c2c1721a27c7c63712fe59f8d280ca96d101c27f1c5eab5ef3b93b231bd0f5e7abd2451769a0c33580a425dc5db2848930168be33c3b0c1622f93e074f10eb56b3dd98c1fc163ee82c3b0b2821c39d3c65399179f1ddf1d145f516e261ece6d0455b6a7d6333dd0df4efdea358a57470c29aa626389ce389cd642ad18f1b0f19a05aa49e0760188ffb9826103fee99b1fb414b0101fe64edaf084240974e673e40abde36c7910eb82187e768cdbefb7001ccee0367ab7421367d113daf9c5d7195e0c8cda9cddbccde6e0ede94b662c66f270dddb1b84db007e3df26020d65c5e359f829ea3a0eab55adabb76669ef1a8303528387f53682dc5e616613e385eea3628da6b51bd3912c004d7b66088418e8bd77ad44f21710d87e2d0238d84000e7c131f7d897e21db86e2e11886b5546f3153ee4c31b8c3f8e95a0fa0ec7b6112cd90a1b407eeedc934579ff137a3430c933cd639995555d520f411cfe8d61a6fd293e8f0d2d6ca99d28933075f03e0ea72fd25db67440e6fc9773c9cdde12e4ff92dffbc2d12ad699b002f7310e8b9427a7166b4fd2a8d63b7f58bf6638c0ca978ce089fcd59632872e16bd99afcfadb18e52a0e27707c683973c0e2425f91961ee059e4ce1d419f449b437117cde69eb72be9e54bc43656f7955937343970cdef5035c28c8bb060bbc8391a112ec4c8fbbfe676c0fc9404aeb85047d68c4b156b5181a3bdab456fa9a1a4eff8be1e811675a383ddd8860f5deee20759edafa3379ea91131a3f8177625225a6c82a0e085cba3f273ff11c84188d55f7e1b3ab6f3c8a90a5aba04b279b903efa39e67005f92cd62d150c47cb49ec4a6431255af62ad85a4d252d1ccf46a9745e5787727f41e8d140eb1bf70bcbc2e52b6e3820e84481a8126b391ef1bfd62042cd9857ceba9d024e550e949312223112f065e537bf0efa16a075cece394c6e5041566f37c054c11f6a503b1633c459cf0203fd56b7fef58b4819b0aebca42a0d38685d89784a3b57563117f400a0cb2b8e4d2efdd25ecec5c2aa64dff9133baa8216ba783fda51ca9d692f64af09ea5e30047deea363dcc7a86bcff0d16109f3249d43941cb90e1a5c5db9d33d6f7c1a9309a4e99893f4b15c9e04243ff691cb6398f012baaa7c8fac6d03fa95e47be7b3ef1be6db68e7077bd9b700562898f41f88f6e850ea7c77cd0aed25d53f0f8ad04091c978b0a2fcffc4d845d06a59777b15ed8c1442a9330b751ca38a04696b1b5036b0bb03c934b2c65d3a6075544f703a9a920653471fddecf222a73d3a8f85980c075f373a74055937ab71ab914b862c759ee791c4efaa58a10a33dfe3fb039700616bf485980a0414acba20c19d5a13b9aa3c382c7127320f6a97841558535055baa07bd99014256cf6208db565b3fbb2dff8f5835772811f45c30ce8ac6fac57e1b598580e107e3e7c7d552be653d9df8aa145beea62a66c9a7a209f45bb81036a57f833f1fe4afd8fe91a2cac57fb5727e87533c39da017d8c08ae5a3529e4ab40be20da33b7ea3776854ec0c334dd8f254386fb2ee2e9443f5262a578602d30d6f6f279af56ed0f5796c7801faa09224081a6a275af4db82b9d6cb379d17129bb93b1fb8cf01ab2ef006239bf191a88e72c7fe0cf7a869d98511906b109951259c6510c76e4a031cf3fbef20f65560a57a4abc8238a951bd5cec62c0f6a12a2dfc25cb3c2508a08ddde787a250b26ebfb97832b03225cd88942b29c9327459504256fb5823a2bcb0415378e86de2b2796e2206158f17e8573e0476eadc4a5418622db5d06117f3576aef08db414458229b81d13dd589a8df57876a1a1d2393957cd482c2e33f4312715f5b45459d7b765659fcaa3808e86b66000f2446a7a052881dd6a96bc592f545dd6abfa7db970a904e98410a6279f9d94d8ddc677ae83a7f3fa21d69a7ce69a2d5b967631f23ac3cf876169574dcfa49fc390bcb0487ff29da30fb15e90128ee41049859e01d2647168e6498ee30422a6ca83734dce3195475fb4a8cef40e35b4b3254773e3239f5df525f3d9048330bca37b7dcab4a3d990edb87f99d1f4d94f93ed0d8c5b170c10a31505bcfcc84c08d73d53a227b33b60fecd3cba7815a3387f08fb8a80d89a280d53cc0cfdaca201ce0c6e467bd4df12c7cf4f034fc3e6b2e031b7f34335eb5d754983b083368ff4497ebb1ccd01dc2412d00f63ede431dc26919ae54c2b0f2f8b5bc28117c6a99de22b67927ac659f6bb08abd23314ae3160f655cbc53d41bbb8d5dfdc9d22c21f61ab2fc2a882d839d105d448fdfa43f6a5150c92129f7a804f66da396aa74fd97e5b550c39f56730f34677237229b692f797508db6c04c62eedc3f415b1debfcfe1ec20af7bcd1565dfa4d029f5290613151ba138623c353aba68e76c33b62346f9b380b7b76d6debb9909fc06ea1d88ae5f27884349309734059ced895dc0e34de9ab460a263e4f617d25469612f035a0c1faa17011a36400f18650c2377622a1b1b2cd43497bed284be2c33e286ea6e8e9f4caead42513983a96e1a826ae9d89e21918a3d78b18df4cd43a5504f19ea5fc8b9ddd5f43f132fd933a9a9b9d083a5fc1d768de1175879f792b3e16719768d9f5c7dee1325ea7862f5af34b1add25fe4e4a7613e1a4b03354c934a74938cafb7e1fef17062771691a965258450035b3eeddc7b880025846f2876e4a4b875bdfad804feb33ee96fdc5f86e181b28a8c74666ff643e8fe62b93913a33b07a39a1284b800b93a450edb345670b87a2cf0df8a0c69b4846e00efe9792f864d347d11eebf3cd0d1556519137ada4334f66af8178c1ab992318d42f02257a2c4a44d62b8d7fa87dc5216957540d47e2d65dbe8f57b23badf0fc00b76c9472326d9d26c213cfdbc035caa161a15a876946d5955bd5de4a53bb34228963462c58134fbc81156e6f5e912c09e1f5774bb2c2e2b7d58ccc4fd7256584da312e268a05d263ffad14364db462b6fe4519ce1310cbd3d8e14f539999c59501bdea71449c0e1a7059b549f45a96e4d2cf4d4dd12ca5d3d41585ecb79d9a68d518c14db29978da6335899a171c32a6dfe47580c196b1f6df1b4dff683696e99126377943764637ca324c01aed876a5caba6c774f046a79d3034afda481ca02109b97fe8f0136a3a0f0e2adcebc358f3e793ec26b883e7828cd8c0bfb554a71706c05bee920cd6d14ce8aea92da91d4a1d57a46226ffeeb944000124c54591b9318a8d2a10c5e5a4dec57f17fb835ff2f0fd8a10e56d2759e6542d1eb9ba328a3ab8d9ee88594bb25624120b07c4fd2610da30bec513120889baca72e10f3fde907eb29405e820da29e993098921357e58e4d1427381a11e224f550dac3dc7fb0411cf39f57ab91604da0d1dfaaec235babbcf9a671a86bf541db8e9e053d903c53707aa1f7ef080b202d35e63e27a29ff4c93f37038355f38e813dbc9aefd1248a18546c94a2b12c5b7291ab427d570ec4d6ea944aab8c1601a169fc85dd75e6ff6d74088f9e6f2bbf0c23f584f457f442ee7c73f0b3f750720b63ecac6c4908f50f5522cad8a19d1f43639e8d3004e2b24dc8b1c8a9cb64abe2e6a3c109586c66aec0c028899d9947f1ed2ac2a8ca7094bc03bfa9e6f0ea1661c4acd1ea569d49d34b41e0aae9c01ee6bb871b35b684d022642bbab55e48d8c1bc3b4e8fbb972a12344778719e7199d45a8bc4601281ede0daf74f4aea7bf64fee85e954ef9ed22918fce82c44d668c555e796f517506d64c1043344a06929bede6a439e83f643fd2b3607656a531dbda7861ad2e8dba90504d2906dc5268bae7e8202d3fe227cc4bce72417620aa4910bfbfdef64f457e4ff1df60318fb162e2634f835e7296c23c1cf045fa01ab500aab63e167e45eb275a36ad4e239e9cd8841e615cded72f36089f9fa9bdae4e177e85a9100da84fd548ace461cb2c25c77fbe90847076f1cf6c3d2b1038e6b001f5236175fc0160ce63589503f3471f03de459746db1cee4f980a9850485f2be5e8849995a5a674d812031e49a1923745d0b0384c8c1c835df1e53397cd0822d2ef789de8b4fbee8875db1cbc4040f2384910a5b86d9df6f33b7bd181cdcdcd50b6bae65a501f7cab22763c1846ab031c1318ff2ad2ead919fc0e4a3a5d350569d78b120f2aff29d0d9c39ae587574d6509ecad7d8cac2e4b8946a76e9dd005bb2658c8ee787865bf4455c0b1bb6ac3ad89baae32f7d1bcffc14c53227ec312baa89a4a1ce282fddcaaca670c6d2c0b1d00788fef02dd6d960477a11ad7d4a94a8deb3a2872184cd0b89964aa42d36a9168f09e3c476800db97eaedf16df4e29b7e7fc8282fb96db951bc2eea67989de9613f0cf73e182c37f44d84146e7e70b16556d3cdd155ea7fa07bf7c972dd3afd0e62533819c6b1f4b0ca0ad37b64aaef7c30bedd6aa6786da4a5316a90cbacd2b0f9f9bfd91fd954404514152c46061b93842db4960739d649b31f6805beb70fdbcda931db42de493807cd0a6707ef6a1ef1a5f952fa711446a6aea3bd69fec9db45b443ac70b914657f9373fdd44767e9699c9e95ca746d742e6a7295c814c0661ec6560ae9c5d81bc123081f1dae165066979618e915487d30dd1260759a06645f430730073837cb1777e3a8982a10ac5396f57ca3e86a6cedf398784ea038049595879ad5415dec44bdd452e0f7628cb721d048fb09bcc6925c335dd87d61c34f22b9cb5bae5aac3a9f7406dd95a0d46cc87e0163ba2664af2265c92b77a8d3e7b4bf90de3f08fd98d1cd02e6f83200b491e30c37c316f0f380064692628c12d455004aa72f508d03bca9cdabb0a47d4ca62b811fe4ab72133fa9f634391a0112b80bb3270f4a5c555cf148a558119acaac7b03450beb0d359b9d89df4555eee757881bb37f7c1d06d801bd786707c7ca59bbd502e92b45dc994bbc7f87bd0b9c028289e261c758060d8571b97d130944d3ddd55244a66c084407566dc5af70de7a89db27dd7ca3884ebaa2c3fed0dd8ae3af4df2468b2016d926f92931165597aa53fcb0b25d333c34a18bc339913cd960054b3ddebc34c97be027db3b8502bb5055edcc1e6a5f13bba26aaac21028d5261b2d55afaa05c2d0062e8a8374a002ada12050c71075dcad048c4bb0006fec61324baed300bc5b5ffe93d934f75711bd163f09682c85a0cb71160f920c1b011be02dc27da04415a0b593c61612d01a347848f06aa8cc2a01a76fbe0950870966d81a07aadf7f5232f2376372bf6f387a655bc38c5b510bbd7cb2806ef5a0837d77007beb67e7dbb08a6e6dbfa9c47673823048488c717342d0bbfc1928f5b858ae6e4cc73b6861140be1366e03a586b0b14946b16907c1cc4f402cf7b5bad76adb56fe6fc145f974be1862b9329f0a340e820c54b7d7d022b409fee5912b0ccccbbf2729be5425d77df0c6ebeba0cf46ce1bd945b08fff1fb5af216d8180ec1a2e23e8ce7ee663d28c55d252ced97ebf5ed91896cf4f9d8df260da4762e73ef6cfe6588294acff20169fbf5fc2bc245264942ce78b0f8e32ddd71131adb5ab7cbaf8483bac2c63f11a85eee6c6357313ec32edcfebf531a10056111c6bac979e85a3c016cd25faafb74181e6aaacac298b7550733fe41e1ccd333f0861016202632f35fac4dcf06d98ce108835cd866173daefc6127e7395499d794b9c605c5557b3e828c51659c2ca9e5246817d0d39dd8aaca70398bb96dea17c623dcb0576c00338b9dc7d662873b7b21bc1f25e96734c3e7801016d68e204a97f01382d790de46e7e1f5afb4b932d0110d060c034dbfb0b384fd82e0d83e70bfb88a0264b9ea858f23d942ee002969646711d85a8cbee2305cb0da8e10d9a188ad7edc76182922bf659e0069066c949a0f3ffa24dd05eb9859ac5a560f9c0ca3d2fec7f6aeed1c69bac9069005f66dd23f0d393123fc7ce62cbf8c04471018c74ad7805b5fd9a5a43094ec327849c9c6475d3916baef0478b976a0d15e063841fe96d99a8d0497f4749b1467e4d2892336b413c5b8c1494da5a372ccede3c2ce569b91abad5a33a4335c5c1ac2a4586f433881bf1fd0b4495a7083f455e4207afdb3d589df1fbf64c1ee16ba7aefdac5f5db1890de020f193387790bccd96cb81ce210d057c56ce90b9b4efbfad497079a04bf28d9e7dae31c8ffe173920b81da48011bfbdad20e068ae37a4537f253b9875b5004388849acab33cb1e50e29b844783dd13018668cfe6ea7b23756f955200fed6bc82868e443531b4e9bc175cfcd85e85173b04055d2a7f3ff43031c9f6c0a4259ce17fb1fa0839d25bfada9c974c41f36759238f97ca66079c2dbbd22e61714f3fce8e7e5568da29cddde64241471e77ba1e29d4cb0828639bc98b411f9420dbf160790da815e0d8242c258d26f4fbc29c6c7d22ee0f2258c2bfab03f8d8bb416bba67129a962bf91916ddc74092cc7db11da8b430377012372296e1c41cb58d65e83ed33e7ce01546544ba6aab221eba458f0cf4de818f8ea4423b5c2d389b3e878a839b3ae0336cfb6f786155b752329961b189b7d674f5501995b58f18ca2ecf00bd8c8b6997e5fb9a3eeca2a3ea3ab4ddb730586449974a8e0bf82cc4d825715ef42ede6505480b17272695fee43df8a95b623349cb6bf76dc2e022b3050675998a95295425086f4327f0c43251a42b4b70fe1ca33a51fb7c6d4b957bcf4d2b816770067311000eeab624d5d56d47104da4f007700ed5f020b9927dd9ea438c82a702361fb0a5828897e19248294d19d26b42a7a731be7581e1b79dd6b2a6d48a85dd352e5a87981c3cdef74830ec714b3df56b5b3fe222f52fcb9146cfe029050eeb6b2e13760814928f5ac564ec6fb3774b1442747f5104b73141becba7d2f48474684f80ac08ba77b4a3173c98b4f643895142a4c03a6a15919f631b37e9db44e09a22384c4c1680554c947c9cba64f5efcd5f089a7a5710b0b6ed0fe1481478ab50148ba341494efb952e1d46fb6d27043df26d374918277a8819f81a9b5b253bb82b7adb6d85f78fa64caad0727e1bdb42bd8498a593c1182f429a428cf8b2d05a82c72f5a3e9c7998fb79dfa6bcd1b940af9121b0c8b243f2bc5b88aba70b37146f4b8b459934faf0000cb8440f610b8d9a3542038944b7126d6e4a25a2c76258e551e9af73371b1e133edf286b5d0f21ac2955d610da022f5f3471d5fb2c0e59b5585f0bdc0f70d96d2a4f6d85dcb742acc9fc54bfaf5ba9afa4dd37ed6d6776e3f5ecd401841ac2cea04fc68e3e258e357cfdee44627f1c7b69c4e724f7ec6565a5b1f4d28bcfacf3775e2531ad93b7bba622ac420219d449a25787c349ea18bc35e8021c9cad1ec36bdefbe8863b0961eb6526363b9ae902e3304687cf78f86b3ce2bdc2893929d505190c46c6a3c6a8cc8d4ca113f918e4764a0a38d15b7aae9fbcc684920b5e8143c1cc9cc5bfa19b082411cdcca8cb002821f3810765ecf123a1c2999c24ccf405b7c4f99624102e8d2b04fcc01037250e482cb42f55d4a7a5dd74394fa5e800b95ec0ad97768dd704c179badf78c32f01ea3dd6ca272dde3ebd0a4315d8ee529de021baeb12d1835dfab5851b225791355ad956e74e9e25ad24dc71a4c6612e83726fd40aae29b1a896bf0e17be4cacc61a455dbd0b37eddb9761c774c74046aca0196d1a5be6204199f472975bffc992dbf8542c057c8cbc33f446fc531245823f41abf9ce40f0ea6e8e803eba4ae9763cd5a0631f243b76a46f7dfc02edc64cc6a4421fe451a8db6465ceef0d821fb60fd4b9be6f9ea6e331e6f29bae33ce21ef70cb64ddda8721c83a0ac0c377434e144bc05bcc1ad1880c555110b383ba5bb46ad7693c738c6d2bbddef8e12ec5b68573b9e9109108d4927e2275b7347456e0695d3ab311ef060fd40c7aab0ee7d2266a64275879c41d58943642ea0b95417e2fc664a1120788cf9ee7079f894fa82c60ba0a3232ebd13de095e32e19acbb933bdac209ddc64509ea2e1fe99628238ffe97dc4f87585c8c7112926898cbbd06ca926b5da4c146885ac4f19c2436d2e135ff989f1bce1769207aa5dbf50c6b26c5f433defb2f13c2674affd57bc9c759b54af9fb4e33e12cad56561a36b0891d601c","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
