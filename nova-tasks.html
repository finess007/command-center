<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b9988a256395548a798ca1091e9aeed54cb7d8893f8abe524aea921fc56318fa42f43bcb587961f562a56172233dc2406839897143eb852f274de1ffae9b7fd2a3789767de5af6a8570b64a0b119985e66b53abe70a20eaddb661181373c343b435e9b304b5826ac6a64c130e38a17ab19b4e10bf12fe436e3ead925dd24d48e3dd521f48829c0db2fc3e6abf9cfe22d8e0135d11606e7c4b4b2d0533ee31056f90fd3fe0a3e58a69a4d705a1e22d507047bfe10942fd9b5bbfea1978bf509d5af99e978ac98b7fe7669d5b4e68816b26507151f1f4b6621f33280accd4d1efdbe26ad1da476898e9ee3c050d56c78af9b243fece25700ee832f535daf2b34a37a59de6686e660940d603fa228274cf96526af46c858bbb503916408e8eeb07dea07b9d73a9c3a3fe6d64b1b74bc3cd319fd6a6f0f38d95346e41343b1f210115e2e86817ca06a5198ca565577a2c4e6977e733955064b3dc04542586104fd2ebf5053c8142b9e1be6ac39c5446e6f55db3d70b827fbf7bddbbf55d43f1e3fdb56c527930f6fc57d43af8c8f84fbc1957f8047018189566db5710b7c379f3e396a0f9f3c386f908ef51cce7223254f97fe243a2e63a8674f464335f6e5b6285a736331c305230eca23f07a989f75bbfa39f819651a9c2ad82d7d6e5020536a0092d46394d4154951cdf9e0e88d9d7b878b7e62fe5290914e34678c578c308f594b894e039730f8a475142018fc5a09e7ca99a885b0333e7695c07f4cb581ee0f257075aa0852b752a197475c8168caee5fc89e1f4a46e0666f9ec3ce3dcc409de6a7133148544db0a8f875dcba475ea6fd1d9c3ae5ee574d5c1cfda6edb9f062e65c3c9b17a9e765214feee031fcda77f7730bddccfc659f95bb206241108113d33da59b57c6d17193299f0baebbfcfaf187af9859c971f2681901b33eea842a255359c3c8aa01a3de3f0da6cc98a8a996a93c45ab6991d7c60febd67f184122e4d602e91cf376683391b1e2e2dd070f0281fbe2b112288a1a1a510f32ec8a16e0e10fd3991c7d929fd48ab3a28775d54b2eaedb48503061890d2589bf43dcf39d25972b276c22d4cd798f14bad96243d7e8c72592993b652408272c9d1544a662fb75e05c53fc0b30c58f0b6e60d72219ea306e8739a1cf7770830dd417fa986c091458ae2e6f44ae7d887cce819090725bc356be713fb27005072f5b54150958f1e16280af8ab27ef90b4a8d8216e6d0003997e2e011e23475066e18d02b414e0989c6db486a610dd871ac9f82ab8349bca1aa3f8f261b97fc20566a49cc912d31a72d418f777c468b8e322579bc80729ebf1870565c1716d5b5cb617814f8ec5117078ac5b9edc011d230d5eae9b7d8957c10feb2392f5520d34fdfff9da6d3020119a57e4d9e352f0899b58fe1f582b6bd972e536c21ac51e9c0dd4b5d32a525bf6af0f366797df0c2ad26ba6dfa391e7544bdea26bc9db63e9a80ea81632227ccb93b4a6087b2bd0c33578756300a07c01d6a7f32a2891e529528c3634dd78dcccb2431cef50f970a66899e156ce0a6669c517c4cfafc6cec1f54289d346332780198262475b39a36fd29dc0f80552b823e7ea88cf21de39a1765dd0615325c4396ce39f366b576d149937252bf5cbb978828f3c93ae1ea8b82ffeb518e943fcd5853b757cd6d3943100a25c49aa43e1978cf698199e0dfe91e14e8bf710e636794d34ccc68a67fd8bd6801c4663a28c8591a546159c4bbe6adb038b3a7f2f1a5ade68d0e98a0c8cde92b8474d5a814c11bf00c2c5d014a02d53582faead0b823f79810f0c0e0b28f55ccba9da1dce3a6ab4cbb0952f4d2b929e5c96703a3627515a054b3a1fbb4fdcd9583416a915cdadeaa5d966c3d5db7e3d22312b121d710e0520ca2057b3947013d335ef10ce5322001cd68b0d45a91927e42e51a31da4104a3f3fdd5633cdd4a3a440bdac304e7a30e9fbb5eb7e178077c1e3e001ae9684a641404bc1ad8ded0f905b5758aa9a7f508019a3bd8cdaff9f5a725110f21f5dc264102674ee2cabac7e524167be6efbc6e7439b672999afb5ae44d5b4dcc31b79c69e1f9263b8537852aba0f8cdaf80b6ba9e6b0b865ab87248aefde3af59bfb77c1d139cf2645eb52cef82dc245dc1f840f2e0329c3ef36a352fbb3eb1803a1214107dcc5eb80c8bf3d651f17f9443395af688b2b14a617ddb9e7196896c162a8df49b317d20a0afb7ae0e8c099d820d5e20fd75e72de5870f6c7271276c09bb042955030d672b900fc00664946c1bcedfca4a14e83447175fc6945192f3f837f8908e0c0f0e5e9076332f0d8e2b4863ab15ee49ecdab4929be6ef17aaf1ec0a924a233e6bb5a2a7e4af7c143a0f2bfcfb045bd9ecdb5e9881d8ec15df36a9ea8a0285d836ffc7a879c42e8097a5a7aba06491065a49f6ce14125ac843663edcfe6ea4f20bb7fa68d40494ee04f5255b3ca45cfe9480f17f9c4bdd9528e096d975529bd3e3623feca5dd707eabccfd22a77a58f37f498ff740c53aaea6f8374b88e58b01483e5b1e96bc915f1edae2e414667e0733bf285b27279b34d3a8757cc6f1c4a2633d852819ef82e75872fa1088e2e523a239d539dbaabe7bb9fdcbca23f53cd5cabe4e960a73330758962308cb2675652c57691c88ae559df896348f753488e605a7445e2354c221f1fcbbb66aee5073d637cdb85edd667ff0c561de866dc2a4dd4443e7d5a3e76a2c7be3b94f881a94b2111e9ce89b10eb7a2a2a68530342cb70b8f373d8c913d7edd75d09adcb853818920a4c1b0c925751a5ab13b66a922eddd3e8a1920be8c6bd1038b60368d320f3905bdcb757644a6ee497bf0842514d5ed3e1a9f7d6978818acf4c2c3b7ae7365d1900a6ce24c6bb091471982cd77a4e2a61c9c6a8e5669892cd27e8f2b4c5b481b4697c85d3b5b5e83d4c7955657ab03089243fc0631ca2b9eb835c31e02796bf6d23288bcb698afb5624c3f53964dd92cf3b5dca3c276d288e7b6ab795b1c55658e6693a291d9ec5af77fcfa48006b90e6b25cd9dae22c272b94ebcf8b4dc62eb18c8c72cdd1442ef6da54374820882614390f05fb8eab1c779508a6960a77c5500caee59adddffca6e9b1688a91603f8dc081e89f7b799a3bef25c318be011636c1d634a6564d8c1640c4dd13ed2ecaf6e947aff4eda40fd59d18f35d7538dee431465716226a8c88b3364139916bed84a252174cecd5601de2932450c7d0483b724abcc1c15b237a3700c6a98b7d3f905d520e253cbfced73841a59ade5cc42e11c59cb02a48bbe90b245d8c36746532f823eaed72c64a611b0b2f976f8f37ef0ee7f1295225a1450a4a79df394f7f3c0f5ae15387d6748e0508e0de89bfbe7e086b579a235357125cdff2d7a9b7f372f064bb2005da02dd12fb5e5c463eb38579149c36e7d625071b7cc0a7e821745156ef3de4e52b3b64072dbe473b573401233bfa758ef322003ac0a2ad113ec061c003ab820c12c11f5b59aaba35fb9b7e1cbc8f2b4413311e1f5784c0c95f2f627e73c0af663388d38a431d5e3835469c893b35eb1921a87e1f81a536574b03bb255703f7580c140c98afb4462c471dd0fd14fc83763683dcde78dc9b8850f6651a58f13d629457b5f97f602132ae70bf8691fa43ade24922a02e32102269551fb9078fb9bf3212787d6fc6545b105100cc76b450d4f6bb5b32462417f84e0c82089b16fb46be26bfe65170f7536ddbd778ea29883be2c676cdaaa5fff86053448325b779e0c25dcce7a57850aad661fc45b19c4af887e1ab85ace5c58837f83a421625ff50c69b0baa04f8abcb77c556ac302386265af264ca08b15b0e248d298d11ded1c7c2291075bf646b1efbabc5bcae68ec2ae16ba27cf56462bd4aca950abb0461acf2230ae30ec02f99db1487b610c6e7e0ae8f015e2b75a7b2ee05c3640097ad4105a5e8cb4794c998f855452a52c738b2690be7fc7dc99f1873e9bc2f8a85ab54b036a42380a46c8bf9ce2f2177c1b45075c8f4b008b68c4149714cf08a9cd0f309cbe04e4db21ec95c7e7c969bb126be0bacbb2ba846eb8f9bd4b15e821ca17cc08fe0ad7256ce4485ab8f1bcc680bbd283ed4c1f438b8521688e1fe2745f65efee0c2e3aa773b73b921cb2fde3973e8761b3c217e8f1be5510f2ac76da69dacf825d927d40a80fc2d4b076834b6eef1c926e4011a1a57128407990010b373e341f4409b5eceff4c857b2a52144cdbc693b0dc813ba966a055ec60efac3a49b95d6ffd0b1919375db88066b766c8d085e9b3864bbfe7e426c6b81a3d4aad1ca46840930725b630e0723d579a40e11ab0a6e9512493a94d0cd6d4429470110b403b3aaaa15af1b2c2b5de90fcb7e1d9f0a8e000cb556e9eadfabf92c1041c012630c821b1bc4a81e0de330b51c7f856b2f9eb4bd2d249ba945640e9b92c269af90e1325da678297e48ce06e07819c2c24c4e08d2505d8141db2e3204a71103e485833f04e892e91898b17b4590b0bf3671b27ffe24cac59f3b56da9e11c401adc006e00d0308d79f03804b33cb351bfcf97d84dee9edcfe22c5ac5c8e0db75e142046843d2d1190beb51914c6122ac5a214cb6da1b8b61b0120a7a6cd4e40d8a79dff26f49b4789032c78fc024acf12349dd599eeb988334704419935c3e6c4586e9ff8de02f96e8d080c8794bc1bdfdb14f50af7163523ae646728e6b21b77ea3d71802f3e80484b23ac56acf9532bdde212552facded71449dd60dd5ac9dcf3d56d4221f3425d0767608ff236e46b6aa73cbad603bdd3d44c7cb3b908590eb6cb8a50d84c95eac0e3f4c59081657820415802661f7f9a2cc474d2e121bb727190c63de1b6a629bc23207a4c0250aeb6f4badd4bc1da1d25f275f4e93d4e08bafa7dfcd9602678669503bbd204301576e96d9027ebfeef1bb446257716bdeaca05d8578652649e050acbe94d5185fbad0aadf277f3bc05d412a6ac010f975458ed886eddd71e69b51495965004b0a3141f775f78122315599e19da61772bc3904c9ab14082358bbeccbb1485b404b7c8661a99ab4c096b8a76fb29790dc8c6febea10c516cf8f83b9e9d5200e4a31cdfaa24dd63612d4bd5b79f61e200c459530bfae90f89a96fd1b3a9585dda3b50fcdc06c5995948df747a05c407c31188b870cda1df875eb36952895e47031c2d1bcb004a1a038d5104b0849a32563cbc75dfab3e7463ba200b3ae885194d8896f4f598fdd6eeed375889b448a43ea303b187f387fc55a002af159d80100fb0af96eaff46267e07c43797b158827125b111f83634dbcea0cfaf502ac59a5692499baccd765522d03f0309013a18d0f138eaf83bd065d0aa2355330c35e28ea0701aeb5ca65edae9d6cae616c93d9d7609299b54302532783dd896598c3107c611aaaa7c7de0334c3b0aeba543ca87b36a7fa46ae9e5c019f90c3e517398a8cae3941a62e2c2408f4be249352d2ba7686b026f0f03bf598bb02290cab6019c751d758bd60316274a9927d2276e14da7b40a590e2742fa7d941bd9f2e09affe4c7f895b02176a93e9be684ec81c472a009c3c9276ab8b4b2275881a50c6eae47a32ea4195d1bb87a4d405516e105abab855cd2bf01d10af4a72436d584d9aaf58ac9c600d9162f36d8235e4c51ea9980a0a0b3a7571b6a86b58c1fab36f8758d2fcf36c5c781ed373b4b2c55721f13a7f5f40f077da8ac5c3536d620276d15e844be9029e7a34af883ba12f336b4ad138f003e973ffe84b67b22eb59a59e2a859c50203bb16b4dddac69df9f1ce16962249aa9fbd16d7e411eb091320c5af529c5c7de2ed3d4873fa5bf56b1c907680af4f7129ef0fa60374c500be91f567789cb1455571cffcf68ef8e506784c10c47dc37af080f0a4dc60d53e1b4b6d6c96e511b187c6614a2893d782bd8a0d5d73ba242365a66a6d7f41f705f3b867cf002309f7a6e67c8e69887407a04f06373679b76f28677d1d4b03b80ebe92c48c68ed516c7dc42da65cde07851532963f9dabbfdbd2bd8c9faf8707ec3b483f5762681e173f00dbaed049b552b826847bfde8272ceb806dd574f58962baa0cbcd72ccd85300e755842d38d28f0730586be7f6933940e602ddd1ea65ef63f82215dd13ce0a73354755b97278c88ac6ca0927453f6ae7405e8a8e6922c62a39d826343bcfcdcd465bffd3876fe93a630dfba1ec554c4f7c2126e1d2453c95d128989db3a2c59c1083f1a21fc03f22822617b1598f8a148bf5795f1d639a159427fe0a3abb1207715666897cfa8d2c3b3d7b866577345596980a4a93311153db6114ca6e9cf6f6c93c700c42fc8dc8575b06bb0d0a75b0e5ba63ef1f83b42ee52dd89103f30df97df2bf521c607bd6524def1a8b9deb7de7b17a4bfab5f4182498eadce08a1cf8a145e8736112cf1d786193b2eaf1e4d35d187b0140f88c384cb109e69f8f3ad5aed9286dfb06b409be9f3b4b71faf94b93bbca3ed98235100e6a0fa09ef67c69fe40c91ef81ec42e39539a35964ee134976b03fde7b5b16046991485a87681c6adb7a0d8db415f0a200ba90ddc9f3aeb968472fc32ba837feb86a5decc63ea61fc548afda22af90784a70263f465e6e01a6824dc01e8660d8b517332cfbdb0c534fe3bf1fdbc21124ca422b15da9bcbe6713071b1a58a719123107ce8e11aeb67f744d77e9068e83c4fb55ad846a16df520f03af982183aaf7c36b191ba5b9808b34c61608811e9b02f2a12ef7a9388936b0b2e2685f26af1d02fd9c3830347b4ff13ac117381464468668c5d5f9b195521c810bebc6faf8e5870a02ff83fc84fd64164eb556cde21e114504950365067d3d4f3d0bddf6266804ada792c46323f7f3b92cdce2b1198325fb7452d5af8e69f9b58f9693cf6581338fd860d60a0fba18c27bdec3635331539270573e78670acc0e1fb75df90dc5ceef11d2f8fb224d1bf0e1ead6bb580be03568018ce763a14480185cacbe2b1e8fb8289a147b08aad433de9fe095723f7610c0dfe2739f9f111d4f9ccb177ff5c71895604b42e4355e4eca1d8ababf9eada06fcf9b1396a4f632e064aa5e2838d65f2296961cd1153fcf17964d88fe032e3047f008efa069c732c807f75f4bcce14557cf891917562c704f4819d07953a9d27d20bff9a5a728b76320529272030f15bf339b81d9a210a2f6e240f9ef8c9c2d0626d57261e37d6f36190b525e077c6027c43e7532ff0d3cdcf2effa2763918530775026ee4623f3735b2a04a31dd1f06bc877d778f1ea904ba7e8ff822859d07d34bb0310c9a2d9f4015fd1868940a1432c7ad52c937f2c3c398f7b947ab5cffbddb0480db40216392411cdacd5c3dc12012cc5651771cc7ac2ced2d70e28e9dd6c3bd3813490762e2059feee0a53308c2f41aa4a906c29e93d85113ec7ed67a8d6de2f0741ec812d8910cdcdf9e582270c762e23d62767e80a22a301b1350496468d87339409d9401d3c4ea284857f7bb6e0c12656e294b139b770bf66d9a0bae2b305f0064ec97f09f68740807ba227a3036c6473a4277a1f6b7df0ddf064ed4d7497bdbbe5d26f857708b1847bf53a0699a803c651c29bf09fd944d4e12ce4a01e5fdbc36f09de4e1ceb01d0b549b0068543166d9784ab8d41cfb7215a357a9f4a1e277dcf085815467c92b12bb3fe1a8e706954769d108e62d15cfec840ac5ec5c2e4ebfcfea8cdb35f72db92a83756ac477b992a1b4ce41cad01f9524db3ce99f1a787a546b5968bc2e5aad6f15c2b91d64953f8209923f5fa1fc18946c648906346e1af6c5a20e1c46e521fc805dbc8f2bca8e5838ea039d2d938a4305289945f05a7f991621914b2dada2c539d45ce04461a24d6d5a03df5b0c14861f02a03a96366996f94bf43dd2929bae727f64a4793cbdfb42b54e078796f8fac38326c265be516292d9d4750bc6f3b904324e083ad525bc883846b21ddd66ac3db9c68bff1fdee5fca858ac62dee9992b7534172d2cd97c666dd5c6e8598ddd09a854cf1adf423fbaec71a49ee928e3cd0b894d6fe681cd239396a6165ae873b598b37a983dd0d19ed42bd52743be83ad42113daa64029ab4a9409cb7ed2d3941fb562167b0bc3f31f30c547832eb4d875e6505b6a62552c0a17a7a39123c4797d5c3bc1edcf4cd5b63423ed30a6942a3488af7a0f123d35ddba2435cd53c51fc89e06ba2ca75417d7aa303d775d13df59e04bd8b38f2056337fed1bd02a4e080b3e8de3eed77703cd66b527f908ea89a9b43705e4c761c294dabc9c7b3e11d8f3749c0e8be689300d1bd786cb94f641a93bebcbfd27242cbd681b2badaffab72bb44e8606b28f032cc7f0004abcec6fc063859b91d4dc85d00e120dd0f95cad29cc3e38c307242927cd1e5de2ff6f36f2dbb4614d7d09b43bea333a47c11c2c6963818babac86ac2ad3343ac6e7ee6c5cdfaf19047f68dcb44ff52d695d2a5d71cfd28e992921a217592014f043c1d5cc8bd16c18a86d08333a5e4b00ca4d17cba0ac0863e238f4732917702eff68ebbaeca07f161fa3a9aa5661ce9fef0898eb968cd0b94451ddd261c90e0200929accd85152d6e00fad391584ec5208ee5b587b25098d1ad431cde00b56fc4888ee01fef535e44a4b0adff2a9bfa5803b589685d7f78c261d1d74ed8b248434d7f262083846e240dfb6fe94b7b3146a1eaad2bad7db1bee6e889da52a6f6950a58bdab21423e7cf88486ee473f912c9fa96ee8967f17b5946f9123631e530740043cfc42242380681a2855b924117a1b287e13dd9958408c356ff737ee5a4c83fdba9295e76f59374cfcd64e119c49a588a9c1342340a402e5f7ee55c4af7825415f1b079adb7ea8c6eb2713fc013dc801892a901d33ebe3571a71052a4a45ac5225269d7a5aca27be59288622d22a2c6162d267daae469b5ca1b4b1959f6e34de7ef5c9215d18ba974a22a4619360c6bb4637f91875fee7755099a9653660df106b4c78a13147f348cbede8845b37f32cabb9851430f38ff626140d8f0be62a022218d8154a36dbca91be16beac37e4dd0a1e80238755c2521e91f135a8a20567180cea0562c891be61b94671e692b3d1ee9a27382d7fe62a259e667d51f9e6127df4df18bbb0822577a1a4e4edd92ddb94a448d37986d3b3498e21babee75f80fc43e410b443e655a3d334cbb900f190a75b38f8a5c0e2008ab877f4701b77b4928ce5500e0d5de9f33f3d157c36953a942809b897fdd2acb44addb109b585020d3f1de8eec92332f8abed6e3a66d88952ba57bd2ea306b365499b1dff4b012d25b96459669466a739bf5be9f1832a33489e02f897acb32b1b944f16c209971864e593cf2dc00fc3b3b2c20dedd9e4c96f5b9e0e6057d59ee24dac48940f95b010b67d4405f9af3b9baf0ed1ed018798b08d477b9203b28e764dbdadc7bd0fee2de5f4aacb0edb744579c23d1f5b73647e4b1416c81c552b8ff380c144d01e9c237eebd312b6b1c6a43167aa43ac5e1d7e743d6782d2048c319db43f28442947777f405881d2843f73704790240e2693579ade17e6811c28073ffc45b2963c8679a9baacfca971ade670fcff1c4d83997135969da45099772ecc5e1b6a97ba466b4e86ebec1218f14619e517e1b83797081bff6f75977970fb8701dec8c3edd1a7b6f5464f69dcb19f096fdcf18184ce1dae40ca16558a8bd561026dc370e458a131ecdc446d5a20a24de67920cdb15708b5b73b714b17931b28d49f1a2afc94950f6f2a36fc30186b33cb602dd720a9028c49eb2031f8b822a63968875ec3ce087687162b19cde394e370e99e2847a344bf0397068ed3fc54396df912f0b0ad69b893204ab7aa42838ad77b7606f11db1d8d78fe46fa612a0eb304c3e6866fe27784f05940f56a9db1207718a1d0882921575594b0539060eb4c56aded4a322e4a78b2991e85d4d2e11d4aaa6f4bb42ca2649683144bd2a3e82248a3360f87b6743db31c7db86de8acd36d057befb2ebb41212c85fffd80cd5379c24e452d4e158185ceab0975092267440228ca8bd0554e33fe6acf5c5cd469a6ca034d7bb122c9c484cdb70243675020f32ea95c5bbf0962edd7cd1c412af0a5cce3666ec5376b57bd8a8f066476bab6c9798a9724b87ac162d808d2d4fe8a5c811091ddf0a1c1d370db4bcc685b06a42de100be30e2722515e4440bae1e3776dc856272089b4498112abca76b96adc4f09b926e33afd71fa0c000ac133ec4966d57451824fc8ef28f2a8d89f70f791a5dfd24a5c525b1b50a94acbdbd40ada2476dc4aca8b04d6eb99a0ec0dc27a4f6341727e17f0814f84e88f0354a43655019c10a1a757ee69c556e44e084710514b3cb6a334c7f089bb23cf6c943e00b7f334ab10b55d287b88fc129b35a2e2a2547e1b5435efd9c97847c07490f75268c09c15070f76a07bd32d67d313ee31c0f353603803853e19a61d816f41cf13cd72f6dfdafd58a1202f8084a279ece32abbf936c53e286dc9661312042bf153b914369309c356322898db565a44a15b1f76767ce71bf4cee1fc5eeecf126f24f83e2940abbb81ad1db6c3d3bffdcf3c73eb1c2d7b0ac1dac7271f690883bdf852d1813cfd6be71ad43bfc99e0bfacfedff4a607ad9834b903a5463ac1f199ff4072b8bb6c76238dc6a42db8df9b2e48f5e512339c4c626324a3aca431983d34a2378e1022da7ed549d5c6313cbefb4a727eb8c4a2f1c6f86d0be0d4e2d4551b38718f94953baa7bc5ea916783146577a635247ecd9ac20344751b0460ce357f5084ab26de4737c99c1110d6680355464f71f54402913bd1247bcf29aec02d921aab6eb53b8990ab585cdfc74f9568b03fac581d2a78f118b5c8bd55bdb8fc2bfadf5b5f8a724a6083fd30e16773dd48a5d9e846b4b74600fee02b667d3ac9a4cf9d840446acb4a7e3ac1b58fd275d7289c84756bb0f7d27f852f202b4c877d444f21c132f20a268a12471b78c9435c5d12df4825cf901dfd4a5b580bb3be0a0cf0d7bfa89ce150094522a43161df891d2d074d85c14a8aba797e5976f50aa5589572ba7481ff4f8aae0f0fc9cfe995ed43dec6dd012d8013645a14de6231effe074fbabee6f23429275b1aabd23bddef2ce8fb392b6cd553c495d6a996f697af400a26a0b1c7c7d40add4b4cf711d097d7be87bf846cc5430df9865a683d326cdb5ac2ea8b9c437b1717f792346739478d1975028d61b611c2f8f934caf5a632d3ae6bce4e9a964534a493d5baafc3cd31bc7594ed3009155f04d2eeee173fcdd0c129249dfebe51794e07215551bdf93ce2a2331de1d9a3a435616f9bf010191232dcbe1365deb8779fafdc8ca52a5b7645b7ea6d53a544593ca21a5b755116be9bb2827d3d5330c9b4ab0d47557f7d1e94ed2d1fe71c4c62c855c89e784a816aa99cdf02ec114c8efaf1242a2e2a0ec0f3104fd4e70f203c024027b9a0369eeb6dbbaed0880a76c1460e03d21568b7980b60fdb2902e2ec5e6c165b4808625ec74bfd144fb416aa01198e558fdd2e93d431b736270cdda647e74b57a1bcd2441faa84d5dd8c3178b5391f83156ef4bcb405b90f742a6ba29ba06b3936c4b1d75db420a870a7ee38d668d728e60a420eebeb5067544b829a002063bd0e4fb3d25b47691bd7c5feaab41a44e597cacf293d4f997687aa785152bc27a87f8ab95c6fe22bf17360676c61e5902455a8c694e8a9420c1ad01de80af94aea805122072f5b117abb0bd1e5b046dfc5af510a073e1799e8ad0ebcab4a9e733604f4c6f3b3789ff7e78767a70aa786bc6117caa4d3dc0dc52318e4c6e454ee12d63140a37eb98686f925d6863d112586c14e66734fd47eb8bcfaaed03761ae444b3b9d6e2ba004031941f24ebb273dcc63e7f7c90a79ce0fa01cd143ab1d6384e03fa5029fdc7e1f0678cd752c1d63a54f4e4af375eeebdad27d197034a00b49cf802c181cf285e8c3dcd834748daeb478eae9ad9404be6dc72265875ecfa28e5b31cda1add65a3f922a9b6aecea175a74519b202f216039a479440ba824d185ffe2a7c9ec2ecd00573d177c57324262916816ac4a7de222b14c9dbb2dd95139a309d3c47f53b8757e572b2b3272b8879ec85a1da2872c724ac2ea668d081461946eb260a54c72c4777b1cbcc1454f9c22d4a4b9018e23c28dd5e9a517caf8a29589152166369a3f501b819e6aefd9f61185a33a78f5834e00df6a05008f5b71efc5c69ac1d1a8af4ed3edb0bb684c9489bdac30c88f0f8d7f6f8ba2983ab2c3a8a7c45b66391746aba803c9915b6301555aa0e5ca8506bf93b5e7a008f3a9e8358eb3f67b991de8643c8129c44c7a4a9f40784daee7d4d9a5372e0dd826a8ee769f5828536124569cdde2ed6469c8b4f26c0bae5b8b4d21a59884a6363b2daa0c8bb2aaf5eaf2f2d4d39c2ad50f1cb8dc99bd16ca202267163a60ec3df5e763e81d9bdc0be5d93af7b1ee3b4522ae0fafd974396cdc3bc8a187ac2c1ad9f3aca3160741bc8eb1126e65019b8c77498baa1672681aeb77671a0342662df6a67633742e8e24e10d2f9256c5b28894169e6aa68b461c4e68ee760633ec27705fa4169a6f9564dc8cab4d27b1e4f10eb1f2a2c3ce0c301e89f65fa1c83a66637e309c201e54637486aa30184512ef3634cf39ffb1f5f52fb428d328dff00ce774ea9efaf1fd915e52a6483b4d7710b13d6759facc8609ede7ca5ff35c8e0282ce022254886bc24e0f7dcdacf21c7ff8d9feca8bae4e52d44f860227ed30928e9c1c9cbc0b925d17ee62e7a5aa25568ede9f36fa53f03a74d0aa044eab9f7a67a0121328681cd3b4cd85a878bf702644070fdaa48b68f63f4ab4fc0571271a1dd7fdfaff96946ce3d71c7ecb6932067b43c76f8aba6e03f48cadce9a970c7cacf7d897ca93d6040f3b0ff3cde2b863095d646656dadec5d9d1ac29b9749f01e68cd397075cd7c2773fef4644e87fb573c8097db574c6dc7b0d1c2c77e6d7b5a53789897806cc98404a0747b9b9e6f2b8d31697be2cf52c5997cc58a47d8a57fe7e0e6bbdee8450f1442329cfd9d080c79350dc099324d845797aa6b8662a3dd7d108e62738f58b2889f4786a5bcccb98ab1d0390b24c8931347255edbfba8ee61719efd0fd2b439e0285dce01d2e07d5d707a634367c6dc6a4f38029f6d61ba364979df8f0716e59dcacab4b3441393264f48217f078a3a0a1a16b8a2c64a5519e4c933c83c4564eacdd933038fb12bbd2a844663780168f96205171fb0ee7812aa544751ac96306f9841aa95a84a07d716020fc45e56a2a1afbfa9842fa0106315b6f54d15f56cda6d88c8921b161f285b61de7b6b1057dfef4a9a1587096764a1702dc4e2b1da3115d6af376aa19f573e60421de4953d525bc9a193d71784ec8e19c4d37bf8a42e6ccfd12cfe262686cd68b6e74de112d62bf539521d2aa51660877d6534bc7760e5e85dca1157ae56dcb0125ee371c64cb9b2abba82c1d652a67b928a2dc67ef254a70e2080337e123b34f6fd2af4840975f1d14c38acec2703a286988a8069785f129768627690703effc50a6b9965b315cdef2b1b34282b97986f2f9bedde2e0e6ea34c2f56f2b61bb1ed23f1d318fee107070a3d187d09f0a106071d11bad4176b714c7d622a9022237edfa51a77e7de30d5bbb53b9337ba7c5e915d00cf99ad1eec013dc81c090e3b28dbc1189ee33ae8a0dbedc088a0f1bd22a2f29476ed02914d031d1953554f442c571c04fd572996d20354dd3ebd489734446dc353f8c86dd9e3b8708929c02a56a088bc4ad18e9c74f1d49e6b53c94a47ef8cf1545c4395843f00f4db57bce9e589f1d2b3166b471e2bfdbc46425fc09a979474ca60783d92aaa13b7c743bb35162021b2e028d152929a989188c72b1e78da96ffb5f7816d0bc9608dbad03d932ed44675648df467c4c8fde4da1c8ce4117016aa36fdf7bad5778b6bf38cb9aa182c2a905954db5841a18f82e81762aa729d9e8420bdb34c9bc9380037d0aaada890b6a4db1cd7c5118c668b23e634edc0ba7046c6b9dad1d522709204b4b6028ef6c4b169d1b7706260eaf4533a0aeee8b288be8d3677b6c4efddecc04b6e0bc8cc2c9376a6d757da8dd2c486560b68656970fa12ad0ccf8904e4c5bfa853f17863d5e2f5ad0928880f8e4b9cc97b0d08b8dc4640953a0696ef5210f1928ae897667ebdf66337cd889ef3da38d2ca3b867a8e0edad8b4d77bd03504aa41804ac621d82e913986f77dae21ce1373861eea6a67602acf850194180ddc4c83d462dd2ad02067c6fdeca8032f7a3a236384430267298780edd9b36023f644feb2f756bef6592ec6860413c5b1499c09061ba9ccf623514c31b60119e9e451d7cd6c4c666e45b3c50529722098b7841a9fe8cffd823fe215652d76fe027a12","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
