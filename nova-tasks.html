<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d49ddf8fdfb399dfc9f6cb3622f436ada292f624646e6ed3d7046b0fe4a8f80111112a4671ba149d5af4c07a561943fb76580f9c7d1af284cd41ffcddb14abff07361e611191964448b66b391cc657cf64314b8effe53ceee84ce2dc349616d77429726c5d03a242ee57e711d1379e41f5f355a06f76fb74e3ad20f1fad0783f3c576d7172aa45535f9ecc2d17b33d19f0985adede12af0a3c57caa135244218d1645a2f635926ca279d1fd165fb3f8bdebb7cb5a99b8a32af31cf4c2c70e2453566e8872c9e84ebfa8d2a4958aaf8ed85f1cab8a667fd5379faab390a0d473b20c787f3fa7e91cbe9c5eb4284d52ba30ce3abef893a1c523ad6a89c66c1055991fc5868e8dc958563f43e6e234b103aacd6004d28e30b3fa8f1ee4a15ecd5be68edb75047ad87bcc1e1b818dc2dad6fffd83b3dab6b4cb8b43c97e10c8e794ed64398a40cbf8d01127bd16ae11a6499b016d8b85bcaf590afd7f4da05c456f1fd3a474d2c797b067c06579785bfd3cbd8fec9b2efd8c26c0b5998e66389466ab32fc4e4647c2427a1b9d96deb76345e72b4297869322f849dad8fa1d6dae519bca6511977cd51430751bde9d9661f53d2503cf6bd9d14969072232a29a22dcd85353cc5b883621c2272c13adbc28e2825e285d3883d21012c3d5efe00451575abe5abe8394cd3f8d1defdc953c0a287368283b85287be54308d50ea328051d850275e154bc08397d9b394424cc91f1fa03d34e191ec23f312b7ef57a2aad58097ed8947427fc3c16a0683b07ee71b5efc7f658b275d063a8d0a5dfc62549db27c43d447b2e73e696d33d76c1397be767647eb04135e88a95c4703c4a66e5f7cd0fd775662e8ae35176c135d3db9de5e331d89acff88963f0d8058ecf67104c468df7d276b0cab978b6e24f058d488a55b409446d1ba3cbd2b814df9337be723444dccc15e567ba5f974fb66edbe8a6890202dd3bd44ce75e40bdcbc36b2175388b4b3814dac007600f3221c0c31fe705dd1757f4de47f4d400546b0fe2c405aecdfc3759ffd9686070bb3d490c36f415888e74fd9628571aa1b350afeb4ba288e69da8f814d22634c8674da5adb94d2e2802c784ae0e224e19895292e75c3f3dc3fb9a5e2af054c0b2f0194c09f82351983a658cf6e54225097256fc928bc0f003976017c15bff7420dff357e3fa17150cf2d11d2271bdc433ea977587cc9f10bb4e8159a6dab67a0c973abc6d8bb00508b5fb454dc509937fe76f36bc204b8bab96352864d27774758a38b1ec660ae4d9447eb038132483f3198440e68904850ab709c53f307f03f8e9276b04db5ba469e2d74dd4684faca32280037ead82a032290a31a6cb2140e667b75f79e01210efb1e63b3ab2511adde423f6eece9e8bef9de383f469d94b17ea48b2422af2d8d63c12b0cec0c54ff6e7d0c00d1503869f11e6ade1f9a9e2312390bd7921d5c48e635642d3b0cb05b161e911108d0fa062a121e9c367dd774c762b87d29b1a28881401cf772159ec7c945c78cb94ff506b12d0e3e2100cae6da8afa353958e4654b220e71dfd89414779c6e28fa6a733d41472d573e5e0ce2f8ba98a1969164366c67e9cdbd0b236b64a4245f583a0919383f6478c1a777e10614e7a6599d34e4f5a68d8162556c74bc62ff9e4d4dfb38764bd62d448818d91480d007d3f9ccd131b5b62cc82931760c02066a86280bf67a7628c9fe8495ebc9fbc3753b78cb8782a93334489411b3bb257ca4e4472d32f5fbb6036ddc7f917eaef140fbdb238e47bb28bc7091a7339745a211aa2244ad93dd848a614c9d188f368e8cc8bce87b8ef2e99b311486a77c5a35d34baafb6bb33a242eb5c5b2f14efe915d75480447790da25e22371050130fc7769136c98b65e00dbaa5230019a9b44cabb0ab86f8f5a30170f05f3f7bcfb0dd10ccdee9d2c7be65c9b08618673d613f7e3f27a46893e3d4eebfb965b9f4eefe9381e04671c50ff2f7cf54b0e76052c4fde2bce78b2f800d2d0df486fcbaa3c53bee6dcf1122b46f0a493af1ccbae98de521bf837de0022e0652e1ff97a1ead19fff9634fb1ce0601b37e66e7775eb6fb5a6dbd9c44ceb6c3494ff4fcf81362cecfe53e1db72b6a31224a10a5e6da4676f59d70561eae854c8909683a5ad007855abbe2140c2e50b0cc73ed37d79d7cf7985d1c6f9510d2389410b3d65341b3e4de5318001f2af20275abd10630ae7b9450047e567c6410fd3b14f1ab8e12f208704fa6d70cc4244671e7ee26fc73a5512b9d4c23cdbb6ae77a7ffe708b131621492b6f5f7b04b5aadfc6c08b24f7205e715a39e14eaf40a7edabf3b1a466429254a9cade8c67ba8f39721dd0704c31bd0966df17bb9515bc1d625a30c37fba4c3ef21c2e9d478314da64a5e81b30620b281c7339dfe7dfcfef02b3594d5bd0ced1cc20071088b1394c6ff3dafa9c222c9a7e33a83c9676ad33d63f223bfc0d2d081af5b6950cbfee28e13fadfe6030270bf35045f66fe353386f0493f05e7d71aec85d815373d85421ed0eeedcdabccae031131d1c98656cb171b83a62e73cefd212df37e739f9324538997c2674a3adafc2cec6c8272dbad40fb7f6923ff5718eb0dc0b43cf51bad82b1831b1d3f0404932d1e111d255e95b3736579fc7cde0839dacbcf9d8b88badf8f13826a9eb58e5959f2ae604b4b7f224262ad0b02f297b56cce35e4442141c407ad5bd2f8a22edf1561f48957d0be9d86397b58c24113b0838019c5431841957891363d3de385107d4b64a3de8079ff06e1469c038fb630fc6eb8c49898b93c4d49f9ef4373b3ca7f78b8f9a11c1b7b9d91ccb78ff8df106cb945b98e67011896cdf7b819e134bff91669dc7c3ba672d2ee99928f62e30b83376650bba6a889954e2f479b432e6b2dc8bbb5e9042eb68ff2181a4c311268143e1ed0d4d9a2e9cc38c8c580da52358257a50af0fc318a553fd8b65289159fcbb25e0e2cb293c4ac7360717ac77e230cb3d190018b8af92e1ce38fecaa7dc851ac0a640007871a9fe69c8aa7365578669f41036b33123dff59348066641eba5a588d1ca0b29219fa2b28a60bc69146b66d23726396a4f9de13c3c3ca37dcd11827c1a64533a758d39977b8c639fd97e16ab96e74d6e437397cfa7f887f786d705b23ad77b76edc45356b172641eef64fbb90b4464fc41d0ca74a3aa987597b8bd3c82434dbb7f0d9d2e08d062220ba566053afb675d1e4188c4809c3e5779894d325737a5806dbce64e0cf33546875b3fde085637544162f26ca0de5082ee0f9c55075830a195007a1430b0d3a77eb94f587371420089ec37c6fe761b83fcbfe30588e8c24e4522b66be60875de4e2cfcb0e236fe7a015770dfee0e509131defa70b93802ffe54833a98314d287bcd15662ab4b07cf34978b9c831513380fd21b33016e0e17104769e5e162b3a7fda7fd0372a9219abb9da8ac1cfabbe807f9651fba12e48cfd151a563948954a1ccf4543e45e77af52a34c79e36b4c3c20bff902702fa5ba105be173d4097bf6b2be92de2fe1501e859d0bbbffb9c801369fee1d384a54fe9e3a2f2f8d6c896f8a2e930a3f4573038514d0a9b5543d030366c5406cd09d0db82bb2c03c71a6c5a7233076a1ca1640c1af1145c24916c93aff273b927e7036f1982be65fac345a98370f260659daf26bbbe326e17669ea3ba8bba2008c98628af0aa58945c10a0a9bc1bc47933bfea1fc369ebd034e1ed3cc1665f0dbc5d48d6fac2308c11fd13011962a882f6d93cac46cd85e943a84cafa5a421633fc41430904cf7d1adb65d744471e5cd6b3cb056741dc2554a22e211a298d3498df55c5186ccacbb49803338688305a87e1c9b065562b56bbdc7ea645d89a6fd83d5d3e5dbabcbc30edfdf14e06aa05be05f74e91c73d004097b7c690de5273998f8cd920f7cd7d878ac3526b62e6d16e3f0f844b6b6a4a23bd4512f91f392056184cbff7002468b07ba4da1bf6c105a7c8dced87c74ab4e0d86a8a54d8d2f31105b91fd8b443d41930bfaefe56adbd1a1fd2144dc16faa0cfff9141edc1f5c36e3b4550f54fdbd70068c995752720e4bdd6a086194060ead1fa72292fb2998d6b26038596dfb2d0caf02b807cc90ca260e54786ea1a597097ba083684ac89b2e9bf6ef90668f9241ab14d7b4a3a5ca665e0197171d9c4ecf04464f482b2ce48637c47baf5b89d8c47f9e479ca253a7d5a800e0789436b1cb944ff7372d324188480e28bb5845d7f8717d6df58f14a127d1cf6b960d450b567b71d27cdfe0702243882584fe4a93daab321035b15c6a2ec8e85af1c646e7acf35e94c09615680fb24c8822ad707f09e508c1d7557cf5a6ce24fce687fd3ed2aee65bdeb5f1ce4c86a72490a68e173da0bd68773857a22b5ea2b9df1995d607d107b7ec129d47f2fb09cfc24b5c4691a6aa2bcc97d764360b3d00bd37de39f1c2745b255542145120b68a13a1229867e70e35beb992906e96a83d2388d55b6cc3cfb1700268a8e49d55a55c4ffce20aa237ba0a7f4cc5875cd947711e759ec3083a5a88374f3610260f6a4d9891d6186d1beca11f49b719e0ca94d300d01f8d143ac7f9ff46e13debbe703fbdf8d1a188e6c063521f3cc71035274704b16e8210ce590d64bcdda99499ef8e1cf545ea251f385835b295867cbdaa37279644e1fba196943c47261e4200caed9a96213f89fdad6782dbe37336afad00418ca718f30049a707c840b36092b474d362bf8e7a0f46a9b15d47c7a8c36adfac8ef94ea6df58ef04e7fc8a66ceb967a6f6f9048ea35fcaa11aacda0a47407d6520c2881eddc0f251afcb20d97fc52648f7c8c7d80f6e2fd7dc7d6da6088572bfea68392f7eadc440f441fe91dab3e583484f8d809fbfbdbfdf0eb76edfa3530ab1b0f52573b9fdee5cb1127be53baa145f7130b93197a10ed225cc787366159a5f0dce7db8bf9c69a600aea42f9874a1658c2614017c63935edfac205a94127d689c64a1c981fae106d45faef1c07ca823d2d0ea71a4c38b44de853406282a356332c525846445a2e4f75c176d215067fa34bf63d43775fc2c9fcda474718516e7d4d8faa9a6d5466c4cd95d3f7e19a69805508af3cd9105b0bdbc9ceb5383e6cd89b659b1782d66c23a13a75028e2cb05214206e697b954cc839383d51762fd04e1dc2fd72ab17717516fd45d540ffd96e8cbe29eb0cbb2667f28787f4e29f5d0201a74ac97e51eccedf4725860715c3bb55b4b9cad1ca467f9759d6453544965e2188b7d835ccc47194c39c9cb9694bc522c820f90bc839c2edb6744ef8a13a1472365cabe9382eeee164e921eccc831257a9046dc15e53a2be6067b016a2eb108434016d6e3ad9f9d526bef0493f9681f66362f53ac50ac8b4ff26dcc376f6f305c9e4326d110800c103040fd49167a21b504c8568a508cdde98ef467468d0bad0899907090824c9a7eb755f0f153b5015394b1748a7fb38202ddaa4a4eb339fd8b917e49b8bccf246b825a14d6e79c175f5e32db488a5982564af1c9a8370179b93ffdf65b26a27238aa46f7fb1fc419bd54013ad17492ad83624f2b65f59eeb7284c4822fb19f53d63d3825703dfdd94b254f0a37929fcb2f02029e65b59f7678262d556221d798fdb14508c6a404fb0130f78ecf007260c8d3392e2b2aaf9439351b1b36f694512e3902c94d64657a2201cfeabe9c219aee8a19ae4b29bec1744c3a61cba6506164300bc3d8f7178ed38304a87261aec881c74b5c2ecd82f0455431756a7446f45928e6bc1bba9ba02d158255dc5d60f79a51d7f1862859ebbb511f4749ccf651eb2486c9604206cebbf8e2a485098f6e7a00496c9ce0ab060a2a5abb776a5965524f8ee25e16ac7ed72f3d2027237f351a16ded078ac2706a7b0e1e5f41fd58eb346f772cf62eac77d80e47aef4918fbc2431665ad505d829c5dbd406fb39ca91ea318190a739a7fcbb91382856db52ec3125c9f86fae2a6d247d21e7ab9ac0a460f73d88aa936e93ac3f91c7c2f7a0702786fa86d5f1163500185e75e450f806d6fce27861234802a86a57469e82e5f1eef0a603d0a463dba42c46914294f952f78ac7c8cfef778c9dc5a1775285f8206f53476621e28283ef75f06200b1d4ea773d48afdc64bb5b959f65c7799e98c1b41213a3efcce7ad26bc51ff48323673541a5ad73886cbe40381e6d9142c89f1b62eed9f287d441af61def0c966945b89d8cf646d75acad3317a0553d13b06f5a54c2411a08232f8d06656c82f32c4beb834319fac41acca6e00b7ea20b716ffe280805be685e13b99926ab8155dc5a84bd6176da34e97a13b5af8ef73156520e7a5bbd0e71cc55a14d16a5c60c42da4493f4eb26550ef76c052a42337f7f0c3abc10964e231a7c26e630e4f7958f60fb2fed5970b6eb412179ccf35122bb6889066e75eb866f7292605159e21827b756c32d07f3c35b2e3eb96bca461004a1e76a28312577fb806fddac8eec8e112adbdda83dd02f374d8887844ad52d052b88a7f0adc50254b9807bea3b12dbbcfde9520f2d428762198e6d0c78143e1d0993e557bc451f03e7eebe2134b680b9938f08bb47eabf8a7009013a89030ea7a14bfd9897572f7f0b6ec790323b3b381d83c5cdc74a963f96cd34217474c7b0e3670a6f52024a1558cdec610f194e0b57de39076a347fe863b72ddf38605a456d9d3657b4b2e3e434f25d739018692abbd5afe7c5650123b2e698029c3c7468b6cd98f5d628c0970432137911cced987abac0e2673ba6c3c1e0c05c93dd65ee3bbfb02662aeb64af0da8e93765fddd7ed2e37424cb5cd2149551a0c2b0d48f2615d9e1870f1c749978c9964c8d6efb49e347823752811d1e1c3d167ce2c9f2e25ed33cc6c8a69760d57eb83af49bc9d7bc5d446f20079934566e1db0c251f5050d18a18a7241170d7467e54ae81b604584186fa45a79aab08cc9976b594d0d4a084481da218f1017bf17b46017bbd3c10103632fbd47bbe9912d64793911f2ea7f75398a7dfc7469827705fba05d2401fbb4037290675aa2a5ffc42a77a110eb38657b1e635da098b38e054423d2b699426928eb1e38d4ce8a52dcb77eb29327fc6617e8273288656acd32cb2e4c8c2b08d491c0224ca4b5f8b03bc84782ed99257d517ca8d81f4049faa693872201580e77817be43d83415677a5572c268f2753516869301f90487294c8c9b20d97bf96fc6a023ad85911e440d93f46a24b8c67d2740b0224d51bf03031844340ebf02b261684f9867e9ab1565c3b8d5f4e1a9c0a924157ca6c81f3c698dc60a3af9c7d7971a34b76b9559aa36a2a3e5bf06ebebc2f6c91d12255126f5354f7057e9cd3a2329f04750600dfd1cfbdbee6b6a22e5015eb66773a7a18047f5c04f9fd8ad4ca328fa70278edd1afcf71343e917d55ad81f7c64e664a3e78674f84d48ee124b290e4775d295f89ae07ed29022de6037a3aeec2a7c15a3a04a7bf261c2b9d3ced35a44cb63fe27bf466d90a939e2c3505b2e5a6c7fda976b7a4f1b5acf35cd7cf2c4301702941624a732b22df0144a7b6907adbbcda50e0a243cbba29a4bd4020b34b539cb31c52b188b1cfee54879d64b6f04e727cb7bff1a4b7baa0f444538b105fdd8d167a4bfabc66a18257e556480a8dbd238834fa53e70460091b18dc4e30c3c538060b95c93c7963a906122728d51f0666a123c8812e9fa4078a8f4a095c0c3cb2af7d82993fc9768484770da2cf478adf8604b7c02be313162c3a3666b93c039863a02325c05c5f77009438b70e96942bbd29b8ebb540bf9f6850b4383ea9b2b8d1ac18aed5fa5b7a42985ef0f8128a6d3465edfe772e56bda5fc50065a69271e7061bd72632a49c61a453912862155f4bedda48467e4837a1afdd10c2e3bcf5bc6d44e5bdf9ac8ebf5fe82404d950d3b26b5dd4d0da224a3af806a626aaf8d1a59aa00f7ca36a25f6fdc57647f287295eacbd816b4828dcdc730106c7a700090dbad6d616567156f961c46b190138e71f9a6638f886413407b94e2310d7f20bed86331582d218133c86ce6cfdb979da1907864aab51c81a3980bb25af84804c9ecfd8b46712de47f8c3f5a85ded5377f759c77cd6bf78012a75b836e517f2b002211ed5485dfbde65d8a00e55266ae7ad3b145707e5e2a696adf6528c94ad6d978da6f1b1d95bc552c0f14b51f8f2c7d5ad957fdd2c84b479b227d141ececf8212e561c0cbdd15b90c96a24cf31d040e659777722e2e4e32033bd86067ef479b6e4b54543445517505a5d66c3cc797244c42d6d2e483329bf8dc13bb3f175624942ee67871711cb2fb3a989a984c16f5b5a202756fff7461070903a10ab5fc7d99144fa5145b9f73b7a064136bfad3fce0b98f7524400558cb40f5096e9c7e180fd3c2bbb214a7122db018eea368c29a023711d3bf5ebfcf6949443c9a9d5536d258b562a1aa449f2ffbe528ed6f383ae314e2baf921a2eaa5dd0cab47f2cbe782f833b48da6f613833d147c48bc99730ffde2882080535041b4f07a875ed7af6723e8afa16b0749ded1ad4873cc119113ee9cfaa080d6bd8de5263827481a254d7f96cc989a31c5de13ec8a7686c89ba87e7cbd3009a54104459b9d94ffebb49036a51b8117fdd83ade238becad0d8a054e9d5e14441cdf7b52e10f9b0dd762ad4cf5b72eb16168f1dc12a9e021e1919a4b9faf97aeaf6ffc4131a96fa8d2f944f0fef8c97a981ff40a84ef837ea19d6b4a952740b32cfa1dee4e5cd55379f08c90c3e3db77ec8ff10d27315a6f918c23762702f9a102309f0e5929cc5814e0b34cd71c40244fe227c6d574343d56c5a1045f9a3bc098d7afed92ee898f6a88bf1cf3ddedfbd8f344cdeeaa14f7fcb15012252928c13df717cd71de803d3f5fccd9fd7c38b17faaa77b72f822da700e2779cce53d2f45a499481be00afe094a1d0cb8343c427198ed8d01ffa5112a0cb97615d1d94f13b4bfb0774fb74ab5130712fdb9836014bea995b0fd35499a425b71dee88a6b27d7ffa42fc4a0356fb7c219a52f837d7d48715e0462cbd3b07a7a01072dbc9a33384a4b4d83225de2267df0bba2043299f46b64659878fdd5a1d72a91d5e1486494baa55cc9a11a81a87f383d2625146ebeeca8e422e5fa3440198422b0429d41f474f331b73e13fcc748c8187526f391934508feaa584b505e40c9f93a2155f511c939130ed572ea058272e35603acbc4b0145a2c9cc00bf6dd84324f53b4453704497722e086a3dfdb52a8a07e89f3a95ca583dbd0d00dd7982864d4d156490c2b5755e3f0d28a0840e6c935c27bed46b70dcbe936dbfec1f70256299d935cd3f69d5f1cbd4c51ff3172bb0ec75b4fc4ec8de5c5b0a0fcab018672b7ccbda32acc2279dc8ef96dfd245e12d38ad9cef226d1a0ba4a788cee9bd2609733e85230892e68fd1c0c3240e5061718758f499f4c6ac950767772cc1d63ff73f05699b0ea0bb3b1e7582104c69e814ad387923121d3b2b602ea48fe95985a431d715e4e509ca573742bee299693d40f78c1fb42646f18d80396f997d7559294168c740e1e376dd827ce94c01047800cd7feeea95a7d0760ed567f56bb822882711d8c1f4b1b0ed5a9f4d61b442eed736827710572b502350e93018af4ded9a3347e6f1c651765a9dcd89f2024b808e5ccdad3bd2a39848c71cb4dea77f0e10d454ffd3fb8b8229fa6d0569063d64ddf97a48a5560f71bebc2de73228e317015008570828268fee56bb8dd83089be65f42f758424a0bf3f545a763910aadf32fd6e2ec4c42be25d9ac4f2676f3165571f33899339b61df61e3e3c043ff0c0747f63b32cd3f9290a44a7943fef043b0f2e135c81f13989d568283632c94e7c47b1c1df5c53c2285ca060a1dfbfe0b79ee916a88928eaa9287a0ec716a049211300ff8b62f44192b35706f57d573b061d900c99d160f12733b1bfc601a91e87e4a06f016686034d0ff76892684a1786293bbf06a56c5e0203ab7c6fa5f920f6e4a5be0009ee4c55cc0118854d5884f4aeb927745d1bd195159c8d701ef8905c5b07c735a33f6063733a5336d73ee0f3ca44e72a6c2eee93121b6dced566cff2ab787f7ca603010ecb3d5ea17a58a9a665464251df8a75d7c3cddeda3610c40d5f9b74c4507e42f5d8df3fe7f9e66fa08b7b1708da8610d0644a1a2889051eddb9f54678f4bca0db42b6403040eab2afbf7c5ac5b4565da1bfc1b0e6137dc80bea515ad15b292be49d36359ac156a0de06dc3b1f8038c9d5a827fcda2f9820060a57cdf8fbf1508812b321efd8f86bef79addc1353add277c2efe74ce57b67bf3388a38972b8f3b46186622cd1c72507af4868dd0f0dd8df907194efad4c256ee2404454ef622986ca9c4e0c2606a80ed078beb77e2bfb03e6f3947907f5dd5ef2feca419b3189ba4262b3bb8483112a14c82e65ce2da5ec7879ed27ab63bb0f91a56a6f0f4901ed785028a091d2af3f462403003cb1107669762a1158bc85b00213c96ee22b2a4f59bbdb0d886976379aa338243b241264c6b7a7a9eb361991a7767587522fb5457651d7e4a9e9b78c58878c1600639e75c866b4b9bdd50594413111ccaff1e99f7431b031ebc04407acde091e532666c209f3e540c20ac618274d8ffca776714b2aac805d17f07c1b2bcc1a840531729b89cb4f0e95c46df75fa4009d76f184e54766ca0d17174449b88855139f562e71381a5e255e8af9be0fb296c7425392d1368f5a31005338c96345d9155c597e92fa769d12b9356d213aca4f15d44a537e47343e6162700d08533505664c7ac89bfcb9e38cea1f94fe8657e67c1fdfc6eb89675e0b834726c80520891cdd93fc02ef60b2e3c5ff74dbdd71900211ee5b5b7754956e4a25d0232c7a72c96b71e3ad3df70eb205cdc13b8782518e12efeff02ac38bc661edc613f8b5ea1b3b0c8a5ac7090ae3c36e64af4f9543784ebe9679e2cdb4a93789c539f8d5fdec2dff0ecd288962762285192d508ba33abdd9d6b8d4d88c0a429a732d18494e978b5aaec1892ccc407e4bbf8ffd86ec210f2c9a860377d9dc4a61e5f920b2141f60914c335e01f1a3918095bf8f89f10932fc7c17e1f0839f2001e9db3bb0d4811e887b87054fee3ad2e53aebb8db65080485d5448b183d586120ae9847a1d7ae365d65209fd6d54785d59339414c97397d98e6b7ede9c1e3f438cfc48dc1e8085a5af25689309ce473411f62a61f8dd554451321157601c6e500c48d544815c478ae167596bc8df65ab351782a30a5a820eb5d0bf115ba015ad9c8d8ce83b791f6e82ffc6ab9032304c03c8e282060bc7338e602ec9d60cb9982c0b0fd936d738f2ac7066dbd2a61f7681b6736de09002306a07f5f9f1974e5ec86036670bd4d761ce3fd055415911b05fccf94d0d4f0509165acc3a1e22685a6fdc4fbd86fe35ee0ab3a9a15ab655c80f6b3f6e13b4b7e0af5b552bea0b7a7ecf481f96701218e04e8e7739967b64a26d963a1167c9b41c07bf42f6a5e8b56778fa5cbb1a035e46170458bc4297d00ea382a140f5bb17a78c8fcb61353693b84ebdb12be78e1c18ed756a48f463ef47f3c53c575afbf3e31b787287f19d7e399c6543a4e8636caf46e6909d8c0b4da4dcf51500a01b75fe07439b520e96e4383c9a37b325b58e1908c629925c1bd3a6c7d0e8510d95cc79c05f8ceb1ef23b0e10a0f4f98ba51137125a09bf69637b322f26a44c0ef891ee6f09b86a38177e955113d3d8a79a1eec0c2af7126435e3d881571610fe6e52301f03414345aab092e0f1805bc91ced857297a0bf7d19fe9d3ac02fecabfee66bebeeee50ee93b873493174024d020abf22a01044247057f406237e52e169dd974a1fe591c92fd83392b1cf96b5362232a7034491a8ec4588074e0169bcbefe57f6143d94d72fcb564f4cc9c061ca3351500b440aadd61e4a023343fd9cfa6e4e6e7cfd6beb5cc382b9edbde2557511a997f7d6f573e408a593d5933bb856d036765e65c6ee0750510ce4c75ac20fe0c6e8b707f2702b5dba4b22a1b85737722b1a7f6b6c4e73bda11881641ebbe50d603d6f47b793b7228f8116d9109182ae71e9f927c0c9e2d8a08e2055b00ab13b9c57f50f2f6cb8c2240ce0e361c3f809f4838dc3066120e4b96b798a9b9197092fb3e53729003fddb96fa6d923ee8b3fe88e946e3f961627f06dbb5340a528cee9eb7eeeeac9f98dd9eac8af59badd5706b3c6aec582ed67e00d34e29fed90196f983097775f4049b90129d9e04869ae8a7830c2e88ac79ba5c2c77a9057cd2bf83877f6e752e0c7411b8d53757a0647ca2b4af582c2fe0d399c0b13a4e9f623f62f72bb48c100551f9aa5edd0f62c4430655bfc2d7f2a309fd92e192d26b0f24bae344623dbf1fe5e793c8970142903cd01187fc064e176985ca2a762c8295249084ba5f74bd1e950b128e1f81f532ac909959da725455944a32acb2ea95aede3a581230a416def080354307e297113a3b0788755265cb08d51ffe869c63157254f070093f886d56e59d0a2e8b7aa3906472d1afe9d995ef92dcb9ec25d89222adcb62c56881a3ccab4251c3d6284732c32c0f72688cd7be696792bdce261a16575df818c8b8cc865dc7a49f7da4981dd7bbea7107c162767ebcbfc40151ba2561636f4d974eb03d98b2ae674527a274371823585fd0e815174c304ff7ca5421cfec4f03938e8656f9bec1e887cc6bc422fb79f3de43520b2dd64a985fc767d53dc0129b7da3f412fbeafc07129a9823e5b5f02c120803ef6293548226289b2440eb3e426535d3f77a586d8ea48c82508024b01e3ea26771432287a597d1098272dfe14d562af4f71862249beba86c83266eb0b82fa11d046bd3eddef939e1e2dfc34cad163d762f7f07d045c7c38ddb00b06e07abb61cfcf818f2fa1d05c23a68865184e8a8cc0cf30a67b39f252885825d8abe42dca1cc89fadd9d8dea7668dddae5754b0a2e595dda8f2847a955340f7225d95acb8600829b1bd7fd5d1a0c99854d6af7cac97ecc88970bf34f96e64c4f5d00396c96de593122e9cca05ce4e869b28827a4ab08dd86175913a00a39f8b9f228680aad31cff8fc47f874338afad5c8dfe514793da61de5ca6399e16bfe47b245ed26e3b675f28d1ce19505db144d947c06e4a50f3bc9c5510b0bd95333252f64690cb9862f5177de0a2711c58d86b34363b1e45900df72994ab29ff6384d10fd44cc3f78f028081c31cc1f9bf4b7ea43052754c95a9c69e11652c11f6bfb2cfd7352c0abbd05d182659ba3ec1773b3b810c159c05ff20158143643662c8cdd4e36f009b53f81dc96d0310e9c31c0e22d51eac8780e9fa12e6a5867b114a32e95f6d90441bc356859388b080e5f119670f113b7cba65cb599c418f76d1f672508b61c7ce3b038e6d3e81e381da565c3e608895027bede2e45f1179d025cf474ba67e38e8b8a32eb1647925e7cb4aaca00fdb480c493f23e96cc31816126d391391db90d07c713e73785971b0462075a784b7b89a3c732dc8fd8b33ff261f30c6fba359b09979bf2541787cff067678fd4b8e7f2ab9046f4f11b3a72550755bc19e845a7e4f642fff563c42fa5c369c1e5ad4c203e50437f43fc55fd718a354041258bedcba4ee1f4acbb7b3c876938e4f8d9a36010cf3b28794bfd92c865cbaa4e1e42a95d4139feb1a706d019918ed88291e37213c2d9e522813eca674d8bfccad43d420bbf0f4f27227828b91b8be2fdb82511c871ebe5d09bdfe86f3c0b7bc4fdf6922f625758c427cf7de9c2721b0547b62b53386ab128c9bb8567593d5304eb6685349fabebe903972335cef6230042d5efaf6269fb85e9b4dd8b0e698bc3195973e893cf126fa64af25d6248f456be8f04d5c2c216cfa5857ff0d9aa28292b70a9fd1ce5f5065347bcbe4f0064878671c05c1db18f742b0db2c3da93034543b7001c1c1fe618b55b9d98de5dfd04eb1f90d4cd49ffc16cccdc3f9dd1aa902e8c1a2a7ae2c4e034bafeab553d6df3e08837aeb456318260c67ed21f49d1781b7b73bfdebed9efd416ca1e39089013c896384f1b1bf34e5204d32bd633472c572e00d176a9477daa7c6625f9b74a0cd29e5ac152d4ebeeeddb2e03d743422db80467715629bbfb200f00b20986afc64c4e8310abe32ecfbf0f97e6bfc0fdfc4b6e559e6646f1dcf2c236b2d31fd0c300babd88986f2299080b22a63850244089263d63fb852266c94e96eea6f7bd84a2d69794ef7dedeec2c7ab3e4d43b544bbdf5fd8202f9f9112dd29982434a5ff2a5b0bc4889b3a5c8c942fd2a6eb25482055ea3b111d05afb40ddb11c178913b8c1940aa1a319ee116ef0a7418206f90888908d866a60ef914816889f2800ac2e7972f5da576ce6403b27577b316","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
