<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"054385f82f3c9c3f6ab148ca157fa7456310fc2a7eec85b7a2dbe0f70e7315a18eeb245bb1e535029ee36ca688b8424069f916c6871ddec0d007ce5981d17e2f26353cff80814fb9ea53aa433d8846d01917ea1bca635ef07c46a22ba4cfd90f84dece77894b4b7670e012664980697d4d196e7e3ab495fd4f2b76aecca41d0bc7f22b706fe4dd47f5874646d0e8c6c19a51565eb6b0f43f1d42c5e35ba62b3316c9ca162ae3ff9c479b3db0d975929766bc758c4658ff57d04dc6bd054d036737cc93b6d2e215db1cdf6e3f110679355965e1be38f2dfd11bdad803b633fbfbd3c4eb4059c253530d7357ea95974407c112801422310f111b50290477976c3d02d500b55d51c9739161755d5ccb85b1a6d6645ec8fab64a337084b4c4e811380f08fa24a203aaf8a5c25d033bf50b7445c94dbe914f26104727839845104d05af37cb7f646727f80c8ae1884fd55878b3fb11074560da21a6dd1c8616368e7953347a0d5eface0a80bef1f689e0efb2c5a0b4876a84511303d2880a5b0615ef8227625d4c8dc6265eefbbb4233055098cdabc3af9a3596e83d69f27e9f2c7a2eec3fea5279ffb3af7f8bbfa2f130124df703466fdf8f341c7b4787fdf79c28215ac7c50929b9e9c9bcab1aee69490ea66c86d71916845815f2ceedd3b628318a1c2563d8e3cda484cd168e16b728fed36e3bc7a8f3363648ae7804846b69f6df718fb59435d2da9606816ffa914f37c8e501366dc21f4765e9c3ab391155acb2bd0b2ea3579bc0e18d781ff586d506418e1cf9b44f8a810b7543cdcf8f92072036d4d6d5565bc5abc72f9669c7a48685cfbfebc4a8ed4eeef229cc5b43a292142c76c2b1928fbd09e78dcb9c4f571e6a80aef4794af6acc38ec8ddfb835add7369024ad1f680a15400fbaf33293674584f5fa3e21c5140ac1e96c03c5fb1bff53ee48f81844d575212bb4da971f99ccd3de4b38b1491bf1942b6e28b9813f15ad575c070b457d36908542e4e354cd6a61d04f5cd6d7d0623f5b52b1945541c5199c67b9336b71d39462880a184b7b625ea9a48456a9b02b36b696011bc7e0fb13cba72f2caefc687217caba48edafa76586a54adc2a9b5fd134c5d6ab5ce1b78f3d7081e97e7452aa5899d1f72e1ea2ab4fa1782a9a582e445054dba73a25bbfaf50235c5f494a7c52d787613fdbf26761d758d715d17eb020637317114fe97cd7cb4e22cb8e01aa22c8489825d135fed32e5397095958b396a869b22463c49fb4ac952b9948d2e42a8aef81567690c72a9f95beac826e83c8cdb87531357081f17bf3526a9c0551db4546056349db5892c07ae43fa156cf5bae3384f8ad2b2ea2780c593c384b76a79803ed6a885cebab78aaa764a1e007a96fbfac3f035563a11d62c6498fd13ceea0b1e3b86d419b42c3f9600cdfc3a4a32c882e7e815da6166fe318e47998bce9f9a6f404eb9b6cef547f7a03d3b35d731cfe96436fceca19e1bf05afbaa304c0d65b31069fe4b585b785ace77d336f7829af567f75c279c28d07341d1897cd7ff41df4cd3de7161c8f7d67f72bae9a8aeed4a0e29d03afbddb1c505ebbd1d9e17f973863f3309c4aade4f54b5f7e2f3e8bfb2718f40105df995d385e0d5f85fc5cd0de5b7d8862bc506999cb39482201b5da7de22f384cc2948ad8af3214c18697b7284c92db00b59bfa2facc499711f993063f68b3a8f24406887d521c403d331fb9c0d3ca95f077816fb1d61770f8c487296da96e9e89bad796719a0a837e27608d827f011cc64863bc9cfa38caa960999ce95d847efdf421913b74f5afa21297d6960ddae49b98e5208483d03fbb44c3c00044664c802883878625b916ecfee7893954f1ca7514670b16cb05a5c2b61a986993fbecd80b5de204dcbaa993ee9af6a25d94d7aff3cc6405ba011e58def602829e85885ee181598bc000d62d7f802ace4cc635ed377e7dc21acda9b0c6a8809e08d3456ec6ef1cc45274e988266b60ce0abbd8b52806e7c1cc8538206736fbfaebddd9b6284e21982a264b51896260b7445dfd2f02f78aed791d2db9744e6917ef644d7a9d303a8ccc92f8d93a0a9018bd9490dbf740c7e5e55e0d45e15edaf4b811d3e392ad9c9ee5a343faace5493b5633517fede4850d92052a5cf16999ea9aa01cea7b9d35127af0afa1424b4c571d11748b20eca81e8ac5c5478d57daf333ceef543b4aee08b732ebc901d424a62a675be93a9242f954b48eb83e0f7fbb13a189a434d17f5b8e74e9d8993b21daae7c5ae7785282f51de348a3127cad11e1bf95bd50a3ccfa732ca8825a5e8db91137b5e3f60ae683972df4a869f91687694cea5ccf43c85ed5b8025f429d57ceddccde33b1dc221631cf7ee28c73d2ce75468c68098ff0526513231a758b781fe547577d26c7c7fee1f63876b343162f78bdd9a19d4e346dfe35c094fc6ce2940f7f681e4b24f5af5a9ae1ec4dc62d975fc45ed064437d44d3422e10509814fba8a43bfed85b02965060bdfdadfb1987cbed71ce8ab28f314402b959b2115dd1dbcf1befdaa5fab70d53ee2797ef903ec3d81b6550f3875f057c48e141a9909a217a1a23d99785d1ecec69daafc23ed4b6a323086d5e85d04b0093189786b28c7045e5c6aa53d60bcee0ed1c00d1d4143cedb5d66fe915d2aee663d74cfc88bb084a6d6b3377947e301e9f2aa8fb0c9c3e92cc240966b3353f200d69c825c1a59d1edb5740d1711df92bfc7c20c7629f5cbc8dbdcc9331cccecd1983d6ba00b07517b730b4e582ebe164ef7a7efeae23f7712a80156577fb87427e2359d2baf7ec53d6794f5606e5670ec82f211be7d228d103a6bbb4d3761a88163a30664da251a377dd092239c3d7f1f1e43343c3213a4e4ecd946e06b2f2baf3783f11f46ff884b1edac054aaa2f535444c3c791720e5254f18499a086dbd0d802313f0c62fdce1a3763bd17aab7c09b8d73c8981fd5d2779f7fccb79732eda74c2922f388b840609a17936f2ff87665ddc523a8dcbb5c3ec80d324ffc98f96e8812390475b5d6b40795382bd7a370a5676c51dfc57e62b9a8a2c70480d4bd6cfa29f71e2d310fd48e6e8eff8611012c1ac4216a30e7f33f1cd2e6d88109bbd79f08dcfb59e2fcc0ad5d646b764a260ae7bccdf8d192fa45837ce34521a5760310f79f2b9bd2344637c16e9d32ac208def3d8d9cba670020738a17f1aff893677ae02d212924185186d3d0d634e643c45bdd2c4ae4dd0d313ef753a44149202b384ecee26f3e911c0bf1ce1c3f94a6baa9bb10a776bd50fa27b6eb87d90d3c25c3c45cdd05fb4fb19d05f0619f0dbd2f95ebe2f96106cc9abcdff5a05d0d9a05fc3f882be26f5d73d74f5c6542985fbf412e81673e60974c20629d888583366c0cea0e1af8e36727394096afec1cf442daebcf888a4a4af2106ad87578b7c593f995edd0735dc69519a9d53ea48da369233e4e7a461d460acf78bafbd07c868c124e23a521ab8796bd1e58ef8e97e9bb7b4765bca2f8b40edfb5d186cb2d934972d6367a597cc5733c587a636709ea966c89aeed2e6b2549ec6efe9ed6446331486b83fecd1e5b017113ed786bcebbb422b28c5f0f6212f56ddbb8ea7440aaa513dbe9f158e8a6904087f059e3436bbdb0763c9c301f07c7a2805c609a09b3a114967855b3347cac2aa7dad241e87ad2bdd9a13349388830d75302de583cc4b4a811ddb0835bfdc883f9b2374faa93d30716fffb4314ec28be292255dffd087e4cba9924698da4b9e10f2f2301b2d6a9e77280c0b8dbb52260a364573543ea08d9b95accf6fd70b6d7cc778fbc66480b22c5e0d3b1046fbf09ff188cf87f028ffdfd214217ccb348a5fff69dd3662f7acf2dce12a0b4380995e1527f6a4d3e0db029eb46059721a39edaa90532f75141a3ce48aa3e8c69ade48a03bbc8b051b1c607d25bf080c2290d3cbbf8b26277784e764e7cd04c2bffd0cd136b39da4f5131ffbc59265889888cb2f1e3e565743b0a0948d6f23420498df00a3ee00da37af9997690ebf982bc8e9abe6553ab0f5b81b70009141ef5af053546626a124d0a5af108e053b2de6bdcb7dee1e3eaa78a9c5b2a882622d553a1afc6f74e54067aea4a4218c5ab87d6c2469b315ca409c8a5d0f9beee3697ca175642753ef3a714ad3b19ad1538c734143e218cf3d59bdcc84b42f3536600eedd8e880a58b5deb045921f3cc43f515714518d515ea72124461aaf6995579bab9dfcc04dafd23786a6771dda2af367b7dbf44f8a3258cda0981f6ff46ceb67284340082da8428b30bfcccf6640dd944e10532b533af3e1cdd1f9689e1a6e6872ef6b7b4b7d19bf20ac02984ca1923c7fd1db9d3c2bff734c1a1f072b6d19722859d4525af00b5687e129326f28da2f3c794437157e3852577d15024143cda2f5c6627c2f114e2a9b6304164db621cee18b95d2f723e092f453bd08ee07de804708ed7d893e348bf3c4f87ee6be9d4db4c05e2636a3820418c81af200aad2f8757ac45b7e2b088d3057ff66a56f69603346dc9c204cbbd8172ba94d255046ea233a1680cdd453ea6069b263ed388855cd576d25337b2eb187b3066bea1051e820222f748c6ad9c63884569b68cc42e3226e26b6e212efc9c7a3c4683d034b157b7338365685d830fe8e4386172fe13935c62ab4361341a3cf71836c56aea89375ce48a87008b2daec18647cea2c5e0d25e5f2b55993f503c23204e0bd2be7fdae7f08f5aaca10c95dca5fdd2a3fb6fef74a9d07f88ea9cd8de24d269ae507d0d7c7efd724d5610408e5626c11604d4f1974d42c3b63efafbae82ae8a1350c584f4c99be48d87ade502eabb50d0c715f8bbfbf10cc3c3200c201358ab29747cc5641fd240144d5dd44e6fa31bf0593c028e3ff097c3c3393284f3e557e2fe0af1cecc378f48968c3852501209bd0b727c6df1e576b9fd0433d08ba2abe74116233aae2fd71f9a872e1dbce3592e9d347688618db26b90cc2a0082b7fd5beeac2b18a80aa882df4ed0ec4733c211fcf452bfc0020d71bf6d0f660e2d9ac6e33bb9e6e9dc6aafc35d22652fe838572572b35fc82d9e582948d55998793f66673c904da3ef5c7fb4836cf5a726d8a55cd6a3f73611fa67a4f792a7ce3ed7d6f97c8c8af583f2f88d1c7ac3ea4063ca96dbdc124305d73f0f546cbd3bc1bfbe5f2ca427f5c17992d67bd37b17c126b61147281708042566880621f2352a9db1aeea54881fe98828437f8aaeb85c8b606c702259f6b75d5da066cc6d76fd6b5d6dbc4e9adc6d5b6fe62ed18623530ae9b3ab9d38121a063e97be9bc23ffff6cdcf46dcdf9ff94b5061c592f9f4998605a947377517ba82f666af1a536abcb0ccfdce684699863e4db3ee2e33c2a1c174c23c05bbaafe1d2b558b6874b8e7610ae50aa91bc7bc466d7b74f736cbcca4ffac08f3b61355a921503f38ed6818b866940b0921c8be2e0d099b940b2bd47c202bc03445cd0c1b5207ea1c4766155b4fbd045e32f7404cfb4756a247517c650c6730ef7225d427d0ebaf857994c1bf2129e7e385796e6066b1a615bd7ca2c575c3569730fe7994499809823def15889842b492a93277c720f21d5d89e9015ee0de187a11edf286d4b2b4806a73aea85b7289cab4861ce5b27893df456dcf7166012f2dbb0bd04ea2a4099d837ac67e475cee4623683ade3781f52738cf097fd1f98b79aa8caa0ae4a6b0d337ebbb8a2f15a0ce22b3508a58ba9238950ae2766b5dff74100b980f6f2df73c07720943bae56dfc7eed1087c1553eb537988b60a7f2daf7c512a669fc4b32758bc80ebad853b15f740fe8ab737ac74eeaaacb8121138d216f25e0edb148e88de56c9b3fdcc66da107804067ff3397a724574168d3b26a61e818acf853442453dcba7924505bd0194b57bc58b12bd9b1f332d309566c06de0cca41f27a9c850bde6d4f6b26af6961adc0ebb263c20218540baa5cd8b28f2f0db2e99994fbb07c50dae709ad1203db3e4ba6073868732020a58cc5c779ffee877236bdabe31c7ec600ba361565849a5c80299e3c33c6c26b1de7da5ac68885a72aa52d6bc71bf78b1b102e86a76c8868619efb5583c5dd8e63eb0c9adea5eb685e419ad41187703000eba51da1369a3f7f32a077435c68a745ba61577252df507ca287cd4bf68d778338a482929d9694dd233ea6d067b07e210ea1e158d7ad7628ff142d6df1f38f5972a175a9ee28c7bee78f1a9fdd39c1c897adad0cfe20adb9c7012d0f65624e34d9e078adbfd9328fbbba8f5144084521d40f055fedba32d41beb36f8ecadd1e09f0bcaba10d1b73b0fc62e4a3f51c0a1a2a5fbc96c61711c1fe7d6a9f9333af57139edeaf8da56df4615dffb3c431c68fd1b3d890ea354d7b416836cda5d28f94b01985ea4cd1fb51184a31d1d3ff54705479d29039d08c209e87132a0224a2775686b6a29df0c05c445e639544b9c6fb52fe7a4e9e48512b4b53f8a2aa78eed9d0ff987dbe762b9edb8620a3fe258d5e1b7d4fa4c0e34563247ce76631d77b12c9ea0c7899b6af16f55d53c7ea7ae1759c9d7c7aa5ed810f43c5e5f931bcfa929e0de5a4fd2073aeca8bbd0084a1fbe7fe7e164cdbe22b04c52678899f17b45682d89e9c9e7dcc20dbdd271f2a30c0b314e22d7d63bb468a2dac95c21e714392519fd666180b07d25f23f8cf500e00330774d74d0346c4da7e4a1c6f2823dffcbd71a9fa3f9dacfe9dc776adfce276dc62aa2bf615ec143b4d8e02526faa5c1e7344251d3e3377353eddb38725560be412622f1714abf2730f59dda742d7e435b0fd0d963b52bc4d0140be2d31d0fea36ae074fc5a1e7fd96a21fa4cac80ee4f9ecca8a270ec6ac5d630310b949681e89e5103d7d00cb743dd6b0c938a2cec84f11081f5ec73bff5e500c9f9df0438c5bde98b56fc1be79c38befd5121b19186c64b6f3439a1963250529e56075cf1db86102cc9b171359e792aa8628a9b89d6e3e551c3fa2b2edc66e84dd646625daa2f9bb9fb03a1bc04f1753afbd7169f238e672bd885d1ad61aabab595694ea75ca5149425eba21e5a788de346f303cdfab23d596d9b1cb1e4bf0ae597ff03ff1c1c0528f05c2ee1cb41c0867a0c1d3112ec85a986698f710b0b4ffd1ea55afd28bbf0897c403644d353ad739d2652af4b67e011947f2500a04425850e1ef9e4bfa7fbca083d229434fb728bd1faa50b7b1588bb30467b1b23d260cb7e8a12ea93d8f0100857095eedb7f9aa50c94109a324162f3ace265ba709b1005a594af3448a4be12ad61b009ac70249d7ac24b3593fe230defd1d84d8ae305ac4ad6427969376ff98359ffe7ee84aabb32cbf3a3474565784bffc06a477e28a162497b7e28c946e344f1803134eee60523d6f060d59c6549af0f1e356cdcca3cc6f816158fbee4744cbc608da7f1f1a0428ee5e6cd81c9b55aba36a534b9b63fabf7adbf5cf5f38432c55ba8fd4927710b602911fab93481fd80de47369818e145a3f4d47f5d17d375e66cd98da9d40a0a01d933986a3ff6e37e409bf6c83d92838a038951d8fab0993866b5cb73ee6a7d74e3f35d7655eb77eebfb390bb0d8c04eb6a6f28bb4c6f2570bb919f9b190138a19f31e59c89fff9609408520ec3e1747ad94998bafe441a64d4a9907c6f0ce14621f50566ef0e0881f3c062f0bf39ff7fece3525805b5eda81c47c637e52bb57203cce23428b29edb3a16df3bba54d219023fb97c2818c9c1d8f951831bbdeba6340c2762ef61b573cdb4dc48316c46822fbc0d8cd4e89d05f77327cdc3855d5d793b04c2980e325bad070a13685eb8a012cf32a524b72cf2d7a27d08030b4520a8f7649ad90a19bcc1ccd3048cac1488534256397b2a37c607ad2d66b332a5886be87ff4e4c7d5a4487e003fbda19d95e432d0081742a4b937e4a738dc2c858742f908bd1584c69f3ce6ea8dfa3d2a4ba78461c5f5d0bf88d1e612974607f9212289362f79428589a37fb2fd78a669aa9b436e319f5b361c4c49af2efcacc40559e82a420fa08ad224d9687ac66cee486f86813e6932342b3dc62e3fd400027d506d777f1f48f5ffcf4e8f3e3587eba59603f1c97db937df56fef9760e90193be837783b8d0cabc8e3316c77803ccaec0b6745afc8a5d0c2fcc9fcd88e02acddc3a5a66887e490ff369990913f403ee9cb2d1bc975866a294d12cefc9cf5cea9eff5fa41ee7b9d5381933f0cc3a5b2b9fb8ddd462b5aca458b349aea88c99ca3bcc0a5275087aafe03cd0a925bd1ecdc826b32f8b31c5ccabc00f3f3708133c44e11d7c6134249ee7a7108dd62cafe0b7d194d1eb56924f81f6314315f2093835234eb3350e7e761b88efa53edd42749b3f68d7de68ac536b9cdfcff03435c3f7f35ed56d61607f6e2d678be8de46afc33361a0eeeaa5f4e58293f742bd273863f9cd2eb9f7645b5750a12f0a93868b4049180dff30bbc2b14fd69d53995cc06d07408fdce50cd9fc1d58999bb3ab16db06f7ab91a37c74d3b937a46c6d7fb2fb86f51616ef8b615524a513963c62d82f39acdf641603bca827de893757426c791e2f951b0f986a689ec97113e6da7ca2e1bcdc0a71241f9f40192bc5ce90841e6a5b16e3d11fd7112f1dd2944159a8907b589de3bca2919d1a69539da297c2fb4512a6d7411c0843d2979d5e5e2ec21173cc6bb77d4c7e6a8261fad38b74242fde62967839a4d2d8153307ee1d63e27d18c78a044236ad4326554719b5be185819a24de9280c58de773b7e029e51e4047b6d43109ce8a70e660d4a5f7035aa9ae043f63ab2a992316bc4e80591e1b3e4dd7003f3f2a2528421112ebad28d97f03c8863d83de7a6d43a2cc06e8d6692c60b0512f9a5ee95c1f788a36868f8c247db69199ce7852bb8dc5c225f1b56a009dc5a3be98091034791f174904b0709af51486dfc93877b49814a61572a326a37e7335ddca4c893b94fcf78b2753b928f89daea6bf087d4330c91f8f804cc8f5042bf815f4c781ae9c7f531d1e7f20a36a6873b87bd6d53938d5483131eda60250cb2070576b7de10ad0d322c8444a87c555c2362410e41c4a95af08521b58497180f1093f1e7a5511a6a14adb2a5b64ee45dce4056b695c45d4856df0e508941db121f6240e4fee8eadea6c6b4fc2be295095938c83581c64cfecc5eefda2c8a534bc6d58f77a80b73376610f013abdc03f6397d401b1dd9fefc447df4181d1e75fb9ba7bf2c1a27f84fdcdba36bda4d42a67faa88f09734c49ff34d26648c3b595a5be4070f05018ebccaee523e8e0b8c7b49907e38b7cbafe09a71e69fd05a2b0124c9bbcec50181bf57d55b80d244c6128ab7c9304b5e802e07e5c68be583f1a27e060d1a60615eb5e345f8f9d82666ab6684fa311cf55937ba58888eb3b127dd9a09e490481ee1c76915e487a6697d0b5fea479d36f49f665e9a64b3ba3ea9f75f4acaa3153bed300e434c4eedefdc8e4dc1588b9c6fe73e6812fa6143ad4c0e3428556d5baa2e8694629e69d7b29a5e7c491ae08ee9ff290f4130b8a2d30f5e9f268fcd8a21b85e202810045398195a38447b0e48d89cc0c368a18278e790778a31bec40a0dd48aabe2a4f5d0fc46705100f93d742323b07f8b72d097f83fc55e73da619447fa70dce72d6ecb801ab748a73ad3f5ac26cfc0844243ec3d7d507210a537ad347b8bc599a904bd32724ee2f1591ac7cf82b0e282d062895184172ef4a2f0508de053b06dd8214d9529f41ba340101a97d32198d23a94bf72ac1834548c8434ec09ec37ee3cbd1b790a657e460431706d37c8515684585068f17f9145d101a768bf93d64c86374601c641f856a616816af4acc8dcbd675fcd8c8aa29f0a1b7fa92207a79916b3b84db3ae078d89ce42e1acf9a537e5aa887a0a0461222b9747390750bfc51aa550d6504c13790f110b1d807a1b2d4a0208726e07f936d74c2390d09ef4d46327520045129fb39376662e365c8d1b38f390c7643051129fcebff4b399b6e479fcd98b8cdc522b4a9fc87b03577ae2ae334ec9c542f2f7f3eedfd22303af932076568a1c21e37bad90392d05cbad4c5cb659bd1a829145c8276c29c73fa78b091d8ffc54eb605600e9db4c68620692a202a42dd73f8321bb356a20a12bd2e2fed9b3836d296cc0f48856bb56cc8f1f6a34c8f84015736be5087d78fb2fc8e0fc7114a07e44118db4b9db88cc4d7aea1c2b4f7a05854b1a8bd3f66e1856ba815b98f2d851306a614a46a06a5ca4a0e5a349c259e3a918f598682c1f77d819a3b136a3126a69119e30686b6f2eab57a00ac2576f914728d1116537fd41b6e0a326b8ebb52b29aa5f6d0b3ec30cda7511460ed7b96d671f5c44bd8efd6c58672ab4bd8c785fbb7be85fc50e3d3b79918a7e82b3e7af01f2bd4d97ac6d79d2fd38c3bb190e457b20671d698b35cc5fa5ce51cfa2da176e20475ff44f0024cb0e0b963b7d140626dc5d7874e9b73b500b828bc6204b9a3ff5d685ef96a6c7c5f6eda9ffcef825b03d2b77713fb484045ce6b96a948b42c2682b4ece3b904ffd1594de70340ecb09886f885efb5f90750cb52e979829c8c943e83c48fd5ad1969bab765289b6e854779ab40f369b2e95b5943feb3ba8c9431d4f2a78e6140c055f76f65f27688e58d2b15ff0b79f935fd6f5b65db1fb5b3055bd20803a33495f2516d3d9b22395a27991d4dcd21070085473e9f9586c3537188c2988df1e99b748e78397734dc31a6472776c9e0d5ce17559f77f245a60a52baabe3e1d8203e9ed8e0336e1fa1f3752bce750084119be31140825a47127cc4cc1d21ac625bef1c851adbaf0d9e194dfac0f9180a9617e132c113c42eef76d3b787cc750332b3dc5cda8053d3e406c4e2e190d8ed0cf3fc2d13fd28964af3fe89f631d8da6c6f5750c97c854918a6d7814dcae5bcd2071be037cfcef5b91b49e68869f0f57a2efa6c6424fa7526191c2cca1b9c71ae30c0f2f183c86de072de842903275e9658049f6227369dd1fe83d1ebecc2d412763dda7c4bd64c6f3f17f2893bad71449dc3940080f6aaa44ad8c23aa4a682f2906f1cfdcfa7bc69a91ea808f0a7dfa5e613f9bfd0797f0538c304442638b1c4fa8efa9a7badc8dc1890ce0624c0a658d16c7502a8c8a25dc5a42adab87abbbbe6a4d4f1bffac256ff054b538cf63ad4c56eec8a14e8a1d195ece914bcff1d726506c5705d57f4a32f53ca240f474249b0c874cda954cb208452883d77dd09e4bbdf3467e30324811f75f9f70c9ea19a8db8ffabbdd2ceb6785188415676dbd643310a4ee242fa53308b9b7c5c2db09f3eb4637ab0008a04dab513331963e89cb2bc40e6e93a5e51b222aa8dd57853f73c48474cd60e17e1268fdd2c491bdd2a64a07d6062b93d4d407f515095513605044eeca4830c86edec02675b19526628c837fc089f7a9f16838079eafb19f2d9175fb1f1f6f9cf70c08cd93cbfd4a7abf8d05bffbdd702907607cb8faba744c3b5d4d8e662d5971b5726ead3e68be31941773578d009a27e6e3cbe299f93d0589848b6d719a7d70e92fb8516a7dcd33dc50ca425a4f2f7e0e564a479b12c374fe3ad8890389b66e4600bf6a079fd8fd99229937bc78d7c0a0fcefe302c07c55cdfda67a8281282c7d476956ac19793f9d4dbe30052105f9912201254dee4bf0d74d41a6e40b47a7a5b138fc99a346a01ea2badf87f49b03c1196c52810b91ccfba5ff6fa685e3bbd8199d217c71bb123fc1fd2da134c414a4b4c686337e7bf2ba3c7699209f66137439ec3a25d6229c14d132bbb02445db8a2af2def339c98dff0fa5bf0e47b34b23975664caba127936796e2ce7fad1a703e6d4fdc6323abfdcddb0ac06f67f00ac40116593e5144c2106cf9ec6de5afd5aab0bd83cd271858fbe3de187756ed9efc2c53822a3fd1a4412dec8716d34e7333798847d53b75a17b180ec58c068c0e4f6183bfb7ef50fad536c080349048ebc04c61d94c162d25357d6e3ec701c5a092bdd04525dd33fd61fd76cd0ab3fba3178c42e8f6dce34ed307d27c0b777d3ef0b3842de616b3b8bcc4e8c67a333ec2e45f47b1a0e13cc50a374a81acb5911910fe4ab96c3d7f568b73f71ad0f4156b222d654db261b18fbc9135f04a404fff6d7ea66dbb0930de4f7c262495765bd45d968036a3db18c63ee431f1f025b64ab38d5898946df9a1f2ae19726c3ddb9749c7da10a54078913c3b9332330e8b3f77a70bacb0cb0d6c2570dc7e2149623f344b3979ec0345e18f2fe27b4affc5a12d732c5d081b6b95eb86882edbef5e1854f6758c53b0c780742444702227ab9af9c937588db6ac76d682186ba8d7ef0b305657e5408bd4f6e1820996d0e01d1bd5f845ba7feca8f3b1754a8116ff195905c1b10d5df3cc1304f794c5c4600cb4e4ed960be55d7b39059e9095068c6876293095473f8d875633535eb9a561dd5e843bb32ad3af85dbfbb4f6a0f458530f1fbc67df6bb6e0d19b039e2d70419cae1688b512d779af357333c8390fa4161c708ad3ddc7b4ac8113b1acb9c384e83a8bc105872a0bf57f31d852e3adae5c0ff849fe4cd91e5989995ece2a1c1669155177df0bf1bea2060b6b25e3080492df5a4d29017049e7a73ce2da3e30f06e832ba0d0a4e299b7810c2e08753a6bb9aaf8f47dd2363fc789c67a233939d8c0a133d559d6ce161dfd64da5855b1a5e8a8fabd52895fb421edd57f036378aafd41f1ae595de5468bc203264eff9682b4814c26f8165f7cda8fad10cdc9e8171302233123e4acf062e6755dc386c4f14caaad78158a1fd5be548a7a6dd272e7c8264c985cf170b74a326ce8e26541616c7eb7dfd79c6686a878337d13b41f51fc061cf7295a5903cca88af3e19f8f714d7d337d9a2cb151171f03455df1d266b3138d6bdad3062489b7d540eb7d7fbfe16ecad0b0ea45e496bbc7c807507ce079cf14c60e96a4bfd283059fdced7b7aa9d395a80ee2c3c0f2318fb0d2d7754b9be20c61ef5d026d2d1ddbd637479675b1e5c516d5941de28af4a9c637d4591d3e20d642474b3c0f080d9d48f5a28e6d4506c9675d7625c33640f8001ca14e5456faa122024b68488adc14926142f56aab82298a8683b73c9d0b2de919b0aa1a2c4d725ffd06d37c0d64867919f2068fdac0c53f1bb81068cc754369e2beca3320a2b7aef48e417ba7dcf0d977705fcdd1c8dfb2a8fe6fc4dddc31d65d38bb436fd93f86a2661c1d94bcb04926a650887ae100816d1781b865c68dd5981ad8483640a49ed59e41b8e0aee278d9f770deecb310cf5547792734b9a11c91968abb55c694c18f3976b8ac2ba93f552c54cec487ebd594d60da515a576849e30ae0d6357304d33e8f4c6b25e34a8c51da2e1f2536eaced3ab1324218bd13bd9e00b5b6b1e287fb01588b20d2552d9052cf3c5acc387ee03fb65c5acabec0fdf12e7a6fc5986f60759e31154a85b63624111937dd7d8542e5140b6f3717b5b06514b99038dab875983dc8fac5135ea6daa96666082b58c5b0daad084376619481004cbd58de256ff8bd4318af6a6f8615b5a8eb3b507203b685a16bc0b947c60e3678b2fee6230155885512f36e41fbd08d6119cbcd562d37563c39c7cfcd00fd57f2d052359a8b102b5a98d883ae00e72512f714a3e3066ddb9f334a79308664e4b220083a454e81536642f4a5e6446b9c74bf33d5105f033e12331e7121c7ba417157ff2df346a66c9068f97ff3e9924a048f75ab7b113524a8e3603ceaafb036e03bc211031a6b6c868bab136866e136d28d0b87afd03c46af66123a66e82be27f4383aa8b6b6620a9ca9c3d74a9d67b57fbd53df705b6146ff87f43ef758af92a2f586d9b7dfd5af068327457559e403700adef4c303a273b716c882c22c0a54eaf2c4b116ce4c70d51c6804ea4430c9c0714ddf40de8eb68deef7cbc864a02f22a27559fdb260fae924d14140bc74bfed32fcaa6acc468a4072bc3169c7672d8d447f7cd85f189754aeb65a20d568822c939c04b28c2232421b64fe9fc8b189d38869af3d5b11bbe33dfdbf6479110c96a2aab96aef84e639f87915b6fdd67af40dc781776769baf65fbbc587bf36cb158fd0cd6e1dbabbb17a2e43592d365c32734609fe8501b0b3628fe93a6adbe11d06485089cff0fab78391045b15e78688fc9bbfa077bd987455f85b5270cd6c2e75c976b562de7789de3d38b85557218acf94a58ed2d1573353b4012845cebc6e908974eef62f88d33dd91995fa6cbc99d1160132a6bdd5c574a08dab5db7e570f9d69c97bdbb39fab68166b131d78891ab358225d9e500ef2a7c9b00cc40b993181cc430f89bcc056e860502f61636f92bf411e4a6731ab8caa6dc9a059f9400cddd9798d5bd10ce04b7b4330efdbbccb26ca6e794c4becb90","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
