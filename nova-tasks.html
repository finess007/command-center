<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a43e0da32babb8487b69240de9258ad305e011148f9ff50ef1fff0992212ccb187923c4907a53b37d5937c8e4a41265ca24edc1300297c57b6bf0f207d7673262a958afae3f563cd7aa3079e2dad9de766fb3f9d2ff1a7e277c221f78b378be6c7a4a35181667dafaf8a3a8a5ba898d8cdb1914a9b72606e1ba2f7c724f71b7e449d867153e6640667dd348a5110dbae6d2d00f4ded4aa63a6c7cd54f36b224bdba09981af0c1bb22fd665ece7657c03c7aa3af0b37fa94eb0d8b0e9fd88231a7f68f2889c00379ad3d4040fbb14121c8a16496132974e8befb16a64bd54ea78122bd4fc295ebf8420ef8cc9efbbc9085e030df0151746942f4c8699101b529f62b3a67fe366e0c364a8285acb1e8351d9d9d531899cf84e1b7f3235da058fa729fd9a24c4c66d3044b0d8a6a435fda129cf9f265abd36211ffb9682615923f2f5d78f8f56df0848fe272b684a24dfcd81d2f4660f46527cc5dd93620451dfef780fb80dc5ddf18361763b67867cf1424f8c117fadb65dd549411576a892c366492720bcfa028a6b4dcfc63bbebb0619fda19f60a05e0e8132da7dbf0fab558aa8e79662fd5d2ed129882a57899e573fbb2d1c140338c492134ed835e9376f07a29fc63992174c4e52e3b66b5bd9227b2d0fee0a684c7a5f25f923e8e43deab2d49ed753d7b62b0ac1be8f46e41337f8f1080514431ab3a06d64cd6831dce6b79baa99721bfee26aa7e7bdc93d3907d2abf3f3ed37aa6c7bf0a5d2258b8e46965643338cb1a6bccd7cd11d9f767d27222f0c541ad78ede9600c4f59f9f39fb53e631baf40fed23f059c1b34d7d7a45418c48159a88852025607573fc001e8132007a45281b23cdfb066a672d9fd1fccd89611d1cc681239bded1e933bb33c3053d5fc78c551880e03d73911680b35aa5570632ae84bfa6eef68602fc7765c8898fdf1f8ad84bb87c46c0a780379b4fb1d640d25354e10f81becac73989196da2341c451043310accb85f965db8de1ccfef6af7e5d7e484a9a6bee20a1b013e75b6a082eb8e1e745f3f6573075bc405313c351388348bddb527b22ea16ba218266e60b929a02932aec2b2250ef551b00e95e512cf4dea8d36c46ff442b7e78daf94b01160454d1f736a944e56ea2f4434d344a346791cf0f31221c2f1439bf17c29ec5bfd03bb21e2d56718aa5ff497af723dae8b4a3de7e51e66b27033c403245681e64de51ec0ed854c511d2baf1d2d8c8454c8719dbde756a3b949ec1d8850969733aae96c467d85a383fe5a76a7c4466263ec1261ec4753d6d591628906fba94a5ae556c4225bd2d5773c717a666890e0cc62f462a876c27cabd59e212d2745755a945a53b3aca70ef05764d2ce4fda4f257c7db58b2c0be52e96162c58529bd40c194a9466e7008202f95da0985d1b1996cf5c33b6592d97a9e199c4efd234f343ae8f7f4cea8860732d32d9a1f59a48c24fd5e0a3a13bd8a8d240bdccd2442c2ece3563e97bfe12f2ec85cb2be92fe696d87df819c181ac0c938947f521d5ec3b3e12678d032398822841dc2843eabf7be3ed1894b8e8bf9b9d788218169e5e6fafea740eee6c43a777f0940b725914ec18a02ecf68f519aa5e1113554b34260a083d4d865a7b9a9efeccbedc5d23249092274d2f5ce6be509359c049f6e6638daa1c1059ec1d65462da0a0f97384d6d0fe68039556669c4ca74f2aa5bf31bf6879bd61a6a26ac31babfd4c801ced13e8523c8cb2ee3e0177f02b28bc479168937269eef71671b42251c707d4708974a910851b22403326320a8c36d36fa426fab7259ff1e02d63bc8d8157162e641106638bfd5386dafa720075c499ac8c63b6dfcb8f9f731f925944b0933c45d1de4b45b70fa2fac577b0cc19282b8c663112959f3fc43c5610e94e741b8d1a46c443585cb8491eee5d3702c3b4ff16a080ccfd1a4680ecfd000fcac9c86bcfd94c7c0e697cc517455938b559abe896a7c7ff3cec6c7b29a025ceab56c06c620620b3b0a772e814ed169ba71e22f3973ecb474b5f94a1388725a8ff9accae105ef9757694fa13285a9ed9973b8b9a35230a5620b81d05d16f17eaa41f58db5e6888ebd8a06b05a76ea161bf9576afae23dafce8d02ddc89f080428d4369c7870db0820bd25a085d5abeac1bb61e389c20026cc37beebe6dc8e92fded44bdd54f3c1ce20fbd5d13c616ed2442a3d9a0bbf07b82777f1abbd20384855294c1d32642d98445914ab6f332909c0264e178d19b539323303c8e42f98938074035671674915d1cef3c426a6a94b054f03891653b778b00b2da6bcdb47dff9b579e77a650032e99131aace7caa9743d0704c69699c47a56bf1b0f8358f599b4786f4e5a9a945fd53e7276537cf040b42d7241b564df9e136d9412a27ed3080f6b731d36394a85f9493d76df1a4c2614a60ea16b7524b76d227122d27ae4bde9b0780fa36b42be263338d5c716d3db1d59c17d0434d7c598bc7653505dff88a38ddc39c43ad6e58cff3a8af348d79bac78ee9d4024090057a1954e32a2f9f38bfc9e55c3edbc4cf3cdf70f91e6c8c8d83267426eb457f5143f8558e45dd6e328241299c50a729c81c65ad1234f414cf9f5cf3a930b4189b6132d2b6dfd1e28bd10b889caf9ceb2d12eae1d4eec494195a87bbcd541b59e3922a2857d5a271b36210d104e15cd4be665269d63c689c29b64f90bf033eaa28c8df033d680a2ccb2b2414740c7b126f29ee1f54ebba856fed613161fa58c7fcb8c79a495391de268fd3daefc1eff53cbdf1e3b4e5039ed0e99e1b82541e83cae709fce24e1f769cdf25783748a8cdc18c7c232515041b0ae656080a1a0f2ba63d56c8a3705b65483bd66ea02b6d624328ae41a9d4343aebd61fbbfd1b263039f602b50fdedda89a02ac5c6a5e903d3559fe011b86e821b671c9884f09266f455bd2db97f0eab01075b67f926a7cafda2816197ed6417ed700a5e0dcab2e8775919850442fc67790c1639dccc67fd8a8f3b2b3c5fa3a78905e4daabaa2488563a8c9ffeb2676299d0821db991404e9aa998c9da12792af3d2af73aedbdfb4e6a1d9064d1c85f6dbd16b69207422c09d57af031ed1bd75196b9c8ef780e6aba019ab11c9770daa97900aa91619487234b4a34f14e1ebf545c0d8773a220a8079295c9e34ec3e2fa2e7bfdd9e7b0f3ab2916da1a3a3c84c324e2af25260232801267d3dec866ed3687752e30000f673b3a47e70cdb9e6414c32522f8c65da9892b300dd2b0fc325aa9974909f456ecaf28a02fd776a47a8e185fdb8172154669c703afdca9f8867660bc14b6879f64915803f669abfa03885f3670b3173c1213abb231ccc58854d6b74ddc17001c101c53902252a91a728eedcb7a9b5977f6c6b5896d2b6d33481c5657d68fedf431495cd4f1a3fe93c868beb0bd7def7308ddc6e36a9768b95e57863d1a505c0f201f6c6a62bfbc2e2658a63e92e1bcffea8b853d08f9abe8b1c8993d50690a0d47306287899f1a45fc7839e6b138ea90ba37bf83bb9723bf1c8fbbb095af2630391bfb597f014d05234dd37459fcf8b1903eddc6491d874f2bbaac8bd55108d13e64cc4b4f2f29a7144493b94511c6ab592fe7c18863b92d269807387af4b2ece66171a7fc7ec8ae7caf4033df3eb8581260a9ed6f70868a51b58151c46d69fc1e7fc5caa4e895c3fe0c1d20507509f0743c95a8235e8e595d9f8a7d2d3d03dddb292bb911dace801dd242005ea899d89038c94867f16ebd53c840fe5856ce0365bcd5ffa8cc9af484197c725130c4d7665a198bca3ec101896af184faa7391de02b9c5a1b9015c1fa2ccef41b29c0f92547f7122faec5a0e6cf199f67d7ef6a6aba7865bb16eff99f597cb804762dea8d261710299950e0c6c281fe57777ea3cb5aa9eef1ac44e465177f13d4dcfaa650c5f5776cdfa7a8959753d8684db4f5b76c91d3e02e12090c7e2bafcbc3be2b7a1833a84fab99a7ee7f5d5cd414cb5b8eafd057596a3c1ad187454e00caeac56ddb281eea06f0d8e83a1ea08b712b4b86bcef19fd78b6e2bb8cac80e6617ab18b4bf98c3526f5ba104900c154c1c1b9a835b8f25c51a09001ab8a31b0f97bdddaa3621826a7cc0f0ad02955928b2b2f7f4dc5dae0ba1025212db507deacd70e105e91af884d610bfc39e27b2ad3da892ba1c3ec41a7451e6ab29cbacd0c1ab2a79f8bf9cc1a745f0bc9dd7c8b48053bbe0274f71e0b8e6728993d0dd350a15465abbcc5065ec201170829582b491eb500e30f875d80b5a5ef6b5f688058adf9f2a8ba9c1bae5dda3c1d4de0570dde156677958fac029563402576db4433d6f194a5555fdd12fc20d298fbf08257d2f8da046d339b3f41051cd6b276f3b4cbe21015382e99ec4c678d9fa99ce3b256b4b6c97715c11a9ffa8b1150d9446a2e18b19a4503086e8b6bd227da148495caac238741cbadd8477f2dddafa3aeadab2be14476b53642be71b65c0f43d19a8f8dad9740e0bc9a7952d9e6f723982773cd38b8f26d714f0dce4b32499d456e8654e44441a85d0e235e9c5ad1567b18c36dd18a7fa12457675fd12260e3d74babea4a1a5ec0eae30e07128c167fc5e720d813f02d6c1cae5fe27e93448d8378fb566ca41e5210e4cf60a8f590d8e03b4d6ca27da81fc0ba6e05f557800306e1b5d2c614c9158c55c41832c2090fb5046c5900c303373c748f67c86b30293c9a41edd5a7217bdf6b61393fcfbaa5db55c4a027df03c38bee19b3f3faedbb213bb507c70c1f7bc4fc6213f307db574c53bdd4a02b92e3fc3b2f78422b6e4091fb1ab6b4d882aa51893d156cdabd64871173331c73d355166fbd8b08a09efeef75d22580c7419357722df08551d01f734080f6bef0b67deef1c227def5c6bc0bc5462af4a5c583658bfee19843c290d6d540062621423e7f8be4ca2bc3e3799963f119d013471f2c5bffdc75c22b99543367a3fbb6725fd33bc01eb091e38fa6b74907aa1aeda76247f4cc248d8a9ffa20125efb48069f76f79213642675d4d9299adb4ad09d3ee82592ca1edce262da70f345337a839f2863b610e1038ec132c38b1ceb8fc8d8796e90cce93976327146e06b93354885aca1b7cfb59b764f2d0b0a5ffe1d2885fa4e2e8fa92f22738485393a1d3a4d70ad72c04ae585ee51fe3ac1727c7d410d17a6366a95ddeb88dd918d6ec534e8101bc7d556cad16e18c61ce471480ab6b5b41f94c39ab4f0054dd653d9b85e42f40f98fbd136688cfd9f61927672dc6cd7be9fd6e88938f7a578f043d50249ce170bfd0ad8f2ced1b1928fc274e770a995800a8cf814beb994508521cda96bdfb0b0ddfc16d79a4ef497945dcfcd8f2dad826b8284299c590c8175f796770106b33dc55f9abd5b6f6f1b56bec2ff662cf875562a540a65685d54275efd97f2a8f4b06b6644c601d5b8ab22db6104aafff17b4b9e257ca79185dbbc8a3c7e9736dd4a5ee3fdf5e45df87a2dc6e82b11963ccc7e3935abdd916e3799d9d2f13336a42b17c8880718ec9440ce4bd68a5b03a54acd83cb8d3b7e3a0e769dc9009d7265054c09b794a487a8fc821ac9394c4814a56de93f519fdb120c97eca8987cb8a461a3052b95b86d7fad9810131337857d8e394e969365f50bfec1da603449df6a4ae45656a2e5d61c9d55e826c4193a1e278a10109ec9542bb487b3596ffdab665c62edc14baa7d1bc6bdaa2aa9e7ab5813196df601fde835baa7f5206ee333fc28edef4e881185b9febcc423ee0c468a190d925c73f0b667806e537d2fce3edec6ffb8c15208f13cdcd1afad4dcee16810f210be423bef1e4c31c1d88dfd2cca3a79979ca8373eefb2841ffa296c66c7b3336265b52bf1a431b29554f2828a45804c98b7a02be62ace11903236db1035144735bd423eeb6b01cc9aae96d7f8c1e443d89706e6d5a927f46317901d6a8376da7f03eaa147600c4992d6707ecd9f110f4edaf16d22197469085225dbf7ebfaaa09547c0d5aac7a2c46308aff8a4a2e262278292368497591a4e028f3d153498308263689dea3bd6fb29af6855ebffa1014fd3a4742621c26032a6b77145c7096c14a804a8feba46d3240bee7af0b7e5df4727eb321c2be34fbfc08954e213b191a1683d20d96a15c520bbec987dedc0eaf586bc212a620ad49ecdee6188a249d29f8ba374662fbe31910e2726d1aa87ae043434ab72193b66a93b89d2178739c0efea846b7998ca39a14e42af2185a9870150a2e8b6cabcfb8c5ea9672779542d9cc7672d4fccffa5fdedd14ceb215362b61987845f52979fd763810c91f57b0b5ae0c2f58b17be31bc0699bc8b36bba943f5ef80a906aed168d88766ec6a867ec35d3f909a0f85356c0b7236a442abc175dfd78d0dcf6571373d9842ce37fb008a8824d5971bda232d42ab27b8bb7f0daa119d67ebdf66e83cd39994900a222465bebfb8d928896080c3053c67fec6ddfc1adf118021c530f4d6e81c0ca836c62cd6abef194917794f24c3e6532ed2a50cb9d617a31ca5cde6dba5a85934bb5f0b2e6b6281a26bfc30330c9aeacd9c074b5c29b70c62c761fd996c014ca72c233a11bcefe57c43a20320384e33a7dc349070eb5b3edff83091749aa2c78ff45d57fa998416070c2f7d8c2834f84cf1efd5f3a1509b831e685e36fa1257e5fc6b34257f80e91791ae25cc88bd0ba9f3de6e1b11e404a88a6de8908cc5a57f464af8cbe7b4f288986dff494e642900847fcf2a7b88e28c2323a4ea7cdf38f93c6fded14b2bd923f4f633ffc26398732ff6171267d73fdbf12f4b338f81c5036fcd56a539af61c48281530af867f5425282e3c446d4c1a7d9d485098c5a0a394e5a7cab8a62d21197d9862d5c8e33a17cd5ff891f6a7d801493097208c5648c3db334f80c1ae400ad6d5468563975777e44a77b24de749d628643077d5e3a1bca3be61279fa3c6f169242cf47f06df06c0ea2a4acce248c160249fd501d3557dc50128aaa8d8b342ed57f21ec76960dc519582946fe3970ad5a5d46490542e2df61c24beee54aaf72f8e87365cea0f74d9a2833ef3789fb59f9514a90f618a8471387d1786874d9ba5b6d2ad13544fb0a8335ff9eae0d9815ee07feedd825cd5445aee0067a08a074a4ac0ef408dbf34a0dd943c19c23156ab91d2c9f1867ff64aeabb48dc35a80a319fb7052a7c7a0a23a786ac3702ebb3c1bdf91f16d4a6938a8ae70aed71cda9ad914fad7e76b4e14157d6d3b1491b5ef5def8c6b1f7e7b104038ada08c4f92af2b43b229219d1439718a7f06f06166d81951fc07f1fc977f91a4dcd378ce4fb1a25379b3e39a0fcec06e1e467e4812de0bed7233b7f1d24b7ffd5e2e374dd8c7880caa8e94e907d3ae2c2de655f01de8e51537320fc9e414bed9b459c89dc3d32341d5cf786356e6aff845928ce8c36cd4e744b6f6d5e0248507f3f520e2bce3bb9e0650e8a561f72c44b5efc0641427859b97846d0ac3133be065080314adb5f89def2ccbb9928b4d77d1e3c0aab35249e9ec07d61c5a37341b043f64a1ea8710f7f049b457adf6ade73f7b9950623d728f3ab753a3760683fdbd88b004cc399b5562b32d6623306d1111af4c54764a63b29c954a0a0dc0d266b89f1f534da4a6bbc57aba598be0d1ef0462dfcc5d15eaf4d418b8f452c7dc7a1e786f7748074dd396335725fce7ca0ccf7e1293ef081ae695e6b14b147d5fbe64bed6e8529f182ad4e16a6765b0bcd4cf7915ec0a386eea1164bfcf4b2302ca132253ffafac61ae9f3944e9fa970497f6f263b0eeb9ceb19980f9023f16138e1b7af982599a2f40583b5e1136cb27368af1843f4fcacab58e8b4f28389dbefb2aa0706107fa6296b88c35e0df97621e70f9607217a438e758dda2376607e2c371ce4deaa547aeb42a2e0f5c3dc2919061860c3069813ab3a37926348a8203cb03e2f6ac110ee7f3c134f7f68df155a8b52d43ca1e13fd1d79156e2885d31de8c06597952da6239bb2c3b572137e8442f8d01333c774de40d845892cca53c29481f922faad61ac9b946f7ffbcb64e691f99325f36c72db09ca4ee31a0ce088f1b74cb5c46a67431e2b9ac002405f5b9e8fe7b038023ee18e6555d78b2e22fd3bf0eafcb889ce35f28716ce228cfa4ce48baea0d0c1704fb44b4b7019da393863642d1fc6149ce09f314c72bc0d5841b8bba42b1d0fd16f29aea9f3c18541dedf933d4ca9736219c917f1a06be12761810c965224860a93c4b4b38f7b870a41d77b5e0e278ef5902a192489efbb50afab0c1b1f4f020b32cdadcf3dad19b5e27063924cff41d48e2063ed573edf14cd16ee61e76127d2baf49e61b1c609882e37581f7029d5882596c5e60702cbbb61d2ce169bee201acde4b3c6f83683255bfc06db2bfba192ca726322fa46458cc86017c5016ee8eb6d28ada9b15d1e427d481f57e106f384a50ddb180cbe679a6060730062651363a6286437df0cdc80b391d1f32c965b6f36375de984a11aa0a39ce1fd17e8ef5fc2af196e3c5cdfe02cab5955f6d04f3df77d91ab7b31d949e0f1943f1e46ec53fc53999c8242834801a6d7f1514a6b92ffc081e7c0f25c9fe124ccd3a1ad43f0547a6cf31a35bb9c5fa5fcf13f426d79013da869de6adbef9a10e20696bc779a025ed2e045205161aa77e0f56a6d414fb7d5786a66220739f58175d71b9255bb6b1218779285fda9e0943f1b37bb932d48331cc380a49573a8c851a2a7d3350d94158575ad5287413c9afbff1e0a274346a32b6f254c957314f351210574b987332c7a1b361f089e953de80ee73fa57201a064dcc3519f1dbdc1c4d7e867473056173a1d454d40eb6e4ffba8e9d64467382ae420efa04963bbbd84002f71fa0037ab8fc900b17161e20b4e51f99cb53ac0a7f89fd4d5e9c5e7764a9a6bafeb3ba9b85c21df3241742b6af59021b82f413a89b45b2ca7dcb1eacd55fd013d83add05d59bb8e6ee90536a5e7f322198c7414e3905c263182018de13905e65c08a655ef66464334d3537baf00bbb11f064ff15709854ec2f45deeb37ebebe7a71113331e9eebea5697f1a5ce49935342cc0223e56a27f09ec7d3202432b60f763bf4a58a3dfd151c1d80c13ff0ff9bfb3fcc8fc832fcd0efd9717234a7887c05e2ddfb287936b7f84f5f35d58b919c4ad26453c202b95ade1978d01f36f1dae483672f58e2c8edfb04c4ebcaa6b7abebf0d2935ea5e573191df6034b522405f473ece293cd2ecb83769dfd05a3f864a01265fe37a994862ab1b76eef61a9b5c33c4317ba3f9185e6c918a571f7c6addf2f37c721e9da34b4363f3fcfe87c2dbafd19471f7dce7af53a8a3550a063380351740d4e34b2ae9a6d4d076f10dc779ed45ab7bf99d5bcae7fa1f9cf31cbe7735a407d90fd0d4a988b6b5b929e9713d4e5774c9a8af23b9f09536b41c8210ce67b6084b994430c8e85b9107a85be8fee52c7bcee693a1b4668440a6c20f2156f2a25ee6bdb069d85566f5b0aad01665b17f03d37a6b8b0754216fb8c227ea214358f417d8fd94fae7d5390e4183b0a84eff9dfb86a51198737bdd3806ddcdf3fd4b0542755e1a4bcba4613e04c08132062c88994d0d98ef7633a56229386794e7bf2590f56e0e16d374b990d4ad1c9aa762638dbb674b779e1ab80fcf7844886699bfe6710f2698a6a2a01e65eb92baaa0973399587efb852499a262d888ae04fc88e2065ac4b11ebe02f0f995545518cbd08c8231efac4af3d040e0b592beef0ab732be9e964b632a3b25ed0e109f33773c9079a47020c19bacc513ba70e5a2eaf3ef88777c4e297197d999e843563a9c7d38fcd1d74344893c2296c979af1683303d5938330d9fbadcbac62cd05bb38804f2da87c302978c9763ad970cd7f46b69c366aa126dc45cdb8efc719f4bd56a031a65b326c6c10a2a8c146f142fc2bd15e43b9baa9938b188eade95fc885e0f8e57f2223796686564eef87fa495fa6b53e79f195ac58926e4e78e1af808ecc0752d97b9f83b61d84add83225e3f7530e6f54fad07e8127341667e5dc68fec5df8ce605a747575e486bc5d8e8ee91774f364521551d4a0648a0ce15edea353be7f777f2f4c4a58a77241a947636e46a07bfe1b47f365b74abe8aa836269e6648f6f42c1f1c584449eb9fccc1c95f6b156184ac8c45f115724bd5ceb2c8e0f56fa22fd19803c32d79cfb500b8e338e267e0d20939edd1d8eb968960c31c14d5f7174771746db4f84a261ff96d6afdfa3c5e136446a05189ea1aa85d7d668402ef7f43417992dd5970f9a91f676f721271ca6c2dacbcb09ec64a3ca5905c0802ace9b4a384b715cc5e19fbe3765592710ac9ab19c1cda419578bc4341c996abc4771a4c6d50b89e3063cdd4c11ae2dbe14a4407ef6fb80365d3895a5a1e9eaab3f6b366124092ec8859eab1009deed75ed7eab9119bc185f43dea48c37b52d875b5763fe1f391e5d5ef58f4e1fd095ee84ac866f4aa6950962d22792084dc5c28d55d5219127cdaa6453f3f052fc108de1d35ff9df0efe050182591bf35b5df72e4692df93b0ed453752e0596c037e39e4538feb5db7a356b3b047c71d6d38b0c6864c70d7f455a172bf33deb5198c534056c904e429f381e0c1c869ba01264a3bca6688c8fede3f77bedeec4c51099a6f5b828d891cf4df3a1ad48c2a23685739a34e5d79b1691745fbee939f1080e28cc2408a8048249f631d5a9e9f484da56e4d8e1750a2f098d7f1e6c557a2e1e3497e575ee1b8ba7aefd97ded3ff0f36ab5a3b5b6172c361c9aae254dd9dc21a9a4d0c2dcb0382f6dbb40bc659f657a7eacbef8bb6b2d48bf54207cd85636837c1b14b6277945248f89d29abeaafeed3b7e315ccd27e33a9d8f6ae982d1f66296d60cc68c144684495069485bcf70629aa872e2fb81fd5dc10503b05653bd55a53e137e86a3639cc02e2adcbaa6b9242d08eee792de8d32594846240d7aa8fc87c0c057c2215308f4310ef5b7541c804ad9d6cf84603a5a1cbe84b28a41c71d49c2668ecc74986e8f04d939added78d2927d10d80a193ea6790a0e626264b1ec5778f043f49eb7784a19be3533e3a962e35ff3318aa264330cb4e16fadfcc501954de1dcf47e414f57cc00746f7f766611726666b9ece900caf986f5ab0d582edcf9927acc42557ce4f5b93fbea11f623c2fccb0e85f0adb4341879c9b484e11144a18e77457ddfd57fb56affb81fb61c1a2ee460ea82c5fe19f8dccca2f2b56177dd1fe6688bb2700e190c6df70ffd7ad73feb884ac599f0589aa8a5b6b05fd2c42c22583f1170ae1da4dd18007bf95c64863437c4cdd9fbe66f24341840afc2ed0fa624bdc58f5eea4fc60d69b1af2b28385841e7be106c21021ff5aacb717582c7f412aa4b602c418a52fe04dae409eb53047bc6a3bebc238c79121cccbac26c47b1027d2e5374509288a2b668a8d292e535bd55baac4400e52099b38e224b05dd6ed21de4d98849c3b44cc7067b790b804fed91e185ee0649a2b343880c4bf9961b70084f3d6f4f15adbac0bcfc908c056a87380f0b9eca448ac0d860460a0a8adec4a5c9170a5559a1bdbc26a6b4737d7363a09701b25d6099e87f217c34e92101f56e8e9305029276165ac65ecff7cfa404de92b7609a001620ad413121a72db3b54c5027ac8718d463ca536e9243464222a5ab3d21b620186c4462fa1ff8c560be8b0e21d5433d75403e6fa227619fab9cc33a41e6fa6c93bc8db8b35d534b31e0449c60ad5a183393aa27420db86fec868317b53af06f2a23565f04259685b541dd49271a83f1089d67a4b259da442f4333af435963bc542831939ca60c29a4f7b6e3c358ef2659b7a02c926b73720f6d5b7c31af7ee6c934d9df8a0ee4522b515eadba0c148526fc9aa40207679fe47603043159ddc7e079f5e793e27145637068c42bd5de2c8de294ef72924351b6a43eeadfd21ee7f587c544f711746c9443d15072a1415f4e5e0355d007e1f8612a11b9078091209161eaf76c65880919ea08c97ff0037f52b0697953451f5d86b167794dbfc75934595d09f423d39774a39f8ff24c7206c6a860f2d209833df03d4a09b4b03e2961e751e52f8b5f171f2351ebedfcac801c69b7cfa96cc547517a4bcb1f4ec8fe74964b70e1779ed9cddec06753f0e45ac36784fc941c7c783f5a862ac92f7910f2d1de84ef59e073ab0b26a5850cc7ec80cf3c8660f3107cdd5d6384ac471036ed02f99f34329c4b5c73c69b3f0d09839f5f624594bbb00373b6817ee8ef0d0eb75eb3fbb04e9df366c0937c55acf42b566ee754744b4c4e690366aa0b74749739c9e3d786c04768853895e52f801316451281d447e1bd4ba7808a3c3d68e5afbf64fdc8278d5403caee169399b631f2acf35b6f1b1cf4ff2203d1d92e7264faeb742b44dbb9542170612400813f8238f1c4b4866b81178d14a688e3616fbbbcda8fbc56aa117b40e7c6050695274ddc757e4bf97dec2c930589afd28e5579b95328d2bfa669fd5e8f2c65c8a3ce48918adc11c27e73a2b4a317e1d2a4b09387e658d4a6ea4fc76e345d132522fe16a55773bb7228803dd73e4cd9f1b0c65ca3027470ecad5b0bae70a46f1476a977cb26a87e74998a62030a4c0979997d49782781dd13277707db7cf34ac220d12bf76ba7b064dc694c366e6196c18b1e71806eeb101c2759655769e49e6b4284ecfdedbfe5dddeb8fdea128f8330d17a64cdf06292fecec1ffc98849c597e3f2e6a38304f7a463a4e118eda76cb4ed59b7670ee7bf7958430dadd726dc4586640a7f5c13cdd929e6cc103ffb64bcf8dccbd8a0b7dc29b4f735160b1fbd2574cf96274d2ff13e371cb2a3676dd1b93da4cf2bcdbb7128c52c74026704315c714c6a4e521bb3b369e3d5a8e987d351a28c58c5c0af9d9d5fccb006a5aa16f159fa7001fb54f082b0634885fee78052e158a79b821f3a95f69b152ed9e86c759a72f63e86ad45aefbfaabd7cf76e745001a17a096049e0ba260ff23c63f82374c7fa5b4d09d9ab426b4243f9504c2f9b96ea0cf1d8751c75ecc8ca92a020d39b6745cd43171073d04e455182f799d58734cc1e303b289a7b09c79c9f4350124256770a269cb4aa07c558a75421f3cba88a5dd3d1e9261e1eba63e1b98304ebdb73a82321d9ac9bcc82c9b4528f06cd61aae702f34b9287f8e0349ebea91acd1128644e0af1cf1ee1b77229a8aeb3f3faa01adfc8ab0fed23033ab950f1329a334ffb41a0b47b1f3cf907f976bb0bee4f0acfe39c21cf53ee2e491deddad89beec268497325d2af9e87f963076df70be72793bf30ea5a9ebdc5e05f8cac20ebc627d70e3c1788dee43e9207f9a37d2d195b63dd34e3777a1bcf64f3faeabc2619d31137f9e5afd817a69e93276274b3ad2c4a2769a03f96de3a3179c417f3c76490f46c079472bbbc40dc71940289d073d480abb01a3cd7349179ce5eda86ef049e6915164f9a2d7ee10e6ffa4bc2e48357bbf564ba2078d08565736b8aaa523663980093e19d6f508b2b707757fbe0f326dc911bc3b4a1780996dc168d39b352d83d1c93058477200f3b577ad2054f72951e9f8b65e7987917290d1385ac51525a1e5d559d220a51af0dbbd70bfc3110a33ad76d5858356c0d494e12ffadc95728f96a7574a2c0f2cb3a483b9f4edd900f27ee99a2a018a6da1c8a20df13c8df88032cc013b8f01029991df4ed5e8299a9b4ba6d3bbc8ea8d6df8e6635d9439220dc03f489d2615d9d73480c25e1c3305ecd484025a4d2e1ac3b1d8be4c1032c17fb8da2aeb423e365c3cccfd430aee272fe9b13ffd067c511c517b89c1e6074fdb1bfdff0f1c1f53ec55bc34543f36a960f3ab8b343fda865fe8c68cf703fdfb7accfd21740b638cdedfe8433502fc5cc4c9d458cb7ac24ac64323ce08e4cceb131d286876c25567c12d6fa350519c76eba9310235c97e6c197247987e3d56ad9255b397b01ad3dd2ee2968b1b5d05328830909a99e08d5bb06f3cba97f58dbf559934fcc5281193887042622f58ea5d0694d9079825cc1b8559be0711c17aa83c324166837fecccf575568bfad41df3a5107c8a596b19ad15cc0a99f23c24935ea469da368cb21e3d1a240ee3bc4f67d73cd60aa591b3be41ac7c4fb71ee30d336872f101fbc3f0ad5e3a6c637ab724fba7fd5551e13c875ac0be0c7f83e0d44a0144dd35bf5e0817d53daa16fa4116fb7065ee80350c72e63d3eba879d235dd673dec7c501885bead9106cd83e42e59964158fa9dcf80ca67549797fa78520ddb9394e49937cf7b4fb254248569d1c53a6340b4b47a1c96af4ce42b7eae294eecb9bcaf5716803e2b431822dd153fef8f11042c399917997e582ac3991194e60f41c513fc3bf3d3b119a8c8d447bceb3ec0f1736314e7aeeab57b","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
