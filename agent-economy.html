<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"9f3312ce709b4140e130f47f5840d952348563b367777e53ad63a2111f39b3e97f25feb0b36a09557504c3fdf3d1cb7314092065194edcccd180e2a7d57b80369f57e3e4b18c00ab0fc01b21fd82b55792ea712aeccdd301665a97012750ac8380a8d61296d7be149121cba15f8907aaab2f9026f043ca4e2f94bce9d1086a042950d7aa152e5c0ec54d8266f05aa8effdfc95258619beea9f60e76dd671610e1e071906660fd10095b2358446fcc15abf3248685bd5add4bda8317153adb1187da6e7fd3c7271bb6d5c4216a5a9a74f515a5b787353116edbe758cfaa289bc0dfdf573fd4e9ed9d7772ca2d63d2109c6331122a87217ff735559acb9537c318adf01fe5aa6dd8c442a3f533148cf32a0bc3f0a6ef25b112ac93a26459af34cf039c9876bb19e3fb3e66b479a2da4150683ad827ddf81fadd8afbb440fbb4f49782f51bab7e0bd9bcb3193a71abf97fc6a1d1fe116f60a9a2e002e7a144abad58304cc02a8fd560da1bbe3cccb07f46d66ab2d34411a94dab64f18bf3f2348619c7fa357f7e06df2ff07b1824569a1a5dff84c176c7a2ce99c76e46fe8e1e20b64de1a1ea9d5a3d81eed645f1d636fa1c0760afc29b3ebe5b4ea95d5af362bda7158ab973dcc6356c7a9af4752103fdf378d7bfcb80e09398c7d9d58606485d1b8dcba6e070c30e17a155956d2d0a9470af62213c05ecfda276f488dab2a2cfdc2f7b6f7705c310b4e22897c127d3155eac62f95a2ae5a0770c04a9f5d73981069423ce85a3dc9a6aa5a8cbe0de702931a01f2c9de22e108920bba06a36c7549b4f8bf856c8bc3193ef3de7cd349ee4299b759c81b0e77777046a1f9bf83f9d4b15788dca9436d87474308431fcafcf9d1d84eb00eca7329da338a0f5fddb9c6180afea14f68102ee4b1e26e9176a064e11053d46d36b230f0f357fe39735f618d24f1b219702b33fc39b938c2f8d7d4fc21dccbc512d1ea27c6eae10071cb56e4ecd0128d262ea107cc514ebca719373d785f9fe2edee55f1021756bf5e7739145c4851a729bd2a63332e3e670004a65f4c08adc84cc919e3447a8aec9f0927b40da767cd5af40c9f8da33b9d89e6f936d5e558a07996bfdcc7e124fe960c3ccb5c726362b715f002d9cce7ebdac85997220ccaee6ddfc69d9641ad295025fa4763426691b5736a5f68c701c80814689ffacf2b585526bfafdc520d8c1505e51d9c2bcc44a9f334f077b2b8cc2f80d2d8b3e3e3111df4ecb3022f7666dec1fad0807cac919f63762d599dfd2ec5f7a8808d6fbe7b2f78d00fa19fd34bb8d58c65165f738bcb1da5540253498783bf77b52f6e57417aae84c2e15acd7fc9a90565a7cc9aaf719a7392a7976dc7af860b667007d4d14fa077fad1b65d49fb180bd759b3f20116afa787f9230cdad14c7c76f6975930850e900cb3827d6e1b3c39dc74854a3a022d4f9aa50a9e88cf98b11db85ca004da8fd74b361284f34b68571974869e4e02e02fd241998f0e02e764c94570f83ec1cad1c1474a83e43abb75c833b8e67a61c3ed56b5e0707f76e556017cbfd4dd8747b13d2c91bf515907b5d61a16e0734e183ba4d0bb49bca3eacf9df1dbea8c59bd19308e7ca0ae5e504ff3cdf215cd58aff333d9b2d6661dd2feb3550dcba9b139092b014e14896fb6db244809fb7a025b874e4ad886a3b744f9131427bc55c03fc295d625f15a28d9709472208b530dda769cb1fffb228703a261b342c1e0ad7eb278850c8d168f2187d4a25443f17258f0097ddb4134e42f748d6dbce386451cdd223db9ad6687b8419532e558ba88893794c392defe10d9b1af1f80a1ce1debbb6cdc668b6f45f517f9f3c136dff8fb4aafa6c37ff34d37d3c91e0eeacb95e6695904bf5a3df2f56e238f49341a0591eacfa2a62dba354614db8b110d18947672a4900bf1ca61c667e5ce36f2e772ed145e689b108fbc5cd60fbbc33c444cffb49418c93154029ccbc31bdfc0d3513d6bb6d7e507229c5febcbfc80cafcee5baae4357ba44757e16cf22877503185cd3239e508747adf419ce9394ef0b83385200bfc533cc8477400b05a0b021b20690fb40f44af2ab4bc0259cc61c4c12755dbb05d11c6e95bfb7285ae6dbe3a7ae46f8b3b9c2139a71f0c881025ddabcaecc645a26903a51e879f2be22d7aee321cf33dd6391c511264425d362456eaaf19f3a40b535322384fa925244df2c25b7b04f78686220a695c997c414c7228b9ab87b7c4f5a59d817a5dff1ef00d1d1ee8d5a02d99c72c47dc4f31ef5e11173dc024d4296b7942679e4cff746990efd8ffd93cba58d152ea3587a32967ff8268d75e7178723a7c32508f24694a49dada84b7c3878ccb0262304e45977f5422c61547203b4c581aea55834d1a2cc42377214a4bc43e5c9e1f8de77e56e5c2a6965ab905f9fd5243b3ee73239a58c794a3c1f8f8f98edd1ea2ad72174f7e5e1bbb1b69e601aacc6943ef8c949f0e4536c0758bd401aaba839adca2081350c0ed8e65561fe4c6c4bb6dffa6848809eb3e791f8cb89969b62e05db2ec2c959dfaabd35e844dd7483a304a9c91d560e978ac40bfbd12e2b319cd73e8d16509ad580f33b45c1c609f4f0eedcb9974116f7156597fe3301aabb76d80e5a9c56cc4b86b91b7198e4d46a1fd26678d3ef9ee19c8d016de531d82f7ca67fb8f3fc6de22aa238a42f9d3d570f22c96e4b71f558c6e2c76bf3277da4a93a250635013b1f3f5a15ebc485bfd0266d54ef5ca8662530b7444605c1b759409f8cf840834ff70ac66f63972693c3e82d803f368d3f96312c63fd365d13fac7477937ba8742fc879608ca9babce2ef5af6f15dc733c7b5c3115be0a242b67ff32197bc13f305fa1373ba781fd1dcc7158856dc0e4987fa9dc8f521272a18a995703efc69f3eadbae13607fc58c456c9a31cf9dc22b0c8cd27dc034714d0bdb877c07dd88ff5b6ab6f09cc5806add6b869da78cda02f5e2141d8284426ed165a277e63b09386f3a14a39fa9fda8ff7404317b7a666eb42fef16d5d5110a4a19826d4c12a2f1c43371777f74ff4ec4d043c26c53203f89414e6817804d4d490a847619f4fe9c29b78a753fc490133a1eae5d5bdb361df565643ff9b5504297389f8b15a63d7196c1d497fb5bf4f1eebcbba691da04c801b649f9fcec699a1b4ac10daa3e983749c4f9486ae96a0741bef388fc93ec1e33a169aa679c0ae09d289bbfde6ed661bc899e5c3d1638113b25eb1eef625ae17fa96c02a9f14fb575839e6b8cdb4308e2881560080f563b6776822387dbcdf0482995b9f12f40109708512382e4a00b683ecb66551509e54bd9b83c28cebbacf1e30976b0fe8c7971dc301e7c41df4b7f0113e17f226abaeac2f3e91db16fe4524cc829310575e686ac7306d263df89d6382ef8a0309d98e258c61a732408814b9b20fd6f5ff1dfbb2733b58b25a055e221a85f56253db4506842dba77ac5e2bb08a93fa166cbdb23cdc1d5001599bcfdbb063e6d6e9eb65d2f7ccb5e869af083a6c6eb37eb96eac7a9d7c9ffe8252367799e72f2fa71a2e15f79b5f6b19e027811a5b81f3882aa04c558e89e06fc210bc837059962396e4f880afc63f5854728270ce91457f2a7950f828fc8b9540311044a98526f1e7a14429639adf0f9983aed9baa051f43723073ec4c588dd25782957af210dc909a0aae9f6357a3d2dae06bb81194ed2873249b28e3b189a8c9b6e0d93ce11c5fa8e59419b3c2a2e428aa2bcee49ad4162b4f31cecc7e5410193c1e51d7703a1299021e903c78235af3fd0d765bec70774d1b829268d324ba4607b62831019e0dafbbdee1a721967564f1605765de8bf16f7b9242f397333551c3fb35e32525a1da6e16fa1411d82ca58a5545a230b14b10ccf12fd658bfa65b4941fca7de836d8a1dc6c75cb4a140948b9088f3db43c472b3c72dbb904a8758b830b67928043d3583e0edff22540e1465c0e66f7f984601e63d83d01edcc596f3f5337c70592e01fff40f4a662a8b5b3c7e7ac6483a98508adcf10a0e974e97242d32af22332ad1c7065f77a5aff885ef9e00a843ba813cf592f55cbcc09c015007cf02aa99feaba2d2d60da4ab499468fb1c86415b8846d1d183d5a01d5636e8b32ad30ec5b5c5a01abfe86f9ba8604c76f9592f14486e1c4b7a845f5821858c59006038960319386d26591a70e3abc88b01cd7c60eec03395c4020fa14b1be49b916961826cf693e9eeb0d8d344bf8cbe02fa739867a8eb6c589abfe67332d6daf294089bd9056ca3698086a78cb6addb32cd2516d1ecfd7c82aca44cf8d5f623c8a8621685c7a72a3d1e53b0162d25f9ae9df074bbc3a887dbffcc63c94218148cec439d5c4e044c9b949b293bafaa2416927e44b4df60330712d90807cf83131af47cea819e1bee8615e71fe83334bd46c4558454f201a6c470213491ce4a0df677acca990786a64a77c40effed463ed02a5d3b671caed44bdd91a76bfc8b142730745097dd9996bcbd83ec242d5bb52e1ca5bfb988cb12b7c1ad15d681a8edae1aa147a665c7715816ea82c81abd804b84812e528f3c15caf686f9398de8509243686e6b9c057c3be13e26dac65d13b430d45d8ccaa8937a118793f4e9e4ed0be29e7ab584fbe29a9510bc4af3cc42e001d2296f5bf6dfdf187b1e373b2f0f5568cd78214c8cd897fc9048bdd01622694a14940c2c1fc7233157f35b80204b4173ac5e48cb078e59e4df7b27307aedb2a175d8eeb8208bdc4c7fafe3a3fa00957904401a9ab04b97d6b6f6b43ee7e8b1a01ffaf16e2b8e0e766be224ab42bdc599b71cb4574a800b90b2488c582828e80559fdd27f1bcd34c9c617c06141730aa277f1ff7c6738537092bc12d4b3739edae7dccd11c93924511c469d9f85a2576bea69f97ba9aa44c0de8c061ca721c9a631b29d13096d8b9cba832ad10f1927f54bcfab76293bf8efba2b58da763fb1f6f9cbafe1ad43c0364e6e019d36441d9a4748e3ebf2ed1a7ca7edfeedaa6c7f26b5ad3080410780844b0637740c92a7ccd5f11821a85aa5b07098134f87b443e64d8d6d0d249e7f493abbe34a2dc675bbed688d2550b80a633f30d68ae43c68aebced99a7836ce6eefb755fc634cc67f7c48b84bbc4486c18c27fd38d3b88c6aa4b4d83909c3463215c885eb51785d41420f18df6f8f57693c4f4bd36891b0efe525529286149926b58eebafeae5e97e6b69e4bea96201ecd7af4a0a7c20f9d983c181b01166da89a612daf5a74a88f24b647e458a009700b8a4aa7b011adfd3459956bb2d87a8d4bcfa20c4984270165791c6ac0998ebbcad0c49079cac1c2bf0d150d286dc67c20ae537a299d43b826007c1dd67a068f9e83401f41c2f3fa8e5da1515f2739ca001cc5d4bacae6c2f4b13201e33e3526238ec28a414c8135ea882fa0d9ca1abbe4517bc09c0f9b5731592c7e0622f8131bf044b354cc47c4d28a9305f5b56371b2cbcefd33e90b48e82452f79ce09a4a0ffb62a7bce79706e4bb06c0b485375ba23478861a3be123c17b52f9db76f56b0ec0d1d8ae57d0da6a88f013bde791c8c2e908ed2b82d08efb0f68fd0d718702f73f388dea8192b1074547d448d37cdce953f3977d772166537dd9162fcb0c22d4e5438307dcb4ed344af7fd844e0cdc2dfa3cdc8b701f7294480fb31013a9408791342f3754d5fe3b9a1e0505c1cf62217c7022cb4f562133e9885c9e94aca1550241ecae5c441338e4bced8593e507040baed8cc1697da99e99e8546cc75beb8a94b04e21c479198bfcbf7c267893f8c635de3e11b2a30481e303bacc833dddc85d5bcd3c37bf2bd7fb6c833522ff0dd86198016099272fbfad6ede81595cbe20c1135450eae6ab14b77862f9fb51fa4fe52a6d7d6fc55048ccd28c0613a17c5e250787fe805aeccbed7ddf28789da3a73131d31de5dfe392e9da88ebd44ba26ea8f5064f43dded35f5f53f79bd021fe0da5403d76a6500e0736cd62601c6cd67a09ab0452059fd7005aa007f99af8037bc2427dafa123cdbaeaa5ba643af53cbbf21c2d2b488f6d81034ec401dae56689749170ec1201f39736bbb95382b0e300246b71021647028d4d23f9d43e630cefee8075f1542054ea3d59f17bfa85f2d5a56bcbfd1d9cff02e523f376b605d006ad0b33e7ae6750e862b51094dd4a175469d582c7853ccd0ffd2215a1dc8cb79bafa9205795df48cacfa40203e52f94e4740592ae5edbb688c8cbc4a8cc31bff1adc5b99c09e6d8e5224717f70c17ff06fe346d8006060048c1379d582c9b2ea16e2386b9e894f2566180685013cac80fd300d17d927aa83b3de7ad00f59e33953f2a834459696bfdb193d5d9620ded75e0ff3da9888673426ab860bf4ba09395a9c3b812e6169f9ccff862fd905288b41543d48ba372b8e0fcbf3030186a9863b6dee49725031a6583cc3e7da3bf3545fef966292bd8b41f98fd9d8d2333c8d562141242f1160b82191396a5e40c2ff4c052fb294830752066bd251ef943f88ea543643ee12849cadff6f5daf8067f8e5f0e7f09f83c4b59dbffb71a2f7dc6aa6ae1fd4cd89c9aff299505e7ce47105bdbd0980fccadb9a81e9e7b8f442ad20c8f3c4f0a621733728007e3e809e57fc2ed85de7d577d7b51707ec5d6fa323b760df40817311dec1704f8dbc078315e76d7fe0e0c2076cecb55b72853e0e8a0d4942bff68d6c4c33d37ac2f597b0fe65516dd705f9f1ce32cf130c569f439c39eefece9a7bf252d4d48ccfc43798491dd873557fdaae4c2aad0670991a496098b4701a8e60ad3b35d86d32174bba0ec5e93896a1d7acfc4799ee6aeec8fb7b5ce52c80aeb9ce756388b26d7d31113c98b6e2fc2eee13c5180550a5ca060b6ea0f7e06040241e9e664a1864b484afddd51a1b2f9bab3c13341653644e50daf07dcacd2000a9c62e66d46d79bf0aa6af9f27c6adecd191e79a565888037c7a1105800adcc04dedfdfc66b45369e85e34348e05c980478e66d0b7fd7f6f2260dbe268a6bab7ae3dc58e084f12e0c9ea096ded681cf8d2fd8051c0d1d6279817e7edf4cdf042109c59e65efe9e903fe1863087f549f07beec7b80dfcc2a958a1b954f8080349e7d70889a79db9b331aeb6eb9a6d2e4640adb9af211c0ab2d24b4162b1ba704225a703e21f0bcbb6c7e07ac259d63096a7188780abfa000694822325985e009ba55d1d8e9ad95e893b25118e57ed045a50494df473cb517d9432ee89417bd1cf917135c95cba366cf12650d7bdbae67c2f3ffef4bfc8c64f1bccbe3cd6d75d92d28d20f3c1246882c942f52825da3e7db8f9288813bfc50e736af31533633392e841c9981f75f5fd582c362e4d34aee4d83fd1e84cb380e8fb64494064e4c684f721290942d3790790a23f480d4eec3723c83fff4fa45907dd60ac7aada6db14acfbaa872005a743f9e862f2f8cca76b6bb8adb7fdf3809ec78a3f2f3f0a2206bbeeb3664bc73450ce6f04eae2fa14849d4273c5d81d0a8f430c5141e4c9b4f764b07984e7470431b1dd45c524ed30d356ae0825d4c49cc9782ab283c9e5807c6a51539fe0914792326f2e3b0792fe7f1da75ea75db4d693fa1f5cf3daa4f3775a0e5c8d10d4ce9506b8e012dcbab74f9ad3b2036edd997ab5bb28230a5bce070846a198cc2361684967fbae25d09bdb71474361cf6dc8e1e0e395ba6b7915e6114ce305a07fbc45e8100c55c6c7e71c69f828126d2c6db4cbc91f46461aa04368ba4a9a9d8152e01f1adfbdfd1c74e2f3fa12d3bb3a946a94c84425ffd4929a7cb2afdc3dcfd39a33dd9831d26a8d6a87944bf68d380bc9642b2e88e53c7a0297839d5b226517ed72ccd7b497b16091112c467f7b122ccb16287c19e09ee9981a4208a8d18f9f09c57d0ab75ad74e3270b9b3e7752cbab88d0ca22a96b977d8f39b7d4ee0ea9c927b95ebf191c7d8ea2c61fd14202334f2bdd27ea56b2c56a605196aac4adaca2f4b6e45b63f28a368d9a5c3ca0c67e38667b11ff3bbb179e48e9ae0211ad9559c69123cd138b09571c98556cddba938aa75b2e956a59e5f4b27e367d0fcacb8c9d907797491818a005e07d1ef2a33d511fcb3469c009f80cad363bf5047e75d488a2c3df0118dd5efe35fa297e867388a61e76e3f635502bfee61332ad7ce6b53dd54f5556dc9780e2224a3211b029a33e10ecc95a2953f1b972135c7a6820d7555bd26c0d9d9364115e5eb75a0e6f97a952a66be68cf6f13a7a129f4f274f35881c4b5c98c19e58d30214e349488be89a3447172ac6903ee5bd9c456cd2ed5aedec6ae4dacf044df3dcc9d00351cf4f0a68a9aa8dc64cfcba3b6a91b9055f6cffafc5acdcacb11ef303cc0f486eaddc48822a4a5af3f46377db4826ca66d496ddf45bcefa81e7881e77d15ab1bd1a12da1d79205a6d64fc284b8dc9176201e779ac2997825c95df05d1a013b7ea3d581ff6d146cdba07c49e2e608e959092b8db7e2abb78f2170d7a063e13c2ec48e57d4e3cc95c4fa78e7b1360a0a1c6498133ae1fd8266950d5b9c35b5bde9b6615180c64ba382288ac02b6a1ba88bce8016d0cf7e09300394659565a85fe57551e79b176f17668b1488d052bb9e9502637e82dcf4b0b7d5570eca735847e9ab616903d629603a145ac19cff3f2023eab1c89e3aed782db73b0ec6e5fb896709ba20c124787291dbc807be9001a289a4abeb2d8e8b19f60625d14f83f5205ab7f7847665b53f1bd4a5ddd5a545ab0acdf0132d676744bc616bcc57d76b03b1809e91fbc91743626550d73b5924ef204ab950b65555e4dd31811e8d4a249c493676af559532d202b2b71e1b0c56db0535b77462a4d267f098916d50c57d28ad9e6ea142e9c784f876a242cf42b24ed5f858b0da528b8aa826f0d8d93795322178d8f9b60d40b5dcfb5b2a8fd96e38937f12c937f049d23e950b5d71ce11566fb009dc618f697c2fb7d390c3c9103af2d88806dc759f327ab0b0ee422123954e94dc0c9c397c520cd8d8c4d0a144744ba33e38f67afae073c033752c2614b5d56b7c830bfa23393dbd8ce266dfecc08f5d4a4008d05aa2a0055f87adbcf817e4df7d523015af072a1f73c1d1bd00bcb664818dd33040c28402b8d101cea2264def320475eecf508017e2bc97044e7063b85e21d282d7720dd0a3d604931b24240eb68f84bb055ff9fb312f1aa521eb648289e59d8d3552492b378da24c8caa6b3af536bfb26f39ad1c428f8f97d5c8a59d5e4eaa905e559cbec3962e1426e275436afb0a6cb425e52731732f1aae329a76bd7472fa8d685fced530b444223aec0ead867344405e70b6582e5c37d69dff1a1d9470cd8b23494fadd134b69440f198a5a05b13821c1a41cd815fc9a8d8630ee31ec3d4fe468242115f27e3d155f0fae531b4d1c73880f9ffd1dadf210c77014bb07ebae16a00b18cbfcbdb02ff30d76255de58ac31789e8592cdc5cf00827dc67d43e0f8da5ebeedd752a8ca2a27327ebfab651b47b579653b2667a1f10d77400d111260f73a5e116f7efed38dc8367ca1a6701517f387252af0dc5a913c62c37e7206b776f8ecb2bd7164051da780f5455e9b064760d23a1ada72be98a636a90102b6bfdab0e972490d616da376b5b6d9a58bfd6bb6689ccd988dbe1eda2625108cd8f35697532fc2d953577fc743bc984432f829ceda9800e8a55a3d44eea13e6a6341d75305e9e8fb31923120a7bc4cb64f3d9cbcbcb4ed533bff6ced7bcf522766ae3f527a91feaeef9eb0f06d9eb65d3964b250e9a58b6e148d7cafe30ed454e5bc7501e7bb113151a5197d938e1b8a44cdc430c985b0926aadb4bf607c884c60741ea4521047a382018ca063939a5914d101dc648702ab1f8dd57808f94b854fc5f2882c9e7fac2767ba0e377d97778805212ef3dfb26c6b2c909af1e750a6e945c3681a85afbc922462d92423abdaa3b2391c0925214ed667cd002f7ea16210b1fef59dd8262802ebe9c7f9f2385f48daf12f17c680bdee4bcc64bc53d95c8b3f5d1b2f07ac02145aad486a2ea0b53ede8bc70d44d0cef2256c9f4ddf3b44de1e1b53178dcaf649d554fa9bb1f0977202f8e001b37f7a6997af417ed9b63a5e70753fc1b86ffa465c94e77e5356efa26341c1f810bf83c4579db4ec52cfed6cee46d9feab0d9777c4915ccefef66bb4d8174bfe2f62805a4465295bb407493507f3a56b2a747035d2080184dd0f559c7010f6cc0e4bca3e47c5d5526cb3cb08b1e0c5010e6bb1784ddb8042e86ad1e16a2fda12b43e25ea7f746b0dd37254169e53a4653e85d17771d62b3632840e57c630bc14d2aa8d7ff71559a8590d0b244d2492b03f18f7167852b9819a3c88afc4f66b5b043a5e87f7d2811b4504920aa5efef4a2cf5c864108e7eb860754d660e7d0a74e03438d98839850e6ef6bed7415a05d7c5db2f9dc8a96b6df63071de629647850902864d04d75d41eae67a8a76c349cae67cc80f1089013aca298ddcf0095c27e30721c226b372d3312a6b16edc6b47c3956af9d2e6f04e56ee2ac6ec68a2ab34af518a43ada27fd74300129eb1e6179256a575606acb61f77a49a3a4452a1c98373b1239c5e1dea8afb1021a58a351f52ead8f0116f66cc4d2fd072439c447f4a45dc93b9e1c77d4c416ca0059280909a55fd206a55714dd65040c9b661a9c8d2f81e1e6a8bdc003a28be4bf2421a17d01837448503a4f3ac9bf85a5e96356a15addde8ea05a3c4b1de3db0fbba65e0e8c9901e690607182ab4903285648a7752561a18634b4f6661368d694816e0e40fe2ab3ff55bbb22abe3f6f1393134e41684ee66fef8183a6fc3f3bbba4018b9eb65133be9fab1fe2d1ede12047a7c248cd8003c002754999addc66636ad6fc5d5162f3a34c632afea9b7112fdac230e2e6d199e36b919aba8fa5fdd3b31f7812b040f8bcdc11e93745f298f78c101811e2d17afdfd67fb9379ccd79ded164e1b4f53d8579b0e9efee4b75ea3e09d74a5f97340cd24e121cd0261e16db3de91f2e3ea5ff3f956580e8196e04bda706a2a224911a1db488fcbe7fa7e73048a9cbde366850a96ec47b4dcd6c58fca15e8cd6fa9c779887f093e6568a6e59fee5a61b192947a16c8e150d4a149e6a5dee1a808b842e8b8cc8961df19a6d2db41a6aced83d0682654216406487c1385cbf1ccb1aad22c52cf4b529bda502c607f02493d276690f501e9eaf09f393b25a1d07543e81d58f8240df29d92381ec40edf3d9cf148cfbf88b4929001551064f766e40861e0720533af3c9000c5367d325c268ce86a783a2c633e68d018b936e59fe4b137d80f3f451e8bf554ae62ab5f5c8bf07004ecb8e6018e9934f43ad215b0c422e4a7bb7b65cd3c0b372995a4a7e217e5f5feeb2d7c4c441b228d069939f01fcc669032939030759c435962b71156f92c1741b9d0e8ba5cb8ea83cef03c00d30a9fe8cc5af4257ec57c76a636387991a80ac4e1d0bd0f77a971b89e46f03308195efa298c88695b979e5f2f7de4ab20f66909f4cf0b975a829f1f7c44e15fb5c553bc1199dd1694f60f070b9a8218ebe8347a99c46fe57af2bd7d30f8ad4f00d95bf3a36240fb174f91358b503544c0dd76d76e0ce68cdf61e9b1968092396889ca27611644ed42bc25d90892454123775fce64c9e902f7e484b0af0da1085ff72ed65f1e4a197f23b3793d8c54974f7e20e249c69c30ebe55aaed277f164d36fefdc635bc2df32d92901011ddc497ee8bab60c4546ab90146e85531de8582de859afd96eca624b6bd48712efddb637e7c87809bf1459811dd2ecb48aeb706c6aef531003d3ee4522b3982ff69f799844c24a3c81e67b7ee00e01fc343ceae692cd1ae8a120f6d5a681641a49df1fb5bc7cd552ec658495a52c471ff60f6084fed1fce489264a33d1b8090d92e106d82056dc52a38b6d895656ae7af2ee6c949c735c5ad1ac40517f23ceec13339f98be71a4f9e3f75efe0e4fd4a8c64b46446354f75f07a838067c545dec6b9349af744348466df06813466ccf55b4f7a95d9f855453ee38e2b23612e7aacdfa63b36017ad44632c27c01055be32b0b9390d594f5be7cd30be1a91132e9028af522db91f07e97d9dbba68070be9e4d96afdf18218a683c174a03cff39426e9bb7930b44c9b88455aac1ce69e3943fd06e7bb805de694e3c47c356c55522432a30cb260481477bfa58a2abcc2e72ff734373589dc17c6b4755277cb470f14ffd87905d10555cf82a24734982df570bc015d37bf26a5d0e70c2e97db1e212a424942ede2b4c437c2f5cbd331cdbcc042c6a5886281da32f402df1410455d7df47be42f6cb6e704141858a208c67776bf85e348747062732bbd7ca8f4b2590264fe2cc2a0e2c42ab0cdd16e3fee38819730467bd867a5de913f028ae3bc6b25ce4e195bc85401376a70de35729a01834d522befc52624d4f026cc54ec8b5b46bb1ccef1b722079357e6f399b8146f4e99750b0f61b431203ae3c06b1e0db8e397074a0b5f86044142738a02b1f8eeabc556000a12fc8ff6eff80d47088050da326b01b767c6d1bcec1d2b35faa15611e823154af80bfdd817c576d1a442e8ccb3d205b355f656433c43c07e509bb9e5409c7d9069c3989e6f7c9d41e8600f51e98ceb84f0bb155e758245f6b78dc62458bca159f8ff67f3e7220ba97faf521df976da32c22ddad314a9a5ea3edc4814cf5d4a79e0d58c02f7894bbb0f1ae5f3d03b56af4c1b93cee15a6491a3b964fb4dba0321e4f33fcab7c221a3e97d68032bbef32a1b4362cd2b361af9d654f335ded4be70889553505e6c3784791cefe17fa121d6e9938ec987bdfbc2db7b7df9282ecbc480dba32c2a7643cbc95489ee23988622b0d8d670a7e88a3badb24559d5dbc941c4d2a57ff4f730faf39008bdf36c7ff2d65773c23c9ee126ddce0b02e88392fc1cb4f87ccb069de7ec07b9bfa5a9d0a4caa6801d7e1069f3073e3bf7955589008f382956cd0fc9d0cfe05489d9fd470165ab918fe05a17073cd2b12a8865aaea3624b9e089b8c18673f8c74690490b658f46bea1c61331fd21df4db7b398db06e2dba3a2e226837d173ce190f46a1916ab05f48fa6f827ce5edf57f375f227642abd20afe01e418deab7c271bd8d26bad799d0767c1ffa26df6d092f24f7c82667967066d1038710be7b7cf65500ef470868efcf51c84f55adaf08777e872e072ab816fb96386b1a6dc485b01957a9b98681c1542c9355c203f90fd62715a6e187336554380a044bc26215ab14ffdf89bda09023200a0692fee4feb04fb9c8ed5d0f7cb59e24a20e9cbf55bd346e579d245829f6bb64544be94775c018659a004be8cfffab56c6ff7dabd18550a6b3163fb2307bc0f0b68a99bd3f123d9bbc3c3415ea3bf1a7a4ca52a25921988e80d5af64dccc05050e1a68e765950006b7acbaff7de6bf6bb02b05689da2356d2d9654f1cab747868288a2e4ae2122773666f7d7cc9293547226148a80aaf32ee9a69caaa3e6c52382b8d202ab21f79f93efc0ac90df7b13a2fc91c93d277e08d91adf4afda576d35e3e9aa3fc1a82a5b091ee108013bf2f9d33e42014573de30ad8992adcd0fecab6f9579516325eafc01eab7e14adda2973b4412cbb3c9072fd366f01e503b88cccfd8df3b08ea709f8ceacdb4fe4c8f9c532d7d008ecbde52a2150a6818818f7998352ab51faf3636badc7cf880aab810896ef23a4d0d3b328a86b8e416a273967b5733cde9c05894ec5279262406e8b513d9be5de688541adbccbeba6e00efeca09662a61ce083e32867bc292609dbe17f061d9c3695df2d17fa2443ef94c03cc95f8ba3c443baa0329ef8bb3e9abe27d7d045395d8f4d24cca8ec1ca0ede1e7f60359332ebf44ff6cd9e7148f1f3c285cc3a058d01c12d705dac8933d128319d66994171464a20bd77cd3386defb38e38d99cbeebe5e8c417bf6efc400398de524f8e80b70a20439ebd4e5f13be4f96656adc3b5b01adc5504e5787280e867d329db51291f69cb92db1043b9657afec77e6c06feebef0cd703261767046b76948f8f078f96abae40230e09801a65c1f4eacb36123e08e5fd9d26036619f53c048291b68ed3fab0eca9701a78184b07dd1a58e0f534ff6c1f08227cd376e6a6724250567e2fec0f0b8a5f8d0dacc626a299a0c45495312ae663a9a962a9b5069b16b3d029bbfc89300a9b1dbb282beac70ff80be53addf103a1b365792946e4660366887b11d49fca29bb42db3b9189170635e5a81d817c5501bad9e2cb9dd84189ed321d2cf4c913be322dba5244a97156422c6c13106c2f72a178cb8b253655ce428fc9d5352f0108207df3d5f46d43c4919417f5b3cb573f57a7722da6dc5c8cb2ff3dd5fbcd2758c003743751a523a7eee5d1df62046fe2e9c0d1b3974e66db5b2766db17d4f63d86d73f76991b55194d1a2c88ddfd5ac11b4a691c3ff4ef3f33843b7e720cd009b6e7309f31ef61e611b7800e8b235ace08434dda1f5cfd73355071cdac34b4d485990075fc38a48b58e7c2449c00dc6b37dabd42f8e5fa02ad6515930944d436b739dba49286869ec6849ddd81b7dee66c2b109f9dae3cbd846ccb753684e19c0a6dd62fbe78e899cfaff4e441631a1f36b14adbff891813148dd531217b172c9c1badf37b3990d51aaf9202ac6553fa5d5417363ec7109662935c300549a9f2fe4598c55e4385c68b23f735ec18a0a8143e61f11553b8249df278b1a44efa8f14e7927c5d2e08ad3d4810c90080b26e5fe9482fadc86689f8787296b39b145148954d42c167949a1bf3fbfb04ea6364347d48bc05a1b69dc075b005fbdb36a57dab9a9880716f9970da2cd61663633229c0bdb31fb43361bfcf20e3efa6eb31de841093e8913c407570ef9422aae986060f5f704cb29f08e24ae53fc5578d51aa1dea82c736ce71b82af07f6ed4d2c6dc4bd037d268fea53ed6014876128148f218f4f6883cef2d5037aee962d220a94098949de2d6cb3ea278380cb17e0bbabb6a7a800d73e3a63841f2b771c4ed0258a31c354dcd1673171289d11ca4ac45e79725c16f68b3a80a14df971d6b519e25dee7fa68c6bfe3980b4cd2f3b2680e0cdfb00b45f037ec0e59fe480e813dbde368771556778896c9b690ff3cdda21a97f4e1cb4e4c5f25cf92ee6e01a6120c61c6578c2c0d0a638ef04a691cd58cada80cf4568af13b0d41de18b868b27e444f129fee37a5829c09851924728c8e7e991c794f1cc05ab87eeb16244c486efece9f1a2415a8cd43e911549e8671d12dbc5f663a38ca6ee4eb8eb0e13c90437b1a2cf00a0b2bbf006a6cddfb05b57e504416ba3775ec57ff9e284737bf024ffe65589149624762d5cc483f385da4b7f6ee79f1b3d836dfe5686ba6a808c387aa6e4b08bcea8e7ddac6b1d8bf7ecf6d6a9e8d22016b296d1846ef921be0b4fc3751dabb0e9fede4b2034ccaaa9557e67a9d1e1c9a85beec531be5b0de9d27359eeb361408561e4b3c10aef4629031d8e93b788424e71d6ee039795570b81799385b3434a9542666bfc5a895a5b3175308f9ca3006d4e94453789743352c292f2c11d1d83f6df21b45c46db00ca16d63a30383a7b0ed0ecfc76fc8f59120e8d464a00f5457bfe57522a0578428b7fc33cf7fa66d2a07ded3a814b06127851709bfbae1ba3c278d6fcc9d9ba59a1a4921b287241ac0d8cbacf0826db063b6208766734bbfa037c7325f6d49dc39a131e26ae9cad17a5e3604581f34594c4fbac6121caa29276cc4f1852ce2a93c342c74e29b8724f78fac1f07a7c503a2476a4529168ba55a99a22802947176fff9a40243c8573e691c5302bd83e98d90ff9767fa3fd00edddbc00853e732dcd329babce2d75e278b44cb5ba795c736cb8d898","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
