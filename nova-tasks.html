<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"de4202f3de4c8f0eaf95c7f7b0464350d329ee1cd4d28f1fde450848c967a1227a5068927aa58042f08cf6ff7a3ed78ca96372f797de098335a021170cfd574f262ff102a00d919c1b16663db0f805735bdd42551055cb604f14e00769d711f0c4b6e146f03a7c8cc287c9947d1825e4420d1068a6ad33c75834f2782b07aaaa42726914b51183acefef3e71e77b079e18e1bb839f01e9399bb49977a048f8a0081d2ff3e1c4e145ba3aebdb30599c36ae447aefbfa195d005c96483f41ae4b9be90c5c7738037297e87f2ce4e0e32dc02cc46c29ae0b16c826b0c0c629a402b6e3031c9d1c16c64667af63c097fbeff4f05036e30eef8c36cbb2de4ace73804fcc5f1cefdf5f2ce68c42f048c285a1744930a213c6b4a167d6f9dfbfde2244a68c688c98951409a2fdcedc4ca1c6db8a38a33079e35f7efea6cec9a5a9a3089b0d8a1d6eb4a2e625852c852bfc86188c10d38f98637d780eb75bd409981e53f07c1af6b1dd3cc152bc29e2354fe19177e6935741b097a15ae414859d1bdc456dfbb2f6056f02aee11e5e9e5401c924f59e2986f8a835325a3207f6b374e70705d20158fc863400ad00c34aa00a1befd77caeb5a3698f75b21ad371605cad572c71e3d5b9ac057b86193f72e4459b3db8995e3dea5da50e17bde2fd998130b11ac6a5d5e42afd234239e7f9b11146e6b29095a49229a501c2235cd0688b9777dd47fdfda9f5e870c71da7331bf2c6ecdcd779ffa258130407baf18937ede8968636231b0e02d53aa4cc3cbf2abd3099c002c08fa2bfc028c562753b7657458088539829d22039968ff35d02ccf4747a0447ee70d0f7e744c371e819cb43abf91840cedd658289f388b0d353fe04812156edaf25aa818810801634130c0a8b8558ed66f8b9445c0e9b82001862f3ce8443142c12cbef0d8925930cf4027b525634fa5d5ca0991f6e0cdc3e0c25eafd92f976a79984b7dc747ed2842dc3ad42c334edf17e17c2780b3551d7a9f570e4a0e62a4432d05c4531908d6afd11613adb12bac346f732dac77d2b0afaad74fb4807c796f223f36252f22cd262296f5137a300ca88d47215369c08bb9327aca3690b13537541871024ee3b5e330d767d69cdf2907064d33368c2996b966435ae72015b023e08446e37ac8a0e197776f7162fcbfa4ac637bb9ca36b95458c6dbe48e6559b0879c37c500ceecf3892428ffc9710138b2c5e81ffd0b722446f82e20b875a4ee3c6d60981da572b2f792c2cf3fbeaf04511c329376423c82aca6a510ab7f0a436f6456f2d604b5ee271df545c874c625280eb51b601f6e4a57d6d07618c9dcb728f85b074dc2a277d3cb7af12e33b090f87f74a7282b78bdab10cc17c09f5f1d77baa4978a6af8f2c9f4634f5e6aca910ee638ed7c23e4c3b770454f41ed4151aa3b91e1dacd2e1fbde878397b2a21020c8d32141c5726447f26415581af689485277d760fec0b2c67d760640bfcd998b9f3b69685ae9d501deba347b5aac9bdf19c52902ed4a6b0796be6563f5d4e528132db999f2fb430c3072a257032feb72363bee66d8c1ea236b67d46b0b5b1da4e2fb0401056b6867a8b894664543f534233e6e6ee0c8256c79bc90ab975948860319774c5f16757734aa2184b533b4fc6c968d5f137d93a994ac823adf5d78727a44f85f2e38f6a98f66b9aa85f1c9f44e19f22301713b5e1b04d230849005c469fa40c5e3b30ca46c176109fb329ef019929d098b23f786a7218fde8de6ed3642430fc3b2899713d4a5cbf3ff99b341531eccb6f932d564d0b9b85f5041f84f428b0d38bef2ac3be3fc25af41f798bbdd74a37f1a8338ffa1f8c265ff7cabf3b7cda6bce45b6b254df00f7f45d12219abe632476bdee559b8fc14bc776ccf57429f86ccbdbdaf594dd8060957a93ff63a13f1e0ce1c4dee651f62a82f4d2d828021d4712a11467683e13839ea61a106acba685049aef83fae37a332b550021cf32db2340eb5be250d80f872fb67a629283e765a727bb04ed4e1d55f10aa054d7501f4df4704ac96097c115de23413a0a3d55ea8580305c18a7b252129bf389b75f6131d5072eec23cea313716b594f1b407e8e9c49a8bdd71a9a87e9faef5221246d3b7f755db5eccbcbe157cb9c765ef46b8f4cee2ba5df02419a58b4f320a8b3a06ccf5b06e72e32b6866951e2c0284114fe84fd82a0f69276121a577bd3926a1f861775b6e6e8aac23a39f51334a5f9af45eb679be1ee05b025a8c1de49594870ade6356ab85e4c6811dadd862dc64d582711feed580496ca423fa32c7df1483a581d6dc37a3402852b75fb961baa3aac7585e216988e1fa9daafcad34aa91f2bd3b1bba91e1fde9bb074cf5b7c79411b918cecd64382184f075f75979f649c1dae9399060330fcca82b54a237cf535bcc5a243eef35c9f4e253e91238be29c97444fdfb31b4f2f96e92c8827c3c163291ef087c85fd64862a1c5b538c0c1e3176f636be989a8c669e2921016097091a3c441eab7a71f70ea66ee3b85bdd77f986e9803d0665e1623f6451519f2188969e072cde483e688e2c47e9e432c63b860d662a16e59cf0ea1b440fbf7d9bee8918c8104b98e508d8af5ca14aa889a1d04ff35621b239598a9833a7782d09b40d8d875411c2e825b6726848f86088d8561e462e08c8417f1b75c9c900662608e36b09a331797c4960bbdc788c1f7d500f1a27b6847016e15fab05605f85028f5e88c082ebb87f927a47f356e78ec62562166ec1290893cb57de08eedb130d5d4ce18ce658628a84d4d49f3ab4a9fe79ec01966dfea8febfc2f578b4bdf03eab664256268f943c3ac289cd1378cabedec3a1d683ad47af227866e96fb0d16cf0324ab365bd27e8b3b551b41660ce67a76fce8505ef41d9655c0e5dd802fbb4e8fe21c9422947b4495022d9baf433dce7407fd8c2a0a9a35ec264a11ea07f37f7dbc96217e8c532cff24f498e374147a7a17250988b5c12e6e743005735299f066481554703ec76994ae45d12d0c56ca39120d976ee60d8381b8e349c374c00a8b587b6b9c80f5b53ebf174fc802916e5b3c231ca72388b44b7fd209184000ca1cfc4273f72f03f100bdda7a28434618b92d3b27a7947aa8d7d1c68dad99af6c82e237fcfab57585157f0dc38d21d6180c59b5cf61debe0ead7eb6c01a7b3af4de5944ed464593bd0a70d4b9f1293396a8a1725f30b7db1e98adee3223c84f469be8791cef514c9d295884c1d800ac102190a831fda74d80d2305ca01ca26a8b059a7de49ee4f225c3557465023da1ea052caee755a0247ca1b44cffa14e267807ce164dd925c6325c2d01dfbb1c822e4d40e436150baacacda81f80825658ca0a42570d34ecea5a2f3d6649059fa213ad70de686264ef17528c45da4ca1baafee3d3088ba8233bfd3116c586ec8247660cc62faef9e0706151bce4f3d5a6ef372e7ea36bb8b5f63575bc9fdee6df682afc999fa84b2ad79791a743d014f5693b0b9d447e346ed8ddb5a8192e52c49c2c8f711a8c7b1b8f1a4f7a83c0351746b7c52724b6d59d2aafd185c21a620ab5d623a3db5540a92e4b042d677d482be9b0d20c0ffea7c6318b35bd64a429848b05f6746de7ef4ac0bb048215856c8e47edf8a112085c73c7631a9a4b657977b78c77fd7becb15b3a3e9061f2f1a8c1b8dd1bd2a6572d7e3b4faa0b3a36118c3cbf6d083315404752eb6ddfffd1823179b8d1e98c5ac8a3ec38f710d470892c33ed9238840ea80c31ad91f60ef97da44ee8acb1a4fcea131f9ef9fb367ecff35633cc2aa38bfef47877ef052273ece43a696a22ea476e952d99e3a760e7f788d895666d64dfcdf971588d3821d35b70260d3ad15e1426e50d7660e04d54eb1ac8d169dd02d590f30f50dc3298d33f8f74e6af28a68e94291b9ebd29ec3f93d6c646aea23144444214ad3e168aa9b627fd181ae6ca61fecb26820f0c035125fe2806ca386a75b9a80de75f2982bff0da2aae88bfc195db068e3937d809b89298d4230d193439e6d70894a3048ed5419aab9716b41f1b552140c146a3e331283f8c30049304f6aa545c513ae88f11932959d014e5f3efff31faf17e46dcfd93eefaa25a5c637256adb539222476b33c336ea1af16bd141950f86e5167fee9dd5d7d8af80bc72ab081ca0e20ed3c644f7de2ce4f5afa10e0982a23861b26d57eb047c5f17aa6092e3a164fab687095d46d221d8b416432fe05bc06797c23b222655f5724cbb597bd9c72c822bb0079874c1811c79e9df3c652b8d0b1f4824d1c6706d78f79d444dce139c11d697e4f2bd19a6877d17738e751eccf5c722ca1de1f85ef7e05590d2c168c33e01cd9496520460f871b1748ff6616cdcce4048e196a0b1408003b849242fa75995bed699880fac0a02b65ff5cfc86e809bfae8969d8400e244937359f76d56335b83f0b00efb0023f48f3a31c8393c4bd9cbce6c01ebef447b8f606bcd86a4b2802ea8ddbc092403eb3fa0238cd08a23528b4d93fff5bc6bf73a4507774930608c6f5f2f42d45213d1b851747ccce22dee93fef02962358f136868cf6e628e32c94dc39991928f282b5449430267429d7207fa59907d93f55ea34ca538a234f4cfcc3637310aa9e9d630fa5b5a96d214a24dd7583a10c3ebbb939a814813f42454a790f747def3f24fb054568710da16ea73f02d99923962c777113996debcc8e1adcc639865a51290a2aafe7cd7cf45d8b524a723c7cc57895cb91ee5d1a5997ce360ac13644b1eb18b236c640fb79544309201f1d7242bdbdfaf4b928853c85c27e28d50dc3bc727b6c49b515b735d1cf953bfe06a23b6b116ba962bfb8997a9316200e4af6dd7eab841cd1e1ea3c547406071c57986ef24e7b032bf4d8fd69f0ddfceb2fa613a8ce85145aadd5972988ab6520d1bd1546b9e7a1cc9634e1aa4528061adf6b784bfac32599ccd1d3ee10b84aa14a313824b507c00b511c778738670514e6f07e3eed2c7f7267bbdea410ff01fedff8acc8ad564e49aa71b06713aa4618fbf318bed1e5ac9b504ad4db6bcf9466a5685924f8e6751f0af968d5645f983f4aa00c54392cc0967fcc6a3acd42a55242200fe9ece50f81aaa43f1c127e2fcdc38fe20dd52252f2c5fd0077493bf15c1b52202d62002ea4b2911b9c11eb14baf6e8d635a423417ad38a1d0f09aa6bf0d3e63d7591377e9a85321116e0f503f0dbb93b975e3a869539f092da8cb1d88286219001b7b3228d056a28e4edc380b656eafa1fec4c6329d958835ea7e4441234770894d095e2b4e0b44a93d3ac235815f3f9828896daa206666fdc6b69d9b9dd41d6051543d592ad2a370be9cb8059e42aba9b7d16520baf71c9df5357f43e389a709cfa1bb9c5953f78ec9f61bf499c6e8aa366b83dbfc07a7ef1574af4f1d94e76319e369cb03d54ad3fc160c1d316b997c082f3e3fac2b2269aa21dde39e0f30fc3fee82c9c55de3838e6a262bfd84d95c6f9e03a2f42c1b0c8f981908d513b3801f151238e9e8e9768ed9c10ad0e86a3607db49912e9524b08d6da4153a4e538c8946922490dbf8c4e7bb7f565efd0ad53a972ff0f447268fc3348f1251190dc10ed296101234648a8ea5277317e441b6125169ad03f8b3228d7f58b0dcb1a3842150a2c0eb4a520830cd583b3310300917ee0030342ce6ba82f1cef2dea6228e5edeee03a88abc7208a91d8b44420f94bf719cf662d6b3206091f466925534d38e778c18ca1b75b012a3117054596217c5f4c6949ba5f9c05a5e705fbbad56791157e1cbbdd39b636d4ab640f112007d2cee12b484a575cd084f4a1b57fabd89f52f5d36f114ba470cee9fcf5347b77ddad2d27303f2e396563ad999bd4e24e0f896cfff67a8ea1d5224d304df517872090ec7ab229676409cb26b01d787c5d70fbc347fea171220d2ef05568ef41679fe89c021ceee833fa072e6d0f627912d04a903e265447117642eee163b5abf9d4497272e06c154b9aee3bc88b53cdbf61c477d12673db24fef5de4930f98ece8a5386dc4e4d055c5d8d5c1ef376aead4ce184417e5262c3dc44daee71031791359d768ee40057915f812dbf6ea1d1086ff069b058406869df22b3ff188892caa6e06f205935f05989c5776a9486ab0cdc51f5f5fcc2109d5c70e2c4798f209b86837b0885c454aed514512c4de7cd0f9cef2b1d9b7fa3eefaaf49ce72635101bfc7f2d6db4946cc92580d4432851ee18235a0f3c009795c3af55a66d24c57e421e73636e3a0487d2825230dcc77d82e23f0819fcf9419899758af8b90ca8a3cfb08311eb3f99b50adbf93db3a2518b63026f40dd08bf052a3260a31dd97ae6fa0ba00865df331d247d1eff88a925c15a12c800810448b6a544522a9961615ba000ecca6af06442a889aec243eadce259e4be10800fce2a0d9da538b9816179f721535b32b2ba2d20832899e655dbfcf40e3ac6017e3ed3909d00b39e5b571101c32b3603d04c60e1615e01a36c3e4a7ba67535be026b79c63b85dd95eaacfeb4cfe4b7035601d4de78f9671b1e512e088a15045ecbb98042ae7cfcb8ddaefce82db4bea4dc11d4cb21a1d5a9a60cc0dcd1d96ef5a235fa2488c8ca0a7efe15b1a9944463be41776ce2fc511035133e3d3871f7b76f4f26906696af6486a38a21f9a1123846c5d74e5d0fa6535e2018eef8e57034341f3a8427bcd80e99668286fb3194d578c8e471e8b8ca9b905824bb1101f468fb45ebf0dc08e67e96577f085d5665051d692a8157d85224bbe9107bcb23dd2605db3c3cdd00b0e4171ab0ce8c3a5fa88077eb592184b12c71c5d4709ed760580079064a2a55146342fc1f52e9fced294f6fc95611f08adf86dfe7e287f1fc508b41af22ff3e52ada08cc8f48a2f550d5a9706d62d939b08ee29ec91179178af6bb8446d0059d9f91f455cecead7c0eb96d4aecee59a0fd8cecb167886861e1ad42ee469fed491ce57bd90f2eb5ff762532382b0fef482660a2d39b22d31416833bc97c055f46993dbafe47cc4a5231957e73772f75a65123267c990609758bdf96ae12c3c6c8c32121527b8fd85a0e16c35aca37cf1a3449995936463c13398b6b00b26b5e925bf43f56c1710da462a21adb787ea819c0368e6de78a02465ba52d77bf4dda1983e73c7d7fafc8c814ada9204335398503e9f4d2b73a9f1840a240edc3a84e4a41870449dbb363f3d47d2dfa11f488ffd6678a72aabf402fa50ad281983a38df21bae4b803900c2d7b0ddaacb82898c144d95a24da35394a3723e71fd4bb25770c51e1d9514b80a24c35d62feda544b9a3ab7577808ba8eb574a3cf9cc438ec3250158fd1bde5122fcd28bcc253a1675665aa5fa768d59caa5f5fcf3cf607da8c12832fabdd0b45701b4de30a43089580c2f52b6be6c1d8788407134357bb2ae8639e0fe36f1222e4fd72ea17827aa9c748fb81772d977bd3ad3aec2c800f5014f719049fdcddef3f88b417a7fc28652bb09cbe2b181c95d93a51a9c15f142028e591a0285b919489873d6a661ba2041761aa1b393b4da39d6486c9f3bb7cc766bb2a809836865c920256ce0efbbbdbb152d4f3bc59be830143da78630ec7df6ca1b3837425c59b04f8dd5ff528227c75d02c335580f115fcd6cf00b05128a114e7e432636a45357c40c39005ec68368655012576075913bcb79339afba48c177eef652dec4493a99dc4571f06ae3528de8095bd2d647546420f272f2910b57e11efb0060c4cbd697891b211c55b0068298616073485d7c2d89a6a13bd8e3dd1f63b2d18c8e0a6d8173fdce8b241e63d5822d8752a00f0fb0f72cc0d5d787286778bfebaa14e3257a2da409926b0f82495a2714c00327ca49e04481d23840ccb22e82e6d77986337cce2a8a71e1132fe14a7254c2fb087b9cae35bb1c4fdd9145e634e590cad967aa2644692e38954b32342f93bb6f2a11cee243afb590e168ca9aad9e889007e712ec9a8b79268a0739176e7abaee6e85d0b25913d0eb6b3afc9b9b631bd6ec4be5995cfaba0d878c932a14ece722a7cbcdce612a5cc3e7c0f3bfc767baad2aaa560869637ee83cd5d40aba2ede2a1c69bb5484ee499ca862c63377d21ce6e1ac8151014826aa6c8a617fedea16ea3aeb0bcf24c9e0f4bb8cdb30a12e9ff0f72e5d43e529724819f2f8e12dc6ac51565d9c45f89ff666e65945080bd75e520b16d0cb08c74cb4a1a9be347d2f04d50c65e831ee4062448a52cfc56660dc66339cbf6a775b1fc3ee8936021bec913a73aacbc21cac2c0f2804a55734ae42f93498c837d856d3016ae43fa64e0b8f56993f04356b9fdd70f78a43c4725fc1a29a95973f96adc49bac31a54ff6300ed61164ef1cfebc7758ee3c2997544cb4c65c16aee87b25fec280ea95d69d86ab7ef4e76a412550e7c92de21daaa2ed502d17f2b1ef2861d9c0c5d22b4c7e75ad488c3e9da4938265477c04f587fda867e577301724f5a5d2627853644ed822c9910bd15fe38780eeac191a56a102319d36109b3ab71d5d7245d3e9071e7234f4c023a2829100a38d45e9a9b916a93ae32009ecd7670557d33519fece11b7c7eab77c6748e0c98dd02f55d7e9720bd8bf559460175dafedcd2777a3004af4c0abba2e18fa7d0d4462cd9e10b4637c9600725fcc1a34ce79cd59dc999c80cbb1e79ff12620b6be2d9104265ce8df2918e24cd8754d243eb1d4f6e0de8ec22ba39f206274671d622935ed37fba0db7a47694d0f56cfe88693ea21445c206effa276681ca99b1028b8587ce86fc2de2c246d800329d7ded93d7339aebcde06907d400dab1ce864b3559fcf7928e2b7b79bcb780027128fded84c5828935fa985444978e13e7ade5093c617416b54fcc3349b7a15d3e158091c8099ba794fdd6dba7fdba63b2c3658e1d9771c2009ed2d4abb673cdf66bbe013d8db5271e8c9a511be2225b50885442de87964c3276f62244e9629a165d70c6a41404d37280c119facb1c41c36bab14478666ba95e0fd5e62ca4cd59ad9e3fa0bdc9300a1d96ca94b3e1f9a7eeda24764ed92f635f2e420bb4e60c21e933f2aa0b512793a3d1001a23e11e5e3f975750d0c4f211d32b35e11149105af74bd4df291d31b148cfa7f7d8e44b90d3c27749a59c69799c276636a8a478c882ed993897630e6b329994651b982bcd8eab90c6385cab398257f5f3a368d23035d3a41ae1f623042409ad3b43bb51623f121a224b38f5ff60e9a259a80f15cabc57c8f5832a2092d8ef3f0b4baa5bc4a884f96ce0ba4c992f90fe70f5d38e30e2449766df300b4dbfebbe2ccde23e2d8e77d0518c2d811a70ba750a8d17754b216b88cdaba007807cfa505499dbde877c00621a3f8abf00ecafde030ad83db31656c1a8a8cdbe3e98290a7520c1c3d81772264ba594641be6efb463b27852a0df19643b4d21511916b004885a4c292c19e7fe278d7fa7a582449875303aa666c41d9f6f61d297e52a197e1100acb766cb73c0db3b8f115fdd2f1823e1b3ee1cbb521a80976b9d85f68f4339b269a5a3974b1207ad4e0958f35e5eaf63d93d50ccd152545a1fc2cef2ac3954922244a0686d3275aa2ba0913cbe7adc28193bced8946d8e7be195d973184e5cb9a2d527cade15b34900e172ef30fa7c6f3a04394f8b135a76b9a7eaf6c1155c311064764d6130f75ff7024b91561f295659da88a00238787b7927c19fcff9aaea16bd1ca56e4d8fc215e74d0a80e2850ddf841876c029c7651f8689dc6c119ae86120642437ce2bd946247bf3b7618779b4e87039852d647aaf6c931afffc489db3a5fcb888f613773bb4fb12ceffb8d0d1ed1b4fff11e86a3a42355de2bc434c0b1e4a2c15c00bb3ed884c4378b79e84a621a2ad8afcf725c0605523594394d693fe81212355e61d451d7d72bd5d527b4cbfa6da8043f51c2a45b1aed24041e2f19aab54a7b4b8af8c26490fc07f1211a5ace307ac569d9b43fb17c1bc3e28224065e946b59306630a83c810dfe1017ce6a41907a601b793e323feb3dbe27532fea6bfc2681e7c07bc3cc747d464b05bd39dc84f458e3d7314291792abdd84b79d260491d49134d058df11e547c8ea28fd9f33e04e20cab1136b1f792f5e89a9b0992d3097c28e14240e57a1f286b79c7ca634a8f563f8c1aa7ce9d2f3b5e89b0d5b96e0dab34cd20a05434bc4425abcff4a37661a90fa7005cdf7d90606b5ac1b7b065e8b00b48977bf59f5a5c8d52320b6671b8d799c637600a7525b92b5905024d080ef60585d2817644b83d1ef7dba86fb6f904516f574c30d04087a3779410d4000edbddb05e0430c182024ea1fdb8b47b5762cf00b6c74139057c4d25db5b812c5ef0070d5a2b185efc7d7ed4b1d2cf38205f235d480f6dd3c27977ae41a2b7f415a9ebc2894eceef71f2b967c7f5e45722e1a54cb6569173260a3dca3b97c1a9978d4ad2ecfe215bd022eb7bb4bc6532abf96a27271ec662e5d8bfd719f3332b3ae673c3a8a2229e98cd126576b2fb42bc8e93ce1b0f21b8d1fc0a86b106babdfb7943b5d0b024945ca3d0293e5cfdc02994b46729d587854c77fc2b046be4c62e537e1fb7f86da79126493b0facb49f75ed46171db39f17207f37dc9827a8c8ac20d51d7c66d016df5019970f2daeaa313c0a8db878eaf167f573ff3f1354e7d4bc84877231ef7b16bb8283be94a9a3474a27510fa938fa1d5e5ec628e64e050cbece8e1b9948092b6632556956edfd306af6013bda0f5ea136731c31ca92c74092e164bf33e60ecd1a3038150e19df2ec3feb69036950ef95adb4892a886a5538dbab64d4428784b437b72422713d39e2f2e4e379eef5e0c09b974037fc89ef1e3a01f8fd7a6305baf1c4e6de8d83bf5fc7f8f9548a24b28ef2215afb4cff1ff164837d9908f6740a6a1d233fc9b93a779dd1251cb45bff6002f3e478ab07cf30df05455cf689e4cda6a4e0ad6c05db722affb8c56e2ef5eede113fc3876d372c73d8f50513905f4f161ddcda29d99b6069828e3e7ed1696c12df0857db6fc1bdeff1f241bc486e8f72be310b9fdc302fe4695013ca246e1c1f2a8da692c36d764ab1e7c9238d0075411c07ca7dfd6a89069dabc1b4a4e092e3fe199e81864b468c761ec1b4c543fcb14d84f8cb3545221c4be6b109671c9170d4d2df5f376e93133c9283befe1dc52c3a4c833d37e0b362273603cdc726232581d7f01a9377d2350424340468d3b086323d836f2e729816cd747d523ec09e6a2746a4756d9c5c8a178979b378828dadebf3ed12fdbb1cf5ee70be627475266c48ae6dbad1bd26424402392c93546d81446885bf594fe4a69cd1a699025e557e318a05a114be16d514d6a15ae1d5f7fd495c3d2bbdc884986f181c0030ec55a10891dbbb7d85590a991b7c6930f1532c26c2ac90edc90c4dfc1930b220bf91dfe2ea7354dc5a8142833a05421d50cc1f2d9527b09d0a9e2eb490a66a6c5861cf9b439eaea3a97a5cc8c571785f1e45706b003ca792d08e826324209b5d2e58c1cfe871228c2d76ed47ba5aa12b9f65057d2ff00586fac5483ff9632b5bfc4976ca80decc074e0141acefe947daa84b3fdc21ffac8b48ad4b4d569e587f9708849570941486257017bfea42635b42a39770f0c0837f264f919b375f35dfe967a750796086987cec63d40e67e76f59ceadce259482324d73832cec5384bc1d12a83b5c7658cbff593377e8327c1dff8a64c13476d1787c86781ccf5d1dba9bdf084998cd15ee34b08d8edcd463c8e5d50fa730490b70406954c1f36b56cd70feb63e425092a7aa012b9e6e1d700c8c7abad24b463ac221010cb67ab5ea0d489abf918cfd61e68f95ae70a5b9f76e78a1f09e7dcd2bdf7714adc4f6ba9d724493ae8d1064e3647429444a7231caebda5d28b51545fc17d00733b37b4b7bd11509ff8eeecaccb2fbc5415119af32cb4169b4a7a1425c53fbed580a5f96ecd1e728ed3d1de90d91db568883243c09b5e2cd1e4bc68423d7206de80435d6b3e12805e3549453d5aa079f34805c8fea5e7249f3ecb8903f2d9b4d3f8289e253bf8e34157c864257128dc5b1bc363e8f679de108749d445409d7afcd4463842937d42daad1906d67e492c41350022aafef5e874db0e9b712dd73a7ba46501a8c97d3bd6f090fd7a75e7a5652bb985acb52e47f041a884853a2d3e2c176b34afd2b13185aaf14a28e5a9e47e258b15482c2dd78d2d39de7e57c5ea4aa7f78a7b15ac2bc66f72ddc9dfd4997619a0dafc7989aab738597254490788910a73b2094f9ac812000c110ddf5e26f50e481919bc5380067df70276d06711cf208c14c4dae5ce8bd8476b97f3ee4bb9b4c805d9b14b0cbbfbed0934f266399adc4456ffc2466eef856877e3da24955e3af460bfcc54324f0f8218281c4fdb2182ba6d88bf068abd1d21753feeacef0731a60986551c573cf1b4fe0c829ef512a6e694eb97bd3fcad2ad6ff294c418a043341e0b7eb48f63b45d6ad35079964c0c5fe8514a320f0abc52e28686ad4f536825167f59e3af75636e53f4d898812935c4172340524ebe3f94f1ec0777bc90aa4bd35895d5a02929d9539a2ae958b2a4bead252750e80d7173d4798aca9dc229b7625739e5bbce2bca2c6b48ab0d56b77113a7796c533dd14114e4ab0048218b5490a3c8874183bf0bc6c141409f2295d7ee7b5124bbe6aad563ed70751dca6c69aa4fb839327c505dab71ae41690832974756e49f3d99d287d9cb0b5a0f434360279595c1c9f2ceaec4a0637fc891e4579e2ccb4fc964c76e7bb6c566f6a59b3b725df6f425655ae2c2c84ee63364dc4f74661a330af355d5ae73959a7c624492db16f837553397d2c7a87968d6fcceceed7588ec292cd2f82d94bdfc0f6f582cfc673c01a71f4305e45e0abb58f97f73e2475fd7151d94e9c8a78ae144f4b84c55a71280ddd1cc1c1a5b4b04698a271f7948bb17786ecf289213058d90b39ebb2e2b62b18a7f1fbc476ed7df0296243b718942cd0ec9c0590da62f9e027ff24822bbc02be04f4232d263c8a90cda4b7a6522bd94f4102b79081fab837e9b8aada27e3d746d7547e5f645279829adfca4673dadae3c84bb2b198f316bfb894dbe9033057831f6544618f737dad4e70cb20aa32b2a798807eea959dcb57204e46bfa9d610e0ab76d158f64999008af0666c528217d17a196d4ed33e6dc0e45b0a986677bbd898fa7b5d08ef098fae93867e3b227ef638a14c5eae8cc3f001ae4e091335df1d3092990a09257f28310aeb10ee20ce60ffa36fe6197dc6a05a23fd71f231485c4756fd2d235dbaa23e102ff6de45c06e06a6711c631543010bb6ed995405eb00bbeae34ccfb0c6043db45df8dfa4c0c7f35de955e146658f5b05dcedecaea34d3ef933fd230bd92a52a800537f9a5479b543b22a5ea6d7a326f03fe1d10d505a9c01014f0cafc47d18e80191a6a3ee8b94cdcf3160f463e15d0b4b2529df543ce55ed02b35e65ce2136bb9ae999e63fbccccf5d4bd141caacc947624a11c8f1af53cff46c0cdaf1e4d209c4ba54c48ff98499ed491fba961c5251523cb09523078310bf4dde6500fe36f4c5f68de8422ec2742692f68261342a044dbc742323f998aa7d590bc043a493589bebe189615e8f41bdb2021bb017457bdf374eddca16ad2c0e66d9f1d05a65de2340c3f2f5610fd5d280a568bee5a28796474ea2067e3adf2bf2cbdba618d28ae646321c4ad7b754e53474d3d3622ec9b28b62acb1203da793908a9af7e1390e440727cf6c33cde99d0fe1374b97baf94c2e708c4838826914b822175755c6f152c9bc1717e7b661f121e122af2b1d62b7f40830128bf75c169f0c37926a109478f808f5842b2c8e1b2d64fac926ce976a18ae2afb8668871a8289fb0fb869aa7061dce9915119fa9f64c2fc99dad41ce7a0d7ad2f6f78e21389440d095e05b86f7d22e38c044cb575ec06f8a4bde0ffc9a73888a4985e2ebc91b189e63bffaf2fcebf294b1372b26d0e2b585ee98fced711c4dcc4f1939b543685e182d4164b435d11a9e39a36d916cbf415fc586ec7dda76db327ee45645c25369361561ea99b86631e9e14338507b154f8d0667ea60d0a5dfdc16","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
