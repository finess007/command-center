<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7764eac848fc6a0cfe720bdd227c8fc15427bc63b8b207600b0dd3258e37b1377682a6c88522f9cc10029301aaa3aefa934ab81cc5ae98b2ffe9c50a06534a97e08496b5f2ec12a390864176a174990aa1f593862b3d7d2267ba39f080eb5382fd255aaacf2ae3a510b7e74353fa1d048408cc1121774bc3565a9c38a8dc383e6b09146b46597bae0903e08132e40b63ec0814e6d373171991b117277d764172a22bf8fb6776e9857bb75c4691b5bbe5c219820353befcf2ba5d4c3d519e2ff1553f3e6daf51a1095eead76d5236c173c1dfe0506b4328af35a6fa576169ce04843c413c93f0edeffe5bf534823787075afb2ebff7a2a6b79185a8daade8c63cd4e13e64e6c1d9778112b211111b095b03ddf564452f0497d4bd39506bf81e54211e68a430d8c84ddf13e0f8e8dbe4f4ee8f04d7cfab1ecca97b62b5f090e92e797bce217aa2d5fc67ae2a0d9cd95ac57475b59478e10dc6cacd92b2b691398672f698e24d7730753430683883ac41abb2e64f28641fdec8988ec5e5613b6f4134f4d14da8420a58ed0b08f67d6c600796d1cae3187aa1ebb474abdc08b305290bd0ab4225c4acc5fb659742fc64495f399564229b6f98e4f8763ba53dc8973deecd123ef50414063cfb3c53f092fdd7a37de702632844c1e930851f44d6e341aaf84f98ea400b7e474b8e8c0447fd671c7ac54d2aa88c85d5e38a72bb8ee9b643b7878c4165eea79942d0824233f9d7cf36fc3f3086276042952f230178b80a7683c759f120532cc6c1fad9a478cd4aa2926d74b08cf9620859a68ad81dc62683bbc23a85346cb0b1cac2ce58213335c40a00bede92623caa8e180028e62717be1bff8cee29f22435deb53880a08d28c3174982ecb0dbe416a8037d0679c2bb3dfebad4ddeb5b76b9476e443f72658d7ab75d024495a4b8750b973185e1344cb39e88469e3911d9cf53b854f5bfbcd2c83e2b72450f3e8cb6904da34d57f262325b0582f3dfa479cf14d44fd6ed419456dccae04755faa3b6ba3f0ee24501d2b9f71c36992a37790e4b35761a5300bc0da19d7815f153f576a1e0e89256876b412ea9a0911cfa668d4d7ed0ffe61f9832f739ef3cbccb70ccdda86ba8aa38e114d3a32c7037db03ea6f2b8bf021820b0ca5c53bdeb9ee05b00dbb0aff5bc6025c48e5b60e5f864390506b38b6272804a4b0cd26c8931bd4431a7cc095315fa4ee22921523d8440db15166a55365f8616060a3b082e9ebb07cecdb2cf8370de12ab70e5cdb6e735b7bcb4d5f46b38f32b2c9a75ba07f0063be87ddf25f5622b862efef1cd9ee98fdc7f8a10dbaa8998f94032ba4971462e5353396981a419f731d69cb1045357d2cc3cec138cb9b39397b55fdb7ba9b2a84b2bf86bc339d8a001c8be5cce1f4eafa7c8c43bc61402f5e546cb7148b76e62884b986884f7f6c00247a31320eff77a88c1bbf8e22c59cb2d75aa84ae09b87ea0cd2542391ec84b223998622d11ba091ca22535572a7f3098a4c0e17ae490b82eedd35719969c5d16dbee1b5220147a108c76c0ff4c41d09585a040f65cf217be2fe62f190b484c4e6e6137812ee4c8d1dc25fe04fa09f87dd29e09b0362416bc71c55b87e1e4f5ebfca8dc8327eb3cf515609c44af0b8b48fe2b0fb2d347e09a42b879b6c947c6d8f9a50ee5704a78b6cd016ad072fbc84ef2624ff419d3af3b5e22bc1b84abb18589b02c3042d510f0eba5fe1ba11a7f3bc1aef4b7173f517e4cab4f1a963d34e8a6e47848bfdc920f97d240a395adfdb92ce4565df47d97981d6fe353ee5b7e317b058ac0bc971a0df3415301a2f8bc525a5350c088cfd21d954e55c99c454e22cb8ec22a2450951393cab5877acc8f22494047cd924e73114d62102a1f0e17bfb5d87e05a995d6cae341ddcf0935500e8df611fce5ba21185d059ec9d397be9a7652a9ad8fa7dd046bca903e081bc41bbaaac9e8db6f1d64d1de96ad135f6a25f7f6784d8ba2964ca412df1eec214c67bfa49778c002372b8e0795d532ecc9c5dee60b313bc7506cb56707064115c64ea7b2092995f81bf185cc551c3ebb89b2a00c80dc4f9151635345da0936f957eb485cc8d64652a644bc5dc4fb372bcfed9b0bd0c35b25cfb65fc8a6a2841248a25a98c0c39979f5736adf65829884289ee49ea6e99bf4ec31b1c0074de70c374cb0e92ef98b7b3fe3187dc2f9b67f6ab95195f02341d3c2fe867fac81dad5bc68dd8dd8b3d7b8dec4738f77b83881402a8f4721bf440c552191a98f3d0216768595aa97b7e4b6b319ad65798c9f6d5ac88b4984d160b1a91a4de8889cf52c51d39448fe3a343f3ca1b72a24bd21534ef77985f74c0c5d1280071fd56c7c0fd8834c874b01894e8ef5f13114bcc187e35f18bfcd7a8f43aa2d05016d295b8730e20d37aafa4ccc9d29368b4902eb471901fa858d9f15f91e7ee922d9d4544193bc487a3075e86e5b81d6ea3373a75b9b53d3fa17b95d316d24d5050b9d75b9d288e068ae101ad097d1c89594dc0eb1e4e47198e9f889b5a6d428695a655cc559bb7acca818da2b49b2d9fcc0eb504531e4af759f42d014cf93fa7914002500e308d9debea70fd6dbdcfa4b8bfbfa34832e402123450833d827545881975bd3b3971e3280fe82ddc4c9269e51590cd81afc6813c5eabd5394e663a658df4cc73097acd178c3316980b542a6cbcd9a55f9a9fd58260fc129fd43962b06d0cae9a1c04061df3cfa4c9eeda8829ba4f86ade135d2bf2cdaa9f5301eb6090dc0224d0857ccd543a7db5667874b936e0df86d32263cebaa734afd03703cd934232dcf507803cdfac82726cf494285182d8ba58ee1bb85e4ed1166745fe978ceb4a72a2fb17de091a5f4b5a970ecef894fe81ba0933f22d4a626939c210cd43aa3480a9bde8a405bda6e40ae214d985964e42bef5cdf8e61ae2cd08032df333230b200ff35e76161def52a03283fe8d0f95f84b336900ad59b0ee785c29dfd14d0fcca680ee9845f6c0f13d130192ca827c46a7a8fd49fccbf8e24bdd6c44ce67a34fe60d37346b7b4e5914e91a384b68e08795efee8a63b5a9b563d1da43b4269e4203ecaa8fae235d3c7bea4f3af013e6bf2208070ee95d29adc958bf39731ad58984f7ebc8c8e5ad18be8cd181beaac2f24b8b2d4f8958b706412d6c794fb8ad30d304aa26cc25d5a65c15af7fae3fba020e2c4971406646f513552399a66d0a10ac8b49b6bc5342c362326ff60335405c2266a162f2ec33574a289e10ca88db27c6ec580dce87601161660281199bb2fb0977081745b6ab9387dd02643b314b5495a727d366403ec22eb68eef26bd043edecd131be88c9f3670c02cfe33e1901b7e3c14fff56169207f7ce771949b3e68bd8d7000fb0a00bb61eb2a1a3cd64e771c7c283114e5da4486a727d74f761f1f7d6ef361c3a8b54a23f39cd200eb5f8baa1ad8d499086e2787e8f4657539ffde8160864da01a950fa091bd5228aeff951704f85b8b0b38d6675387ba8229d53e5b3199ab3917fd647941df9089d08ac2f76b80c1de863069e12a7e3aa2777c6d28dbfd0e8159a0dc680d84d4d438751e8ef366f3e8cb54bf43ad2c014852b0d6c8b0af32cfdadc8bd9c28f89a41e25f8ba75e8b08592a4d4de7a57d33ece26970220c3698cf803395de7c8b546f84be2e827d2eef5d7d0f173c461e58ed3fce99a1600fcd644f8c5ea17e6878b7c7a5b5f47c2dc92d4b8b6ba930c7b94d0ac42c5ebe04a5b65240d5011814f359edbcfa19c155e1a4573b4cfd27d48f6db76df868e1013960f75643467e5b2524fefb4a9d23d5284db43bb88f3733dfd9a0b372334e4b4942003fc70bbd8599fcd35b857e7f7814522c28f9bed7db48efd05072ea7d3a71a8bb2c3cd43771f931ca0b149eb96c0b5b6ffe4646a8ed377e4527083c53f97a35bb5d12740e8c1546d1d4fc9698047795fe080cdba2fb86c5c31e50e9e45285d4eb445460872f0b76f56c4f444219d6fbaadca69dde8227b5c1fc6f52680d26f953396fa6464aa4ebac3a30a04ad85f1ee7c2bc7540a65a876ac7dcf9a2d21601f98777c6855b51464dc18287d2a3d9295d0e6fb4862d996086b54c68d1f6a5fc5fba4bc096df1d4b203a0224dbf50df9ee06e0d0d75920c5b92b78d37868371a73078e7f3bc5af05f77363438e2b5686aa1b22f826ee59a9e336e5519a6cbdff76c2db021e410b5321aebe78d2123192db8367baacf6097505ebd9093b42ca81b20bc8987de49e66a28d87248cb8aeb7cffa9d1219626eb83a61cd381cd9efd9cca8107f0c7fe06135b94ab812cb02a8897a4faab65a92134e38f01d93bc091491dc971cbfab0aeb68c1e8732e4631e2cb73268f6b3cfe609aea26bb1f03f516bfd7054e58d2713ba4f0043315567a25c78783653d6dba66c564acddb3216b398d9af5f30f91196f669dd5d7e08568f6ede27ac9948adabddec95f7ace82cc709490cdbee4a0733337436bab3f4ade73def48993550b53c609125aa4f782134cefee0693c5e5fee897e5bb90d121cd286b55b9b378ba6625971db7197e48aaf123e47b9db9a0d1268438fae998ecb25b54544acac61b03ddcd544ce11a2a989a900f62c0999d24f993d0fa912934b693a8ac99107831930d748658a581cd4c22f1471ee48019269195cf6c709f61b97d80d1825ad39bfde59738b69e68c0cf58f1153bf53af4fe289e84d2f32f135863fbdfa1a6aad14aa33b5d67e9b7eef582665c01734b20d406fe606247470b239ee734fc43c24b99d1cfaa7ffcbc1456b6eed32ed582f401f87ecf1c4a046504c23ac57bea7db128a8640fe0114c31ec9832266547aac72dc179085ae15b05260de9878ebe6ad7785765093bd93d913c9fca7eecbfe4d25b0d84d9fee4054a9a4b64d2f4c0bc2cab84d1db37aa2ddea571d29ae55392786b83ef74075283d39ef01c7bddc1dd7797ab6f27134e8fe69a666dfb126d876ed1fcf286a363bb964877521fd5a41b1d6b2ae2804d25a592c12f1b64525fa55318851393eb04a550c5d5c7d2625eaa69b2addb21e73e1fdcf744946f51875e101f0fdbf2af27746e0958acebc9c8cc034ff5a8b4e47cc70d42bb250dc400bbc33b11844957d3d3478663f27ac568eb98c5946911920fe982d3bcc2a3929a71ad283a1c08302e96f3a5aa1d997ae68d0c74e13b716c1d6e5634e3be170c960692f31d8a405d00ff5e9401cb9cc5141ca093a365206db9603872de8642ea3238567c2421dd1a6d97c555bd154e95649be69b19907b21ab0278aa1950117f2c7544c483d2f09e8b26290b1b7bbbb3875d3fb7e493687e25e431553d49cf4327734d481b9a0ab863f4a68d61c3a7463203352266ae4298bfb80de761e1e41e9bac6dda48086497716efa009364c9ad4a594818ee1847d23d4f89a3862a6ddd4587e819c39d17d0cd49e28ec3b43529c1d9dff5015c75cd00f8cf4ecfe7389c627fb7a540092c160f6c6d84def780879f6c0f9287afe10fb9bde13629a5288d7d7c657076d3dc94efdf925a574777d62bcb1179c09433cc02812ef6d0d82d910b0f231d594d7c0a29057c11e7e181b898c9fd904bfe7d18a5d045752e4ad631de519d6dd160a98dff021e59b8f7a071e9f72ec4116a67047c8ab5209ecc00900723c53d9cc2cffd26b38cff1446dc589425339f1a19cb49b0a93ca1bce28af2610a4989631bf73113cd453af45897b98588f7562a43adc49cca6457ff3d0af30b51af2feb905f66ec9b5cbe7fef25019d1114f0f207350c4cc767885473a53f0e08d9ae7df1e17de27ed07e9431fb8a8b678b327bcd118713fb21d895cca82c06f89fbe1eda83f4c71406a6bec533df564ce4568a7a27f71f44df9ef25e0f42e03ef9397249aed7f6eb3761afe6c50dc327016c3ae51efed5229ec96b6e443d3cf9d5299ba9dd82819eea81bbab531e7f0c18df351cedac8eaad4a4ae9599d4e14fb9f4319472c94b308668d4eb6790e81a3111122e43c7f47f260614c1732f5c7cd546161668487b60e157366bb3a635911777e5d41a22fce45ef69d3451aeeef77826ecf0e09894b47d939fc0fb0d79b0c1babf1a3cb6a491c1011d1432724818f0e77341129b511ae4f464d52c48c1f58be0ee7cd32f955d9ade186f65c12979f9b9572509f8fc906c3f4973cc876f59b13a86a35aa32ac4cc7acb2224a2e65f3b862180078070e5929975650efbdb64893bd878db1e62864a116832dbf7f9b7f89bcc66cfb16d4a06ae308aacb9e66b883d8678bda1a804b756f0992ad781ddb623d94640680b2612d824b625e01ba327e1322c6d25b9f6e90f7e3983009bb0669ce1f34dbd554ea5afa719318ff6103f2a9895c35b3a3ce46e6a57101325611287c0be32bd979d863892e3877d1bded0ea35c51deae1457e574bec34146621180c1bcf35b92343d002166a2def5f3b0d6caae4f4052819a2748ccf6642524af1c2b2037a403b43ce1f0a8fc2e1ea8a7978710cddd769db5d4b6e08a1bcf40d29b38649fafed36085fca584a36470c99f49029deae0fb7c1dfd75b52769e234b583799940d1bcdb403c1ae3657824e05120abfaeee6669b8ee6d74faee174c78d7406756e174d15743dcc34e34a5c75cf0261df7e6fde435c717beef110343c1be6ae88f66fe43de5e3a0f8915c764f2e610126c62e5c09e87e0e27182e595aa84cf4c649745fd7337816a70239eafcbca4a87286b20bf792c115fadee6e26f1564cae7f1ccb56a0d2d2a594044e4a7a4702d4b0424b0dde71981b9ef24d41912a7e618585041d8c398876566180812a18879cc949d5ac246231da0c071af8e644c9f172d44837e1c43681121e6baacbbea5ecb1c009f2e8aa9c164cee55ae8a4fd2cf8d833841ea0bca0e5f0e35df7ce3f8f17b3f26bab86a6b1d11fa9d8fc85b92c923632133822d9b1c3146c30a818b430d7a4ff56fdbe52e83b9efd873407210432d05ed9d6ef6991b9f854669ce1d9587d003cafdf6da320fec6ffb4ad03297122c4f65d09ba3702fe81e20567e7b5d91122c2d808b777aedc05dbe3313e631350266a64548a10d1f246c045b1972321cca51d4be399692930d8ffd2d7475862377ccd2ad1d698fcfd27c8e2fa0e8f8b9065e06a4ece491179181244f3c0a972e3215552aef2b1b9614e19d9da1d81abd1acf4b99c303b59038c6d2fc2c7421db8ad62bb3d3324f1c6262335d814bcfc580782223169d1b98cf50a12b40f06ad69ddbe94872c54f07375e62ba3c616b9b86757cb67600afab9ac7fa94b9af21c0059a91adb3705fd5143c9310b846620fb4f9a4bec6d1caa078f4a2f0e1038c85a8dc6945b4b3688bf4d2e6576ef2fb0e290778992acfb79e8110aa18ecfd775d009479c5939efd28015d01eb86f176e1b6c85f0689f8850b778b69740c69e9694f45a97d1096526411e07ec469b3e153c174488aa0f1e8493460ba762cb0e06a1d53bb09813e3bca126acdc4db790eece08118a093cafc349c06076a09a3fa3f154f55cfc11662964f2b96e86bb61e3f7a48771cd37110c8010f55c85db7272b30ed75f0c293df542c357b37657b1328624c454493719310c2a1fc36b9ef8681e16e12ff449c5f82b6bcf8a6c242486516fcbc0bc5ebee71289a64dab3c8425193a29eac32b85dcbd5867d94a6f0fe9ed42def6eb7978ec949560b4c5fda3904918ccd6d276cfd241cffb6fefd89e696e3495030c4cf54b3afbbd1c344411294cea68f23914cf35d26af3d41689fc962668cf61cf0805ca5d943261006769a0c79684637ca7b14cf3d6fbd15cfa6f01c6644c07816c2dd91cd153161c6b837ae439840d11e9491e479e6c8a1493172c9349834457d9a2118d63d9151727db09dd35c56d30534697f9d68134bd9844cd3b499fd5a93160896557287d4a993651063f5609837b12c5a6da9f2e462370211a8be546f617f75f2c52638a8b4751424acf33d0ebe078d21f2ec1c17d98c789978f22558dcc09b8cf033c7e5759e33279efceba2bdd1b18dc666146dd4ac33825cc4cb4984faddd1eb0c946d78b15a610889e03dbd6687db0074246e51c74db05898dc3f69da6691ed6f27e9d1e88aa3dcfda54495ce163e1d83c6f557d8391cf358cea9ef63afb15841ebf6892babe239a65ba3b1ef36335feecf49e356dfc08091c8e0db861da53299d2b00da3a043a1f01ba51c1438021c69b164a6b795362332860b6e155047ba9bba62e2e17bfc6838778058f7b1a6cc9d5c9af864fce67a19d5bc3552a2afd8f52c9072e5e47d79e45ba06670b7d7ef26bc3d128d685732cbb2b8f7ddb4d531b255e14a8246a0340b25ee0a71657f17d92490a4fae269bd3778b28aadc15a3555a35cba2a7290d1f59ac1775c4caeec41f824e791d1ea618a3cd1cad7a3b11a4924ee1e50073d4f3812c39df24362870c4f459eaa18ac6ad0fb32e8e8299cb70692af06d047997e05496f940c343091052593f159d1068810d739000c20f22a92d9a04ef961a7461caeeab402415a76ea87287574476f58a5fdc88bdddb24e3a435b242162820e6cc570501d266f4d43e50f697ec404d327c55637dd516f7b45dd9c3d08347d9fc1cc683586ef30979883d0b68edaed403c89427fa70c246b02dd0b726c60e220bbbf323241e851191c7521d22ed139996a670806eab506d944aeda5d8e41033c12a432cecfc7c72ae93b4b70616ec6c47c48ab6cddd79d9f02cff5bc5323ff3091ce33ce80697a780fffb7c6ceb5dc1d178f927e3dad02d96a685874bb819c95c900353c40f90c362d39468a5862d5a7251811dd7e52151bf024180c393ec554e20d05e8764b527841a93224c3cae433ba4873e56efe18d19f57dcf00a74230fea368605ba9053375527b35b7f4c0bebf9460c8f2febfceafb81d29227def50a9e3e9626c3cb5609b24969aab643464e54f01cf26fe2c237d27b130304fe519d0b6a4b98a4c2d22d2ccbea600179f3c6680cd5e025391e00121ed0e9d09b8241eb0ddc46555bf014801c58048e66e798b139e65276a733e5af2803d23600d8e0645526c112ccf501fe965c16b8f9da55648be166dd28630b88891fe73a287c40bfc6cb1a8d6b46e7570af75eb7aa51f7edfbfa3eef19a502dd207e0d0fe86efdf5cd67ce75ba5d43c89217e6d7205a2d7a4445462f0eeec0b81bffe95f57ddc54eed6549c285cd119bc747a0451d879216574e64cb62a3fb49a222ff7f9c5291d3a9d9f55ecc5736f9aaa9a2608abc9a48c3978794ed08c5f1e892d518daa546809de44bdca08031452530285f9757974048a79c312383d3d53d7e2875e0abe95729757954222f8011dda9313f1c9d1e1d1fe02ae80015805b46eff572bf1de67e9d361f9ecc927dc8a2378b72cdc913eb8543956d8dae80947b70ed117e6bab8d28d349bc43a1afa41b9dd7f09b28c8945eba2fe008b4af1643c48e925aa00f5b798d25923395556e9b1290a13794d226527236dd46bace62d4f22400fd019cad74afd94e18fd32d408c01cd429c3358de179399fdd3ed801f80ec65bce8a7f2c4c90c2d71734b5e3909a0c494c4c2d9181951afe07b3633392f7cd87060ae74b4a0cda399511d52b91d9ef2dccd4e9f4673712d443a31b5956ef3e6db76c88a35627116d773a9cf5d78fb84cb9fdb21b80950026d24716af04cd30db00c5e99141c40623987921906d4cb50d869c5e4ac1e1b40ee7a5e218e187562353c5394d4fb8cd58d5ec28be3e31f41cf8cb3480970fc6fc3d03685a7f9963f9e802d2c29bbc4400fac9f0305da284433ac594b090cdb01e0a66d95930a4e1022d28fedfebc33d8a028b6b7513091e57ceb9cc637a498b3c6f504d85d329823ac452427fff8b3a051dba4b973ad1af0e27f771d0479b1df6260346aa03bb861b274740717361771f722d8aad2c63ec1b1d0ce999a699f8ca55406bd47a372c0919f5db44629806905b69b5406b2e44139157abcd452e6a7ba78460d02ea2beb5b5c60c46cd4b27cc736335efecda2cc644cb568c151cd4e70b5c9ebb40840894f0fe46a0530bb9738e08a3665173876616ad87c0fd35e658e540d0213f1518f8c1642f380d68caa86d097661ad3bea15c52e1ff98e99ea37790cc3fd2dbb08d54248c589aa1ff34af818af90516c3686e8022fd2f70607eca5d989a42d44900f1d8fa3cd1a5e1ee82a4643247c9dcd2ac460235efee3ebc4a45e8c0c6cc90e9d75a8790031ada92abbf31971acba2ab86bccac113f5b6ac254a5162e5bf991fc69b4c4c3cd78459eb58d55fd60c9e3fb158f91292d9017400e372025da3e819b3c887fc2ad2637ca79d6e5a29de4fa72466a5756d0ea75f88bb5dc59a261029d9dd3dd5863cdf4232bec9cd6a21c2dd65fd07ab658c4ead7c697c6f0fe52c234930b21f7c4f981bd57fb01984dbef209c3deffc4bbdf978341c3288feae08f54df16942699d029904f6e6833922880098d5c7fbc394ff391791043a79669a433e3df770cdc9dcd8de5bf5dd393fe6e1e56eaabd93c57160ddf488abe75e64e7d2753e638555d8ba64e7d2f010fc02ba78fa61b4d82782493089fb8fe40e7c071a2d23b0e45dd63e3ffa4cbd860b4e1af30fa849526d4969c1b2f10a84a0cefcb7d5ac6b34121c9cb14afb78db224385c121e472ca7fcf546cf862749f7ffe5cef65e1e3c9f251ad8d2af16e88f0a5a757c116221a8238bb4ffd256c643059788615303293e9a5d9f883cb583aef73d11dd8427ba071a1c211e11226285b6502680c8fcc7a19525581539a3cff8343116d84d39ce3e9d910cf971c7fa1d0dd0fcf3488281ba362374d6ef98327b55f962fa117ef403141e5846cfcc7a60ac5657e2f2639d5e06803aa7d1bf69ac33206de84189f1544bf07ef9845535b27fb2dc91c5d4fb07b834e2702b34c1e5eebdd7fc6270535a4b66ce0f219e0c48e413c0fb108c734c0d5f73b85e2efa4c7d6acb49671dbc1bd83228d5fdb89892f9af10d6dfd9c58e030548d9d0b0b5d0ad494c5598a23d5002740af9895fa82c59cac27d16e0aedc5999efbf18933561a0d3ebed48c76e54ee3109230e2b0ec0ef0aa1333490b121d9411c8a94cf6464f7ca7bdf537d720da365a99bce8e9ae4bdb6e1df177397d9805e59574ab7c25c2010bd14b479e5cd36e017fca56a479a92e2292182f0ef3e7be18fb4e6a49f5601abb19b5a76d8466c0853b60a6d22a8acc82ac7903c43d9709c6128304dbd7c8823cec549a86a0666ec91aa8d8113e406945bb99905a2da9029e23ba1ca160de0e3c69f52acd2a8563e4d24c241d54243624589459787160cf07774ea0ab21b57162cc3eb2aebc3efaad5db484afd88324ebc0cab7e147eafc6efff7a58d41dd9b29f53e9656634c52781151782495dda7f1852c4a315edde327d76ed93421fd46838a0a7896f4c1fdba1023f9474a31e54350e3d51ae7dcb18118cf0135319562939720b9acaadfbfb8ddcaf5764154c41a4022d65cdfdc6874c81f4bc16412b4d50a239d5087a75a9a959807c60ebd2d83cbeaeba99043a8604e69c0e2da5f2f4ee4a28802689eb1a7cd10d217b74c7156aecc725d915abffc3a7ec10a1a0e0267d634a946dd023dbe17d16539d8a86c3e48b4af1b9d879846c82ad885e30e652fe9ec1716e26e3d926764f83aab353c2f6bfe0d03a20d387426c8a728032c5ea7fc9aa2b41790618b566aa64ce7d44cd5a23803de50813c8c7c4a6998fe1f8cee21e808522bc08f4f2478c10b104e847521f6fdcdf3078e4d4c932522249c17938bebb8750708ab5224b8d047cbf78cbfcd65de05d203ba8a5dcaeb24e5b4b9c65975cd9c31a05b9ec57f23c3829b5cf8b280aab8b5f840df0a4fefdc4a44a31b8176ff53b57ad97e585cac94303c10719f1fdbf7a251f0dcde4eac25344bdaa581a696743da0c3b2440caa673301350931d0ce176a25438790da048c80f87f6cf7bb0827b8ffa7a8f92f054a0f08bc4997fae84af4830e0df681639335d9ed9713f25b17c542e82c48259bfabf0461238c7d3e3b0449a9e269ea9f9eb8251f8f1773eaf9b19e79953ff998dfe56dbbba42798fe4a7a87a55091973143147e1a407f089345936ca78e01c218f5ccd0883e8a0e97a6ae9b300e52513cdb1f546fb6a41a432e53c74fd920f3e6de7ef9cae44261b01cc282fe863300f0a06b44a88b7be2ebb6ad9b3cfefe35ac060d7036f9c3fc39c181621849730d6066ae9bbcdc3e75624ab00384bbf1990fdfee277bc03d78a2e86dcf9e854c8dc16019fb91e41927fce7df0bc0101b8bcfa56886ca993946ce6bf7ca6fae17471f404a597fe27acc90da150d629b5415a7b9697721d44e0b7ff56593257dece6dc55807e1c4afd3646ab338ed674e1c5ac8034b35ffeecb4883db4d768cb9389bee8223d693c94acf244dc9a84a834fbb7815d57b5d57d679e1ce8e7a394090f9c116eebb64cefa6886d785b34f5c727ef25f6c11d2b26f451478ab07f5cecccbdfe94049d840cf8f4e79fb8bf381b7f120521de94d4300beed62e64766dec15b0f8030c474b465018495bbe39d452484e9475075c12869ab0a15666e056fad88f99cb3dc31f2d49723d9b842a1ee8eee4f88a41609dbf581167348641acbdfdaaddb9a78d350119c134a720a840eb1910d3be2bd40b4acc66d1992ba97d0fc0cec97491f0b4b569d06028bfbb42cd8b67e308c2eaa974246b573e22c3b225501e5f5a60d057843f5dc420e017280352c25ced56b938c9b114b45d2fce0a6b502469783794bcc898762e0250447e602a6f7a679f26c69f5fa942194093f4624a3a6682067a43800103d400c977bec5b365f8d7f44dd4fc457c635e7616d3c522d1d7591767273e1bed5b6f1ee71b508c8108bd4bc4758adf63cd21fdf0019a16c36363c4074520ad8cedcf4d47e453b3865ef8623c6f3ce51e066d42c4b9625c02b44fdcc5b4ef6623cbd6c76f21067dc5aec2660b661525ce40f04ab79688c03696c7dd7462fe5eb3029879b183001b5517df96621c9f68d3d0baebdabdfc12f2944c34f19e80793f929d958137c8ddc0e7330dad1f367c7ce965357db7a2998a8caac97545e61f669ace055befad1d5b1f2b4343450a348483799753d74b09c987536eedefae247e83ef32b9d772af3ce6276b844df4feebaa19426287bd4b400dd640b70e41d76001ce01733053f7990ec6fe4bad65c8b1faafdf4860d7243d7d0b5e53f2e900c3023d4e338267bac4401e7b365185c9825641e55011a03b7cfb7de1505d3fca77bdbf262a48ede154c56b1bf9e15a4bd2fe0dc31aaa44aa0e660e9baff2573ab104d04ca7ba288281b20f4cd79b32c488c0d69e5cae4b61b4e6b16b484534acb02f8fff424f7ce4377bc145fedf6b0991245a4f16d2625b52b88ba8bdc148f893c2143af47f90e6757e3079c4e69f134c634d6f2feb09d4f00216931a4192b2c3b0d7b80c12741a6c70ac65155f892558cba73a36117339166a1fb701fe12ef3836478f6c1d983b98f60479e56cdb3084a2114f7815519098461d85f8a5f1362cefb0ace1d24d5e7463cf591fc52c9201e28fa341d817f752acf803a3d48ae57ebe3b519a3cf11d0a4c2d35e0190b4a66fbc7c841f84f263680736718f5cc4ec93ac1776106fd10215257dede89c7774d5187878c9f1e92634af26ec2571ad49273e9cd089964acf98184ced7d5b323884dd4213fb518dcdac719b84b20cd48d51d382fb58e936ce811bb94532a9d99afacbd177b34451bc429abd4315a96abb4e8031e7acd5ac1cf41d4f4803017a99cd3dc1a2bacde45f50c6491f09a3000f739c352f67155dd4a81976b7320b11351da0a2cf72b7cb798c33c94f186485b5119f80c3244d34be18bf154e8e7c634461ef845a4e6df8c756e35c5548de022156c04e2832368aa827a98f29312f42b1f844ee8f1270ff5ce68ad15e865af78b8096530463142750c62fc96c92c284671ea695c61748e0f3983e779dd15359a7817f0f89a8ba235f0201b89a75d50c098df07750b077fdd9d382044a904469aa56d2e418b31df1c9e3f316476c1ef8e35b7db305e1e6f21303da68cb440d8e741b5909e70109b23fe7c01f432ba3d911a1ba1f3667399a7c10100381148624eda0cf63b282338c56bfa0345ab5f7bfedacd63f6ee2bdadf5cefb5bd59633376a1edc55a2129c9b0b8d982ad282fd01afbe74f1a2caf8649454fd415e60ae9c84cb69d7564a4162e6944d5b4cb250ec7db267910829657c882078f22b210dc88acb0e0c24ab12d03059389f043abfcd4054e0455cee9eda3370780b7ad45bd95028cbd4bdb6432291022c22616e7230457b0c0c42ecfe4a83dc11804edc367dfc61c81328b4e9c4df3bd5fbbd71a791e2ea769895f596c27fb33738c5b325d41a9e70b82","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
