<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4a6f70847f0ae70049efdcd4a2e71a5e39c15bf8e9a91db9ec9e969e4c055b3d9abe20bd4ea31b9aa2cad7621197da0ca3c2f53d54ee7a48a56aeef2c9adfb5c47e8d14042918cbe6d760424933f11bbd8c76eb8796d90eae1c6efab49bc2dc218cede4a46bb826be4c51225939d11ed81dc99e398fd297dd225c9ca585a19eacc15673a795c6f819412f64480714161d02860105febe5a8696fefb81c4ee0ba8f2f9fa96776a2208274b34c2e25c0b574066df2ac7157293d4c62d7280f690f010ddc6e664ad82a07a987ef5a4c19d1587a59db9f6ddc666019419b98114fc9f7b0540bd9ee5a5ec292582e35b05425c5b59469203f8b54429e76625182cc330b0aa0bda34b45fb21de0a1c6489a0253072156e389f48225b3d2377edbc81018915e9de2dff4ebb822ec579270e5d55dbf86ec449f716ad1387346c09fbbaf0f11e833a11703a422797927212572c7ad3d9c9d4bc9e89f23924a6c119cbbec40f332ee7b2d0dc1866e0e3b2c790508e3ee39c1ec4578431c25b2c2bf680c04eb8216e4587c8ee31787697cba1aecb5782ce298ae6dfde01d2244096ed9b793fc7eaefa6d246ee5f68dc0ed56cc7603b65a06c73c35c031dec753219396357fc24d4648763f63ce0e60ff7d8abbf32f695fae950a0852b5116c9854cdc90445a9e577379f678e570c0e8aeb421342ba7320cd0d48d8dd175934c5933df8290e256f32b77ba602ac8bd003cdd3fd0eec3dbdc8ee5fb9164341dd6a39fc5a9289625cbadc266bd58cc6d72e0b2f182d8203b53b5d8e0502a50590f3292af1bd032c8180305ae0f690cd4d82ccc73f92685c6807b5ba47b450c77278fc51159d7fb03884a54633e3aab5e983e146a46c7159218f75005d34de18ae2530daaa92c21188104d95d18d1382073467ffdec723eae7ae1f72c82c31e899eeb0304682dc93ba14618a722d566828045de3185eaddc316703b0564b7d85c9c0376b5c04c799b6a57a33046834d2d3c77486aca5e908ae7c3cfccd47b87d41b88f97563593e8c9805f169c5d187c413999670408b4c4fffad603bc192bdf8eb519d2f8aa9482ec488dd941d7b8dcee465a92069bc91a4a7d4e24635214ac8d59a6395920beeb58e09c80d110a2524c6788c8e8841f7ab8a285a2a32de61bfeec8869722a2467e09afe4439e08be4a300f78ee86bbe43c0e687675bb7b154fbe51fe1c3eee3f4478091754ebac820773ca8f8e4c559219fbec2a98caaf919958b6a932db27437af5391556d6e87764d0ae303d996ffe19eb0f82788041938554b7cd921ace7ce0b0da9c758ad8ec42a15b55b920a0eed5de97ae8593d2da45b9aa827f8df2ff35c22fb0cfd81ca1fc011c8095f5507d37c1a94ef6d4f5de736310795edf28d0ced76a41c10b432a7b18e110818fe370d53a49e05ec249eb99086fcd8734f9fbac96321a1d6c8ca36966b4d26598fb48234023f20054ff867354ceaf63b63a850973fab660d304c60dd9ce966e1525d43f53fff6c7e211352a88690c6fef7c77a057acd74ec2af14865b1f1da152914288133d880c0350bf658190745b69b1e1b34d0b57ae66daf3e08a98a792b912affaed88f7ef1bbafa561186713c47d73ef2191542add228a6ae05b8dfdc42e6616c2bf03c67eecb3a44771869893fd3dcb97583be8d201cc4e4f544327e1eb792a7585a7009163518a27189731891aa8fa8433fb22d46f320f53bcfb8fadf0298130ddd9211a20d9fd52c2bf2467a0dd8b31bfcef830c619d3d600a0d5b10b51d9a9e018b9eca9eb2c6bb4bd4586e83139105eca421921a21fb40778b852916e14326b920aff421a55d5dddb0e1d8856f83a615187d02fda0ce8986f92fb248afd7a6bccfae27948ccedaa2aeca02d4914c986ee46ceaaa8d606b0c15b04664a27ce8d0a6d25bda6af2142def8424057c8342dc143a240a1e647ed0e285a4526b669916921df6664167520fa3fea618e743502c5a6e4598ad1ff73039b4a42a10a885cf715abc7722085d7ba7c331c53bb10871a322a4ad8efdcf9596df5ff1b401ea689e6342fc2bacb7aceaec518bdce6f82045bb25f4aa42a27bede1a8c3d71ff2801f4b4d7c71cfb71f7c50cd47bf3e5a7b916e7f57124230b2ebda9c108e79e38759f9bce578185af399d1ef0176a7182305dffdef76de4f63e7c304afd525b16da76b61a9364b2dca9ed5daa17213b452973b33c3d9b47cfa70c7f37c9749783695e44db5dd6b8121cc72f09ac34b05f56d9edc59b813b68e23f4d305d08502a3fabaf8eadd3fd845842627390a5fe0fcf9501d16d17b69d1c371caa32a5d43c08430ea1a5d757349f7d3ad30db0c3a75def0ee1ae6bc5776a5f604d1fe25cb49e7d7e4b7d3d823fe75f0ea22a3d32c3bf59882a635ef56d9e722fd37a0425586584b1131e0964b0219a2d494ea6d0d806094bca1b2f740ba4ed1473f425023968d6a1e1e10a501cddbc9a81cf5b35228f0a30913947870d7bd3c9f6d951c4a3410e201a3963233bf911d20fbba9a9cae236efc1f9b5f427b9a64f1a2499f81fb75304c21f51ce9c4d00eeceec120da01a6f5f01056e915f0703854a90d2865c105a03b01ec875665e4e3f5db4bae3d6d353b92f0ad432eb172fff5b0c2c3f80a95baa282c264d15c4fcd21bc8d8e236a90f07ca901549eadf64cbc9d2927346d22920fd925deb79da7c3dafe581cf0766c7d874aa27a1a10552d7f3bd5fa20e1c38858193a32f20c9967b1325ffc5769253dc98dfddd00355f9df80244f8720b9bd1e24c2689dad8001cf5148881c7e914a3f0a17ee02b86e6a01ade51b995cf991f9c4c1c6b17b1c5e7aaf61c1ba29f8ec55b3d99727edcbd064bb6da65befb473be6f8c58c856b86bd14b3d153ed83063f1f9a1efcd655020aaac49cdf913ebf63f82a7a463977938483942c39eeb25c491b4b0fe912368a9b79e3a81684b9d0a5f4394226ed015d16ca14506716889fb259ea605c3e7f148638ac9b78e05c7c934a603f8b88666ca3f2b790ae8b2a265e11a25095d5be3c50d9a548fa5bcff2717a5c02e1a4ff0711c1baf6677c952b47fdbc450a10e29b749bef7fedfbcc8a13a1fec78e22e0299464a779e15ca94e1041b8a7224cae3189fdf4034643fbfe88e3ff3574c1d371c1eeda62767d77881960ea09a009ddfbee2efa3b57632260150c8fbd4aa0fd973b54863c17071b04112646d60594034f1eddbbc189429d3c15f25cf0f7d2fdbe9cbd589eaa924222c20d6ee0921bce88a816502a41d9b95b4f81ce3d85d954e9c47ce1d091f97c2dbd0012b68e283791c21de217ab0e0450aa0b0f69266d6588d2d3bedabd5153dc7f20d6e9201c8fe654fd7d7d434497faf4d4ad5b6cdc7d2f19fb2495d918858e74425e883ebe903e35bcc3c0a9cb821d04183b0c27c61c30598cd307cb8eb147ac91ce9620273f76ae9e7f60dfea49fa13f9e65114336eb70336f9b71e141c7a4dead2ac448a4fc942a88e8c03aeab474640f5f8b208c10c899910a6ea06e2fb0e608e9de492ab19ed340b6fa1852de6e28355f86cda9f2cff172b19a7cc0b42b277192de8e1610b383437b998699385816a71eb8995c2edf5d0232e2a1ab88cf605137a4ba0c2f1867302b4aade8dd9d58ade77326b86ba5e1f07dd1c73df857e649c04666673186a5bfb96be5f597732bffe350ca0603ec4f347ca88ef0bb2111d1f3e976ba3939c26a9f9dbf1a67d206b4bb612065a24adf2eccea5a988902679b34c5d1e4aec4197bfb609c671afe5b035d066c8c8acda00b9438ee812b01022e605a7198a106623f7adacdd74af39ab57641138729122306b27f384e19adbd340400ae93ba49b91922b01d0378226cad61e7613d895d88117a5240062a5ba60f9084de200df496ec5dcb4c22b522b6d1287955bf0fa31d74812cf7869a836f3bb5522c8248e28d5df18588d4a4df420bdb5a9e7a5167dc4aa603d1022c1f10bb91ad10f5cd0dea4b3408330743e91fd173b791e6b8bddc4f688a7405052e3d3d45f8d388b1b8c1f06ae7967aba7ac7df7ddbded24fbee6a20c72d2369740db8db185c56ee1942a9c3ff918c14785fdd1d105cca0310da6044dd7ec7f58d928c5c532b0ff1181628372dd1e9d1ff30815e239cd23c1578cb186b7a799b4058ca73a1a85c18c31fc69695c544f7fe0b5bbfc84c195b9cf8b09e1ab7b53305fa653ce4cd239d463f7ed00b98a69e1d370f94b1d57c1f211236f859430ca8c2ec4178bb2d67295677a19d3aeb21c1bd096145c4cbbe5abfa790060278fa19338ab8b186827ade93d68404ba75b9c8f375d42d24032bee7242a9d25ad32166609dc6a7b5f9318a78e22c5414bc80ad18c04d72ace573499f5856677d5334474382805f2be394a6f052355f410f1d822d46554207024a3a44bafaf340e50f2cfb0e54fc15db446be64f7eab1d07ad86b08ca98695f5fe0dd5e48f0c23ee8241d4a642884d9823968c3fc1b06f433c47e135264fb8d3899878085c663687b31baf0a8110aac87b226b1196133e65061cb01690d9af14e7e91df61a1ece0a63bc59cb625b7aa872678679d5ceaab4416f55921040eca1f2f66d0b6f84f0474f055535e01272bf685e517beb6063d2a6d6ee82bc327cb1696544a8a43309f30ea97d79df04f7d3cb0e4b6e019dd403943da9eb3274fee8aa49829fad9ca59369cf582106fb379348321fa30544c5f997194ad5f0f8b27ca623845a0d41caa74aaf6343fd61a3c649cddcbc97930cdb87db609d787865b1fa57b8854ab6351110a669051e5bd421ba7ada0e42498f0141e5627703f95cdcfd0dc031bdf78f52c5b1676fdff51ddf7be74c9cae54eea9543d8a00e049957728b99409e51626b5597cc9850eb23687fc0c7b4bd404c502801b47586a6c15128a5f245beb54667e13310c29859fd4922a8be1c8d9481c096b82aa4547f52affce8278f20f1f8592088d076ad19b7fbe61a7d3351ba4f8e69b184214c2e700b8da410eb7371482fd9f6732c00e75091eeff12d6ab4bd77443cbf46c2be53e5aa4d6ce46e678cb605c701025ef9c95b23934de666ef32d7f8660c145a824258a703eb3d1392ca394b5563b88e5ddd69205f1a97a15b7c39fe4edffdbfeba9432a8cb2f1840af597bf109f8551003b2821b0f38c775f7f17b25b88d3785ea55e7fc7404454ba382a68e06e276f2c5b184a74286d577343764083e6b0faca1477d928fca4b47c364963560908103267bc97a6f2abb3558e8ef9404000b99f79a2d6b4ab7a3a4a73e25c6158a4b47bd9f749bf0fbaa427bca69d9b33ad15f22bde6453d2badb577f63be36f34ac6bb81036380e1e1106f433bfb37f078af7b7a0bdb6d2ba0e931f9d0dabfa4f646a345f546dffabfcfecd7b5ba9f30e66358ee0c5a58486e124304a616b29ead462ed9aedfcb7467592cff84ebfe54749d55045e6fb61f24c6064c6fac1ce9e6a8ef85aa1999035e7b2b937a30f21691e2e9a193ffeaa8d0320ff0b37cf6af9db780e0e5facf7dd8ddff34c9a4b0b47596c35d94de4da8fc0866b0b5a5a3716cd17b1e0399eda767b9e9aa44b4497424d4274775300e3bf8b00212d5f81d26b1803a999ab1ee82b432163020026e71b53b2388fe745cc177dbdb61df15e37b30232f024af80829d02ccc5302cb208aabd58a60551fb1c4fba33567091e8bb8b0b4887fc600e48cebbb4e7f67d2f9a3b63d84259ab2e635dd83c270db20e4664bc774d67be9a7d6500e4c5b3a6a2fef5724f2ce481728bdc5edd8aad8ecfeb6849071df1fefca61eeb979b27dd0d840f3ad9d24e1334e34464e23515bf43447dc4eed2f1a0b053e5611412aa3d1127df13f28b1656606b0d78a725f7b07d32a741c95a3cb1cb2533a4538df614972cdabe1814bf8d9fb343d2571419e47a90d76c493cdea57b55fd36230cb2803c69bea9192e04396ba3f8743bce5abbe2de0845b6aa449a0bcc9840c30d752dc5a275951fa191833624d720d3ddc74fb8095d0171092ca14a6d4d3f7edf304283a6c7859a314af4c89081dd4297319be2905234859dfbaf63966c520ade5ce10099d9657db1c0b222e9175b2111a72f16c56c3f2388b12b1861a33266adb285fc73629cef8e552e8ac97989fadf0511a82361f807cc8a091d39b8434b2f62e501dc1c8de87c3159d0d3d94f8242e749a672df2eb0daf91e3e0569eef860c373dad9f4cbd06e35c16115c6abd4953cc6b612a686baa2641b2e17c809a716df5849a910bb51ea199ed5147ac703bb2f679f60872926bd8ac94b488a6c28c3f6f58b5021092b4d052b29c20f1ac6856748f80531d71b44bf3c52a729771bfc759c3efe6c6605c0927bf741b4cec64215ecf63204fc5ee617c34db1c8bd9207053a1eab24dc53ab158c59b9ed74965ea612a399673449a8425b65dfff48f836dd7958b1d126c603f2ed90f845ecb606a436196bb3b07ac83c4702185905ba9690dce699fa3221fe03ea94a8abf2c830caae1bd8a2f29d011a8260bf7743b182020df987a1b5024927999fc4fb0777544b92f2f09c3c5ad24952b03fb3b222a274e325c1385f73446d3d9b9aaed5075af0995562c18973e3ecf9114bd36f3185ed0072d56259b10fa9c0da4211c6523c779ca986150205a5406a47872842a94167b922616bd598d7a405e51bba879dedd82acc7249397ebccb92572086f6e37a0a8a053a18efbe114f0d1b538d50be25476f395b75869a19aefbdd411119864960eb90925e328e6f23a272771f9eacbfc2675285930251608b6e3b58add4ccbbd0599038cd4e0642dc65735515741115894aa4fbfc139125babaad7b20f85da0846e251ab0ab515b19f894ebf408c1a9082262fafbbb1df6d8c1da0cc4a0cb1c6e32d0ebd27f660a42d6778c158ff6f83aaf30078a942dfc7df6dcb206fe030ea7ccf822382222b078b1e5a2ca48baa23b81c7b66fe988312ea244f91b034eecde3453410b485416c80d9687759186a20241b519387db5a9d4654f5c1c37b33d06c6935d201fd147b9f12286e276593a53527f14202ed8f0a9bc5f921ac5b2054ac6111f365209f3c08f94af4723890ba07e51752aa3aab1ebe8c6f5f8621f2de224718c77d1baf7013d0d913dffc3f5af0e15a9716d4b8588a18e0a0e3eff6f0bf4d793ce1b4fd2e61652eca0833f3c6ddb5f1655527e1b15942737086f705e3f123f73428323d1f4784feb6bf255c64e0bcafaf00593798585513722d19f6bfad7ab814af8304de15d73e82865fe8308917e1143f53b40ce1df190f4454c7477b6e27b00ef571e50cb7febc93c0d4efa0706b4af5a7bc0f9c380ad15990c083d6f0ea1583f401a077ca4f3e71addba2d405f3561e2735ed2892ffac853fe30d9bb59eda46a90a5906a988f56bda73756573865b8c9ef34ece9d26f8bcc35cbae5c2295d1a51c8a29c14f3aa9031eed5e913d37b22c71b47406fd16b376eb4db9ff64fc13a9a1aff650af7282949611102b5b58ab91bcfdf84cf09f2d4aef5a9b815ab4eb7fa5c6188fe304a57c3e68f370cbaf5f7341bd739c2c1034f2bb13bbdb57dfe1e18f4b292ef34bb6f2b22f1cc92085f14fe922fd530519b74dfdf00515d69a1abdc521cf589657ad77c81c6bc14863be7d74687a2c083835ab3e1e14f3a30eb6094c58a1aa2657884e27a29fd84af3b7bf2ef72593112a35f8c82a91e6d704f84a62038d8b85dae6f3327c98c8dca542c0cd2925afec7c8eef60a6c6a4dd395dff17b6f7548098a37051e3eb7cbd0d26963ab8ba1feee61de625148419dc8940d9a18f3f47724a8a556101d03aa27900e6ec58f4e4c125a9a6da087c948fb2086f6675d2121ee4281de18cb97d3bf7320e793fcf3e188ae0e65ab19f16087c5d1a50a6460c850c10f0f8748d4859029a49a5ce1768aa4e8d10767b548bff852624a220f2e2feda052df01730cd2aa3a27414617612d9fa2ab63b12953a95fea168881b4bc44d90665c66ee7c937677031d9f20b1357bb4ec89568436f52db39abcf12677e1bd71dfbee1563f5f8d1de71775613741590c0c555a3d610f20c201ae60fd9430d4412700858315512d8d730a9e5a7afda62ad8f12e608134aaa5c805f6e7fe1fa2c54785909025cc61efee05a9096c63c3e28bd321cf8d744fd193a5f1adae3191bcf0d4ca0469408c32ce7131c40245384d864c3cf2cda31fd7aa12d32495f9f999f472898383636593ad34e4b0322f1f832ef1ce0d90365e179e93963d6f0b0938b3d1b2bf2a7624d997ef2560ad9a3b2c5344d58444d34a01086709051edd9862bb56e59a97b7d58a50db01983f9381d6ab43f970b3fb29ef60e4edd41081313f92ddb4404d1bbe5de62015ad2cdff7500dce75f6b1dba1bb7f5883b35c0652dce969fbaf8e408a575f7c20c3582ec1928b604e2146068438dc2a5d94359892f75a294a2331c70892eb5210a5da17385e8f5e6b0d884f176d8ba7646d4fee5d454a463699523501bb28557ad4b045d0b48cd78910e40c1f0709e70fb4e4acc9f883e83805321ee3b0596923774fa5783654c4dbda424a04f931747b5990e3113adc368662e740ed28b08a6783b220891fafc25048ad6943bf9a056ee4b74536aa71002a7fb94ff9a15d1748644e772a2094a5d8db3487e35ca56ea0e63291285442bd91890f68ce57b6b218a62f44148a8011c08e9ba4eaa74e989029abd8cc87aebc809ea6d9f3d8cfe680903826958abd71af580a8e905527e5741b7c662e2e31c93deb4aacda799275707a544e07e5abd3cdbb8d91a9ff3c5618d876f6584436fa58a74dbde9b8c671815cf39e7c2f53e418217ddcae2200422aaf35e47055c5179a1f358f7897c2db449985b4177580f8cde52ff9f000139530599369a7d1895cd74c8cbc530e1cfae33d064cc9ad10529237885228ed358d2a20eb91146c7e09a066902cddc634ddfca7bb19b808ef19ae31deac9e5ae25ddaf0a4e947dcc6d46e7b248c081d6afd075f3829a687e345734b8e58beacdab488615a6e151a633508519ca07ca9bfa45b0f2a8c50c3d4a6b70d02f56efecbc43133b97bd8b97c8db6f87c684520d44b113468e0f3bce34278c12adfa2a093cb40431bd08734e22be79f0025c494dff7e3097881aff4dab526b95fa811779acb4fb1168b2f09c581c9d7126292e8278f83dc8876299e6183287789de10427633d4c7f7a28401deb95da07787523da749cb2342f7cff9abb9d08f1b1d19e172c86d75291517fd87204483402837f97f7b459adaba54f47f79ef791e2d989e4ec4a851707d849a12299f4821cac14e1ddb7a7c58e134ca4af9e74306ce84139604a967169438a949f947ec4ac066254d2b6d5dcfd73caa5e9bec440dbe4c09335fc45736e1cfed01222587770c0c9564af19685d702671e0db6440939780e7cfd89457ef97d10a33400cd40705e7547aed408c5b640a7d180d5dc9098e55c351897437aef67497c3288e3ae01e7925b7598124809a14171cd4aafcae7df368f488abe33136d00f535f25d51d9f5619c1d59eedd831ef966a5feaddf2a9901d78f20773d8f28e078602aa928e65fb6d44907d413d6e941a73ce6b8a57e84ba710bdd9b97b9149befa791bb9747bd6ebcb19ba99f91e04fdd93e2b8d3a6f2d184cd12af66cfd364c5ca0ef6887aafa1523c463499431dcd4a9e044d6cf7d682337453b5ccfc1c83e1e207e732c73fc535a05ca49195bffbf444879d4479045f5669c727e4e5afd3bbcd0e067939f410b00282aa8888410155f265633f38a037256614d29590b33afdd7bcdd171ca3d98cf8bf98f4d5b0db4666ae4a6425ecbbbe61bc5936989197efe31ac7613c7565d80d97f645fba06b5f2e27e2c481d02b064b65f92d861a54f5dfc856d23577841d025cca0861f5396e5f0397f63b6a62b5466fdac388ee3be592c7acd44c76b664bf979f84847924ffd0ccd6cf16e0ef0723a0024a2a90b13237bf0d992c41a3598a6511ff34ac76f633bd05b43f5742e49d7d5ede45c96f64bef9897d10ebbd764c77e534d02f3815857f66a60fea4181d380e9b17d00c34a9d0b4b5a129ae5c89dafd6cb63b275d635f2fcfbaec11e73c025d9ffdcca817815eb39de98bb319413dd401d6b130b4e6f5ee57d83bf30fe4704a4850ab904e25a909c83a2174f50f7be06b2a84ef6ab87ae865e9f651bdc464bb36338abfc332a3007159d691c5b973974eec80455a768e29034d40e2a214ba5c6e5d01be752ac11b89d658fe4e84d16f34879dba689005fba03e79406eaac046b540eed8bd51bb1cd57f17a9778af495b501bde4b49c75a5abe3e2eb59e88b61c9891630754266788b020746bcdd04a2c8175f876d0b089a8c9981894d0f9fccdfaf49d0df780e9fd3d2716dbc5727d4847582cad6ab2f533b8d7f67c87b1554d419941cbfbe7cc36f77a236ce8e07e5b5088fea68db9312dd96a7b1f6948fc1e7f65cab36d510ed37b567fe76eb4edaa16346d7c2f4d607553dfeaa5cfb6fa5f2e541860e33d1a991829a44b7298c68cb63bbbaa3292ff0b247e197b8c331f00b0e08fbe8ff2a176243652a7108c2c36d859f3f05431ae5301d3e49442cb4798f1efde212c526480726b22560178e2fe4698f18b22af66970bcc67af5ce8be94593d4bb39c15f5d58465666ad9ab3d591777eb931e31dae096e7709590ea2381744bd48e2e20cb49a899c7a562b41c7a5df000d195ace52728bf2e291ebd3de8cf3df839f9e6c2785f28b2c7ac6c99aa66f5269b1ab4e23640afcbf6642bc798cd7b015c2ba6de968fcd02f9e2f0b91a23b20b9bafbf3ad71bf116dd859137ea1bf4560f85091b8a10e00145d5da061124f663b6f47f62f1bf863e4be71122e37c51fa57be019a74c237a466c529814feefd392426fa03fe383b5cb1b51618bf66aea10e7663f1088a2ab821d5883a44f1fae5d5832a9f8c410de75997c0cc98345984a2e8cb1088c5db8afc451df6a23e9244a5b19da3d6dcf907b8877b37ccb5515437697c50d85a09d9445ef2d0e89b0cc6f927ca1771e6aeafc485620c39d7b160a381e400503e49b22c2709edb6b7b73f73a27904b00609e4cb614b70277f252e6fffb714f339ab3eb36af3e322bf839e70d7212edc5d93d9acde5284ac5b01c8144d4a74279a6f406082f056614dddc68ae52b50786c2bb908874f2d543d54a158d969c74a6c02f686e33621addee10304c62608e80be0c11091326312d2c583bcb7bb40c053b3d592b35d7668f6fa3647c25ea17ba5da14ef02f7e86bd80f787fb723f235d89bb4c06261d02c74f93d9ab552aa709f85b371e39300520efb131de59955c8015af9495337f4d1b15eb372130c9c0ff62b55c58fce45c2940651e94d81d41af94ff8d821fcc26a61aff8c556b98760dc8ca1ae5b6e9540402f91c6b51386ab3a795fac836d5c5a2590ef4462276d886225a2055bf9f496a9ddc41fe2cad290bab37f76f42facf8bba328a5bdad629cd5831dc42705df860fea6a8b806e06c2157ef5992748a4c591b05faf6e882d5c68e3ed6d3f49da57c3ca47b1d49ef90c5d98c36ec000ab5339c9fadbc6525c2002038e62fa93eed7b7bc7218099b4d8c2061239b3d5f1f32f712bdbd7c709d928f76bbbc5af6dda2e65f549734d68a651de4ab6becd01ae0b5dd3353c94fa467d00884ed6ad6e88a619f28068e873827c52245d0d42b351e2861a5f98d61ba37ff705db48e203cb6bfd33a4f65880f630d48539d4997bd07e459451436c9efc6d7af9296d810054cbdebbbce45ac124f27191d5e1ce8081a0c6247d433ef4b3479f422f89e98c0a6bf014562c9f5151fe13c779ba5f9dc6f21d574c1bbc66b90bf0f9d9e41d4b81ff154cbdea65ef0658e3cf2b0b305a630e77187b5f47157e099b4ee17df0def3ccad02cc5150a506fa2c00e0dacf25c27d0cf4ef6f8c79d900b8636776c7ce1265e5f223724c71838798f93661076b97596c4c0584a0f8a2daf9dd93ba6623fbb2f4f20b7594d8175eeeb321718cc95f06e1635d0adc1354c76954ccbff1013d8f081ba187fef965103faa21f15c6b376fe3383d86815546d1dc2afd376744601fcf7295489019240594ff4b4920997fbc0c5f4f17e9780b2383f499e8c5f8e756ca4166660117f6b9215692e932765c2d6320b587e386338433677df386cb2ce1493b2d1af50d07acf38646c029b0b428993bfd9eb675f1be2a2a0191669f851cc631535a21fe737d2fcc163b1d330f5da25177f8b37f89ad97395bf3dee2dd72615f5f961962f7b86f1175b9fbf3650a1376db9b5bea5163d23ea8c6a421151e321dd4353cc7ca64696d072b7206326d86e2647d8f932ee24a4105d55840c2162c3936f1b03b0b515149de5dc217c77600b6b14b844a46b8fedd817dd15c40665f5e739e33cb20d3ddb3cbf4b5c2bcae03e948d426e1647fe171736cbc22f6770e40d145cedfbf2583d24185019af6aa8d80a24f1841fada821e4aebfe31933387d1c83e172b4777f1690e6dce652d250d0dc28910982652ac49ea74aec2764ffd3cf7488de078b2446794d1ff9841e84f92b2f6872850c9099268dca858535be3d0cafe84c888ef62059fcd8ab90035ac535f47e07d3f7fd9be329e7a1c61a3192595b6495e59fe9337d30cf5e678acd36db280f8b60afa6ac50c18bb75d305c59a487746124e75a869c3205d7cade2771de8d33f274df4d060114080dcc1237e824adde8eda7af5f0abc16b9be1cd3793ec84698f83e362598c84887fecd168b0995e0407b99926c736dd35fe628fa9bc08c71fb10a152d045e43bce062a2e834999293cfab04da893a7937fc932596cecd8483381f59848e5be9045f211521242e648bef24894eb4b87cb3233b0bb7c7e6009710f38ce49cac8943c6f9fc8151c4be3a65cd3c473560da25d52556ef53136e7cc85580df31c33a120ec49d3dce976d48aa2edd55e321800bf62a6819ea9256f62b70c07e617956916e9e02fc615b7186a165beaad49ae080efd4bff1945b26273909fc8d9e1340b12727ba9c9b6aa37854a3d914c030ddabf538cca71a2476602fbef33f3e65e3276903d0cf481f0d1f3ade4f678244521171553aafd22031bcf26f317e425081c7e9a77ff0c10b43fcc9040a2a0eb65add222e7434481e1520fac6136f6edd9468dee9b60e217de400ed9e55e6f9ffc1207b5bb57277f32190c537aad7e8b5496a2f611892ffa511a4e850f5ade85149214894c2b55668344f3d95e67a7cdff1c71596f2546b39fa381c071d81ca7a9a273be76156043a57285ee56e1742c60bf857835fd24ab330f2f2e41d2f3907eed540641d6da19a48cd02ae469bfc2f20b8b3b818400e09aba475e717970ff296d194d68dc9d89b596ecfdbcfcadddbcaf6a22c9c693c0b3b63126d331de15b7a2efd16be75bbacd7f3bde4d0b25b67865de1f12fad0f040f161981939d7880ba972b35604cd5568ad3564dfb5b79c8f7bccd36acf02c5e54443fb97fe59a3b2afff4147762b0fdb87d6d5ee8000aa73595f48281dcabb1c3afb3597e476c8876f852720394b19a3777ca8c15fafb2441408c6a9f2049f4ae04cef8fc9feed4e77fbf663bc5e14a8940e3058cbabd56e362b42ba773bb66219fc3272d40bbd3373a7144f2a861f5de0cc4d345967b6c90298ae36d756d4a8f0cee2dba34f4e2c97256789dec13c5a7f57f9c7b5e5364d026c33aabc3f28cbc3e0cd4a285cf8d43c3ab9e78b6bded40d214d707bcd9a7f480ae747711714578957947c045cb753fed0c8ccbe170fd03d235ba49f128aa2391aaf7c573342b1421a58227ecf17785274ff5560538ae3243dedf50764f30e4b6f4278f1c5d5ac765440b3d9dc47e6114eaee5125db70754cfd6f0061eda8410c860aff02c0a4daaa226b488041ee63e4e0e70dd01aff035e34b087d4503999265a5207b5db86d9689bcbc3ac4c886e2fcc01be005413f21ef3924c5a61e967b13b3b7c14538e9023aae3c83211716253188f80a92ca0ea85331f8ed6dabc9fdb9a2c169fa2b31c51f037d09a4367e0fee49e6396a52dd094c36035778aeb526904945e7e548a67e72443da1e0c3fa3af0e3ba6801b5ff032dfc25affcf830b2b8e133775efcc8d4b7e0fc6611cd7be03711209d6e98c3f73dc7a07c81dd751a808eb4d6cdd9f80f499b2da7b96b334980562ee7cb16639a1ece783b5f8081e19624e17cd8aae140dfc659a194115077b1e6f889f6a4ab263bfc774fe1bef12ad7da243a619e6ecb98903302296766635f9f7666fe532723167f60026324837b56064400dc0ec8882d9a5047d73c01c70ad8a8af8274e41f6f038011dd1b01fb09c9cd40593907e8a0188b9b52c472487e80e734871fc11afad0ed287a5463120cd16f33d01aa1f875157ef7c73","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
