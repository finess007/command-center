<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"69bd899140e7dca39abfd3a3a369d00af4cabf88a652b0fc56206c773aa997a23c1e98b2166482ba1b32ab9d27c7e639a160ee59e53c6e3e61902861c0603eadae404f9a9eea04888b8530060d806f5f80fa0f818887644d672b095fff282815f0db1f378be76359604b7d9e8010d6faf3cf74f27a8970811ba140a95b7b34001406942ace80982590e326fe66ccd2ba82e033902958f49bf76f1239a3c6aca67c1d1eda60c5ac31ba3429d437bff48f952a5a5223474e2b58832b3078c547f746fa15d531ed6b208a33c54c8b4734402571dc47a5fcfa7217e466e6786df8530276c84ae9fa11858beb935ed1c51b318b2a32ea91a4ba660a1d645b8457b3f312f65637b28a35270086452af8a1e462d880811a4bae41a569e4eb6b2e04eb71bf8c46be21b6d392af3b5e684d81bd83a69be167cee3d07ef5257da4fe95f9c7707afe5d69962e3b9c934f3cfdf3b50429548e95f8d1bd5e16accefcc27a701c3a4768b6f96c726d68af2056ff6d587cdfaaa60475976209cf251c642bcc9aa5304a5a2941cc401b2c79b1c4f048f69215362e8ce458a638e36c4ceafae42143c2d42ea5fece01939fca51173d7620d8c4298970c17a15eb543556502d4d1cd19e46c39cebe182605e59e935d3da0d9c62dca96a3ce2e8fdcf614ea02f62c7402304f0f7e0d62a35eb79558dc431c23bdc05041e0fbf965fef55ab0b05c60c6d327b7ef763a945e207f672e066c8da93bbe8c4d1a92f6c83dfcd03ae5aaf1f0595c19389def278919b764966c68fdf39a471b3bf818611187b91f983ef1f0dc201c26772e522a8b5bd15ba120dd99a5f4afa39668c48c6fe816090cd168d51b48e5b5ca0b5b7ef3302dc4d9e8949e8b685dae75a852656431a2651366be698c6575a4f2697db56bc0f751e6feb7261877f5b79df719b0502056fbf4ebc1925ef3ac3150c071547af7d3b9f7a910971562c4d54e6868b3a7809bfa063397f0cc94f6ac46bfeb5b288b4f4d38ad79206660a1d626dfb5cc49fa44e7dd339cd79660478a22d0a98da33fa09c4674238217965659ac6c8f9b7e10948c33bd203e0dec5fd4b426a99f98734a19f6062d2c1fe34f8f22d4229389392a4e87fc6a57917780460a65770283bcc5f7ae7c85312455face5a834183e848106eb89066a37f89d08eb679f421ba550dfb154113a86673b2f3fa2feaad6d0975dd8e35cd7d91ade465cbca01887a09883388273d18d2c19072ef238e16c88cd185b97f83885b16e77009981ba516d8a0da5d6d20b1bbaeba140c7428f5447c7acca7d08582fe67c5bdfdee25fb6d37df49472b6594c24ba0280e439ece1fd5d8862d077798c887928eac4849e9d31da32dd78e8ca7117819d4d9a129afb4ff1885d7365635ad35d0c3fb2f0bccb1e24710936474726837b5b65c26bcceefab3e1fba34c2575a1436f272ba8d504cffc6357f888d65fa427747eddcc6ba9c0544aca22015d31cb50882a928a7438e3f5682a021522df60e013e935b672dce7446984d3046ba0ce9526ff6740af07f59cdbda4fa9239f06942320d616aaec8dd8906ac4dd286fac7fb1b5313b51c96ef949b60d24bcfd536d46c46e4d1d6b40657b095fd710c4d6e60b4c786c523dc79194e34452d27ec48a6d8e8999efdc97a88df38a4e0b97887628f5500b3042d416dd3c940fe7b86263f9376e97870b90bf99b629dadd2448faff1e9f2d8467b40a77e164e891ff4f04e12a4303aadd12bc9093d8906a2fb1434edb1b0fb34f85c4395346f3c9d05421b31b35d7592c310e991a7019e360641f9b2129447fe21b90c25753e7c51b52da10fe0b6431454102d4266ade46bae0859bda9a522027219d585a4598af70552e8f52c22a65544bd08616a3d627ce16ff6a9572345240279f7fe8ca6322f320faebd5017f3ddc895a49b80475d0c453e52eed3a515f07013bb64cac2fa7b321d27e65541fae94957429a2402bf42697ceac06fc4e54f57f51e551ee89a2dbdbc3c5f69488ceea1a93a476b5fec7c6e5dbae22ab87c67a0938d379323e4968fe7372a25ae1165726c0eba007e9a9ca99d73939b9e8e0a3e906d9a3fd4a908125a277a7027e08470b6a1fc7c02493d8ced1980bc85ca0b852dc027098d08c465e23e920c1de08b91c9b46079a1b8f11788fcb324378ca92304c4343d594dcef3ba43f448dcd0c2b06dea929a45cbf4c4ce122bdf1c74526a101f5f063e04c1e323ba83723d70571b6e01733548d349eb2d8e26b67c9d7a2c9564182080fa62e1851ed86c1d2d4942465f5434d19055e55df06cce19484e305d9bd810440a83719da8d50d3df619cfd53fc33e2ea9d066e01bfbee7fdcd0d57fb162f71e1c604bd2e8c8d34b2498e80a6220d1ebe21c16d6c97e83571212ae1b87b7cc17c14b1f5c189a9dce64c0fd90d8d66cae7ec8c824999fc66521dbaa1b34a2bed6dead2af27af70750a66f062d3bd74b7732d6ffdaaa4f6641ad11ed3609300f3e839d615a2574ef3d111087523a1891844ce95831f5a7973ae9df5cc0d29537fe2dd18ee7e7a1e01cfc6113f9b43328d4eb1dd54e2b6bf9169b6814d751f6052ddbe9596b5ee1295b4d462603f0f3d4125f2cefb3eb40a543ae1757bbfebc1ae7258cafbb0b75b42545cb3e7f685b7310c7cc9afc7853a8310a01fb87dad37d5730938d3775d341b23ad8049260aa5ee18b13603b5246ee1dd4058629189834dfdba3f4b533bed867786188517f1e60cd9f56ed66f81d24e5d1077484f8e8960307c74d356f61c106e3b9d61c33138dd47a4671c6775f85632eb782aacfceb9f303f5bf65ca0cdc8178967f689040c7b64ee4bfd750c96c1aa4fe7a2e33185f5f75ae85b90169a2fd9f335db920a06c56bddd576cc9b572bbc10fe21a774e06d18fa4fc114d6185a1a91e82219b9e3f386b2ee2fb33b4ff6fc39ec25da28de6d0a544fa88f192b6c76c7b970a83d9ea090a93b5bdbe6766325252356ec799a0b63277abf0a29ccefebe323a7f495d1a07d7198c51f4dd3f0e0c3fd8976d31a4514650dbafef4f8f3c29f3c9a1f2caafc41050373395472eea2c491132989d18404744b32329c12f8aad5fe28e8afedbf103ed27777b8e1ece79e534c0363baee7e5f30425316a46c6f05f1b8f5ec79e02bcf249394e6513eda2c52142e57686652578fb0f06b4d10dd882610bfe30705c34aaef34367f0ac2e7d7e9555d030ab7570f06203996a80a27d8b5476b46ed8e1b4487819a89ee37ffee92a4c0e451f12e6f13753ffadccd8b2951fa4ba28cebc3823c4fc72c4d54e83e3104636d9f0f0cab8a6eb3cdd0da83da6133c631626da1ae12ffcc319ba3be3971626327799f6866eae7fdc7482269e67fd58cf6897987bae6548b2dadf1402f6daa7636281c9688fffe888351821d2f79a48827864bcbcf26e468e2275af5cabd681132b70089a8e499893bc84fdadc1cfc6ef04ba39213853b9f0033ce3af8be866a4899f845aeea0caf37982a5223391202a0652b60a73b2813904aad654029474df1bdd534241b9961e8bab22e3819040f18c9f6e41c6daf365a618efb27090549dd7d5e49096b96927583c2201bc6e173b482a611ea55912aaa715e1df81d98170cb93d2e878f40d70110d7eb8ae2fe69319ba8388cf790e6d925a70295459cf23ae8ef275bc2e4e29915e3eae4237d9ec554c291d87e5f9f947ec4a207827a86983b7ba6805504c35b24266b161158eb612e4b8967186b700ce6062edf3f8f7bc9f91893394427ce95a311f9bfee6ce6bcb64e818766f8e75c14c1266035ca8f21007c508449b047a8ac7329b6426ecb2c1225431c1c974b11ee3c73caf39095b6d11f4bbfd1981fb94b5802993a34aa97e44d43fb9cdaaa93055b7d350a0874f5078b05ddcd44c0e8771354df45f01d67dc4519157fbdbb45ff5d8a65b536f138fe13cf6f0c3888acaa9688aa64ca45e6193f5a0cd53962a3f529bd9cba064e6203ea4754cc65db1ffb7431d9318cf4fd8826f81b2acbb7c6afeeaa81bdfab0fd8c413b1ae80a88f14e373e00657f2d9dfc49f37c141c0968c950cc2b0270b1add48cc4197a99452547aec9fd25b6405409a83acbee905ba1445ce44bf3d16d69b6a1ed6c283d47286e44c0b1696bb3eb7a1e179af28808e19a200c9ea50f8a1824e95bd4b66f565b96c836b7880428ded078b1f2a8f9362d2a326d684559bc28475150e195c2a4dae77b5d5a37292bf5223900937cc199a15ab1cf442d0a89c4664567ac510118976f8086e572fb7377bc06d333321bdf3e79743d69e2c514c4472ceb6ad55ce29c8916556aec473e8585032daf73dcbb2a11c8a405027701cf8e046dbc81dcd84b4eb16ca7ba3c52b8f04039591247b914dc4ecb90d49dab4422501554c5aaac6ceab87c2995491e10c4ba10280ef4424689b452489c5b0ed28790dac9337bacfdb7cce9a6baa52bfe65b177a72a2bb6eedc4a5f96630b062446c0e16d1af7d419ffdbc98a42a629f7698074e01605d09bcba87eab600809e97038f135bb662dad0ac7ee44cd34dd4321d134331b28ad471047443d63aea8a2223aecc3fe516205cecdeb0c2251d8c0791e9b4d6547cd4a702f67e4df50ef1ce43b1e1aced3fac20dc30595503c9c83a83dc445a91bb27be0d803d642dfa3d8644de8dfa43a7baabf6f403d379d5b3f146158af99586b254096853261e5d10d460717a1a4249e161713e13a3ba4814e07d4ef23179dec8d3e6cca0613079a1520cc4a932853175c36a2aaf57ad6b2ccfea27d066f539125138d25ff39458204adf10ddc332fc86ebea78663f43c02dd581c2a602820fca807180037f31b82b40da0475fe29d08118abdb46cf1b4b911f95bab3bb0b40183a8bf919b44c520713c0b22a74e926415c5167d7829bfffba29a43b64916b47198fc8cd3e27e420fb6fd4432138a09aef8a05394af9a8fda6a841f1f1c4399874d16cc2c7346aef1923e82998a5e47a8e7750b6e0be22b9cb05ea84cdfbd950f1126f16c75916ef48004485be193330df19bfb549b788e315f27d93b44329ceaf28c2ae9802d01d84c482b068bdb05baeae3d2a431c0d7c268ba68af9d412be5fc000b978b85437dd13a385b2eecf48cb3a16ac0e1cf95d67d8c92545fdf8a9a7a9a3f04a8b7d2d970cb70c52614e5e4d2aaf0f9ee87ad751aaf278dcc0f316506906539fdff6e11793a63c366dbc6516716f46aa2bca32aa62f9eca29e58e8a6576047c7f697b02da1bf3e2bd64669e75edbc00b1d21dd11db95fb3cc4322764d109527955cf538d0fef4465672fe56aaf259631259fb7e0e373e2fd0a32e026d30df906134a60bcda96e7d793c7a6b52dc6bd38342f83611131c20a9eb0e7d9d30dc1f5a6f3ebe3aa6155d4e57a1bbe47f8a44cb01a9e95a7db154f591064afa378fe327fd190b20cbf3ae16efe7c4728f51f7230f545c17d6fea1513a319c8bc55292cf9d00ede3368d7c5b3f1dd8744981e21ddf29bf40ad3ebd3aa8c440d605e3c4ce2baad04f8f69f9de5c6a73f267aee7e8559404f88860f01f0a96e0d66f613ff66e8ae1e3f9b26d8fb9476ee57f3e3f40316867260adf2a38a38fda71cd5297475611728ae9d3fbd99a79b690c3c6dbfb8a570884ba98647b4460fab6a841afae70bc5d7e70b707363c82b67c63ccf1680f81554498e36553f1db87b05ebf28264bf69105283d9779c3af762017072d9daa14b6a790e5bf5bc180dfaf4c67fe2a788168dc9acf68c3aac68bcdfa535358c84f0b3850891f79f2fe02ef4fbdd4834335940af23d634632c8c0ec19958da181380a46fe29da56aa200a2ffe8f5273a7f8ca9099702462f982a838d3c860f6f700f7eef2c1f26777ede8ea0daf055107f61a08eec5c23577053b7cd7e29b14f7fe3ea15dd1d3627eb1b3ca45e593abe629e63f5b33735a809f9028998dc35fba5976af9d60f68b56f072e90952ce8a70499c08db5798794af2b9b84cf652a2ddccb106504727c74646bc0c41984808ce8b06d69904a4ab0c69164356beff67e304912f93983ffc687052de010d686c8dde8baaaa28f93b69da30f137cc71785c652f2ab9758a2f3c1567488633c01e7073959cd353e1de92e75421375c62c5d771e64259425c24147586a3d1a886a6ca741c51b3d3842f3dde4d67b0ce1bbd63e63630aab502fb739058c7c560a7ceddf7bb01b35b05d03fc3fa0df7a42a7fcdfb2f2ea01d075f456b5a70ad6b323404b1c91037fbc85faa90c9373a7a4f962d22c429253dd515cb4349f3657f422c46ad39f9ff317923b8b31c3fa60d3758f508e5b995588d21872569284c4393d407a2dc6ba10d872734136d8d387b7a756f49f9cd21b6d8df9017150332a3e0d2b24f05368fb6b291b43a8a56a5a812c681184f9aa5e088ac2cb9260596f368357109b8c0d799cb3f9de72c49a773a7ceb0e2cb1a6542dcc2c9dd76e2cb847ccfa8a30d413716f9f83faef4d57bcf97e142743b42a75202ca1646fb9c24bc4473d4228ebd3d5a7d5308226022515348795d3baf6a720e7c6c729f80d0676d5850b02fbf2aa660e9caa40243d6ed11f6a798e0333126b9b274968868124df84dd8bb685546c9fe9fff809fb8d18b4a9503622f54d6551de37a4d9f43bbd89900a97450e9ebd6959508885114deeaed4779bea922a210bf76b8c2f08a6ba73b5ac683cc667448c84871c94a4b74c3654dfcb287b2e4e19c7bd6c7b46256d21dd32d5fb29f362687fcc9364a8d2dff39545e3e8f7dae6c4e58eb96de3b73b063a38ff98517a0513f2c46d4f2fc24ff71161764828597f6595e55c951829696375bc40378d48eacea948ac94a29c8799fc8cf7a2737003a61bc1b8e1af5b6764eb11c197de57bfdd70896cbb005145227288ed2c3a3c2fb242fa55639eeda56b8a712e029bb32176f98e45dfc58c6dddf5b7ba223005ee935bb245c0faac8305dc5e9a622bfdbad82d6afe7466a15772223898e8693fc4bccc749cf65f8e534d453a7301971af948f3148d4a55c44485ca9e86b160d2990808cf68a1d97b7b52f3f3318e6a3933c747fc9a0752712153109d98e55767557c1f7b612cc1791167dbccf30b65ce90fb4d96f2e9cd56cec4222684d79463cae166c592045903aba93dda423b63370539db6baf7c7e8afb766e539d1a080927677a5c4fac92693307c3d5b8cd4a46f5ada4a36aad738d2c5145fc7185a93d759c1cb98851d4477b3cdc18dd7744c46cc7c6c4d627be08b7d9bef35de513e151fec4c295554042d3c128ac858a434efa5d6bd6164719a7007d574ef71af844c862cc5bc151e7a5ba725fedca92217f49693cdb389e6e2949ac203a895963b6118a5c0123bd41a7d4e651c949119e86807a4afb2dbc8e9d8c5206f538b42a02ad3903f2300895e9f966d68dd2313053cf9745d07d7693c1cb638528bd0df5e9cb87ed1b093a4ef5c0c6c82c2b576040051787e6a88e1dcc23aaa0b6daef5132952b6c731f61ef6f36cfe8fd61eb186a91c5a607754cfab95e89d9065e2485ff879e0de5065f8ce43ba9e9a3a3b8ec1a87be3722901501458f813de0ed951772a3ddd45297fdc889b59e10d711026d8bbc1cee35571ccfa3ab83378b739ca64e2155d7f1849f5f580e6438a48f9e467a9da72be67d2e47b3ad19d0af867331fe736c850bcd0bcc5a0099ec958b5375165f6bed872b0f60235cce4f44be771e020f36636e5e47d429759ce4670d4971a2c7136a1e13da1cc0e32916bc03b95190fdf4ce917fe94c14b211abcb4ffb7c7ed1378dc32f85c9b3eb15e281f29e231687a8b77c8ed48b91b0db689d1364fca50334545705b808be550b867fbebd3a5c5138605b2a156b0e3e7d4127b2676cb973bd1a043859585cd5cd42c244320b42ca6e31c65f107537fe7cde4937a5a8d85cf03ca62037aa7d4f5094c11190b9d02a10d6523e0d583d6f7afc6f0aa4a8324a71f224f48ad69cae0080dcba5c1548ea2c5e70422e4f75202c17505d6e4b84c51768a0c64daa628130fa4ffaa41946caa7e82b020a744caa5183c08f0ee8f5c0c6e7542673c5e368688961237f049e6f10efa1d8dc5902c5262651f80167dd815c174840ac7e8bb4e0aabc9e8915033695561b3014dd7c2fe9f67d63a85ff820d8a1b14b354c520d1b4a444fe735f2ba7371b0163cd120ecd6f39c18dc0855b86553d965ccd5e5383c11541e508a8431a839c6dac527ee200b1d4bfadd4bd9ad062d70576136421367679b3265876127821c4ee0ed20e1da787cdc627d753f97c5c81db06b4a77fd1ce63901f310aafdf78cdfb00e19dba7a576ad87051e186e848f0a40bd92cf0d167399b8fa084f45a78db94bf129d523971043c7fdb4ffd3db3328d928d6bb39fd5e24eb2d36fcb443ae275a40533283ef4d5cb131e049e2d5503594ff1010165633dc12e27d8212e1236fa2eb8c2a4b2a4b451de5d6742f86c1cdfb6e23628609eaa5eca0e9597b0e8ef53eede6436f64f731ded1f147930cf8d70f6efbb68b851926fbd9ece0b86b205314b51cc17825c7f3afaab32602d95e7710de4c609573d92155683bee4fa5a8f92cd90220bf16dbeceee9a16daa77542eb56e5eb550e040fa2c4f57bd5d586ba10d0bdd19763143057848e13a8cafd7722d896857a654955c8c8dfacb7efd55768b8f72ecfdf11e3287e9aea6a4410f6cb3cf7c3214325625417fc941a7508a5ce8e6d0047714730bc59f75beafcb1ffad6d65cffcee2883be68204f066da8c8f436e101ca531feb92ffd75ffe672e3ce45340d5f27da9c62d0bda63e8f9ebd2d8dee9ed477b8f57c7144d22bb5d1d03671a995a5719e57477f8071a82df28d95055d1ed3b7cc480b059e51673f17810b87a7c5c9a94126ee19ca7e9287bdefb2bdd3a74a66b28a7590565838a1757b1cb84dcade8c02d26559d53b7c5914fcede2e7cf9667936d280446b43b6962565adcd5fdb1605c0b04c6aacba9daac0089468bf1636eca08c56521f7eca82fa3d2baddee444a0a989e0440eea0c8cc570261e1b8e8d86a705b321e3a3c039f53d2ff8f1484c8426066daef31077f1b4cc615ebc57383fa17f019ced575e80f2c23fe0835c4feceb4744bacbc622be09381aba36d80eee2826ad4faf699bfcb9f02fefa00542ee5de13ec62c3f3f975f74eabd9ad1e3eb9e69d71e7aa214ed09854ee88e096700b35fba16650d7f3d8c88ab2189731e20814d14a7b1e48c1a8a43bc047af10cfc58fd11b46241e399107a4a100645dd5c1320c0b6234d1b16d8724b3a8692e4f7838e6db1807e03dead5d276d3ccb337806cd84578950dec812c1a221a60921c7df00d26de0c639f9e44863a65936defa5956dc0190e46cb5dc517a01e7c2a1e6243d5f9060611704b056d4039357c40c1e9b5db52ddb98aedf6229ad02c0d2bf112c7a5ec97f8b6f6be9e3bd4ab180ce629f6552b4d14fe3e902891129289cd8c4b12cd82980193ab0cac2d7e7dcb08fdf5ea52fb5381be337a44a7f3d322df560e672caf78744ea9954eb98fdcf50403fff72f54338546180549096e7ef4d334e69990c78bdbfa298895de5bcea256d8356095ebf0bdda67463bfaad45689d167865590d08008df2d49376f3fa12055d37e45d9735da874231457237a91b5cb26236e82507464869ae98539a6b1b384f365e14b59c6e504f08857e3d112a6ba5ce0b1a5e15c780e1e361b147dee187ef7c439e07fe620868b726c5c7499ff8f24cb7d4a2b1bb157939496270e7c8d28c2949a5e47c1872099c5f7dfeea71f9e3c76b19d9d889978cca61950573e4607ed686512b2a4792d3efdb0f8bd3ef141ddd97534968880021d98a5cbbc43cfe1309a44a3f1ccbcccedc692e8a809c79d2f33b69bb98bb3825a3df888d04eee6202a31840ddbbc5f8afdee7de3d9a606959f4ce5ab83ee77d81eb1289696a9f5048d821d57484d956ff65a6fa9ae07896834f5d7b3dc5c8f41db9a8ef25f2ca9b67def9e42307c1ff59e262b31243a3908c8628ea49571da9c88d24a869acaa7925b27bc93ca8177357e5a50851eae706440dabf742eaf28e16d887f3d170c9a25d2dd7969630b0a4ae66ff18e238b49a208b68113205dcff2fda1084a720729eded0a126cdf86c55d0c2972a1f63b8331c901544cfc53420a11451e892bf62606dc3c5639be7a5c448ad81d5edc6075ee025018e4c07d5580c996d4f88a66dd1a5c6a83ee1d54cb114be5206344f96291359d2183bb72f74692c8ebedcccc2c929ef364d8f2a953ad0e7ccec738e7e0aff870c645076b148137f21c64b498cc762a21c3143838e6cb4b4437a5f4a39bf73a2ce25f535e4d4b7370d12f2ce2c41e9c91d4bac0973ae92cc82bbfd821063211263b54b161e44b0c173b6b98f99f58b48fcc484313bd7eb1354ff51b037d0e871dac06ba182efdf20209019e1e240726bc5643677b2ceb18427584726a113f1e1465e7babf6df4d58750f2c6abc31c4adc322cba875c5aa36731f34e6aa685360864786fa7b9d8a724a190b7b9ef52062d4e3759571aad80a0790223d6640adf6d7705715875af39e6ae3bcd6e8dc60d2fdc79e33af307e9947936df5ffdb8b6d7630573b1133d8ad22ce5645fe6c54b55a8927d24c88d34cfaae2eb9b52c667d0370cf05345136d1139e14b379847c10aa4afb5f19cedd1e0497d7631fa377670c1ab5ba92c4a2cbf1a6014ac99da051a72ed80e786fc3ef82e73b2af063126c6b0a0d2c9fc7241d1ecb56333b87ce5163bd44dff2a3c6689408e5021e413297df80f1cd9c5f8bc3b0a632b772a63af2c2caf18099c2c5c811fa94782e4adae274a0de2cb52f829a865b9ef742a433498acf86c30f134972222aeb1f575a0c909d3152e88a220a19e8bc410e1ce4c6c640a51493eb63f1bd95528c662b49498d402e3cd99a6525a70d0b47f851cbe1e89ef1696d0202f5ef024d90d344d6332feb3fc3a7e5ce56f6bdbb2fc8aee5fc55891911284578702da4c70548de3ec5c8679be1141ed8d8b8e484fb24de506b5c3e4bca37c2c374da2760b5b1be48f8322a880004e9ba2896a30e779e42c8b444e87cb1b3ff77e2ad4dd948daea5a534755ce9fd04780d955cfbc62a0d25db0a50918ff2627dc8b7257ad9e2b51d61492f87cacde625a76a3b7f68c0cc0fd6f125d5c9f8fb723a527cbb4b9bab7137ee263861170966fcb37983415df52b57ca82f6b7c25cf652e1f8744f190e42f7597494ca32bd18210368cf66fe219711721f8b7b85f71dead40ce22a972079ccef78300abd69127d9273174ead518bc62703e4c5f8c9171ddfced32d85a88f008f017a6be0b76b1e6dc2a7a2380aaa25844e707479de13cdb042f45d472ed04c5b2ae50de31c7e7671f22ccfdb0831ce150c30b7f7ca4e58d757198f7ab978f6ea3cdaef9971877ccfd0e2ec6acbacf12628a44cf72a947214272df8a8c2996c337ae206703c1596d8a7cf2abba35e19d62ee4750e0dcdcbd8f5a832b3d854151e229962752f76ca1dff7902df586b789768e25fe68ce08334ca7f062aec45fd5223e8ea5f50582a68e8179f31a6726d7f635c8054b720721fd4b601256a5aee81fb0f0803065725af1087b7ff1e85214d12dfc781c567d9a5495067663745f1998c642bf42ddb74a4f991fcc16fc74f4b3aa83e33d1ad4354d93da033cf857825165d3904df3f483e2812a92133ac04792194a5e7b4f83411958e4ce42a8f8e9b583ee5ab11782d1e4cd036f4da9eebb580209890a5d0de97d776ebd74105a88fede4b95b0e32f1f87d0f23e8a31bb9e1cf5b624faa2792eb169a9979b6c9bd1eeb4bd0792258b94a9a6d92a80194befd816f421e5f1bdeb98aeddfcc11e8abb4c5e53836f6bdf1e559f25fd08983405de9c2191d862b83a2dd732a456bfc1d59a8a9cfd06bd58a1de0c95aa316aa67094cd83da36ddbdcf9fe9ef97eeef45849fe5d21ba1e01257bae61b821c403ebfa7ce79fa78cd4698d8c0f078001487aa83b467ed630c915e6935b4b6ba678a400864212cd11385f093378e2f48b24242e8f0067187b45d6cafdc9fa2b8780bd72305109f85c6ba0b9f44ef503a18d1a98abaec03ef484e61bc6e12cfac5eb8b3ebdc3d2a673f0c08d599605971f960f205d34418591b8456bb5861fa84b3a6a7092c1883dadb7000e5d4466974f8f810dd58d27d59fbdbfc51cc8d0f6e6dc78d27bd58942701c445cf2c1d61e0f414fa5ab1894266f9a0c490eb4e6b6689edaf319d6ed6d5304b2c7750ef061f983f3a8443922aabf7d057d44cc4a745780684d50c0887a2ba06534f56fef3378832d34fd6721039881b3df1b00dd1794bba1c60fe44083d02a8af02f4b9e21ef0ff265fea9e88a138a050df1b4762c318d4432fc3b1ef528b71f97bcf2a6a8329d472d0559c5165cc58af12da7161bacfcbb19dfdb6f6c3469233666fd18b37a27afd86504bbcc11fda882b6db17dd0fb8b547901752493836413c5d4ac7a33a15a5041eb5afa274f12b955b1a7a7e8db779a142e2c7796ce1e87354746b8f9c21e4ec95d9e2b3652f7d82306430cae917ebbe007ab22be93419e0b714c2dcc70a8aeae46e39d3abb4acca7bf174bab022b1653fe49cd4fee97b0b670220d0065bb66f0a4ad1ca5104dd05c62f2c5cbd827ba0805d615e2f7cf8077c673de40543cb14fb0873a02a79d398c5ead596a58a76daffc7905fb6f90ab26e7b4df8c2eb9e6ff255736a87048931acedf5400f5127d37cb1dd35a5a1519f69b8cdae774e4100cce7dfc7ad2c893f42e0ac2472cd4edd66cf78fd02a0634c6cc432b0e5b687d3b6501766f34db88fbd83baa5110f62e334eb73e846fbaafb6f5f70315873d78fa0eea907639aa71e2a3aac43a113c36b237ba6e0835a2aca2bb35243e170fe41e9be91e2742db6ccb14c8264c854713601bbb19f3dbe0ca6cb92596f5d262ea23e5a99f627d1b6b1e4572d92580456bbc21f1e74e163e28325f4631cd747fb14be83acb482a319bf1c488bccf1cdade80fc0ecd2a951270014aa2cf939651e7ee28c90e4da3fe9346e02d5f162bfa871e71cc8150f8158e12b2692f08b58b0e98cb2dccf98821fce9c29291367a6ff97203a1574620a7bf7fe836387617b3a1e1d5ebe1b74f08a0cf01df8f032a5873c8cccbae180e5067ee34d66abaa57f77b4dfa40f0631ee001edf2e345e2e5351ce91a722d801b61d311ec761b32457eed68b4eff9925a1365b18f31824579361f0ef8a73a84b5bdf9d0e7e5b343199ebf27cc2ee09034aec4a60c1ce03a453b75f7c4a38dc0da50a817ce6d35d2697ae8bab1040092528435f2e92949d4c9cdc71f79df255e3e85f6d68f2d8e57a5d2fa9600732beef4658afb7740572bcfbce64626800c9d8bc1ff40403a414afca5b2dc12dfe4c5ba5be2543f60f0e0263f9aed890c0b970d7d955eae2a64656678098995a3f5713fb1ad041b242f782484448de3d03c4b140407fc6af0e53c8ea733765c7c2f95e1010677768a689f03fd6f4b63f48efd2bca9017372d3c46ff03fe8dfe5df0af488dc2bd883e56c4a994dc40ae048c185777018fa2ab9201af79055c74dcf483507949a15a18dde10516b0ab82ef0a23fbec2fff77992681f03a9d4da761d5c232a57ccb1624f00fb4e3091ef8876ebdc4f96ec758c00291d57b4129413e85cbda44b27e2e71a0e89c545693204f481ea71fec7bcc82e8e416f685b0ddd4bff18b2e8d2831357bf2cf68d5ae96da552deaa14b1fcf435152c39f6171924e597fece5b0cb0a8d6bf2b2dd890593222628bcd91d1145655b2ce539d96b6ab2ea83de59f07ec06ac7b4aee66cc765290e39fd3497d5c0b6b0a4ad922958e6865a979ed52a225e53be8b1665c8938af6db55feb917a76fd415a8b677f84ee0e44e5b670f50217b166366063efb687004f5c70f5bb67a8342abf9c9b5b658cac0e1771c976c8896cce2b50f8685a6c5c2a0995541d26780763d98d804659491f6a0f3c84b734ce8e840fe7b71030c0abb9fc3ab8776eb282533b4bcc9c27bbb78694287184ad8ca2b9033af3c27be4e21ee58939817abb339a375b04d259e0a363d3a386cda7f28cfc59d5d43f5ab04ee4e960de4bd78a79722f9f1942083ff7c5b5619e23b30ff0183e7e4cefc4484689a2968910c19a2c54a5bed27d78fc68eff31fe979a9ecead33771601a2be0f8e1d082b56751310449388099f6b6e10c6f9eee887ea17d83ed434eb84d164313e5d0aaeb2b89f21bfd6742519919da60fde211b2b587b74daf79f674e0095bd38aacf80bd13a1cec9d7cda7adba0b2e762bc1a638150b038aa871907ea1de13a1babdd8b355494cc806b4b8006ff992f9ccded47928d4ef06ea98278f10b549ca2ae356eb9c37c98aa8e4bdde666298525af34e297c6b1e7","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
