<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"660cb88a2f5f19a88697570b684838ed364d1b4a55f9c3814dbad2cd6a985fc6ba8e8641e79f65e591a33f956bd9c5319b5beddcbba1c96187648e78b93a3d5254b066996405a6979bff4bad97769b686b2771d8cc4934e6e62cb317e694ecb4ff584eaa1d5c9abafa2559640f2a9a5d05fc938f40edae3a1deeb6878c0f4c0fd24757076e81d66506d8e2a4acdfa3461e465d7edd0c0aae921ec8a5985825e60efb64f3823e1fd378f2db57785858585ebee18978cd67807d328fcc4deed04637ac061509955a3acc60bd069fbf59488b77e8af98dd221fe52b9d586b7b7f5bafa045035ac7c0e7a8809790e52f58b77de1d4a1f7d30c2edd9911488f515385b3aa3ce5fd688c97858b6eaee0b7a4cb52c198fdf9446a3889d8c653df9915b8e27a5bfe2970a98d3e427b9ca7d85545bd9cf5cb439fc3ba84d40dfd5611aa94aa6cf7ffb1787a9345a174d114e6d282d43a69e8c1f3ca2cfe0ad5032a5fdd6f95dcbfc5dcfe39643971a30722554a6b3e07f6327ee2dbc24a04987cfc4c2fc1da542e7336dc11c44b7b9b68bcfe528df8d697c9fb6bd75ffdd9f760c7f471b7ded7151fca46ff85bed9f39f6176568446e745ccf5a9793ba20d6909efc0f869c59bbaa4f2f8156cf3f934738a1568e3c9b91a60f9b1d3ee09534da0791e4d5263660172b820b009a738246ea8c5eebd843f8ad6440ece47e6c414302bb16d3ae5f4484c5a15f54d8f11ba72cdc94d4b8882d48791b81246c661f7372fbc36b9ed0d1e50ed13349b3e8803fffc50755dc9ed49247d03212697747ee826b3ba9145b19b26b0354df19cc62ae2897e05f43cbd9ba579f5e3a3c69fe9c7b0dccf019c94eb1fa8f465716f8ae2f90582ada4f07b2bb18a100717311b6cbf26b82cc88c6dbd1440f9a1f33ad1f5bc7ac4de41681ba6a4a9091cd20a8fe9c2e5ba74063747ec1c655de79f9bf42babb81a872cf21ac9fdb51c6504c49a024e2a3067cd76faecbaef8ff0c21e362ecf4b08559a6bb913d8b655ea4875d2bd4f6174ca87696e073814d6811f2113294f7b5ef4c55aea127e63a84e683c99bdd9b85e91adfee47c3553f4a1fd289ab661b68ba961d715b6d34cde3d62f1ba2c9575e80502770a1235bd667dcc42e0ffd438ed523a80c6cb4d910b8075ea7b6445759f27eb575246cbc53e7b4413311f2d1cf1ec069a22af04d23cff8a32ad84e076c0e2976afed28018cfa34ce77419973e290f5a8c680407865426493e82bab3028bb80db67f038c46da46dd1a3adc8c0d4c40fa19dbc93533912427f2ae76e1be774d136b619958e71617389bc645e8257a048b532273c2653c7711bf2e73cc1d1a0d47ac92c1277964f3b56b4dcb4c4e546ca2e113651d4355c8eae4243996554e34d2ae1ada86a7cff56af6d1302ef1295cca449bf41dd3c1fdd71195a3002173abdb9c0655559887ec70d143c0a9af1477e2908b84c3f14b2dfaa7d3f439c2828213e9013bdd23497862f798949878944818b8a7de34f308d4966271706ac1e2eed3caf3ad0565b064150cc4a96f8a7b23569e5b02c792074ff723faff31c8a65d4dda102118af5513432b6cbb79a480811dc8e01f04acf57b990ed1f15341b192bf53cecca6006faeb2e8b05ed0755dd43200d66f98d725055dab300935ade333b506d953fa0ea8965ee39bb834da4b12e63ec4afcf9ac485a6e0191ea9167defe0c12ff59baf4fd903b213ce4e3fa74da419a1174288419e5f709035aa04bd1ad24ece3ffa4f79d968ae708b8be6faacbdbb32d52a6c983a88387dbf654ea202d0ac5afa604624be931bbfe6b18512dc4ab2db8ed11566084f5bf63af1dfa9ec32d82f69ae192d0e971c5cefe4ec3fc2c543bde48aa9df364fecfd20162c41401e335f2f3e4dbe40393bb144c406db18d10e99cc37140b9563f506a7eb1e51d3a86c00380bc2af4078f152887b96ce0c4270459580ff8d14cc30ac2b05e56265eb662a9483e0ad1f6ccde53fb87dcb788970f346ebca6db3bfa1ea363b5fdeaf15ed7da000aabf6e6a9025f67560ae8cc6445d5bdc05ec7c30bb3d13ab40392196b8b06c7e12d363dee663629f2da219f7d19de97150da0059807670103459cdcab3342cbbd2f0c665281f45bada3b7e34f2eaa316c678c2fdb72dacf5a9154c4d20edc2e8c5bc5e23887e7995a98c36f36c35a843d570ad9c396270eb948471bdd5e3999526edcb6be219c347818298a211f3786a19dae47d6dc18ff7e2507b2a19ead46b1b239626eec0742dcbacb4f107c71b360ae505a141ef9e70d09fa43ceba1c81455377900c28b716ffa3f3874913c8c6acc554a9a4b0f134703822c785d311522739f264925d69d7e691a0f637fb0bc0b45c36cfbd39a6f4f4a6900463008b79cd3a73f187531d32ba0d9f3bc667213d4ea2e387961aac2ad349035b27acce12439fcd08da7db3bc758cbc006ac7575b88e448740c119c4619cfa86912ae886cffffdab98018f5c9db3eda9a2dbdda02552dfbd712595fae8b84ff95b657a73862c1e936e5a1c5ca02472b90f7484409675d48c7515937c06888d86e005d877630ff737737566203075306f9acc246140731640ba7af2e13d19d7093b341b29834de16dc9b6c08ea15de8067981524c74637c5903d6fa2ea7ad76327c0d7187af223d00b2cffdc4126cb358f444524d93aa9d0165271055a6811e391ca2ff30642721b87cebecdb8242652934c2270def73139cfeee3498cbb09d49f60c771316a7457758decd7162eb4379a85143c5464d26567bb161a5e2e6042b886c2496467886ecd051446e4f28a7c8f628323592b475cdef418ff7522343a0b559d984785866218a5ea56e5f2129ed2dc2a880659af00ef70c732f1bf0dda85a9a87538f5b0c2cf2eb9bce4acaa1dc7ffeb412e46400f7c89ee01e47c9383e152a0b0d00a0e19eebffccb026a1fe5eb433b9641426095f5d4b2bc0dda6338fcd2c3804aebdaf700407e462257c49ecc0cecfa89ee542f8fb8cde8f12ef1cd4aef4fc61bd2c1ff55b350441c404562e67123d75292f8d4f00075972fa4acfd9e5fde486dc6514bdd13507f2a29c2b760449c2e6d9459ce2856baa764f96437dccde699bf9a848b8fa764100dd948cc1efe23517613559cd5ae8b5ab244d48f5c380c7451cfd2da910b3e24c2975bd48382d849704ab8eda9f4c79d07a137a95778aa06ff67983946dec64195947fc600b300c7cc9be243e1460fdc9215c71b98b39d42da6544fc9a77ce3ba96bf175f6991748604ff92f88b493dc0dfe70b328cba303cea59b036bb41701f1fa8888168c8ea3651a10f7f752e5163c5193089a0be66b5713dbacdd5e17a244bf5702630c1eb46c5c656e337d5038514e37414f80b790c5455e245fdab4e8cad60055a4cf68a4cd79b4c92984cf46c2dd34bd0e756c061fc3717aa05d7ae38b0e867437384ba7f5fa7469480ffe34983f063ce74550dc4acc0e7268928645a9e6d5df4be9bc94cf172a2531e4ac8d2cec2f497feb598df5411271446954eac8791b51039fb44e5a7629eade06f2c85eb50e6ee9ee629864156678434e6ed1e7b44335c7410a6ccb4d89a40153dcd4254241ab0fc00ab8869413c3bf6a8e76d00a8a8ddd5ec6e3a8f7ba0f01c0d9a653c71dae5bd1b38740b9fd34b239a764ca9f08ce6d9d53f5e4a029a4d920d15379402f3bfc2e35a40d81d80d305f85d260d05a065cbaa6ebe73ddd1ea53f9e49844474d5067333bf3ec11dea89ef0cb7750c1e7bbc8f890d5c058f349c0d486d44eb19d0746d9ca9481b7a9626e7f564829b0beeafce25faec659e2c7a08178702c30773514452811d5647871ec2e1d9483af965593f0853a7580911048648d667a6829a1b7522f2e6f27b711453cada0dcd3cf2e988eadac46a2f1cf9932912482cc300f59c2656d5e6a44ed0626ffcd543e76d9f433cf10b28d359117581bb40e57982e3a7fb556443a9daaf82e2d413efcb25add11fd9cfad2d9be6207cc5e75c6615de605c45f542ec07a9eb4a0e7dc3206ac6ac4bfe44225a59ae91b9478db64ecdb2047339c23184e570389e512273d06c8eebdfc56d78dddd9b5617e88cf3953305c20d41f67ad77f76eaf48a0c06dde887d8d1bd22bc4e5f6d24d56a57453b5098d8405305f6191785bb912e3d56bf30d1745a2456200cdd8d99aa4301db49d3f5c5015a5e8fd0ea3bb9a17c58e071703fb4b936d8a20f71bfd2add7539591faa293d4bda5a0e14ba065fb01386cb90326db43324c2e9745fe13ecc8b1274a001b16dc7f4b0bcb14452dd4133431310eed22abeeeba5a4ad972bfcc7ba2cba99cd510ed95774a5bd7463769f56d3ea8cdcd9441e6c5e07045d2ad8ad988d17211988a9b204bc44102c619d4e464fb615712cb413b1c3353c3b47bb59d8d1f26751cfcb559a32cce8e43f449dc1efc6a60254a10af01af7b7891c337b688c048a87241e0d34797908083360173e8d2ad829fe3260867cc37ee823e50c94555648b5434df097ac20aaa712e8886072c625b805a36d106b1d7d4db9c78e297c96d25cee416bd7c694db70a2c41049df09ccc0d6a92fffe64877e43585065237fb8a903ff8b4849198fbc6bef1c16f300d75cfbb4ae6a0d6718314bb890f266f1d9113cef7d84b78e54d88ce958efd68c4af1035df579e3ea20a8ab77d0024db3652c117f1807d5794211ab20a2a09574da854903bf07b98811bf0a6a9f24d3e39256147289a8cdcf390686d33857acfe3daf691b4f1392bbd3b85b9c6ee4e2b5225b3db21a8596b8947c0a85c2eef9c9a5f3186ae6a6b940398db3edcbf44388b3f5a54e743c8e3bbe38fe3c28886aac37006737baef9c177c0f8ebe73e2eaea2c7f3803e9e29ff5c6c5f2be2e30d7fcd66d65a07c5fa00925f314db0c56f0880de33bdc8c2af0c5d8441137180106eefeed70d262f940bed4556d7b9a0b679eb3e179604dbe8a3702ea3c555d77b794a8eafe28ea243ea4f7f3334adcc502839c07c9293039ba9a0fc5a478305acfc1fb2e938e467b0023d4ac7def093f9a9761adc71b1445d04528b6e6f8e72f774eaaee878b701b784aeca2a964dea9a3b90b433429257de06d091b880d878edae56a8ed9fcd69b9efbd32dc1584775e1cdc6d5b71895492ec4cb6762d603158041f301d4902b312beb1242d0541158c6b6a995af55b1c4b0e44a5a7fd19eeeb0232ea2adc49f7088a294239706a646c9048f92c50757c98a2bdc48d682fd78b5206f6a27609f7cbd7c2c4b80536fe1430dafda0cd944dfef8f68ac4e1eb04b4bb6773e95dd4a077ea23db2a2c4073a9e30bb240122f2e7765ccd169e6efefd5a6cdd71fd248e38f137b822fef15b9b169e6e027bb0ae1ec1b7258da3dd6df29041fd8af029a5ff2d078c10276f9cb5550f7054a2385a343b00fab319b60866a2311d0205fa7e4dc1f588a96a8c1478542e6d2dc8c5812d4d5ab014ba28a85770fb3571809a8b6bb16b48b08985174b8bf984a4441f1ca77499989fea1b483fea39139ee7dd2d3e701a128d890d1d2730ff08366763b7f126010fdb20c2532ce62aeee7c2cd6b4a687b7f16676a72a3064d8229b50d6153e51c933752074eea7d761f938b8736271ba84a418164a1efcebcc30e059b62c79dafa41fddfbcaf14b2dbca7f4af8e6adb2a9926b2a5cdda28c991ae072b6ea530d152143abe7e15956f3b509620ef3796d2dad5a899e635906191cd5bbdd4cfd1383b347824cf58705b79b565762870b9bd4c6a1ab789eb342d643278917fd031a20a649be69f3375de755a6446238319b4a7f412edda52462b45f8c5b258e5d05aacaec3d3700f08b70870f5a1664f133434359f6752ae2cef0983a20ddbedbbfa2dc261293250fa086e7efd627eef5456a752bb7fceebff341ecae8b3ac65fa297cc32c4f86c065fa7ffecae8d5b08c3bdc19250a223ba5559d1f9b085357e36b9e633735acf0bcf6f52ba92aec664d304cea62a9082ec273a4a58afef0775992413993d2f99c63df92e2eab95b73b162f2ca3be79525797cf086d48b9041dce89a074d05da94c15396e502fcf3d37f6c9a42af64cc896fe1a99a90b60841da92a00865efe52df929456f8c630368d38e1a12f819b59820ec749f0627a809bd6a54bb4b2a8fa128abdd8b2229a2f86b3fda47f2e1b1b56661fb98e391efefb4872dd7f171060c9c7c612b4d9c99c4c1e8554d33972ddbd062b13d586d5d54b3f57873aba2efcb261d4babaaef37354e34256559a568cc1ac58a9148bea8b5acf596478a87b887b5a0c8b2b40c01c93efa1323272ed30c886bc09a5bae572567b6f79a62c10194e03b0acd705ca03795eeea90d2abf8b64680b50234d5a6d3cb43b106791b6eb2c7a1a8d2f29ef4b12ce2cb7271829fdb7fd64db241144f0e8b1c72670a99cc11e05615efc19a7bd449d7a11475ebd4960b9dfa51b7d7e48f8b2b12ae5ad95d71f18cf50881639a03d13808cac9fd8d4770964a5f33b6f64395da00b85ef93e797781045f07dff4e06bb9d3ed072091edebffb02fe1f139d6c87e76d222e2579fa9786899dab00596f7a6737ed5a773c44916a9f52880612826f0c461182e62d40af76d1608ca9c2e8c3fe5adc7de72426e67c8a2ba6d7339fc0c85e1cbca49cb54b0578532b334c750e741aac7e5ca3ff67f6a3492312beea82c0b9d0e53e890cfe207f1ab8e94f7dcbc674cfeef7643800e421f4ddc9a974f0b25203f94a57ba2e17c45a6c5c11c937ee20c06a009dfe8a328fbd6dd7ef3f37f964e9873999fa5a4d32e17e49ddd86ead4bc5bbf08a55140a04791a05beb578562c047ad9cf82e57b29606644b6727472f2ac54562c94866aa3f2f82da661d81bea003b18bb3ad70757fd4f7392b7e2cbb017c94f8325bc839ab64bad44ae1d72825c354452f9030d80aa7ac3dff0ab8d3dcc8ed4ec18a702936385c948470d3fb1b3b076b6b2b7b2731e586c4ee198311280d6e45967b9c3bc9a44741cab69dd6264cff5c3d95ef71692be27a0a4160c846da4ec83dffd0ff528a5344b7f09798e42638015d3f3666510058473a2b98a0c7bf81a985d8f00fc079e087ccd83e95131066c881e9fb6e53191cfdf9e360ac6517aae45904c060be2152a165988a12d21c9c4e3c03a882817e4c78092a56dcf253dfd9860babb89c7261478b1ca444f90ea6806debd4c4f2d48a7e82ac10930f1282436b2856ef2e7bd3a20d88219b3e5f670fcd43ff64dba53581a30ed46e3ae981deb681de4210eb210748e1cd6ad465f9c35af8c3580c6d287cdb97ae00237beb492074a05b53f8b3c0203e16a18777a3d47d7959e00761a928c0a25c44dcdd51c07d0af34cc08466d084301d9bb55359196eb5a88dfe8a6b56a74d79eb504858ee2533e5d285928dd54e1f87a76c5e13fbe2ceedf010a9bb0ce7b8e05c00dc399ea7b7530040af20ba49c195d72e74e6b2434e0e2e383ac6d89a352cfd5666c3f83152e5c7b475753eb7c455811cd408c06478ef03bac58f954b692c74c69ea34161c45ff9118030d42681d3d40fd74912a16da674107d3184a4a41f0cd8b0454d4b7abead9c4ed56d808bb89ebcfa0ce558fd91515f9b82dda070df43558f1e00c985ed124b8414b4c934828b3ac9af688c3cc549a228a10a79ee14afc6a660e470aa8313dcdf23a4cae5e366536565f1e8ab874ed1b4beccf8abb05dbeac7761a0f97b00dd472671db74666d9426bab141e3bedcd01833828ccf1f08343eec15097730682d296c568b5fd99cc820a449b62a226d1b50fc39afbea12e16ed8bb248869c37037640b7626383792077e0cc12cb4e96947b494a31a4d2f7bab7d655a3790cd65f37acccf7780342aedc3cc0677468180a3f7f3f1e0513ab532424087efac58d72a8902dc78f0777c3ee6a7b8e81b54fd69cd7b21010113c007c1a61293435a03b3759aa610548bbe422b03f3b5697e6c268755095e3fa9061e08903c57b84a1141f03c300166569de8f399b1dfabf30ff17a5d0092baad32435894d10d98f272f15d9d7dcd8c1df0cc01397de2b0d1c9953d8b6764e72ec9319b72e8d716ae007b8a313fe2e98f1eeaee3eb7786cdfe2d647d5e0a5ef80e2ed4c679e2ee24d582d309743d6c4f0a91a011c7bc9e5f121ec78ca8c2add4a7f5ce586035fabaa7a98f88296220c3c6af9845a327f44f506ae86ad568a4099a63a824a333720e0347921659360ecb44fe738ef1cad7abe2a65aaf435e97e9accc413b90887e30f68f6e59ced4107e910c62cb6355c592e98905605abb7b55f52a194f9f7e8f9efb85abcb731b07dffe490726d715a905adea80b70f1ca93bbca39d1286a0790bf6104b71a13accf09df96e8adabeed4bc398a4ad3fb5ae5c937dbb4277fd4c1bd0cf05072608e087517bed6e2f5f6ff75af8ab1528a8a7e0daf015490f10779dd991c8752eac91a300bc8790559c2f991ec5c4b4d3a7ac72dbd930360a448a5c907ed2a28a82f3d4b60423fd72a430c1e1c38d9e479437cdce919d9725bb66216cd98c62cebaee426b2cc53caddc5d4b0f2de0c8fda6ee6f0ace30381ff0c10baf10513aa70e30113bed60ba826718e613f948a7514fe14a994ced508c0b267e6e570beafe83ecc8661c28138967bc2aacf643274cf25a65673a863971e9ff1f723969477ce4448bf72d04bc641219b671235c3abdf6b6fe3380b775ee10072bca7e1dc1a0bc1676f0846aee094b3755ed794aa08c76b5f35e2a728575e31f0605958a38a1e9eca02097580b9766612951bb99cd63b5841aaa64d1f389cc864295f87250f26b712e509decd73ffddd76eee5e3321669a14463c4489cbb9de9c8d0b271d958c1a00c5014e1ee1b2885f51874c6eaa4eb38d7589d103b3f382b902c48b13dc2e615b8f80006f55acc137babfe3216e84d966af4539897dc9f04d9481dad552fd853602860f4052edf4feb49fa88c0d2dd72d91f058e94e8d4ccedf15a1e4fee6316102e1245baa217b71bc2a9a04d91575315ca155f35f5d8e3216e1c00904dd524e9e81d4b57b3178afb473e98ff3adb7c123ee79339c510ecc086945df630c4832938b91b19b8117cc7720b9aa6f8d480ce9e8b90f8f463f50f01ddc5d7a992b21a2dc09f24e864731bf92b958bdd426d57135cd7b5ec61e57c50342c184d5b45ac0527af638996182b0f8dd5d1eba8419b37210e0a21903141c44cdb4e754a35bf58d6822b5f67e9dc1f683aceb0ace5d360562377edfa4c56860b483c5f466d41c9b0678b746b1259eeddebf4b48d40a24eb25b3d96059822745a05f9d25f550bcf0e34431a66c3c4f802e728cf0006b2796980df57ccd5feb6583b4d1216f92fb7bd34dddabb53d3e7cd3a168573ba6f1e9d232f047f0b66bb041afb047a2e10eadf0767c87cce29328a6e91e5f4d4049c06284ff4bd2b0fe7d21bd46c5220e1cdeb861b96065703b45a87e7942e010f811fe7ea050ba6a08d6c9c53897ce170114f30f7451ead75a3c021795561ce89ec6623275a68ae6d63cc89987ffc311bf531806468c35f9e463ca57aece6548d449167eb2d4733010f218b50ea8c6e87848eb6425b1d966653493a0569e309b7068d785a6d8c5773165754ae5aff7e13e10b87925d0b85bbeb808c5ad37905dc931916338492e61ee0ed57a85dc9ed8d28f3ac35e8a22a23f1a5914218067aca1a91b0e8980e5f8d4a823480b6047d23be75363a96c056068e018e060c478ceeddf412d6649458527d95d8997ca2e8bb18877c1a977ccc3f96d5164de8a4d543ceae02a1ce7557c2e9d0a0732563b8983465b1f6059256df1aa6b663033ab1ab52047ef5b1a8340b7fa50acdb8e7fe7aed17dababd7b9170aac951bbb8b2fc3d1e0765aee86312a3099e3dfd2a7309f755d4f5c4e0ffe21308805c4e6e540bc75bdd67d0050c23e545abc2def7d45ec899d1f8b45070cb5e2fafc9d4c6f6692673ce290d7246caf91c17a3cd5309b062711431e7a1a949a5a4fbf34b816addbf0c05c92fa1a77363356477bf0e7efac59a7a77afce83cbf5d8cd995592e17a55cc2c6ccc6e12359c1cd452786bf546ec765722052e0fab4dff6d1ff8d583b1b2a09c40cc2357bd655c78a7593f365d4be4bb6d4cd5758d9767a2496343ac1de58a6dec0abf80735c03aec791a63c91efd6c7fe3cf04a7a4223c19b7a3bb31c79afc4a81c61fe3f6e3f3318d68912492e81709cd8963f3e21d88045fb33cb2f22647513a5534852837e5506323473935272f33a698a78ccc48d8f22ce62e3e0268e39257ce868922b61f2b8c515fb643d6698ed115f2785c065776a0598a00c1620097495c6693830657873edbd8e3b2d229889b8654cb9ed40f83bccfaef0ccb68a15740fc36d64bc2173adcef87124b05395a6cc055bc64e99ae73ecdea8e1872bb52b72fdbcf7b8f85d2f8cf23696dce432177c125040e1b39d431729b5c56cde4a9a18f5045b644abc9f82c79072fb82a7654b94a8fbe1fa114e9890107393c3f27e1bbfb4a60b213c827e398270861ab9e6d62dfa99b31ea8a35a102ab724aeab05c1d1585a5d7f5c0426daee5cc5aa661890c4c7a88c799d12920f8d8afca70edd1beafc7aff683f3eadaecf803f73d7da390b87af924383c06288e7bff69317f31a26eeb219a82fcb5c9118ec8ba9a21b4523bba614fb3411d24115487fef00de65d8be0cf9b0e5ebbd651f6f8649e30982a3ad795e32c765af3b71446ee67c6ebd6e3299ee8d33a6af56dbda0983878982ee5d54af2b290f5d9e6f2529b96017a44a797a8660d2a256f24fc8c5002575713b59d423750947e608fc95d32456df673d315495dddd931a356dcca30fc98b8b360d2dad2cef3b57d9e9e5e1f59b72c6ac0796ec7c0c70366d8af37af39bd35b0bf8912022d4606e2b19a7624b761aef509bb557cee38c4236f1e37d80b682e03a362c088e5dcfb23446e9f9eef9a5c17fa8629aff2c444ff31f52d2e29894a6b4e76f69fd3a4ab5695a5d64b8497b506be66519f0940d9fd8ef78f2455fb96572e79269fca97077bf18b7a8f71e43c464e2ed9990e636a3a354d9002e8ddaad264b71b8efc7c91f48c35a13217950a9576989bb0f35dd00bcd50fa97d2e1549aacb83180d1b5eb1156df72544edd67225aef1303c5bfb402d481c5fd33d28f1b41b2109369f34e420ee2d3ad853ed82f457d52757e127a0db6b7a2ffcf7d60f31c6794fb8f5aca166a69dbbc1a99b826dcd59e2186aa2bae81cc6d0089a13ab70d7768211d894f858abe3e951e14b61b93b6e1b1a94c460df5532573246b2c787956cdeff5c0fa12072327eb301a8a189a00589f976def1dbcffc2e3d4c4d6a7b20e936565809c0bf9d19816774f0c5c1a2bdd33f88d703daf2291ab62d139392e2efa0fd99b4d549d986764ce6c0ede40f3b382658c516ec3bbc903794442a3db7b20ed38ba0789ebdbe77ad3417bd8ec988a505950a7da10b9f9a9e51fc2fb400d8516634ad0ce7d51de3f71d9e1d3103d94f96b972d0ebc55287ed86278026f5c551c1092fdf8780d58d1750b5725917677a78bb910772bffed98a2a4c92444477e3b970dc9269d1274ec4ebfbbff01ead3fee6a82b7e28b0ecd23e7d0e32d2e89a20b238c30421576616e5b13036176aa14ac5d9a219dc3f3f4826244d47b0f59a58131a9651e0732765283f482636eb75254f0519c68b97a0537d588e995a0dbc7cb657985617c63f75f73562895f3c0396e31d8e69465a5f6221ade709d9e1899578c7da940c25a8de72168645559db21173393d97d4a74adf7115b85d082737395652099cc9f85b641b94d8aa4c6ec044e532c981cb2da5e235c8e725b170e24935ecb089a8beff26dfaa2900b36c8c7672efc5150e8b44f634609c4c4b5b8d0f622995c1426ef9e67a7ff10fc091f74a28aae321e5b1fc00f10672081cdfc4923fe0dc48f9df740f15e09364940e8589732029e8e80858220709a5d8a9889051657509b3845906a5f8eda25216426632e68b3bd71b1d634b41249d6805de116415c7810ec5a60f3663a3e8ce89344431f67d0cdcf66d810a5f89843e06847da4bbe27f55c83ceef0cd658b3101389a99ae4f418e2cae73822ca46c83116a3658fdc02a59ff90d954d80bd40ebaa3a2fd4359ce45e31452b6016fc9dfaad169b04ae0d6d40d85f866a14f40168d9e4ac0f7b96a8df43a4b0b280ebfb1b56b149d3523bb54ae88726bf8d1749e1cbf5e84e66be3f8e88dc918f4ee386d222c48bcaa82bee7e32eac1874092a85705eb5f056c9e00be914735c2a653655327f28cb743763538f7d2b9629398641f6a278211c75cc1ec924cbc585ef550d8a115bb335bd64a0142464273f90d665c1a843fdaa4d102fa737b124dea1f435377bef196b6f2e70404a96aabd757ed60f8fd8a5019469df17375820e74d52a103b9d0450bbc6864d9e787d4ece85211723a5a6ca54ca69bd427ab1654358bd4fbbe93930ade2c9d104c7607b4defdbf70c824e5055fee76ef683d958c67e6efbfbea31e6594a091d3adb27084478c7e7339cec9c076154377a367163a38e584492d7936c7e821a365814550b44b06f04a7add9ca8ab8a57e87ce9b640e19d867e99ee4a0165f6e79728685cae295931da6dc2854d12705737d49896d71951f9217c86b8cad4626f1615133735250af9ad62e872ec2e0690e3b45f91504a5268dd93b82b77023c1a66e7e24a792d9b34ea7514d712f4f454210cedbe8a1edd951ec123c1728a910e2d8de982ec8d9953fc408e30dd7c293d22e914af1a53e73871011c92d72e5dc578f8e0c0aa3bb859813592ba42b0e21aebfa338724da715437ef19b6c42d24dbe4dfbc388aaa8403889eeb498d13e05c463ca1e0b9bdef7abaf589d5cb5a43e9289acdfeb7e11b913e81c8a1c8d4a13838bfdb96b38840a2b753a9d331a86eccf9b9a910e72060ff4978b727c2dea8d5676869ea0810db24f1c1a18b6e62dfbcd7f2cd158f46e5cd16f46e5e1464a41f6747b6c4283524907229cc05cc203f8b9fb6ba5810c69be27f2d984a358b4fde1a67609c82f04e929d541fea4a1d3a171bbaa9a0a4ce4c07646e02c9fa7413402b9dc0eae24583872f1d234c8835613bf7dfb1a1e75c304a9d7dea2788405990263d107310a3d608729b9cb8f2a4180824e40cb7c0dfd3e55f66daff230483b3b6796b1b8b0f544be76fcac8e969527466604998847267e63de0892c0f644fc421b2d13bb4b9cbcdc21d8e9f353d25e0f6dce7b57b345872953d4ef9823209bd9d9dc5e9bc9173001256f7721276371b1feadf66f591fc3e0c8463872bd0d4b931abe7fb67f7b6590d9cf85bd173580eba88d40eee01a23ff58198cb13c9ec4e5da8f660bf10f7066775799cde35d1a23a636affcf9ab84d9a15cc6c9b9b042e95ed46169807efc599310d51996cb3d7a7db53da7cf7078a295e01aeee5f287dedd62ecd5ea9d9d6100b3b85736ceae45072ac00b66844ce60bd836c3c750ad945bd2c260976a97d51e2368f02db2c25ba6f68bb229e7bc9eff766def9203a79f7c19d6b60ff24382df0383e96bc4920c8fa89852a741f4db26b8aa098feeb0abf629ab66b26d14e14fdb24b456103e842345f1596335bea65427f0984387e35068072b4457fe136e16a416dc5d4b1c0ce3866234a79b505394de55c5d6e5777e32fb09f371845b28023095a859a3ed0b3be0e99e84d324e81aebd575b341e1808b5d7ac8a5858228b570304e1260f24d27030172d944c52e091639999aa75197cf88bf9c32f39a55cd55bad0c0b41cc5f4a29b58e9911dc9006fbc45a7fbcfbb67b9b1764ba10aa1bc4eac1c44902550dd58eea277bb9ed1c35aabddf90eed7443301ccb2dbeaab0e8d1d484ad894983d4a042d99a8bd6770b9df7c6ff06c35cb3043bf5b2ff964fdbe8d498482c7bc22b1f6ce728bb8dd7938f91a413e0f01b9681bba34fa9ffdbd119bee64bbb4c2e67709811ec7176122204c78e4284b0a1ba0114e1aef256a2b0553565867d491e138c47668283d2837df641c6b68a077f0a43f327db5b804c1428ba843a6227f4a811eba339654744048dd20c5b34f48c9c93186f2d62a2102a273b3e3db53c7867ce1d3d3aa61ccea415da843e92a957624f482daf9e4ee7af86c52c081c008229e1446d79f74730028dd5a0c6423d87a6c786b064ad0e8ffb6b7bbd6f21536ba5250f3cf4f2cd750def37be71073ea313e94ce829629640a879600cf264d0fd4487ba7effacac556187458c0dc6dc5cddcd799e216d57e1b9169d03556aa31fb1d70a4c7ebf74a3334ec06b8d6cb828b3a31ed30f6525eb79f2b5b25bcdf9e61271a79df493eac9260e4c98fb1c41a72b825fbc5e39b30caa7580e945a14ec7b1f36287d8b31100132eadeb50ab6be1b7db986ba404bacb355e17883fe846e46ab623de511fd030e1004c450032b179a14354eb6291a59f63a7d53495e7a3a36dbc162f7deb11d0621168830cd9ba31896d4b97bc3149e4a2959dd11fdf52a61312cfb413196a608ad691630d79c2f9a98b444094583d94611dcb7a85dff536bc6c14869e0ec070e2ea52d933dc315639a7cd43ec69fb6feaded394ea2979c6e4e25e34f0231c37131cc397908938a5cd15c05542d134e542eea2f36fc118f886e327f2da93c93b990dde4d80d1014f768fa759558ad9775f7e8ba193cb7d785b6a2ddd3448cb849201736a809795e534ed659a86d36511e40cbb78d7db764360a9d143b9f9212ff060a7bb5c4d6681c65afcebcf6cda3d16b6d101c1de5b60f776844cb7b535e8f325d449f2053a6fd466aec1ff2c15bf9b0d0bb54233de9cb6c0663a82985f1cc235786f71c641e337df3c7eff0e1db75725a19d22fa78c155c888c2e089b946227c96b060ba30775ff8e1cf3db16ed8656ca2a41fbc308753147e82ec88568591d164d26b3af8a02259c19e51d77621a9975b29ed5b0c15a87060f629aedb785a1d042612990f2cbae615b7f853ec68646716a2bb4196fbc836bd050b7fd864d055550b33239cb75455325391864049dac470c6dcb48dcefb8a4d4693af863332a8c47809bbc0df38d9079e445d2c25f6c6e79278e52dfdfb7d69c00d8891f7a480c35c2ec03cb2d4eeb5c6f8e95f08bb37793ff6d86c0c247a2a063fe0240ab1e72e56267360a13a6d1ac7cebc2febf2333d37c503f3142a23c0e7333c2aafaeda967250a756f483a97b5b7bc899010d2628f7de0b1338172f57a2c05d331a975f432d05375600a5fd2aed9900412436c936500642175c0eb125215900b763f0c9443227287dae5a16f093d1f20c27575c714812f411bf4f11220e90d5a98916c7cf0953bd1343bacdc9019cdaa78aac82643bd6aebf3564da086ee04801eb822d08fee59db7ca50a1a4f07595928489c9373bc860ccec672aeb2cac28872daf90a3687a1d6fa882d4dcf2256c7c29851efb634268e965d8006a2d6fe8b68aaa9c301aaee8e84d50c9918766ce1b741b3c6a1e799fbc8be573c6d0bb0ec4c4766bf2d6a378b43e737d4786a1bac0e42ced88bdaaf1eb44a4cbea1244b6f397f05169391d4ae78a209887bd0c4d9f24cd38528bc0b9aad39b7c7b933b16f524cd4e816cec630f84278581035120deda79572a8063990634917bce331e67c79e4243e0e4a2eda9993ad8db4637b70e803589a14ed7d280619f74a7c06670da6ed2ee3bad2315e484ba9ce056fd2c16e9a50e3c4e14446d6a11cf060233b9fb522a4856fb2ba783e33d7545d222e1f63acd512c895e3655a40ae9c8a615a417743c2839be973051fdc9e147d0379d13e2fe641815796d302449a857d0b3606203de5923b171bcc00e2e3c14b35adebd03bca0818d0f580b122e82b6a38d7e1e936f25a04e9df","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
