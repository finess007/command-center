<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"54811fa4a4ac97d6b69dea428bbf574aae97f6680b4192436fbdd762fe4398574560a1e71ef4dda777a93f8ac518cf668332bfdf19f7b4d6d98dc79f86f969de5b5cd7e5c6b0993dfc7023c59701eb394f2f21fd4cb7b70338f6a5de277b511e6cca185d6d01d0775566bc1d3b3f9cda5414c76a46131df10abd02591659f67e45be8aad0becb11a7667ccfb5c0e5b0519d02d7e9031f0cab984d98a44eb3a58ed586d8071c7450a6e25b6019f8ea7d5c1d46f7adee236ac864b70adb3059add851e95025dbab53e9640452f43df0c9a380cbfee5e1fbe19fd8039dee40c08fb94ffb2bde84438aa7fc78c5f86b2367aab0a5b45c66222179ece61981bb7c887a20ad0e54d3089fffeb68617f4d97205e0d85af05ea553dc53d9509848c31bfae01b3be6434da126a926bbf55b2d40e7cc17b66643d4681abcef31098197a56da7a3f1a8f86139f5f7bfd0884583569ffaf320a9bc1abc6900d9833adfdf970a4fd53a2d0c34f98042583260f774e96ebfb2c565b4ad1fb8e588d477e9a1811022ca7cdc18eb6ea25cee248517d58e85f89d6085ba6a72cbbbac35161c73c8e28d096455067c0b152ae98820123f7fda637905325c870649010e965cd2f14ab2ac17218aed057f1d850417859316e155607fdc11ef8982377a93771267a5c5be460495775d4821c2dbb439b75e41a864a4018a61db5095f8271bb388364b0228c671c0bbf7f2d638aa97e9d7069bf20ca11d168b5532f873f4bf5f33d67e101996c5a88159d919cfd6642b8114e85cf6b3087782dccb3044cedafd3c2dda86a7f15a53e66caff0f417bfca65107e530a4bdeec3586bdbf2cb2a6670a906794cd7b94eb053d51b73b2a77b1a8f86bedf412a9896c0dd7fa84349c52ea4861547289ca3c77bbb6c7a3bb6752cdcb11c591f7530e309c651e60ccf46e838969b6d0ea49ad369d30a7de1c975cb9b304095bd291fdf14dc2f17067e26bb6742ca5dfb13a2bb9bba2619f41f57421a88bcc48401e151b5a0e614ce7ccf3a75eb39ad256f6a9de20f741b75bc2e096c499bc48e54fc33de18dbdc8b732d98cc088948a5886f9f330947a450962222ef819cc0cd7e80d4c496b3d8d7cd394161d2509e53b39db19c6a13636c5ec9ee9c7c5b5fb14a1c2cae0715fcd6e4bfd77dc40851c054a74e28125557beae6e8c37d11128d23fc0642192c45677d2f1a8afbcf2a2b2e2b3755c2b8be7c389097a567ecb9e8d57d4529c7f7da7bf32915b6eaf71f82057787dd573521cd23c4d809ea54acf2bb9bee217b4e63f3e2705c67d49ddde11ed62f49f73eeeb4777abf951852401f850272668eb5531c4a57543387267826f8842f76e6d16d0ccf9c7b3ea01b030da1e5f1ace3f2c5fba766aba9ef86872c0e346c05c6068e6a405960820316a52c8fabb4749103c84150c2c019a66a61530761554a990c32e80d942805770041c818e87f11bfb6a63f662aa6de67281c9ca858337acb98c54a2bab07a05c8019e47b9032fb3c00c93f252f195eec1167574dbe3bee93af63740b93bc847c874e195142a4c2f742876eea17073042454046163d05e6952edd0845bb06a34330af238836cc2ed1f2a21a72b27540e4dc6546e6b06971b38ec628038977db1020df445b3f3d226dfe8b11e16d43db4bad064d7f674120533b0ad4ec89a4388b5a3c672683918f62720c670e8a62c149cc18db0864a460f52ed8434b366d5d51d043c7880e85dd6e475d76ff66a2ea0c8403be83af6e976fbab2fc0895ce03241b0b8363d7e2c2a267217a161e50e4825b6c10bcbd00462d798bd3078979edc3b99b588bb10c7ead7a0d53fcc8740e15a632449ae6127ee0e7dcc261a26d0efe818d73c7fdb876e44d3be7c915d1de73340591d618341572d0d9c500431f27742031b1790bf02b7ff307384f8977a8e0ffc8c172735dceee2b6d5eee0f585d365fe14b03182d14d9a8b75ac7008ceb115815ccfb265e0f5817f34b2725f8c71443f436942a8a04d9de359b9418c0e7fb2de3a5ba3e0c181d8926b543b2f8f40d9d4b4656dac3145724afa52e9f95ae401e797836498d99b13f350a3bbb2e969167119be9905b5c2586bdedca7a1b56f0ef3b73fb7994b6462d104b9804adcef5a65fea757ca1d3b9071f89a20840e77bd24b0cc5201ecb4f49eddbb1e8a12edd6b4ff365ac4301b86d73dbbd559feb78c7842d30f6c59e9f3a1ff7c386422b940d3525d18cd5a6bdd23c8e208084649017c1be62f976abe0dbf70f6cf50b10716eefffcc54aeda007b8cf85a48b14772fff5840874bcb9e18a0e48bfc3d43ac09877d6140bb4377664042b555903b6f8d40e77a7d9eaa1d73ce40d44c9507e75f576da6ae86e63bb438396f6d2dbd895e6c160b0c1310e791625e703d8e2684ad5dee66f830b881fca7bd2a09282aa10b3076700bd15cf2d3fa02b590c1a88453c3f05f25aae5f4a57a3ac6f42bd9566cf76ba67762bb99e6b05669a1b8bd7c6ec73b2a0cc6ab8aa7c024621ccb6d76ad246739df732d5f70073997602928870a36837d8a6674c2011da1c492ad382f7e9470ae47d3198842ebe3c7cd8191fe77cd8f5dc59279944d83c1ea4ac813fd3b3ef0903b09abc1c1f54713c8493ea365f48d2bde5b09a87cd38180d5aa0b7efca42e382ce8810bb6bcdbe94f93aeb772f0d555de66ae136bbf237b27dc246151c101170ecce310e4965d7ca927e72ae123e732214ab274718b2cee6d882876ac4c80eca1ec189a203fb63efdc88d455bef1baa3c159fdebd99aa058e73a66589a68751b64fd444930633bb818eaaed3795502d7894c70b1bf27fb56e7e04165ace13e8824a217ddabe4dc97d1513203b0f25cf9631841a052735e293895a2f62f6d4f393ade1279475cd6c8dcdc3c0abf7586196e19114d0d57b8077ca15068e42eaa656d02dfa1c0aa090dc2c8e20b864560215dd7c54cc3126a21a80c6ce65f758663502075c346ec28b6780f273a09f9a5220d88950300fd28458c25ed0003c76ef78962e18722d902e409ca6e7a146ff33382ea4f2e25cf14d49f3a132822492dda91b4a0e57e0fd6f622dd1cd17c0ea44ec2021be96f672dff330f7ca1e58c87ea2257e51ab6772e18284ff8e9946faa52a71a676b1575797227c7b30525da3861524ace1728a6667e7a374aad72cc3ec07aa60dd511e0d6485f3eaaf36227d6ea142ac9254ea8ced67885064bcf2820d2ec8cf426e7e78876676593fa23b00d93c465ccd41b01362f33c33c7b6cae7602b6a52b96ea7169b6e8771e09b4b0c7ebcb4c6e34c08d0eb573a9465846d12002efc4b8a0774bf0d056ea59063326612fdf0bf19a6d32177a3aa743817466c4df6df59717d6f20e40f04efc2604320b6ef84d1a353a88b93a588bca2a0fdcedf02a1c8be42aac0d0560620139fb7cbecee1107dc2625a18421474691748f6e34ac3c2afc30ffe648041fd013ab245b075434931d535688b9ab7f7d85e179224955033ebc4f3500581d4ba2f24717daa651e30ac4d2608ba31b2f9b576c9b9aa7585324da25b9dc06ea92b3488a01016f0162a78f6edd538a4f42c0d99ef3219cb3384dd97661fd2d3d2ab2d9edd6b040445cabdcc62377d2f6667a284f8555e14572823ba1a1fa51cdcc953bd990d4efc0d06e4dad9856b55c9180cfc53a2adb25b4d4c6f60df56c71d9fbfa69d906d666e23f3c7c78cfa507ae3b8789352d37ef82993fdfb9ed94ff48c5df1d21e9f39de1e160aa116f0718479f97116bfc15e1b4a27d8e3cf5a40f4f426765f2cacf33e3d82086c7cf991cfaa5fc3c3024d2f60c17cbed4360104391060fd60a49db9d2034456bddb0e636b9a4388f89dc6c5e5202cf9983714ad6487ce7c56dcfd80b3afd4b9272c65fbf3671859be6b998e0d3f9fc6f3e416957aeb3bf607fb98adbaf3b355be7907b51eb37e27938c39c04e26cd088e53b4b080915f01e8ac038f167d553bb1d7c95349cdf97a57e4a86b04f41e983f5d8c958a3070bf8808bcc5d40091069fca64a5ebfb587cb315fb9708c8f6252b029f0b9be3f72eb7af8fc494142d9e02eec908c29a2c6e5f5761fff1288581478607a85a07eb95e6af5c1528ffce21bdae079ce07db338658c98c7db641071bf25aa701191fd8ff448a8e61409c1f052a5aa3d45a068686520e9b930a999c46c401fedb3de816e93fcb26306c789e0be0f36ff1fde3e1a9f9c3f4614755d328302ed6c7dccc6725137fd199c525b27c1ea40531f2387393cf39d05da60efdcfc30f50acdf934d24e3bd2f1fe689952eb1266d75dd71433809a352b0cc0402c7cb043486aab183251ad315246f0c3a96412dbcd9387bd8ec3e20cde7b8e8d6dfcb5f2962ca07ea18b4cd5f889af87110589789add24e2819be237b9fc0973181676c51f5e3dc447e329a44692b476b31246e23fe51f6f8b0a355fd7f3c86d58d3be923b17f389028c85e09bfc9ceaf2e262c0b792c61171fc80cc4efa8c16242ca7a5d1fd80cbde60b8e56853f986f4beb5905e0b199ab334aabbc30b09bcb175431e2350b298be6f998cf883037664e198415120f154085ecbb8d3023d686c9dd16b1bbbe3ff33ad8b5a7c7fba426d11965f35e2d2b447a0cc73a6981b03314f6ecd6a7b9f8738a32579fa61a768649793859ee2f1f8fc52c86507becf67eba7316c107e704658b03907150a96e849bfe2d446df23e85c377f235546d03b7384a3de784a72473d8e9dc5e05822f824ecd0a505e89874e70722ea622a9a182751fcba5fc65cf6de4b8f1a6ccb6274666826ca1c9a2b16f1e9e2b63878688fdcc307da7859f982dca90b33c40b2bae1148881a03081512ef14c57642d560741f0f977ed545847d3e0a47f58710ca392e530801988d61a41e665ec7a74301b596b0c83626af226362000ea8edff7b0f9bba1f7d192ecc4f2aa56a2b62ba29177d9cd0c3f208a73b2bea00fcc53d161ead7f14f1dda89f52975bd41d6627782a0d25aae32c54f7ce238c3fbd16492aff73c05f5406a5c7841951983bef4efda42448823069b7504c93125d924f88c22ccee4d03c9eca0ff4c5f582d44d91ef5a239224ab65bf6070194170fad14353e3911de7ca01c82faee8f33aac964e4d861dc26be9aef424fec924d3ddf0375c5e1714544a31a9888873f2c044bab91a20dc9bdeabeea028185992bc3b3da9a54e44bd5cbc4c704042a6e17416e246894470b4223fa019a8e7276337c10b51c0a9dae398eeedf2500bde6baa9cf2b068eedcaff9bd2b304a8849528302fa882c9e6e4999ff4e7f7853d4ff708f620850260bd3fb4c5f74dcc1df51b0e6286dfe1f8d57392986567ef0b2ec2853dae1ba6c46dce00ab3cb6889e7bce18212a7cf9d145d07108b1dd54700050780078c95af590c82ba2d2e9d907dfbbfd8d8952f59501280a21f20f8342f3056521985a7137d35bb7814f205c8572fa26bae0cc984d8b4e4cfca202c06d47d1e6988723eb7ae21a5c3c2025903aca44ce7aea2d3133c93dd08708912c817611a94578e62d5b6a4a43e98360c21b9b4ac53bd7cabdb1da8666f36b8a03eb091d0be7af803720c05c9a9e3eb34c213591f85cb886019d899b37e656c324ac59a3f9c0a4c05bb8ca4fb49f7a67a5bdd0fdfae877bfcb1e0774ed54db43ea291164e732e25d2c96e27f78b1267f71ae9acee8c07d07a37ae500bfee817622c07a933dbc9b72cc8f413a87585772957103edc757854d341484d8250ebaf871dca32cbc9bb0ab1d701821d15088a83759c41d860ff96e914deda24a19d42b1739641e46eb3e4dda017fe8cd3667b3cae312878be8d6372c17feffda968357e384fe33281a7db12c42e229f480997b04d2dfed1db8882eb8a4199bfd9ca7d9eaa45a47d7e00839a0e57996303bcd5eb7ed086364a038d60126328d281278e3a8732e66e58d3e726cb3d8809040296f1b586f467571f543026cfc0e3104dd3314734ec40d3472f8fe666e2ab65de827163188d143128a4b5b6a0a0d7f29d4e5d334c1bfe2e9194dec4170e3e4af09209ec32d1acd93be864eda6c13f6af499c83171c666b7437efca3a78676a2af315c91dc4b6cc636f38d40a6e47bd2d128b55dd7027c76b592fc24f100b9f26513edbcf1b3e7f15690a20b5ead234b6b1a724dedc51ce0d0b2067357fae512f4603ec995f6299e7e32a0cec4579e92b755c1db79cd5464961ce6ddd77a91ae79797a3c6de40323212e0fe33ed3af8b2a169960ba83c8f14ff85ebe59bff576a5be1a222e1473a7bf564609c8548f83fc798026b4a4448a2aa3f7a75b54af8dc7a4a51a60d63dbe33772bfd8e2abcfa5b25025dd119e5d0138a836c8f60e00fe62879a4ba4c40d26137d1b21e9907bd8dc6912755cb8ef37182ef4ab0c382d8d28249a8ddb19592f08a58fbb2af243255da9362115c0f918e3abd07d83f91434e400b02f3f24f83649d65354d586372e48b2c62a451030ba436c42ac80ceab805b2f101eab213e3009b72dfa07a030c5a612b7c1dccfc1947a26e65b5f30e89556ce3129644d94df58c6cbc757825b2ae0afc38e0943b71cea0798844f591806e27baea4001b10d84a538c7d2105c65814b8c99db0ae9852fab07b0153e8cbf20dff30e9b4f719a96b19bd997cea778fa4808c40a326beb275ebb74b31936c17e1639dc2583f19b4fc2f3e0d9fefb362bece15d2f32a1c77662117afb542121cdfb29f5a38ad49ebf70cbdf3bc727dd8f95e05d9d0a35d9e50ecffdb4c58f0ba8fc78c235b5fe203b632afa91f06c8ba9fac8a70ca4cbaf86b81fedfa2351a8b7caeca59ecd595927f9674341b06426db8f517bb4816ea646ab668dd205085a7675d29d259f2d45b3453b70d4b1e9796c3f440d578657f5ae941c33b66883a34ff10251223fba368e71b716f9df0d77fb6a35ac3a14c4885f1f1f086b32559aeb4ce1d02288ec99b177a07995b637e651498dcdb57d12a6652abe09c83d4b62f1d8a17c0bc8f618462e14e8141ec5d1911ad02f630c92c1701765ae4f31149d10d3a091e626005278276f307dcfdccea74fa22471796bfc893fed14cf10ecf38a5b341fe5d353d0fab06920cd46dc77ba18c304d46b4850023a6fb5637d0ae1d2da61d82f83c06b139d2a37120a97143535944812217df93d7b0cd2c009fee017cb6204cc19349ff2dd864ebbf6959a3e189657f279aeded371cb509f35db39dfaf8037d07ed0b392ce3cc23c8f845383a95a3213669869f4d4ff9ff90af2f31491c28ac78ca718297ad5e8c49ccbae535f82f0e283753c23e8ca0075f4a76a1007f999daadbdcab9bdc25dbaa909bf3c23afe942fe90de7b5804968a4a0377c4012fbd7c72edd9eaffe01fed427b639c2a0b5dee336d9d67f935e8b8e6d64a4e6a80da0420ab1bb6dba1171a4486986510c62eff57c61c064cd0e0f2e5ddd77f184f6a262ed4207d4ffcf65a088f18d4a9062583d29603169be815dfcec82509b5a5a541e5678140b9e9830bad34f4d4e10c67531e6ac668c847ff686a8720e7e3c3c99179021c51c67a78da37b3a90dc403a352cda4e6a9c43fea05cb8085e77e10528522a0e4a13c2a0a4f1ffee50bc44a160e011ee217555509a782accf73de15b066a4c5f27e14e56e0de30d1aa6f5723c523903f1c3fe1fd41f2fe0db0501ce56dd75fbf731941f1ffc0cd02883ed1d76c712a2f5b9fccefb1c5bd86da1cab47105355f2f7ea95bc528fa69e4055424f2964620a06627e6aa8a7b925b4aaf0cf0a63711df6d38144b83e55bc965d4a4259bf870d2c42d64a409363bf71c8cd3ec3c75400206d635629ac52462408a24c816e622e8b2fab4101ea0d7915c92949139a8fa265ecf2ebcb491a3261c4adf0ac5f061fd8da56c6b861a836c29a8f9e1f71a349a578ea7299424c4bf63b7931c3519e74fa0a3d5a9c886dd713415819eb532786e0e7d1a28d400bb2d4ee43be63b33e0fd4d4dde5aedb4914c71aba6b0374040b3d20209bad55fb7b9573fbf6b2b4b07e75fd501bcb3b5fe7572a1be6a462a72548f2dccf1ce3dba02e8c9719f1c32fce7fa75c2370aeba1bc97a09277d6bab638168279af6e1fa27e9a981abc148c8bd03810e6efedd4a61055a78e82b33033f812c95f130085b1a5850e20ee54992ed6cde6d3076acc16edf49d1ea1c9f5b6d7bdfa48f93d23d7538cffbf69d65ef7a1aa33312bb0d82585bb8c077313c68366b1d499b323950154ab32ee0ea093fc44ab14f0b91d8bcc66067868ea70ee5b549ccac17972c0805b8de9d15b8010138b94b6e3220824d353675fced9468cae1233061d989dce6dd197b463d2f051fe0f73cd7f54e888d5cd381ba1be63b04e29203cfa3b137e8758bff1710d1903f287843408e5e0db0fc040f33c46d763a4434d43019d2b37fdaa72734faafd7aa61b90bd2eca8fed35ebc3df0c2beab1102f8d32c9ac736b139eb45236e22c82b895ca119878db108e57800a177c40f8d462d711077b72136d6f36ce577fd374588ca608dfdfc6212ca8e4d541a04ecb0bcebbb42988560000f0f6744b0400dd7b2fdb11cfd4cbd776c0a7835c6de66aafa8cba8c0d2ed4fd040a95d0580bcd0cb7594b1a938866637c9462ec848592bb705b6e7b400eb78810b5e31039c07f683d6ba085e86662e480b5e4a74491167e1cf529da64f346aceda36747e3a6a249725a2d7a179a2c69fa9ea8da2f5bc43adfcbce49cb6864a4a9ae0aa8720fae8cdbbbf5159846a65c26f6d2df1d5237fc1e868c23304c2354b400c6a906a7f6e5d935688371cb2a6daa4ddf81d82f41826a0e80828d8a7a1e05e6126a4fa590f233f3ad72bfe7781cebe35012fbb29adb0a9b91b0238a857d647bce62dde1618e728eb95cad6808645a9cbc290821e44f27f8f0ffdbbaf54d62cca5ec7b94472c2d1c6b09aef036392563a79c2a6ec0cb60e6205557bcb4214bdd4ceb31d92a8a2254a9bea38953bb17c0f28c30b909b75344f1b4e01df88371d8f2f465a2731baf6b3b477c3f775e77b39555bb759e455d7a9601470428b083169a10fbd40d0de6b41f018aa9d53783bab143db5bd86750ce40528cd72cb4537527e7457a49f1715ebc494f934dbe3961c300d97871b5ea020c5bca749c5abeb4834a0506947d57a187515654c855fb2f57fd56aff74e7f322e9513e031700f84d772e6daac5170e260cd2618085342462cec8112ec5c5436d1420aa27f82e256e131f9ff0102271ee4ec517d08fd932d8994ae69ec538f9e9fa2832fb6da9d9463fc1f105be91b5a8c4afa7ddf8cbb419b7bd3a235ed5b113984718f53d434f3e205869d02aaa41a01c1d6ff88bcc4c6d2f73ae1c8c0371e499b1160c21b637fabfd6ead0c19b2ba80643cd5930527294aaf238e9ee0db9643fdea6a6e410c08f71f68216ae5d1d429ef9055ca88f193227d43de961582dd5a4269c6fcc915803be488cae6781cb94215dee667ccadbeb150c3dcfdfc582ca15bf73b69f28a3d0a011d4ca1b0e8e983826963b6a0a4db4ca2273d15a8be24d2c11362e7cf1f6c52ff04da6be63109a527aa2424f79aec2089b86eed17acda5658c2ebbcf3b06b1efd71944e8d0ab69d17cc34e17c2b995729468ba45aa05e100387b8f807385127a75927c4c9501b32f27bbc1df677a9b3fc62eeae3adb0a009069fc4f5233ee69b93c1ede493c87406a2089c4d7577b6567483cc2394e899792153d2f314c19d936e1a737d2d4293f6d71ae32cf10accb1b1bb8f6cae471d7d9e11776cfcd8475cbbedba2bdecdb21a641716d675b8bd1cb73e6b587cdb583b697efcf518ad911880a11c7012d3120427101c383541a919067fd177c784bfa917006ee31b872d16c61fdeffa4bbd3e3a426481f6c10a6a0008d16235412fef31fe3515559415b3a0155fe66912519f25ceb45859ab619b66b2eb9f6ee91a1614103ea8de43a002a2cb7dba93ad26c85f7824adfcda2df8877778a7b865e6630c81690d7d99a12d74e91bbebeafaee0ebc133a32f2c05970563efe55a453f036c97cfb143043d28c29e6ced09c5b49c839dac48fec87254e7e9f2924a7b09984d44b3e0ed8f898639a817567d7822aa4ca20cf39d71b9931cf3a00396372b11e3d52316fe5991ecd6b0fdc02baa76c327b7c8e82ef6aaeb3e1c64147d92c46fef79f52252d0a61e228729989cb4d561701680c5ac7fa617a3bfe1642bda44a5e3099ac3a145dd4b9b14e0cddc68d4094362d4a07f89221f87d41b872a6698c3ce1f9f86781ce6d795c8342a5769d0640c279a617f1efcac07a4dbe0269690208c2369c133f1c36140eb823d1a95ba4009f2f01cdd4f8cb318f213b4ae164cbb6480b49c635de5752d6b1394ed6afab98ad9c85e162460cebd3b2f579bf554007774e7c1f9b327b414cada3d9667d15cbb060b605f7a7e09566705d72e6d134aa50e0da4520db55f44ed4d43a3fbe431cf27c5b6d6687fe5e7370d0e121a97f2e8370b0c3dd41bb39e5ffd15e3f5432f8adbbd1bc76b77dbbdd8e9d74877258395e21f0376808dffcefe604894c7ea74c51bd63c06c1564dc50b1efd0c443cee3ea2f8e4b7633255ff637f88ab947e4c7638be760a020cb2313d8020e1d966931020529541b79e5226a055c34c716b65b3ae96c6156e453c1f2cea7331696c23f71f65b2499ad64ea39af06ef26023a9ff05b7d73ea37b3a8d4a577c2b53ceee9cff98d4c976ca9d0d70ff0dc516e61d8a892067cc8038c717a5c6b5f4020a144f77f0e4d861618a4272f5d6ffd5ef99c0377910405ae40ce7d8d90cf49f23cb5cd08ef5f411a1fc4853e282cb206859a7c7ab46453937f5230abf8b1a1ee32a27c2150524121cdd16fa40630a77df59eddc4a958aff1bd28d7b36c239da779757193779b7bb9c33b34e9f526d01fc0eb1921720c567a3c95c43b2b520a71b30217f6973db8eef2af45de88279e31347f4cf9400358587f6649067917fab3097d4b29fa5eccb963c28ad06bfac438ece4d130687912c726f6cba6645f4e512beb4a654c25f8103569a6d03372b3db9df96c2543d2635ee596a27b6827919c78a4dd54fe37e58c46b57ebe397ae0269ec7daad320823a44eb14fc212e2c3cf14ab4dee568a6b9dac9aac94aabd5ade2c9a1af0575d5faafa7f5c9b1ff56612b64906e4ce7d5fe99f349afddc4817e1bf8095f8a879d1a248ba1c12b9358af6729cfde1e1ec9a279c7585b74c7c7eb47aa6e83849775b803834a99b283c0197b02eaf61fe8c9eae4ae382a9c9661bedbfaeb2bc124a254b838b63a97c2e1e291169335931e53f5f7808aac949f4785c75178564b640403e3c26831f9416221625503e173c8c2582dbc69ef81a9261c187450b17d2653c7af7210dfe174ccd8026d09cfd00297f4be9d643915c698d010649198f74e8a1985ffce6d1858e90fc8c5f0f6e6a00000cb75ac64d74bedae919ff549027f9d1b9d54b776199f64bf202a978c529d36e4adb96cafa223f14643ed6b476721ef3f6808f13603fca1f115ca6bf811369eddcf95e51f1b366126b960d59836c6621f0d78bf4e59f2386d1b718d004afe6c3412649716c6ab822dd62906a29622dbd48277637a91d0178d1b1952615515865eb76fb2e105841953a0d387ff8c71550010b3d8910b3b51d9eca6c4d1ec4b45867278abe3d8b9a425b58bca8687f891426685e073487f548b862b6534cb391e6483941250472d4e06e0b9b7efd40935a58fb23c3bce52ba6fa2ac106a3dc30591927d947df3998b57d8add018f7839a131f73e70fded9aa1512004d285241365de55732596c2add1a1f85b0e11c251c4c04d23b0cb75d2814b5f915c1b6d240a4d587d5561b8a5c2471234d85f6d211e1ede5c9a69345c191e79db5488efa6b8a71fc3855ed4162cca1c5cede078fe94d6db6bb66464740ec2b7490bff788372c35dc34a1a59e09e290fb686318d3cf3469ae34446cd4c968de80df96aaed1d707337e185991a84c08c9c2adfa362b68525b928643d3af1d02794af9510bd84ee4df3de4b8b2f4b53fd899e61c8debec46726edca2aa5e1da0ca30bbffc1f65147f45d0d30a9b53259ddb6593b7390c61735cfda0bb1f586603702cb7d17e6ba2927919902b155624fd8a57e8881112621ae85eda515eaf58f7c2ddc9dba756be661b095ae296f85b3b23c64d61bfe1e94d479c01c98229851ebc315c363dafad56b21364a97613c6526a7e9be74ae02ea2b93c22ac12f62ffb72e9f043779e1376bd523fc0bba9a6fe1bfa2e8a0b948c4fe500885705ec7abc5f737dd840bde0595277fc2e739c864efe35b5fca8d7ce42fd305d562e27962df48731f54c6fcb47ad01f2a898f7669c680e49c5b8b7ee41c4de76f2ae0942f3a09041da9fb364ec58eff328cbe781d0cc29a73902059e0e5cb219a2c242dfb0983b951ff543c0d839d2413fbb5b01e72fd7b7264ea5c8d1afee30116fd966520c5d82a012bb945e13b3d8cca23a672c4701e46df80f680361abc7acee7141c23731b2c23e6868709e4d448fc767d5f6aab3e032f221658ef13533746e1207236da5ca3d12ae87be6a6165c2b65f9b5af062818dd24743d21009c9f9bc4136dc30c4b60d81e2591cd3f8f6b7c8f8f68b2306978b030311a30b506914dce7b817335850ca5c3f468d6057b74a80af1e0d0bccfc43c6559a3c5391f005f7057c3b35b6ee9f53eff8a0c983ecb1029bed7b6c16d312be15e63e8cf211898a4b8a76e86ea53c2a950156ff9498220e2b94b6e832f914ac3bd515921b4c93d8665ca601010986c297a7db48ba5efbfb75ba5c2a09b69d6af8acaadabf3d98f36021b4981b9d615b61f7e6b6e0ce5b97ba80f85307f564e60b8e84ff84af04904d41555e63039356cae4ede94d6e6ce176b8a89eb1deadc604a1f3bfe416a77fdb345786de8de5846a8cd1647b4c643065ecffdcd39465ed95a23a3a53e3f0d31a0abedb2cf973e4d9891c8a6c6166b05873d3d4d4de4ad36a4e991979e258b0b91a8b2dcebaee588afbc1357c2f75030f153b26c4a3394c6b5929620b25653c5d6c93de732ac1382a3f0b2081c4a5d4236533904db050797f2bb51a3bfd35a753ee0002574d9dea57489abde2752df6b56edfa641ac7aa2476e7f9b23dfa5064eddd990998c5db63f1c1071eb27744258792d3d26459a4444ece51c0bca4b632b317aa7e6a990f3c67e611f7237e0038d1e2443d3329b1237c34060d3745970d13f1c04fbe304d4e59645af04e02c5a3a26f66b47df0ba34739c8e1dfdcfe9ce2cfbe0856f9ac4d2ec4c058c597eb5105c8bc4413c09089a9693a482f45c32282be468c991962c692507d2358f9c6cc1c119b47427b46a90db69bb59fb32827a57253065f5eacbca80e8f2fa112ec9f0a25455b8e77f7ffae1a11c9915ec215b070d17ea3517e7a4ad1684b5fe8c3f307139a1e5c493460a673bbc3f736f572ea76bce46dc4f3bccf9a26eadaa790ece37145dc134386f9eb9bf197d56778f20e62dfdc3f62e2008b603a7a4061a9b608849be5f82cbf502bf9b10d9a8a849fbbe21fc9e1705a8890a654c9b0637d12990598369583954a86b80eb468e8dd65f7e60c558baaa39ca367d8c960194fcca81a5a7bdb4ffa177bcdc1b7672b6c70079096ba40fce93f584a85ccb4547253f9cf191c8e7c767281eced29296d98a4e19e5a707bb738d4cc26b60f87b5cd7caea9040bd09752dad2537c4b2542992c11abb95550f41d9850bf339a15c27b9fd8050c5a147616d2072cef053721c4755c95cbd242e5f9899cd9d4499f5acc4fdadd12085bacf01e9861adb0736b840812b14d5d820b48e5bab28697eeb79f035899d0e8ea9917a6bb327546aec12aa07bcdfadfb977575ceba572dd5f2c491ecb1c36f50632b9b2236568697bf2b735647f2f3c78a16a61eebe554798cd3d6c51214ee89f923cdf14084bb224bf0534a447e0324844619dc31a659d0e152ed6e6723929dd09ad87662c39c51d558231274f18dad24920275740d178462a10ccae5ef56d5b608b1de32292785aabb8f3ecf6dc368241c49eddf020bf63d0a0acf656a48ed2c3c02cafec4655d10c9447666cb7687fb4c71056f5a5540e9b40534a5c7882a8e92d13ca27040766fee384dc27fc8400d953cd28eb3863ac581660d70ffcf5c226c44f023ac0949acce1686a7b1b3002e9eddfe89b8dd09fd5099b7b1859e1b40e396e10d3ecbb1027b0229e65579d29beb846b6a2c6f16a0207237789f6d8e12e1ffde9536df927b65d72fd9d4f7c9bbb795056af30b8f928c9e819d1d93a06c827324f76bdb54a9c5aad2fc5d83b8e4ef23dc60b75cbbf5ca74e78742b1fae21f7347510ee33a97d414d7eeb3960415c5fb79ad970ba5186f2904da252d204b760684ab056d6ef9c440b882790edabc625747fe1d57268e7e70f19f3ea368e82993648668425f710cecb3de60d2f6a675d66a7d5467ad24b1391edff2c125270078c9ca0d7f30b97d42871a802027d19fc0ef5f30ffdc739ac8328b11c913019f10357c52fc76113b4597da7560f071ffa4c54bd0e50b664ed93128e85795eeb671f369b58adbdc413253effea9f2e2dc5cf28348e710451bed0baa597daab6609a111895317c25c3e5266a4d7437af3d0b481a59a78dedc42233e9c11338fca6c4e0f32f563d67b95e9e62c6506d7a4f0170e877df6a5a6f1aa8e30bd4072979ffbe2be25826b6e01b4c54e7112aa9238c67b71c51f5557d176c5513ee9e6937d50a395cd2ceb371fab2ca26f5891f5e046fc04180311fca5ff19ac4933cf4b0fdbfefb89cadaddbbc2f5553f36fa3b11b9528ea22ee1f86c2bb08d477d5e370ae507a304e5dc5ad686e110185b31935e620a488c1b5415a263467f8cd7fb55ac9344d7d07c4ec24ba75e6283053ddb0ddf5acdc16cc1b43ff21a873c6a214f1679621f8783c73e13878eb4103e77943bf9190e04552dee94a658ab1a3635c988948dbfacc9a1d706da868c21a40d16485ce86f8d8006f5de9981681f45af45d06dfbeb6e71d50bfe540ca7eefd44abb49a43957ef51d9926a58d7527e4151cf17c090272f19a2163f404c0f54ab3622ff93d75bde0f7b7e0211a559f5364dd7cf1b4bb5222c2542377b69318f5efcc1858da7b735051bde5f5ac6bb0c508708a8e3f706acbe4a638e8d2a9db7eef2942e59f5e88e91c7a0b223e1d8edcf7647bc4352916649ea30379380bc65eae54b7f899fc3201b35a8cfde1d8b03d54fc8db66b8744c49aba36c57b7a76c9910e76e9866ded20e2c07cb8af22238ef202e2932ef4ca0133fa55dfa07fb42eed3a27ed2e326fc769593fd3a6eeba71e78cd72bb00b0fe9c07892a6fcfc574f51f72ef449721c0c88e60b656291a8ba80bdb44737f556b4fe0940b3264e1cafe86e9324fe9d0ea67d48ef8bb0a29b1e57ce6c5ad48a948a2c8d242e6cb9481ee08ace2d9275fc9a08823688dcbf687f85379f00e4cc645c70690037dc9ae4e34bec7c89d2ea269bc7725f0648cc46153fad824ca915f66aa1166e134e0f698438432e86bf8a5f38bb2834360f755e9b81d5b7120f2335b73f5ef1c737e79c09f1df6750e4266a1cd7fa1c2361e2d101cd064edcdb79853acbc71e797ecbea899bf530d3c226a36f9e5dffafb290b55e65ef014250de938a392a93b3001bec3723491941a0ca3c46519f4db58902fd01b25a18907c6a72cd4043210f966a43f5493222e8a9e9c61cfcc68e274a27bd08e13bc7a78eefadf233ebca20bb0b0326e6a4e56825020f74e66872f023af8dfbff24419ffcf2bd8c8f3829e9b85ee6b57227d73b4997dd6296d39ee0c44e2a32f82268b69cced9c43c997d83c7e2f3034d97da1652d63b5c47614a58f931d472f14105a54613f4785cb8ed5aac7e38f189588bda77e8beb8f3ec203dc2ed8f5bb411e94ea5d6cdd61dc069576f00ba86d42b8633a3643f94c4b636b488b1b3992d30b013d8afe5d02d53049e4008d050ce630178c690226d656cd0c976dd200f791d6cc35cdf998d79f8c29e5c65d77da5897f845a55ed19d01cb47fd6a90543be64cbdf541b68b1706abbff1260f8c852c2b5480cea5d5213d52033ae92bb4abbccdb1ad64177a32e52a4741f18231e922f130568070130f7a498e9044c82fae4254cdfb3722b67570dca8f75e7abf6933b5787e47d9b801f88288e6a48eac1b7f48b746fa87ae4c3c547650a45180700e7d150fe2354d0be2963dea8ef63394ba400784f8c624c6d1a22241a2f72845de128e3303ca64713c4ca325e709061a64b131fabacc865eb4e5df5aebc2bdfcc7cec41910a10829961741b542b9b21ab6ee9986267312d4c472a82d7f2a03decca7ca090e133ba5fd9732e06dd9f0177e09381cad6a2aad132ba2cbb413401f9cda9c85cc0d5200b5a8c2d6fe03c46a59f14014d7c6e879ea4dcff21b9e0e977e2abb3972eb73c3315ce6df63b179d17bb2bb1e383fabd2dee662580d3601730e6c61da7bbe2621304fb82b17899511d632e9fde9cf861942b7d85592e450103804c5ef2c536ed6ac016e0fdeb461e12f82bb5d25a36e7064563ec27d15215e02499d1eb648d9b5aec5872970b3718c34383d0216f565bc8e5b6c8c8145c70244ae24b826fdd40d06a97244bf71700774da6940d2ca3f267bc5fe600cbe4b38a1297fc90d49c489681f3e3dcf0398d07cf39db88924ec0440be30af248059250d1dd9f63699196ad201e02fb07f77699f12c25b923d7f8ff04174eb0013b4486ed7d339d0251b36c6ea80447e99c0df40fb1dea487224fe7c6c9f649df8d63ea8ad921f40119c884fa505424ba05603030edbb3798507a6180ca5b34420600a054d30ed64fd93f84f1b2b461fc2805f360b8ecb4d41d619d5c6af3394b3d6767849dde3095224c24b89766b4c7162a089ec78fdb752cadfa1d5851d7cf6582ca425ca0189b667399e842460b57288060adddea16ad8c0ef1764186d209296d5102f717a9b8a3219611c68090735946bba1f46cef2f2b11b8842da39813318555ac6b471ddafbb09afb0eaa5b06097593be1b6de676ce9941ee090dfeb1b1d2fbd572e9dee33f8a85e8428bbcc262db6e1d5d34723238dfcb64acef606c74f56be5b90fb2396ea39e388f2633038b8a761f82c29b0e66e63b99aac24bd7ff33580706401b9c6c38ed5244eb7baa18bc5e115701b3e2989fe0d985468fedf7869cd21c6accca57af69455a4d4abcdd7c2123182d2b7ab0e94aa153b49186ff8887714506cbff2a1f4684bea3f7c00ff5440db8f6cff3116ef025ded011a66c1df627ea675a028886e555da30f91af433e14a692890f6fe7bcb48569572ec52cfebc063e2489b203c379d8f3786324a18a8fb7808767f5cdc71d0468dcbaffa53bb2734786a12b09fdf77a2141f3a2ea3d1e783c17179117de2313a93c9bb2","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
