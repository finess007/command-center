<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c409ccc8f933c39649e74463e465fced6a13c4170944babb5aacbe100d03dbeddf0a849133b570ca5633b0350582f48b0e6c21873e5fcf415b6ecb81d7f68a180577026f540cb6b37050b2f10a890f26ca6e3c57966edadd251e70ad3debf87d4ceb7d38019321aac944d6050a739fb97f8cb10160e8b8000d2a7a865bdfd14e320c550faae0691144c212635df2373b47b94d545bcec0e284c25790ee1add9e78d546eea118bc521a2bf6b97486b20599cae48cf36df0ec93d0034f21c21cb34dc83fee781d361e5fbdc02eef22ca5f9513449d88ae153eea2da7d2e124ed52d8c9b27b58a1d0a363708dbae41d23a2dac1534c0a49521cd51b341f8d959eabde8629e189ae7908adfbabba2c6b9111a6c8d1eb46becc02cd7349ba7b947b3d4c8baa82fcf1f87fa03f8a27d7d77dea41bf36a3f1dc037cdaff4629a90b528b18124bdc038621acd0fae930134773aa62318ea296f78498891cd2e9d6572d4b33d639a46d858e903d189011eb819af4dc1b18819b8c109f85a1b0580e4eb8d705ce15b796d27060a54f3f912b1888741b9496d8c26b5ecdf9ad631a63c1d5cb2ab148265d9b62ba83b442a24249f6c2fe398c981015c0c5d87f83d9d3b89182a375e16b25eb4e124609f3b80d1b2aa1b500aa30fdf2659f5648bbc62dae2975268697af04d9548de732b1b46e05e58f6c6d918d27d3aa1b7bcde3cc7a091be4e711d3c7974bd307a2a026def1de39681ac8f07f7ece2c52723ce25875b5eb7c4021a098bd81986e00b32dfeb4e4a2042792be172f2d037e6a2a8702c5ab30413cce15894cd13aa19d8c835e77f86c071abd9936238d945a18cfc2bf3d49ff271e61e45b01bfd1108abf0c3a38e9a82ee8251c615f5d86e6d28b5dfed19da455fb70bb34834c75d37e9c93864998780858e1497b0d3785be9411b261997126524988c8cc2fffed26525af2acd9d4b792a1ef1ffc4061e6152e66f1155cdecdc634f2df3376b272d1982aa4204d9aba71702f19d055852cb0bbaab96578b2824fccedfcd52b141d43e33ec4ced9bf11fec5eefd120ef45e7aeb8578a7a1b62f273e8300d0be5c725800ca95d3f741af9f20389874521acf5bca95871513a62ff20741c597b58160825486221e7691e77069d0c06d54ebf544fb8a99f8eca34a2a5d2eccb39699089184007d990a9d3c2655d229ec55ccdf9aeb1a7491937f3eeccea5e6095ff51b92efce237c34f18ded2660ec0ff7842bd6e445fcb0625676fec8a8c5f0555a00e0816c79601f0322b8156e3a9cfc39334ef0eb37c32250597b4b0092e706dd962a631e812a8ecf53966a6f1872ce2c4ea5becc4825a3095e282dc416e680dca49eea1ade106a4696c8b96ed200ce17a5380347e78f5fcee373c33b2ed02dd607d8bb466cb3d44f0047d07bf79a169e3718860aafba87c890c59a18232cb0d8ecd16b02c73aebf4a9fd28b2436b485782b69bd0eaef6435dd64616e402a66689b573283d093b1713989ce07b44d44073cfe32c974bbbfca40dab9dc94fc05753225e5674bfbda1a0c00f424351c5476f4188a48ca31acf2e9a50d4ffa7c03905400ed06ac2aa92382ca5a972570687c5797fd9e0b109c4c160e36c35930683eea2c3ed3fd83054f94f561bd18341c4072d4642211fbe6d76c05c35e5f98da49ed0dfa50276a5627528da633e15795bb13192564589ead4fc412917f6de779fd6b73e29bf11d76a824eced61458f5d60a762e875162b6f09521bdf87f12a4bd373dd147fc777158da62f07a7c9e29debe88f7a8f2d1facb1a435e8ca5300fc1b3c72b5dcd68e4bbef42e728245d0abe20769af71619b2489c91de8ac1c6c6ede80e3be1ef087db14dad5fc3328fcde6d927c255121d0f32a59a503b0ca3b15a9cdc4010f0ef1c2f562b7295a5333925d22485b7d4019443e22de92eeabee30de3a13261de4e57a426f360c7785237af4c4febce1a2abb35d7284528efe98b53709acd7e85a73d914deba5dfde96f10b9de645df839d0968b6e431f1c4e6e94a9952dc6d9b74239655bdd84647cfe86e679987efe28571e3d694fa7d5da4b220d1d069a0959284daa29a51e9f39a558d169a6b5064d6dfa722390fd27562abfed037b71ee694740c10dc5e8e72d0cac2a76d2bbf37fc817d4decd30be6e56513e1caf2ac879fad1516f601bb8ca97225da484b943aec8d0b3d595a31e4ed79c4b6c625d98aad7f7b1b555f550415186eba41d8d92cfe9ce7041fe921207897f56a01e73826e1d6dd07192c87f58b6656490afa3e31d4025ba35a3dd3b1a6f1b02c2863a2aba2ee880e3156fe56754a660a5b351864b91d9681ac2020cbd6d8e1c3a03873aac00bf359ec6e995bef52c341cfccfb089d7ca154e7fed17025a806628623c752e6750b1a34ab37d5b59918bc2b824b14cbc58b7a7a4a2071bfc8dbb8bcfffa3540be6a22a2828ec23af044f30ccc5a0247672820f247f097837f2dff18eb3ba90647dd08c682e3c955d07b7199d10821173a3cc268fc9f9aaf4ffb454f566c5fa04403fa8d7bae1883d7e6fe32090ef54b490ba4d1e6a0609107bfdbeca0c5c7dbb7315e784d9a91071a2e9791164bd94795aa7d5e3bbca6422b01b904ab950d692627e0c8ff858eb729f0a52e569822189850a73fcc8d095719421a22a4e707df80422af235e73357c6c1be61eb3d431669b6e45e68ee8b5a331dcbc98e9125330ac08c81310453361bd326d66e0fe00d715f5bf39e56085311e05f800958c1877cca65c1c0f21a792681fe1b2d8ae0ef3f7b430db90819b04abb4e6f1422b7874d92b80566327076aac4da5cbd1f4918bdad08e414f422676ebcbf51f39e5c620ac6e9c57a4f6f6e163ea00315a23390f59a339caea589dcea153a07e5018d8b4e2b950e7f6eb9a20c3f152a6224398ae182dfb847897603714aeb989f093fce96e5b651189d9b27694504e2a53dec5cd1133bd2a6eb7ebc673b7abe07c94670cf169d9b4f31e3bddaf31a74b4a90a9fb40aa5efd29e63afb69f1e7076c3f0c4a2d2e635ab29f987d889246f8191a76955ff9785bc074b6d2e838ef4b3bcb73a6e400a9c59f36142835d916a84f4304ce4b929c393fe7157c0ff328095b6ed4f0ba8504b46b35eb3dfb0d6e9bab6141ca74b27ca71c7071a7d39d245fbedaf660caabc10a10a67d1956e32339212c709bbd64333cf051ee9fa5f67a42734d13f9873064a79d958d4d86dcd99596540eea8f50e947a9e5aa2fe378dda62639b224e69afdc5964b8552898e077731af149b8f0d9086998459392beb5df054f4e10cb2a91b14bab2d1b559096b51030ab415e6a47379131294300622502be29c59e198243d38b916086357b6dee7ec6b788a8d99fc93324d6f57ea55c56ab9fde0adce78be282661a388a86e1ad8898b4afb628f9382ebc71d039246d66f2a07eca2c2b8dd08bf2cc3d1701d78425a5fa859d61d3c899e77d7da459c0d21c1a2e3faf7aac65126454b797a7341ab8a2b9690deb51a87baf2947269cd4c8496c9e5d383a440ba8803b862b1aa2966f8640e6ce3c4224a9cf884eab03c13b56535bfa857f9aa2f7cbef2546e2e9c6bd62384c3b1cbf15c22efdfeb674a67dd4e466db7661800de91dd1861645182d3334bd245ccfb6033765abe25259b5bdea70ab68557127c681dbac108e81b3e88feda2e1eb3ce2fa0ed49afd91cc7757f06f91a4c9c1c3c260497d3d69030cd8815af4955560cbd83c72837c09310d6612eaa9184ab9f08786ee464e32678c005f76de62f6a9b2f981a50e3ee7bfd2f8232e4602c186b4531296ff6d60c4a5e31bbba7010e01b0e06537852fdb6a2ec22e662a2b0a7f5417c87a1b35e7f6d19b404a82dccd338a3e4cc075f457054a6aeca35584bcdc4d4b2927db2cf5fd4703c9d96d6848e3ec44a8bea2309e643ff75ce383e17a9f79e2054e802e35088cf492363ff64c2a6af1142304f180409e84008a9c612c2ebc1554f64b85070081b2092e74ec3795cc12656a7807cb71c0a2e671836600c491267bdacc78236056d324458b435c13f957ca77681c37dbbea10b55e6065236550418d7d3e3fc470ba0610bb7c6d2d834ca1083a2c589b0fbd63e497fedfec7531a751682b1c54b2c2036380069f397d4fdb69d20f2d65e79379e7ce1f67e9cc4b9141c1feeb6f6d3c4f066610d1bce9a431cfdfe9e199fc2871696184999ad2b89c364ebc37e8dc12344fa15f00713dd8d9b4360c2f97ca2a8e68530e45a44ce591f411a19e0e5fd6b1e574b315a047e618792fee4c01bf6855547615985e726bf7d85456a6d9d0ef1178886455244bc26267f4cb494f86eb702deb7423a7a8f7a5594a5fdb1fbaeba2df222e96ccab66c75e2dc88817860d66ab91c951e22a52e30655473cf1e2a132c55dd59e46096e5ce4c9fb7a97fa44cfa11a42a2551cc7a4a7c20a64ba383a2db0556e57450f44478c56f6ff916d7aeefb52e4ae8f674992a5fc9f935dfb60583134d73a239df52398425c532fd1412970a7f714dbfc66f425ef3ec3d642a035cbf6cbdd4edbf0e49e4e9c6817c2c788a506a48713b65e89f528e3d42c7920939bda5db1a5dc998b87a6f3ab308695c02c2ddab20799c56024d7af7348ee92b5addee56764f2e447deeb00ca46a0959b9eb1262fac3f7eb0872a0d8290f0c1b349d2479d6ee57dc3a8a1b05137fd4bc2d397bfa4cfa58fb5cc33912d9c40b7ec192703e77b6e6f44a830336158af80778c745adbc358cc461e375351c16205f0dbe985c47e13ff51dac8bee2409ec037ae90a8bea9e15577e59d06539e18e017d29983cf5d1e8c45cb7f5a0a7d0a168cf3fc960f8a997820062fcd048cc64c2d255fbc83fc0fa7fdd5a3acc203e454bf2c012905431724898513ae8698f3865681b9ef65905dd1c690395f1d93c8b50ecf377b57611ae039348da9f7023a2121bc69c51a6972a03e96dec83e1acf3aa3d26e77731c9095547c5f137e8ca3f9d84634485d7d3ba652ae29630ddbb690a4470b581977a9d365747f9d3a68f0e9c52e9dc155169366685aa750f9fce37389ba921ab9db71e03bb45a399ea5929f9f0a70b4965340d83a02ac61de94a4966af1241b1518a7736a0d0f617efc84c044506b5fc08a6e9f4e06dffd1caf9d3b36764d9836a948714911bb468416c664b3fc835e628a1d106dfc20233ba46868c6850b75fb82d094c44fafa9db1750667281d1cb730483dd140530a001cd14fd950ad4b9028210970ea766e49e2b123b4ad51a3e5c8baea302ad839e06f7f93b53b71ab7391314a8141b529982dfe5d342cee2af7e49472329a4298cc8a60da6ae35f944961b4c2fb287bd56ea4342855124aea962b6914c98dfb91e8e4868c43049eefa2e6d7395d58398d2cf153d61fd4f0caaee53ec26a7e5550bc07a46ae36ab4c55737bd33c125e86a02d53586ecd0e8b8b8c3a9ccc9fc9a451f6b5ad5a93c9d167d539a61fba3a7fa18c60ac657354ac0697c294911ab5a90bd44d67c37500437fea5d5c14b0a1f0584ca7cc5e2311844b983e7836f26e255d68bc3a368a2eee9f4a24b72ac398e68b94cf75b47c96160e13c4d1e43bf406f3e1de213e6a3770f9f48ff61d0d61814ea17df6fdcfb6b1c0fac163118e83e1968b7134c725ec8a9462c91ffd400574aef7d6c704affe4cdd6643d4ca0d537e4c064e2563f7229d26703bd4a7cd970beea54c9f17724bde77381f2bdcf5c1620910a8e71edf8768bfb9d0975293179788bcffa4bf7884424789d87e388e3ab90ad49fc36b4f1b17c30cd4fb0dd7d3538e0622b0b9d06c8b47b20052a8a664575941c636c66bd67357f9fafed8ee3e2bf6a88ca2ae4645e981a19c0fc0b944bed0e2c3b8f57d29dea67bb80fd69ff4333a5ad507fc215a1dec9438eb06746b3b434b06b102260945dfb92d07f16a28bbb476f3265357e813e74c498d17e4909eca75329cd21c1b26615f7151409e75d168abc48ba295248393e347e662dd9ae0ba02e95656636bdb5276650168e2580330e1f95aef410b66ae9b57bd23f8d3117660b0e96a3f583a7dafcf421b8b2ace64bad2b227f97a596b3bcc5a42c75d41e47303de6678ddcd861927199d033165f6652969d3d08fdf8f600c8ab397fac53f4bf4caa9ac150d8cf6ab498e413c55949db7b722d44f9056ed6e834005cbbd30fe080de2b9e71ce03b3128af36219aca58c8834fc9d041844cc2d7cb3c230c507670f7d04fbc61ae28fbd58d5adb6a8041c278d1c8a26db26396e992c5437d3aa0abaf0a296f339b336d44270f8c0786c5db1a8993af95af7cdd9d982fbeb6318ea1e8547af9bf8ea7f1b04d058cc7f5604179c82432c31ffef7fe557dc806b39017f205b9eed0047f275583b42410a6fcfe6631830b40d0d8025e8873780b0cefadb976d5f40a8f7e20ceaceeca4e0ad6935278ee479e3051ad28bb4c5b1a530ed4edaaebe3869425cc1a608c9bc6849b104bd16eebb11e0839c7a5537eaad99c9d6601513acef72ba0855400f44b2ac4e5bf209aa7a17a488aefc18825ee943b4bbddac046e329c8a47bd059d8232e35318bad7a6671f25abb93ee77b7569fe43870c4fd816baa5b2dc835d440e85eb0d4425dc42bf908a73f91863ebde15762e30931df3f094c656233de003bff89497ac266a170331d3e1be1e3929b454e4f6b53621218532f0a307f97645db9c10c2fe7b6ef3be75af3ec7ac2eacc4c840bd1701f161f21354692dbf033b84d2e5f45482b9ed151bb39feafa13b56c286f596bd90fe0883536d783ba6e566615357d2bc8f4bf71cef475e68597adc49bb7faca185f48ac57fa1988d34700d4ae2492679d449330a966febdcc12b063693f72449170bc111a4c957cd437cbd4c95ed3c7cf54f44875970ac46cd12bf54def3ca6c34869c4004f69e4d8bec4bf27fced6b2d444821c5faba7fa5d0319cccdc8d7c2c31d30923a94b3efa6f712ca1a4b89f573ce76308c2bbcc0b9bf45ab48b4a23df3ef699a6578cfa902b2042681e83c18339be22a8880cfbff9453ba5b4de0adbe18baab9ce92412964781401eede3eb28e2d25beb58d631e5a64b4f29d435159aaa949b9b6898c46b1e7a06a3b5f5d429286695006ecaf817f266421886d890c40f5ea922e530b9ea1ccb468cde8d0d669adb667a5802fab3504f4fe83809074c784ad5693cba7ca27e0f2e9f52f1a2de7a2743f0487d2073ca05d05dfc6b729949db2f91ff9a581184360394c324db63d1183d62924e596601e3526e1eda917035ec6c16b4ff0e8cc97ca994d4233a84bbca2279762b47538decb8b7a4382f5c9afc4dd438926266dd641f473726338cb5c24fabe3f0d17a089901a6a1e960ec8451a98cd39302aa21e164978d017c481ce093a33443a1598d9fd0412cac01ca05509f2eba94a4c2e1413432b8c4e581341324c74c1c9870787a9e4b319dc8114a5f67640b8acc524efd29ba9448704380db638bb47736ef76d085152246283c137326268aa9061446ee5195c120d95506f771ac7a598ae4847a45bfa5d9f76b808fbb79e6d66c6ad7f1db13892efa379fc4af59a3bed2cee187a45384becd8c167ad9577c0d3413554fc017f417e613f85c2cc911d02539f192a173b8a72992cf3853ade310c0df4c64a19d83e8b7c6c08584b97aa6662eb1726c84ca47e4bf0c74cb470149b37c735a9fd8a4169d825daec9c24bf1c15822fa745dd68583337e80377da0041166aadb91bf560ab2516aef1b7c00f11185b69b78158cb7832bc3b21920346599d61a6b6c4a334a32d90986fc2070ab70752fb39884b2db7d06746b80abcb1da570bde627f7fca7b1898120ce2673987bc79088eeb73fd83b2607986dfd74621002ccea48742e4cad7c0be3f711020a538655d2004624a13ede115a9ac7717cd64e99adf508555f6b9525b20d8b464562b43df381a150b44faa245bf892cbd630c24f7a85485f0c56270b87c540c406336d2f844cc8688e667db2cc64db52418e15df8dbfc2be970c86cc45013bcf4bd53797971212056ef41713dad81973d8d9dc539e1734ad898dfd066bd81c79539f4fd0d1203ad76eb33b37bc83452140a8a5497e0bcb4e1d2e9adcbc401e17f1d7774b3c9b7f835031714e5f8736cc4627bbf1b10266235ebf91e3a3ecb82be77580e7cfddac91bf42f9ea51379a306531775367a11577ecf26b4dc55ea6da28861dd491d4fb3fc78c8988717807428fbeb80c56baaf4e2926cf6c5aa8098969bd55925b55e7ce62de235e36a7376f0f0f3d8f475e8d12b93d27a0dfc7aaad109afeadf64cb24e8645efd9f9dfd24f2c5bd99183f665b054b4852d2d290c2c84e5c8f46adbaf4e746e8e9efe10d3b07290b5e1d2e000e308d1eda3441ce7c7cdd3b3967322876e7267f9fa806a747c8f494f23d7036fcdfc3f8b8ab2e055e10783f9d0a3a29ddf839f473b05216f774b3930adf1d6dc5d99c4af4174ea8e38c999712d1851dff6b20ae19ed68434d48d427846b7c49625214bbf03408b34332e44166856502cccfe8ca41aa55193b79ff6b0a8fc53afca53bbd49c10153ef5f2641df86e0ecd0459a04f31e182eb2c341857431f3705071d9bae9aa01c7ffd451cc11083c242e294c2291bc56a8461cd228b4abdad66e8e15a933467ea1e11d0895deba9ed39ff479d4b06af26df8251c8ed76a69ef6c3caa631e6b0dd6088992a31422ff9d3544d9280eb07a98dee86c0694180a348ad755c493cd18a8de7f12b8ee84a42d6560bbd8269531352e90b737f7dbf1cc66e9b9f4e6e3f7f47e92427b2855c8279aea15a75164ce6397cb941184dfb8e035ab8736ca3532b93b7f10029810d80c46920fbe04208e4724e1a41c56abe0215eaf41cc0d13bbb8b40c926495d69cf966bd9e007a8ceee552fca31bf3de30ef343cabd4bd74d3765e063b702c31342fccc016ad45451e85b3bbe807547e1ecbf3d5adea07f5c88c2e8d7b7c8e202b4035a8fa1945754cd88f0c5c8c7db8e7be3bf2f57cf612c4e8b0a7f2f6973c02babb8cb9b3e9ffaa09e1328ed8ea817446dbf308063c6b37b6a23b58064cf887a3ed78222d9097a073f93d2cabcbee0fb80f735ed56981149b9cb631e1d4551a0c7b01fde8d1a5b8f4d424b65f13aa66c7433ea8f90ce481e88dbcb649fe2dbdcab01c0bba7728e8a95f80a3943b8310bd16b7a0db401870a62af75e0c1c5f5cdee62cd3fdf8d198ea4d5c67d76fcf7809f710caf3242fc8e61c5d16a8469e7e7dfbcba13f26a85c06bb6a8386a6313bd7315f73f9cd2d14773d0e5e813b6f13a64ca02e15f8285c30a7c31ce2cf14ad17234379ffb6826d37661f26218942d36902fd66c49316ecc04e72266b1c21e1f40f8a6d7d7d6f454156cb84d1fa06cb119e43a3d76d0479a2941c63b3ebb38b885ad3e23707a16d716f5c9522d50e75de2f42299b2aa7ad1001ae364f38d2cedc54fa7ed2982296dea905c8844280afec82c74ec12331ab71e91e870940eee3ed7d6f37cc63c00a5bc01479022b999977756ab29b5b6bc043a1460f0be368b8282dc3523fe8fe70da52fea5204ccd2b5b9cf97cad1fca206b13ad38ea59c9906877412a25ee5e004af3e4df6af28d5938e7f955133485afff79ad45c23346b5e545cd18a637a8dd84881935c326080b15a33bd1c53ec2b64cb2a2a9aa7d838fc52a34ae63ded26197aa50f204394a720ee32855e8c414b3112b8c1caaa5dd76e2b2ae5a4c10f7f0f86cd80bcbb7b9d4bbd7efba43fa2e33c4f7782d723f32bf773115bc3754092306ab344ee89be64c41157509022542ce4e4de77f53c633be74f205b7fdaa1572ac478d0ae396addf978fce105c085bfc560b6976cca53f223ea8852ab9018d3f4d44d859de3b60243fbc3c2bcc8863fa07aee02c40697fc2c7f7c4523bfa71fe4cd7941457bb72d64b2428bedad419c93e1d49ce18536417fc30701391778c2efa88d1451ee84af3c6d23edba644fc4775a4ef919ea25109be32b2855dfaa9a961a2e8bd5c2fa4b91cf3ca3e6c980c5fb9856f5973bbff27400b03908d8fb5f1dbb1b58b39b58e2f4c0f013a1c7b6a53dcb10f740c630b1c485920334beebce637b24bff017122d335cd657e1e9490a109cdce0d2bc3cc0d5646e19e1de08b882b98bafb3cadecdd0367ed46d7d6f1e5009accdf709a77eda430730eeb47e8f3cbf33eefee597ec1a736ed3f77af1975b1f81307db4d2901796bd1cf9323a8e13259c96837e71f073a25ed6e08c223b63d224039f5c4aef70fbdad937946681bb287e692019d442ef723a073adcad9b67bed14beb0455ee98d9ebb4616c9ea16340b77a56c07cd6e693b161174e80605917ba18e831f5f39fb30699ddac03f5b0465b53c6f08458e053adf6866ebfad6c50d541073e79b44caa16ccbec40758687f06d17ca9adc337a78d4645a817d0c0683021d712e01954187b3d384446d29d530184217b8a52b40e6ce3230eb7f439de00e6e47711abf33652c2d2accb6a2b566b8bd4c8f26f2a7e5ddbcb6756870465351e9aa05eb483af8d01d9cafe20c8487551ae3ce31f19f55b3d377d65913a97ced148cd702d82a03ce25dc5667ddc3d9c8072ed75510a3c3729632bb29e1df185a8105676e81bbb1dd20a2ba8970352f768f38f5a344b7ea73829c19e4fd927bebb0782279391eda949a3944d47efa9f773564fb22cac6b6a0156d3f241676caf82af08d2520d7c0224812bd0980ab2721398f56952907c8a660566086d2f07db7b4f893d81aab9cc2fc7adcecc7f77896a2c63b831570e3e0452a2f0962ffbe89375da3de92ffc065a84c8e7ba23790d5fcf47a42a4e0b2247d69e64614f9aa22790595d65cce033056476df272045877c5f835671dd7a5fc61f3401c7526071a958d99acf59d10bbee5e5640d0b9a078a825a856ef30796206cb1b38ee10f0e93bbeb02feffd7d6d28c8b339c47722eac7e3754569efcda6b36548e727bd69a30d7d921a67440b7f6564860e64f30952d7b9701d014e36f4f7b644a8a4d98e72dbc36eec14f70d80aad76e5df928ff10260f8d0332d25d94eb6b1a5a4f06ae4a41cc6a74aa9be060287cddf2eb6d618afbdabef5c377f2b04933d2ebd4d67333a35b0816cd29c8684990e95cec0049e6cf5a0a86376c7a3aa5413c79101f2e7cd267dd82822b385bee05530d8ad9fad2773f7768175ee2730f1abd6d5dfc43d565aea674b26045f4c0666459768f1af41a7fdbe0d22c7fa6405f2e909f2a87c1a1be8418ae785de085891c183accebb389f5854ec4c7c95e607497e404f7cf238d6871542c0504760fe972e8f7bd216c8d204cadfa0ef0090b67a2792fb633c84c1189ba7c2ade0b1c69666c713e0bd73e117ce4d19113c6fa39ae2bde47bf514cd4daddebae978e69bc30bfe11d585abb9fad29d8c2608176033f30b498993ba7a19f3ad45196d009652750b407e8ad370798ffa6a16193c85f03732fc03bc886b4c6c6aa0577bdfdc9487d25d3bf466f3e18a53062c39a3deafc2a96782f0bcff92c933d939c894d999586a807cb658299be3fd62a4a6e0985b2b441086d949b1d5fb00f5a959c3e3e34723a635f7b43d80dddacce860564f4211dc669b28d69dc45da884a06f80983bf2a1cce3b247c5cb9b3ffbe8db57007dab84da403c8a40e79ed345689f2c87c51d73cc6e5622a8bd60ca26f6b4b30b39fb341bd1456f2db90825bbeaa5d6d01ed564d67b1ea7b44fc57a3bc72e683a8905d3addcd0480e8430c25e2a290756f6d1b2688d8125eeab8737dc2f9c64a6a8fa5cac19149ceb84210c2ae7a981218595bfa332e469e72558e5d3b56357fce0e2fa6a2ef50a66cc704ff6defaebdd8458f01bc54aee1a3f0c47c8a4fc8817a63a990ec6506a50e17264948f336c871fe06dbb008b351c053bddf3c928935f00670d9a7609a89eab0817a014310907c78c0292e344c15f5cee6bf10c6bef3c602c77c0f630ceb132c50c94becbd9e6f52f67444d0398c782a958fc1c5087cc15a4698e298b89f7c3089c7043e39781c9fff58f0c1bb947015e6d582943a26c4d90d87c1363e853a62f086a994b1acfad599833b94a6f1f0713cd467138d8ecab8694b65a9a844179c234438bc5a97259f6663908bd2aeda9d450cc1d1e89dc24c86012a358657636b43eeb832d08b69fbb4c695abafffaf610e93ee103403cc14b5d7064345fdf8f6d365e64cd61908635f9673c38e2b579b247148180f3ea195578d5a59be023eab5e02d21eee9a25a765c53866625dd475054c6b6c2cf00a529b24891cdca69e00628b29618ee78712e4130937da3ba6208b35db50376cc2f3c4204f0fcb9c1b84dea7bbc53e32787ace5ad4d42cb05142044b3524e81982e17ef668f5d6529c6367859cae95c0b06184167f3d880ea78a823ba2bb0c64a2beaa2c6326d9aa9cd15ebf6dd120834c56a7bbd22996186a1b6d9c4dc6e91f837be565510498afc44e59fe6313f7441b548aa0440c123e827b75674ea710470738920576af045570fcef22fcc33d6ccf4f7ac27e1821d31a440e3818975b5af168739ca746f69ec0444ddf66a00bca4c0084c4c1c24c531aacc79fcbb43bae31246652d61e7d0e2a077434879d102e0547426787553c9b58fcceaf91bbe213ad49b36df8cbe7c45c25b12f6df3eaf8b335149dd7dd7421bdc1972786ad720f79ca3450ff4d9736db2333d7ef0830b18c673c6e82ffd2220baf12c66db20208fa9712559474aaa3699fdbf362d3093a2f1e01ae0ce85538583c969dbc8aceb78a5558ab27977202ea4605455ae76b2ea8aa843454ba125b48aa717b1130502bae0e60095701bec3966b8500606fc6a3b46a339f6cfb160b930bb6ee037f3d49bd6c156f19bbe01d45b59649db2b918abdfbba65961efbd3a0138c7ac085ff427e3dc46f1505fd40897150a21c8f0319fe3b00ec791a9f7632efc4baab883050629e47b811245f9d723a779e14a49618e476c8c4ef517eaa586570b144e30a47048a72cf2a93cf6c41cc7640a8c9145bb89879d83a02f518bca4813166ee0d43d0b60770ba16d90206c2fe5920909fbfc77d6a8417739f0490a18bc10f37366887522eb75ea5712ccf3dc0e5ca13a95084e3cef8305efde83fb6bc4d7331c8b4321a108900b02ad840438f3c0d227a8f200a5ed4be151d9805f494998561147e899c2fa5d460adbb2081d0b5e97a2d2d9e9f1ccfc4c5ce71e63cb1b84c53f9d7c07b23d1d3ed6f213bb50537db131f08bcefe9e1d53fd73c86a7841d88ac28cd17f0730f358b55b28833915ff665ff39d34d5176dae5b75eacd688ad7e38d6a9aeba07bfcc4f5bfa5f75b04509b83f8e4c0cbd57e50dc4c9b7a95ac72671c35f43e5d0eff0908aa0651fc9ead31056c076b67e1789376318fd62ae1395745c80758097737f2ae48f68e21fd2ea32de8f786172d2f5e0bdfa8b9cd159282681edc1fa8e4fd9a19a445cf9f65205cc4b553294ada69044374c170fd6020bad9d03bae7be66135878f4999ed08dc58bc0bc9a721e30f28f36510d85007c71bb8ddeb3444a65e5a86a0cd04a262ec6bbc25ea0ded195fc4a29a00ce660043c1ecb5b326614b01bdfc90c183017a7ae7b28880f9c6d36435458701eb2f015ba3e4eb5cd500009a094068c0d2d4c8850cd6dfe3889ebca39606834dbc63455e587ac075b39307c71a551261acf5bf5955e4611b16fde942987a206d46ff911238d41f4091e6f0ad560a3ce33330ea6c59195052e61395cb99710297b04fddfe184d729427fa222bee9d090734ae38a9fe7674f82bca14d5f5072976ad828a26c021dbaf49b3c3674e41480bc2c2ab58029644e288f36ada5291340fab9e24836b8106652e9db14593894145cba90c9c65a6fca07f17f0337d8a61999aefd185f3934f51c6f0275b13ed9e15e3a85ab355507a9407a3ec0a39fa5e8b4d477cad0fc04f90b56fd6a45bcf42dde7426d349b86fcdce6e5458b4e4cad7947564fe5584bf72b3d685df033997cfcfd14d228d2960a5bca70d0067d368d3c82f451d5d1414535cb4ef598941640278627987f340cdf1a8877f051e03bfe3f19b68bf6ca7403e5ce210f73ac8317920921bd113919b52a4aa1b3819c99a85458879022412a30b1b1a20dadf57819e8652ee6b095b734c242974cefca4ef9873a0222bddfb0d928dcfa06cfb8543d6b7d06cdcdaa1c16cbd858f692c4b1bc982b719a40e98626357474ea97bd29c2bf6f5efa0e2d840b86439f77e0ac40917ea30a1f05162fdf15132af79fdb80cc804bed3972eb332662c5522eb7693148066e6352940089d0308f05b1674a8187b1c7b292e4244b7eb22f3bf142f9db0ba3a78f06d345fc4f93096fdf417ddb874109b604ab90dc19affbe6b436fba66c43ba7e3","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
