<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c9962c2f9d688730fbe98666c4b0b7070c35525977ba49f0bcab0423e21e794eefb5cd9e4d2089781e3faec0dc97161883b3e7e6367da97a836e5791837e64f7a1b2427be7e8994effe9ec1d00bfd4afa6f3a093c007b11c5113525f81cef42c61b9299c9069555503df8e0c12dc257cf4f405163c7e7086aaf947fad08ef1028ef75493966279a438b9f8b6938bccdbde67c2957fdb93a15c5ee8454966d0f5f9f9138a6e235b881ab32b0ab5a5e8bd3f82de5ebecb2d1cba28f5e932841b67b09213f19b05f0f6e6b04a1ed39d976548dbcffa46a34f7c031dc1d77f6e6f553cc879262f622e9481774252e10bb31921ab8da87bc6af6b5d825ed3c714ffc78354de26f0632e2fedc4c592a8d1bd3abf2b3a3444ed2105b1f61bf1002ca53feb21f751cde56659b431648693865936cd68c2257780d8e4941869dfa54f5ec13a99373eaeaf92e9f0107e7dfbb00b59765dbd5f148f8b4c735720d9e3053d991fb4328cb8533712a4ecc0031f511e6db07b6dc0193380430018190b654383b26236c9439a0c1b6893f2195a7065b86f67270b8aef245833ecf786026506331d9a56533f3eb57337d427fea8dd925f02d6661833018472d48814ea11be4333d3088b52f5cd0658b987c7d439a499760f326f8e4622c3b32ca761f0e713e2303debe382831d837dd7f61b5acd9444f74e05d8c0c103b9d1f98f6472f9424d22ebb46ea9447176ea7b25e6b7bf0d82b3b33ae4286f0f908d4b3ba6e5e5df0c881e21b2be68bbb1d6c4421b6df636e714d9cc5902aae5ef147e33e11e9f96a908721821a9b4db7b45b0c7225ae3f3eb1cb5394cf57f79faa5d92d45f2b8a5d8ccba2714d9e70c343a53dd8f1730a3e53580de3ad3e901afdaa7203b83138e3de4e953c5009c1df7971a9e1ae5808a15c84f2ccac1df6cf82dbbac3458581e2f22461367d7ef557b9aa0db4ed05dd9334dfce52cf71a42a0c41fcf3ba4d4f18d517231d2e8dd144d5f2a13df3ba5717c2dd8a906a9295f0ffe05824c400d16a2088d6975c2cd149f4f5b801e41a893ad4d11c6996e5b083a46f12adce6e089c682fee1fa90488fcc4ae85007791b2e185fd2fd1d8c7e1040a8baf4522744e2d0d6a4657b1100f22397875903c7e6bffc8a91ce1f59422e1890a68c833f70cda1626f97d55678ee27f27c50da79298d894e76a77458de27c1d5215a9073bc56d94e0d2156d0a3c0b80b3ae56449a6f9cbbb7a573a24a5902ae0bfc9c6b6d641365b5c93ce9b84fecc1688cdb9aadfbb9b4c78f940d949e7c372031e23dd98044124a1e0e4968800a2c99fedcac467930801345ab3092cda1db2fc88668a641a8579c2e3b198c1e19221361cac84b2520524aaa16a7d521ee2c6d10802b1d22efdba6edfed19788a8c63820d0333593b9098b35520a31e5c57e34fd751813f7b30ab29566e4f0afa27032674d21d06022fbb854034256eb6e79f8b6f1fff019e2fac5867057d25f4428ee039e56d7951c38cffd1a85d4b56d8f95bc1881e9ddf7a2ea6ed8c0223c9239da1cf2b2f1198c0b4abad3a5227000a943b0b91f457720c6cff2057b77a0de89d6dbac7722ee815e55e2e189a528e09fb5a7cc27a2bf821f3aa11ca2b9dee018471c86fe89da9d67d2fd3599d8865a17753956fa1cfb26074e4a6c6de4f98f0619f6e366949bf9df987200db704d6d5ce1b13c462dc86ce93cc45cf340489ee66b9b1607a7f1407f1b93ee37afd23fe6c3e9060521d5cb14dd4846e85cc3e7498961e700a2d644c236cd4d4e45e4e469ab2d79b70968df2c8876f6f36451e17616096fcdf71942946b2033eca900fbbd5a610f37bc17dbce0c189fec9b8633ebd2f3801ba8ad0fac64dabcafdfdbf7914659c9ccc9c03c12c7f033bf551d34d604e74bb1c15941972a567e11ca7ad254e801f87b92b8fdeba19ec54bff799b0eb24792acf17c598d79c99829ef9ed0f0cd0687fbdf8351488f2b0fc92e03150ab8e33add12115e189a1d5b74aac2c0f072ea98fff38b0e7275391b5180b9cdfea3790ed375e3195969de534ab41bda57b315d75c9b85e9b86ff900d1ca8ed6c4bfaa79f6c8b393d57048b65c1f22fd39ea94412427f7f34a3b989e135bd68d750578745e8bf29c00bfe4c50812f1406050131ce984372f4bed290d297895c4d784e3b5df1d70ae9c5ff353ed6d582ece869ac72a0d0cb077b0d144a45e24b6f6b57f3fda76d7b2def1e6e16dfd1101d688c658f43b23adc8ee3f7723b8b9101084feb8bea0c0f0c70bab1f250227a514770fa623b7d5611408eb04245af9c86036e3ad4f1dd38f2f37b1ad95feb24f65e8c97a97610160749c4601f9e3496d76a51c8f1655711ef00a1511eca0db32de743d1b32a886c186286802187363fa0ecc8489d8f499b9fe223115d60affbd34cba60122013d4d1427c0319eba00ff9104c60273f0894cb346caea21efa61566c3d0b5d3e4ad6856a0d4415acb49da24cf3dd735054fb0f16742628d39f82cc82ced6d8c885219d64854117ebd500f850714cf244159ba4a1e50941b775f617d4a1bf720fd08c2cf6ad3e9ae2d678bc79b212efdd7cd21f807dac12af5dd2ecd3ec02245f41260d86c0a6751c6007469c55b83e9c726bf7a6acc6b81e45e599c8408c6dd4a38474a49772de8d837ddcd44fc35df70abfeeffda24ccbb91d16fc0a9e985a3213e424fb9cd426ae7bb9e53b95cf685c0e0ade263428d14e196448b8df9beeb8a27f55384f8512ffac581724d56d50f3b72f85e19914dd8291adc9e0b568b86eabcd319c8a16fcfefbb50bde4dcb6cf18b13d4299a38bc6a0f85919ea7cb1803fe32621474f45bc6e77421dc762cb9965f9259690f6e8f9c634bb68bd0c59b872905d91c64bed09caf7dfd1d65af23596422edd22693eb8f02da9f757a090709a047d486221d4b54b9a9d2f3f9dc5e1445804a20c87c2b494a9b99cd0af0a33253f83a823454ae7fb680c45c68cb662a4615e63d10f2b0c8d7c90364958f53eaea62d8144ef455448adbb5b7db03c55ef8b3ddd8bd6defdffac708471903dad7598c73e56f639eb96777ba7c69a1c6e0794db84c18bc580282de217fd42687136886cf1887a405b3176620a664df48b5cf7f20aea284ab4d1cfe6bed4e3251fc6fbdbd2950242e5e86e70a005190c898a61f9b4154afad3afde4fd9932d35a5f67c1b0b3ad0bd6f63e180b680e3f2a186648cb73f4f4c23de3a35245bfaf0af5be536a963386062c8e908f92e323d5a6ee939bb0c3c23b0419f90c7851b5bc58cbab5d953ff9f43594d258955060868ea9e2ec517ff78c83344414554af6e9c39656f8dd46cb6c59a6be144213b8bcdfc87eb33227508e27bdf758adcaeacf06ab23020227bf5b063a5d18300d170ae8a001a704d4dd64dc69632f2f511909e26edb161c63af09af28a0b5557604c7191503aa05ba3f01352dc1da2abd992f55df331b342aeb45788231e5e52c470a26fa2b5b3618bca001edc26b52b5eb9ae565a2fe32c7b65da9a938385fb88d62c82bec0d95ebb5b1ea379c23750ba1e6d3de7365a176326a28355ad60d44e60cfb64d7d4be99c7e84cce9349105ca927a97bfdaaacd6c8b7282204591274cd0ed0746ce3414804f4384268ab45fa629478e6378f2a44b90d277895e6c6e9c6c0e1fad319dcc0eb4fabcd2b50c36efab2ed65a24940b00f4d89b5f21654b394c17a30aa5b6033d9636b627090c29a639b3382590ad094fa8206c351202ce384f68bddcc7e0749bb8a269fc737106e200ead298416eed6118d475c92b929299a17ae3b720d0d687280a3c04fe1fd58912185e07a87413110a37ad11795953e3d542d0dcf41290891942fdec35e745b204ae1e641a3c7c717d59b52f5fa3e0cf4b42b15d142e57e86809e1f43fd630de7e0b5fd56bee8f4776f073920bf2907257fe28fef34e153648944b22e9a658efe11208466e4e4d7a49347d2ef1adc86e18852e3aeecc93f5f69cf694ea5bf8faf822a88b111b60de13eed91488867604913588fd534c8e81e9f872f52cda7b4b766d6462ef596b3e6396081775fbba5cb94a5b8ad20294e74724fe742726b0e397c8e27855fb4c68555cda539c2e59bc1cb166123d975038f8143b809c43dcbdda13e50499c9e38f3ecd4531778b0dcf73fbeade79e184882c8e97dbc264e98a1d9bd5a0a4e642399257ad75f832d27d2d3a7264e638c9b35110005133be4015373ff65ab8b5dc847070cc62650377be4513bd8997fc3d403d01f936b36f9f184b7b870a7595cf662bbf9b85e3dcf056db73194991e142e5f854105a365ef24d63b67d84052e1127dd1091da30bda91dd06786dff9e2f67e38798781cb87415d2dbfbb9c5a821ec6dbea2bcb22b11e8b52451783cb883ffa2d5d270a591775f8a816ef72c88c4ba55d9aea338bbcd74fe4b691cb38430a7ae6cb404ec3e8809984a019831a8733ae7022f163f395aefd632f815b0f0bc9158b7dc3f8ede42230b160b4b9ac1cbf3ebe1425bf57018aa700111816db7570128b31436be044e12c471b16653b308c9428542f638b97a486807ff22a2686aff04d727d2b43043cb39e787a18eaa53ba1b0df86afe83cd596da34ff3a5fc59837ecaaf713fc78eab407097001d4ee8ef857202f95331b2e1759328ef31c1a984a8537f432a16c56879f0cb9503e4ef6fd408cb1c5357483d145c2d0e82dc1af4296e43c61e77c64388078fbe36d9cbf8419852b33285dd30ba28437f8d111c0740694ee90bfbd0a472554081979c858a6581f462ad8451880e616e58c7863c115a8984061680a5840f025a989cf61e980be7dc602b108ee626d1410a726710d232d75d5c14658dbbd43ef418e912fe0c2d0f57e30961e9e96fa9f55879c66cb563a0d7081c80859b95d29bbf689b21cb54c68ab75491e5889a9f8931882e7e47ffc9d08fcb754fdd7b4bf532f3e360589c912df9353b2c68129aa1241bd126e8b08e142c5af9a6ac4817c86d3fdf21f86551cdeee90f80427ff57cd50540cc8eee6e582009972ca94e0a7f32d9350dbc137b3a959ab4cfc196d502711fc6f08805e975320f6b0cbfaf6de8aca3b1a81ae73586e30feded535aea3f35642c4313f2cfc6fe5505aebff736d7f4b2551dac5e96c8babcf387430820a1c3ae02cbd9acd3d2bd2e32aa38bbfbb81e6bfa2b2b102ca9f27d03f207e2b32dba03ee1e11fd4c218791cd265a73c38458d811815313f11518c2b521d0fc7581629cb9e8335fa2367060c8050508ad7b21d7bdc49b86f6710cb096f335a1c24b2e635d105fa6f39dadda7568b7ca7a954f9f8a5849d91b2f5343a6db1bb6076bf8827b47df3dd17da42fc20029d1425b5559dcd6b9516a70263c78b6dd9a93f8f97a2a3065a80db7a556668e44d3d2d63b49a3f7d2aba914e585fa642adfbd3b16d1b8f70cee7bb66a45671c191be5468870208146a24e81f9a859ca42e7f87761a2e07c159b29edb0c3c36edd8479cbe069676487cd58b2a5a868c2f3520919a6d6a0f0b89a08ec42aca6cb4804bd3bc4919eaa5d4f1ab43873a0b9202d6b7cb7f4dd8d5fd1dd3942dc080676a8be642a74b76e1f97240ec1148dce68647d255e76ef72a69dba3ec3656ab28d9d8803770a300575881becfeb501759108a72dd56f0b362afdfcc80a53b482b7b2a73ac00a9110ba416eb44897fbffee6bc7d2268f9c81128fb310c7307df8fae9bb5719f4a024e5255166e595fffff0bdf5ea290dbbefff3bab45f8d93c796fdf36b106d21ffafe82af446330109010a60d64f4f5b5b8a02eeccb3629250aaf46a100025b5f1069bd9763f4e876c5dd2e6c813ac30363bdc9adb43d2b67f9bd99b2ede09e571311294cab1d86144609135ebbe993efc6c776dfb0c067a841e202cb41b698f8d46bd2d96129809fb2f78e2f3693bf512136617a38f017fdc6d7ef68e4705c1625c2aeec00fdf0ed18bb20b8e75d59a27bc36249a214ab32225286388fa81927cf6779e97175a4a8c53bccd9f074f6b38561e973fb501fbd25cfcdbeb1f5f78cbf9d713f1c0f890ad762aa888f5a05e2ecb7239c911a6175c078c850478cd750fa4fd39c88c3de300ea56e8745c3ae1ee03d5fc0354801cea8ddade13b4039b0dd5a4ae304e94de97606aaf5a46de83a3fe96eafa3105ab71a3e4c17059d6221c3825ed4238e0b5b9ae2ea320ac311018c68d52bdc5a198a3d6f51477ecfbe9c86b4b987c425568075b4972fbc9dd58dfa2bc03620326bac81119ea30ac0041e7e9b1098f19712d32b3913f3f7dd6dd71fb607c6d08aade9cf6c5f5226dcf94157779baed090a872f4568e8bdb44dedc99531f717ff6d481142ac3dda457e42d56a8f805966ee6ce7a7fb682ab76a7a1d5b7c91ff7c8326b64da92874150806d5c1796906238207904bb59abda4180e397029a51dc80380695dfcc373fabd1a836ac507b7c7db551579298226d52380ea89dbe2f3d1a73629558cc542e30aaeebbc5d63055559e1b1522620e3fae3ec83e78d0fb57fae91ed283be54382e598f05267a2ba6a56d2d3b27dc1cafdd85e95b9faa18c1937c98d76011dacd7123cd60ee1a6fa1a6a263640c748bd7764f3816948b7e0a58b01b452d4fb6efb92f8db24dae6596bae3c02bc26fde14730f970157ff7dad20906826deb5725ccd84636f2cbca91c997060f36d9685e0c69e5454fdc3530d4f325e1a508517b22b4b212ea7dd9853e122fae050b5634cc74f8fcbdef93be41df0e74ffc9c72fe329f867c644487a15271c09e4ad709024e061b7a423423db77a5a6c3b1d1ca8d50b0442ad6215e9665e59cc9248c2f18f8053639320bb0c37367cb4ec62cffdaab5b5e144e2f3995736ec3a38deb1f317c2277bb81c27bdab69c549ee0df861091226813d58e3aa7be12000ba95ed2fe1f43b209abe7053a213790ebed892f27683de7e1c65a203aa78e87927350f835ee26f20dc825970a39cc1da5acf37a8afa40147112ddd696522a415f5055c3eae5dfa54cca709dfb4a320589184341c81b8dae2e6378a9110de123f35034ebf4e7fd1457f6a0e555fb2a5e3602c21e326af3713dd7e88f093aa318914fcade992fe1916169811918b4854ebccf4e75c5c5d497ad605d2385e42c2d0c29949e3bff2286121a7d57fbc9d10e67b448a4fe5c18185bfc953d912c90b0f73cd909caba1cbef3afbb8f5b335cdf8c2bd2e56204a4b414b404b8f867ae7e1a8f349cae23328564df2eb12cd736876dae7d73b431aa935e1f161de199127a84a9827ab538df09595e8e8a4f8bff3bfe2127024300628e06003e4b39bf5acdd154f9a52e717a76da9a45e5876e6652dc5af1e1cd8bd4700f104f1fbec12ebd0cffa083ccefa3a96866f7903baceec8118261eab8e9f50bf35dd30d811fe372e2f74aa0edd1f2b7e7fb6175d905a01f90bd0d2decccf065f9c616a36ef8c3e9cde0f5bdd83ce3cfce3d4dde26d92b0216830f78c25039ebda670f7609b96bd27a86027c87ddc3ffcbe6c30abd26f0449e84017df0c82b88bd06c68246c3f051e9f737058c9f7f5bc74c4b0e126148eacb9fe4f110cfe9776b0b660ed762b609d6e2b66a6a281eeadffe81c790aa149ec3374c0c3e04bef366e1905c4b406d684c0e26e08a50dd22ef954b20bb8dd61d2666c170d1f53f0da031fb88c8c235724e074af9e70794248244a1da3db04f940a868467800cff50bd60977fa6b7153cf85a1d6ff0ed4104b6244059daa5d800fcbdb383be3967c710017fa0044b27ddfed9f0b84f91dcb5013901e646a2a49f12e7e871949e31cb6de4acd7f921b3a501fe32716824021bfb2770673c812e5d2f5a6b27f7f2b74956149ee0c85b7098648b74826625f0187b07c0ecc245e4e24a280a52b3f3f9b41777e1b50f230c97b4651d558552e68b11ab776a2dd17f49a781329ad689a8966094f894646d8528daf753e675cef2ab01aecb0e1ce5f9e1b2c018e3785da20acb7f8ed5e0bb02f5efd42886cf6773a56a85df2cc7a8a58f153015945ff36bf33621df575fafccfa83b12751f8873ae20e84c1b791db33b65180f2fe6321f39e2d2320d4e6d0c1a091908474ff8d56b91e1711d13c4810cbfe8d3dfeae65a364f2cb8428ffe3736882afb4cc2bcc20ea845413305b6c46e08cdadcb946131f374144638478a4d2fd0ac1bf773aec462bc852bfd983f13e77c1d4dad9f7284b6846846c98970ede40806977d1c1905a1c62e51ca62c7ac9f203ca58ce1212e8ce6df03da6b42df602b9132d4b586cfdbd40900cfd1bcbe52e9a64138219470d422cc58f1fe0369ec4072bf121aebe50eb0a326fb73d4209229cceb27f7afb393f63c69654c79b6811cacbd5681bf14beda7f1a86b4011fcb633ce2073009082bcbf234c62d6e300a174729d051c5ed1b374cabf2659bbb0c5b7d3a73ae9c437b0ffa1b78c2385f258c037c856781fecc2165ede4063b87d2cb00878a2ba145a5b35d88fe1086679cf6d5ee54b462c090f45acafa832cd4cf2b4266d0faa1fa88cca255eb8b15b65f35af72d80bd851eab6ba50d8a2291b6b40fd2773a7603d7f312ab774e123217306c6b453c2caa7f2a82b834361991f183f7a3a2efd9fa9f40d7737c2b53870be832a131a23f433c686203fdecdaad343fa56505e1b79477331948f24b20bf213ae157f7e8ef4bf1af701cea1c44d83073540a880e6b415f86a85bf2c48ffed8e0566710d5edddb9fd4f05acb674c927eed93a4119c41c2877726476fd3d89264ec0616eac864a096958ccbfae4ee7db06aa1089ccafb206eaa1d3fa008949d2464890f3c97768094a2624b17f7355ca59701baf63f653a01c790920cffe7d92c7fa96003a3bf54093953afda96459b0b21ed51582c49cd1080b8a447030481509dd2095d3b67702fde02ac2955577c434296cabd7612d2f596be28c07c5e35395deb0ff00fef05b0edf8a1225b807cd101cf34d0cc80d0ab91bcca7a8243054e5d5bb8e456f2a2e724b88bcc2756d040b50aedee29a14049adb458a1dc19093ae969657c7606ac9755568bd55e49c4b9a9d6612d2280b73e54fb8fca8082ef95bc7f65e05510d5dea3282b90c3b8e7fb31af279368ea17f00955f088c42148f8c84a98f792372050d8c7882a80d445ec7ccd78a484c27ece0b8ac81cee5bb1d378778f74e7712ce8c7262146d1b0eaf878b95114c72f07ba265586db1660b12d131a09bfcfc7b60b637fa375bba99c8b53938e66f3d243eac9e29d596de6a1181517077645ae10291dd5e1ed158646252d1da769ce6c132756410c93f1378e22971b11191b522239e4ea9f0ad3f7e47ab406ee6eeca7f5c98ad98df10e1a0e31a42f1a32f9f2bd983eeb9ef5bad65473234462b7a1fd9e7d74e7ded13516195bd1e8cc240d853b06a22ad555f1943baa109098a431dc65fbdbe175c441d36bcd12df9b48984c97791b0eb23f48c885deb778fa6d403f8ecfdc2b029d4a12a6750b16f4433ac56e942523cdad887943d45b1a6e6f3063d9fa571fc77a2e73265c518ed9556c91f8743c001ee3f3b19054ae190efdc41efab7390d29ef4bcfdf089a53c4b72d10aea6d8cf767c645255b2158dd26afc064e96275544822c137b8845e917f12090e1291847ab91bdbec89898a8c63b51e971d37c47181b7a00c320a152e15ac01a2a6c9d129e1f458bafe18998ff9cbbaf94b5e2f33caf6770dde4260dd9840657523f30f069166bf68c47f3a66ab60e3b5668e735ad061e68c3906506616b6d0cefd032203d7452a989cfe348836df5b6f9cf20c2ea22ceb3890e8a0bc1c024cb147b91bc459cd97ead0fe1ab365097ac9f93e155e09385c7b70b83a6eb1d3d3d3da6957999de1dc97b5a4dc57a6e2091e0bd39470343b39bb0e1b7f42e46771b3056d292491a16d8711e153ce5d2ddb9051226b8e91feda4277356d3a5f72b7598df2fc074a769cd60ac9865e1561b66bfdf241079e535d0b4c65ecf5a93255ba9bc6e5a6e0e5f80ce37c8da040c26e7256e16fe412a238843fcd90a5bf3222309d1fabefc5def3d5e49ea7218b3d204e6557ea1972ade8e9a709f43e782f1e06b1fa525c9db7356390ac467344084a8636ab75917ac50c5ff8dfd8ce65df0cf892615029eee2fba90b03b8de579bcbd66d7964fa61d718e365ac308e6b910f463ffacd7910ed04834e68478e049378b3abbfa924062e88c59f14d4000a19157c64a9bf5dfbc7450f7a9cb1314d8ebf0980fb5835d1cdaa0eaa35fbdbab5732b605364550bf6b15179954c85725dea277280489ec6308916753f4319ca44da485cccf3d3702a4f1eadaefd2cdc12e403c5f16118d6ced83dfd6990dccb6602c8f5f476222acabd415f21f0dee0146c3afd340780f0d0c41eb29ae34124d31ab9e2429fb3ceff9c3c6bb7d2a82d56a8f16b797d7b9f366bf145ceb519dbd0938581cf3ef98b2236a6766b9942974d9dfef1c8a043673551d41530aa0041cc629637d6ad8c971e8b5724f7e577e156330df48f72cfe8f2fe29dd02c435c5dc7e73d6207a39358b194361e5b535b8c1eb8cb883a67d2a93859d4523ca73e158b722434a0eee2c494ac39b22335a0098de07ded3e57821bcf710b42c41f51bb6914e7d87bef56db60099c152067725ba14003526eec03efb2507e3ee8fdc95c53d7e57991bcd1d7b2176bb74cd45a776d8b98ec7ec410e82f3614803a8351bb45a160f344bbdf83694cb454a8946ee11d7a1ffe39f45048986446bbe4d18d7f7489be78cd78a423dd36f95d3bd8cc7466633257f4b52298c59820ee95211f1684d79c50b4b39d6c31f3d9f590ae9d9c35f12b4333dfc54634408434c1018348250dbdd01880ce242d4831a7b3eed26523b5c6dc910d2948660c32e81e2efa67bff9299e04cae7a122c1201cfe12f7f1c00cb191a483ad22d0467cd393a4901372d5b517596e6eda5c3b7de3e309c472a3ed6b78dc4d5ea370573a987af16d623d720d0da74bfcbbade5f2167d05e26e27d7e7e84a4d049d59effb83495b87c54439a508338b116a7544d2e1b8723838c11c745eaf29df18a24c4e45485c54fd811166cb2b967d3aa1970f24bc189b23806909fc9f894327218c4cd7ac656359ad542fe7e35f3ce1cbf58cd8dc77048e1962c6f59ada84c2b2bad76452e8e55ddc864220dd9d2e9b451cc3d88c49eacadcd75f2567d566d14ce4e2bf2c6977ac5c7f366557e51d6fd41b1dc422b173fdd535344f2cf6aa0366aee8762a0e96a9ec47419b2132782682e36b756775574b351ea27a0b501f89659322f6c86b772a1959d284f580ff96bb314b68b9a2b9d95d346c31ddf604987096bc117ea548e1e5f8cde9d05b74441739db7b001e8b88b0112ba5cee196a54bda34f3aad60737c53afa150a2d93182ef5014580b804d989ddc020455dc4b9c88da1ee72767054f3b72762050f418e0eaaf7e12f7d56f53083b9451726493462959a7a6b66af197c1cb8279310b9b756d31bcce14c3156ab2fbf5d95ebd9cb52d1665e0e2dee45ef80c08187ca82f05845ba2d21712fa9bf6fd402bf9f9cb34d19a771b98c29828d300a0e22093a902ace2210c8cd74ca14898f580bbcd3e5cf8b15bcc2e44d05b27eff706d327f498a23fc646baa5988b496df939f50147a314ccf9e7080eeb0fcbbd0acf1a61c4fb0fd9432da9c8ec9736e271e6df61f8ec4ccd2bf97b53d8915d75ed8c5a1021b682fc32834e0a7dab43aaec5dc9236ec5b518f56ab5a4385f000100cfc789155035299f10e0e8e4fd070004e765fe19e8ebb2b95f23b8cd93c2e34f7d273df0ba5952a0434250d0ded4b387c43a7fa7d2b5e9656fb84960e97e9e273b3815038fcd06096c3585112966218049fd1c5721eda67269f5cb02817fee12551d60a5081831ba99daac9fca17f5528defff59fdfda27ac18f090a6425e93ec2c613fdc1fc285557e5a4e697bf44474c7bfa1a4fc7855e27c1896b198680f943c68b05db22fb8be2d2fdcede6ff85f9aeac14e861bd68defdd038fdc28dcf44123d358fda7706436b83b019206ae58e84be93b42c3debd8a873a534d15e2784537862039a9647281c6f7a69e1366628740e3ac6f517b8ac79f19af92897d1bae59897bb7a2db831e3463969725c89008182106e307d91e26d72ff04f4abce41bd62c38ad20d78d338b860287af5683c5536dc02d38446a3992c6732ff3d2bfa41492deb69a2b166de0cf2e29e45d1c1c4cc4ed0fbc71783534f66a9ddf62a6e9189378e2a665de8ddc007298acf76bf064afd364944ebb8bab891717878b72533c9a978374a1cec07c2fc74bcd22858cb60cdcaf5566309d6dfcd97b935480bcacab11e8402fa4db728d5c55974a129da33f4d5a0ac657ab97b1da453c334cdc98627b0cafefbefb1529519126dcf2be3e84d9f7bda54c67c074828ed9979d58ebf816554bec893205f63fab4d8c1fafb46cc3a2365667891812c7d3b89022ad5543b8082c3bfe134c3cd38e784d6649d8f69acb84071c0f14f095b4867a8ba39713ba79a1d22ff626ce0e14fbdee0fd4e7960561e6d93894495c069cee7a804e28b388b955d981a10074d9b57a71b93b08a6091e1edfeeed1dbb0d9448b575bfa5201b0ce89ba08df61352e580d112095c456f02f4f46e88504cbad890732a3551ff7317df3e9c94f49db6a1b04628b3fc4db25b016018480f42021ded4dfbc2c74fa35e1d1fc4d545265cd41f5d3b61fdfce862a67adf3120f2eb3cd3b4acb390f346b6e141c44dadfa39a32b9d7d6d0490a57ded308cfe19b143d75f4ade39b68666c8cba5489a7b0c9d2232c470a500a63feee3a2786881c6105a6df710702dedf397c48ce99c05992cc74286bf02bf078bdecd8a1b41203a3349516e7712ca7a4e43957871025eb697ce2078a36f4fcee3ea5e5da6b309488a7929c46bca5bc2ff53f62ddcc178ca22de9dd93166b5028c32893869174d602c4c3c557c2e0916fc8d3f7c9e7be2c2d3784847b259212a9cbf5105e5cd698577b62accbe9e7a614fabe2414983f00e919de4cdddcbba5f5fd598195cdc648b0653064dd761531c3a15cbf6f4d6626bbd33bbbd6b6b1c7c681b342b4716fa769b37900613d2a3f900a83f7483fff7768e19ddbd00a6bc9be1c7652057d7adabe9fac86ad939f837273630491de5be62d1ec985d2e88b1a827237ab96d23ca316436032079279b69bb5fac736126a43728915bb15aeac667698e33627a33537250361b7636aa5ebe675c41798b7ea955baae36b228da7f52208af5f7a14137ff82f5e76663057533b157f4903b38649215dd70331718a15bbf8474a14993b0ade366278e4e267975288dafd2415e59b4ac0cc9487e8519de3fd6ea60fefbde55feee1468e98db9df473a26e87bd67c36ef22e3e631bd8f5fab03b6caa17d10db80d5e01209c1fa147bd9dcfa8a8f45ea7e50ee62e46eed5f45abdafd7825e0731b18bcda41ae291a608e44a3522571afc68c9cde286ecac719579a9565a9883477a7a623baca2f020839485582741683eef61c64575bce24c7fcaf382c1eddb1c378c08b0b1c8b6576c11edd44edf304bf6d7105d7b46a4f955163f0f234177b73ea9517b74237f713a9eb89becac8ff63b403bb3018ff092395015ff59cb91821b212edcbf2e6925b4652a0f5eaf780c2f7c33751dc865055698d6bb0a361b7ecc683177a436dcd5a52166d6390a65eb4122aa081b3c8f0d6b97a688265473c01ee22ec93dc5d7834f06a93b0dc65f657d627adff3d2356bb05d4f82c8f0c18553b15f1054b140e610f8678300059acb6e45323984c3d596f1d7b15b9c924879ab0f0c4bfbae80cd7e16ab7bc6e2d50f029609ad9ff8cb469d99357f07fd4d8318e9ebbcc780a6a77256b826cc7a601496b7409c110791bfcc0d9a3de8ef7c891832bc3a334109587f8b20a2d44e1623be27f00f7a86da44f8556169c85a47e49e1df2cb629154a5ef33e703251570ee80cbcf8f44242080f3f63b41cd3a21775ba39973ddf9b38e7370fdae6c5561369a163a0d56cdaad1e99746014645303d862c3d79fd07a3b8601cba6e819a41015ced955dd8c33f2580f07a50d595ab2271030b543702ebcb71d6b2c0e8fc7f878348185efc1ef8860dd8a197703adea25d6dbe5f21923e09409682e283cb0d56b596d45c1dc6459bbb2ef42e82f6136dc9ac7403d29f1312bffd8179ea27de51a9714275c5aa33011a27fdb3194a06a7e179eb973442013842606f14e25e11a78561d777651c1ac658ff59610b0571cea28ae4969bf908418ac21e59c01a2670462e6fd05446e831ce8463c8e96c339e72c80f84c29d062eb5d6d9df216202a243fe1c00de5c5c815387702d3ac330ec2ae2a4069fdb1d134d35b6e83b72255f2e436bf1d80b08","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
