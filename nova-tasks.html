<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"25cef04522863d393eeb0183da11dc90bbaab0fc8157072b8f58850b42558f8c474b0ce4f4b23c156f68ff49b4b01775519e4549d75bdde8a75a35c7800217d208752539acd29dbb3a500d4b1668e8285951b6f300a33b4c97cdfb41d63aec9bf2f9c1e89c67019cff7ca58ecb4b274ac0438a672ea8e84b4c95e9d72720f21fb4f5709611228f83664f5e4e1ac852462251fbc9150d908ed50d963e9abfb2de3295805155d0dddcaddd15b593915117d3bb9066222f2fa0b04f4f19698513f6c4224ff5fb90e8bd518868badd950c88cf0fe2ba0a56e29a248e1edd4f67f1eec38965bccbc95fd7c5fd77845b82bfc9c3ac8b0113d3c946b9fea9c4415d095f0e57e1ec4c5c37b82ba663648c852630ec8f2c51dc792854beca5ddb2d8d97eeb919531e803d0c9b6de930a7f32e0df35ab501b44e871ae7ab286666996d113f44e50ea50e7a2632e420e36623177f45ab504dc9bd272f92a638e35468785f639d66aad11d069dc730a5512b7edc5a79402e9b39b6a9ce15557ead964efb2376ac695a8bda76ea21b684a58acb376eb2760da83bb94fb9bebd90b5261a61cfc678503cfa2fa4e6630d804f5e1b6fc8a2b8bfe0fa6fbaa2e6d98119b68c75aadde139e6b00be0a80ac76cb2aca929310725079de93393376d89bed68c516b766fa68f7c3975862bed05d94cc6b494581eabe6e2ea122d3c7dc2918b80b49d25c5294c438aad5e3713dd57eba61d654772e255f41d18237b07659bdce081c482c741d7c2311fc35c4da29102df25b16cda3849eb77984c8fbe37df7c5e8d9462463386c278d2ba511c015aa1dbf939f6c808e73f314936482cb9fe3b1629899f04502db54f9e6fa6e8ae4cf1b93ab620743c29a064ef307a2041c8476de5ae243aa311fb6dc9b287d22da7e8ddbc37b7de8fd5426e7f1898728614cec28250e7097c4523976959a90b4a3b8aceeed717eed76c3619f5e7ff8b91043e2f8c4faea04cf0bae3566aae91556e0ba07e8f341295265d94ad1f116ae3fe32be444a0d5f1a0a57216b72f43ebef78625003e5d47ab453ed730a47d2f6549056bbbc27a6e120aa3e0f81eaeab1499b9121e539561f53b27b6905b5d9be9ae3555fa8d54a11e9877b387127466d739748fe2f412f5824f45e886ebad505343d3284571dda6cc6e71b9db35dce214bfa9942e5fbea7ea4fef36f9078cfb94b9e91a17e25c882fe7e824911126423975d055a06b330c9cbafa9d63eaf0c53964d225761dbd2dad2f92426972794c20a9881be8632dc9011fb3e7fe17665a76a31be834b5fe1fe095c78b1e2e274b64e8dcf01aabd1b798c912de08e72bdb3ea4ba1f47e7480a0d10223d6b6c3474b08ba2f126ab4fbd84b01568e3d9bf9a2ffa9b6f3b8df5c20bb72cabf07f61480d94f050d6cf3254d1657c3738fd469509dcb24498cad0c2351be15f5ca548c5c114dbf8f5a934bd3b0c19d87d004aa5033a75ec7b4364ebe35c4b5b92dde4b268d7074ba1bda3e0d3f36371a2ee8c9f5bf21a8ece514b2da8ebf945c276026accc2fdec5a2a99f1c6c93401c1884f4f4b1d8881ecb419f1ea0c6f8ef5e94c8d25a9e17dc28c89328f35b7ae415f4be65a076700f6e2c57719ed822660dc82a99fdd98553e50e33f65e912318a39beb06c40f0b675171f4c936caed56563ff824df59e98844ca6a884de8ba6f2922bca141639cd4bb9e93c6d7d81466b60134fbc4ab15165d884d15e379f5867b1f74386cf46c13fc0a5d766d4e63e09deb74d7c8f7dec910387648c5bcff1d7a919382f594885754bdee95fca043b3ddd012b5e90529481634b13298e97202af72c12a1898014947559d359f51958b6bcd1dd8daa236b093f56d6fba51870fff9af2431da839d38213bdbdee4ebb1e209ed657c50e3057b9292e574272414d96ed7ac2da59a080d933401cfe2f218ab7bd86b4147806cd73ad8de592838a71ecfe131a014018c872b19440309b7ba4edf9605866710b834fe47c655b62075cc02472699be462987bc7cfaccc35e54ca9d09bd356d61a7ef58c60541b93b0062b77bd61fb89e39371075319feae2e90b509e67c55e252906d4651583a0df8514a4d90f836ed54e507e1fa517fa98d6ede3b05017b76a697a0fd4d7e4715933c7db305be02e8ca47778b523795bc44c5fba3c1349db14eb96dbed8807af59c52996da0631806bdff1efb69363507cb00c30387f143e03e3718c9529c54ecbe375d1535daa38e89d5a8f3cf3a6fc7570a8039ad4a643c7c550396606f1a78bb85ea7217621cb7ad4ef633dc7b37c72c3fe6bd5042617f57538b8ac8cf0d66d34706234b1e9da36310153e07926c50dfbccb60554e289311fb22b90efe59d738ed6cee5c059a6148eb6e6d5aa701b2448d4ea547c4c2d367fd1a56885b99bfda50b8d9aed22bfa07312d9a4a958cf88c1e48b56e85ffae2b3f9d933d883328c167e07de9ea97739d3a2fa76055d4a0628a3cf96295e7f851a4359bc8b6d0c75165579a2a8b845c8777b8e1913a0106ce3baa1dc328e5ffa657fb4ee49150fb7077c182d04d3962a4098aa063920fb1aef28cbd9d926ff2dbafb6a08f0da51a9734d92677a8a5f3f62be5abeda4a886ebb77c1bad3dabc99ca998151aa84528c57f4efc17ef78ce8789e1fd4095ca439c201bf2ece15f6153b53324f8b43df1e9fc4f9b0580d8d892f34392a54d87bbe6186f22ca2391508f74ca3a5b9c28ab4cb266c7b26811eed267909b1b163a61f9c8f7880e3fef58f5b99d4bb1a7ad40ed26d055dc5a134b7874ff6fa0a30856b31879a7329714f7ea5cee233d39d9873f1465e0cb5c03ed34271e30ad04437d691f30f11ac3b48dc9d261bb78f3736ff1d32d0bd48f7334d0dd13b293483688b4cb2f7590c5951c91e8056a110bd461ef246f647df40aeb7b6ec3c0e34a75f6885c7541af8cf0353d3d016587f8bb2352d2fdc8ae8969c7619eab2505c8dbdd4b2ad6a037768dfecc65df25e81341389608b08f0fe377bb29c4fb2fca2948dbb341731e1a381293725c9990761c08930a114ee331d7455b9b58e5fb0bf4fb025be42fb0c124e0f1599e401cfe3d6e321875e8cc0ea6390e90d034a1f316613a27cbbbf0502d60924decc3068c89f211d828b3b16eca76c2f0dbf348f333c0f6908f74a17032f34d6917d2152a66f12f0316e39cc10468493364ec112f8310e0fcffe86b3e20d2ffaaf38e6c299d677efdb8da58708246c05f813bf9a760423ce33fb16c2c308c471c70784c8d9c213f6e341910ef8c2c4d144da9170d265953f7de56de90609b45f41826cbe4d5e5339c08bf49fddeb3328058b03e539412fa9a86e66c04934f9040dd66f8a854ba61b972f73ac831b20a9d9471ed49c4416fa3c5a9335e70dfcba49de0433e2ae02480dffce995f31b483288dee2db732c7f6196e3c26350897e41460069c881968ccc0ba5c722c67ab9367d90116d7fea43b95a736700d14dd353f1dca2781e6645d3cc1944e86e16aa1f0120968605c99eb08feafe0ad3458986423e9afe7066e22ea735a47bd74fed9c4044028f0172bbb71b4bc89a9af3721da1b62e17003c2008f9e2836a9fe1ae55ff07e9d9738de3ba036230bb3e48bf5ff59aa109e1b030911340403e7b7bbc1f21609403b725d2243f986432b33d6961552516043e960a74571dd5e3d197a8bc1e05c917181d2fbbab8d7ba585e035cf132e7f091adc588caaa4fe8a256bcd7d7a2ec83231d6a1f36cee7416b17dfaf9c88cafbca03e3eb9243c0eefcad481cd3866a3fb014e5d9d5ff19734f491af98e7cefa678e8fc4346f3a5f1c1464dbbea9d67c650e4ebf406c7e6708e9cc9e41ebcb96501b2368bbf0fef6cfb7328cc66909dc33f8c45b35cebc137cfc65605b5b5c194bfcff17cd5595f37203ff36d23149fcce2cf2566a5217316aa52eecf10c83929f315f7dafb7121ff155ef7bea24502394667446dd1f7de9042a170850be4f01738653eac15ba8079f5d3fd0822cb9064850fbe5ec4e25157dba54c340907a776ebd05e74a01cda03a42abfe80c382ebb9322d2ab8d444693f3de9a425983fa50cf6e13bcd8defee37a86b578ce82e7df91ba15b2635773c2764a4c22ad01fcfbfcb2b3192491666739877ba8dbdee9c7f2fd278f5ededd6de9f75dfef341a8c94cdb3b11bdf4d278f7ba20c4e291407c3bfa71ebd91d53d78425939cfd8198ce2611a4f00a01ebdd61e33ecf740caaa94589efdf3bd81c78c8402d7faaef5876a8b1d05fe069d573247beda66203a43b69c2f705fee02d9f6d1b63673be3467dd3128920b7ca12ea512b6f10ff38c166f3f10a6bf06110d3ff388b46d8553ff80d07f667b15745fbc2e2abb59d2ababa53185118ba0fd7722df6cd192cccba425b304a138afae586ed537831de97391538d6828ba9cc882ea0823be79721cd8ccbf8de4df538c6011275b47cfa0747ed4f48d7cb1354a265e27d79b13a5a968d1b54514d4c7526848a325c8fd941254bdc80fd091b7acd3b8edabfad97de077919c9844de383364bb7968959142aef1082f9eb80750593b613c1104617d79608a9f91242125c802d9be347c3809a29c8e708843b9dabc2cb7290b6b10108a88f4179707fd6d10a402b2e19b087dbdb05578cf57c40299e343d5d9649b58d4d49b02d07c076130014d8a03b2c81b6f5a6ec1bf4a9af57c3e2e9aa3b776b58dd8d711230e1a6c79d72cd4dfec56eda2067e884522cc9ee0ca19361e0b6851959f78dc557720ac1a7be2adeffc12201134b0457fded4e01d246af1a1c3e09bcbbae8b49d97ade0f298db5fd9ff7dc710cd8578e00f24ad90da530288a8e6a22c672f071cf29089fd9a690b91899c14db33ee1f9232a61a3b34fb5a3e5577df7320a7ba63fd2d093415535a44873d37b42cde5e34b03487d70814d8b3d91a9a6d73ae221655a439aa28fc74c1bd0b735eeb49352846d0d858d3f55a6e9975d2f86b00718e948ac9868dbaa73d95c4cf691ddbbaa77992c8863afbfd9e800666cb3b423127926d7d6c042a91689a52b3d68c680ca3f765e5ea1f36863fd34a567a93655cdf41ab38e365b1e6ec94fd9b9e14bdf06eed815df7ea58a60c523673325df3ff439e424ef4ac422a308a4e0b676182ed73d3964240ebd145eb83b3bff8d80c5eaf604dd9a3b9dd18767aa3e8cd7ec389786d39cb71653c0a1ffde18db9f72ddd174e1da99d8fa9cb77ea12477c1269a2d680276456077e8c7a17ad40ad597fc5bdcb04d5a3f47b23e1c19752010ddb42f6ac68f9edeb58f7fc159f8f4806a2eb54f4248c0c135534897cd5093e9d18749874cd04ed727d2f0486e9d6f62b488942a26e72d046e20f91b0ed7287bd809eb857380047db32da119d14044e1c6ebac721d77d1d516e55e48d2b86f7c938059a218b2bbcc16646e96d992f35e3d61250248af6282761c0a86ecc7b22a9aa8b857419c669a8d713b81d4cb48d712167a0db7858718f57ac9be4676b79032e7f204eb47b70256172907fcd46812952905c791e54fe4a81bea44f9d08880fdf8e4af2320318dc3854d14852e44f3cbcab22ee04a9d22baacee441166fc5e0287b5f5db01e87cb57a890c3bca44f55763cb650760a361e4fb46253d692882d433b6f80676fa3ce0215999f16d518f6b329222a41b2a9d91f6e8a65658c5f9ff5b415b0210c6e20bcaa581eefb6f9d0b6cd0e91fd93bdcbfea1d2a7fd6ec060a8ae6a80a2abd99af28f6c08e10dee115c5c6e477d7c4c681e47b3247c169a0e1114f4230eb21ca0f249fe747263e2acd34eb26ba5e5c87b4af8e67ffbc4c55b649e15f17c6d8a6a28ec091496abf159aef7793f8e67b7b8e84548faab6947574cfb73aa5e231ef7218cfe8e78d6aa3206f50e65a2aaf27197821b0daec6c7160415f9da0969d3062045f16b82533df65e167777320b92dd69bd846056402757ca454752afea3ace427fb3494d90e7d0fd77c24d5063330364e51b096f8a688e4701aa8fde9a406aa558a0f49a843f7a45c6683bb201a2961950630bb9a92009d7ad5147344732173b95913d6905afa54d445e92e512fce7a4afd2d7d7c54b72bfac740a6f7a3b4b60d1c5549792a870633724284d451fa04fe4039ae0b1986b7f847d8095da56d6a2d1a401c6550a3a5867d3b780a0ceb59c432be8ff0ac3d51fdb69d1b1db907c18826e3556eccc00245dee5fd65125155e82208060eca389a6d06d98812b42d2b209c446fd35101a53ed9bfaab955eb9eaeca3051bee2dd194897efc834d3a4393d2e54bcdb927b81822221133aec876d333736c3020c752612bb05cb75b5edfa95da527e5305ce064072fc2e97ee3500ae36cc7bc61334b63510723612cd7088704b91f15b0ea807b971c7bfafb5132b5cfe828765f3f08955cbd75afe33997d51488b06dfc1651ceb646f1d44968de722bf31b0cb95037854e36286c356ab766b31ad2339613b001328c5894ecbedd5c825289eb07083d1d5407c311f12d5d5d0e0b679f9623c1e5f7e01f6eb22dcb0fb212a494b5c0b9c1478015bd00f5e61eea1cbb226ae6983f405e012c0049fc5bb8bb09c8d065c7ee7c0596d7c5a36ea5705462420bfd7ec5e6849b4a55036e0a98c1aa2f813f69ca50f77d5707132a5f9fa2466e9b6115c69821d17633368ee2828936defd0da86adef9515ed58b10504d57f0cdd27a80d4895fbdad33145713c757a4b5d4b5fbf1655f7ee3c21611e84a817172684da78bedd2fe20a360e86f8b3c1f4f04c2f0e6df33dc0f985eee877bdfac8c2a7ab1ca1182ab9a46a55d5b7c0da4e82b8d089c229a5409a5f9bc325a2872da44113799a7cbc8954862db7da7a96de0a2dcc728b6efe310fe4dbdf8f0519ce84b8549e114263116abea512e5d4f25507e17f05796a53b69f93c5e4b4deca7f961bb41156cf1a447c735742973560107a611f0e3bb4c5b09a0f6ecaa2d368a79ab9dd5d80d57a05fbd4d2b5f3e90f798f4afc0393aee77a5cbd17e4c8ed55483b41739e443275b610c89a52042b4b75bad359571d6cac2fd8e4798bc777b85b08ab98cb87fdba51e7c386e4b798e66ca5a23b987fbc35dac01cf9d7b9dcfca6445b0532858fdcc6ac99684d6897079f8fdafa0b089b46f9795aaf7d424aa12ec51bc814a55d42686dad11666548f0389f7d19da3dc6cac05a90bb756c3deee6c95d2a1ef8fa3b7673fce2446158a9d2f0b9a5c8d27a657f96fd68a5ceb09779641ba30838907284edf4c506b3dbd0dc06298e159ea5ffbf08eca37e6fb6b0788dc7c22085eb00f66d41f920fa9b1f401e0805253895f7598238ab6c3f49dd1537010d8e11705bf305f2d5600bd0f18760ea2ffc53b6383c47c5300d13aa4bec30b914237d310c1e9f7fbd7e153171d0fb879df5089a68db8b144bd039cb324739d52a927a84e92282ff2d86e430f5061ef79d7fa79d82c5e9293cfb722436f0d6115bef14a7f4b953aac740abb570245a9dc8d7ca8e9e76932f373b7f25ba056b5f90005b12b06a41c14d23283d75dd6b8cff47fbb374beb73a5376be2bb6754a62e0a6f7bad053587f0fb58afd2da8bc0bc06ecb0ac50bf63c9c9d94a6c20cdecda2e6689f9882c6d7cfb2e3467b5dbb1d7c399b3773bf412b97ec8132481e9956d64eea953f8304a01c8fce8f4ef0d62a871223169db2d1fbd1719eba63471ba35f2bd1c99ce3bd564b816189ba70138c7a9c68c4691e81eada6226a5d03b5ea465d8f19288047c67625c54e5b77f9edbfebab11159b62ef0a05102b9e36a0fce5ce0aa54776d3d98e29375d658c7cded5caa11203ebcabd28b920d92569984e194f8534fdf017bbe6844afd465b60547f041650698403e8937aacc28eb8629b426e757f4ae09970a6868ed518bbc40bf930fa3178825b362c086b24b90beb22a4d1229afcce460d65265144ca8ba6190108d4dde7de8ab68c45509913034198b7935807bcc17dc36a5c451a3b532babcc710791c11e75eb48cab73b021c022f565c0549c2de7d44fdd7452e4d7b569ea4a23d17aa2b99fb41a3e1c06361c81f8bfc42cbfca8df9cb77f61f9e4f37a4568578f680069ce42f33f6c9e0711a599d75476d079cfa9949625264f3b89bc3fc2be11f8e45473a35196f85bc010be659a3bb3fbd47c2892c29368e613e7c23c2163f45a05f5036b9083c74f70b66be75d687f98c8dcd8d1dc8cc674b76b423f9a2d8ec5fae744b2d19009a717660b17e22316d83e0d3149d459d9bb01d4f78e5c0d54e20f44313e02a467e99a50466aed53b58350ceb0d3e222686efd4608934b7f7ebf3f7cb0da7bf42c583ac75d24c4a7563b4d4a9d40990275a539385b1b161458b80781798222913614059d34ad63c57c826806b87184ff92f17c60484e82d16249baa3c00d93936424b29e72cf4ff87ec793e0d73cbc58c99fd0ce860044f29c32b4196333ee750e64c87fbeaee89fa4b7b42eda7d8cdff20f01a93ebad2c5b4d36307119d5537a29f77a50ef33fb1398279a73efba32ae1bfafa777fb3a3d31d85f0908d3286d2cf97f3d1666742aeda1264542f71981b55d7a86e5714f25c5d7d11bfb25ea1704ae35199e681d58d43ff072816a2e6d0ef2f2ffdcc7f062d14dfd0ce01a84cdfe54db011a1a64e8d4ad320dfdae346a98f8e9b94d30b44d0b0d1790424e91a05dbae5ec23234d5d902948a5236a11fa3ce3a8c12fdfd08fe1fda986f51fbde616775b3c7a2ff2a09ea871ef88ac98dc5ee8912dc98f6e3be009adeffe094c4f75a8223d40e54edca3e10cd29cb1b2955cc715024be1459747fb02e0cd303b59197146ba2dc9328d94c9549f7a5a3221e0825ad00b2c18bfab2369e8f3afcf5783c707779e454293b60e16cf8a6f976b615dfe53e4380b541609dfe0698c07797de2d1d3e693327949b566d1f42737e97f84517b86df12d1cf8f862518a5c98a90ac88face000d38d5ad4e9d1e4cf11acdf3b0a40ff5a10b62e8dd80822cd064856daf7cb66c0b6c8abdfe69718e1a941e092460ef16cf18d078e09644e866b874234be0faacb29079e6b6e808131fb00e1ea5aaa413d36a7b8cd11ea35b0e163f1dbae3d35968de13d7d70a0f28cada46bb0c17e26e276de75ac7e9097de183a6ebafb13448bfb8a49b2766d1172d747292228a7aaacd25f569aabf6a4d39beab0a4c2de294144b4ea3b906045a8020e0f5d3bb8be2030b863d11bd6d4e26a01e59615e174e0f1a62ed2cda1ccc46957c913d0cdf361bd860a03efeaaa74562714b2037780ba71b97145c28cbaef5d1b966f42673b71ed4197516da88becbbd7fdca52073c99a1cea99581062b00fb377b0ec1a0e8d0acc3749325871a866488bea7456e75e8883114b63b88858219c157637cd1af50fd98da3c3ba408283636598d139cbde2bece5f995d1b66a87ea246b893ef89fda42e00be3008dc62635e761a1f41ff982048b425466ef6edfa63bcffea318dbf87b7473500ac41e6483cfe669b8d322130dffa56f50d161bef38888353684964f594cd6fadb35d7262c09915015a9218d44c737747996ed1f9aaaae9a38842829efc67176e5e42c3af0e00a3f89610f9f1d091031b66af254b9b52dd0f17a8ea91fb77c52308ecd70165c8a1bd9bfc62587b5ccbfa459de4e4eea0011df5da6202b1b83cfc7bdd57e81ef581013f2fe8fc3547a239764b5d299c4af8551801fcfb8d7852761d8bdc7a0cff008a2c32f41b68b4f0df0f4444a5a671680b3543bd987eda4f9f20968012558970de4692e5b3305e5f8016793cecba1d0e829996daaafe7795909ba7f813393d6d0d9aa592b01241faaf58d5e5b0548cf1bb2c1eec9d69e369820baebe56f6d9a28e85dccf1a2b1ae392cb0075b558cc85d4b3e6570edd6233982c98bfc753d81eae40dd829c4d2b306d306b68e53c861a34f83c35d31d5f268a5ec85df99f2ef4a3dd170b44c5d5f7aeeec3268e85c63db3467c9a5f187f85c74720c52cb301aac6b74d337d9defea7fb061bf2752494603abf211553c5770ce9ee8f233351098676ce4f6beb66445d522396519ac508240c750498021e7b7aecce6dd5d7d6fb80c11105b68366e7876a14d38e2a215062c3111e8414bd67579dd28095655f57da9a77c6c8e6a98383cf166fcb6094db7732a84acb3efae749a1c9e62edd22b105542b4939cc39db6410f4a797de59816faea5712ca14dd24e64aefb0a0734549bd054a6e7616644e4415647d6bedb2eb8371f86f00f949260f844799bd41733b4c5c8684ce412705d7e7af060b984d1cebd538f3062630194b4a80800055d8cc67aa7df55c06e4bd5e5fc2f4cabad5cc880a8105a6284e83aa8fca8f603e970c236252833b3a3711eb41581710c2fe72a6a33e8c450154bc48b01b3177cf2a03ef460593345ed8850b714bda9e699ae9a9cdf56023e5ee18e4e2db8a047eaef67e0e5764c625a55a346926b7a75748d42590b7e07f0cdeb137ce4e2cefe050c6534831cb17256e34737d9cc8f98fe437638b2ac5edd612c9e83f8f5d67b3ed683cd7e80fd680a613797ba437d8ac0e1255875ced7ec30b4213ffd72d0903a4384f71d5f603de45ed88193b327b6f2dc8c22dd6ec77a5ceb65d191109954302c6a4f33ae171f389d4ed9737013459b033f423b1d78f3d9c5401ef3d6e2c73e089eb9d09ce13601397c55414a9c9238246665edc4adf455b1a1e1e43a84caac5fb41d142649e32d17f2be70456cf35a8fbf762152ddaafd4b1f4559bb64f9d256f830fcaae7b9ed939f1113d886e3290eea444efb02a7f786d4366ef90393f6a122f3864342a7b38d504b1b5e3f7fea4e242fc094138d6c08c8c4e9751307c272ac2b61142181fea23e2dbc5635d836e3c7586d2adba7ba93d7d5bc8488ddca086e2dbefb4d60711e9b9ed6af625a0b3f7eacd0e94823ed1234f109a73f9f45ee351d54879c64839213de6f460a8d2904411d6f6dd43e31314c830500747614621f586b805ef7065bbe1e5355163d02566e937c70e46130c24c63a3fcd878c9c5045c911b8c1ae4da4491b5483a845fffcb2780264b2475b05cb02e81b90e68c581d51391f5f2c491ab658336e648eda5171194e8787db707154a518570867015bbd7dcfaf2d4410dadb91e77956d9637c27bd63aac61cfe09ef81a20e96d9eedfad1063882cd8f4d427984e25d21eb5d2855e34468aacc7da66bf7020d67986787bc789464085c356cff1720ef20e7845143e3d8889b70b9d1cc8038e2cee9cb358efb1b952784c075c0e2c1eb9f8665904973d7e7cf4c30e76d9965a47a7732ba835bd73795a5cb81db49f22490efc0c303168917ff7fdff03d18601164f9811083fd86198ad8468e1a9ab82d26a18395a90a783718dab45651f23ac800ad3e1a27ea26f46e07348c914366ec215675550755e1e40bc89b59040efde3f038aa704d19357f52a32a098f5b39fb126dc306b1d277ae62ea928a47d851a0e96991d8f3a03306cb4dcd1866ae5baaf03a358b2294e20b876a3595750e99a2e724e6248a79a922fe8f22acf9fd988d685c046cf1fd47aaa7cdc185e9ae2080d5b916a89dc51e736026572ab127c3a482ce2e2d0133eadae3683275ac53657f73fc6869340fb90f39440e07232184f43f4328e4e96390d8c9ee5fb7de67b497a5ffaaecd598c0014dfa1509dfece9f1500836584ced04919cdb2062eea6f95cfc3775b81a3542acf2652365bd1258225e43088ef242fbb18a8b01e0c32f45747fb238c1ee053dbbbcf20098693bcc39d797524799fd71d126e9e6cde4cd699b31115065edf4a3242868ce05d7f0299223de58b0d05f0a751c0784d09fdd9b3127ec664168a795d37a6ebdccbda252034712ecf21e331caaeaa85ae0373279e6efc15528766c7266f67f1208202a3c79fd0fee5127d2ae4ad084080de677905101f0f5765ae7a80531cb75919966d7fbbedb1680959d7b7f53c082f5742bcc214d95d19654c30c3795ba6ebad1eaa099b7e1009b7b7492ed75e587a25b3f3a3c5287c630fab465ae0a89ba0e6e2c8a81f2344660472215d89c7a6944fef8ef312bdc527f396de955cd9052af809c9f429535f968dcceff062fb10e9a6e356719eb4a747286d2064233dde1b9823986be0f6f61728b8936695f1ea74d8a783c9a93c4d9e4f4b56e521640c402433ca80802e56c9d190d3d384109c0967201b34a6f76c9982baa73ce95bf30efc21dade6f9c5e458ded0325247f91e544d1ce53fd4cf2ee100cd38b3bfdef9e94d93ece040110fde4aba92b47342dce211a3ffeac3d52ec17fc1f77c18202aff72fc6675d87d07623756cb658983b770eaac50dcd1c598a848cafe20f474349ea76b31bde1e0d1193ff3d3edf1a1a292d2ab7d374ea08dd6cde9b3aa3fda1c1c12172527fb22878b2daa6ac65efd3854ae3315b9e7fe56c22769f2a8b8b73b295560e8bda0d55ac2ab3a8aa5612f464c5014ecbdc6c99738b33a468654f1b882027e3ca7b80a5b4a4a156ae44b0ba73876de09e8b71691c8c20eb0c535b04594075e254c9d48c5ad69f019a197ff1286c947212a82f3a96afeee6cc1a5a5ed6a8d578726811ee487140ab485067958d8c615087adced0518c1d5900ed29809131c5efd033a234d0eb442646570b5892280002ef80541d77b62bfb029c61a3a62682a30167b3d4e644e2eee67485bce9a9bc24298c221f99e4654c944945d4457c1a958a95eca589e1ee0a6a9df2efda3cc62caeb1c875cf37cecb4a79deae5bfefc59d44dfc7f95ef45895c68b45b5a6cd132cf4ad64a0ca06ee18cfca21c52cf9c77d6d9229ef58bfe4a0cb94abf66884a2ce1522a2afe80668dccdff8fe6c442f30c274041d8681e2159c4e0b77440146aafa4043ffe6f36d90de19f8134829e5f5a597d18feb6e6d10d3e4a54cb9d0b25172fead8a4bd52c483500de9038bf0acb3403b34ef522623794e5873430f8ebf5aa828ea881f6fdba61dd6e54570b43134a1723672e78a28b0e0445737ef7269d9171d38bcea967e65e94024b12f96f0dc53104b8719924c8fc06ee7796e43fbdc91aaf3d52b78c5b80030b25b38c0f0324acacaa4d2f013aacd539ad00e6df9e13f9be5280701fb89c970faff4d4925611b1d7e1a26f181fb497d4a9f6353dd7a8100b1e0da3ffa6ba1544e6e89637787882ae456982db46435786a10b316a7b61f17ea36852e38eb64fa1fd9eb992f2a43b9583c5bb9bd0175d4341c85ffbc0a3f319fb4bbdb6cebc8d2a2c1e3e952d60858465dd93099134aa6c3a2eebf7952560a4ae6a7373376c0a4a7eb8489eef64cec5877a77f6383e525bc956d7c927d1819b956ccee17e76fb46c9eda187aad78a7eefeebbb33b429e3e087dfcc3ee69357e5eccbb7d9770f6f1236fd0dc949484830c0cf338de992309bf0bb612b8351a501f3b07353786caa8c340d1528616e600883eb3b2945114e3251213526981e6ea3cfea9d94d7bc74faabf1e57a64083725ad0b730682695f740e080689e1354d9c39ef53b868f550835b80edc229dc3b0027269752561687d09b915edef04982e40eb4a4c7fbb789420077216e493d08155cae94a3c6199a2ee22cb0e30e40892698ea684a770a5918a3c61eaba180d7193b9601569ff1243d078840e508c6557bbeb85f59005a71e1cb23bafe077252adbc75cb3d82432be5e429afa4c95a138ebea49fbbb57f1172130f46b4063aa10c0249b7dd0a5957d1fdfb635412e8660629392f54b1e55dbeb55a85ce67d6c794dcabf67bb9a71adf9cf51586a0176466c657b753d2ca93e843081504ebc80c5e9616c3bf4a64ecbf7ef46f50c653359589d1e3341661fd45336855bfa152bb3280c1d82b84b1ae3bd5de6e5e0cdcdaf2b423151c0815007a866f4f5f675d93155dcc78d9341fcbb51062d0d803d2497daca76e534552670c7c09d0e2a86b08a57d5143f0db8f905f048195f8d7951e2f654678f319896de9cfc302c5ceb2779a3984a43af19f04d44b2b6e74f9238dc4133fbfc73e7942d60c2e44f99551729d29f74d7690890d462d186cc2fcd45c9bd4e663b4e594c52826c5187be11fec04dc6bc25eb5bc93ee091881491901707dc7fc86519dbcf1fb0852d97b4f2594a4ab4f26a0c4aa67fb774986925d9c84b665b4b0f9a92ab649547b3105b5f10487557d60680c7f4dabc218b8caf1f8dec19c87565803ddbd95943d752f5068751205b074a3e5944dc7ef7e6c7304ff81a7bc1069c593b2186c305f549259056e9cb25870f17dce196144878e1b59f8611ffb19dbe26e78870b980950849db09ebf216dbfea307a2eba0180560c0c6a4a1ee07353c7ab1d3c6fddd712186579c78170d5527c925b9d1454300cda4ad81417233e755ee8af4341e677ba33c3771e1aec2b786aa18e2798d","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
