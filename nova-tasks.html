<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"eb88fbf52d0883116c7ded78446f988cca084770e222d55e74604ee6e35056ec7915b178eb1b1781df6df788b5ef59da0042df604b0895e73300776133c8d6975d50396e4a5cc3e260e1c5e94127e0630f62ba3deee51bfea05934e2ec9cef2a95f332c44f99ed17a3e563bb30053b3491fbbf23ce950559c550110793014ae620a9cb489d7d34c6e05638ccd19333a43f8b5ed1bdda3be6b03d5b404d5ae9d6f98c2562c30a6e45622df77fcd0afd676a93787a602cd1fb63b165f9a7ca0c163b90dfc86f22de2933f97fd282102045029ce55dae6cd649a88d96e20333b0969a6fdd6b994e83454bb205ee61432868f1555840713430607a0e8625ee57b1710acf3a227013e9f28a7fba9e964c4d14ebbdf7b2a04d25440a71dfee005e334b5e441d2f9366fb3babec1b1b4ba2bbe2f4da10e7d2ce90c59fbc51d0dd6a5a32a9b4b36e36915f124c67d9d937157601722c763573dade3b85deb3fb7377bd6942babb400f08028493dce0cdd8dcf6d93292774254a577b8dd1e2285ea438ccf8a015fe9561e18ec35d6ede6fb13d5e2c12222052f4f90b187f488760dfea759f3c17f0a1e496a6691db284b36be2f3f448188563acd4807f74c94b8e0af583a4109a69183934e710ab96b41f6d481279a77174098b6b9f5b76d29a35bc2e93146f067f76fa04cb0df2de155a71107e741a6127ccf711fd4ca639662af97e4311ff781cd05ef43246ca27ba011e2c405508060789ff83b53dc7e2c14013104e34da371abd2b07e7570d59d2bce493da312b1c23e1f95d4bb325283ccd2a7e12903744eb7c59cd4d9a5d452c6c866b6567ee21805adb47b44842116f4b64caf76ec72badd1e1e732d431926001650a2850af4e16f3367a89e81c8aac7869f3b602fde0739a789b71a365a36c97b84440224c8b529c908dc2acf7731fafa057cfed363601d749f6c53d79927e4a3b135e0b45a92ea5b414d4e23759d3ad403a9cbcbadddc4f522473e2c691438ad9166a3f4b7f682ec26835f15c66caa8f96e1d80f3e7a5fa97043682ca095813f9f9f27f750bdbd93c2b280d5deee2a9b2e87e627411690baac7f59526cf2a0558460a9076c1bf61a5a3e63a2eb1e72084c06cf075237c1934a017a297b76bd9770e49572da5380e4fb66b3d764bfa41e66a7c3579488130bbef14d045167847f5a4cf41ce8ada7713b12dcc70d3ff959f4c193dfd57cef1ba6ec4cc24028eb57b59058976cda7e96ecdaaf064612171d54a65629c97723af8aff040ca4aaba66fc1dd89ea88d711284cbb8312968520f4969869b2bf79d40e319f34e569af4afe71d6312ca24d40a89a204f349e00169323a8b3b5fc197791218030babe6d310ed2e16db0900aafc1c1323518cff2e35f9849bb566906d15058598a5493c2c55db660782bda01810df0e8a3abeb2ad4377fccc4a99bfffd3bad8887b43e37befc0e5a39374c5c2e5cb00e516870d6891ee616a57000d2a177227d996db1f6f3d4b98a0f1a8dabf94a9879a3b43738aa55b5b87b4e331445831492f4aea5f1a7a37227ff6213a7ff8f61f9b991facd58f1d3a3afd4ac1ceb6de750660943e81a91688c2131090cdce9534ed2ee55c6badadefe313c14a3ff10475ca49d05599db483173695c0eb26c982a4015112df828915487d0d258d9462d2e6cd363f3bfaefca086ed514ab4853d184b61d15a246cf0bcfb14090f9b93fd90acaaccfd9515a7ecf5e383ec1ac3e0dd708c2d6c630338fe50e81d2d23b0485e92a5df807df923cdbcd91c4ce10a25a7b0891dfae808ec5b5475353c580130d133cc55bfef40d79ae5f91b46b11c0cc2651e9e348f5df0108cdbf2d8a3467c1bc4b5e473876df75159862be017618b534bde833a3939e5f59a3d1c97fc8e5e015bf3d4d93e4289885cd2da2ffff514e4c2d0ce19313aa7df189e8fe59de5cc285f6c4b9cc3f6e5736bcf43253c1c01d44ea7cfa04cf8016523a739afa85591c9a1abf292c9c0261342272100e49aa7089bee1364ab4da9ec4e4f21b2e1b94c1725af785dd0bac3d8bb037397cab072ba7a1008013867a7580ec4d38856255f2a774df440e19c16acab369a3d028759f7247e2d2e964928f937c2dd4fcff310c27207ce729ff87ba600c13c080ec0dedb32e4f2ee0a4b984ea1d61ad5da84891b284d2b5fbe1301bc12972e2a5e76c553d410e07a2b10fefbd8c42ed916179fe4f075f573bbf8f8f28fd8da239165622ef1cb32fa54268b0d8760600bbbab688dbf09d9e409162384c8ccf0281fa4ab3f737e8d7bc242f8ba59f38c67389b6cac33f75aaeed0bdad73eb8bbc60fa3f7a159c61b0f6f3c591c279638560d6da2a32401e348e4910deba763c0d486a055c2b1a6df119765dbbf36110ec908460289eeea0ca4d3d1e8df364dac4884881d6e38239026b1763ede005363b541e669e8da7723d7fbb20701a6808de3e5ed309e088f19674dfaac1bd0fe53bffdeb7b5c36dd2a69813540daeadadb736df19175b83cda3b1ece040e04474b7e00d87b1be725cbb6f6fa8ce8a2e30c6bc648225facf1dbb0b74496fbdfaf3f916a6890247aa945a0b69c16a3c5dae7fe9219b904b944a3b73f7f3e5414ffe9d6e480adfed7557c727fe8f61c13fd743be64f55b2334148bc72548d0d2ede77b79d11f2f2d6bb0c03e8019810b0afb7dc585a6fd4d545c0a57488ab663dc58755ed79171d44f280a90f6edd99494ad44004ce09db49f93112d875b2d09748556c16e1492f40cdafb1a22b2b125106a026068c93d6774ffe0e12794adb53dda6a5b1d4d2b336267428d215a8eb8f28b363aa048e3fd2c6642705b41440a72588cce8e34a17f46850400749aa7e6c807ac3fc0fd78ab28fbe82e0b7c097454ab027e32f6f081452ef86342726f14b2749eb68724571133ecd7f237a6dc3e08f0ebf7df7c1ed423f8cd2e7a0f573b4d7a2d5cab1be78e7589ce81bd4f16989684cffdab522f6e6dfbca7a620f202f64b83ed84149cd8feb16336f4d9b567900cbd3864efb292f941b05bf755e4fa3e657136bd60038720dbdd635dda68caecd2c4c274ba636f197c4e0f7e0a8452c149e4bab8ae1872de9277689c67a7f1eaa3a6614d2051aa5de387cb2a92f5e4706668a5af5240595ea5c696634223287d5e001a4bcff86c2f866d4bd1b4c464b22d3e6e6a98df5d8060f8eb4f153bdbad1d34c738d764f7101de7eac0d20066f9ce2c65003f84f3c38d902380857b7d173f1941e038666141d112757282404bc77711d428619971878013f03313dc046b68897f444da6d215d2c714b1244dd952a68f574756578dfd48ac46eb44762c0746f50355e6979bb8865755234ea467814c8d9823161744b46e49b4b502d47d1ac0d79baa659a88e3daf662d4c6e5224c5dd6321013bdd7daa634895f96f5001b4bc0b3df6f2efeca4157dbeb9cc79a5239ea39e0f0776cda61cada4ee5976f4477682148d9d830a38e8ef2ef45454e164d8b27009b017ea3af73ea178e1fa48e66e9a177ac6bb8f2aeaa2097b18927ac17dc636c39531e42fce5fd1060f2f83711bccacb4d10cece2c380293bb2711f8ce734a1c71731a076973590c7ac547202ae44f0d61fc4f209371a4f85abb04ce511b9c8be69e9273e082dd8243403fed0e5d3bb1949c3662dcb8077c9467ffab0e590c23c75ea552d136aa4d50a83c2474b2b3d0b02d4ee70f26bdbcc9df93926bb21ad6c2214e79d27df0eb3219d055f6c3866e73f54d80f4c4ceeca1152d71a750c78e02ecfacf4c529ccc7607bc8e6379750d67c820fa918533a40727d99d9b30850aab908178e8c3e968180792cc30b0703fbc36bb26f5a7c1753036db2f968f5885441076444b0d93598e880ab2bb6c377b9e1698649f9875625a8981905a74d88a3a9c2293e2bcfc52f955cffabbab235a293a668a7d870d68b25515e520e1da9b208fe82018abe22c9e82b29652b88375f1181b14dc0656ae9feac903e4d4ca5f3415eeda2c3724a74398161c619ad5b2d2839def32813d4d07ed11e41da4e0e0ca440a26c0df40608679e8610c38090ae5df882146dd7e18ca322dcc506288ebc422148b7a26025fd5789942240823885a273ba38e6bfbb11f4d9f2281f9ea79a72a469a9ea08a8e9aebd0e7a29f2dac4c1421efb937be6195510ae35ddf6cb05a88c1c06e01823981d4b4fe223dab5a84030dd6a6b61e74a42c41aa37c1905cc57114f17ed43bd892e0e1c75c5f5b653f716f4dbefa7250a1c675a7cd1327e5a5523171a17ce9243cc84fa9f120b14cae835b9b729b4b99f6c88b240bcdb239f0992aa1d16875c5c3d0c30ebb1b79da0e7d0cec874f7f54c9d8427e205cb6b54813d76c7e94c9fecf44cf1af3e8d4529fba8799d7051828fec4993eacc2151bc52e6432cace1a1aface45762d0bf77c97c1ac68da87a0fc331363af9da987cf47842a56c10eb9ce58a20088eb6c32416e9646b9921914475c3905b6736164a74869950e3bec2d88b86aefaf05811ccdebcfc2f8e11828922627b7918fb8e4e723eb197529fa82413899ac02c5f66f0ad184dfe6075251c039dfbf4f61566c284f4726b11c012cf3d0307e3737005fb0831aad2d1e5a6df5fc08f9e2e2ff423589d201a6b966c0abb17ba09308a4d27d37b952f63f078fbb0c232489c3bb88a50682cf24e0f40dff61b667a9e09f4ec6b8eadf68b882fbec17cf348de4bdcb2157058361a7428b896a536610bb67e7d8f31500ebd4f61d56bf81a9dcff29131b393a54a7b0b594f5f9fb258c2a25d3bbdafdfca687d33a4a7eb2e372939535fd153f288124bdf3298c606d2bb924afe43f2ef45f61a9cc8d9852ee9a5cf958ec7cf54ecaa3a2f8b6ef991470ab5475f6169c59d4a1825204b954d32382f3d5c4cdc944683d8bdfbbfb1dee5e0d974dd367a534669164ef4ff315b42191d6d834f437b7084717be27cc1b9ae62111bf2b59e1765fd5b156d61fec7db1bfa1e789f234879de6589f26ad7b2dc5a9e63952146484406027ebb39a8eab0ff2e7baef83c883237e10640e441e16494ddccb01a777a76ae00f6cef1807f7411f566788be2e56c3ee451f777b18ed1b248d11860b39aad94c499f2d20cc66fc4d91a54d48c284fa0c55add380866db6f0afdf265b9d3ebc372449bacd148b6c2428ddfe20055b899d22814a4c7466f5f7393da9c393b118eeee8fa31236b9a7c3a100ed80a1586513e14b97f8781d1cdb93f3ef9925129ebef3f81b39744b8ccf7a8fbf415f5a6133a794ba860458143a9c51a2e131ce7b4efe743406b51ed186f6f4ece5603b0c6cf60d4c7d60c1e0afcd750e830c47f428c654b5ab4cb15743ff996cb32de2ae76380f4dd2c4daf56bacb15e5997d7ae675a6f81c66f57f834cff3b1f3b6c8a8b97cf39d4a13be31cfdae4d32bbe901319b4c0aadc0647799c10bb6efeae36b588b7f89f61840f013492558a4602b5dc29cf29380230f5f91de304256e32087b70e852a63ca3436f433854ba003dcd9c51cc8da690be8219c42d9cf3cb2c9bbac1fab21ed8d590bf1c558f1907b3ef3cf3ebed64358944d5c19ffebc86a1929ec8b5dbef879347071ac7752c362ace2a76d3284732de1c9252aea2a297cf16fbebf9fc5fdddcaa8da23736796500d2a586e416d6d36c2a8ff3ffa8d40b30c8d9b4647cbfc3314cc75097c7855db312c624f3903c48dd23ae907a99605bdcc3cde62c6c702f4b6d1c982f6096db9600d8f39215c94122481f6f9893361e3287b39f811c1bb2321d332af6a095fd6defc24de731ebe443a96fa114a74b67de4ff11f80ae522cbd5c33a7e86e6ef7b4d2915edcb4dcc1064a8ee5459a5583109cca6381f187272897e16ab302a17018cf2a388e26c7f2a743664201a6879754fe732eff0292b0e8caf3c52a10414c2d4bd6039060dfd2da97b6f9d4e042044161fa945bf967f047719518cac56cef6b32cd9fdb4e69e4c6312f36cfdb3826b199f818af6f0c926d917c5509d6c5fd0b88a4da669c729d7f9308ffc707a55558e95ae8572091dd19b95eaf8a67becfc948748a7a44825d472b77157d156cf42056ca4c79bacab99424059d50b48b6ba58034e35aaafa293271fbd72cb47323e7fa9515b145c6c97574bb86e450b5ae7e50990c02b88165817ff29846702bc56ccdc0cd585c227fe117193ddf9f504d09ec0c612c15b690cacc466939aeade67393bfeb0a5d7a20457574b4ab1ead84517e9b98ceef3257de5117dc2352f06da3712629299844595f559042c5120ca3a1ad1a36566e61487e6ef78938ff0e4d5ff2350ff7d20b95e2f50545c4314aa462cd5653c0b984c4cec6c8a8350b92bcb7b3abf664611b354a0ce5de3dcc6add4ca5ca28f17c4635cd5b635dd412b79feeb803619dc5fbe17879d65b695564ae9298169d4f77aefac639ab180159206f4bb7d5eb4debdd7442e6cfa0ff0cb5d12afeebd893d00050765e62962ac29ef3da37b672a1e37d416aef2ddf30daf937234299ccba293c72619d108f199cd826ae2d153f2b005c7784b11c30cdc636a7cd18b62f2579a2396425cc4a695937068f207dc17c839fc6b73e87eb72b32a2592efc8ba466d1c0d493b4895ee7afebcbcaef84ceb8b29aff19c1612675db2529cc8d9ab992a1101a7281fd231424b3a4253dd54c4ea6983e4de14c69512a6fd01b9131412c1d0a823c9e4925fd9ba4b86a078cda12cc29d42f694387d397136485304c2aa29dd9250ac2f219ca241361d923aaaadb7721e03373ae231f37b54c99a2b4a9a7086dca4989b8cacc6f512bbe148be0b25b8d15c30cb57f41b58a975acf33377fa8f680056057dad9110206c282f27805258e2f81472e612de82206143602a7b01380cf3d48eadcd9b3a9bdf832c3582a29877f25471dfe55b6095217c411b9d6f429e87c4459b358820b4182e04deb2f7a1f8e8771999614ed5b6e21b90fbe873f6afca5271c8e7fee1db4dd8749cd231cf49a33331c01ede843852717c997384b535688865c11117a87c61a1ad4b8933d8cef3fcf078ca497648a5697514baac0e3d8690c2dabf8b9f13983aec5882298b2c58cdd4c0fbc3bfa0764030c376500a9762e9f666446151a4f4003483aea1fe052ec734103aedc3315b68870d1eefc4856e421c5feed7aa1c5ed2688f6d9b7ba20da5c3f576fed092a27d948bb70e755e9992b2aa544f2344ef6fb3391e31e892ed6f9502b5cef51478554565f1a6e598efbdbc6b8bdbe3e4466c16f09d702e07f7ba92aee50f5f76ea38fb3feae770f6462ab3d92e1bbc02a3c5d7745a7c6badb468ad05876b64f03ffbfbfd39fc9fca6cca2d5c4f5291e0511d7632ffcdb5459e4ded34fffdd188b83a27db170c9869559e0c0d5406845676eea7e66275b686a94050a436524e83123b448034fce922b008b571b8be29e84cc42c9223e765865da7f63c00cb560682eb72d5255588369f101bba50efc9c7b6519e267695b7370fff132ad1964516de8fe8855ca93b797b0c36503eb23c8eb4da2a40ce8d545201b389463cd92067879182d079520c58fceea3355d624a8f33970a01ff05e501efa90fd0e77d72e40581b8bcad1fe9e922af822a1f0a67c4fe5cd1690c368619afbbd36a061b96c7450abff86c10be8ae399e2a4447492da95bb72c9ad18ff157983cd3fb5d518f64638cfe636d0f5fface7bf3720e53c6813b8639c8780909a28480e2b27f4337ed794b47e284ff952f57feda258a65ac725d364e2f9106b281acb302078171b983ae04aa134dd10ad13c3948235ead2fce0d1d1393ed6db9de537d578c70b27741ff1f51d1ee983f164caa52e404a8a060798ec6b295b70365361c075f96eaff968a031083b0f6dd69f19e5716ddb90f7db5e40846c413ed6e5a4c28c433872a50155a3420fd3fc4dcde7c17fd755b02cf41f10dbcbf5601e1b7a70237e0e73b7db3540fa770291b0d0491927471798c0118642fee33e9333ff721cf5edf785202b7b0dd602461e29f253a67696717ab1fab8ba02feffc1b3ea6e0e39781df45118a31d80e9795f69c734c730deb2249c408df252efdc8bc50e8d288697dbf2a50f0bb5baa2fe64ef23bf6a913859ec332b0b8f938ae561db1c652a670285000593f2e5bfd472ea760c6ebb57610c7b7582eb9d5a7506aa4d90c0bc2b771190af187a6821baed822fa25778a1719418c753dd92e341fd1f12fb1b57a2a92bde0892cb2af2be90c2950b90c72d3a00c403cb9054ec198b0ef116487886a868fd76680df7adf602cdbed987fc9770398d6357c542e2ba398f0f15538139a308f1a44a62dd2107132acf5d1380e808ce04deaa9e1a3774555359ece1341514aa87c05f99d71ba9525830bd4e654d4edaf83389831c21def1ce67acd9edef1e8b8312ac62f35dab9286fd8a4d74af9077525676838fbadd0f8a0ebc28ce53288356b36244ea81a31b9f7de7eaef1adc385a90f66b56947f5a09db44f615c825bb07483367a63accc69284d005dcf852e51c9254dd546d3cba564bd2c5cf27120733086272fb9986bf67683e13bc781f23e3b4678e592b2269116fe58c5bda066fa5764c4ef6e89c29906d76112f115f8ce8ea7636d90d5b3e4cf48bab9b7fbde33ade44205b336b859d530d6c7bd48e4c6f76d18ad3b0f2a24bf8e9d4d697b5613bdee232fe62d60c8a4d1623a2095c2d66cbdaa3fffb83cbdc7c7b389a293b5f82b5c1b5611cfb2819b7002d7a1689ce6467f26b718d2ccc94e958dff16bf53dc5b84b8638da98c1dbf022f7c949f84262bd7f263eab043df1c512478ba3496c8d4a453d2d014ff5ec9194fdcb1580e87c1c1590eb295fe964b43f6fccd28dc6635b04c1c5fe6306d9e2ceea07650afe32e149298a97e3add322aa603b407251e76c53379e035053331c54a293bd333e22dfcb369710e07d465e9b1281f0e60d394389105c797a6029e9fd13d38dfeaaad3be2461e1424c20eab6126fc4044fc5b032cd81b018f2814c9e8911695cc37765ec217be9286ec8745b20eb9a48461104845263266b84dd420a152333c8e0dce3e26ad230928f9a3284663f8dfabc32e4784d557552a1aef7cc968d18fc8041ea52955e5f49e7d985431e2b00db0fa70bd0244a7356c757838c1fece131566f9549d9c5b75606304b4c7fdebbccd3fe86a82dbb561f34fa61d9674c56fded0564b6c63fe538a5fbac57a9e575efbffb87befb899e2725ac24f551245e082d86ee8e729b390fd0a0361324da9abdf72d9ac8058e18fbd29174621b44809a3aa56531a19c3460f4a98a8a3bbd0c92fb8dce736b002e2105083d5ab07435b380aeff52312738bacf0f29e8ae61eac376c5f1e05f885e16087037af9d796dee7e83d3d281b0a21c0f64f8e7aabf9063fccc21660bc9cd406a3d04c837bc6fe9072ed16b2d5cd88d83e888e7dfad616e83a32515aa6ecc3333deb2975d8df3614f0b51cbdd48ab0e85f5acd708cd25fa0b175bb43a97b1d316a7d5fd64358a89473d9af9f7f1c97296adb3a26e18592cc1aaa900a7645b3077160d71047654b1f6dbc3c2c3cf3fe4369df7c8a2df611d446d0f6445c39e696235565026ac1ad4a7819f43acea29d179824df861da346b8fa8a00b9aa60e20942327ae402092a8acd2aa2587e6ed6bdd09539177c49ce4742ec4a9093314f1fe09f4f3511381352ed01370587cbb58a7c340fb06706522487c9d42293e2d0163f6a3288e134e6645365a7db9b156fecf734f73e94f01ed7a719b8c8da06b9dcb752e8c01f408e299fb4fbe2b0a4b9e8453ccf5a14432affc7a95c1f462cbdc7b7ca0a70b47503fb5bb6956eedb7c5f296ee54457116b07823a3bf471c8b9e495b7f2a27081253696ffe1595eda9228f8f84f326f4a111ffc75d0dcd08b9f1844b4377d0e6127d97b9a852673817a3027e457e128930bf2883b162d680329f298f4425489761d8709a5bad796f0d38cbc122430df8826bec3ccb65d97916d658c5bf89182d6b8dfe4d60e03a2b7b3d562fe69abad2601371e29b19765a29b4cf32597c1ceb29fc47688a5816c71711db7ec7e376c84025f60fa421233bf6a8fedefd912dbc7349b9b8b523aa30be879d35dfd88e551f12351d16ca620a292632ffd82b1e218f5db6c22915f2e7ba453215a227fdbbb325b75e455aac0f2b520292317130836fd40da5160eafeb5d3e1ea1c4fe0e074decd2effcbe76f371fd3f9ce8ab2eb3b23389545e41cefae0fb22bb601b8db7d144b6dd8c6c17af90f7827e25c32240a7a7e22a74219c6eab874732d01e24c160d8d433aeefec38a8875c056fb90716f83e105c46edfaa80cf9bf23feebed902ffa0f2ff7491823f08b7fc83229dc5c72a4c12fcaaafc836fc6c98d27b1ee7134ab688f5d3c129d55a59133e67c7c15c150ebd66fab5fd183113c86a3ea8e9905d7c1b45b368a0da59c67daf06ce0180cda1eda65537b3051ca88e20e959af16b0e6a1c3e0842ae2e37803d4f746a013446216d7177d7d7822acd505009d75c552b0874a2e1059e68f33f9d893c376e440314284d8fc9f89aed1412aefcee72b7887b5f560e726ab34342334619ea85518a10d2cbcade3094cb787f1fffb5bf717aea4588d223e60aa4909c6203b17933915f656bc3ec589998919b49906dccc72cc12acdec3ec7ef95abfe67cd7ae7e450062829b3e0687f98e64bf3e2be25ff05e169f2e1d5753c8de124a3f91fd16855ae8007ca61f67fbedc9561e853cf967fc08aab1a7f53cec6c22dedfc336e4e3a4b008bcae5fa67c2bdfd66ed364ba2f2aac3a8fe1656ba246038a92b423f59e8e3972ab57956353588d088bd4f310aa6cd98d57c9d53f0c2f189effe2635bb97316e3c0cecd532d8196819b3a0af06983d21661af5408ee5452732dfa40bb9cf584951d0be4131873602ef3692fca3489225ccfcaaca55616e42e67defe64b8d2f368ae3e818886225f6f4c4094532e28454189d07e7740b08a84a8320ec358039e75af681111b62d40d60361e0039e8d8366b78516454218159a0b30babe1b98ee324a735a4b425fffac2ff77101db1b9b21f26886c8243fd6495e7ad5cf2d944396cdd24dce43510b63033a1943887a8b9575a2ef245547528c83ba94a74d4b7c1b92ebf67d5a18fab2b6403d4edfc0702d5068aa4b7577cacd6e2f102bcf806c2865bf88d9b1ed23114eeaeeac34f81f6c74a2f4d73046502f8afb5f85e9a4b5daae64ad4df228fa59e94fb1006b523a72c43328996a7857cb086fbc8180c67259f08810d9085b1d1d3fcc96919d261f5212afddf2298110905fb13ef184ac1ad2a1da551542ca9c4e20add7c5498362468754696bf925b9bc55a7c6e1e810dad0098ebae6436f1a8d8575124c96c8b9196597ac7a97f2083c9c7cd66972f59d8cb1dc8bbb063bd7d9cf39d84dcb4e1dc9929d8ba04c299f3fa458dfd47e7c11ce9092f77ff67b67fdf33f43f4e7576a00931ffe98228a011175b46e420856ec77d4098c9494df241280c891301e37afb99acb4b22f5e315df82126e803ea15e87419437dbefa1ce76f656da4129345441b6ba66f8979004f8b71f0b015660c70ac034aa7e1e902ee34397b614af96456061dfbc13ff65997d443f6b875568426924b2c835f9a4d7f4f838e99ada4d7ed58439f8e2df18b8b0404a6d1f651ddee012a18310848c75f75d6cac2b388467d7b4560aa629ade28a1d2639d06f34ed764cf7d2f29d5523c0fddbc7908e6fe7ee9d9caa9e55a9b477a8d82278a35cf75714579f67e397ed7e5de59277d8d5d000db350e63b8f71a4d60723322d316cc32b954ccc33c619674c3229a2b05575834de9af4a4a4d664811921172632e1f2f79474335ea6dd5d8b0bf2d2011fd63fc8cc7841a1b91bde29854d533b91b40f8cf419736fb1c43112b03be3b930bef5ae9cbc0489a82f8895ae37b2e3b90801dcfb172cb411ed17b96e4c85e36e020926d6cb6285cd1f405f3e67a9d14e02bd53428e5036f9123b6df26cfb7a9f02b36cc3420b122db4d1bc70fdeeb431fc74dd9e1e94e9f71be14f1d5ceccdfdbc1271714c56224a5c7e6a767f614b9bc4999bab021404ecb2b798f2d1ba53771ae0f1cb1cced89b71f56256f58f291cd4bc6ab803dce806dc65f833ea4b5af63024251bc57e353f4f0d921c6feebaa80e7c4e8d9a4eee64b83aa223ab1ed81453bfa7813ac0f503dba90f4f18882e6b47fd671726d30c192047b05c9cd2ee7cf3c517a5291d844211a7b07c05a47733e5b7275fdfbd6440d4bb8228a2836ae7c2e264c094785cb9eced366dc3d6844ab8909278952a5673deca896201193d368da631251af79ee97f64b6a2626369df47733ae8ef978961be554608a54441eae363c9b64219984391f70134d76fe34d4a8429d37dac232060efcd8c9f9e411b9d1046032ead12dcf164dc765b99259539b5ca5070bb3a322b663476e62612e232b0e69dbc4f86edea8e930b8e7d8c572f35da9a1ca0ed5b570e241e7ad4f64db34a86779ab224289032742294ef1ae99a20dfea2ed1354e38d33d99c79bee65ffb1ef4430d860de35ba25862b7620df166a06f52aee95eceec5772cd43376d8c9c26678ed9b68a91d92c59800a89f419ad4a250db223b5268f031ace357f7257cda6851a15db35f71f03da21f556943e7adab2bed3d2606ff0967c20ca5e3175abe1475159f26aaa4dba0f8f39bbe4dae174da7369ec5be11d82c2dbf9bdc1fbb49d92b200594ce20e0ce9470ff83bb716624734de27cb35add242273cbf04d31942e56e337cc1fc8e0a1b2ae94497a863707203cf0ac70f75a5f1c847a0f87c2b2ed0928fe756569f40b3c0497b982858604e6dff47361580a0cbf4126664a57ec313f577020748a9a688a7c14699b726af806ddc6c0c2b801ad6da8f70d8297521b678c04d4243ceb566501e6a7a6ba489de40f0fccb68457d857defe28280195ea4cd800ee47f2676df441b5bf4029c89094c668850c1d2ec49394f9f140a5ba3c76e2c3aad258844bb7ff94d8a59bcc68c224c91b4e6cab98acb30f3c3839d768e4af21225f0ef9d89dca2fd4eec88139b878cc4a7c2612e5018743d0bce2cd76fe5beb53da4aaee20646a6353a8bd894c6fe00a79b936664c32c4f00e6fc7204b6de548b1a70892f5c3f7388de3b75b39eb3b43ce007eae1be01ea9de4cdb6634f5ac8bf1e4278ce1ae630b118239b6003c0b70d612d17f381c459fade30c669c07a58bb70e70cfdbec4ab4d3aece3a6ea99946ced718eed082ecce004b91d9e7e57ef13854d5a9714bf3ced14a337dc9e5266b92ad0ff97721764e6f57fd543c9b03eed51041fb6f15c81f27ecb2b56343619b5f3411010fcf38ce184896a18605b7f600719ca7969483ec3f13e054a0cbe6c9942704f104e7c1c879ed17b11e34eaefece64bcfaa66b01493d0880181a29581cf4d05057247ea973edf873686ce60f1c1651c55ebafa8e822e7a1ed8b5b9e00c9c88d2f9b3c5adea1cba4fd36b0de4117b6b0964e538f1b609817ce697014936e66a64a40709cee383fdfe5372a44ef7787479fe0a79c2d32c32a47c8f3bd00031cf24d55b1a45f929e5da9ce43b1a9ed1b4cd1d301e4addd3f4a8cab9cf24b281dde31d796279572b71cf61c2518daf8948289f4bbbf40f857b4f88c369cf4f087872750f22047864ba6be977ecfed0dfff984a85c1b247cde0b8fb8981c66dced1c28731e4ae89660ee6763fa1d2b246ae51497b855857fe1cf5444269dfb8f0aa46d1caee7cdfa0f7caf82d29ae79f41b2ceeb97dfdc8feaf827add83d23f1d568032d54441ee5c9f598e95ce37753b50dae75c96ef8569b2356988b33d42b39233eeda92ecbf53979cf6d1bbd78b8af70676bacf48986e0557729a0d4999017799a6dac2a0f3a5eb0de1273cbedb65a5e28a13ab6e81b8822f39a71cc8a4ddc4d86a72fba10cc658afa8f0233fbeced62237ff85b7ac4b25ace05b23506f6df6f3b6d1b87b6b9e8ccc0376d1ffa9855e39f1d1976afb73c4793f024883953fd4114a1cc5bf9b9c8f09570935bf64c1b485b3e09b98a12a28d99f3e1766c4e8a9d6b0ddfc5b1792efa0ae060b55e6e3fab72af1bf0453c86cf176a6c087a671aac253571819e445458b9d7ecd735e576a1919ac65d56a625af2c32866bd6682cc996016034493aaa2c4d9b3f58c3819d7412c8598d84adec9d9eee8483c7b4603ef108472dd01037952b79dcfa8790760c258cf5efd414c85a97a5664295be4b7ce205e21630fec48ae6bd0e2f5b697049ef577bd90b3d579e66394a4cd7d8bc5474814b394b79489aebfc27a6a2aa23a50f5027daef9ff04e4342a212e55167f562be1c56495ffa24626e927af6d06dfa7e89a031d44b61790e3a693933748b120607524299b0","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
