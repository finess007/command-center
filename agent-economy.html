<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"313a5050b9b0eafd618906651af9fa2cb17f64c7d2be46710446b828674e392bd849deb449c464e5930c6930b2f7d35063f74fdc68169a411d28c843c24a8c4cf78f1f94a8913ca14d0f5ac7a245faf5ce0bcd147d8a8370c15b0995da1c7aa3550500ab01c7a449437bbbc7f5f7ab981c51a631f6f3cf603f025a3b532d90e582e26a00049a2231af093770b114ddefd2fafa151fe17508fa27c3f227fcaf6d5a9f98a65e5cfa7f0eb83a947cd7dafff2ea15138d80f07cfaba4e9b70ea4f44a3173b1efe3824588097e7aefbe7830e002264d8c535b4e1ef7f32b01a53ccca880048841ba90b4af8c7b764e3cb3a1e22d1d8bec889222c1493bcbe7adc12a9f09aed146c0f4fc4309c6a56a0f339a7aa51b744ce995a489b8561f6b849eba1701a77151a8a504e9bb97b43fc13e13b3fa11630dc2b4829e33bd8e5bf451263a825e2abbb759c674c9e2af4ed0ad3fd7af9beb11ac4f6c5c92e7c2db7e87e206b8dce43ae05ada25826b3f2752fa163568b1360e73c8ed94a5b423b2c59975eaf6f96eace30d541dc4100e81b8fdd88e6fcf4c8b801fec6c3b3630d2c1916a30300695556edd96fd1ab00b2bf59773ad0a8512de184d2c91f94a210e034fe365acce4b2680dd882632153852805a8c3a6db370147e83292eb55e1e187a46129883f4ee35ab1e1a45790797486217d635597faffbe61d3af5322fe3b5e4a8c5cb476a9f97226d369d139608f8d90ac5f85e1e5d70bf3ab742dc33a5461b47484c87573c91a0c3dcd81c54c41752846445b15b8ae6711b3841439b7c90018a5453d1cdd09e5720873458ba89c3d1d35154cee664c777803516f54a4eb9d1d1070f96c0b0ef355567e40b8674756756d79a9cc7f494825f6c31beebf10f30b3ed0f866125233d75af5f205746110a39fef1f4aa3eaa03e89eade27ebc9b78cf3f98e7a9b0358f420a9548a14849731324500b7b6ef66286557e63087145649d2bf2d530615553cacc03c225a4f6793367c312dd872b426853bc8535e7c72b1b91d6c358c3b17dd339172501d2f045247cfa18a5af2c05bf1752d90f7b46a9873343cb0c9c9d8ba779f4e729dfff78840d25d004bd11d385c6aeaf9c7b09b8ae9ea987d6b51e751fd0c93818875fae15c48b9102c07cd42c3259a1ec6d7cffd6db31536fa913ecd4f683f2973e4643fdb96a9fb311e924986ee2b68ce6674f2256791d1ea3ec2a80a1941e80d8553a3fe477ae9874e77ba95694eff964c1f8ea4449aa2f9d341477f27020312e792277bc5126135c7f72513af48427fd181d519ace5c90eda4866a9d73f51e7a5a8484a0d3693dd89a853fdbe71a99bf020aa16e038073dec42cbe333d2bb63eabef75a0e23ebc04de45243370c85985962c26e28e2a2397eaaf206ed8e1c0588c06885415c578ff2f3e412246f08a0620a2523c182893f8073d2366e9e1f47aeb316e06c769254baa0967c411be8472d1cdbf7bb6a8e86f5564270bf3f1227cef957716b22681338f373e78239e7073d62fb263ef091071094d8018e1ef7fc5e28bec9d23e3b8b3dd9e69978d725d6cda9c13f62812f6524b1dfe5804b9bdd5c313ec9c3257f5593f4a1c945319664ad68caf0bcc0dfbc4378be14fd30a136460a9fcddbe4a9069dc6e43a5950cddcc30b4e7456816888080524c6ad1ed5261a9cbe04a25548a0401d7c2021e226089302b46f24c8a23c1d29cef065bf954b563199fe6eaff912bc1d4f8c698e4980702772f61c734d1d428fc186696c8e7437cf73f9b18e03b554030d7afd610a823bb2145070d5237f575095bc632d219158b086d8c1c0c5b30a7a8288778fc108a6bb3f5b804b1b04f3c46aa78dcd0dfe233f9603fa2d67b2d81e5b344e2e95670a33de422d58a0218896276e02e69aec95293221ea1784732d00e71dd38c6027ad04d0035fe3049a6b4d981aced9f63ae5d9a5fce5f2fc0db8b608f4bedd155569067599b5406e6734cdfbda18e94508d644a9a92cd9da9bf971d6c6cbc47d91dd0d64e6e1a0574077e76161c1c6258996943050612b565e737d3f913be80cf71613f8415a8296080cfd3d6f6d995df97b44f320b2eb0ea138ae364dbfdab4275739399220c942e9c2eb57ca00a1b3d2b5bb0f52f10ed1949d0f1ef4db135ebfafe77bf259992cf325e32c8836d48078b756c9d99b9db659f1ef738586ad876ad012edb75bd0ff060e0468f6e5fcdb01e4467e2062983db558d984974894339289e8887f05b5a17384e7877855b8c0f2c350a18972656e3b128fd2be87d1f3d5bffbcbfdc39877a97aa921165c66fb72e61b4b7841691055e0285d46f452fdf16763ce58f551b06dfc8812e9d8a79c01617ba3cf381ff98a69d716558d5f8d863df150a57e64c260cd6d47b798bb252671cae6c19b713ce7775693a37017119dd9debab880d31d1d39fb6308bc647748cc6f687bec8248f97a3603d13906b2c136a7767f150ff16c9971cb2d8f6e65f6624003e95dbb8127104e2656c4671d2bda6fc7d3e4e55f24f63ca6cb6dab9266787ff70259c5f495c2087cddacdfe6059f7dffe64309c99172efb4738a057bf6caf0dd2b1bbf177dba35a6540f93c4813a00bb2e6f6ed5ed0131001bf6ebcf295b550f863cc515f92ce9a70f460df2c38065b14cda50136f2f8466f4997aabbc9de5528871f1a7253ce52f7ddbeefd5af68da80e415e398ff8e239acf278e6fbc630ff866bcef6666a6d233bfe399ce7eb5d559ea6214c0e232be74617ef29a38ba84bab6f7f8a851c0f80e536ff35984f0173fb099ca6cb8876f13bc31fcff4ee8d46ce40f07156eab281ae6c482b3b0cd61b70023b5a071da954695e3138ae14f934be8997f05660f3e0757a02d27c58fbe99bbf2c7e07261488c95b5f3861c96759d86a3db8548bb1ed59572634e7e9230ff7f16353017df107ce95eb4915b48db520c93e29a0d9b1308617ab4f2a1ed9c89b69d1b417e1c2d9c95647814e1cab772a3d0366ad8901e8f1632457606982c950f46237b703f731592fdf7087d9e5779e2b1c35242b4219b611cd309e79ac66480ed6ac22c17a065b50fad03e5623fb44e44a042f3bedb210ff9859a1a4e5ceff24661e9a138a43e081d30476e055f420903ac42a0c4d6569bd09690e0a34b4e3f5ac827bf334ad1c91eaca2c1e192b27b7349a229e7e94946ea87439e3e8add1932b932ac45500b17187bd8a01cda246ab7fd3e4ba0f2088043b0d3e3cbe9d2333bc98e249b12da7c60c805919131f87d652addb727a3aac80a1fa89bf66f66009203a598d8c490c43b135f0e79fc8bf0441bc6cfc61b6c70803c40a6f0e95d367a72d92c694abcebdec98cc37a9bffa2657c78544cfa2df0405d93e3bdb3661f9d42dcb8bddda18dd75d9ab611b6da1abecbfc53513025886969f2adaf218611d4179ab6dfd8778ec8b82353db7146ed0bda02eed6d0c5e3f7295b7a8a0d1fa563acb89c2b89af33547c8fb1db3129701063664b36bae64fed24d2fc27f9e8da1cb5c2e6fa82eb7c1d7fc57dddff6f4e501100b948b9b9b37d4594badee8a757c3e2d391146e7eff3a30e7c47d4e5907e02f67927624d35ab1f4c2b1bf7cd7a87fc61bfb878abff6af919d94bfe48a5b01aef071fbca03d63232136bccb6ca740ebbcb97a8a0dca7953719185b3dbdfdc49d0e5df2e85a0d074ec97757f8efecfcd4372b79fab3fc48ca7fabb6995da80974570c0730cf9adb3ec91e0f2c667c8a2ce9408e77d88824d3b0df30666907a99d0d7838af8282565c531be41d476b841720bd6b8eb2bae6e691c2a7fbdd25e16716141a08b69aa16b193cec2e094439ff0f2b1198b5c14f0b3fdb0097fbac6561b387e8d73ffef750e4d84147fc1b5b3c934e9a000901eeda9ded8e4678fc41a7556aaa25e572493afd35a1b36d6a0f033aece26323091fbc59c5145c5fb0db5b05dec1587ed2e71244f2debdc81a4f1465fe9b1c8c913524db179ea7b31b7912ca02e851b14a73ca3bed6dffcdcda1dfa3a2e7db645b5597a1f4a369c4f842e1c9ab3511a42fc437d79a17eea1fa55cc3b43dcdaa8dffade2794b2ec347848fc2045be06d23beca237ef3a7082758681187e8adbbf5548bc3381ca8830be4166294974ca24ca52e9af8edc7bdf206bf6c288218280d278989070f475d07e636f172b0944f5ea1e644e5a027bafcb7e8b86c17a4f7f6e3abfbc092c05913e0da331a2419ac471aea6442cf27680b9ee487f327061f40012563bfdd9cc1417cf3e3737c23d40f30ca58e196c39bd1f67181b0ee075a6c4c156342600fd7463699bf9d31d1fd3ea21900dc6bbb33f2c2a04704c2f016743b675f4538513780d21a34774086513140f9027704e1c62d1e4d0f924ef9abd0f5f2640e83121d68063e9aa137b260263a103bc658a96a55a54c8352205db6bcb220da95ad59b1d2f53d1bbd0cf2355fdd27fdfef819b29a468e54554581753a67d8004eddef0e61f0c04b0b8f9359748377909e68f85b19000f20c694ec634bbf413c3bebace56c68db063d78740183d8e5a5daa9572ec3b774f5a4e6e5a0ecb8b04a66dc3fb63dcc1634a0d555d97e10d212ca6738fe89b8cc4edd7dc75ce87d96d9652b9761162556c05b6eccc91ae135fd59aa20479fbca69267cb158f8b28d596fbe1eb2e31f2351a8a37c191bbb841fea853756f34e150e04e2a0e1afe9d6fe9ef05f1c429606f7370e5d937850e15c741f8b2914c215a1f1ded4a8d577d2c237539aad8e0fb72e967e4edddac580ec0b60a58c08d9d24aef51e72ed4471f41ced3a2dfb6fc903ccfaf82677f9287f680cb1288fcff81356840b96ddf44d408895678929a886507b102e187fdaf0029a70cfb6433f7d4a479dfcf4e9ec6262dd38c3f10f7a7da48562fafeeba749fbf649f6964e125fe8e68759a7777142d08eec6401562a4ba60435b1df18b365f09ef6b70dc467f8b5245ae17266896fc4200963622fc58f634b08c859c12931d45b38a22fa114b25a796b86a3380f1286ce6971801a1ce08fbc9761b0cedf7ca505746d4f49a546aaf6a4525cab13faf43ae7804e51239f3e0b679cd9ccbe5009c449f828fffd85a02261d84a7569b872ded19615f43b4cb8cea8243fe3e71447d5c8f959cdbdcf44347492e124bf2012eb58ab04fde3d51fb8924b2cc4b9b476a1a5ca3b45e5d54ea9f31cf23272ecc2059b8b961ab2392284583d1d61f4b1fc35ccf752a78b369d0c08f1f7ac742686bd5fb667d01f2c0b486e73b37789159f4f2d25150026326454f8b43bd34531777c0151002c6bb780b60bd49b5d7b24b2e65ee9954f001a7f412b43c6c8e41bc094da9373d444aa80ed69a1e0f2b02a39207feeb41a69146ffd0fcb1559157f432e2a3a142c4904904f57709d8144cb3fd52f2158e6c7dfbfb7f2641628f2c68abe8e6637b3d2a1dd9273b478f2312e919b9f4097202eb0402aa798dce041a5c00038419e6220fdbe17f69484870fac8e7835d5df6b37b060a9fbb28b2d742880e111233c52760e78925182963c5f1dc7f7def740473d47bc2033e813ffb7aa9a53d48271790631f63c8bec704f6ec71c4c0d28d8d09a4a1aafa4d4521dcb2ab8efd4ce878b7ac9781455271191c34f9ef04acdcbadc66ed477a6f1042786c78a05794e0e06b14a918173df8e37365eb7bee117284b6cb9d254b9cdf06011a36341b00d2bfa74c14007a05a8609d6b3b653b8b16e31c4e432750c71e7953ac4488e9c792d32988d51e1e17605b3525ad5cc2434e4e1f8f20afbc161832605142372bebe69466c8d82366bf7db41215313ec6a7dbf8ec8c0e0bf7c1fff433a0650002e295f744ed19f087cdca0bce4e747b071f1cc813f21c62d4f7c84cdb412efaf9597ac403f328396cda1e40bc4c21b74b4eebee8c80105b49de5b75e04207f546089875bec41b3ec03dbad158fef462d5e5e5f03541474959969043fd4cecd5bd7c4ce6301a6c195c5197e814b4c9b06ba2b51c22dc8da1c18bdc52acb259de73f6cbe484a74880d5b7173dcefaf7712e79a7aa65835fdff49203e7a796da36e1371378087db838cd553087bbda8fa23b366398ac795086d05678078a4e628c21f53a30ec2c2a3d04e9d26fa2d2ab11aa953f23c378ba6b694d346f264ef3212bcab8c214c687ad077dc0ce6910a27e705520c36ee5c133ba89b6a96a1f79a1f2488f322a0907b429df3fb96bf487356611a1c9890fd7b42dd9946634500b71be61f41c7514d393acfabaacd163d2a9b80c1d877032927f39526b5b9896c19b8930f936d1e4472c30c47e0257e3793ba2084bf0baa3ec9a382728da035bfbb85172bd7f87d183f10ccb135bc74b9726bc8ab021c9eb8d02b6edca6f73710810b7cc7cc9bdaf0da093522187331a8aec70d845a51dedd86395ad9c198744121b5f34407b491d873078023b3c2a8b30d60c52f3b9fab19e4ddddc0c3f3447878aa49dedcc6068b9db141b76211722f390015e7aa54554594a7ce6146c3965f082a1f3dd1025f23d1e63718a813b31c8de367eb718c39f33623a016d8c5f11cccf2d703023fc7a48294fbb115a68f7911d3e38557972f74615633698029b1867cb00c9b02ad8d205d3c2f2be35365c218ae3ae1ebe029baf9e7fb7a8a3469c2c561f7f8a102b17a1485b731ded8cd031b5aa67d8959435fc125943cc43bcfe4aa25359d0db6959cb4b4bbbef290eb3a4f7f4df254b0b7b709af1f30cdd2d9a72170576c683dda2d8dfe95aa325d7aafd843a998e936313fc2b448b36a1852998ddc749a6faf3248b61d9b5d2ab6c1c48287146a3d3b41d21466de1e047811465f01616588a758992adc643923006502bdb07b485bf776b9f3c3fcbb9d637e64e320505308e2746f97887975b31bac9e12e8373a94a39c86f9af3bb6036f3ed352bdc02f39ffce98f0a4728073106cffae38ac2c867bcf45ccc98230fe102f79d5e99b1eac2d329917adbcc40af44b658f148527bac5b208b6905d7f8b53b3a94dbafbffa429a8d5c17bd958369ed205189856e701c8e891be3d472c1bc9fa68d072aac0a5ff131407e36b22b18e5d9d7b809daa010ca2def3b8d9e2257b70e0436cd023249896f8e872c5ee6ade32d40e87e2c07e66e62ff9fc60362e9ea6b22f6b092a7fa58fc5ea567688890cebbb6b360ce922a0abc9aad312601d1a5572633970f72e537073cf80f39e53ea4049a2ab4547c173a354069c8b8c378f0e56bf4893d79f6b4fba797357a59b5a3c991ea7bc13bae48c598400ac2a64cbd4b4e5cee865582fcc460bdbf9a4a417de8f89b8c26a42c4d7f9852fa2121e5bd78933cb000273b776006dcb5d7940dc882eb3ecf0c0452c10f5ea9c2e2ea1ae9d6d816e722425ac95439de40b58815ffff99e5db8db8b5601d29207229f37cfd16d41ed70cd09e3b8ee7c0808167707b7094f153415ca2384be25d41e78a3631bd0749d6fa35b29f70601464dd6786dec6397dee22fcc47cd21d5780edac28b384ccb22dc56f644cf983315e47a13f5da0f9d122716001d2d65e086cfadde9b2a0ce363147558c2b1b8b7b56470d18e412bc66a9e64867aad7b0d6270c3ab82b4273f1370f93f25ec01795bdeb97aa5a66e11da96c81f391a5b84cc6b0d289b4ebd2c656e3b554070143196e99bdbaf102e77a233104041d978ecb7703e17210d465527c9f23e85d1eb14eae38f8450077301a2ba49d70d59335cf736f17fe377a91be01258ace4ee94bf6cdb3c90c88ef661036515343b79126dda94c8038f35c7ec942a9e2acc42af9e77106922296ccdde3c7faecc79a72843101b6c0b7815b2162c6078e00d690312426cc19544e004979b45a5b57487beda71ab89f9f81d3c6f4d470bd26350d7b36dbb84d2004d35a5a3568def55d74bd9b76a9ad1193a296f0cdd2aa2f353e30328142aa6c2091ed1c2e208707afe8ceefeaafbc919930577c89dd9b57b0c12bf05d8b2c158c8358fa12cb8b73b55984acadd0f8b795aee633017fae17a7227a6b167fe7d6cf264ee75193951851f4184bf57ad6ea49b544a82c2abe1a7c1830513c6754b4a73146bf030423992d4e53a91491b7c247e4a50f3876ff770f988a908ec1f9f366e0c82d76e98596c6a1d23bf094643d0a27006297f41ccbc985db277a7d95ba56a12aa957a0a3825d4a6e35d52f3027c6d581ee701d3321994d3f8168420cd2e20c08d07ffac0301f6f924cbc68d933cb2204b8a971cc5f935060547e3681bf15d720d9ce8ef5ed46cc55a9221a6f304bb77f30d492e10dfb7d0577a36936b86c771cfbd11c8842a5dd28cac52a0972fb9e9d10463fb2c4d0bf89f039a2ef477e82a138d5f88e9df9fb11bab4a1e3d76ea421dc5d5028723a44db7c4c9c5d5532022aecefbd9f83ffe36f6aad00b109bed7ef0fbd61bd87c11794167e9ada97700cfdff765127b60d38cdde1499e8a434297e34da0d96fc61a96fefdcbe2b3e181f4d965d24de839a3442babebc394be1daf94535cabec804c221fd2df993e2bfbce6ec6fc00692d081a9193456a900ff9796099f8449f0391efec11c13a1044ad85a355896be3d97659e0c39da04e41380f38f457ff072f51004ce21be21dee0c6532d9700b01cf95d06f57e79476c6025cd85ba527e7e53d3e4ddc2ee9d5cd296ba4a05575fb3af673c58b72003893064b789434f2326e46e871f8b7bf4f50b1d56055741953813b0ae9fc1c35b43a27c9e6a5b83f73fd6d73d9fa44d30096fda08d7d26656b9c2b29961d2318750d1d699fd3141d1b100830fb2b0504e2c7f77f45296ac9013ea35fa2e4d60b9dd2f2caf2997b773f39c4b041bb45da4023d5fe2855b4ba2649b4a8dcfbff70ed3aa099e25f740530f3402837e173f23fc31367079e6ad07ac66878e139fb27cf4e78481b4e57ac4bc8fcc662e12060dd64d3190f7ee4d865d7b45534d5f3b49a10060a3f1a91dc5fd4f3fc287dde92ce67a7eb0dd25d8cf1f596e69fdb5c91903b424bb77512eb8e8f4b9ffef035d6251a0848110e32106f09c00aae6c0a99ae14aa3094634753350661eab4fc3ddb2ceff5e6bc867b71bb9a01ba26e49d742dd452447cd9141b87374a3ff56f32d8a47aa0fb16510f0b2db09f40f0c0670a96181d9d77ef0d2df17f93564e5842d924993de85ef64678eb1586bd2892c03ecbdb99f939ddc8c819fe0af39671a947b7de9d5e7a539f555545fbfe6b8e6ea3916cc1f204cccbd08b46c9ecf6c4bbf5a0eb1847de6185410d2c50cea96954e0b370712a40fc81821ff44555ffe20ab1b49e0dcb8658ef7c3a5730ebd7c2b635d08fabf2e6eb5be9f64094975d72fb811bc200333aa8068c8ac235fde3fda3f4ff28982997794ade12c794ae1444d74ad7fda65f628215d54cc6c982a84200c1f512ce44f8d083cdd2ea89a61c0a218acd55971cf6358871d9f0cc79706a5bfceaa49126314b67e5f920376e6504787068049f18bbb5f97da59108bd49eb32992c9a8728c31e71347d0b0c4936a8a86d75d9640d70a6112681aea046fb69bb4669039d3e80905069d7e3e6f83759ca3fd7e31fe116763950b711f068c211286a2e7ba2f9fc9110875a458d125cd7042854b78d6adbacf8242b83f50f51386f7068c0cf44ffb949d353e62577954dab3aace3f2fbf22fb5540c45eecfa74a9bf222004e5cd2a5a09b401c1daa981c7b8087668e82664d01f8a44b45909f7d8599cf9e1191f1ea608bda72f3b2346ccb08f03bb47281b4e425eeabefc5345606dd96546b2f3953ee82c5b087e0cf977308b101c1676cb3d6a869efe6946719973e196fa756649e756426e1077d917f5020ea857ffe939395d8f731e7ac32d28f5f261ffd246681dcf45ce5fd900dafb9531414768f3ffad26be1ded8bcd01beaf1ef5f6188bcecaa3b5c655f2235c74227bd50d460d0a7f4ff9f8654a9a9449b5c44ef20addd6aa0c920049a931ccc2b7f2e1383da4185389b6db02ab7bbfcf85beab37e420cfd64133b9f489f2fdc9632d4b714c7825d9ddc2394f16b81e1c0c40ae5433d5f3c7844307fa1629a07019589c077bb134360a144ec6fba10d0282fd305da54f7a031e6f11717f85936ec8c05ba0a5f4bd75daaf933828ee6f98715365091f217377e5e257e478b491544e005a082f407ac3047792dff675abbc2ae66d8f8d81daa365d67958483fb413b97874267be3367b89ee367ad4592ebce217bfbc15d222700b17db5f3f827293f651fe1704705051488267d8914495893af883a26058fa9298780cb6b3c9cbeae4d5a540b34ddafc94ab0fe58cb594f65dbad396de9204b0d4f6f7fabbbf0ac8afc011eb5eb9d6e34263dba7ab2391f0dfb4b5ff86a32187e358899803d2390265bdb74ef990cec75b53ef9649757b9349d72d04aa4937fb8f20a851528a09d4774a37309ad400614255cb4dfdf15b48425322d52df3ddb61889ce1ef4c12e96a79a223fdaf46cb347f5c2ece256cff8ec813643bf72418d55f1ed5df58d591840a27f5f2e3784e3069e2e2ed5638b1be9677b3f700e7d4593767123d153f5a015f6f4815f7f0669951c46e69f44abdc912927055fd83763336bc0303792792c8ea718e7892a1be00fdf00676edd99288906fefdc3923c7b4ace9f835e1f7a2e8cddfa224e9801f1940c2404f2517d03e7283a81f7ea9a8afe95c2f1cbcf87cc7b12cabc9c173d54f916e3b09b9beca90e46dffe11c0664fcce44223040b18a6cd95f61a2a67245c0621514b6501a3dbae1ff51926d4f02697044eeee8d6dcf65c8d9798edfe81b5b7fddc8f1314ff59371a10c35659f523c28bd5a6ba8d0b2748c25f9acfc9eb9d352a89b322fdb74913d127725e6b7edc52cef89dffc1691cd91193b0df8b667652f43fa09fda3e719908796b08636ec20ec7cd67a77d9c8bfe823019b2579825d9a53443217dbb742b8a5cb3f7d4099e82b6a422af5c933dc1e54eb67df29807a83c518c024643244d1ac3d17c0cc895b4f8e3f60179465cca99146f0da4f973263432ef41251223424c27f66075bcac24188ad31e24a58452e828c7f8cc6856b80ef5ab6e66b6da9dddf0f281c4227b1b6874fcf6e5bf5b7478f30e58b8733e498dfd1ab76dc0a48becc2ababd3bea5b488031774f13af0c3f56ed58234e1bfcf8df90c79fa5a255fc8d1a2a1b01abbd80bf6716b72525859905742ead9a97e9b596a5a3ec95132f8da18691cff11c4ae6d3ec7db82b08fde535b398af2bd69d627f25474ecb42dfd097a86d37df1525d1b463f8501ebfea176af4b5f20de3ff229b2f5d22654bd4fd9c275727f902a6258efb7ca0106d3b738b9fffea2ecb70d69af20ac8762467ef9b2dde97c6981f6529a92e4a4f9148dfdf1811f5f0b750d058244c611acaa9b8007e865c998b4e4b63efaf81ef0c0835de91ffa7dd377f8b4946730d1b9161dc80f6745cbd6c8244924efb03681d5b8474a9db1181044b97118f975b2fc174e9a4576a86f4c6571dbac45656174da48162a1a4d219d6b9054808ef823b9baf412e591584524f617e73e39f883410967260c5579d5faac16b83ef145737a5761e26f4ace6af2aee235a0eab542018c6c029c46a5dea375dc32ee16ee1545f4757de1586a2ff04f26292e32782c63212b7f25004f59f29bc69f2dcdbeeff399b97547366f613b5e4524e8af60d4b1bd70ca2810969416688198f051b142cac6d95005a1dcb3f7a4f509ac69dfaf78028b05b8988915b88c715c321631a450c20d7d7fb5089ecd3247e2aa3d752b518553a3a20ed781ebb0105bd4fe25d3994e96de5a5ca98dc991f1767d8b32874cc11f08f5937561d1824abe8d91eece1440df67724e80fc40b57758efa4aa32c46caa4a3c42e6211097ba1e38bc66e2bf8f2adcce480adf0365891d73fa1a1150386a8574bfad60b29ef8bd2a8290f60bdd801251488b9a9bf3621a1150c960ac447fff9e75b4c04126fe18b9cecc42585fe835d4a12de47a535a98de1b8e1c7f674c0331878a09f565ac582d9c705b73059c38f25aa1e2d84a606f2be577bf721fa43d1402a13437933d7e03536b7424f9ba73af6be03e9c41c1146cc660eb8032a79ccc4e28982c785858cf2f0721b5c0eb2a001c38959fa78f2bdeb4a7a69df88297d252b5f3d5c1cd468359dcdca3dd400246f74a8e366937af0ac0b2b5121112d60136cbb9ad2dfe58e2e946f155396d4923643705bbb43d02195583c81eb3b2ee4abc0edad91f5aaddb4f2f9059464a713e3d92ee59e6ce2189b160c69b1faf3cb5a5f4bd8aae4aa675e0058b4cf3cb6ca68fdfc884bc505ffbe57ecd3b07095e922b068171a152a37b981f455eec863b2bd7f57c24899cc612d0bd90d99e383ba2b878399b510b984de9080c3ec2d1aed1fbf87bbfc87762c92726151d27c14692f51ec5d3c9d8a4111c5f6d784172bf72c511e2330993a3a3c86a937a52ab9bb4137fd6b36eb9633f3968a4edbdd11a8aebb015e2ae481bd2b6f6de2aecce12fd3f1e874e5f51f5d0222134d693fcb0234180d33b586db749c2a6bccdf4d35046c849b84b45f1d10311aedb1d61f14dbf8a3ed47863e0f97d3ce3ea34cacaf34bab75a72a94dd48092e54615ef68c294a1533ce900bb7101c812454b3df21a018727e6cbf03d594ce3fd00956338a9b8cd619ba0bac5dba56c471c5fa36a99ad4d1f715d68964b3f87abb776addc462123e732599b50e03cc589e70126fad38f3ec57366c6a6a013e12a013f69ffa848c578a8bf49675e9c9ce2a1654dffc1844e389a264bf473ea27208c7f43f5641dac20b9a78e82b8bae0b225ff2f32d1e5b5a94a2c293e036321ca143768c6bd333ebfa140277dbf8e56b41e2eb53dddc95a38e77f576e0e66e59a569cb44c1bb014aa805b6ef97d62b5dff1c2ca05420c194e7b835073852cfe05d4867f33994ffc2d8386b3d8b9ab8941503b780a5cb4a2622679b36d4ddc87ad38a19924730d08f21f1442a6ebe9f5cd42990c28272e5e276e9c2d1e6d82b8e6848ac200ada44762198f3668bd2b65e225684b41bbbced33d2a4f1067e312bd18c90347433b52ddfa6e8bd5d4fbbe009515dce21197a37c9086a9e3d9024d982c386fcaed355b6e7c791a629a4c5bb741cc1cf6ef18798f079997b62bd06649238009b5f3e9a50d7c115e286f8df11aaa11afa3d0bf8c281b74d2f4bedc69c8c602c7a1616e915300ca03d551c6352f444153530229a8bdd411a5ff2ee03de6eed84d47a8745d49a002192801ba8a7d966bf665ad8e5ad48bcf64a9ec7545c0da886e40a6c23ec435589fc64462ba12e2fa49c0603cfa96e835c1b45a630e78569992fa9dff23a26a109fb752ed60c17f59f9954ea38fe1e183a741bbcb708412f6912ef368f08f577ccfb114499b4dec505b23ba21788032f3bde4ed439d843be37dbb5832eb9c9ef8a6047174ee32ddfdbbb6146db0d09184e681f9f257b1ae29dad8f6d68892b41124d48de77ddde000ea3daf3487482025f9b9d5fbd3ae3d9e935054a63e97a2670af2435d61369eb9af51bacdea5f3151b3a20923f1716c532999dfc7e8d65368decaa48ab392713b5b20d21357d4de169529e5dcf54156af05472972315497fb6097cc18045a5cf26cf1c640da06c447a1340b939fca505c2758c830e8f554b5bf1f93e1f4c7fced4b5e561b302b42838bcc43ba6c59b73100dfd280b84262f2b45c746bc84f3258346d957cb96374014e903f6fc9c13cba05a3dad918a7e336d7e4f9d4467b97e4ad7988a8b5c90939f7839d0c8c531340e9f892f350bcd61b4490ebc9feb1271bb7992ad6c5d69d6476a9022e825890617a82cdac0c86cdc1f29492f3860df0c5fbf1fbf7c51170439bf3ee552228a29c8e8a8058b790cfaa79b08a755aefd3b3af0546311bbf6cd8f6b464277e65e24a5e71fe8edec174484b85c8476d17a15767ae1592434535da58c8b3c01211af53136649bf602cb0ccb3af813919034b10858a8850fb8dc98c7e95fc58214f832a50f6a0dda54f30e41d3daa8b51a20849621b4afb01c08d9d2203078bf8d25606314733298d3fcdf0a026bd9ecc95b2679d1f8f0fcc43fa18e8afe349ae68b9a503a1af501eba6bcbe81984879e1d0bcd29998665f1a6c43ff1d7f97fc6bf53510c3b8cfaa4b2237d0d224b1798b120a2fc7c24584fb04e1d4073761f7fd5a9b454256c7c253659ed98f14880958f749d4bcbab7432bbc514ce3c1c79a70de1a3f46cad374819d34c25acf2fc5c86752e0f38cd3ea95564db9faf7cb7779adb28255c375e92c6d1621c5227963b510bfe8b66c5551d93e7dc7ceeb03f3c2ef90184e56c75ecae70425a285d48da3b66584cb8c17c0004b809e5cc745c20d5a77b46201a8235941519e4d6a8caa9ab12f531b691bef5a43df3e30372ba44109e14a66f1c649d0f40ae37dfad530e95a71ec147d38ee94d8155399d4315dc753a063b5305dbf077cf269ba07dfa5fb27682e5341d8564aad83305c8aac6dab9c704d0211d3e78c4c4d54b6f3a68ac1bbfa8b8c0e32540ec436c5baf017e1b792c93a565c787d357f96e973b0adde8aa7c20826ed84b245d83dfa01bdd6489cd7cedc95e00c01a3e96d4dc620ac0f30d476fdfdb05a6887019de2934770e382d8230bf3f98861a3d7b5fb2208421e4fc3dea568e8973d73cfc53cc3e9b9277ade936c1317a1b5d2915d1ee588ff9ba8262354a97a39c249e036945a8490e1cc03e986fa1698342af2ac2277041679d916fa9540d9dfd456329cada9a4e957d7115e62ec472af3b6431e2cb4733818a49738dad162a20b766eb44ef4fd303ef8929a70585162f03bc27f8927542ceea6bc50af4c83a2119e8d6b6b433f623c4e22562df9e16fdd773e8fdb80f911a1dbae23d99aa0e525ae26d269b42a0e6fd63e281f42ad66bda2ab811b903d9da0ff0c49e9ed8b49c76328cf88547c84eb7ddda01e44f2b0902037e4a706760fb8961052baad58d825f2852ade3fddbf723697cd9b385ecc6d3cdc2b0467cd49085e8139b8897ffa898d3c3bc78e9dc9bc111c097192c92bb75b8123517aff85365907fd7d44dc03b4a06e98e94ca7ebf68bc47abf48fb3ced1b7867d45f14b67c5b83f57b5c2537465ae9cbae530116977cbc60ba4ea2b672713295d11d380749afc9875e5fcf76d1d82b473d3b3e20f0fdf8a6b44bf56b4953cb9117a9f6a9783b223cd7f4e4390a040058d2254ba03a224b266484edbf672c014a583bc83c1ac485312e9ef352c0d67e80090d3ff2042f7c0cca60426d52c10028337abcc1a9b6ad3c6d1b10fc2ff4a684eb2bab109326f27fd8f78776ac569f90ccd8a7cd438019b3ca1e38b4d5718d3300853930c0c9c568e92a4b1e5da198508b578612bcae7520c7af777f0aefbc8f3c0cd0a17f250b22ddede68bd710dec5fb719c2fe3fc4ce6e82da1cb6ba6410493eefc27352fda5139b0ad707737ed869f46630af802d4a41e201fc015704ee5cbc88bff77efa628a859af777d8f0558149bf59a0410c3c92ee409a6e9d00b7af404da1a785f8ae542e54872dc512a4cf6bd1ec56fc06d7eaf274029699f99c7d02d531393ed1e9bd8d0e71135ce7782c4fabd4f92054737ddacb566424bebfd597e5c0ad63c8a2cca6f3a5d8e7348b5c3370b2f878711c48b72f6e2aa1cbc632e161f151180e362f25f125e6832d6307bc7c09ecaccc8784b7e65f1bb9fc304fcad9dcf9cff8e1d77678bdb70a4904f477d622a1f03d1bc0d083e324e7bd8986c3ece7f5051db55d2baecf518c182255ade43dc2ffa55406ef30d1e01837ef1625737adde77a74780a0760ea52a52a5da879e23608ba95165b988eb9409873757056fe529096c69746307951ba130f1c229846d86b1660173ea169f7a926bcf3585795a2ac4c499","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
