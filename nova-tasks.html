<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7a4cb670e62bea3d810286c3640f0ffa6f5fb09059d65d75b7b4db581d4e044ef64baf1bb08dbff0ea0764a31f08586beeba129e1b2380d7ccaf261e712ea187d1d8fb0028f7acb41958d0ecfa721529d282f4efc716f6171c35c43359bec5ecb9d76940700b4ff49c645a1c008a499fd1bbf90a520e6617e3f87bc559cba8fd7e746deec18424c905a78678d15277c296687d62abe3e0eabfd0aa6df33258a2e9dc0ff1cd6de257ece1e73d724bf100fb85aa8b5dfffa26e66818c55d9d007fb946d1f5de04b706e6b0baff6e51ec2f917220c32269c666df2b3d9e2b0c1b1134ef85d61d16d70bd619e4b7f34ae5a4c90c8c99614e47be407ef91280bff4b276ba4e39c3af905eb95baa715682d4839430c9fd928bdd94666e1040e79c5163e92fc2f6cd38747e19e091b46b4c53376754196485ff6812450d8e92e84d56999bfba9f7ae11706e50a54450a990ceaf74fecbd765f008507d8c6c92772083786075eb4e2652b7a963723337a15e114f41f8476859f59352df612d0c9c09a3d6a5de357a6b401008716811dce20250635564fe500dc8b474ab38e18d4efb69e664fe282440df2c3d635f04da5e5d18e73eedb682d06d3432d8eeb2f29d2d4da88f51da0e8f656d50b233ab202b0892ed7e3f3b0583929339655790c39561240ee4b1e48eb8997fd663801a7d06a9b8c272472393cf67dbf22dc2bfdb49a9e793f0b01afbb5f2171fe757394b6fbd5c42224e74dde5b9423419c56ba67c7bd18dc2bc31f98701980e95f12c6a0685cbec7d03f36ad9ae13878e2e27eb821e7c9c3cfb32db2186811cc8b6de5edb3d546515f7dc92c63ff1eca267ee32a8f7423ab6c24598b440e4730ef3e5cf95d2e67add2c94689774860ba51312f168be8876ffa1704c02e57b87bebd2c344d862165fd8de392fa26623fbc8ed8aa1ed5c7b8b562577fda87bbb47a3f31e3bbfd4ed9591464c42aaf02af5a689afa78f39a449fb9cf2ae602a78e1957019e2eb62a9aa2b03db199b41ac57fff2cefa40f1eb846bbbfa8e349e7ceb70a6fdd5ef2df8e74e4a63401b8963f112702aa8aedb558fe1b701b6248a276ffc57b09fc1de0e4924ce3f03c77a1ecdd6dbfe39bc2f751575e5018d312ceafc1743484304d47d6dae6dfd04d465e8cef86ec65b9e24ff71e18c481accd443b79698ff347a191a1382942fbf3445a93fd92442572f9b07cbd720553b19082bcd8aba921d7aed7e71578a1a102ff08fc48c611ea5bd2b9125469e92cca52291bc5c7f168c2609200388bc102fc6cde79bc31470863a4f55ebffe416aaa2c801fea354ccc071d3aa33cf153eab9f8e22c653bd8755ef3258f4efa30c4f15cce3988d99b4946a313fe4184447d6ea81feec2cc012fd5473118e3f6e08c7036509d6c2e37acf34be0651bfed9242600a4b235f8eb3d8fceb0a177f78268da897f7ee3b5b864d1b2671ea77122cfc65706f0e3f7361ab550891ff58ef3bc1cf1c1c4e6300d65236907415c1472b45f5d83919a2e45fa9e3bb0fd3291a5aaf023854f050f4995b7aea18d9705b0d76435cd2230f00b4d9d166bf01ae93f6d7dbbc5751a24e413267417f67115f16c0319c4dd3d45125673199df1eee3fffcfc1938a71035248b59a9dcf187d909810d173e25fca7c9af17d85ef6d4e33e248709063a04df1e308750e40c0b7a4c4fe2fd8e79f87a8b821e35f28777e05aa8d2b81cad909982c154910cf590bfeb5d3b51ebd2bd84482788c132545c19181116ef1b9f6536d5ffadea3562730189f378fb3d22aa8a2b0919fedcf9660c21d85dbd100d0224f6e63708bc761232c3b5ac61de1556ba04e74ddea4b35c97a2e6ceabbbdc5f42994e468f2faec89955624992e1afeb4cca7988d44c51bbc62df52abaeee28993847b3ebab5223deab709739445baeecc85a933775c55032c4726cc618a2437f13044636be7694dff4a806882dbb8f40fc82749863d624cd270c6e665dc4bc9527f885d8f397b2e28f9c56d846219a76cb915853d6b3f64f537ff3bda1da0416dc38ee5662f2feaf5ad6cd78439faeb68379b50ef05901064891ad242d8fd46a393615472b1c168e084ede33510a9250d5ad58667f700818fc2f5f8e94ba84487a46e60b82041148a539a45465a55bf5e8ea5bbe8b491dbc1d83b6ed7be3242e0ea095ef0d066688822d535c257ee14fd430edeb6929ced260e98e985706f6a2983ff71d1e24aeceb8a6953849b59eefcde736abcfcedaccd53728edd07caf7495e8d2f7a7e143c26f9fbbaaa5f055b2501793949a96c0f269fe1f7325d5b93c5ab82e1b8b8e96978d853eb799914bb1af5eb918a20ccd20343300d7db60b1d7c4cb1d89b611131bc1a2792c77c1866160d49aa5ad2e6d1fc66b3558a1f8d352c9942d50714624ac0d16d5bb625cc2ba01d6703fd27d420cebc249f7c51ebb8988a36b90867e5b7e73d05211f473cbd598e613a7fa286087a59aca39472636622733066f786e208500e6d7e59f919c2a0c3797a946898850b6041166e0428d84eeddba14be557988bfd8f931ed589efb7b452d3a7c7e953335524232a28c3988bc4cfb889cafc7f541582712db69273771d469839abe937f69e9dbd145e32bf061491cda726bf6fff97e8eccdee6707fd2e6a4a18ca67a422ccf80a9ac6739ef5987ad50c8e81c5d745a45be7e95e576061606fa8168ba8910281d7015235a8183de04776f241937b7d2d5ecd3628a467327618dfed80a0ac592876d353e8f8dd7d7d070ef9c2b6f4ae905af82a7e8d028c8f6cebcdbaa72097fd933d8123c775f798255f3f4d431b33beb919640aa7ed7044617b2f8814e38a973c1c6b7d64616925c96b04254c578d331d047c319dbc0b49ca559c65d56e81eadc69fae99ff67d921cda4bb110688f3d12e70ba7e91602b142b6e617cacd12f663705d66c3cbf48550a839f6561eb32c105e6f2c0fa0b8eed7244424409d42c1304c5ca38ca08047e6cd551ae73ad81dbf2127ab4164f168d0a400149a8ad21ea81aff2e1e7474eb85cac4e93b1c60a22875ae103053dea0896b325f525283aea05e841be69bf141737d46e02315d4599a50a9c065fb0c806c2f29969185e65be8f3b3fb9e7f762c5a6c304ffc94e21bd37f3c851c20be1a5df43af36ae9fad2ccb8fcb2edf49df20b4518a84ead9119ded258328e7f60030d82d2f500482ab096fca1746d318e4ff960ef7c4289c2a56b00e1cc7b4395a36e1ef5bfc6c0d8267d0f3d93bc75447fa4f05ef004ea0f21645a58fb03c9f6b70f4cf48550229f1730b2d785bc448bbcbcf8360dd891e48552e4f36fab1e2245e33f95066043d6138e4f904e1ccb692872a418b5cb5cb1c4d91959172941b44bed7a5e3f8de777e5851901e3f76f6fad624d2b61fa45840d1ae4c607f411913356eea9f4f710108a45b8d8de8368c858638f9e48721f7c56feb289eb7cc861bd753a83c18d4e27f702c459790e1a24be03ebe1aaabacbe1434f18b715717ed19eb9843cd5ab19d87a8115a9460ee7d2d62c3f336500b24dbd89cde207d118b61a8a35b032ad423f477df5507216fc17ed5b901ed124441948591a9fdfa29a436aca14250391470cc2246ec5580523dc27b0e6b66b444eda9701af0632b7bb23bcf06e58e40c4f6f41a229ad4a6f7f8c4bd366760aa37d2668365f834882a5609fbab9fe693c65f48b4fb7f1f964d7891fddb67dbdda8618e60d96fa4a5fc5a9fa205cf0a8d36de6a224ba7a9fd98b090b3f19b0034cf7f1e826ee84260c285635864b076b569404589a0dc579009d5c9f23f87d6e19efc481705ddddd36f39dd8a710c3ccdbe2fbde60e4ab6a34b33bbdd684f025f7411c22f0d2e48c38917d82278da93bc2602c799a35a85dda8992047cf790f84ab2d5d635c7c4003ddf52076b93fff8019794054e81656533119786864052c5617bac8582c55050ccc866aaafc5d3483d6cc47c436523c9973797c0b31a31af93374960fc9cd3a3f44d2af530c370e563b667d2dfab84af8ce69d5b57ad0e598290411e1d7267e8d2c15ab7a8484ae567387ac4035ae586a1bb7a18449c9c83575e505d35389b59434abdab723ef8ebdb58b4e0b1ac90e872b027f426a5867f279d7e52e13079332ee4980520c04afca41b7e616b29637676eaf54d92720604e8947d92c8c45267f3cc2559817bb7e2cb08522c6fac72c51ecdc28256941832ae9b0e1cf5be384faf25382055ee12448b252bbdb984069e2d874d138e9175d0f3d5289eeb2ce393606f2d488f6039b7effab86ab9d381eeb540f3e443105d0bd068ea082228444c4ea738af83192624b0066285cf42cb487aa879384f6474c732575db4e5522a5371eaa896b5955f4278f76aca0a4ef7cb1552f512704c7e1996d0edae19df4721b1f80c4c02e71c1a053584a3f91008ab757449f5546a76b1d8ca061932481803f2dc302872a0098580a8beacff31ec33832329f686757b563c1d0bbcf517fa911d7f098b0e144fe56f8cdb3c150329495c0d7430d969a6bf9f003367c662b1d95fee167a8ad9b252289a325d7569d2b3cd1f8c27610ccac1f47f204091159be17d56fe5907195276a8df08a9f619ea43887d81344b1745192bd379d0435dfd4a5c8b8e9ab8e4324007b8e9aefa092361e5c315d9d7735169084c67200ed371453a7763563e36ca4495c49f844cf4addc246b970a1d104dea731cef4cbf560188ce93d768f99fbdc0f6af230a9526d52a7bb0af19b9629b420fb5ba1755d1bf25d9e967cd70107c182e349095513612bb64b363d2a2b6da27bf941a5a63b917df96ceef7fc9b977c7d9df933b6962fa01c7f0129b2f208ee618d7be808bbd835936d2c96f6ae950e430fae37fc000cb14dde169ea24fc9bf88bb0a086ab19c19b8b8534cae1d909149ffa27f5ec5998a24b00e5fa4f9249778f005585763901e2ed7eb23e2b67b4274c3f1f328b11335e6abf9ba30bab72c2bbdcfb6be70000d692fd230b81c181aeeb7531cb727d8adb7c8775980533836e0e37c04f59463181c8dc60307a5ca0dce980f443fb719c7cb25bcd214af1e5be737aa9902d7f4e5d3976e9189b6dcfc95818d968884e85fae565d79ddaed60d0e2c955a1375aecf8e4563f1cafef80e3f6ec97add0270b2ce6c690d58cd9b1630fd2d251516602ba2f53f7f056d295592eadd93573533e4c594ad09959080324e37ae03742117d63c0f258a11f624d7d7fe94b7f749de85df920c6b2221eb39d22b2ac99b6ef50b90bb31ba125c0d38bd24c780d31b25b96209e1f8efd8fd173bc93a772d186d03d16e757580d594044f9144758359c473a14e9b6ec5de55c3bd8b7743927303ab5743064232181afb9e3698106fe19c1c74c589a1517d04b0c2bc0ca1121d9adc033cebd0ae19e328ddd5f24d7f19f46b343df1697fd9484bc15c779f664d1adcd4e9062ef4dba1d7b49149a35a7d77c2c9baafe49ecc1f8388026a1f0d0450d2485c09540a11b9ddec35c67b9098b5a63c9fda5f49a69039e5893b0c94eb973504a0e45ad5bae5912e798591f5370b0d7e3dd3537cab98dd3b9acbfb9592b6e6beb3c977bdc95d881c89ebbf7c101e3cdaae701129c62d8b11d6be02e00481f4e900b666328a08c44444e7688b056a97bc3401d97de9c010a1519ace3d102f0c76e6f86930bb9167bf31fdd9a8d7c0ec0b147545a4425c0f7c35386ae5021e6c7f704b00e89fd41c81d036570e8910e7aea3054f0a8eaef3aee1acdb31c75c4accb3e93053676847b5e6bd855b81c51fbcf831f5af9492f257a8f23b827f4985b5daa3f66a0200d7ef2b93497029e9a2cda22b4203065e0e7301b3d4df6476b694e9004b171ce3bf32a47f5192f405b40f3390ad4f91b22817717fe6cc868a4447d6822448e3b1077d8007d2c28d8d9019ab60945a2d3449288a1ca1861e13f24a7732e6b2f8cead149b4cea1c74ae3a26852a1a541c7df4a2ff3109c8d486e546dca7d95d747c4c8efec8165b7a516962804092887aff697dfbd94a0c93fc20ed6e6c772ba0ce2df7470e9cfbd8087eed226fd87159c8aa066d9bf3ea31a9bda4eaff1529b9fbd91aa19e9dee6b93f2f5ef163b433a59e410a78f1ced4391e90d129b1fd005a3ed6da5127e2b13ee4efee7a9a3bc776890eb5f8b8db686ce2ca47670bc06281361efb8848bd7794a2f179b54e325a6bb4b829209c81a03b6a593a71bbdac95aee9a5565169b02663d647fe814bb3a703e277d5cd6c410509ccd3731cc87c513d974baa423c7bad434f324caef2e726e8abede7556b3808d9f15b75769eaa52c2079ef32086a8da44055596e926c96b976ee254e34b38d930975b484f8a43e34e3f8fec4ad3d28055560d16a08966efd599065b0c3b3acc5ab052099239f9178800c52631b962bb0fc2c88da58a6b9ff4d45e5d82eb89579d1a6c101dc75b203b75c8107e8b0d55581acfdec0359f9641224bf8eaeb612dc71c282ccca29e092e355750309ac3ab866f47d669ff66d0e165d40a7e859249fd8b4813744c009380ac907e27cc054968d4c5895cd7af0280dad37b6f8a3d24fa1b2ef43a85ae038e0151851a59854becc106d45957055fb9e4ccc756b4a50fe51d6c58e6aa3f486ea7d334f281bed6b01436dfa5acc1a267e5ada3334911f20427a33e85c6c4373344bcd5e6fc60760b1c45593a5b2ac7688880cbc6fa6b9b2bf68a1aab74aa57de558c92b54e66969802bbd9b926d7d4a82216038547477cc9616811aa80f483b7515c86ca751b3721a64dd5291fda516beaca985c5bf1040e435face1ee38f7e693ffa2539d75812c1ccb3ad87c79faa75d06392edec96294ef4a30caaec070527fd4d8d2ffc64a78c89a902a306df25d72ce634cec14162f76bf5c1b41c43aaa010dada9f96ebe06a43313a42c6905b3a3ca59922caf5f17b4fc1ecf99573444d8888d62cea0022f8243339402e6cd03cc892532ca70c3940b3e04ca6ebccc6f1fbc5c4436cf61f6625c9b94f6329c0ea2225b8f274f2c55bbeec6d1bf1d6ac98c132e4f8f894b65fa6f0fc655d108564b1c8969d8b43da03975c4706cd27b3da7bd856c753dd5537049244ce383e0049e73687766b5b7de211f982c742cce778912b9eb2ab82ca299896dcb8c302565b874454af9b547e2053734daff9393e75322ccebace577d34caaac7b23327c5b57696029befb3710792a1f3899da2cf11849ba31db27ef1731a7abb29dbf0f22fcb19a0583d3b98fe4618e147737dd0b6d418a4d3135dbc97dde5e2149ef560c5c39deea32f505b4f855388f1fd1a5bcbd3e7bfcef6311e6631734e47aed56b4ea7781eba15c38a746de927f0a04cc5d671b4c5d916680eec1fca5514c1d7386cfac8118654b25732d1a0fb4a2de30becd455439a38b0d2abb82d454573d74d4743481f3c547ea87b9a02ea99c0a946cd5daac6153641593978f3b547cdf33dfa3155f85c675dce3e0e9c63aa5afee243d735085692ef33d30f41e94aed7e78c5148e60760a2ab194b73a5a0b7f2f3e9a63398dc9914a1553fcf1f73245d656f699a2718a6f9b03d7ceea9a56f8c52d5c06be8fdb54e3576ded27ce18b265ceb0587e242763ecfa15bd0482cba3d432a631869333b5b088065d3c0960e82a18fcfed6ea6e6f6a6c91d89847b712f455cc1b7d0f1ebe5295286e2558848adcaf26814e175bdad262b814c0194e6e2aa85164dd090bfb214f093aefc0bf434808de8888749def6f131aceed9877d08a3692a0bbefc1bf83336b8dc4a96cfffb9898a5d5b2148bd48abfad4d17f816b865e8cd6a2ae36018494c4aaf9d4dfbd66e0c3f788fb7a1b43a9b1f762b748bbe42f54c97bd284d2a32a906d76d7a964385e8baf083b003bb65d00938d22c1b49adb2b0b77827ca6d9ef6160ad86787f6035d9b6cdb4f63bf633e7aa346e41375765ba52312ea14f934a446c6ce8204d66ca80da20af3f28646cfe85b65a2e60abd3a370f24ab6faa0f807978dc7da3a4656fb9e17e4dbb1fad7e891df0a88bcb4af05a7c5a2b888ea63de20c195dec31060f560a238cb346cde451126a26220ce61d84255416a4946d0af3713c90296ceca793a21c4925b3f6995ef27f36beed0b1391e6a01568756ffa04068f6934e6027df6ad5d4de382cf9f2b64d6e2c0c5528d179c74c7fd90c9096d86b3d2051ffe3bb4bd93b13a484f4fd5e19d9376d85f8adfb559221e0e6919eec37a4a932c2c9cf5f4d94e86ee0974804dc422a0e74f621715a743b548212faafbdc399dd6e41e354d646822ef1ee786c72e8813b9028eefe7ef738467e44779dc36d72248ba095b9c1197705f932daffd21a2dce70d779fdaf6a165c835460b68f794d2e2e9f241e853fc65d55c78de102f80fda41f1fbb7af4a915205bf12d009bb47b075c03c76a7cc1859de34d7e750fe43533d3bb0f8fe06e496b2e297afba988120bb19a5de3e91606b0920b7f4945e0bf1310fb8c99f8b1a4944fab4071a96ee891371fc0899ccef759d6e3a4d8f452c171d04fbbbd43a5050c0365d72ace3fb67c16512280ef7854300173cb56e844f8860eef479e1bb4c170174171e0e750fb7dfdc3899693a0cfa1f3fd2beda4ea1fdbba1236e37b792f39b8c82b601a84c482912fed224811233b3edffd1129e0abf25d098104e37fbf17728a19da968a636db9c443f2a465bda8527ca095f4a6f5f2844950589dd3e7da63bf3924a36e8353c51b2d4d9c908ffcb64c7530315542cec03974df08820617311623fc574d8e0669afe40d1aeb87d16630ce05fbf8b93b72f30417841c2239cfc599215686a42448c077d1227bdaee436fe42d6b196be83a5a368a6f5627ff6a75ef255f4273b2ca8019185122b7011ee1052407a8db2ad502b963aacd8719db5790e23ccd67aa827ad7a3ba91fbe6d72f42ad11b591c467a357d1b0edbb6dc23f4c78fdcb66cbf76c28c34b8a3c87acb1639b9ef557cf70dd618ac4dbfb3b2df37d1a4e84b2d983823a1fdff994b161113db5793e647cd5c1db707fd2cfd7720c57fb0e9eae61113357f21f0b74b4fb4b34aaba2e8ec80f1f483d181ae5386f9e25b4594d13741901a0a76fd00c9a5e463e50e92af8c9562f2b688204e9d2ea9f3ee9b818d71ac5a681c25394bd6302130328ee702840623d023d845a0efb968303b002bcde35813692d7868537ddf9994d7c07a37f9aa1bea870e250c33a621ae3a0cdeeabc69539664a34697c13ff7506a963a026dd738e948948d6ec6b666a2e50b615fbe0959c291fb9a68bff666833070ce7d7714292409a7b613501e5797277cf56ddeea3d9bea2fc171c5678d3a35022b5cda3a59a1853b7090755ce67102b3db60ec2c87d6d528a7849bb323a52ec37f98d4dfb02c22b3dcd65ec82c97531cbbe625e66a2a946a0d5b01c164781f551dd4df3e82001c1b0344ea6ecd3751cbea9f1011a9da6a5e7b00b94681fa5d122ccbce044e32160e372c9465dac6306a3b3c19e01ab2b4947c831249c6800cdf603675b75cec724f56e6c4f023e61ead3a8a3111a33e8ec1b82c1dc281b1eba9bccbee974553c4dc8ec2f4779122575d818c2d92b04a571fe7f6881b2632fad4510c5034c9b575653ac11cd126b662cdb42a58329dcf16d741a6415726c989f58de29cd368d00a59532eb3a638f0f612545b12b1d4471100067f672f9d62175d9ba1265347c7dd7bb53a75cc207f4765716c1153523c061e731ed5c3578d128b5e5ed9fa54b204db10619b4c652afdc5b78888c47b0b371d551344154dd37d95a78b22f8ce2ebe1b9aab66a3e9c791e9f44fb1d59cfcc025860ddf4a6d29829d96895800e47e7f4881210af3ba801cc3e8e33574b36f92184f337e4bd87c249e1f559fc0a8385c1161d6030909ba08437d80d376e47cde8d23dd490544c9e0c7bc3fbecdf36197e457c5acca1f3ebb230266c43a6a9820bfc377068aa7341acedb786dd3c72027228e4da5e8732edf3e64dc56bce70ef676cedd61fe944c069eff4d2134c5d1e90b79610fc438ea6a311c87b2ce6fbd8b2077d330102d05fcfdf6e3ac532cf29ee2fa7f282ec97453e7250b926a85c0fd72644c549f806afec252254b6842d72183664cb2c33bb81fa39d47488ff589bbe6a08a7468ed026e13033a7514602a73d8388d11efb19a742eafe0a7054d205374a69b9a07211f9b1a757a41880c27c53f20858cfd886cda0c52fccc633ea5377746509cc852ea3e0794d34790c242581fde1f05af6082be149f3369382512c97ef080bcf2be0423ee940412c1b43574b4b87a9b6cc2418cd5cc9743c5bdab453c8882360a4e0094554c2ec6c216dbc0bb4e87a220ee588b51d85ae9095a502d47d8432d6553baf9f8e48bf198bbdbd80ee5fe3fcb6f2228b0f6ce8f6dd1361c0290a660420918b3adbc603e4335730ca5e82d698c74db38a19dff0064fa4336a336352f4d44111efd6a07016db5c524c14f1ae621a06c3f3ba1ee4f625a7da7ceba3e32e303bb7193d6a40db6e596eb2253c05c100f680d8ccabc569113c9b2d65ac5d7ec5faf6e64ff9b6be549e99a788edf5b5a7e98e832990928846a20fa3e9d1c60bfda2c1527ba68fee93271c58bfd807892c44533150926437692b9ae74df62e73641350ba6df7146efc12b662e40ded301bcb550913a1f8ae09567118a857593ff375e3ce79cf6ac06a80cb2b634aa46a94c4c016616d80b89e92743650e4068ee23bd4c8ff50dd1eb07283f828b9b8bf2cfbf4bdaf681e68ec773ec6c5fda07d6da26fa17e5a413b3274ebf2dc520e6ca9c3344b88d4319c12ec3c33c6221450943c6ff3b08db271e6220cedb649f3fc93edb2a06b40a6ef03ed5a9b50014ac6f8ad904502399d74803bdd58b600e09ec406a1581a4dc7324eb37139b3e67a151ffe2d9d09ce081c599401a8e6f7effad3a0831251109251d69ebde61540187beae3af03f52d2ab23694554f9252659188683398597028e080dccae1bbecaf95f39ad14beded395030c6d99346fdaf0dcf8f292d82ed54447da138cd62ea94f7ef95d9cf60e5bc435e2d5d3b94fc5660f7228f1951d0f4e6b5f09c0b347f4889cbc8fa3f81a4fd47aa5f52ebb4ebdaece9bc99be50a6b7fad74a9e3efa0940e9088c1b7dec6482b2d06a13c49e3afedf01d618580cbf98488bf6fdb469b5eb5f1228c5d81f3af7b8f92674a1133bc026925871eeceadbf60c43d3e27640875d3de89a08403ce2864872b7de6ca142bfc3f1aef1a5f52ff4518d167dcef40e1c020f54b3e4d104f92fb3ee887b73fc6cd6dfa0c2568855c1d825df7e7793dcc76e97ae1e6a47abdcee2acfa4d44d8312b023a4398671c7498af950856a0716a40e2ff4d9ca87b7bab7ee37b6f897282616a454abe5cd6654cce1d4d9594dbcf6f2280bcd17d1c133cf1bbe15fd523ec3ae13723c5d2194706a3453a548d4482b1d9fe45a03e1f4409a8332a8d03a95a76a6438221acc74b16faa84dc9bfc525c762f94f0f7557bd163d53e17eb23e4773b5f31793bc773d1f501e2ceedb61b6647a7edcddddd0d5720e3de303f174bcdadc2653ecc10f3675be1a8c50b0921dc3e8cd1ea1aac5f69173ee6a7aa7e34ba2596253419c93bec9d36cf9c05742b911c90a7f0641706bac91e94688c0a899632a0da4b800bc1e4f06eab26b21d607ddf4b52a40f5e33e2659bbcb504fe12623ea71900a006d5e73266980384a553e3dae035187a2a4008174d8c7700ae73aa5a54ad63ca01223aeb624f1c95a1c5e333dccd3af3eef1f9c1aca9c69b08f4d0b9d97444531a7bdd17f9779420fc9adef12985cd8b1333b039e682ce62dcebae1c6ac907d8acd87a3919a234f64bd5d5434f062f48d7f34604a576b882956c2f1f7718bf7e2150a5c6dad57a7bd51fb1dabf0555de7e07fa4f7a79a7f78f9d5b92c8058b0d62219efcea20a1975dc5db0708fa46d0f66a728a22d7549407c4c9ab55f43d22fde13783105e687b375972319632627148058be8ae8feb15e6485c9302dc9c0f3ebc0109f904d3ad0d2534fba66eabfde01ae6478c01bb3d66d10e934088b2ea9b840e01347d65220b57eeb6ff50acb9f8f48b1b6d3b2d89570abc623ba9e21297e6f3d5920e9dccf0f6f3cfa6d2f7c905be7da0cceee06161ab534157407941e143a672526255eb0b70c5ebf83f6365a7bff3080d648a20438522ce2d8ef0c82ed400dea798f7f9274a2b5c4a8270f3852b663eb4a944eadead35c23c4650bb95d6f3d496061e808700fe5b2e6aeffca767cddc00a1d23331ce268173fd27ad6d562dfbfe43e3064d71919010a9d10f69a7ab9bd677aceede914b2d7253752d7f93f7be7c7c7092559b8413b78c790f98ea52f2da3d9303ca844b04e9e3f31f3ca0ef52133f210f70bfd28487a2d24fe2e50465d6efe17dd681ec601c55b5e956a4f38db402e4ab5553d9b899569e57ce705b02a16e861c513f3a1102613ec27d102c45f7a51c9881fcd7925531b4283aaf92f069c5760986a283f88b658f383f2f7ee09bf8914afcc6bd702c84141cb2c7fb3e1ccb1c62c816836d2db1d3189eead2c1b44c1b35609dd8f271fb8054d7af21f67d32c1bbe111a96df737b6e2034ddabed9825ea77ffd5f52cd089efe9e6f0bd31a73388cc6c178d066cd45e04ef4102b9cd3042497f9e2e1d31f0226c7202dafe9d718607759b294bc4d8b63b930bcd730c6bd95e0f83a3eb9e170444dac9b293e6e69bc3c43c9b3007389309cbc7cfd861fd1d6a2023a73c7725dbdc105af45ff025947c59a455ac8973d553cbf0722ee836a0ce3877d1d490079029ed641a4e3f3c5cfa2d3a3c700e262e18d64cd90ffa5d141e23284719c4ed8e65d29f54a3cc5fb5e9e77071bf67a80f457327bc4df66ff65eb3999377d12a8948555e7b76d556db57585e944996a854cfe97e9973af8624181f7462092c6318e9ddbd0549407c5b8d3bb371728a19fbcdd7e017cff71f50ddfbf46c755d7caeee416a9b26d2fcc5b0cf993fbd5f3915858591f97d0228376d045ee2ad73d6481d96a106b2966a64b68160b935e8185645648d48ad72481f0b8af96306c02a1a6a575b7c0d7187f11e076c941633d11c1ac748ae88848d66e5e7762e1eb57211140ffbd3156dcc2d1a6f2debb9b8b9402e903ed3e05efad15efdb85568c554898c19eb90e3a6d86d95110c6359dce56c08277185018e2c27fbe6e0be1385ea02cf925b07601c6d3f2945b28e0e88e283969b636bba07af01741689317a69cb0b573a38ab43f3e3f63dc367042b1a2963826a1ca75c3386e4f666e84fe083ed8587beda76d78f42f7796fb1afc392b0a77f4d081077249c049d0d4cfd943c62450c62b28d063208d27e815f0c577ed560b490ba142ce3eebfd95a51681ee0362acffb9680ddb436e7ba125e752ac3f479cf1ec26d90dcc184fa5169e511a8587c5985ae281cb3d5b91b46038335fafe96292d882e0ace7871ae28123a0e9d341ad50799188cef26d94cb737fbda68e97895285e4fb8dd70fa911e3ad80f7860e013ec6892845fbd244a5e80d48513db0cb7c4bc098da625e24fbb6fe156ea8f49e2c10d9e74ad281082b1e524c6e6b925a181c7c302bca2ff562a9efb123709d9c39c1175835505470b638aaa74842e36b95cf6b5cff5b3c4dc4e96a08fde27025d3c6bb8071930d0fb53137449a8100299335a4e0a39592c3b66aa70effe252d2145b501e0dc41cc0d994f7778553ad284b1a3b2017b578a2d2df7fc295d9dbecfea86d15180d7ac20e066dddf72d2a3445836c4b533a880b60303e06b4336f0a6489a1b67385609601e78646bcbd7b53181535aa67741dcb6cbbce021d461cc74dcc26a9897f65781c5ec3c0e827984a7dad96d23ee3a3b094d8365069172cb618919fcc37c139feb55ae9becd5ddc86b7249cc4687fdf6ada6b8344f06eefd0008ec2aa533b0a5413ae3bc03a58b25661697dd83832459d672f4a523997c83f5b96ee38828f2c9d0f81a9aed5a7ce955186b66a6b1a28f21299fb8b3968b6053faf1616c753d283b1f85a7b5e4bc67cc1d1d4bb580e36fe90435b4aecce0c98d9c29d83af886ba90bfc185c8dbe31b3d45cc8e2253ef8702c387d414177aa0b9b0e06b2721201eeb78ca9b386f50c336fee582e4edb48d185b602cf30f44049f5d7cc6be39116d62c9aa09eab6897208e986c381594aa11f35c330274b4fc4cfed62ce686d9e7f3982fcbb5d08b3e70b6542cb86f37fdb5c9ac2760f51cf0163e38cc5a5607d1d28b7c8629d4bf2a23e9b602aff820f363d675743f7c5b6d7cbbfe42d6a52cf8f3f3481ed28b26299e93fbbdb107621a884c4a3372fc655402cd33bcf23556ee5981304127aebbcd51910807284aa278744c9536ad161c053ce1f08f6eaaa4","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
