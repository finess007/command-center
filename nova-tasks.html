<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"1d7015b395911503069f939202fcd69a57028b3bca52722f29b694ffdb633e1cd1e5c1e3d8880ce15bb907f71b911d6a69c2b4aa7a49d575029e13ad32a2cb530dfd1b8849ba500f5892a581551ab343838a7d8c766de565acaa9e72bf2834264cb8af23df1303c55820a389ec3c3d1328bf58669665212b36eba9c999abbd20a9d381832fdee1002b81ac72e636cc4a03915de2ca4b6d839e94eb1257e99b699a5c2e3238780ddf0f2cd57c765073ac07bf3247cb7ea6ae96bf90dd584f3c6d4d1be03f30dfe3a9a89986a16be2212047368b856e6b6f6e96b8282550ead64f812bb07a6de29f423d44d17629f0160a2bc11dc67719b822ffa371472302f660889c87251a41dd31fd3337626a5c00b4066a30ee0f68c535fda8bfed3ac836278e6572f3cbc25cd8263ef4c17dfa22c5bf6dfe77f36fc56c72443715980a2821936f94f046608c82c300f19a29e5e2d7e338c55cc61155b4c7785baa45062300ec34535a30c550d00e53689890ff7f8dfb987e3a5da0833ef9438c9c6c9f5b4ba12b74f5130d6fdb2e33631279d754f58d37a8e4d99597c6162d33ea6e99c6f4aac2d4f05c47f81ced0604709477fa036adbc690ce81ef0e62e183adb169658e01df2d21ee2fd5b93fe7ec7872fd0430a843e1508e28349cfed1a2c046e0581d4c9e71f09128cf3bd76e246db409741af01d4e62da221c59696a4f1d03b33c95c6bae1e114a076dff458d4aad9fe1b0efa3eca3d7a44d6e84b1422e846125bfa3aab9c045fde73aab68a4ad1f8ffd60599b6d35eb1a11b807228e57a7dfb6ebc1acea78c66bf7ca344ed86990064fba4e2d27af6ff21793b4ac9a44996b0d6855ecfb101ae9b04c2656a5a030f1c41b181f2f30687d4346229bd910337a71604e78303a4d36e7057de4188200d67fda50f865f1faf043f165ec09f1a8c306a6a2a7be7a22bfb02b52ef9d8f83d94a8e4f540b197449ebbe3653648fc81c1b07042f868927f5da3054701ce5f18aad5179724caceeabe90d8fdf17a4820f107baee1f01f861002b5429b67dceb30739bb15914223f84862df63028341b08adb526a563ef0797a61e92d8395a85cd0d5632813d5b15294d73f4ad18d15bae20817f8f94551e2c6ea4baf63b7d13e724f6a655e4244f599ee64d6464a0bab9f0c1eb8b56f3698a08995a4a980ceda3e191101d6bd7b56c07fd75abb7a0f38cf4aad7a4a8a63ab29dc689f11c81ac982be120218ae9bc42f2691442ffc356f8f2d07ee4ae0f7bedcc4319e263526019eb44640dcffb44bfc1caea9fda9b1a436f5e242237816c7003e86b9365ed5d5ef188967c851bb102a1cb617cfa776a4615f8658e4f338d1b9015e797c53e4eec0e25722fbc007a37d3b5ca12da3e8620c8f8d279ad9358ccd744584d570893d362138b237629513f9c88aebbd1413b2f9f1b9bc2972aa02bcc0a05224e4c1f2f07f9a1758f35d13ca3b02a2e442268b5c7a98befecc1dd84e9b6e956dd2bde2fabf6a5c6acf0813232096340e714e9b54227148ee552b80e215824ae6b669872309a6f3037575e46dc2f57968239aa71dac2ff1a22db530df7edb883080eac0bb287ce1f6073f483588c24f7485064aa4c9f204fe33a5399b8679dac5c8d742e885d10958743e8cbddfd82daf2fcd608874496365fceeedc93d917fba9c5ee09b811f6143d238513b95eadd3a298e57dcdea8358f87beea1fb15657a54a46dff9b09ed191f8a2741ec91e81a3ad5bc3d2a4d7e759a48429396b912dc0484065fca34c18215024bf688b46c7b65475e6eb42b8434e2130f85ec2526705e00694b51daa177a6bd143c02771e634599c032beffd119f82fbcc415074d1894404e83332f693664e54685fd5024e73000274ffac4efb45c093ca6bfaacbbd6b01847202e4ad6dc1442413930b675ea9f03f423606e5f2897d900c47118cd233a96097f3d2abe6d13099bb90e2f38685e1c972562bc8f36b59a887fd8c050cf7e943d6f560b73462181fa50433e79be56f52fa78ab784c893843e07f9da3985e93128ce3367544802d736681d89c96f5f71520d74b4684f78aba341d2b2b32ae28e3c5d3c4fa84e855a91d2fb1da8af990c0257f516418caaa807dc2908459580306af084deeffea76402d23db72b2098ab83802d12a6cb56a0307a59c4c2a575204a201bdf352333bdb9d2b70a1c23995dad5238644b40f353f9e186fb340b65d57c166483f1005d118143b6027a134e418f41c55d7c173880b4d1dc3b884ff04fead77568237ce36ce678b1bdccbafc37898d921fd1514d1c976e06872814c87fc06c3a10576c8bd412fff8b627620fe4ecb5a780b26f7c17b2d77ad7c3c97e5b6d76a5e037b4287ca14fca69bcc6ba912e4655a89af443fa33677d4782fe1c723b815faa45ffa40a1071fcf9aabc8757154d96358303a96e3ec8c8e3ef66eba7517108af5c8b1028939404bcb04d53267af04c4f809db9231b0868473f1bd9e6a1671aa240d0e6e2505b62c139155c30c39014ead55ecf9fd25056b09de305934004f4e202256fd8eec11ebaa0ff8dbe12031380fdf7307e4866d4a2318a7dabb39b544bef4ddaa4e85f1e8d89a41d694a2307f4a194bc3d6967ba6db37fdab052e0bea4f53b1d72c5d22003ea39110d54d9c90ccc54cd54335eafb00045bf4266576f2e9812eaa22426ba70cd1d5a519e9fb974292b96ee6faf02f06ed40eb59418c230e25dbfdcf229f82e809254a6df2ab8c2e2c394e4b0c19306ce904a79b73461f4cf36f83a7793ecd89428dd505fba699c541584321e7f1fd404c20db10e5d5e923e3bf17c022f39f3fc23acf72cf2a8237ee03c2c277060d067105c37f638dea7f146cf211bc63d7fcc03efacec39d4f9137cf26d63cd8d94e5cc7d814cca70393f3ac494ab65a72092f46b67dc7078f83a0657404e6662a720770730ac40e3edf7e02cea98ffc78d46bba65e55252493b8c2676646c1f7be6f18483b70ab9c1974153c1499a44d702b1cb80948cdcae433c1a3c3e4f5cc34e7c37d7e4dad1e182c4f89f8ec0f99b5077aecb43d75a3219cfb3ebb04fb21209a34460d11ac762602aee57b0960da1601d195c5db40b3b53273a94b28a1c8812d9cf125338b564a12df79f0dba00d8ca2804e8d4f581cc758bf388295843d906426c1fdf6eb5ab69ca50e09424c051c6a25d0f113e22c40fb8e501f8faa99f63409f26f550a53a5223a8549a9cfe7b429a324ed14066fef0e9f9e05dbb7f2a00491da29aa768ac0760e3e2b81dcf3a6c5481ec793b52888a354d9dee20228300a1fc27c3f1755a2c6919a1a34e1440c5cea4079fe4181bd2e302722b9f9b28449ae722742ef4c42d702229a0968f943a76caeeb1ef85f1ec018ee0cf8de3fdb7cbbc04447d915d29136f855d4b802a29f716b7ab7eafa664db0e39eccd9f835493fc6b8d316a050d6c02328c090685e37785065155b9b83c31824aa27fdceb1d4069eaa6d272ca55b24f026e50e295499ca7e589f665269e8af866778419d382237af7353970ab613d45aa063d838bcbda4223a0178fa5520d31fcaebbba6bd13c8653601c6a4db9c08a115bb8b69e40bb8614ac86c6fb745f4d270089f84306151f118b5b0a811086a0cd7b057225fe794c4eb7fc342e0e6eace2795af09c66126a1fcebfb1b32a74861f172789cf9ac7b594d76289a51eb6b9a8f48723da4ac66dd0ac5994214a6517cdbc3d49f90241549191b3dbe2cfcfef81f4b30ee998aa2abbd27268effac58667afd4757d13ead9177ceeaa9a5b4f3c76ab93b9350fb02ec074639000efa15887769366a5944c324c1c5d9fdee495c954774ed6c49317e2ced801ea67e9eb68a1cb25812f7cf3900921fdcbe4032f3de44ebdd7fdf0c6a10e0ca5824b2e22c258b3ea8ecfe18ffcb35884a9b379caf808f87dae7ed3cde2e2039dfb2138c5856e1a6e127c45dbf96ac7eb83e7083489d23c5b2421a47fec898833dc4e9145da3d0abea60a106600aa81a826fe3fe38f3dd360e06585ae75ee1385fd2dbe47a272993f785d4c15a9166773f538ea2742d9518bca4336c1b9a9d6e3e75f5ea0badf7652ee171e1f21acc3f0df01c7f97dec8d3c04fafc0dc2c843fae156b64de27706b5fa3eee64649e66e28ef8110f1575d994e4a2552cd1a571882dad05f63c1645ba6eb544ebfa356dc5816b60ccc9d706b394a8753182252b9b3b2ef5bc6de54b78c6ac1a538dc156be52d66ae02b077c5630aee08ba2977cf07fbad0b5a12b2c9595e3d77984ef53948f555d7b57da375053ac3d0a901ca2e4a9885561820b87838bda0391e406487051c9f7eccbc45562cef75b745e852f470219b55e32a4842528c8d206d3746fc87c96fee752b8b82e098646ba67eefd39eb826d054f37b9e443d7e9faa5adacfd157c5da3dc8570fc02fbfdf9ba91d996ed3399c482f3b868e7f3812dd596618da3642cd4fd77453e9c757e40ac207dd52b0c0f44a1f1df29f384a8df9448c5df1493ce3a41e460a47dfbc36167cef0b5646e98a6e5b0d91d56fb82107ddfcd5dc686a56ae0ebdfb7b288022df823166196df70c51322751d4644ef5b3ed7a295ccb90e7a0b6c2f30670166aaacc2a6a80e80ba568971784c32a690e6a508b771eb1ca31acb85e87f930c6825a652ae89b7cf65a6f35f90e8e6e672b1396cadf01acbbaa9b1487e6e8f747f80ed45b8541fd7f70ebf83edc7b2fa32f5d5ac2cce473576e9258ec0ed5e783a0586c9e5761a4302acffff6df74b549e6d6d35b6dd0c2e4e4558a042cd06d18e1b9e53b333fe30ffcca720334b2d9b980c0974125215238b0592a923cd5709a5dd97487c5bf026ecf2ab16a3eacbf1392cb999c1b60a7dfddb5b09039ffb2c15cd139c16d4bb0941b10cae79a7457153c68e697073b3a2ad481e0e0864d888fa2f02344a298204b51c70c81dbc8a175f6268d507496a2849fd7c8089d2a8edc640f81e16d49d51ec421c606da8ee64f78ef431fc15e99947fd488ebdee11ef61c132ea26541807f7a866d4d098d9f935264db1abb7960ae50807250b1c14c382b443a2d657706d09b93eb1f08e8b13665d72b9317dc40476853f6ac9967e2ae411066dcb8b53cd6a918a0f3a1769e6942c9883aba4c914fde0458f09f2a6630b98e8f8880bc440f52290848f8772867083dd4cee25c111370414f3c33b8b491ed4baae7683e7a1589525568ca1f96bc1d2fdf472648f23335a502977121fea3bc5195edefea541b5d10b4bf011bef9af3949d51aab990366905fe61d15559467e4a1468beb64c75a642f205afe9b7fca70a21d6f4a512601137baab5336a5a70b95cb1bba9f7dfed9ce93e01e822e1df2100ff7e30ed80238235b161d92d129406c5144974528181e5282801e8c197d36bae15fc8ad794aa68d374c39625dab52cc63a83e65fee125b712e9f85e520c084a21fe8e2838916a43818d3db20dee9b1a559a79fd0ada2315d0519a23265be422b0a7029e258d50d19dc2b751b236f4a03e15fb59c23cf3871af8607b2b16065e330580553a4d5403d431d44a9036e96faedc062afa5ddcb64be509c4533d5837f297672a237b384cce75664cf9a2a5e39b283dfc69a0f19b2861b6bc19b3f95ba2e014810a2eb3d71799f3fd20601636eb38951b200f327b9618e77da6757bd41f24ef34d0cece11634fc869c999adf369b0535db737f3965d107b6c86673c058f2968022744dea267065dd9451b7ddc8d171a4227781b38520168045a8bc8b4f418b00d29cd779f32e0201de9d8b5a0971d89eb68242834fea12a68196d10025cc4524ca02f117b52bd37a01e6ad8cf5913ca050977afd5922e814afa42cd64e41e1cca0de5f17ff0fc18b02308bf45e7e31af4fc1fc1124089e9c288e5c0782acf0c17495e24e2b4995964600a89cefdd3d84a289aadb4e212f11ed3efdc003f9cfb23c70c157a349801447e5d1717b649b2fe89994963a6a6ba0c16672b078cad8b3efa472003e0e242fbc3096d25c9883fed5860f133b1373241cd4793aca035a2714acc2192722276a45301d9ee3f439fa5c4effa7c4607c49231340ea18132d558f5380a7164d189d84fa9d64d1fc21bf76ab4519ea4ec1cc16525fa8b8803871f93675cdcd1b769040ff789bcc8ec450c19c030cf03dfee5c8786fe4eb2276a267a3a4661cb238db6879e9e7157b24bf9fa936f4812d5fd5b5bd41fa9c55690460878749dc8305003ba8b8fd106a7ddabf3d2ead18cc44a171ead64c012f0234f732040862bbd2929ea2d9ca83a5b4832a1595e3cf91b89702d775b1ff0e60e6780b0e221c94923f7e3fcaf143cf4b22085e45e8508325eecbd48957053bfda5a61cb323cb4a8b33c2c95f7a838a1cbf6ca33f5469d266f260912d3804b6f1a88c72a0c9ad1a3945440e11c1d3c15a695d4bafba9a066429265ae20e82348b93edb91347609d3824d0a7f8a30be74bc0a0d4d1f0ca56a144853ec452a303dbbb880f3e0e1dfd4146956f3364161542d32820c87e5f70f56ba651fbdc816a6765536b5a62d2d550c6ec04c5f3af292a377ffa3f21e232710119291a8fe9503675374063729fee133fb5f1596d6ef03455388416fca187609da28452d1b4cb6ab272e2bda97997fcb51bb20cb0987bf953a1cd8ef83fb36a30e91b018e8477f70f31eded6f875ab27d8b603332031ff9b2bad71320fd025794d2834eeabc9cfb1c59a6a43c666fbb63708de657fbcaf2a76767e3587fd09de753ad4c1f4653c6ba2403cc72135d2e6babe2493653139eb661f9c083836a5b6ed5f6f1f4670bf5ba45edfe32a4d53e80502729e00bcac4962714a2b225201f5aba66c175102c70c5e2beac3416b4fc4f03855ffa94ba1e459226d49147d9ea6d57f7c854b70e76e5ebe618723c3139d70a74ed2d3ea02c2172b3fe251633af00c172c617e539023c5306b06bdf7728c14da7b1eac2341d88d00c8e5f0a68c98743b3562b06b322df50cb82c3e78669eee3e592388870f262c60a05a02746819894422a520f106d231b16894b8e78466279dc7d9f0c0368afdb3603c519fffcc96c4beeed48a2e1bc8d49427b1ff735357d1aef0ac1792046cc5420437894b7f7ab438219c78f35bbf54ab55d1fdbc48ae6196b101e7bc3b31b5de127a50cc92524db6de76e190ea3deeba63e96cd049ce7366be857838ed7b9495ff14178090d6e1f7c3b4958ca306e8568512341db448fd291d42050cfb2e37ce75521cb4aeeebed66030e5dd7dc260c7d7efb20ce1445a0d1bd9db58783805960eb204fdcfed690d4dc2abcd4249889901154222d6b24636e6e3db6d7d519975f2b8dda12799859991f56e21334a0d56f1324607c6436d43ac210637ee5a2e6f24c587a1cd956ed79db3eb4b0d9daa13dbcfc13b7dbc1485bcced9c51ba7f940dead2caf04c1aa5487336128e6abb5403613ae28d4cd591f2a44f8687282157e3bd2bf01ed0e4cc5ab9a9a31773804cfc1a60eb140302d44f5d6f5401c79a365afa582d8c5b67f4d5ea174272765ea7a69e0ee6e5da1ed478d0a916b0a243286931a1909baa92c3e4549e0e90642e2ebd523876d1872391b1282e936b1a777dad00b84693d54026fc9ae229a0ec0d94548609869a3931a913831594cb7728dae7d8166e5107701ba85e572df2cc63960a5e9de92b540074d17b4bba090f9b0612e30ebbd45c2368444e7ed0f5976d545ad3a2c15ed9e46eee02c61c76fa2e16ff2652ae75b84b54d09f90c1be517987bdc8c61be3d0fe6951b561116a9a965ee5c5a5b35aa68917a3053112ace9f52effe539e2fb54b9f1f96f9f752f444c4246934e72ec779a66dfe9f6380c04dd38cc392540b0eede33de6ffe2fbc1547b61ebc2e6542da308a41d3d72ef46cc033d61ad29ebcd47c110e3aee5dbae5ca0d6d9a1a76c813366448a5a78b2c445f2b6b48a27062bfc9a18ddb6c5f5641335f21f49c54888415b24ac67c068fc66fa27d97f2fd4ed87936c5d96437e18f5fbbd0a417aa64f79ebe0b713ae823d3800ef08cdf2085f0d87274f6b3d6e1c0999e2d4bcde35296bfa5e5cd6717d4ce11f09806513513aa061b5a29f8569f0258acfd1479cde2b19be644134319e676ede0a9d702d7113232d880861189b94cfeb1eae5b3ef4cb02abfa1960d7ced6fc28bb45aaab398fbbbc698b29818059334539ed770489fdf6670baaa41a2c48c45fa5598ea89f8b9f3de2ef7944a890eb43a90bd853b2bcbbe14cc45a29966b27a3b728a9ef3c83812365935451f8b7a064db8827ad796eba2e9d893920af832f9971771b65c96fc9db15526848f499556aba935c3f07c79a00de6af740d408fd11eb535efaadf3edf21af5a99878c0c9a290b2ec14592becff2177cfdd5da3338e51f8b4b98f7dde615d5156618b37b6324ea9dd99780cd5d7d3c9f95699cb3e6d4c9dc0fcf710ed5f9e2e2b09b57017c38fd8c0b178fe7cbc28c1524c0da51cbac45c0c4da744e44961b12ef8639460d357119a2020139e55b691e5c6eabb6f75368c86cb7b692a1d65620b97cdc1a1195b1030c4802068470dadb085dd6cc569f314c4ed531fd398f2caf4b108d915b9ab05a24de6ab8e00d207063c46ac69bac43d69e9efc5f527aafacc07bbb13167cb27ff133bd6df6a4fd0ff4f71d9fefddf3848c5471a224574c6eb9de700047e4173b33887bba08cf711b4f103fea373e86db2eb4aa8b9d42f84f9f282afe0000b0ad21e931d65122ff1c9b03ef22dbea3e6c951cf162ffa373a6682d79de808051df2101492462b6c91139fa12f8c070e955ce431fe062981f6a329643ecd7fd8956bec77c50cc5130af38c63e577ca2ca4f7ea6f75cd919dbf08174ab715ef2314f0e0492f23be753ff0458aaed5c43c4cbce6d173d028bf5f67f675782de248b5199974f65ab4078ce13aef2c583ea8ab43e82a33e388d0816dd620b8462f5fbfed38c8b6366dcb9a532404838f555c992e0122233e25817211734a36cad5940e37aa021da27839ced44b6649621bdf7a4ce9fde1daefea13fdb1f7be004cafed0e86ea0299e027a54b8c75cec91f039e9d081048411188559dbce252abc70849bce2b00a8bb91e8a395487a892bd5b82a9d62536c3c25b0db3c98882667ee1c3b50800c2e8ff141a5e90ca012d5b14434eb875e58321e7118b571ac81f38ce9826a2c6a91d343cda57f441c981675eeb56726cbfec87340579dca10a578c6d016dd80dfaa7670b2527965892c2038a5cfa603be873c24872781e524cc4465b59a087a7575bcf93bc23ca009312ddce8c1d0794ebe7978b2ef5e124e9d3f380b4191c843346eb0dbef41009790ee6e966acbee7bbae72afff3cbbf18d458dfa609e73b2c06d4a12b35e95554ff5dd6567bc55c11fb49f70366f7dede895cd7d8c426c7b1a5d13c48c38d39ea6dadf6593d219b1c8f1bab78890e736fe8959fb9f809a6144067550bc229139ec772df00eb5324e8927018e7b882c16e8feae1b309f46c34c1dc03d8a60a01dff75f6ce7fc806177208943b8b81c517da8eb66cd8422b9fda0cdbc2d6999937136cd846563b998dc0bd1f1a1c908f8c3d24002950f3672922f3e76dcb804591c0e83872675600d369ffc67a77a1925af5471e6cf96f36e46ba5e89836c0822dca0259db7278dd4c8abed8eb5832bb9c4f1b3c25e2da2ff636252d3b7383d60a1a217c28ec6ff86cd3696a69c713b0703c16d775de03f1c54bf7ff66eaf453ce7f2689961fde234954b2e6f1091a70762879312c5e48947b14892e5b425d379ce8a4712a625e85ddbf8b91b7a02f53498783b4895220bdad1ab648c571e47fac50e1da264f2d2f24f09983170ec05811b443b3eb75c0c2c0367b2974db9d8e0ce9cc53318cc9b384559dba1a7578c6c128e893f26f2e4299fbf3dad808b02cf1b7319ab2a5cc330f6d376d003b5b8a2baeeb3f4f296386e5ef9a97e755b19dd44653cd88ec7c43afc16604938ac8dbb2714f6094aa3124072d6b5e6a7e7175deeade563c940254de9e3b784a2d59350f1932bd78bfd3b01d8c1cc3c7e770c5798df9c7f3d3a0c4688d53c5ff4e3c68dcf8c850d1a3919fd7fd8b995c5fb9513595ea76bbca8e6c7257a466fcc4f3a03c0097b4d8d21b96466bb3ad28959050c46c9f4a4977df8f84a1e282db2ca17dfb710577453e0178844ee6bc80e4eb973cf4630a28ebe51873f32b0d6ad707a0301c660160837f8895ecbda14312b60744c6686dd5ccd2fdae0fa87eb0cb7461ab18335b711da858bea2dfbda3f0ad0915f7a468894261200ee11d8ea112450b8f446fc36fc7b528fe8e76107b15f45c2a97228111ec1993642d2dfeedfe7db5edae4702340f4ac70541f1b9393c786c3cfd8e058b300a10a2a00d83f40b1f42142e798871f349f6d727ca8b8a2cc8d4adf7df2475f9d936a1b8c85cf4477ed524141d88d479511edf9359bd1ec2215b6e1be37f22373d0aa8e10a6a275eca4437ea1791b687e440a9bc5ee873bea0710fcd2c305ab61cfb888d47ed268c04fd14eb50a5a2ed997593e4b05d562aaa79b66203caa6311f8509f16eb7ece7f107ab716d391bcbbe9dd77d4d8566fea3b85748be65cf61e46bb1f331a06d6e592cd3d69e0b9643e17cb9a4c143e87b35a09b116407cfcdcca14868cb2a1a7e7f450dd8099a0d049f233b9a407719b79ab9f5d639a7c261647ab12883ab1f83aead959713376b673b286209350779ed1e1166b4aa4418d6227df2c35c8169589e393a0fbd4249cc528e42a0c94af892ee9a0f3f26501d7da0a6c4dd0d5fa05496d02168dd4bba7dd09c91467616e4ef5064a02859a2f95a9c9f561db3a00ab12f317094c83ef0c7f7c88f927dca1945dc105b25211644d396302219a95c91b993af50578ae84d8fbf9c49199e06537d4844b13adff7d0aa93dcaac9ee16d24a42b2748446cd57becb502548c6ee4e7e943a43d83af6e8b1dfd2a2aa63acf8343ebce7006af8c8a56d154169b8c77a2bf5ad36ccb25d2d67569e8f39c1b308c3558127380e4be1a0e00cd7d0b682e74a932f00319382c0942780310b6601e3bce4dc74edf968a1ee69f09808385b3bcfe66a0c3c988098f0d24fc5f94df3336da79734114c7282b69f750f4d1ec35fc08fb01c518a97ec6dbd3735043f07e17267668fbb0a75f68549ac860f6feefe4ed2ca15d531da57f1923589c1968835d1ef2af6978dc96dd596f7a3bcf247bed3f9c4cf1a19e80abe62b97ac67a700d1288fd0957df15e7e9f660b7f3e4e9fc01276f65fc3cdc4946d16ce16e602840516790ab0641d8e5657ca97cdca20532a4e712feb9f03f4c1d56f9e44ed87f353977a6ea8b459847c52479ffda88e2efd1addf322db2a1e7dca41b6f80340971563a1507808e609a568a7773dabdcaba35f4bafaf26ba021cec641b15940a996b6be266888ab6ce7f3803cfa3e7baf1af2e383bf2cd29a5b12ad69669efd7d05fc910ddd40e420c435d4887d8ef3b5e16e71cdfa7a73ff719a9aa9967e0676a2e5e8c5699438c7ab4456705ef8994ca848f92f50e7770e8b83e9b9571776c7ac2303673e3aa0fcc16281df1ac130e301833c13601d868b82ffa093ff1a0e2dc9fc4334c2239bd705fa4285b72f030091890f53ef92f1e8d07acc422019e25b87e82387156299e0e1e56758dfe967da6e042a7ee8e90596e949a3cee5e1e74e012e735b0e94df5b71e78ccceda687e44c6f1032516fe10de6ff1b4df0d5a8807b19900bf9f8833c0e6388d74a881a558266c1113ed7f886a78aa733c7554e37dd169e95257e951b51d15428670c9ef1a05997356a13d42016a7ed3c51e513ecb690da4ff8b35f5095b1a6d5450291e4ba21a6dbbcb11e93f7df5374850f3015e2aa79b8e81f4a493b5c67a4df40c62b00a2b86e511e66656b5c19fd8c65b9280a08f22553f550f7294ba69bcd1191603f3aa1072dcaf22ff6798ce57a26b507c74932cbb201920d6374dd283b14b2b55303882d539855fbef00e9c5faafad2d536adb205fa2809d6023555dc8be07ac27ebf798485bbb6cab3429680ec31dc7eb3d572d274c28d416b1f950188d44980c137ffe513db180dd755d5a6936e57d64d635571320c41bd0dec0c1880295360ed30bcda5d84dce68ea24655a0f1abd06b2e15895dc7baa4fac68797b5d612df926994c30724d762285a56c1126cd34e1f6965ba936af276524e141c2379d71bf5aee0ef1a4c820c90df967a115f0bfd382d69ebb27343746e4d88837fc0e3534c5de7594e89e3b5b8631d2b4850d9f6f489b945b048020895c07691456b1f673ea8347737caf0adf4201bd04792f4fa37f5e706d42d1a433d940fa9b7cb6e4d5778021deacb8c0664a47f6fdc2a5a24e3967bf3e846cc4ed756071071fc1dfa3a5ae2713535490520220304aebb251a655e8c23fcea7f93c379a4091819e47518d787b8765ece13470cd86481e654a17e9568553f31dd28861461d8a25bbfb4124c0a1685cf9e574b3ec696182e3bd0782dba5da5261d15182c65bd1b86c0cfdbe6009930e83518384a9646071b1351381baeffb76c13634e1ca9332d8b349af79a2d68e7d401964dfe260827f60b808d0c2afa3cc8ea73df953558f481e810b83d22ba04c142cbaf77d50aacb929fd49b20c786e45956b9fff3a9e502ff2a65fa24f8d19a4e8cd9a14098e44c82463a68d5db6a37227a491eb78b1e4e5b259dc3460c304428c981e42dbbf3de73f35f9bda46de9efff4c2b9c4d4410e47b7867277dabb270a5b41f1869ca29a2bcc0dcbd69c019b8f50f935bbd18b2bcb824271900f2c220f381361f3f21418a0a15db449c6115900e2d2e03d9fffcb634574dd38b8353d913f050aaca33ac3f8fa04b447a5002d5345d917469b40ae7eaac00cbf3c293e35d822e93cf138f363a844071aa72fa6ce40dd2d15b61e2003d6d12ef00d97316cbcbdd8992d25a96e2c68e9788330c566c17d2aebd3e24c95ff218404076df5e9ef55988b927ef62f043229edb24150836d47fe34df133de56667288cac0076adefb0cd10d8d4627e58f6d057732cd96fcc11849c0c490dab0cda5055b6f5820ac75c7470292470d9ddf4f1d06319f98f3d21f4fab5cf752babc5b22f5f6676ad3784b68cddfee3081493d3ef5ecd2cdb1ec9a97388d7b7757805185a214cc549a2027bfe84d021540050e9d3b46b3dcaff65b9706e8a3e197a7c53ea495fe1510352378ad7359bf2d9e97c96aa2d9345a197da00426a5d27199551f4668813f045603dc7ba6ba4b57249ee44ce02f3e56cf8d64bae56f7fe275fe71f1dd19500ed5c10c60e5640db72b5ca44105e8d007e30e46150c26c2443dbe0b0b224a8a3b0f0ae2f622747fd0e0b01f229bf903b7772fa77f65244193441f501cde2fd42323b4ed4d434d01b8cfc0d533daa8bf8a6ce038db7e1e17288c28362d89c8c8d1583a99baf88edbdfae73a9082f578e0deac5fcda4da88a0e3e96a88ed3642db360637052f498b52b825c3cd79ed5b9f246e5e1680eeb8403fef95a9bcbfaffa27630cafbf057604d566b40139f48e3c9bea2853b6a7d4156127712112955d86e0be31ef9e713c93f14748cf0071837488d056e779363a2b4d5b898674cdbf069621b46ebb2e6863b476bdb55ac4e31b883073818cb785de19b7e99b9243b5b6d57520c607c39afd8612a2efb1830d78fb2135d6010d609f863087583705c2dad960aebfded055f419d2775ac1fc2d7e6339bcfb5d38f1b167ce7dd31febf048affb52ee9c7211e91bd472904e22e1fdde0972554af65c55e615f4a5a32ce579c452031397b141ba5939e8c5e60d28bbe917c9b715975e9123d8c69998793ef7e0135683e193d5f1a6f785b96432db9b7657476b2f45beac65e7bc76f40c8043e9aa0349764649a251c28d451a0d03235fc3004d4779468efebd05f8a2b40e48fb626a6f81c0fedcff526f6359a0105edbe78fec1a074dc3098ad943c241c792a46bee6045b6995672589da6563a776f4051b1044401bf166ec0de90e9fd8315b89dc28f41f3c9bf1409e44ecb5426f785bdcc4f68bfecd9305297944280b075fba5ef02a9d1d5431c18fd776d0f0ec2bd8cd6664e9577794d75f1cceded782d9863dd98c1370ba483f6b8b0993d4609d6793fa8893a2a358f14835fd2038d01148c7a8553f54a5d96bd4bef8641aeb521ab00f45b6e944dc1243e793c847ab895c995ce0122178fd7ada8fa4257004921ce45a10deecc8d39a3130a09f13f5485b110526b08fa4e9169d91ce4ae3142f3854fef1c960b1d3c53b7f1880f36aaa9b0ab283bfe06e6f11cbb6bb2404a8dae0d0dab3b858f9dde1b9363ff4f8533a8d2af98e7f14bfb5f4b2e7a202b8a9072fc7e41f4e9b648716ac0e0895cea9f6929","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
