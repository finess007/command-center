<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4556b7b605f600ba7ddc44083493cd16097432d1c16c60f692e5b8d98f379d7295956dfc029d05185094600da9834240ad8b764865e334af801d3643f5de40d1a9feeb0df7391be9789d059e3d52bad54add8caa957fd10fa94f435e333149b919254be72ab26cd5d4dec15d63ccfe95e256ed3e293e6ea87404a6bee7bc2cd672dad111f9f31661a8d79189c62bd27047f47b31fb117f459ab98edbe435298dd980c131bf3ae37126f139f7c02b4469872f61befbbd1e9ed6335f9a4e04f54f7ea3ea900088427d5e9c6fe331a13bbe6afec2672a9a84601d243b38067ea1e07515dc1603fa6e1721fcdc603b000561db621dc48f4499d9ee5af98916602c99b60ed8f4dc62dd9c139e47e192ba18eef275be50ae1bc3d96b22588e4102a238d15ee1a1b3e154d0a3df06cb5ba0bd901f46583a62b920a47008c8bb2712a9f90c6d349ee483cf95feb20415538e9a9601c80c3d3718f0a58f1e45d00a959036f3d0ee5f0315a5ccf2b1ee5b80f1b17e3b58ee3cbcb78d99dc7a82afe2f5646df2323bda476ea2cf5573ae91c39587640160635b8022f8e38570efeb0fb2639fa2975cd75b0540633f459de3fa65752f6f4a0f072ccb766f90c8bb0da08b5493ffd460e7713933d0ad1632c48596118740a068101aced87e73c5e45d0b6a47605261b15d758e1024c977811d3bb2a2ad604a94c12bcc0b4e892fd159a782b50336898fab0c8f4de2093df9c188ebfe920f48e9b25a62a4155b7e3fccd5a7c9b59e2faabb7f3fe9a8b576ac2c2d717ff42a15675a8089f89970c0d128c7e28996da8751f27ae73833a9c470c0097f02f9af634421d6ed4563296b474befcdb7b59dc35fa69116881fccc988392396d1db949acc42cf9971f8c9f5558801bff066740be3f4445af95516990b72cc1fb373c8805384387766fe91e5fe8a3bad644c58076edbc891a455a68083b38d47abdbf6388bfa6fc03b3b87f35b4fd24124e8c62a88802d730ba696402c25f1ba65d75b31426150d03cfd1e6113603d810cd45e30642d76c38ff44660b4d3dc3d4ac715a73c09021ac3c5416895823e17632f5962d8feb58097ec0b9337bdfeea477cded290af3f7ba528e6220b80791f8ac6cd0cb7fed06448e37ebec9b811a860328c61a4e747e3996c5bc1b4750c02a9e994b61a880d29c067e826533206d61cc689a4f2b946e34ab056a4e2210e1af90e348b201f87ab0ff0625105b52a9ad0d228e125ae4fc8b56e11c5496cec0f08266f062559229659dc13315474aa6dd5c5962499dbae8bc9db03b3cb928e4e0aa9da18bbb91ee68726132a5e35f61bf2309742cc7a76601902e7cbbef42ad19dffe82c27a86a73d295f6cc8f4ee1f4ba96c9a2f5c2ce80a31f139a938b57a1ada30e09636e6bd946f590a7bcfe1e0864f12fb940d5258c59cdc92409469f8d0560b7031f84f5c53772ea649978c8f2644f8f6b0abdcd76cfffa54a29d4544b82eb0ca1aab6db133e44304bb7e2d56c2aecb6fdd37c011e91bca7906e2b5baa54e577ffb6123898589abe9784239d13cbab972126962eae1f74dc4de25ebef3f460b07ed6803206005c7a143dbe5adceb8863adb59902e434e8c058ef219232213773a230cdeca5457b58997c489b9a31d1248ceb70f4b9945cf30fe8714763d5c1ee903ff085ee683be277724003bd9d577eca393343ed41db1ac77cf4fabd4a671640a3c4fc110e76807afb29cd5fb4308fcbc3f9a1b37c13592ead066ef0839096d6a1e294b0d4443f7f59f6e4320c032b630056857c16705a6d593b932bb480411c9ddd679f42293fe7b2c100aab62e8b19724c962aac59a5635e2a9280b4dada141d41d6c67bc10dfb99b6b4ed75327140e69d98f5717064449afe39896944fd64ef3c7726cc543efad2095072131fb36da12e0dc0397b21ade761cc8c8312a648198400f7ab96ab61929d85fec85614b7262f90ebc2e38cac5965ad1e20bed0fdc74e188d32c0039656739cd37bf6ad4adfbe9209b39c7a8b7faaf31ff325ec1059bbd5f74d5a1b05ee7609fde1dad9f2b31681979fb2e93b2bf2e25c792b9e0205887b41191efa260cd69908742fb57324935cad2cb5125ecf8e638d206babdcf80ea939430e38bf36de9ec22de9aab3b29f25c10ea250aa55ada3f693737b6629e2e0bc8c1c9bcccdaae40b1351c8b6361ca31533a2cf7a23a77c933d42d8c01b1e64b7a782d5b4ab183f6f774f77c8e052d49e1c7e1db28e418465d985f7e5113aa193b16a943720124268990249cfe58d364bebc42602363524c17a123d54d48c9761ec93906aef2a403a22342b82113821fbc1ba23801429ec3af240be57e4dc9ca8c913195730ff195f79dbda29615c11425126a92f8e625c9a303df4e9b137404b7c1042e608c6b8eaecfbf2efa878cda4ee53b8246a332e68cb97a9b1292322299e6c8e6479674b4a82c31f817aea84b0547078cd6e623d245771fb937a7c827d3298f44e93d43b3d76919bf115df51ecbf24d9a35820cc4ee1b9c73f668a21a3f45fe678422bc8d3e273b35f002d1fdb233989415122cae19c7e8c941c168710248532e3b9f84452c33825b73df6d58d601c0dd2036661733d389ada4b20561fdfb9d1dcd2e1fbd9196b8d4b7d9045e612f3227c87c7f00a3990564cf8cf7f3e1bc2a0cd9d3b6121eb4e5112dd5cacef11ec82d4d147ec08d6421ac6fd898e2bc55bdc015f70e132df90d41cc789fcbb5f26541dc277a9e64c629009b0810935771cb70128c5c741a9440eb5bb68795ff1c8ffc27186d0a71bbdf375fe09d51e9290b2f11264323a9a768aca5da5b1aff4da3fdd3a74a7b25bf817bcc7ac11625b925d814f7ad0145e01745187271a9c6bb43ecae197f42c091bf628422e85dc7bfeff2c54d086897a6a29ff27db77a8f5d5358c06d3af7ad09c12f97f55646b29deca8c2e416bb5ea03e6d5160d4577cc8dd167a5e5f3abb6d18bc8de4d4898368aad374a05b268ee036df3b3396fc5ad6a03e08750e81057f573826541c4de62e7ec0eef5d0730197b2201a31f4c0236842f8c2dff161d598c8a0c69bd950e0a0cbaf298d8c696d321a54d0f5241cd78ebdf1a7325836b8ce394649b3b9ff94bfc4864c807e1dd4230ebb0512a84ac73a087ffd75ac78d3c2b478f5bf944d308fb082771bab9f22ca9dc73dab7b15ce6cdaf6ba5a126fe60bce6b01ef4210c11fbc327f93909895290c833300a88b3af94efacb39ae1c0adc63b276dc5089dbf7ade61c151f24213e9cea4f85bd48dc1d1e6decab1506fd7b8aed23aa9d674b64643458c40d77ae0c1880074a488933e6b49ac152570b7eb5c63eed24e4c6b77072962cdbb72f496d58fd3ae4ef28ee503d54fd66c5a35d8c8a078d2db618febd70177569c6305419ce082c5518ef42f8c75af9bfac911c11f7afa4d605027910bc3825294516ee5325e13feb73d073e81d31b2d716ca7597b0f81ab8b32efe3e4eb976fd9afb2935a3dc77d84cb68d7c739194539e7b03bd5943e80c1f65ec8c377800d4dddf89aa3eff2b147a47a7a2310f6a5d32446a0cbe678c28b66bee09c6e3404eb9d2dcf9a2da659d94ee46ef82da1e1904f6a52dd1a249509ad7ab43585d012912c546335ac16ca50623e3352e16d01295e5bb8cb497127fd5739588b1d01c8f2b77e7233185030935b6ee7ccb912cdc8811324fe3821de5e033936208d96759c0dbf4483eca087875300eb33f47d1d9b1cbab5cf678ad4e03a934972ae35748084413ef063529914701acc044af30e5ec0e3f0672aca52876b9bc24a41f9858ae8f191bb01b6375bc449f2c493e3ccd5b70b13c74ebdbd46d318107bf543636a40cdb884fff87985a6a1d720657afcd7e2090e3976092b53c99d3a610a37898dbb089e5d8eaf3cb02e8d9d6882077a956df7ff043bc5e919b92548384f4a97c6e175840e20c4cc948a63f1be0b98219a176ff1df887750d523f7c2e13459194624e6432c085fac5a68c3ace6e083f55e0fd660657b54ff357cc240fe7957b865b113ae4f4fce68c461ae4a264a5d5d911db51b5a2f67abf95039e60444c31323e3f1996f0ef17efeb55aba6ff8c0d0e06bd0560af9515ab87179af02d5b77516311bf943517035513cb4ee8bcb1a9683a3deb3d9d9e1fd6cb91495a2991a185d6150946c5f4286512c93bc90872a052c0ae9c69cf87faf9986f0f23634dd196308bf89429cab723605f62ad868362beeca046ba35643ea7adca5e562abb5d8c412abc3e107ed41322cc04453a24bfa2ae9dfe1ef62f6c5cd788eafd4c2773ad735ebd5ac954ecd778aa2b2f56b40df25c70ab0c5fdb82dfed7c8bda05c8b9d21b06518391c3244f5caf7e103a189471c12acb4689824403cdd14f15aef01cd23d81fea9ce30c6669e2774dbf1082c855ae2417438b6943ce97d7b809687312f8cbfbfb5fcef2dcea86bc1d1114cff64544927637e778595ab807c6ba4f75d23cc7c00bc7b006bb1e4b66c983327f6767462429ca543a4807f0996bdbfb0401cdcdc71cd0eae66d18abffaf9d3e7c12795b89f6e0f65fcb193f9e8414b96cd53fcc9a1720072ff04e43833d898e5bd0e00567a6b3c4b3791980bc5471587955e58ac0fdf5e12bc35ce41c794d44582aaf766d5afef3b223a1f065d5ad261e2a95dcd59da879489752739d4098517c731c044994c71e9cccb30625181cb8ecf419f78c02c45ab93e2e4cd7a997afa999cedcbfda8202fb0789a325c6e1373aa1b7e8bd9f44233e6ed05a378bc2d25fd3f1c0dc12cd87626eef296b50d0074477debd2fefb2395e3b05799ea28bc9e12fc083004fb2aac22ce3bc6e15bbd47d514a3037d2b86a82f76968181f8971d70ab6a25ce7801806060ee4116bf647e9de6589ea6fafb2768235d0c0cad2af3d4b59859e888b27ab6d66f7f7cc4d3d8a59f64043fe09a5a11d04182d5889b79e8575b68f5da28503d94a9ef5001a15312192a70d6d039b84bf21e65e05899be4fefdeae8dce7b2bcb540290c3c5fed645e663ad6d8eefd5ed678b5e9f37d09d7328cefdbefdd6ac36e8f79d6da5b657aecaa036263d6b9cb946a8a31e52c5bfa83599ed001ff405ff74b19a42bdc400b78092073d04a058b7dc8d81e674ccbf450ffeaed27e943c1976c7d75391f2cb7753e666d165e294c1eb42b6d4316cbd94c2e9d5f68269a03acda75177fbc5f144105ff5ca1db39823b92d0f0cc45851339161b651cca00826d06218a0a68aa453712cdda3223b4119b61bfc293645fdebf25e099cfe597a1193711a7a62937fde8a8cdf4335d8c6833445dcff00b7790b54d979ca9bef35a9116a3270130cc329cbf599de2972f61d984ebc294e3c200c5f23ffbf7268aa1f4994c6ba1cfec74a55fffa692a633f9cd7efdf6ec001812e24dea9cc6397af868979c92f3270ca3841aa3eabad2361adfd51c70012fbae259004a414a444f5612bce07a89d5322d6e21c1c5f332c4b15fb137c2a8b1e336b9fd868ee95ad3a5324d6dc26bde48ae878444dac60d0536688136c255939b352c4f0fff92742112f9caf5e78815d1039935cc2bd0ed93aca4f972de6b3343495e4ebf68d2b1b8fc029f7297a9ff4f4fe99ac39a9814cd67d9da90b96f52ef3ee16304e8f834ace3b95e29c213b1c884980873edaabb13ece4a5ade877460f48026ca61e15bf52c767c78f0bf44fee2f3e5463f7c55d2be34457b3257c7edc4f005b9a65a1e8f4b024738f069ddcd36dff2dbbffbc8f39c00b3a691124af187adbe04ba4178a278a064ad3b43b3bfcd88bfce27b2428790ec12c097d02ecbe31ff074dd3898a0e4827920c18dcba06a3db358f29e431efe81ebedafd9531602c7ab6b6de11eef014fb9892fda412cd590b3b04caebb3eac037651e15586c84b3a853a912abc133ec9cb3db796a011cb1604454b861f57f45740fea6eba1a5e9bb0c0000a34910b56f43a4bf164557285939f4788969ff2ab665f9ab27260b77d3ea8f71bf0a01576d5e3a4162e4df5bc55224f3e54b0a4f5277d1864db5bf184c80bb1d58566430e5e1451e5cf572eb924c2e229f2c758526586b0d7666f17d98ffd206bdd1a64fe799176843b3a3d1f84aaa37e9ab523308bb4d964a90b59f8e514dc478e4f28ed781300b633a677c9246d5e4de98c5957edf23d95f8150dc2e1879e50e9387aa68acdea18e48a348d956e0f5d4b4de9f713a586f72ed811dfaeb1af089c786eb13962419aa3621b4532bc347d6fad41bda778794f9c5fa8d0b52a4cdad9561fdc64e5bd0935cde5b18f748c8395ab9c853d27bc50469ac3192efc2ee649e83add9326b4b00ad2469f1a74b6f715c447849536ef31c461b3bc01d61d998bfa88b01b92d8959316edf3a3fe99930c641fae6f34eb1591b599b4f1e2253585fa17473916c35fa878796f7dc446b04a22c1b8eb89bbcb88249ff9abf73f61764ab43ad03600cb7c01e27aca93bee8a8a67e824be671994d002844ed788e17a9a2d4ae446abd25aed1a2a108c9e057b6de8301571dbed94f9def900627dad10175d95e66edad336e98a22b0e5195903f682f14472b9f07141db0393bc9a3731efd55135d8e4e18d96f6942d0dacb91233146180d8e3296515883ae8a603800400badee848beeae3a06890b4c2814525d583246b6d02f070abca0feb8b1330e097767b9169ff1fe68f7c7c1857d2757cacfa5ca9972043fe70f245a8e20865006f55ce88c7c1809304d17026e732445fe67015e10b6edc7a252ca579326d9deefd7981e4bf2cc13f6387b20710843701d5de639c58ec2f8b4dd3a4f3327559f5555593ab81d6ac7d52b30d3050f943eeddd4e671e378cc5deddcb98194f831a687bf8f4993f6eadf84e4f97fba0460103a63bd2410f6a4defa5c97ff627a9e74f61502cf0ad13ec66b9a3b00a675438048f9632e57a8bffa089b9ce757efb0c4077ef6046e61e2990a76c344c12b851bcfe4b043b0551c02540fca2e2b6c9ec97ad68d7d970e25d195617e746eeff7fa8d34592f13c6ae5a6345720b4500813f5a51c32549965c3c023c1f9b96780bce31e0e133cea7142be10ede2b5ec27aacdb152e81b9c8aa92cf4bcd49e1673d6f70ca02ab7b710b6468e1d19ddadb8c33b829a910106e5536f016e166e634bf5508f5e348a5ed4acc49961dabd5c2097da457ad17b91786bb2bb7d91a80e63b7d1d88855baa8a488de1cf3d6bb0978d02822038781d1b4abc75501008375cedb08838c3a74bd8117d7a822f60482b43bac76f3322180788a8e6f161df6d7702e2478334bbd277d62f1cd3509dabced3249500df30f5b26580789ef8db9deac08c297f221a05bce4cefdaabd9dcd1455cddd3eb3e9cd098e4c1beb55861c93f103ebd82f3d88f84641e2daea4c2221feec2f7674dbec97b8cbf7177224b2c97d38153e579f935b5f1c68227ea837f6aafca5d4b554ec1bc2f9cd5fa83cd6e9beb920b3d26a0e84bba51f6a22bdc27c3bc58f9f34faa4c3b2863b09d107928a4ded08343426179273de464ea40795e2b8ea181cfc16f75dcae19bc8bd769bd539880be6b73c2013c6a56d945bf71616c72f6256a386c987730edaac0a455b8bc21487f4888431b7685adcc89d523ca8c1becec50deb6b3b802e0a63ce0f3869ccdb98ec79db145f9f66c2ff3b0107611b61fdc4d714e5e9aae10a394f360a30f3032efddb80b7708dceafbf08ce05e7a528df0aac7590733d8629accec44872f33ca400fd4ad10c78fc236dc554969ef1046e6b250b9c88691d3f60bfd807cbd760e5cc09dade06399622629fbbae1709f32dfcdf15d88612d14e3d22f2fb851094595096ccaa545ac7a81e331cf3f2244b01c073400c50b8022c143144068180e276ebda9c7c973400d286aa4226fa5594a9abed3ca9534d34fba66416925fcfa8632859c17b05762a79b6b6915019c50bf0fdec63bcbe9453648b4870d5677ab78713cac737244d1e04e7732cefded97410eaa4e6fd2b0998ae01099adfdab32ff612665e93de01d2e189f84b40faf933861445069120e5b6a4ead53845c6f5e0a29e11c9719b982cec2d5721d36d61998c150cee17b5902276f7c296a475a0f8ab76541396c7b47230b7a43a8fbc45ab5bc5f6e39c020827f0ab0cb6482b380a77674ddc66d34799eb49cc5f257962bbcc178d670021df0b913e8eed58be5939e1d56a938b6e08bf41b736c26660c6bb82ef6411f9dba1610d964b853edf86b5a5a669d176ff7b5e7cec6db509922d8af7d7296b0392fde2fd1d73c2d2918367c65d492bd26f8383cfbc232429f214d432f8271c819eb3177b068479ef8e731c5572946c9a87516f5ac0275c37e565092578cde0aee9d2c37fcdaf9150587beddd826afa9eb6afc5b93863db0559ba4b5c0cc3072a69f770965fff2cabf17f765472e0bc40ce580a8ac35be3c175d845d15323a610f7354ee09358abc6d1c60870df41a188a606d3bb8d5b19575a0f47ac9d7ae3fa7f164fd1b9a12762e948b111e731dcecd4912e2041515c5ab3a5a0cb6c42ddb51108d71aece93bb360a8ec7f8f02016b22b4c95e5f7e490391971fca70191ec61acb8ecfa2f014d154054278c32c471d47844584ff6f85aad17e3ed1381b747965bb603f996c6d2b06b194217246aeedb04ea9a4e0e3165d8e4cf43288a4533a581d6592b2252a51a0853c7d94e6c3737310fa18ad26c3deeeb97115dd9e137a459fc48930c8cfa6b6eb53ebd564596612399fe8e8b2c59056d06fba3c2ddb65556727e3453dc98f0594a3c64fd05372cfec55554d0ee6b933f4a785995bf8389d2188923f056ae0bef4e990087842bb1fa7109c7cf81771c1558ca3b18e7cffdb7d69662d0a7c345c82289e02c26a3f3398852971eff091edeb4316b0d9f3303c28d2fe2834becdb961b6f9a131ffd9ad5019f3afb23b5531d810ecd814b5369e17ee41b5d7d9c3ad7e605338a03586a235e8f593e0daa5ba0a94d389044f76f0a61ad41f64770f87e6609024bf99ef9a181df6e9311873f9d21293afcb41432fa597006f81fd35b1f09e5336c4978d50febb2aabc68150762d02c9cb21ae4978a9687072d3ffaf58a814db71c04c71625a4c08fd1bda55403bec470b1ded1cfa719b242ac3d127b37a62e5d87901b8dbd3e64c52428caac2ae76395882108e3a2d2678a5af8bba0e39e77373521b6434123a6fd3e2538dd461425674e7d4b2746a3360692c15e26247ac61b2e093ec7149293fcb37799ec3d89bd7c09a76cf42414a1f47157b039e423118d784026f1cc8d1e1148b9e3dc74260421f850f46bd92c3e4916f49c0c1c152a1af9e05393197aee973ef2101a06875facede6e82b1cb7953308902f4217d95d30bc44ec936a1eb24946c2c792c9d5e0f274b790e4ed0687a0e4ef8e97b906658c7625003960c41dab5d3b87fcdb816cf31b119e8eed6463164c0bf6541d560b6334afb1f3f1987c6b8490bec17075c2450c9c44bc85ae7fb98e792963fc6317c2a7ad07eb4d9789ea04a939b92f4b3cccb107fbe662a1b096a806158c8544a055d8c32d2db36f60bdb38cd711b8fab10c8594d960df2d2fd440e34e8c52c3fc5bf23997bcce159dec63087cfd2d3e34269f46adc7210454d3616f3421b832201038894102b39a74211d8c7cc5e1338a8454aaf646cb912a6ce537b53253a672d8352de8139f4d330deac9eceba3cf79e0151bb56ee36d3ea027cf4e54efb304b7265ed7231c321bf7c4d7022737f8b1e0e76c70ce55aa71d67cd05e6e5bc9b563fc717b40687201a865cc9ab32dd45e455d2cf9ec22decc462af82614e2dd3dfbbc4a30087bab7dd70017d71ae7950bc4408c706af7177a6269c929a926cb3ed93da435c0739fd119fd8d9a349dee38dcbfff6b905cdda538a6ab356a57da50b710fcd603fba82e6b2ff3a238f709569df064bb5de1972be6d6f2cc786cd18750bbb27a2f8646ef2cef73fafe5fbd7214846cf8fdb3c7d71619e73b5da81dd4b01ff4d1dfb07183ac8d5597267b4837b216bb666183977e5496cfa9ff82c9f6ef954d2bdc6724d3ce9fd1a61dda25eaf096eb5037ad8beb890c72fc79480cbc4a3b76754ea975b98a55092fd9ef5c6928dd23f826535827444c03da8160f2f509213bf55767eb45a9c71ba8ad530e787314185abd6ebf66872f1afa3d140ba61ddb8db26c6f2c113e31b926cde978be392a37506db8a8217b6de467f0ea1a514da4b32922122cca8d162c95632864c230dd29218844d7c06679df88b1bccf3d963083956c9376f282f6baa04c54d2cc14dee02e8bc7675e68f2ac38cd39ffa656c3bf5fea9b729d44dc0b832770965c6f2f9625b1a161952ab940a42d522b22819c9830b1a9264b3bfde2f5e178e793566db21be7b0189464d6c28787ab6b0df1e91fea594bbe547aa3728923f52c15b0bb23fd8c326bdcc4ee3e62655c26c153aa6d006249370409c4c35d494059583b739cb750c7696b08f72e40de4320d66bf837d6c9b6a8deff9c7cb4b58e130b862a744cd266de58e266e55350399f027245e1d3ab2104633e16e0fb05194efc4973bcfd6fc3541d9cc783bbcb44bfb2e8f12eb40aae4c5727af688e33aa008ffa49b12df86fcc34ff251ec05e8502aa24be0eda1894ab437db2c49445d154c1b93190b3bb3c1f8b7d0530d44b4cd7c0f3b38047e439e3e38c54b8609838f29d9104f5066af98344dbf42f19b93d8eab8ae815397c1290f1da9e0673a9edc7338db0624b18b9c56c936980380efd2e4749ed0cbf7d2aa544fa2173aae5fe7e1af485e9e3a9949c947c32cad0fceed7033aedc3b2d7e2f82e45dc56bf4a677b019ee46f0a849e44af59680564c51eaebafdfa4537e02fadc9fb22389944f0b85e1972947208455fe226dac105acb146efd403e80123d25eee4628a6c70e1590c14d99cf178af589ec493f07577dbcee277bbba076ca29c1a26db9c0fe4d4dae03ae06b91226bb700b1787a2add7b15e2b53f36d18a656950be1bc06c491d0ba0956c6aea2d36f40c8fbad04edf23e7e71d24d79d2210450ea949cb867d7547f11c5a4b20fb468d46e6259cd54c3b766ca20d3ddb01ebd835a3d5391f641624c4327c609dfc060e18a750a2475c7847cdce1dc2023255a728fe401963328f82eb4c7857e73d4d1942a0f024b425a53a319d756ea6b6730cb6ae56598f8dfd81512dd58d313c4a8cb5f4d123386ee8a580a4bb9ad315e885fac496b22ed77be86e769db40af444b40a6d33e81f02f19eee2f8bca7624c18cfda9fdb16f4ab61a86c45cc43b9807ef8f136b257a83a729e3021262d0495b937ebeda18bed8af4e609cffc305208f553eabfd259fecfb24f6b4eee621944b9d17ba4f9571611b0ad8836dbab31ad5a364f5af4eb528f3fc3094f9955d0b59efe310282193c67f35af2f799f72df91c778e3a1a4635a30efe81e2576b68ae5c0066779b9bd5b229656a945a8f51f9204827474f2c9c0b671bb5f5b16c94c8b9f8187f9cd572ddffd1fc66241c4e48ad6bf5ba4f11efbf62a848ebe5930b7884cad53d0804122e26ba2c055bb29ad6fa86e0d4734a787c36ddf4903075e61992902a4ef7e7bc12d26a9cceec688a817e1261ae974843ef8bc633740b2476c4c3044c5de6efaa8cd96c0c81ffcd87ced726c836093d6cde488bc40598a78f12fda62a151659f96c319afb216d45567283898a837eb7f9a78caa3161d20e2d37e76e8f1660ce2d6f27bbd0777f5ca72b6ad44dd2433bf5c92ae53421b3d4906e763ea8ee416bd2ee026d19b5e4a4a76a5e267b5d8841c615926563cd35b9ae3ad5e12d2e097b4a4a81edfaf8348729834bb744ab240a70ee05c0f8d9d1f9032d5782e04e2cd522ed32f2a4fee1686012b0692c4d298874ce5c395509558893792feb407c3827dbae369c0a308c1589a9439c8bd41defbd5e679af0fdab7c5c1b379eae254229ad73b438a000a66e32b6041438e45a736b88da4dbd3517a58a34fb4c7733e76d690514ca0eb842afeea397d2c1baaae8df0fa6764020e22c50daa5c03e7625b2039a6ad5263c3a3513d6f797f29380216e99cd221fef32ccbba0436c307c7661abd506c3409297455ebe91fb2466962a1234473b49dab32b611d35b1ae76a8692ee0a75d492521e62e0168fce851e935ad4925c6f9de2b81be1ab5296763735b658bd2365a3193c7afc846a429dd148bc336ab855a7f2fc0af9564bf57f1fcea95e0970e11957499e7efe5f8a506cf34d76dac7249195807eacd5d9872853c2e48b0fa41449973623b3b62677fee6bbac16248df927bd591e21e65b1beb680608fa4e6496bd99f779bcdaa7200b82d61c5cfd7cf34eb3427fa9159a9c42c181d563dea9144ae6f58ba5d66f6406ee6ce064b7905ea2bf03f8f153823d06ade03725181be8be7d612b6d3ac058cda5cce078de364bdb855e154247d3cbae4b82e42359b39e28e5ad7a3352d9e7d0653c2ceb412ef02da6089a3e0f49222556c7e19b8e2bcaaac266766384a81d1f5c57f185f1b5df8261d7d0683954255f53900fbe53b01c293cde37bba04645b7dbf9771651c077325efa58c1ba34cd5b109e62bd70703fa601896f55303dd0e6821beddf9d047fb782f747b6af09b658fdf3f2468732fb5d41aba629a097b1e9aa72ee29398645090f75b450b907722c1d6554ca91eb608966f1197f3f2637c4518d2c114833bab929f18dc9e33c39db46b8d21cb7455158559560230581a1b41a316c96174472dc5513741584a2573c474516982df950ff4341f87bfc29be4165cc55458f0dc175659be1c1ddbfaeb35e833cbdf84c387a2e0720cf820ca9eb9f8b901fb749c6fc9a35dd903fbb320b256cea0cbdd97441169a3e31daf06c4c7a5693b823fb40baef1f7f3599d529908cf2fad1ffb948d99b79845e2fbc997f40f19580948e0f26fcd339e23450bf4aa02de48082574f55d706b872bdb72d444c06f3a9f1c518ad04cb03a3b326e1bdb1f0b9c32e844fa69577c004ee4b1288b23b9d3bacdb7edb16f532ad84b9051a12ac1f05be1925a342e1604ab473d01460448f0f404b3893c2a4a5ad67d1121888322cc6dcf8d11486a6a9877f8cdabfc53f427d6e5547f0ef19517f057cb78ee96b56db843e1e3a124a0581ce37e84392fa252d58c1e71878f897ca7f32a7f7f25bf0fccfc6261cadfa9dbe72c97cac3ac5be8478d004353ea760f0315552a52fe37f32a716ee7835566626aa97400c4f83282eec033d3f5700955c5682174b866825e99336e2e9b619db2ec33526b18163aab640db0e3d5908028e5dc32fd3e2f1ad12f75541b8a284d8da358cad78a57c8c38896728b75c87fa560cbb954e02190dc2a13b4c189fe2586d20ac39955294d8a1855438be40b52df5414ff59b790654de3c52f5bf4c71d6f7f01735e8e53e1433c6520336b3b61bba55b1c48e6908c2ca9de6560638e094466ebd384316796ca14ad51b62b9b96a5b7ec0c3c3da13fa726d87f68ccfd1d22a78ff0bc275ea7c4c79bc20b33e78e1a0e5c53ceb942c22da607b55f806a88b2bf963bc4c53447d25b0d9d46261a892170ba0594b354d019783f07a6c5ef96897527ae613c2712f31b10c13ef332c490e67d622549e2145403f60ad19eebd27a5e1dda95f5d5f250197017422cb34aa943f84fd934578376f09d4a09e773db402c6f6154034f4830dbc5ef481379dce98d6708549c9eccebb1dbdaca4ba0c9252fc7f66a68bf2d4e6f97da540c557f952e92d4d6a6ecc68063b662cc6360ad605b549249fb703b408fed36e99481e1d348c058e5165056b5474f4f7faa5b25845299d17b4a429f787318289d299e98fa2754cd39ea5a652132dd4e4753f851a23442d32254b87c0fbdf0d99bb038c274f2f610e129a0d58f4bbf2725f52090c53fb7535864edd135db415502591f939af8d82bf54bf971dbfa013042e613e821735e6625fbd707b39f083640b2ed42d6f03e3b88299f17ddc29c2eb2fc4e466351b366575e5b7a276297a07ef683fc173bead3fefe0b6ec3ce04048475f2524f1c81001a989b05ee410cf27bb6b3bb74b56f88bc0e4ffd6bfa33256798d0840e85cc863f5e4b58a081936342f80d51e8caaeaa68c9bdb832d1b9ae80837422caad1a218dcd9e4372f0c48c5c3fd28085172f398d0a8568988a780e8565cd8680eafd476213688af8d9485b0d3127a661fa201f0bec79499c50b116f3fa6fa6671ae8a54557b02ce9855e18cfa332c09073019008b8cd7376cd0eb8ac5220689f260164fdbfad8a790812884063b1f22f4fbd1c5fe5fc68b50e4e939721464e94a992a7c931e8feba508befc594489317c5d53b604addfd17a4c8c2a615adc8a4c100bae79712603a4bee8c1087d499c031f2ea95eeb2832142d3532c5d51112b142e2780d53a0b278be857eb9a5fbc494b28e608822f44f40ec9d87502c47589cfd192fca7a45aa3ef3f926c5fa9922f10d95834ce28f52be9762547cc712b245a415729ff22743f5f58fc2c5571c8447e2bd57908582da5160cfbdded3bf40ba378b5f69f51a4fa5e75c9e82b6765814f20510e622aa50732ee17a4cd4a5f5329837b7dc37caff9e1cb94f7fa24d1075e87bb2e136044e35f88ac45c8231b0a8386eb66465a918f1718f0aac9c968f13604d3719c27fc7c1dc792f455c5b6fabc17f56098cfc636764fdeb1b7c14acce4afda0598804145f92d4b126dd2c0bbee7f5e4051ac7452454459c1c464b8e1bb2d40bf44d3eb533488c15e3de9a74fdc080261011191b44db7ede726bfe633f73c5a9637fcedd0016b2da8f3823201039cd898bf6d798693cde18aa4cea500a33946ba1f6082b115778dd56feb8f0dd16f212a50351bad566908f1e93eec0f27c5a83f52a660b596b65aa123550093c22263dabe440762478bf59144eb8cce8017b7b7f0d4dc5da9eff7bfd6554411e71788e78eb047bb8ce3e4e033117ae60e6299452f8b1fb0a01b2be8bf1bc2bca155d360d1e8da298fbb9312dbc717ec11adf04051438ad1c0cc0a1b08e956edc879f625ab7761091a945b4bb7fab114b89930b703dcf79fcd1ee3facd5923ff227a47586126c87ccb8ae6404257e5e937b0d2c1b4df846e44fe14006606ca174566dc3bad3a86e96e491b8f6946cae7c31681312cae2080f8eb392b77b5e5fc67831c8500e8314afc45e54cb0450140bf34846b9b54c1369f21f9ffd28e6fd20f65be1f08f82cef14aef60784c7628d7847dc67c09901c9a69d21431b008cf4dbeeec7bbeb3856efabf441809c19ecf0593d8a2b12f05d4ebf6487e6efcf42971fe2fdde448c6df4b4f6a5c89d2c29078d430db09ee2e5defb0689dee9996de38e656b0f7875b79edb8e1813b9bc04767e560d11a57b6ae7ac3556aa6c0a2fec86671b444f409e6e1f5a39d40bf7a1b2b3cca921766d54d86ac047bbed8659a281eb7f54b8ac8ab2a5e0d3e4256d3aaa9fd4904aa7055b41335f87277fe9be612dff02c56cb8bcb112f1e9e9ebe2394307417fd64316af4fef861f06558917a754949660c696ff75670f8899685e22f70473adfb3b9e36c6cc3c00e358a974666d2d349a1814f388b94d080625101812631eff0bdf3b966fa41444d2ebf9597ee132397e27333f8fe08639385384887acdeb2f59abcf51ff6ec2004764d67a9318bf9b4d49ddc3382030dcd5473b277d8d7b82ce88f8195593b014b96c27ae58a22fb20e8540952c271688f8321cabfb6da15a51778407975682d466f954b77d3d4fe9fb71dacc9c9b9f66d022aab5e945fdcd6c6bbe3ad05c5f91be65675487a53d328cb0ea4f093caaf4e9f357be15f239fe2aedf68ac8366e5a2a884315890c5689db19fb52d5ce2ebe1ec","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
