<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5f6a62912281a00d233c5f53d7224c55843181d31054d8f62065263a9be1ca6112e07f7a9d77e46c60730371280684e8fe3065f7e357616955aa4cc0026f1ff259c1b180cc6e56ef62edc0d2342b72d776644eed49df3db9514b5bedf066ca5d1e59eb5414e612fe0ad5b2e58d40905cdeef4ea0a8d320af7f59fcff73649920411a9675f7c36366b90823b6a3d7b078c74e8679e5eb3837f9f733f1964b43db3a50847b458550bd0d7c23d798bcafb157bf4f14b3b0ce8910d0bbf42931e8c8fb4b48cf2f47a0fc6bd64d1cfb14ca0a7148b06325352238716c6675ff7036c1a5beae3740e1baf97104d1da8dbe18fd868531694e72b2cd20c07bf98a18d005d201916d352c73844c7b41cd5a758a66c3130e14973cce7ef72651427f8774e071c67b081439c4e744b227ca794e9ef1f5e5a39b710025e2a66ef28302ec481a18cb95e0edf298f7d9070e8816968c14923bd8d694b1f1c59dac8b8b0b569d21f404afefc7e377e32836092dd286132fe52ab0e1fc63c84b1fce5905ba2b6ad826a0bb5a8ab78f1dc02676e9d00ded944728f95f11cb42b17780276f183c9ed98b3563ffc7c756960cc89dd3e2882a858bd16c41aeb70d7eee6875641e58a9acb4c8545cba315d664a3dfb171da5a1fd9604c7ab8221d6789f7bfc0b29fbdf00016b16350b446961f6a0231b8ceb363699b0842ad80257e5dde434dc1507d751c447de47d045135a83996686288e38b3d946fe6507b26957fdc5905767bd627ef3bf245a6cbd15f9e25f3a0ef737780880a97ff79ffb0d4d8d4048c20ef340267c07458743bc932235a2f4d87596e0e447fed2133e0f70886464f514e8169781fe12aa9e771493a6f91b9857ce960526e53b2acc827936d6c78ba30516a10a5941b3ba942ed1366e5db028ed46c387c3eb236f3fb28af20e375293fcb8664ea6c90846e80ae66aed684c9bc08ba0116d5622de449edf57d17eb78cdc375bf96e948241ab0ff32630742a45b4515b51bacbc4f806dc4a78d4ed05ec4dca19675c42159f8dafc467ff3e392b4c985be2ca48015432afdfd1736a52ec1b99487672365dc03915917db96e563c94ded8a3dfadae1d14d24f26fc6b1c1eaf6a0510e9d5fad31991f5424b4f3e8f481945e05e9a2293f54c0ea1c40bfc0a0b73633d19c8d748be4ed542f62de323793b06ceba14b31e38f9f989787e49b1c9eab6f2d4cce65a6fd3742077ca14074550d6b488a4340c080b180ac0d47abb1d340a15735de6fe7e35141267aa45f2bd0a466557c0d6024b7105bcd0020ed50ac427b7146fb02b6363179df6d407b94bfbad48a21afc576a717ecd0d2e81325517c7823d4e885863bb63b82f44b12bfb5c4efdb42a5fb26135c8c8dd24bfea645b3d822763e3a3327cef864c8fb27367803a232ef769439143aacb1c0cb0cb9d497fc6e6c8c416ecb058ef61e7ca9d00a4bb2a9eb75c15c585a29cccedd1b250ffd6caf04bb1a3db4fcb90a67fdf49f6dd8c1ac240bf908d26d7805681eb0f59f693f229fb1201eb648385be718674012014135963605abb32beeab0b35fcec9800838a5c5c6fe1e69836d46c0a1c9c217ffdec52c6f912acb34e04103237088ad55e874aaa68f70d617f226616f4dc250c1ec2b46f49fc44381401c3936cf8e28a69f55600353451ee23db55368b5b5edfb740b9a6f8b63b7e50b95da29b00f1b28beaf7784e797bfb0d95dbbd792a67a441657bd5422a449b01f95f8156e99227fcfbb72b64264be0892371ed7a92af5f8fbc4e418d8909770e4ae97ac2eaa565157ac6fda3fbbad158df53c4683f999c824bd111ac066ac23f3a3650c798845e35076054bc803ee84a5bb4e61600afdce008cca698135aea863a2214f62c6b71684bdfebde99fe393e4019c5e4d1976c488bf1060d6b709c5a2e29fcd5b3bccaf548339838b4b5f870c34beaad52ba686cca7c2674a7ff50b815b42d45084a38cc03b6dbfa8f494bd2eaacb000236285a05473962a7a840e8bb7bb176361a76850aa141911ec5d61ffc15a2ffc4ef6cd963621846a3f7c86b2aa40448cdaf18fb7d45009c65c917762d2a0fa842efb5d79fe963b2c55aa6519cdc7f238be77d45f98672517b54237bfad398567eb2c4b187d03028d77cec3331419c2e546b9dde7defdffd3ee41cd780dd09a0cb972a3e73a143160e0e219f56987215cfb41df952bd2db1518ac7570cb12d13db0dbf452c0dfb99e4573b96b30c11c57346e3a18f035822950cde7f9a863f8af11cee7aa0dea2b7d7664539f4f4380536dd1e59d7a3d3ed2df07279b4706fb606892ebec1cbbc7c44e3dc858e548ace6f5fcb9753eb3c0a62b9c52a08796d85d8e1415acf4b3b7d091c6e4462709bf50e84eb1f6f6cb2ffbe9379737befeca4ed8d8ae2017f1c616ac924da8ba40cff677ffac2e6b3363c18b46dde65689404372b9f6e53c5b063c4d80161e08b88f28169141c79fd6d5c654bd2ea1f3df66ba741034fc76ed12506262701354ef5a0cabb7e3b1d47055c792e1da6aa8b788062eb8767990c821f951b2c55c23bc69720aa9767fdc1721ac996fbde0116a36591f514264b20776b4e34c767f7d166e05a44cab54aab3e4c23dc9ea6c21606abee5478682f7b49026f00eae57249ddf8b32232b82076d9f647f84e3e48864a879e90013f8580acdd685ad2ce7e2181fec1dcc7c096009cf12a0d8705dbcae2094fe392bb1ee82092a68bd66acd27478bb40a2148d4e6f4040bd30318a1d33c7d0eb4a09566e2d77f3fe06e2a2f6234d0f3e22d49430a428189f3e8756d0bcf6789b296e72f6e5763efb6cfa19047e38a6998991017c5e9cf11f565db7fefb7316bdc2e5dd228bf1e518a3611ac4cb713b587bdf2d2f905ee998c51e75b042cac109faaebe54ca311a55505e27e1b1333f0dfaf7ba040c0010bd147ddce78bcedab70d206412aef93d60509fa6ce465df61cca357f299122cd46ac6c59fb47ed1039474ccd601b2c78d0b1a453150e2cf67f3c87edafe3fa6228c6badd0bc3320c5857c34122835ee2ea2b81d14899cc174c0eaade866d70dfab4f00477a8dd97216325e011e39b18ee0ebc31b7179d96dca2309a93a4df9b4a98c34313923df148a607425e714797fa5685d1ef53175b8484660bf33e496d4b97b357800bd949003bb9d4909fd1509963c22723612fe57ca4c78b535e76a007a68c31b11118c4290a9ce0829005d045d1d4e7c36cdf9d1813976ed3c2c021c0585a0550f97638148a168674f8f6e90fd4b330c20156668d7a35f514743ec2686cd9a0565a3d6659e4ac9cff0d3410fe8e908b4bda1c57fafd62d1ef876149a94b29247f036ec8d1317e6c6cef551dbbb0b69b6d56b5f7d91dc0e5aa9f66a57cd1fb18d72b8ebcbca6b2e579825cb2d7cf10ce6ee94981d093e56400d89d12a8a51312ee0d4bd06cdcfceedb187379e0fb06ce2d63ecf34807a78e2935260e703a096d1fee29ae88a6c71c3aa2d5fd1c245e76f1c767b9dc6221c571dae961181b6dc360599c7c5d8dc8e7eeef9e13279e6b793c023ff0d846dec10b15ed0f1691485c9a5665a468878d8fd986eb161a83401f896b0914038ae75bee4136c6abb847e4c4d3f63adad0e7f1540e41413aa4a1671b2f06fdee6fa71723a91174e1637eb9623b65986722c8e3d9c65878761c634867e2686246808f83d31b4eaece3f347f9ab3910aaf3811b0925e770999d066f3dfdd02a958beb4a00c18e192199d4ed11ddf356f6b26afc1aea0b14630abdce0f0891335dec3ef797f88636223da6a8b3ee539db9923c58ebe58eb977708bb063bc5f01417ae291bab99be9bb019dd8a4b51f6e253aebaeae50673106e707e0559c40bad6757cb0a8e555294fe071808c4dbbcc95f8bdefeeea158eb62a5290296538ca7de26891fc2b89ea6b7fd1cb85b1afae447c72e887d8f7959567114cd252a940d775aa0dfebf0c002345b552f8dd8480ba0f5ad077f2e06f983eab40947f770c4c99355223b6a7decffb470a18d753a81807da19547fd7bae91f826976701e066e75be3859b25514f093e328425e616fc46bb9330d85a785d90feee72cdd77621ced61ce8c4e0747e0cb91e584c57242bc253f5a976d481624d6fd0c85b54c33f605f26d69da70729bdf149da80750e7dc81ff17f45897e33b212bded6906bc144c5d10acdb96877d5a1815327ee2b4cd762af1c1251a2c550e793da7e5e3e22326a73daf8cb5e144b128dc7e5985ff8e2cf3fc6b3da5491d9e93446d33bb6acadc1634623e09304ce6d95af5ac413f54eac548d99eca71baa9d61b98ef23baef84be94910bd3e6c5ec77ff2179c7283f2c71250b6a85a2c14773841de2df2235cc0a437f19a44c7a4742a8b6bd5fdf3fbd2aa8a1109c929c53bfd5cd2a76ee42c7096cdd7d991fec2ba84feb7a87153040425a6ac9faebc58e637e42f9366a592641854ad4dd3bd8b50a0df59063b6434a9cbbf4e5aa0836c44ec9058bc677957fd82c3db08f6e8165e97cf9bebc9c8e7b631de66d02986d41af8048b47213b0fd410ef19bcd7be23964e1c2ac771a6e702597329a06f9f52c01f1eafa20d38e6748305982df72541dcbc084ec3844d04dfe83ed7ba60238149e2ceb844e693324c4ab149a407d19bdf1128db049b9fd1298bda4592386af1b336b98d944a53c07a91fce3087476bc3fbd89782343870466f7b0f5d6ebe9beed382e72b5f060e6104f5a0f37aab6cb8c77bc0f10afb976292a2cd5d10e61d27d46048668bfe43a6a0fd1138bea64fc6816a8b8397c6e0e1e8144b1440b965775144cbe621df0ba56a196c26d60367bb9b8dbd0869ce26d3a5fb998a06383adf70345dc1e25f23b7c842513fa04bb9056a507aaeb15fbf3fb70600c4f3fe9c7d9267ac6c145b3436f4620e31f0fc3590d3e2b45fd375514cfac9eb896408e95b70cf3fa4d37da22ff024a361ff4bdc822fb1201083e18c64da05d665fcf01e7f514e92b8f551d455cc25cfa86d1ba38d866d87f8d30a3e31b1c5751917f4c256e601b39fe6f0da365e10d40b38783c5d038c34e915b9cc024b3eec8a1ceb7325139337f888221305b7cdb10d80f43e1d6a00f918ef192391385c6306c3d4afa4361b67e3a2079a61f70644bafdae554138af200e45fa45fd3be4d8f4df60e76e3772082c71537be5667665db5dd9a096c0322c595f147b8f7116dc6bb2d261de9e6beb94e501275a27bf8f95e8908c63c4badbcd2852dab9ab269969819af3f6361de5977f7897a0462d9d04a515131742479b51d50502e23194e0c7ab6bd3a3e04fa2a457ea62ef5fed9e440f70ed2bb57d9318fccac67b0efc893103e162253b2d878140ceee412b8f8c52c8643c8791e0cbf6114f65d5f060a46e3e58762419f2620d9f52226e73dfdf075aa0e219151bb7d11f007c58168f4b50d4beac01e5f7a6d811ae528a5975f332da57a7fe00b276c277f9540dd70b55fc945e77d885f22dd8ce5c2c3d5bfec3a177acf6e9df428e4f0e5324164c62c512d9654869c13a0aea03c6a292ce37f47cb03c06b962a8fd7c909777359c17087eb8ac2fce008afd56dccc8a0b14408baaef6afab9ebb8aa5328caeef2b0c4103a7dbc40e4c44422ffaa5e84a7969f8501938d6ba1df67833f731d7640598c8bd17f25694213821ac9fad6317fd66f760cbfb028f752aad7ba3ec318a8849ce5512f7a905f1d398a6ff1901dd5ae02569f8ad5f8ae0095484b596b02e4543010d8f6efe4f2bacb7434738e5ddd1c1974797bacc41b8182a3da9ddadb3e40111b462b2ce4ec254178d5728c760a27f17e8cbcd4ccb473c39181fba8500ebc82676b5010079d1eb55a2173c7100d0691af40701fe06ce7095c16cdc4ad16c7c10f4d7a5390711fe2056679c3e8213b9104867bcce7fc19d72235981dcf9d7a09c2238afa457c00e78198743893cbe99ef761fc192a5561fe779d0a0f505a243204f7bf657b0fc5a3b0abbbbdbbc4c66ec00d0d1c11348b2e591160df354557844a063d9014f492d43ea7401a3b415f5c001740707ed463e7da4784dc3c804721d0cbf0e7839d74cb6fe54a300af91b82923471ce3c2d0237f67961ecad1347d2520cab00d7be1e200ff196227536ead20efcc04b30131255361402315043ad427fdd599aae073a829fc76be56a873695bcfae18c9c74ce791d758da5a14640ef183c3bcc0bff8b494ed9e6d91d826ada9dfa3417ae0671fab0781e83cda432daee60ce78d430a13410382705172b44888a4d917e0eaa1c598af6b3876e529e6db162feb5fce098c2ce96940f65841c7a204e1410de4b4b9f143333b0c2ea5191bb08fcfd67a5bf8245a5b574916bc04afb5e92f01daa64e71a8d9cd18ec49136eec40939dbb669bd977102e9f3b0ab281cc15f5eca46658bf1f11002c4aa644e1286a87e529814cb371cdda61dcb8de5b5eea3168a95be74fa6ec28691bd681adc5858879cf9a8bbbf2314f666903ab985104e9889d8ee874b346be08f5158c5aac085514598efa4cc5e9c5148b0b19a98c84f746f27d46cd571bdf1cb7b44b0931b0a9d615cd8805a29711acfd89e2d8761275c76523077c83ca4af7634c11b7b481138cec3e7eb02010965d611a9ef1b908d267972684bb43dab1651151f58a4709ff83a39f33054b21709a768d1315c0039b858e7502ecbb070390585c848345231133c58a8b45525d2d28b7f04d96dd23a16fd5670df247ce9034f42e9c28617e7532e243995e093420a39f18a705d58254c6bcb363d79496dc5078a6e4a8eab05fd438fd7a88070c7c26f57651ac1eb988aa91fe3bc8456d564c4c81465c7f0c8d6ea5fb37a79f1d7d4650ca227c8915a1dc26e10dc9d8447d28e8ae4c6f4e751b62c7991f01f29d06cc7b84909e30b61bb4d3125caa683f44bfe264d772dc30af8a0a0951f2cc808ce4247af5198ce58f8fba34fa0f77a937da9dab75f5d48218dcf1e62128f52cf3aa38048147daa9057f958e820f645c6647a0265441e2ce891e1c650dc695f1f3964b8b28a7cdffe75c54770d8c1ede5be9566b2d53bdee5391069157f09d8f534236060cd70ea37836251cc4b27bda9185b25ae50ef8fe32d2ad4623a53e0e42a7cc7c0b968dc41ada2a918785d9261a5dda342d60f0d7a9830034af08b5b6f968b67ba907b34c0f91b58021056b1429a0c136c90dbb048361fa68c3c2e50aa3ba12b451b49ac677f01d4b3ba977f659e8a97abcbfc1fc1112b51e95c887203539f862e8760f56816e1b63a248288b27b2e2d5addf9ea0449cff3d978a97003ca19284c35a866d56b730f335a5ec8129d3673148e3c36b1b9bc4c71d4a06631f93ed00f7945ac33f5b77413126319bd633c31c5e12998b71809020441ab5efda484c781297aa67f73775f689fed83d5932d9b59f1e873fd52806c76207ed3e43e5da0f147ceaf6bcf25ea55a0dd5736ce067ae8b2c4441016cf9c45d4923c641944a5438d9c8b9c69b5c90a745f02481ed2198d38dc148bd94d4807fa6799d4b5523c05d00bebe008911fcac5d8639cfa3fe230371d68724a2bba4e386df8e8107006611710c8e2e0687f3c07e575453859f2fdd78388ab4308c151b02b935e6686f55247b45abea5227a29f95368e7c5a42a8413cdc5f49930c1d0016c55cc1005c6df1e7bdfb72cc660a41d249e64cb339f617f4f6610d256262927e2d8a4bb41898b20c190df21431b8c832325cdbf91e3c39840952b8912f7cd14804dea3450121afa4ac2b473b606d62991e7f4259bddb3e5bf74115b7f6e5b4c669e63b771ce47099fb21554781b28acd059c67b864a26dca72a1d67c7f568d2a172a94b950ab27e77449f16465b38c3d14a1185600a26a3dd427c3c5b6799aef4e765754693e53d93e419ddfaa814bc8c29d138ea2ec37feefd8324d2316a87ac96cb65569a024a082f7293152e7bb583ca58e2537ca1fd6969b78ae1c30a540c3571f7561caddad1d32964e3255d9a14db5529bb3ce66b2a6ed30d7ce1a501c4f67a220a32797ca31ef045f072c6601cd82fd5302f09d6a4c6a66fa1d78a2bbd049f4d32a253edb16c4fc33993398e2078325710c9923b7a08c998b485b599480ce80262f3db8ba04b5f4d21c7568c5bb417c27a1b1889bad415b51ac9c02db192ead1a886754924a7c146413e810e2067534758ec6ea50da3b489520d28ac997552b0d57c9555f7236fa395901bbc0ad1d37dc07f006dacbab61c6880b8c57d9da83b5eecf0bbf08e31c3ae768bba4df73e954fccfb0e0f135626183ffa59b11a4f5c1f87452eea22214f2170a4e84fd7d0dc05b04b12a14e8b88fcf73fd2734590156b6be2336329a694ace91d33e9e5dce2f1401af1fa183b797fe34198a7eae7cb5f04d6f00f8509e6ccef6ea175858a96db384f27dabf7171b0b30ba839d68f866bbec42189845c749a4c29d32d5d7e6a7b1fcc92e1ba2c7949cc64f15fb14399098bf468b2fab6e7a01dd50bd47dcec16969f5771a3af3c3ab0ff5b0c50f1515a810482f17a3f99865edd1e91834f5d63a202ae34fc84b1b89bd4ff646c869fd38e7cde953df403711a26ecae527c1ecc8b4ee249bb4e4957d9cece873b92584331b5553286df0111ccfaf39cba7d9466d7ae6767c31fd372b89dd5073ca22b0538164d28536671deab47a0bc81dbc2ae99ab050ba3790108455c648ccb3eab36668eb152d8a3066a983db696752e29b29911c8e31f2b326873d0e7dc30a04a0922c792e2b99775286bccf722f9bfbd300ac767c341ac15a7a9398d6ae00098e5748660643730e05473dffc80d6c33f17ff1992cff2e5bb155040a1108ebe0d857d748150e526473f43105a0c8fd1a1a362f9e66e4bdc340e927e3790013f886c72dcace9029944811f90fb3bcb814b2087daf5d070ea8d6fcbd11397776828a16acca1659034cfcdac287962e7a7339a6969603e4c8358ae073c7f9f1d3307354d3309f76ac9a32723f1a54e70bea35a5046ee51ccccec0bdcff876687c1d7fd5e1e24b4b4c5d3d54cc260fe407d7104b49a47dd63f95a5e0d3826395407ed59c555d21fae8792c1ce460d5adf004e3014e23b538483317a4e0c46ec11bcd4d3153006b8668a01deae49a6b0b22a9327bb8ea1ad6d63563b72eb93976e97ede469949cf72b9bbc56ee3b0e00e0c133b2ab0454f2fc0c3832d8e10458439270d1e8fa954ce8409138962dc5c28f7dd303ba3a4b98aefab0c251ab1559871498aed913493b43b2e6e3454f7998db5d86244aa574de05e18dccc4e9bd8549d4a8f9a59619311e6ad4b73640398a240e77aa3a75ce1aacbc78e9d5539faafaa860f3c5ff48680d8b413fddf3f3201e616498df8c0f4b7061b72bf847d7e680d599af66708aa89d1c95638509d31036306fa4af46cf3361de34079eeefd991293cba805e049a02a94ce93560465901f8f755a20cb5a083b1f18b8afa9eeadef51cdebcd4ee99b9b9f96a55f323247ab4a8d6b1b96e9e3d4280f76545f486d20259282d1bbbffa3ab647fd899c7e238a4cd0a98224a5051e213fc521c5bc6c8eb4348bc6e02aa99c36242ca2c97e52cae64c308dcb545585590a82dd0f42302382e5f21c51f8a4ede82b08a4a6759ea5636a8a6065316db4e6b790d1bf8d8bfacf2b59a64feeee212ebc883aaa8523380560689f5858790151cd2e6dc4674888267b354c0b3d7ea922a553eb4c658501f29969cb35a517e215fef5cf81ac9245f83f5c85401a8ee786f75116a237fb181fadb9aff92b03df370ae3c8afcb80f4b9759902d4da8f556ab3718ed3e56898c1c2b9ac7a9cc7a6a2503ac6513b8dbf7eb6e3808c4bb1647c3d23d9f95e8eb49404492a335512acea3ec2d1b6f0d4b52c3c5ea75dbb50667b372faa3475eb20da8aa96e023947bf917276c3004a955cb2630b6e17565133e7498a55e9091a88fa6f2d1340db36dbf52ea59933e76f5012a06d07ee4dfd51b924cbfc5890301c90ce227a2f746925f45f3fca6b8861559e7a165afabb2ec4431809704a52f2e326938b93ea6deb7f4ec83c1ab5f56a1a6d0f2cc461ce2b875d28bec1aad91d42cd60d3bc19591bf003bbd3ddd07a16d1c30906dde9021f8dcdd0e29c777bde03d83629444ab7b02d48e22cee7ad2b029ac667f53864dc6daa48b1e0f8996dd6135bfd2ac0b7722d68676d68e545039a58c7127fd76dc034475cb4cbcbfdf16da76448380c354921aa450bc0471e0a8617a9f450b758c212f9becf1cb839135c5159c7a0b59fcb6ea8929b7d15c859d4c37039abebb2a4de37af38fdd61fea8dd0a525d42a9fcb7a64f91fafb6e6c2512a85e1b9ff5f98b514e29a2fef98dc3ec79608692935c89ab312a38447138f02d7c6dd6716e37c1d6b0b107bf9a4d2b24777ff0f7aaecfc8a7a510211129f9a94509e5b229d2c91058023d9d982b71db07527dca311b3a7a1a2b2efd6adaf3833bfa009b5fd355c63a8372ffd413dd81ef9750e1f0821131c56c840969283adf166163555193d8de192bc4b90b860ff8dda1c9ef55c2747f3b236e62c35ca1267a2bced00e33e7f8f21d2c98792a2bbb69b3e46da09a98018175236a1f56a03ddd1e9a5764c3bd25b690be156ffab54b5af103a6bdd1b97b87a5fd9f2fe2fc7812fb61d7c84720711f46950a3664da23604499c4de0c2f86e2330ed743a284ce5b58d430a1eb701a18f6c5045746e16885416bae4929a86c66cdeaf60e8ec8d73b4ca33908a0c27df0fb4d15075933ac413ffcf1bc6cff8c1d47f690dee3bb546f03d481a71f8196872b375825ebe0ea5e4ab10efdcf12530c92678bc1f6a575135b83c24242189c44cdda7cb01c4709dbcc8a9275275ec12199d486ea3ddedcd669faba22948b74d12ba663e271fa306c4a910f91d79659f88b3ef53c027761b8132d1c580fe6dd7eb6ccf5d7f2c60da620577095a806f03925a64b8e1c46efa2f396e392894176f67794e85ffd371afe2dbf11963d494a69061a150306e8e759b6f9aadcd19ece095d47be15529ee457e54f3792131cc6fd5ef5d43c1b61fde3b1ce1847f9e18e6fd6d20203531660ac51acd5108832eeab89464bfd80901439bbc4c21bd77292af9638d6c052c8a1696f39aee60b176c162492841ba2e46007acf06359241a3e23aeb69b322c09a62b8f4d61cb3ba2d2921f5010bf85ec7985d10d8ed33a8f06a737fd8e1b66e6420999791e08d3f4a5474fd83b1b31b59a06de1f690fc3e7f11eb4a0175b3ca2b4bfb610c223399fdc58e45fcf74ce6b207129986025ab6faa95bff5d3ff1c701d600fda2286ad90338156f98512949a67d71cac1cc5e4acc3ab6dccc9b643cb0590fc8676ae3334fbdac42a9535ad4fc5fda977f1428f29dd7d63fedfddaf26bc6baea7c2feb2895ec7cf75d8ba5dd5ac1297a2598eac8300ee93579f152d04b6ed4bd0233a083d76feb0e5933c4199796d92c58c230e85693c87795dcce0f86310fc85e2863222b4095256a593ce050e0a94337b94a3a9d10cf518804bcbbdbd45ad878b4c02dcc5d19304922c5fd8451116880564b32e11c7582381bef9c3f28cfd4669088dc3ce6d6896709e3ff817a70155a95a05ba6be88c3fe5a5ad4ce0167209117dda7b6aca384c69d5210a2d3ea0ebbb5c065a504c7d18c1fccb8ad86c06468b7557fe8cecd384a7adb1f7a06b074ff50e614f35033d81b6cce21a87233c40455263f03ef2d6945e7176f0f8df320ab4189b0dc6fc4a33514c8b0af36ced4f9b659c9b14bd506497533b873ba002c348c54aed7616822a254c8e5732e4a175f98e756ab1c456f7a599ced683b901f2a2d8c529f11631998d6239375b288d057fbd8b99534ae5f6a70e4ec9c7b8862e83f0d6f4d8d4c119addf6c37e9452c7d3f310f1c3a2b9cfd6039a45573826f5e16727e80a5590b6647fb4761193577f14cc3e0766909d0834071005f6e79bbbab9116c17234fbf00cb69d9a19c875536bf70b59192c392fcc1da88b807cf9868a06ba6aee2dd52ef429ec75b636539c78bacde9fbc15d615c69c25a63782083c34f1f7755b7faab3499c07e3f2f1ec6b38f2162bbf6e4bc9f35d75bf50e8992f8a5aff56ed07dd5fd42cc7f322d87e4076eb0b34066f2cc88a4dc61a4bdbacf8f861aff3b0e1e4ad06f733fe58954cee6f408ad3b79d761ffc9e1c1ef824ef618f2d1e6ee506b7584dc970bacb461f2e26e10774314b07d8732ba129d33cb230dbcaadcd480f53a94253384854194f58025e5043148b6f49f262e8c1c417fd0759281944649e6accb78d3ebe73af4017c9366802aa103db8213cc4b2fd39a7501ce49b2561e94a2d0016003b700d9c3771ba55b48d70ddf660fdd51fc9c5480d3fb7f7ab66c31da390535037c6c9189c6c7c00594b8cf38742f86c62968a4f0f64f8dc4a1c3d87d1714110e3fb18ae300e7a41296b069b50eaf35e560e69b9f4309d43bc8206e65bf454939ed3244d680c4264548fa39d6f0ae8fa2f06263a246af4cfac733eefec8fc96cabe6299a58563522b8130649256cbc408bb0ccdf429299e47e6842867c27f84e9d270ac21fd065412a71d8dc37824690a99fac3308c5d23be93bb6c82cb9dd48a4bcc654e4a2a8e7affe827d2f2fee6385ab5d7b64d447d117585b1a1fda9e84369c5539c9dedf760085a25bd1a09f3777238bafc989d3fc6d2fcc2e98ea9ca979290cf48bdd1179c61a192d5f75df06950cb98a07029b807d30eb29626fab625baae7ea0cc32cd46ccd23b81a7361acf7a6b3c7de1443a3a02f5e8d27fed4cb9e61d5943b275665d7e1f43864574f47b483c70cba001a7f1e8865d91b42de0aba7e146a1759de1356d79a99765aeaf81042578d5cf673bf4175dddfe1a7756d26848000704d9e71f355104a89d93ce0e9e5704de3f40c9e4a0adbb483a2f8aa3b51f5eed252b5d92cd71bb45d5bd3d587fd72ee9eebc25b5920e51ae9c82808f6db4b51317203a1bf2a9d0a805c286be3fc20863187ff52fb1b5ad1370010533c2f1eb113575e27237c26912b94ff03f1b00d90097592db8481a4bb554ea1200bc409e4474734c281053d6f2b5859a3d619482778e96f3c59a2a01c00112a8c9ed1c66ced0b973ac69f6791a9e1d966c6f0a2b4d2a6e33ffa0e07675365b8630b959b19e3ea8e33ed6d9132125a27e1bfd82655a89cd6ff0c331b49298c3a4e3a1d777e94178ac1cf762291d022d13f97b51dd8f53986e7ec78eadfc72247a157a683200003a5d6f9e78d24901e8c805940a6e7df7b228ad8be4f84dd3c11959b14b0e4df135cd5e6b612eca7d11e88603bd29a48fa90cf537f6128776d57e2d5b19b398f8c86a637467a6d4e4d4c91fc0b0bfdf5e1c23ec19f063cfde14407efc15b4513c64403942e699c01c2becc5b8ca1b3d514c48dc036d2151f8a57448080bce825e8c68482478514ac71c342a67730b1659ae8c280a15d69b57bbdd367553a8bd881c863934d680a631d9b4c7cd1236f25e172346ca0529aadc331aa6be76c90d19342632de165cdb861112cf45eb6c8957f7e74eb840dd3be358ff977810cb379f716ec47c806d861fd643cac0c515549d76657acef2f5b78727ce700f3bc95807c943b49444e0b6c317edf5319c21e8554a05630011f3ddaed4c97ed8bec650b541acd7ff3744a0be88851b4965ef54a23d2b64e886e32ce296cd51bdf26ffd010c03a863d16774a03886a667ddcf4abd312bbaa6deb6139955e1d4420671c37596cf0671c2d12a8f5a212d75eb207e051fdd5783c0eea1dff9c0d4829bb3d2eec5c8e23cb4a06efc9506ecf76dff73046baac466c845818f4a493b9dc4867c0a1a28a50807d30a7e2de22b2b13670a2a7fe7cf16057244de738a4c481b0ae4d01e7e765fb4c111cf84db05c33c5fe90ac7dc4fae02e7587731e67401cc637f262b3c80d144703622e24591cda1c09e9c26ee4175edb2e84c453df54e2ed9cace9288bfdb8d4899c3af313aec3dc635ea166d19382899612ac4102679074ff7c741aa2ceb0364cb92474870aaf5e8181c8704b7e56ccec6ae479281e5850bbbebf34bf9a8a34135f7f13da3bf7710363af25d7d137954edc7bfbee3e169c24dd527a07fa72a6bbadd569cb942199b81934c238f6e6b2040e0630c6c92e94c403cd3db4ad02c5d560e9756e606caad4f433cd90bb42bb739e4d950bf02c18e729e2785c90488561ce9fabcf7ad79d4679ce6a6a404dfba1097b9e8d6323e7a4935e1986c9114535e6d5ae1c447a5a2884c3702b2ac772050a8d99e04a8cd327ca1c9de46459b07be795350f26d00b11bd101d941967609e53649e80b6428cd252cc565f45abb1105d46509da8eb361d42f7fcbb21d14f31d47e67cb188032e3de1141b811a8236e09930e4772af1fae771f64ded8e448720606df21369dc2afe4b6fda082ff5eb7346d9a11900198c7363ed1c4996988ed8bb17694aa90783f969aa4dcc708989ac89fb5bdfefb7781c275214de5969ced76375c2b2d07eb0b8776a56e78c29bc470c8e9e8c0f6d0e92c15101f632140ab6926e74e06b3cf08e1464ce541091dabf40bc950cb10ecdd29527c7492a1b44c89f8dcebcf834bc8adf80ec9393710a0358535378b11aee22d6abf01a620f827f64a6bce3a5663b18e8718abd47baef6b9eefe69da07088c9a7f83feee17d557ea2639007a1d4ed2e4ce0ddf81d7304b4b843f49caabb5aaaf715aa23157c5a704f77af95cb3178ec9136242dbe318147c0a83a6ebb3df5a8c7190849eb364a4479e71d5ef17154263a7fd352252865bae5d351efaee01f31501554a359917112f7f524d2e6f636fd7f3cae71e360bacdc03f2194a680c37feb97c490cca7cb1a6994b449426a62671b5a9d3eb042b3ac56e3a15805922aacbcc106e66450cfcdf5dee22b5559f47be04387ddffd79e8c2d04166f834269e30f05a3600cade1b8cdb6ea532d415119e434928a69ff8066bcd1a52dc8d78e47e84ba1e492d04e2c230bec1361fdfac1dc1363f5123900a7d801a321cbdf45dd8ac0579da0e6d2cfec598559663300ccdf46cf4207767b7d217b89b288cb1310f402d25977acef97f265ca98d5db607103c41f1a4f52c3f708f971b868ea10935c4cd5bf34678a789c58dea04171a976068335c68a74051e0e7a8cd8aac17a9c2978e0ea0b3ec1af7f805463f6b13aff8f2ce4679b756eb2e9838ce4b575851000906205aa266b65551feacd63833174050acfbc9439cca16fd097c393e3762881580657132d48133e58ca4da129977d8a491be26beec3db7ece13b57e8ef570b03bf9b64ac413d03fc56a1a2173a988eff72b9ccc3b2ca8e093de992d8633da7dd63a020d1d0b2ac02bbbf2aa7ae72d23eae66138e9e22d4ad4de30ffda8949d0d5e168d99b806391cc7ae49b7fb8351fa02b1bd4328e7a3b3cb818191e592598873b0bbb2720a36b1feac63aade6aaa56aab541bb755a33f387609031ae1632ebb98f5d15428fcf0081b42641f22144c75f399d9c1c1c0a80222736e4f0d08ec0f1eba565022375064447c775608ea0b9a310bcd095f13f297d17ce892e988c99008382ca0b64ebc60be2ad1ecab64123dde8d37b5fa03d2171ca83a7b6a4df4b68d3d4dab0baa50f89e89c7a741b27a2af5bd5f00b9d8aa1b75708d650b8abc25eca2b77dae391f6e9090d53a3fc40d65971fe80e95babdea3c426debb1a76ec1dc19e0909f9b3037ae3f588b553c6d7bded1814ee03f91c54652b196e618bd2456fc39b3ba1b1a6c786f7f67bb5d37dc3165353286cb91b1be75fddd3a235497a92d5610bdcea42d6450aa48b18c851881fa1c268cdf409099b339d3231a360cbb331109f800f49c4349ea30bf6ef5eba05f76aff087a7e7b70fb4b93825c5dda75bc2a1b5e","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
