<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"765956687eeb8d0ff888ec748543aced17ffdb9579af113eaab22a181009e653435d6931b69ecf2484d502c25721296e87e86810c3773ada2dccd4ead4a8a2f07a5eabddfcac13a262541cff04a20b6c02cc70bb0da13ec135c4bb13db8dedb4c903b48869da19566a4c84fcd9bf0a8b8f3f837592e15052d5e907f1a06080dbc709b93a1c073858ca07b81fcae9f74a0fbe6e4f63530adbfd3014805825c4948daa8247c37578c17973de78fe2a54e3c0bc1869ea108ddcab10688ff747798a5da94825c13f64f467de9578f17c342d27ef44f94deb1285f1fcca96c7c0978308a4599fce7e01b9077f4298039d9a196643132da80a365f09eca5059522b815edc43d96a8e3118d0a9f7fe82ed292095f68e5bb36141a75c151f7303da741c03108e8b8a571f64462746bec2e85d6d3459d7559b268f6659472643dd419f9d4edb2713cb5d0ed2148e9414aac044a8245a84ce89ee4f6e938885b12f7588f09df8110a549850ea951ca0321e77d4e8e8adb45e8ecf9009afe440550547aefa0491dcce6093883c1727c844f99280039536ad599bce5ffbde67d5aff5838ab8cd5960be724bc010b01d141e9ebcbd52fd0a686b8fb6f14848f946c37dbeb68a2a55ad200d19b3369b702f0a7309c2a3e9f78c853f81b426ded14c8beb8db351afa7a8caba9e9434df8edc50a4044c77cc757960c5d6e325a483788b622b83781d0a53c88f906e6794d7d6373fb91ec99b3ec953f5d47de951bbc363d3b95b3713f9b3e1e878170eda292c40e69bea57c0f1f7672420d715b72275ac9e7231c415bf106be1071bd5508b6ffa25e41debcfd3a2d2134136cf1b8fde8b3af94173675c5a8e233754dc0497f71deb897e2ca73682dd80b82daf6d2025d3a8fbf264fa22a67365ebb4e14dbe03c7a62dfb97ebce6d461dbcf891e765f31d3f879a7986aba1455ced49c447f659f279c6202709e6d353993fc40f5b72c3abc23d1120e301d13ebfe846fbb8aa0d1655ea6d63c5e67f18c20346a8cea6c064c7225d2feb7363c5e01151bf48badbe0e1c2be20a2948d8b9e494ae65f67ea47e8804101ac29c91128b86a6fdd0700992632c83dfc173b5b70dced0cd3d856c1439343d5b47cc16ada32a770c3fce5d3522ca12194993b09853a2824561c9fbec8f2b1df198d4f6da09ce7fbaffb49d364013e3472d10f073f2dc7d487af16c27735dc3b48d7d7fc1aabc8c3944420967a4aae77099bea68dbac03b4f38ffe1b08f601a50393efe203063f2ae2cb536814f3053d3514cdb546cd18ef4c79825a8df27238ae0a7da6436f04460af451060cdf068e98030ea1275e8be7f71c01d3ddfc3cd47eea943db96a566589b6316c1b8608bb8e0982198b6e020481443744353484b80b6848302c74ab492811ff3c7d967642ee851cefd6462363913ffd6c1ec679556cb3e54f59dcf199223b198f4a406cc441efaaf4ae23d3d0bd00bc1c35aa7a83264fdf0d863822bcfba69fd157fd670a60989d29a26b9490475621efd7fdb434cf06fd97d01a9f995a16081b7f07db7a749a508d89ded9aec9d9361691ddca4ff4ae51796884357e0a727bcfde7a7737c8af04f940c275ec7bbd2ef11c238402e7a750eb0f98e728c44419591330f714871893650147984c7d111fa992874a02f3bd039fcce11411cf3938d9a1d7141d71254a0fc383b8eb9062527f056488f5d1b1c76843b24fb881876bf448eebd06499aea88319161f44f57483d35dd0270908e1917e20e9ef9ff25e02c1b3b8de674435787a965b19b1b3389341f9fbec495a5d865b60da505503480e3bfe4c5ce09ca4ddee7d4a910955b20a43abd5530d4e37dd9d2dea092cdebc98389e9d539f7dd4d3290f94fa069482ba1456e7df8c3bcdfd0c8218efd08c89355b10fe81cea16aad4e2b3e3fd8310284a80e50be56b9ec6384b73a03c1f3f19860275f4c8d0dba9436520b6cb6600e863692133e85e01d54a08a1fd7ffdcbf55c6eaff8331be5d58ad8c9fa01b048d59045725f413d4f9f04756e824be915f0aaf0582614e290da549f2fe8891c2502968182824ae329717b94598717efab09b93148b3bd11f242f3b132ec83550694d4bf9c26715c0f90b7a85ff89d37dbbf81fbc28383458e6d4af7d454b5ed1de9cf8f2d15bbdcb1ff9149204ee265a375c6160e4c762b5ea07ae889a3b057936fda64780614187ce4275d6f60ddfb2411fa37e3b33a169e4e6399ae33a9f75278225b17bc8eebf3f9053f9f9bfbf3cfc643c8409e6049ead7c1cf01a422a713e945b1a96eeadd2ed9cb773db7928fd1feb45ebd5c7258b746783e093fb1f75f48b6610acf6e9f0e15c45600d907bf62f3289f7b5080370492a1fe02ef3dac4768d198669fef458075553a3ddcfba091fb6467575c27a179c3fb511dd96cecb8930a6219894e1dcc279d6c7d7a37ded11ab52fa88fa3839a08c69b193942a3fc3232047b1413183d7f6258a95dce1181f191a89b5dba4dfe9c42932bcef5ad4e912af8ef6cd45e71e61bf1be2725a4ca1bb480226444cce3a8a18051608dde487076a0fbf0c9053038f5713cf503909235ea9c82c1692d0af74bc06fa87d5cf711ef1c9b0253ba68e4d23640b2b9c53b128b071163aa3dacb5a86f21be1c3d4376a9f6c58333f4eebcf4e58d6877a237dc89c237548e5480904d3bdb47790e5dc00ee080860817712343e7ba8143f8037e22078689f848b523284f0d10d32be1b950dda26bab52275888d2be203eeb6358b84252646aa9ffda40dc492609ca7585f0ef7ffdc5a2c2e77ba8ea1f925ff596e9ca49c4de4f811b6c12ff6e0fb4e2d756cca5c6c11249f1182720854afcaed429d2ae2c1048cdf2afadee39f6a6c958ae8001cc7de1bf44d876d0acf7f0e0b049bbe15326407463d52380d27c8378ffb5689e1d6434814776932f52f333019af4632992f6aff863f3254f6511e66213dfca557234b13a0aeafe654622dda249c03ede8cc95eab64345ac942fdfa9aa861cfcb900353edaeda964f458ef29924aa4e5b3d4df6c66dda9b97d5990732242e681cdc748559536e0c765d7f3fc3486a2608a8436eecba2326da8383d37e960cf963beba3f614e5e28834bea256b700893d4e97bfb6ff6d6050d925b99aa5b762ee96c0294938a3f8937ac4c59d0e5f5f57a0f25cd168e80bd761c19eb5e6cbadc761cd6db82dcaa5ca0641b268a708b740f5ff6555ecbddbabdb82038e6546582e83f6642606a5cf4d727bbf7903d04d0e8581cde1579411c7ba591b2bdd5ac133119dd0891de17c8d497747777856da845c92dc04755e81573bc6a2355f15c65330ee197455e61eb55848cdc362146422cd822a61c1eb51cd4bc1e17b6029b106682a9405791b2e97585408684911d95ab86424a5ff6e58186c4770b86f002756a1582ef93b08dac9cb0e62b34280c78737fd227ce1560ee42f30f659821e2178afe10161ecb380bc9666548fd4ad1b3a8645beafda2ae5bf73c0c0f4385e42d314cd462128a52e567b9bd87dbcfcd35fe50851548d88499583cc6441167389829970d443ab9e0d48fe6fef68a5b7c11c14dfd749475f106c92ed09ce60e09e9d524d3589ea1d30fb531f8c44f8a97eed37ac3fd9584c5b5eea5ce921edba9647fba357b263f3aae39eb9896e376f4c9cbc0479f830abe5575893d8a08351aacf0af150045466c1f8a5c4664bcc8ccdea865c18eecd5c1f03503f3569a1eaaf4dc4c5153a101758e896bbd55fc38b47fd522a38d6c8e8f379123112e799034a979d49dbe1e2ee233fd191c765368d1eec4774afe9e3d49ed9e989da8b4d4d062a17bc3a35126d790178d177b9c45a785ba9be8cdb72c3c6aa25030b554608f44c2e7facb3e11dfde5847316d4303599d89428ab535eb4a03d972e4dbf7163e075fe2f08df6111a824a0a2d64492f0d32c9b6b5a9be79a69c05927140acedf2861590c2c602ce0811de01ac1b1fc6048f375b13244ff5fb8cb41c7141145917f3dc647ae8ebc65415e18e4f65262b661fa04b0fe04de61af58d01da36af13862ae52a45b394f2bf0d8658c5e97fa0d70e1e25796325e92c728e75f269c007496ec01b9e51eed2d742a419c16c764989b6fa8616edd3bc38d0db7898bf987700d22b87fe8a63deab26aba818c53ac68f91b80a9f908f153b3a0a5510faf2a06f8ae95f9f7fe2590ff886bce4d9b19d9e79779dde299244861015abf51e6d92f30cf1c243191b3f17b1e992043a90fc741a9d19aaac2f5bf5f626dcd47ec59d02cf4bc827d4c87261d565fd9d18b5b226c256880ea4e5e49af9d703c04145ac0a66d9bfc9131d0a1a0778bb0ba1c77a8abde4b9b77c62e381c7372a7534804e44b7192826d07dc88c33f6aca4f1ba8bb3145e01d34fe04840ee8543fc9109450ae5d4b7116e8d8868d31048af7ef3e66da7d522cb796951d81e8e0c1f03987d21748eb444023ee93d2a08308e71687c25c56770d95605287ff3712389ccd4937e21f6948aa26e67b32c23b80a36ba6f3bf50b44d4d1b7d6d59a473d57e37d671eef77275033fa908452c5712cb669dc654c4e385317ab13a9e16e3e63a9faf0c7db1154e1740da8cba3e313cca16e4cc5f6489c9fef8ba9271db679dedaebda0404a480080a350431e713ce3c70e55800890d841345e62ece016846a1c9252c2d93a1488a2716ee8147d077493a3fea2b91fd87d408f4d208e1e1800b8bc2c6caeea7c85496986206b26c61bb0b340dd442c6da5a6552374f03f3cac22b03c1edb78cf026ab45b3ff3d91e662da800f8313f3783960d7f21a5804deec84016a740bfbb3705b93da041a9b158acc4f56bd1c09492764de2fa60740824b41a771b3bcf0addebc581f73962089d375474d83d1ee42944c11352e6c90e9af3f0a70e67116ce41b7c8672494b2280241eedb22a5cfef3b13f8567c27a5b0c90c3d1b0bdbcd26ca39c61e81521aa9c38e13cb6475f1947ae2a50b0f3b15d8a65d858e2b95987975597443e0016277c102aff853cc51b98132bf7c95055de65f7e572bb6e37649570cff3072db52ee3bc3f5f20fa6516a002fa91f738a8779f2cd37c39f053bdf6a26c18648edc81588048f01a97ea12c614bf3311e959cd32f7d1234a7449824b5d1ec18685b48a83459c9c601cfa051e8f75bd567b96f341220c1c4496bceb0a12e113dfa67c09b1dd46c738ceeeb59b01b2507042303be1b901554f7a9eb1f03dc914f8f64c3ecd5824e6f4362a0c9c69993f84ddbd528cd97d15d4583587ca1e19c7da86b8a92f9e0523e01b5b41db59c4dd109cee2cdd0f17c68457ebe0171a51cfb8affa38ff19bd8d7e43591dab65a429b655a19fc183cacc41def6d23d812f776b3e3389d867781853ffc77168d75c560427cd520b05e528f9e53180a6b4b53cb0b94d19f4e0e20b06781493f029ee9e271ba588687511f9635e0540f2e77697e680698c7bc0e70f09872e24835ae8113a383457a6ec6c5e521d4a099c66fd80d0aa0e4313999a3dd8bfdc40685b29a6b11314c6404699f99e4d7a25b4fe1d4d6f704e52d2a2f8e02f96c7c3d9ee3a7e84a4b15444dece555e94dbc275ff54b1cad54a705ab258a888de5293283004166b1bdd9563ee9ba8314e401628f194a21e1d2225012eecd3e80b60b670b40fb56ae891141267d41a94dcacc5c798756b129f94125f0e211906afacd8b613e772b0772183d8fe08189970adb0f144d8edfa0edffdeb2fb7b346955667d2f453ddd39e5d5fc011d06170383132e7de0f60b9587cfe3f5fda44d705fe846400a6ae1824ac28e449bfddb11120e30a5c0afa58b004be295db2ccba0d9b98ac277ebb830f59ffbdec3d6febfb0bb2bc1ca6b1bd8e9bd4b53a3523e0a6e9f8e6da98535f319a725d81a911f5a18e71a698b54fcfa4eb26a0ccf92ef0cd9503cffff04e362c16c3ba5a87e82fba2967ca49b9603f07c29702bad60a19a6c6fa8d0dcbf48058b58c92402015fc3660bd927fc12660395983c2d5287f135b8483490cd42d9c18ed4694564c29730cac1be2ba1e915addad45b4171079eb399b9b56aa9b60195f0ec887f462a14182f3171ae02171a4e6757ac17e115f8a085a8ee8a48a927b13038d25f878ed518aa047bafd15874209553886e4e3ff0ea36a7f63d61d6d2626b1134e97140da283082bc8a91e6073580aa11982a487e658916d83ac5227cdd9e3c93deebce8e4e200ad0160850f66acf287aaa4d22fe2411adb0678f97431362a95f2f6b237d295ca535082b0d1e221a04078bae192cb4fc55f900be546da9dc8271e3bba8143c307ca3f39e415841483de870870e88717f86597f3f5d0c5a1c2995a62b1d4c4b8da146eef5367178ffb04dc73ba96f13109973560a50cb7688ba0b51244e896e46d74efb9a21425da0bfb62880474787a35c5ac9553d176a527d6cb5a45d412940c83b368051b2b710b925e81e7b140846d904ba0f9d7e9fd5c52bcfbc58c287b44c9e49d55cfdae90c26db232dc1ad8b373264c2d880e83ef024fc0f179d78b8c41da29ee74813254eee881ddcc7bb218327abb354b94ae92fa67a3bde3f354550371fe02688dfe86da4cbb5abdd76d25a970bf6bb778710efca6f5aa5048909ce80c265c1ea22a254065bdae929c56250c83c7fbf9ceae989284cf31dd8eb49dd4e5deab09a82a187baca1ae8e4794c20d287b5e500b00e14bcf6c01e382f139aed28820cb53b0d0747b86f4acd0c370908ce6398e7a1b43aa49cac0359109374e9b1f50d6ef2e4901b5b77c5f635227fb9652e89c493166713b24dbfed6a585da6268a2a1070133a9f75602a2785bce2f70b9a3b02f0cdd459484138c6167b7a6d9c2c76e6d29f0f7df1aa9585cb8a3b3803b3a654939009866c5cfe84aaa595658d1f1a13e4c71b86b471b60a5c6f05b57d446a071ae61ad9f6bb452451503a64408a1b8eb49f0a186ea26cf6429303d863bac4993d26eb4b1afa2c88757421c48174a4168169c2c2c1e34817726bccf5ab7fb6029a3ae5a62d9643336a5d090e0f6cf09ef111393a32f9e368e417f8c50050651d53be19d55527ddca4a21df2f3ac6a70fda51caf7d376b0a20c127892cfa04f8a82d627ce08b4987e9494831971d3f1fcc3d8e09b6e4ef5ee1990ba2ebb65bc79f800a2df12a88288792b5a85051acab73584de9a7a26e0d7777b4e103655e532506deec0b84076c40acbf5126683dacdc0723a7cc10602f4790cb5c83de9a46be4870954dbaf996bb62d4c7b89a419b5452dcdc3fa98780070af705409e70e382506fed9aa1874d73b43919426b9a5efd935c588878c19af6de390a47b7f171c18dc730fb75d96e48a3f6c5e7c0b96d91418817d272862a8dfe28401ee9f3d72c137540f7b67c33412c1ed21e0118abfe87ebdf28a1dd923008552878a0d70b2dc65ecc76252c1250bd197a67cb0f5dfe09f967daee815e59c37fc09828826cc0218db5dab23065ebe08201f8b470ccd4f3815d09f009bf0a67b0ae507c74f718e4928b282f001129bffba55841157d4e8305b0c47503b7eb6a99804e5ac1d72058e459ae6dcb1aed99b060a3d07a8f5b07895647328bb4a8e04393c1a781e30c85af6425d92ee5b23c71a979831f192dfa2002c51eff42c1aba1c2b5c99946049e916f431a1eb88ed16f5ad73110ac9c05c59e2ad684bc731e5be61c7552d57c09d9861a8e5907fd7a0478a8c523c8aef71a23c943a691bdf036c8e9f6a410bffa61d3ee8a16e9d66d8754e7cafa857df0f83a0205f54668fe0b1aa35988abd199b7d1cb00b90f935ba90c438cbd20ad4d2fd1db4dff735769f14f40ccf418469a57d1bcbd31c2519f17893eb833024cc655541da05c8d3eccbc045cecff0ff53c3e5ce3438128fa556d1202203c2e01c860c925847fff7b947073466bcb11321b33b05cf1659e94481022536cb0da75fa9926bb43c43b86046c5496acdd83991385a0592150dc2ca388ff3abe3bc1ec6fb76119215ae1048d0c568261a6b22c6236fee9a6bd9d92c9cc20db6eb9525c363ef8d3d30192667ffa90beb0973fba16853b9b9185f3e5f0475a4cb482bb3b84c164244e5c06a799444224b09691d65c8c8e703780270370dad2d11d9ab1729457191cc011376c5309c6db5d109bb7901272f5ed9a9bbacc525262f517606ce6fd257bb1f32ae3d82cc348e81041f7c584104e1a5d3b66b929af5a7364d39a9b36419684aacc74068c11c8980275f59c23a4b5f598e3326eb403655c382d6766047f0035a576738fcf0a54ed5b7d70fbf2e5493ab220d69491fabbd334750068c434b1c721c2e4341388b9c2f46c86fb8190fd8a2600fed807ef4d809b3871e44698cb76a389742ea0e1438e291161591ec05d4c4db0523bd685b8e236a9aef826aff42885fb1b1cbcf524a413c94640d43df2410d50f53f98dcab6ecf070d5bb64b9ef421d76cad587ce61a7253dff14ef6cac0ab6ba69983d081fd802ece6ea5311f53c99993e610f361e362999f70ee1547691fb1e1373bb928f23e4ee93f7077dea1bdfa80de125c412c48b89645ea6a06a8865fe842dedbd57077b2dcd64708fa6f8680930ea637a7e3b9d156f6875bf006b1ef36d4c0d37acb39fac41c618cf91387fa1110517be7a9ec4e9f0068b23854456c64765966038fccd066435958e3d4cd1614b831b7a6a2eb3fa2a13df81989b751f32713dbb18ca6527412f3c462d0225e33d7090d504b00e63a03f2188871b98e1f84e741ae9935631f353eaf13d85e2ab3e01519e046e0519f9b9fda8badc55a64e05f6b46420e11af32c3e6e75817cccc10005ea0adfaaeebd4f5f491a8a2079857895bc67cc82241c1e21ea50e2c3172b0c4c39d3bd11d139d31dbb5c12948da483bf7911986804d962710845591064792729421b3d7d562629a2d4415d78aba7f3b2884c0fbac58772c848acc0e340249d8fd6b17942d82d9911d43de919cca44616fb7a8285f4bac6d39c4d13327a397200ef37d0bc861ff83e2a827238d276375d64ef1fa03feda05abb61a8b0afb64c59666480d6693e096d6e295a546e8051aac348cf2383cf69a167dcb5ce18b459577c3ff83d293e28257473c5fad035ef34202d2f000431f79e937759d7508daf5428b1721747ba3ce571b54cb0a5a98575aff6bd2f08c9549ab5bb02e102e620ca786696a60dc68f4e04ef8cb04bae7d1787481214570e00bd9008f3ad5384747d5f8d8d103b41ff5291b43583e244e899d7bcffc443c70bdb42778a8e0732c0f39ae754c5357c53eb4eea31abe33ba27fb928e94e530d2012caadf674e17591f62e1dac27d52b60fe051a1b5ea19fd2017ab792b3f198804a587a42e167bd0d9492ccf50cbb412654a6b12337f8e5730456b76f5805f98e46c797267efc5638c2526379428bf8529f10ac29d6fc85bf2b1f1477d87d31f10f300f7c0aac3c683846f932de51d51d5af1710324c84be6153e39fcd31a93c623869cffa4a51196ab65df95102f74c254e6d8a62cff5635d32d7dd8e3a65231161aeda03321fa5f7d609949a2bf49044db0d11895ee830bdcba8bad709fe5a69063caa86cc4d862ef1510f6cb41dbbd675f022e7f79571478fbdac18df6a42dcda1afc394a79c04d69628ca2a486eae8f6f8b551afa86c8c2c8ad63f2e6385f1c6fa4c778b583299c5b25c064e47e60cf00c0c440bd89b14fce33f77da3fbf922ccff65d2f2678b0c524e69e1d5c979687c376aa7e0689916f2e81083a10e725dcbaf12e515059a2dc6279a23c4300ed0be4e24b577f63f86f66c74566598431c5f70b6d32d30bde6948e56358e0f9d3fa5e09e602838194e25539fcd60a05cf5bdf8c3dbd42ddba9fe0f5de0bf2cc50c9367af02a90926a1929eef974b41155c3d01e454648004dc6b01c7bb1c8ba164624ca5ecd6ee3a961ca1c9d867686e40505567da194df997e1bcf76c729a6953a95059fa43b7bcd4cea4a596dd6ae5ee7816e8b8b91f66dfeb1b93aa3bf31afdae18e8ae73f3831dc2e57fe18c815f4f0ede69d935657918bcf594bbf423d5688dfd84e838043a25b57bc2652ec37d44bfb4baed6a7135cf4da8414413b3c0fac63b10940c559b16331a3944ce1b8ada9bca59a859153501ac8dc2d3659d955637857ddd07718367cad343ca529fd5c177f728a1a5407329e813d51771f42c5ee96ddb6bf19c310b80cb841765ac1fcd767253bfc34e51b2ad177fbd16edbed04d5bb469eb5badaa9f1f3503ea78c126b7019d1c2f1a1d3f108161c51d957c9a461075a723e433aaff614a78848239bf8835da11740a2f0d854317cea9dca10bda137fdc543b9f04426f1de50f7b5d0cba8a233411fcf5f87299de61d37801c91218affaf50f0f213c3480f90dc51643163f2d265dae2a2226f6474ddcbd87c0e68f40cb94d960d3205401cc728c61894a93fcf6d0b43f6857cfd77f565d1a8ab79ba1891c5135535d79f88926f4b16de0532a98c0c1f59476d7cd0fea3c9632bbc4d7952de4333a61a8591de14e476f0df989520b8a51c35faf0f8edad603238124f4a71b6cde77be2cf6ca5930ee38f3e89856deae281c971085ce1cdd822c3f9a9ea95ef3e69d9a2a1ea599df34cbd528f14cb1ec1d8efb97982b06a1dd94505fffebbcfce71bbea5d7757f71f8a65865cf34ba00ea4f5f556728ed56974fabefa5e0d5600e08a48ba33d3efdb312c58b46260fa2ab504e1f6bf34465ba96961b84b28b885eed41c339eec3c4d698859ef5903b6c9d80901da33117437fcff570e5b877263c8a2a64a505e496ca865a8444e0628eb8d24516ca29e82e439edcfef533807cad4c054fc5a0c17832bd248e87e1bdc363d1e10fe8efd910462104d2bbe0093284894157b43eddab15a8c7d28ec88988173c1199aac1cac55be590064a86da43af893132885a294e2d3a10588be03a257f4d18fb9113083be04e186e6c5449a06c4f84d777f1c561716f475056528bf9bfb0ef5463b9835a478df26e2b5dbec97994ab88874dd4a137c17495acaf21308e3f1d14d811b73a3f4a85f619eca528669c78a1a92280ce0c982bc8f2d9b3f6db4db347ebef728e3b0baa980fdd71f8249169947eeb51ecf2bb8e67f6c63ac92b23dc4a5cea1d78bd82731f4ef222285a69737290cdace9bf73d6b3693f3c75e6456a262e4c5ad251e0c63cc0809e0cd2925fdfb0226758fbd4cecbc659d91148f0eb1ff6d1c57877ea528d67bac5d6ba01fbccd3fe1b645a8d3893d50aebfe35adca8fc3117b307c94131e3b51a8d2c6993755ee484483e95a58b85596bb5f7f991fd181f783f66337e31f5f07c64c88840dfa5ad2d496f4be3f406bbd6e5e1a852ab87486f58bef0c50ee15730dab0d4e4e8e7718dc3d519244b28e4a09850d8914670c4ab37e618f72d7c993e8972451bc9a2c044fc21c1c1f6cdd7aa34b98fda341b55d4fb1292b09633e075b8074fd91929846c2af61155767126fe76cdcce0489cd08f1a8a9b6de10c8cd6213919d8a7c83665ed53bee65dba8785d9adb9b81bddc0a2bcfd75f3a733dd00e98db332ba8318ca1280b4930764d545fc1f43c1b7015aee82b3311df3f20f63c9fecde0cdbd98b21efc34215e49de247fc346b89898ee1ad9dad991a05b9e3cc6b62453a2f09fcdcd6976955e2d7ffc5dd707b4cd158068e057095b44d9bb549bfda33aa941bb51386594a50142192522db14fa047be1463e71fcbe792ff12c7260f2b0d099a363ce7433d0730b84dd8f0233d101fb71cf91c9a3540ffa867ad727e70aac008db267e3664808ec793b264cc068aa56b9f9dc50f9085ae4852b617e0b89112e49b91f5d58b820904bbb41bd13b5d687f42fe2df91a7366a1a96e70268f3ff0c4c9cdcfbfe5dd51133c2e9388dba52f565ce0ec653a9e4c04cba349e7c0a194f313143d32e1fa922f14a71886149ccb7a08870149b2f87ce6fc77e5cc629eebbeaf76474fc4fad4103c142b0732bf7b7d48cc9d15378bf4558aeaa9837ae0332fcf698693d76b4a886ad60de2ba6a314dd9d499b4188c96e688e635010f6163e02379fd55adcb62d554328e89abbf8002fee9c5930da06e221b108689fac029e9940a8d81e0a3106a1b768019d0bf09fb044c7741987b9213e015112281850e050a78a2aa56f5f28835921eae0d6b8380abbe8e90bc2b5630ca0429daba306e8d5215cee6aea6672764b89b1dc9f867c0d1f237c9abc34213efdbf09a96a3c1d8884724f8a044f6da1dc423bfd84c4294e143fde2e800d602a72dec304799ab6c1509383de00203c428a02ff0ac7ded77c007b4526910bd2a657d83c5c5e1503bd7d07c3831fd4ebc20c7b9053443659701a628faf0aeef34b9001d0bba75a9f0e62409b6ce9bd6e9a5a1035ffe64d2bb6050ee3b37617207bef44327248515ce4a8745259adc5d1931e787d1fd90b3adfba726dd18e99da2ec267dd5ec33ecb932fd56f97161cf92446cb09f65684169c09f54b06dd3f3bc1bf81d2d6a978058bddcc05075bd1a9833548eef97e59e7793288d1f4d5a9bb69d82ac98eabf9c5d8e3dc0bcd7bc7d57f5854d425338d829a3153b774db88ddf5fab6455da8d7b3930113628c85bf91527552775c5d24178fb17ee4afa4a1d29698af23196ddcaafe6a32fe1598fb57cac0eb68b86a873fd711e4bfe26a831a174627d2c1985866b0746a93fd16841b2d13e80e854ab7ae264fe24c4c044042b348d4cdab6e99dd03daa1f0ab86d57c7e07a0a189ae91115d8e0b3f7bebd8a68f2c5ed63a827cdb7fc69325f8d1ee339dbd2cefc21652053efeaf8c29991adb3678294d7d616cb82020fb7ba5ea7e5a274f8c0ab70d8bfba369f278195f4618c1d163f31ddc725854e326096223ffe49f6a04fdbedfafc7e009907115db71a268c9cbe635831cb647a6d870bd278fe7ac934823c7fd4eed7c6c907f26cf637e5347406d4944ceff882511ea3a4c01a9ad09ea209caa11726f61a8b0cd81c5bb5a3bd7c3c525f970bc97e80f18c34356ceb6d9a627d88810d81cd3ba909233f39eb73e15c72f6b386a244c48aa97ca96c3b0141d67ca4268a3b7c1f9410d70bb41891e50ba37d9549887e7f9ad8514e1d02d11a5c6625feb7fb846161b8919c2c6d3303587cf2eb1951036478a8c7d1f86f8cb335874ec39b729a862e34aba6dfb2d3088eeab9026855fe1bf4bba883bdc1912cbbfce8da32feea14cea3bf4cbf9f4919833fc30a7937b876b1e41963114561661391c91b15f924a6a290c9c68db7b1f88598002fd2bea7946c0c2531fb44297b268bf77ac5dd98851b3d21792bff5378a3a136feb0d50c831e211e1b4b888a4d6c1ff9847ba105a10ae47aba6677c6a6c6eccc572fb05c0fd2382e5e58d49d4f47b1396b5795662874a8c0c51dcf940acb0c49016beeedb845ed641fba29b9e60696708f4a47135cca56da8e1e3fe0d1bbb07e25a784f4c73bb07d4079b048e53ac870f337d4abf499509d754b34f33560148f9ace04c0f8ebc5bf84c7fb848ad499c23f3d13ba182f08395fba49d4bbbe550b3401dd0e8852a93e4dc6759c141f7df0c587dec0380522479a97881fb11c7a7561675bd65fcafec5353341d755dd3dd767288d400ad525e096cf5abac46cb039c92e467660f7ea0e97a4c3329c341f1762a8b0b9b4773c827f01b8a77fc1116262b20b16b94b3ba7ef2b399a344741ff406288d4839617a609a2a4eec50a7c1c03d411b3218eff6f9eee37b88767d71fa0914aebfcb9d5a81ac201b8e628acbfa440a5483f0348540a9e310587f994c5623bac1655a9287ea660741cbe9e8317987832e11da5f4fad3014e4748116665f982e3a63b87dd6ac9925371c310dee2e4db51292e5cfe72ccbedae945aaaff51d3807acb503807b3d0a56971d74662fb0f2402728baa22e43fb0544eac31ead076598d2b65ed04d1cf4ff3af037ae631e570dc8e81a41f2995e5e0f8ebfe865e93a145ce80b39abf9c48ef31dd51767a0306b35daafa08ca30506570e73df42d620551de284d7eb6aceea6377d3e3e8d32be4d4fd19e0bcfe5a72ed0d660226cfe0c94ab46205153fa6603637ecc1385343","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
