<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c1d05a93a3251e944b64e27fa1ec08b0414a890bb503e16f7926f36293c2d66889c6defb22fce1c7225e900441c4d6b35b9ab9d4e3bfe1fbb1de9eeab4a326da4ea79d224ce962062036207e2ec9ee1ed50d6ae6368fe9ef276ea270ce14c42bbe9700b62bc6b37a2cfce9cc60b78dce203580a38c7afa82d7d34deb4c4a8847f14ec3a9805b7bc367855b68eb2368b30df883ef70ac4155d3a7a4756518d365d418699690bc0e467c7bf3bdcfcdceab6945c2cd79cc80245dec954d4136ab5dfa4b0d7c5f54ff093206a8df440c660f4ea5e9fbd8bfdaafe6f14d209da2c6ae80a891260c4abcad417de3c205c5e92a8e564410cfd97ad62d572bcdd3fc6d24b9adfa8cf31fb8540cc06fb3402b7103d8f6b4f60ffbf0b0684925d084f6f23c9ed2d3fcd592757f18d26652c18bb18b73c4c8a59ee1bb1ee8da37276f0e37fd82af4a7f3d97b7a75551ff1df290c0318addce9e5340976c3cadd292355fcb0c2fd385df67502be9fbdc64d2bdb1b47b545ab4468c7210294d676c2ff1ea3cdac72f11bf2716b1a23b983f2954c3d30a259e6eba7a03439bc4f4335aa7ea7a3504c42dc70f53abac8c786a7f7a0a71c935a847c5f0338cf120c5565e9d1d505b0edc732ea6204bc5fc86f4e9cf9d67d97d404721d844fa276ef1bac5fd20c539f09306bde99199324561dc34aef1f13d73315033b0cc25ea1159cb71a431dde0cd2c28ccda0983dcca167d77541b7f9da016680ce544a69710e8a9cef17ef9c9868ff6e5bbef533ea007c67a98b847987f83698966d7ca8a515657f1b56823a3a99ead2ed75ffd743db832aa1320517ce7adc0266c6baaff8dfa7fde5b8ae093f0916adf9077186431e505832610818f91a54062d0336a37b515a134dc7ac53abe7a354f63e9c7bdd2223a2628bfe07d9980952bda5bd1b9f94a3d27f734d73fe91615bd521969f69d5e21865141001d9c7eeb8e60ac936168f8b124efbf5f92cf0a3c27faf9f5c3a2cf678c3cfcb1d9de8143a068451e15b39b74fee0959d9bbd903bbb2288dfaf7dfeb9883a9d6714e3ca825bba345154496c43c589afb4a2f0ae4c9c9b716cd73f8317077c5bbcb582d77cc7356085b12d0a6f7f1d038f9d8ea0b2f08d6e6f279e71faa6accbeebd7bd710c100b4838b478b04ce567850ac7e61a574584b5d6dfbeb26aaf2a7fa286515064da447df3a270f78b987135a7bdc0f77638a79d89ea4b770808eb04ab6d3285615b753cc36184d69a441dba38a055bb8802bc3836c366c7dfcbcda82bc84c6c4868d4ae08a407c5c386889205bef253d303169d3bd50da402c129cfa2dc8a3a61f6ecc46cf83e0b63a2f4d8dedcd113530fa746e2382a84cb61ffd38db5ff255c4d29c0b86631a3c73b3850bad8c313ab789c4c33911810afd5ca21d7ec8b8557ef25498843f8d4b078bc83d5e4dd3f58323ac902b7cf09480a1278e1594c9f4efc3a63baea77a0b1ab1130d022ff0087189e2448e3db9250d7f457a02035c6594833c461fd367dab4b431a73f0c110f37f24c4cb55a066ab28263e37cb885eb61c5fbd9ec52c08e3b8030c77c51983ab7890908c938b618265b4ea386084ccf4047018a78da69b73bace7eff32b8f3661a9932e04b8c3d0717d512cb0231129a7421e0bff517bad3babb6db6bf984e8fbe443f02fb559c42517027c101c18c6073241f1cd6ab1767ebc12bc5922f08f5878ec6964f76ce173f19c9f10f368b618582d95d610fcd2ce15bd6df282faea23c33a7f2f5975e5d3a082e915f12cf354ae0fac6d3b5f92125598267c7671f999e0cdf5814a36dc44b84fbf9312136885425b746d9f22102ff2540e708d4bb7a6cfe38d67baa3917d07321ce5326c8ca4f508182ed37d8472469b177f798696c6aa18749f1443e752db47b81b7f4cfc3c1f0f5bd9cd5e9f3c5f1cf8c92e7f9fe7cb17c9f22b8561f64a8f334832453551992e0bd834f23e48a2d98d057208a5a734b98182282481ff72f87c83333370e101fe2d52c5d99f07cecb1a47cbb02e5af545b757a03feed3d8e2b580a8638e39759e1392e7b731066f3e37bc471b01ae77a7e299450f953482ebee7259a19cdb64ef6aab1657714c6ce6467ec5a55d6f6d2d79aca7b4f298bdda3b63316be3205c90fab1dc3c6520edba3ec89d18b6d50c2606465daa629afc0cab3e04fcb24f7d66ac9be93657bb63aa717bf05f3fab31ed0b1327384fc564da5f4d44a50ff3ceefc0fce360d85ceff632629b5e993654cd2e89fdc1e21847159acafd5bd6cf9e87447e017c360df7efb73667f463316b5151a36f5f905615f5f807502395faaf8f1f5f66fd17916e93620e940176ab2916631c24a89d9d26c9917d5bb7f1275fcc09dd761909203863d8394ac4372e88c50b7f76f2b3fbab64ad1a1fcd7c16f8b22cb57f921a35ea88fcfffe78373c7ec78c9a2bfcefa573e10aa4b2ee3cca70c3581007454754db1e0987582f2461334a4c4ea4e0f9d8c4cc14af30afde755b7a3cd9f900d3e72071e305c599a70bd10fef8c5ff570e4f32dd31dbb73d8985cd1ba57c7e6eb05e62e6831a009e86920400ad9602ca600cfdda4df4e053525b13029e76718d7953f2f59bdc0d0a2927dccc224069753849dea1dd2aa12733bc105b97202b5d5223940bb8195549efbb80af1f0736975de2827fc398c6e6694bbb69f06c5029cc57d567c484129ac4111e16d081ff07557f0c7e4b4dafa7dc0ac14a735ed97a787255470ae674fdcf8bbda02b33b0269b254de943765bbf0e517a085faae8c1c898fb6e0a7f244c60c321b29322367e09150938474d0189f1e77301218e6cbeb68911817f94c795bd4a093efd25d2a1b7d78cede5648d5a1b17b64e5582a101793e0efd2a531127efb05e0f7b03787c143e4def4f567eaaffb6c94befb537c86807206988399709777a69efa4751705c6dfb88939068cae496e8ed94bd6a7161549f9e455e0cc1a534350289ceb5848f910536bc9ed4634e0a57545e0e8a827a559198652973ffd05224e225d72b5cb8fb76143a6a27a90bad822197a80108a7a55b425d516e8c824d8ca19e1bf83cf4be1263a79b0084e5760093f62301f2f00a73e995adef2bf88bc9a79cfdd4e7d4747461c50494a4d47b258e144ec89b1e23f40f81b7505915645046fef23427d79ddd840eec2c4182a20a3021f3b482faf28e66f1c8e02adc0c9db5d39112fffd0b034f0ef46ee62f41ec8cdd9c0481ac8deee1c9fa2d2245b3946bf0f878ca9dc357919b195febb7e8626507432e4b69856395a79faeaf0824f4c4a91f67ec90414599c5cab3432d34271250121efb5316a1fc927de0ab72a7aab8d41b87801a3272351c8e5c0073f0adbe541ef4741eb9875961a1a0ab6820d52ddd5254a79ea9e85eb7ffb8e923f4fe990c1e6ab8d27429c671d5c8e0a031acbd20052f798335380e7e2bac3de4cb279bd7ead5588be8ec69affe279d7dda19eeb58904c713df7d16c06e2a4a0e8b9f15ef27bee4a5037d08e01459678f30278e3b54394a3a1c60000e60029971184c8b3b6e517f298c87acaa5e47bc84b3aa3b9a9efe0c0692df5d9e367702328c912c300993d2053cc7b205f6cebb13adb242493bef83047ca43158ed61c22bfa28d6608093d185706e754459a0ad1437237ee8964b4261d56f737afcbbbcd167ac153fefada606f9b4fd09a68faf180b0c48be6555135bc82497cec40f8480a88dfa73e370e950e693fb40f3807a54be7e8a552d1ecadd27b4848e365932494e909fa404df4fbaab33f5914e8f90d6f64ef01027a42b665640e039dd420e942f2e13380a80c5be8d2e277280200931cc97ba236366ee0d58abcb74c4369684fcbdaf2249c63e3f4cf35f35c7af22f9ebaac3bbe6a7803a38a5243bc5c5e4fce0dbc1799af9ad9b91cd37f9cbf24a45ec6bb888489f4dcdee828c7c1693311f3c6c9ce3d7492d600a38a48bf71e2a9652272125f747487198e7b7cd735a215eb94d2ef4d393b924514336147bfe33e74c0d2c1a25f9dbc44a32fa356e22a9588b5676021172bb6bdc09e42deacb2183176a563704355d67986ef8eb61ad6a8189ce2c10178c3bc587bb14e02beb78f480be66583599049c39570483c7bbb83604b36300d48b76def6772b1bc91dc66e7741a8ff2588b8648ae46e010d4a010dc15c98a5d1ec85a9437b3834446d6a936e2243da6310e1f32f44047e29566a87d0131e255075b5456a9548e0954234951017fa5c6da1912a5680ff1fefa9b98746aa940aafd2192c054b6a70e7f878829937365bda365d06606c3e00db81f716173e93cee639ce71e444b7cb9babc566fadd309f5af5b31db6d3ec57e1930942aa2492360c4a8a2495b75299ec78010f4e078bacb1c6435a5e5f9a3364356dde56e954487b573b6b99c8382ae2212bb9fd98cbf9eaee4edff8cd04611567c7079bc6f5294e676c11c5487e9c314b27b0bea6822a2f47fcaf2d8105cc11def4e004a72e8e455ad8a9e8a856c41cf3ad89d8407f50fda42aa4fb86f11ea9eab6a0b963b21a1a6ea3e6030e64e025256f45d78e1fd8085c3f70308757e5cbc369d8089df79147605fc150c71bd57160f48b286eca73107c7cc9b93901ace80972d48bd9e4e5c71666d3548347b2a995ff3930bb90823e7f764db22ddaac25946ab4320c8bdb68a0b384130a10173457d4983672aabd3387fa7829ae5234cead104432cdb159dab694279cbe00ad6568e7f74b363434d99203c794034f01dd40066d377c98c319f71138e79b420d7fa238c1c37cf244ca6158fa93a9ae39cad0373bc5204b2866e466cdd8cbec71280a982e241ae63cdd7bbd863bf8c8c8a217a36d909d9b956df169e9bb422bcb336101728b52c3fd754b551a0ea229d98e537ae84c4105746628597e7249bd6384d1c446d9cf2ec51a0730441c14e1278eecb6f94bdd537d7a0f573b3fad827710fc26b660bcbf573d7214314e7996551abade522c86cd5702c6d6c5637abf675cb4c79438d412d497c4b8f3264fd57004024b22e99c5cb6c540c33f8174b88fdedff854d0ab162ebcf22008776ebc366e6aa312c5178406e0ba7fce690b3d8c60001ea6bfe5d57fde33fa31a989b26e35de6093e59cd2ea98fd87021f80a65a940c29c7a60c6c1ff8f260e41eb08bc50d816714244879d4527e345f10ca05cf87286b4f77223074ea4a089380f318c1e6f35875fe8c552727abb76fcd17c624f7ec10f743c8c9929ddc9b1e44c346b69dc2aa1979ebfda212e023dc09b4cea8192bec3b5e182466100b8d403b51e4bfe4713dd1f38386555d5b7b8fec615320fb315e8fedd8ea36c57fd028cea4a91b32d7c4b095decc6456b07894dcb56939e16fb8fed72e18ee28cc8d493f73fb2ce2e1cd3a6b9ce339b2def135fb40dcdce1a7060adb6e701205fc926d98d00197ff7329c1c5c5c8d28483773f8ee3b371b715c2bf3478138d01105399bda9defa01055dc3ef50de6ca6a7613c91f0b51abaa7229a096ec81de1468c9fcd28dae9efa5a7f2e886008b97a8a6e2c493fa3e4fcc700bcdb17eeec399d5954a92e2b0fa7d84aabbef36876f499eafc79305ed3e73c958d2e6bc347ff557b81c769230286aa72c3f9ea0bc1c7c6aff1f3afe0f53f1b8d76f7f2ea42a899f50aad97a5d6fa75f9de1a296db60eddfebecb347a5ee209dda79cb72cca79d743c9467d81b6237b6439bf0467941a5f2571d6fe60883c359b4f69b246ecb275183ec8422879b7f2f9edf8291f5d2acaa1831b9ec3a96bc0d05a3a78d649e4fa9248e731834be140c5be112b27c571ec193621f35269dfc3d01a76e72f57da7c5847c2156abe42edcffb1f310cce304e66f06100881321b2d8dde03152b0f2ec858538989a7e371e9f28c8326486939d0430e20efde5f63d7437b5abcace8986c686639e0f1a8e4c96894fcc8c23b5f60a6a486d1881fbbc4fd96f5ae51caddb00e3a54267814a029573ad73faadce3b68971e68d12e95b735742a0733a475f62b2aed674f360b33ce04b6e0fc7b4c4677ee0a4d0fe6527ee1576c311842aed96a2775e218c622d7f59c5b1bae9bcd0168837e9943bd9dacaaf7b5dd37099f567193cb91124a2eb3e914ccd0b34418985d004afaded399ee7b7a07769bf27c1038868e289987b417d0d063c16da6427fb8babccfc2298520428b101447ce4c730ba6ae5c01adee3970da144c1226d7861f056b34655b7762f1c093049559e3b6e1ed0c0b7847c7726ecdfe138298919e25e6df8d520987807832c7bb202e655c766a4e97682463619b18eb8ff1edd15aea48e018fd559493e1583f37a69586dbd42fd96c82282318f45f0589983886aec3e46931609869f50bfee5bf9ea89cf6c8898c3ce002a87f253989a2278364370683cc676627c9f119211e0bb44d6f2434f3faca8cd780466c86dfde875c2e84b986a5bc59ef441728200f2bab9611e4e72896898aa07e362b6f90f795ec0a695513e3de4b5e356cbcbeba25402a7f9c3eb176dfa573099fd8db58cf8094b43646d74cebbaad77d1b5ed4db238de88fc15d535b076ca4252aabadb9f21d8cefc37e6cc340eb41c891b8a993e32dbde9bf707e59f87d53bf12c84e155f52e655acf69947ad1b5960aa54dfafe13cf78539d30b3856bc0b67aa3d93100aa7a0f2d008b9ea2f8ca141ffa1c4b433c6aa8d609c38757e3d30b052bebcb1083af5984ab330736dd59dba9125d3a1b259ad79127bc45796984bf733f76bacc4ad78cea3ddb7c0414c35d93e894e4d05cae10ef6e48e9fbb72bebf403b8e35d2cec1e42396deca78f0b67f46966f3ee216a36bea53536eb9fb89337de40053cbd954a6a11082b1ee6b6e54e8cdaf205a3ca04d423de66e019feaaa87bd30d4206439aa391f8ccd28edae7d6bad5cf8d5a6a2c3f00e2785330cb7cb57a4b0dd6112fd69ed12479a81192d673be2e3d885b8d5b555ee6036af5016cd935a9d23a9afa6ad7d0e5638d51dbfd57c163233276cd042ead2bcb22b3b8e7a363594fa6c7d94e7d6f42b4bf1d5378697339437473aaabdc50a5d74df675ec8a7257b545ddd92bf764c0fb648c2632fd0173d6dc58a53c94029eb1a17569759ef9eaf1ea10ab5df0ce35e0fb9433f38b9b6d3201a2c16ae4fe825918b4107cf297891ba3320bfc392402c27a2906ba101dd268eb1ae91a19762203c0b5dc6697b2ace428258c9e8177d96e1efcfed333822ec704f7f875793017f9cbf169bc32747dbd9b556787bb2ad4ad878f8e1ff8bed052e8942d42adec6c208827e034df54af028b959ce5b1e76c4955a112f62ab7019226f7bc16c45e1f3fd04f1458ec2beec79bc4144978a66358aee1e787c153a6cf16cab9bbfe67822949aec631c3612a66e27bc28de4e5779ee95864c42e6ce480f2bb9bcccc8b27fa869fdb7eae1d5d258f7015acd6f6172807f06124f7de28a67943ab655d02bfe6a940913f7d76f5a269452e0ef0cca5fa2dfe745c28b979312a7273fb0b597bf7353ff5c9ef7e4c2da2f3f3149fc5a08b7b7f9931d34abfe7f3a8916faac831aca7fac0adde991d35ea9ae1e663035a92aa20c679a3159c2ef209c547d363b82886f14700d7721cc02d84428f2d8ad3ac43cd0323c0748993356fae05209ae1c0364a53f62d069c62e9e7f5822a3219773293e5166c81eb72d69b21f0ba19228f984b38279fa82e994cb6d60e9feb2a42207840de9021683d8e4baf6a10ff3a90bb1791c0c557d48fe292ee6a48f9354454cf40a08c28d42e81d519b2841eacea84e6f981f463188d6e005c166e148be570434eaf4a259eec35ee55ff3bbf5b2d37b42b5453b203e158df4d171a2adfc19c737aac9050111e05c5a138ab5e31a13fead08f5d0231045deb7f6d72b965f0879c71e9b45847971daabfdab26dd6f7709352e57d7b17ebf27e22fda1139ebfcfd2b2f3bfa7a423c0126f824faf131308cfaf654673c863c4e9b5778932e5bcb9074cec33f15ed81d119478213262b965f13f6b10c377c760cd64be45b07e6218fe37c012e64d573c4bab10cb7e72602e716d273024677bdee883196f6068fa147bff78bc9793c0e2d174a2e5a60c6a60a1cf2dbb9fe05d813ac8e7fcfe31ec2c39a2ba88bd962e6a74a18a9091a8a3bc1aa73c1da3dd6544744c5e10f1a6cdf39210d363b7992ec99a80c9937d1a6c3a27ad57a441af4b715c12ba7d7dbae46829811002885bf802c82d957ffcae84378e43eddd28d83408e3ecc74e885782df3784dac018852ddf2d6ad824c45b27e4080b45cc0f07dd19435290f80ef88a5cebb33848d6095aa45a944b9bef65e6b45083f1e615b1db25da2ce66a2e3ca726875478a3d02e72370d44a8b9c22024e22a40bad670f1b289921e1eaf19eeddba71797ee50d457774b139c364bfa94ce8e5305eb88322cf8a63bfd6bd3c5ce958e0fb61d4c2186429605716ed45865ec86e25f8ea0dfca2943bb6d0da018f2bb7cf299ac456d10c1f297894e35aecea0c4cce39e3b820f8dd976e470006fc07168d80928740de0a4ecfe6f139ed457265267c67574c4503dad32717b40ee7cae4e253546073e57d6bb478ae7643b8e8a0926198e2b47d7cb590038632072565342f7220f7de04267e8e621f8a92f6fbf827f50de0e752623959d36a3b48c696f42457db5c0362a1e41e3e6655b60101d220ec28ab5f314d8c01bf09e5567addbad1986c06873f3150047743e13f3c2a15284ff00a0b450cb4f2a17addb82266b0e36a17d950a6c22f020f8b788436616e9537e8ec5f6fd4406b080a346521b8626c14643570dfc503b69224e3e0868c17c34a4516ebe56169fd915cfe1715d7c620143c021f4c28f8367cd888480ff4428c06b06f73accec5b6db085e9cb962d1d3a9f08f3979e64e9f1b34b9b9aae4f7e2fbcf03a5eee249d4310a2f8b2cb626a0c227709532ec531720bb8f67d6ed6b7a16f1f438c20df4d4e19fc788b45325c51576b9e38649fc65c32212645dc1ff9c3710e3aa9809d5a006fa1a7340835d2f41b99c542fa9014da05518fc8a11b562ba201eb84bc49f69f2a9be3d5c3fe5010751c47c56913674ebfd26bf229f484b6a0cd35f5200c34d838b0844540b6202e816a5ab2f97bbedccdf45f4d90b347e5fbe417f4b6862c43c9f9376dcba7778c74658eeb998fe8a74772ce69af7155bc1f66f33fba9debfa49f5e76f0159abdecd67a7d6379d46a747aa02c5a1d5343a883f9c4ed0939a56b7a05f3450082808aba385481139cadae427959778bfc1b9cb55a6e67e661da6a7c0ce17768d2dd50fd1c18f063ffc1f30385189e280bb11ac1a6bf2fc632c129c3d1e51a9b1085071f4a7d0361fa02cccc51d7bae25f34b9e69714c3690017b552cf08db7866bff16d8689bdfdbe8c98591d71121ecb408ebcb00993a1fc5ceb288754a6587d893e715501346e5a3e68ecbf1c797cf5c4ef6d5ae7cf2858a07e4c204f95e5e2b153a61ae6263679358902053b02ad8725a09449ce3b41cb18de4ba48629d53bd3f7df641ed0d42a5f4a3ac209057efe7c63892351f4e931a4e8c35a43f45733e7501b0b55dadcc3158fc9b1d57003419f0f5cae028692979450bc657fd16ac811aa4059a34e4ff43dec21029922a9427583c7d7dfd72ac4cc8539210ee30ff3baa168d3daa6c2915061a96d09273892a20702fb3a8276ab13f4cf0f19eb3e82dd5d35b4aa3564310123e6e37365bba3ef7255b13211ffb420c518dae29bf203ca93123b8479d8290e5d70bf91a5eafb696350067fd747e9b600df5dec1cbf81403b9b84aa7627f4dd51d280d1220d251087e53f4892a6ee99e2d580b15440a4f5c46a0ef24dca319f13131ce530dc7a7b8abdafab1ae455f555bb9bd0f61ff4898eef5c703114928a2b1b028fd1f4c13e582d6aaa5a96cfe557f9dec27a6ca9ba74613e9f49f79121c2825bd0e174af582e5d5cdc081978d7ecd4ff32dfe4307d3957c4dce9932ef8a28ab106c82f1aad2806305dde0c49e3ce4817088ec2008fc17b11b7b8d7ffac734b5513058ad65a6326e3c63137fa75ad51bb2fbb5136d5b3b5ed14d86cbdc92a3eb116e502c88481b0e9cb691490b306bc1a27e9463b8f37960bf05c80f12dcb3b0ed8e286f3bcf63274e1446b057f8b68ea3ad06dbc86948997f17620f66880e1f5a6c80c01d3bbc0f2068f0c1c68d414cf142d98a39811bd666789a2e2d8e540b4a0df130e354260349b18f82218ea809bb877316ebfbf837275a5d9b2a5db139461ecc5e1a0adfa2e4a53d39b5e97d266a876cc275abcd269d8108df282618a2d2e47a358f40d437e1ecdc161ff7ca3c76ddac1d553cf58ccdeb1402a14eeec8d49d793aa9e86e734c59bd38e594c5331e5b6a32c8fef24f7595fa1c0db9ac5b75d6245a4db4dfdf9093f21eeab24de5df2fefcce391fcc00c163598986cbe857d70450234796283e6fc512303c60c3b146a6cd13aebcb25e10f090bf636f9654833130a107864a21a1fc209fb8f9712ad7016a3e8bb70b173573d8b93dd4d9631c8a167a87b37bd84af5e209a89bd58b2cf87209a54a19700f548aa37f437eb7b89de42706301a52a1e76d26d678b6b5b34c51d073279ee15d4f15556f9b6cdfb93fa83decfb4e631db4924decf80615db1f888a1d5b023fa21f02c0b40d8e9e42eef8c37ebbfcff00f82d33d033081251c456c7a1bb6266c44bacd988bfc58c2ce3cb3debe028e67b71c481275c2b68a406063f6ed4e17b926b35543c496a3eda2fcbe9c5a0fafa3fec0becd922d7bab57537f45a346ee8e7417454ae0b88a6a8d333cffc38fae0d6acabd4e0f951d1ad7852d7606038dd67bb0fadd8a90271f28b1eb25ac8e60d34e9e186c2d808ab5646bcb607a03f560767668de6d5458471330a34f84524228dae228ebb1f1a6e6c7f9da9d685154b62f626e7451166a2510d3c5c751bc46966919ec768a1c0f8053d6972b14e4751d792260dd8dc4adc624ddbd7dbb0bee533fac39c284ed6934d030f98fb764e9b7d831bb0f9927076e6385c3460455be089f14d1e96347777957472694524bee0018623fddf060b994bc28fa7580f010cffc8c2ddb67973490819c41088921b003bf4484f85b80e0867b7eb05d5a16d65b042e9d514de5341f5c026e8bb017f429fc497ddf4b332ba64e0bab3e3829594fe0d2e942aa92d79246887e1188977123c0ca2cd4ccf343f5d68c13a13c686c883a202eca3575e30a153da82a931c93c3cc912a793fd5cef93230c8ea4b18501036464843e1c6ad9be9eda5bb3e894c26152e5407f0edb4ba64ace5a061ac3ca7b01d399cb2c910a3878489fc2655645b079f2c8181c51d07b5060602e4f61d0b44d4f390181a6fa5949bf7b4e58d293a39b9cf663d1869a6b20d2fe54c74c17658f1002e0ae4adefafa0e8108b62e5555f2b603cf82ca431901e9518ae8c14db646d317937d9f8d4c0581e16e898edc42789c494bd8bb55738f3e7cb202c6f0660ea59167d05b1b5cbc4d65899b7f669ff9de1c096c2878d9a9aaa0709cfda3169269088950688b2ad571da0fd26b3618bb9e33b1b8c1511e6697ab01a0294f2fa6548134daa7b574c35836a1f5f09ca3c9740bb4e559744f7da349a6738f4c38f4004a9932e77a2cc8d51f7b4825308ac90ebf698fefe0c65c96deeb9010fa3d5573393d8a4e2e81711c14777122d41a509f4777fb070e32ae944f34b88e3be48e85d2432826cfa46a2ffbe4ec09402972ec7d9793c391e035b232dedcfe5fe9cf3ba5218586b8eb305040c4e95cfc28cd7346195c6c469f8aa44731e0a7666eb7199e975adb6f3aa5a621813f08d19a5636beae4dbc8a4c3024fd56770ba9bd3422d7615cf853426b981b07ecb1dddd04786a5429a3ff2772b202446871ff2d73524dc07bacf181060bdb76fe7fb8ac61807310e3df1d788cb8b787b6d88984efa94f1da417941af3c9b27bb2c437bf6b97524a5c0b345394eaaf889f532890cf9567ad46f740406418fbade7393cbfaeb1d9394cbcd6fe41acf615b5a7b5b749fb3963bf10db742c9dcbd2471e36e8a9aadeca81bd7a138359fcf975c55286e2222821f2623c4b6a64fcc53c22131a13cc0beb49f113c1f4de9ed26f96ded363d4768e1bfb0b28301fcb1de75b00dcc4aadfad14b166d562ac4fcfc2b3e212a3702e656801d41367dd7cfe44cf1c738c8be895418d22e002d975b1f374fa6e685006929597b9191f4ad91fb01e3d5c0d95373e1dc812e334b51f13864eebfec3e02a0021fdd42ab6c2bdc1eca5e28465b371b5a9fc80226b15c51423e04cd92fc4c66271c44b6a83f9ad7af351f3b66fd3d87d5c4a69ccf204be86b558014fb161ab241a5fc9b90e96afc0cbdfcd0694259b7e1c5d88daffe091060e6c7baf8d5998e2d3187d4d25acecdd999c693fb3bae212ac3ef0ff3be83034a8172679c559050cf32412748a585bdced58e9aef4ba7b88c60c494efb5bbb7de434f6f5c744f084eeb9915c8563bf98c76b4724dc5f802c8d0c13b9fe7c87f3d30419c8a9fba50b983b6b1cf9212b77230c4cbf58e2b59147d5769450b81184d6fc462570aadfda89f5516384ca9b11755520ddd335b8cd51854dc2475f8681a70c9602cb82a9a07fa6880be0ba98accefa6d75103aab35995f22cd6f4a0b07599e1131175d2ee5283fb8bc3e5c9a5a0c0256f7d9adbd5bda06bd23667754fbd06da9a02d3a796e9618c80e382a541e77f97dc1609a6e6b582f88e322c50c2f7e531993522d6bcecce94c82dd57249d9ddc81706683cbd3475fa9869ad2a0fe593a451a62471fd44e6fbc39bb9b55343c0c8f9015151442c6c87a5238a980df393f84d60baa088964196f377f6d13bba4428cceaab898e4848e066d74a3352c7d8e558fcb4eb29d5675b2a4eedb73a1e384d04e3bfd56af4c77513fb2eca7c84afdd55e1a6331961896031b1f5bf87dcf9be3d95f27f05574b991231901a59fe289fac86a04af2a9f38cc18f0234107b965b644ca0e37a18a760739cf011f98859c1b660847e0652eb41b568310826df9926b5dae58d459c1363a972ac9a531743061262efdce36c047dec38f9e445dd397ad1b4fbcc64e7d8c11993140a88c9f78316b0980db4093fa795f61c342ea0456781feeca2f20ec55a89e33465f106b98fef4de69fd5de52478c57af9aa4d6cb00324c259472cacbe6e283c47d06f460e637dba604e8c34155b94db5598dee6b40e507e5254033a645ea945f36535b2055e505c7a1eca946e0fefee37be96918f263058044f5f1376ef628493aeb48e6dec0161481eaa51be2149abb0aeb71d32c9040433668a7d3457b581ceb8ca54c2034d1af46117d9ec4aaaa25a4a9e3eea59a53560be44a122a04afa9d32547222845b18b6df5ab9269b743d0613b13536a5a00437b2201bf735896ddd9e33cd92f1af3fe8e46674998d493d518994bf9d4af4e01d7665ca1d2e83ee3f410a0c929ef0b812caa7994ab7a52ac363cc266fe43daad6f83ee50a7529b01e72ed15366e4ff5b73390f38fa5bf9fdaa181e5f78260a035fa1e09c84f85abe47ca46a0d6db33a440b40735d82a599edf551aeb2ea00e48a4f79015307c8ce23b0822938cd957ff5bf97d2d7fc620d43a8670d3f59f4942557d50280f80459bec3b53c01657d2134c55d77afb2aa4f9eeb6a773d56af29284ee70900bcf921f4f011c9faa02aba0d77e5f81778b2ebc5f3a76fbf57e7b49b751d2a5bfa8350a71bf6ad686e3b19a15f7b4cb0f3f082ab7d9f4d3d9b36c5740e61a86c6493b82f1f1c8eb74407fb95159b4061200907dd60113b31d737377e4ed8bf9145489f0a69625524f8e900f52a54e834a76cb90d1d392a9d6d135dd8238d807b645ffd758b915610e8b79bcf579fd7f50d2c166b309d4a77a399feed3daa365fe678a6a269f20df5cfbde6773df4575e75a4b1d9513157f01341a37cffc29eb3c96b1a293263ad9e0824a21548ada142a380469a2cd93c4294bd61c5feab9d54b194bf1692d7ae1989175d123c4d5994d7f24bebae89b6cb9db8a21eef96ea75e8290abde7d429aa6b65e7cb0fd0dd72df6c2fb2fc44a269b8ebfc035dd58600e38b9f6edbd702a9d2abac43914b4c3778682528b265e9398d1540b11f88d8bb0aef7eaab7b475ff3160bb2e36dd2ea92074c667d6a2c7c75d35dba4b586d6fa6294cc82740baeda72f83fbf996b0b138c8144892a35e2825ae6e3f254e0ecc021d1fe52608c4f2a6ffe3e5716a9934e7259fa4498a4a77b08e9f1357e547dd66232bd8adefc9d77e25b3cea2516cf0c69791dee20cf53c3a4133b314175d913ab1ca7384c938e685bb4d328fd7f4dc221055b7ff710e4edeba5db5286e1835d1104229cd3588c29e93ae382eaecbe41c16b90b8522251fae1f16b15eec575fbb5f6601320376aec3b13693a9edb6c5a4e213dbc977ec3e06c3f6bc2527adfa7e432dd0921a56b07cddc2457d8c14679b28868d2c36a8288258d15aca8fae5f35bdf1435046de523b754498940896f6e0878efe5912890fceb801f6a8c909e5b97c6761ce594dd460a64d19e9c5d9f36fcfbdf788e141292b81df7c5eb858c6ddf65f843bdfb859767309c8fb1352136f933150aa1419149f7a9f3088af1a82151a57661a649d0093689156347f71117e1fbcaee7d0ab2686139447d5f7661e8f901355a19b3a0268f37ecc91a9f3991326f9409509e9e32d30a09cfdd02b7282b005bcb433f2589ad266396736bae5b23d53ed79f5aa05afe4ef1f613f03302ad76716f2b8d96ea88fc1ff93622f2ba039024546f6bcdf3f5a9e0d1020ac44539cb7698d1a10b9639b3891bce6b66f17604ff99c505540dcbc90fba728229f8c6eb3d2d0980fa259783a20357f9dea9c71f592c7b8c949335b38edf265530c43c6a2023231dd0c57d062b35eb915c1b3fca5d241fe834c30293be843c39a83a512d3e4d3b69cb1056cded0170fb3b178a246012eb0be43601ccf8da9e67db7f52a8966054044de8811d88170c1d83c517b157bfe919e355ed0e5afe890fa77a1071c3d47eacb58c9c09cb0680add76666593b9b619e2eb96a53e2507c707e64230b1e612080eb1f8359469de99fe480d54188749b1c34ae41ecce2b5a92378fe9f32218b09b197fccc5992b0f4aa59e5cc07105756f59f53b06ea092f80f3a20b977010385f00037a9bcb7c3e8207fd658c3f344877afb3bf7a1bc90863e4bd491669771afc09562b95e2031b11b51da8db3fe49350802e33e1eb1c24f738563f00e4ae6904884eb8b935b0879ff118f98ad81de3cdfbd6ed8ad45a6197d6c87744f06666675752c02c0d0c93813e744db7e71f6649b426b64c1df6987a5ebf00e433762bc79bf1ce4587385cb259dd3594eb060431ff00bf48f610b37dd2b8de478d24c314a54e2d59163505bc84d4dd6ea3431901bb1c3b7d5e6ab933315907fb2fe87f09e03a83660e42aaf9056782bc1d3e356647a609153826f652b14a639a1cb50c97c2d38b9fd75cb365c6b3280fc9660159b14f2d80cfcdc1c811e40fd268e77a34c5b75ac56461c332e4fcb4cc5c2b995a1126fd19047182c4bfd72f2ee4dfe9e956f67a8b405f7af98b9a87c8b1cee2b4efb8b6b2d6ce4481bb9e71585f63212f4b23df259af785c0aa4469b70cbaa1dd885167acc22ebdbf0a900db509d19c0e6c18e15fb071d2bd2b4e32720c31099ff5409a4e3a749449c8643a7b6fb720cb2a2806ae89816d98535e437138954ac501af65da26d3eb626172c66aa7bc089f29dafc04665e124b8941cd5abb8dfd8dce1e251e07c8cd17e4fb28772439cca13ac6f052e59a90f46221b18a639cec7dac0d8d2777a1b25ca3eb3a30052437f979c","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
