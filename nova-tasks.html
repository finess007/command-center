<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"489fc8933c0efc4d27bb03b24c84ebc2c90cad17818fd0fec28e47f313a2ef9c61fece4e4ab22264da66e42e84302b7d99489e76c60839ab309da67847211602e4960eb5f22038d0b708e15545f6a8395c8f5efa37b44153c69c6a303ce627864fca86452d3c9c7620b21dd5ad56f38b1324d7121b20b2f71fc093e9268f5ec1364b9dd9f96ef1e8b64fd7a385d2336ab5a6c94a7348cdfa251277f183e2020b5671ed45328b7fa8b877657f658722898826162371591f871de1bae03718d9e1d70da93a9b352b84a52536060ac3bf3681816d8f074b8fad2d0c812c68a9d7b8d9f76abeb41ba4e003b9a2ded9ecc945bebd220e241071f54069c2080dbb13bb1bc6c05a3a6a9aa2616f5d8cec6c6774f368f5970efc431982bb9608d72c4422dc3e5e7a28c3e11f1c2322b654f04ad22ad8660418c510b9779b5a6136b7ce5686307fa72c22c3ae426ca770f9583fbdecaeff53cc449ff07ab9e3f472c1accfaf9ad749f0211ef646cf17fd438a39099dc7667635142c730e81ca0a1e1fe6c68e8fd5fe581640de460c3978453234c9d33d8caf484793c448bb5560f88ab19b36571a6c522d6f7093edefde1fafb52bb7bf1011eece9af2f2ea4c3d36c84bafce980bac1ab776573c586cabfa699ec2abe0a5d8e192ea7d19ef02a321c82a82c22520cc3aea45a08920ba51bd91118bff8662b2b9bb441fb02628cf08a1767d77ac7a87367f6e9e0b8cf7a49b8979625d539d45df0620c6cd1fb2439e3815baa14e7de6b72557f3b7a34da019af36cdbb94f2925d9349c3678170250fb6f4db4f1026604551776ff1d414461790bf75f4dd7d2c267f596a60c8c5125c07d4f20248896fb4225404bc8092487850ec8eecd82a3678df75f4231a75cb15c0355bf7aef2e66e7d3b21aa08e12d046f6e18f94f7e40905015cbdb10bb9500002e3f0ed287cf634393e6f4c8b488bbc9141658a4d92b3284f410bf87e7078131428cc96880322177db07d22e5947f08ff911374d7d85150b4f8381c6aaac87adbfcddc7a842248aae2a561083aedf2d8e46c6c4955572846a53f9c441ab5c9ab300debf892468acb5954798e74257a28ee347f574d53cad86a8ca61e2199cc7f59c0a582ff0e0c73ab911abf08d39f52fc96649b72c694ba8cd5c79f481c9fc1d9c5b9d90c8576d7c2eeb1409351e11826b40d4f58dce1c34d3d1b805002659fdda824cb5a41f06904e13e233826b344045e3f6fc5e3b184bed2b57f6025634d2b6402847dd8081aa8ac40e3f35817d41bea81165989507c67585c2e04a789eb2f41ea52977a03823109630fbc5ce0e03e1da6e5a84a4b0fd6730ef90d00114ef13956a13fa1c0b0e9d3a7fde697ddd2277d19cb22f53d48a9a746f0302b7cc942e980d32162da60bc845a1e956f1cf7a4b5e0eb6f047644854c77197e7c0267a29b0e7625ed3c297546918310ecaa4882f3209e3815a37228b3956579999e9b1fc931e03e660a60e94efed5a7435360fcd07a57e3a7c2f52df297db2b3ab6645c7269b550755fc9b33df5df579ee4e377e718868569688711725ef168e40398b20c8a3720e60db13dd89fc8ed8683493dd794f58e75f0578f1071e87ca55a29a6d105c7d48084c6437471bbd4906f6a6643af3b49270173e17b22d6e2fa19f0e10df219b22a38f92ed24bd535be8847a528afe5f4fd0434d1e70d827f9854da822647db1b4807818cc9076c8520dba3a4034613ff80733ea260933fc29bc797dbcae1ff008ae3a01e8e9495f8d7fd3f28877b86f124d96ea56681d7ee2a7d810e7be2045ddf6a4e6156174fc41ee72e2ef19c6e7eb38a67a3c4074efceebd3010b42ba9032e605afa8ba033bcf7258f084a2aecce9a027ae64a9b600de1caf556ff7595f07a66500eda95a73ab0233d1df6bff3e075392f2ef5598628fdadf1abe2307564d06c90f5b937218ca93ea71a2aca5639771b39c0e858c0f7c2fb29a5d1322867a369af69ef26656ca051c7cb7b887fa0d3173713b602762440f2adac035791bdc99e5481b5a400b6caf7cf61ba6a193fe031756d8c70e66a45f16aab08af2ecd91b27a63c2e1660122e0c0affa6d05e9f7b2d7b7ac24052fe113b8cc0bec92bd8aadbf9b92f802ba2f5eb403be9d8aae897b76f505df08127881f46a35a195d089f885150d3f80fdf17e3421c17719e154d96c6801e13f466c8d0b40e1936cd647e0ec2df05728171a891cc688e4402f2b31132597e5fdfca5a100f43f3f4d240b490aecef23143cdee66b584107123d257062056594626ae3ee6537eb2abd224c461be9328bc3a8f1fc66a5e2f78460923db5846c464b8fbaddfd29aeaeda8bcbc069a92ee3a6a15f8cb1091a1f262f484dd9be09c931516e5afd631bb50525d20fc3aaf6b3c86a28996aeac8cad4f7df82ec1d4678df04f50cd6b8c3bef129117d86b8aaae620eebbdad4875c4e748d452489a005f25b55a8b6f751ef52512925ad035b4d57284fd0cd50b681c569a61be2c63a83ca1a8b0be7a7657dd87a4301bd311523cc627bfc09389d8e7b5fc4f89d901e3e780555a88acb3fb1fe5ded30a3810d178ee232de6a2fd197abe237f6fca157a965406b1b2fb0c847c666c5287990be337a8a2b5d1f1693c3bdce02ea2b8ee4ac9f888a1800e5979f5fbe82d02e5ae8edfdf75d44d80aeb0254b45ac1384aa8e3cc2c97c0f0577bc7f6c59e89d8d21ec1f0ae26ffe6790a745e7a8b7694819672986354316d401c949c085ecbe5181c26048eef4652f3736b9fc93934cf8403a50f7564e957111b637a4d2e3405ffbecf8e842fe651389d1ac7b39a7d37f2f34e8d9c299adf3309b14aa4550e7e58858143661c0fdada404b88dfcb9ff9d9f90625f5771507284364dcc64efb066022ddb067b60fedadda899f2f359afcbf2532a08a6801556782ea08cee782e3f0b2fe6a745b2c0178efdf4fd2ae67c96e2eecb00375f2536edf94c2c0b3f6a6ebf91331fd5f83ae152d921e84f2f156304d2198780b0df70b0d4d9aae03e75907c9d74adfe4abdaf20cd15b01b614ada40ce24ec9e3e82a2b7775f7aaa38d84844596f6e8cabbb2a9a37f1d6da98f4921ea7b52c6c9eed2552f6b9fa9ba621e25fee6531cb881f29f96bedd3f3ff11c4a8b91c623e6b183604b7895be33b6e0535a4602bc204027a284dd9fe7e8202612551f5a0e74cc0b4469b42bd8d20ab3a2b07932225894e1f96b5ea3de9396a61546554e6009edee79dad21a2e0afda9523d778e4a3f285b3e77f44f9f7b22f2fa2c79ef6a9934a81fd2df9445dd001665d25e4ad318586745f81a4a67a9a8bdfe952bec77df32c2c751a6f02f3555791df761e737771fed3c35834a8167faacf4a9f7503769eac00cf97f8cfdbc31283d32cfe68cb15d80b971c185dc987cb2a6472b1486b34032ac498293ce6fc138dd57f89fa56b56b25908028b3fa53768545770bf51936889f43b2d196f89a4eb16934934041613090a5d967d87df63b99f61740188d4f0f2a9a2bc02920a00d0b28bc6cc8611d06c1e0c185d80b3d99f243b9da833fb714847a3573d41ec41b2c553a6bdda955251fb0cee6041f67756d29f0ffa9b836a9f646f5e27f5dd14d26f88665bf7afde7c365a4a455f0f7f272e1f8120fd580e3f9153aabb4f60355bb77f87b6d1382510692787729a25a68d67084c7201e02047f357a03f2285d199e4a9b22c584d186fec41a2d0c798c96d85322f9aa2199bc840534816b465d4e53f8bd71a8e57adc4cbea6d603fff45dedfcf7ab56f583882774ff6ff8eb55fc93b47e6db26d72fc82da20f9836b1d6ca6a94839ce156ff223ee4132511cd64a5168a600bec6354cce1dd3e71554f2f7861834a8450b87303bfc3563f71b6a93c1d704c90147829ae82c7800dc729dfdd381abaa95c40d6aa4af00f50b1aedfbf736c8d10cab1e01ebfa0665b417db080e0ef3f17c0721c23b4a5d812f9c632fa804c6a3ed192f9d66eb7efc9e3d17a97a2a72422de1ca0caca9a0a288fd36759cb0c4dc4a7385c2202359ca7836d92bdeabcd06b8dfd7c90fa9608389c449d95b5560815408a6ece62bd267fbdd2dec77539ed9e5c85536ca511df98df57e47ef9d120021a0d31601f8b8fb33e95b1b3d3b9b4df46da638a1325b58215894704673bf1fe639e094c24b89106b484c02d94f72bf1eafe7137be364ddf15bbc5e62d934a9c31fe9c4aa8534ac42e9457d2fa026f99a8eae84e2785268885abb666d7e03383cea65f0e84504b750685d472b41ed6d9a6f2271b0a1ca47e5eeaf94b17ca06991fe715bb6f205615ffd307e9898ecce24ff8c8d1d6b7679c858140ef746a54dd6596a117d30e8deaa3c62482ee3c26857a7a639b95a5622f93e47b963c54e34593cdae4ffee17b506abb2c4f84bd66281b88f445e787cf01a291b7349fb0961d18ef76c01ca5e3c8c0fbe8977498eac5a13b485450fb490810c0c6e19ab15472f304248eb77208a946a33075d320c543b29b84558ff12c8649b76c4c679d2ffd5ec55dcf421d473d0d4fac007384e8e8ab603d16948d0a7fe5d25fec28c00eaebd1c84a89c22a1536b636db3eb37c4f52a6ac66cd201e5c1d2186e71e104062b5da9cdf1fea9eec2aedc06e2e55a3296c82236d999450e28d8c0a52fd6cca1fc566690d6d2640f662adeeac955a8d6be7b6381ebefaaf95e6f30c80a40c67d2d0273c99b3e2ad27ca08c4a1d03cb80d943a053238868d3212c4c111d747ca8a12152e057a708a9c3e0c105a77e550f85d46326f1580c13a5db918430ea5d9a58c1a157d5d9c202b9de1d98ae32a0ce12e8c92dcf014ffe3d51787d63d64ccd5ce0ef9e174bc672deed40d3e30faba8dd2fa16f1a0185bb3985553f2cd5c96545b5b4994b4b79151d7a7c15c1efa98135110c367145d32cea3a7d675fa61e2cf58416ea4fb53365463172f889acab2f44240e3610beb9bc028c4b662239e4628f5eb4434295e8764ebbeb0c8e8a6be4910df8201a281e9a874e899e2cb96c602ba60a378bfbb58acd43a20bad328784722cd6036ed4a839c08ead76f0b667ac0452e4aad94131b2128ece29f870decb5e0bbfa323ffabca64f315678aa0186f308ab13244cbf9d3f7c248d7209be9034e72d6fc35cbbf791dc1693fa40bf15be8738d6471bc239fa41aa18f0e5ab132058cf66fe796e8e3c7179fd0637d86e1d28b52c9535fa802af3aaa1a0f1191d5c6e0acb398edc9c51142d38d4964390151c401fd3928a3994bbe53f07e643b8d3169fefba9b6b1e8af2a01225cff8e4cffd1820361a482177d32b360bfa6f523696c865081a77d671941f79688b619a4f39ef8d98d32f7a91bfd098e8e9f21807821c94f041fc16c81fe64e98b98c656ff50103eab42579ab3ca9ae16c28af04279de086364398a90bdf0a86b0de4d532fb36134c98c86ea871a599a2868f11644eac4aabdb1521f48e5c0b5d669a1b5f93d52ce0d29c3845d22ec1e08939ce46e166ece51c8813ce82d6a96985b2f821906bebd5dd456cd0415b4275396d0d1fc42168a011077e8288cc9146a648778bd5d55f4df47f2a6e8b3675cb19062967316b7ac263d7bdb17993f4aae7173494223e8ba60dc59375a873b8ba7d6f7e6be24b1941df00aff469930194175b79ec415f868dff4fe024fe4d3084d7a70c7aef37ab7765a6c4710e948320f811ece0ab7580b49a55576d3c098acb9a4de2066f4dccf95d74a98e15c1ac21931ca999c9e41009f098f427d2fd3e89590b97d951a58184a93edb62c2d677f1387e0ea49bc054dbddd0f7b9cb3d02c473762debe696e838c862f466d4bb3b90fbf159bf4fd7ff937ba4fa393023dbee5353941bd05296bb503fcac241271d869cb7ea05dd560073ae32f212b775fbc2acb45284a1ece0a0b79736f4969342be708209a6c22317927c4ad39cdf212afff197ca3ca63317786d3deaa03908c0e61f28050ba2f151985be6a0448f4acdf81e00b4702bb21ce4ebe6e7c9e50cdc190cf58233749f6ea37821c78e7e20229bff7d31ecbab567e07b06878a42f3df80d4574c1524dfdcb32cd4ca39a4c6555dfbab114b93f4e025a440315b1997c500711bf7f8686bd0de50fc3b5b07af309a6797275466bb53bdfa2fa81f959072716366f98ae8ee8ef784047cbc5f240f4240d8f115edddeff431d7f3853454a9b217cc870440a74076a899491349e888d4cf303741b49561fb72fd0bd8cac6482317b9c26d0864ba3e7be7af128d4afe8abf77dac10535b878943b1d1b15d9b3030a248760d3a2ffef5f66ad3259522ac9944a7f182d28a2efca4aa7f11f25774144385a15c7f5044b721a16d517548aa0444ae77da15a41999a2bd00252b59c7df6d76b9ecd99eb4b8f2de1f3204d7cfcdaffddfed00669e13f3f512ee3eef49b87c74d7c4e169c227d6f117582fe85798de4801eb36a33ea7f16b1e8a8b984ffa8ebba74d9a6c7597ad5a1249c2164e78e8777850e412acba641225b69f927f5bd831ac6b339189c95799a2cc9dacef70a463b668c1d32927ace5e7d54441198babf1fccaa7216394ed82493e72dada6a3fbd7d59b8ea292417a3f0881f81e39e94948afc6190a76ba939a1569a3cbf00489989e8f65ad0944a7f11772e6bf6c4f8404bfbf5efc099af0e2a4cec4301f64fb9442e6e6e08edf97c228836009c8b9dd22dcce682eb3203436eb33eaf9e1043269b0da4fda423fee76e07e368bd8496fb7982eb5154887d7b1d1c4d743e74e24ac45f7fc0b06577d7217d377ec6a9f8f4aef172c2531b6f577073803ef0afaa6aab84b296edd7f639f922d05e0621904b54ff7c4b7a09b4c868dd2588e48a069464f619b134b38d3533742e74b560d01ee58154661cf1fbc3598d543bb122b225a56305e0d5c9883fdf89d211d0f8af0e4607b6214c7bbe8a4e69ef7a343f72e49634476df09710164fa6c2f81484c4b1614d6d540360bb49bd55e4f1903ec3d24c86b647d46bf305a448a96e79bdd1f01095b6a0444583edb6df33619b7e997d2cedd789f42faddf41d4b127a481f7b64c22f5947fa3acd672409134d8f9367f7e9bb0de25a189d4f98d1c3dcd845d76b5fef6e4186e8161942e760152e3d67bc08df5e1acddbc297e7d1b73f5d8ea870464a7e9c9ac427fd15906a9dad82b45021fe52f9e048d5215d8339377927fea8f81e23b0a1edffc188b862e17253b234361a12d1e242c8584cc44a0dd2f298b65cc3eb4f6c810a58b28525f1cca150bc0c846073754a369f092a7b490903635fe55bef5b3518fc8908cacc6135c88cd2e7af473cd3f1074163623914cb08eb65c36095ef21aab59d1ae70d9f23b0f734923394fc4b4fbdc67ea4d0f09a19ec2cb1c361b628c67e0573e4fe4fffe277d0e9c5bae6f83e4918508a44625c2b3d84d4a834f2fe52a51920a79c4dd8d048dc820975e7082e638097aab83dd89d4bc8504998c8c90caf059a039a88266d59cfe4bfe69fc31ab85d22d2a8905b2080e58bc5a065dcd9fb2b30c5b1e77d8252684a7e3ea1bb11f74084b437000cabb0059b8c4eec323a7c9e93761cc6d4cde003f416539b85b189ffd4d1823e748be7836e38f534bd41a3e21ff4588f4c17a1098b66a4672d116ad9f73f505117c7350a3a1e2fc183e8b788f57fbac0dfe8f235a2f879ad987159825981f853f3b520f1193669220ff44071508593fe8f8936c0b12ea6f27309eb1ee6f332c31b4eee6445b6a7c232e4de1ca5cc57b753047c90d0b377ff03a62537ac395e5f5b4c6d0d032390698e66bab0713ae45486db0ec756dbc8d821c58843c40bedd092fa2d5a170a0a7c3a85aff930c6714e6798530bab0aa230bd61daddd1cdbb37d29355fb0f35eb2751fb603f573751705c3da347b70aa825a08a9859d2f08ad894616f87f215a0fe18a3e815b16cdd0bb066b201887e59d852c43738faa84cb7cda4b95bd94eac10d413bf47397eafa871a105db499b7758c8ee971e556fd3088dae33f6b9ae19e7d408de76943ac2d42dc4dc4edcec167e54d79bd10f349de7abed0c8997d1c3087db5afc92b599cf2ff248dd37cd306c840bd134aac602e745161f506494968453c6aaa276c10bb48cc384a96bb5cb7f96f736732cc1057e4516bce5b7b97b4a9ce2ac1f223ec89a07b1037ce25f75c15765235ffc02759867852b50818c4b6057316d26fd8dee9365fba03b96eaf5ea8871d013dfe78c08c6f262a1e5789d6e7e792c32bc3bcc0fa215887c48d37b80c73e47e7836ee35ef46f13ed7aec392ac46d7eca63f8b70c407401e050317d8a6c2e2722667ad7ade496168626ee5108540f20a2838e228e6cf627acf23065ef8563d4c33984471ef5f74b898c57e9b871a65dcffb808480e7601610f3e27f72c221f3f4c88cdc01c48f4f42cff6586f2132ac4ac6e984e0a935c2a88f2997ae8271ac5b7b57106d045a7fc38d95b506e65e78d37297f424b086a24ca3aeff39bec3d73aec0ddfbd0b7784f1d3f2150c1a4265a9f4b21e53547231ccfe17ebbd39535c79046370c1353c4abf1df485a37a9b4f2a61d4088c4d7901b538fb9ec285602a3f95a08347d755fe143667ff55fadfe44514f27c3cf447790a183a714372397bba4c48be5d55bd8ad857a81d8f3a94bb30cd60d021302245e3b469da7403809c0730f2ebeb5d25a1818387036db295f944f62c3d218643cdf494c614cb7bfff368f7fb455ce8ec5a625bcdd4a2e434bde876a9eee4ee61e251e276a943e65092f92bbe348da05a916db728b1c749938f56e1201a55b2938ab7ab091b9ba28cf5113b68ff617b3161762b85dbdf0c9069a6210842fc51147703e511b51955fa3916b9ad10af586a6110c69e46f4ed9d1a3ea1409d035dfab29671c33eb8022a9072fb940fa9b66f3f56e06f48903190c5e8329866eb36a8dc6829b0daa84b698e23dc41a8a2fc57f1fdfa3bbaa62e4a6e765e6237993b4f1c5a9c86b6eaa37ca6b547eff92daedb5ff623df44f50025c73663e6382fdc968b0948613581d33d27657084d796e7c0e23da95672fac23f302c267186430bf51953daa1cf1cdbe3ffbcce0bdf48ee1a419598d993a4e91c1eeca39b978ca105fe35f3fc7f9ebda2d7e2aee41956fb66e9648715dbd4c3f0e0af07506a556facad4f3c6931ebbd759f4ce4b19160fe54f06ccf3e275e3eafcb1f942e9c15c0cb55c53bc376ad6674fe9b0070ce6b6842612fa0ff14c1fb35247de31de2eb3961310753c9a65b93bb0ad949160213deea6051ddd4229305fe9c9891f6b7592798ad4bdeaae08d8da4bd56c93205c21928a02e38caf8e93e0370432b175ab6e41d26bec815f7644dc8c5219e3330fb75861ddc321ffebfb4ca4ee3a3ad9c808a7d2335fa58d421a756c38aa82099e81732a75bd745daed51a8a354de267ce7b72c14e2966af66cc140c060e96207f44efb1694adb773d58ddb65443e3a75dc53e6061b298d8d7dc71b0839f9989e80743e6ce810e89e2db403e4402867ff9e68b7c462c0db77e5bbf35a96ce3f0f962f0941a7aa13b8009ca95465d99005bec72aaf3c7d121d683bae27db248540a9c643a601d8cf5b26edc7ef9f67ada3b0d01db123fb44566c9fd3ebff694f32773bb414471dce83043b73f0e7610eb8f5f7af26cbab29fba74c1b536a9d47b82d5a9162923d72d53f09159f5afc8842baa1cec1a3ffd38e96aaeaf04eeb94b5f9e3f2befa33f97cf80f1b2bc9441202bc9dc872f5d856118477e69033b0bf82fc4066c245f5d5f665c09da66445feb29b99f043f133a9615c8aa436a514575ec9a4b6b678bc98995e3de68eb94acc57ea0baa48e4b234bbafbdb33ee5d751fce110134c6ce06dd6c446555cef586544d3deb75fdae698749cf559f1fa86c350947d106fdb2f6a47947831a6f678a0c2235ec3aee8d5eb25496e5c52ce34f58789c2eac35a909df33d174de5a048a64a3f10109bcc154dd4ada257863a42f610f867c636d232426b1033695234f824ea756fff7c35a0de3a98a31055d9f97d3035a65b50cc0877c3c79a5f94e45825110552085ceba78370379c5bf7cc4efaa2bc8e11dc92d39687fe3d37d6ad1afa6b3b3ae4b6803cd81353e54783cc91f33c344b608bcfd0dea8d0aac2eff2b31963a6cb7f2fb78376ebb36d395263d7ce813a390dd38a4ab651aebf97cf4aacbe1c6bc2073deacc655ff321f87a6c0f9d28a9edce53276d8a1a2747247d2e9d3f26f0907ed14c93e8c4a591223e7a14af4dc805e8554f1676016e6c5ef9cddbd87402cf94974c500fa34aa01b927803b9a89d3092430bdddea7bf1817c39618e31633b3799997cb9fc567c5976918ec1da760ddfedb24d0ea0f2e0d631c132f1b6ee63493bfb049e158cf4207e99621850c78c7f5bc42d79a1a474b19dfa5c060b47f2636aecd9f4286cee99690cad75d08eaf1938fb4743c91d66dd816a44e99910db34a6156cc44d9d95a10b0b29e63699ce859da401f385061ce1cb0fb606ca64dae86c3586d9774b67394c083aa470d77c054e9e70aa5bc9dbefe1f31a5575a67ec0dc639399f44c4f69fda53b82cc82025b41809bae8d057f4d4c53bc2a0380353bed7fe15ae6c1a3e60c81927775ac172e27d9f953aca6c46406fba84bed3b72c3f1f9be1a80063c85034c0df100cd993365e97a121a0d6fb286db3b9d50177bb441bb5cc0a9894b12debe9a820ffb5a69e0a7694785454995791d5863a584fe20c0e318e227999193e699a23ad1ac03bad91c08dc6694d5747428230c1076ba55df8bb20b98b55d127422b5f36a21021022c37682dfbbfddf312aefb84faa9a0f280d15253d4419fe4ad33a71f2cc4b8f756f4868e327b29343fb77af1b19b025454fa49b43eb19c9d082c8f2c7289b1fd210b6d740e3b66ef18a1820c6890895b9ea05e017799c4a8e8ea133cbcff8084a2a58263ffe0ed5528faf4ef116bccf3cf077f782307fedf86540f3b7a8bbfee70d16926e2aa2a4a9f7a01f456a9eac99410e613b1e43dcfb74d7cace3dbf717c3c4e6d2385bea5ea5e58b641fdc78dcde0a2a448a61b215f6521bdd5c0562ff481bb5edfa3d0ecb78058bb4645ce9e4cb7ed30cc88e4f00997b031b4e832bc847f585618bcde01432222827bc4fe5a32dca0c307381031b47fe02b0f8ac5eb8c2e2ee8ad96f90b88cdc0468373576be8a653796b028ac478942d463cf0ef86f8238ec908162ba792afb6a6760783e8b42ecf826b08d68008790d2e755da42b1b616b64a8931da1fc0dc753df8b569fbfe28b3a3a3dfb86a2e83365850c1cd80dbfd128bf0357a063266693dc1295119c09eef18c9fefe8663d7e7d169f3daff3bec79bb86c7b0e7098ca0e57b503fecc671c7bb98e20b9887ccfdb09b2dbf6f16e5222742f96c4ce7df64bffcee0c41862640a52388dd0793fdb605c7e5b0af8caa796c2b492e1233600035560bb4b1ae9dcccdbefa3e352019f34e16176cb004f6ed97874825fc7f58673c8b33023db4437f72610e4b6ea380151d285a5bfb4b74780d79e5322d8de1cd3207c4dafea7fa97b07ea8f126cb4de946e26d8c062f690bf9366a2d78e26e2407a5d3abd0aa69916e444741faa327e7818062fa9026454e062cec09137b2f982d4fb657537ea45ca2326da6e53d9dc0423f06b91a37d5d8c463df2f3fff39b57db0001e53353729927f999f8e6ce4491d0b481db2a49611df87b8748cd5ea3e6d4bb50747cc86ff60de725758e3599752907519d480d882ed7ea7ef00f5d7051f420f2c776abab487695bd174f212a27dc809ece052eb3fad51b5a5d2ef62bfbab341003fc723ce63d188fad1a1563b1b735f9a836101b47c6b0cb57bc22b233a7b9e0a727a737bdfde6583731317734e9c4a80bed00eae9318524785bf46dabbc174243eb41dc1e2b4d422d94770d610e720f8a2bd74d70bc5cb9b9e28ebd119ddb1ea57c5b8d4d5dc5b36d6063be750e9aa2908f30a1527ac55051f80d487db98af6d152a686920e165a5d9787f3b9d85c99f1971c5a9b1f9ea7e9854b0942e94b4db3088fe7111c0652020c91a5c1ea5f2f6fa7c4f6a38e839b844c4516141cfe456677b364c952fcf38524deec9d1c844dcb8af9b0972af8771c1c73e9df9772cda5eadf3ba03696ae265d2ca3e6d3f4cdc247adfa8e500cb931576958720bfd8abc7f3e2810740b8635065abff446b4eb9a27a63e7e62e3f25f5d26d8b804694c8e34ada85c9f102e7e5780e0cbd63e23f46d972d0de7f5133be1fec1273c81b3e37bd1e5a5fde460a2d95727b1466c8bb70b66950b1bc568d083d37d1c600c2c7f8552c6926b386e356b4be9896e49f6f39b5f941abeedbe22ee750cf4c50745796abab729e608ee243d32549bf98f9ce4da87cf78c8f1a81f817b1982f81069860cf0936a323a9f391d5243ae958e357e8aa9f9cd8530b6373059e54650e55611fdad59f91cde6e3eb07311989437146f81c236c31b101879137ea83ea0542eb569ba2ecb3f274c6e726103ccd715be20cc755a0bdb7c4c686fce6c1f62698efab8398f35a355ed2148f6481516f14dc98a9006600f39fb90bfb97580387550de599e97a6dbfdfbf34fa630bac9992dd9c3b5157d12148b75b074d8e0a2647f235627bebc928e95d0134a17e11937211e449922da026b5f3bb6aff47509f11db2488bece632a43e5194ae3459f094a002f7a5b5926dc475490bee36f1bcaa559724511525e9f1759a2f9e80780e1291748d40dfcbb74c8f449e7b12ced47d9f408eb71aed9cfb2f6daad9f18ae368fd958203865bd97476d64c48ac30b1dd2728cbcb853e702eb154ff01a47685bfcd7d2131aaffcc4bb2404fee763bea678004f723413ce5f19b9d4671ef9460bf791752da317c1b2c7d1919de6f1fc743050397022175e792a6adf152247395c72a94636310d21d73842ae94a00db49b21d9de87d2b6e821fff628edcc47316af8ea4cae336f5cce5c100b5727773187f13353da5957476d8a281e5edd8ed5375dcb86eedb66c9696d5cd31bcbb522407f2d8509f3721b05ae603276a611c3f8b710f07a9332e9cb89ac769f7e849c4fae864ecf6af18d1f031c470abf274deabf1640e350d5439ff7326d04bf69137f7ffcf545a33c055423076cb31c42b60a9553c1a9bfbb7ed870e577c8a6e5dd2aa979ec517cc985411f6f04f5554aad9dcbf0db86a71d4e354620b240a7f1f7ad8ea1a2e861355b7f1a44746948dde009fe2aa1741b2c6e08e9f7a05aa49ecd9c9951754a87c1004b9f738bdb583be2c706b76710244e42052af1d1818338b8bca3d8d928a9da30d74e77b3bcce6151358c3c269387a1b3b71643bd9f3b065dfd7006bf991086e1fd11284022aa9946290ca98c89b595c0152d1ba62b20b33d297d1185aed73b12bc0425ae42835bd82690e2c9242cda5cf52155975fa1d7bd3139329294bd91f3be201c391ce98b48356cdb5b00ca1a8992f501097c08ff5d2f9af1f18709101f25ebdd34cf3ffaf0a3e525a8a84dfff5111de59eac15ab0e625b0c79a7275426a65d4a27e72c1f2c564a73d681f165973379a8915671ebdfe884687f53bc3eca3faadf8c3f092567752b54fbe0a407133bb4a34f786a0a9723db3567a723620d74f5bc2990c4cc63fe5a6c1b7745accc2f58439b29b6d69b64f0d7f26accca907bc3a8b01b11bff6a4a508236c5c2d9bc6bf8568569bacbd79edfe4a191f24eb037c54cb6c955c73986a2cf2ede074055056f2498c87451dfd927ba045adf988557157e6bad2c701b039812d88f37a8a49bdf8f0d5988081fb93428da5720405703311bf31e23c3ee3e019542326a01ea25bf85bb77aef3202ca63c7db6463713ca68416aabdc7cc3a3d39b3e9b87cbbbb4ba056660dd524cd385ba85d915d8e250f314cdf9b6c1e022b72eada11ea2e3acfed1ddbb379c9a477695415b6b7bc8ecebffa3dd0f55224e0a889c87208ed60d1553c8e3a64cd4e94d2febe8e790310dbe51ff6e2c68d1223298ee933c73f32cce9a2b90ab23cb796c8dabbc3f5d5be971567ca761c9e3d87bd15e75e2809c369c26a26055edf15a400eaf0313b486f63c36a189ce3a370ff8ab53b933ca2701bd50a19a4c00693ea336ddf94302f075cdab574ee92c2676127b6318133da7e32dba263414822c08a18c0cf7d06f9f3696925de378b0a10b12fe43a049e5d020eacc283482ce51cdcbbb9afc84a857ab4ea4a1c926d62b9982f5dd71ab74471ba8cb8e9ca14c1c21d0b9878d5cff0c34217794a84ce8d34b687176d9e0211079ca2e3eb53006aa3db8722fdc090113e83ff962e09178b8544cb4ddf30146b745242130d6db6b98c3351d0456a7ee37fbc4283cafa4f7d1448fcfd214e773f2aafeb344b09fc65ee51319756cfa09c8b6dd104e3cb9","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
