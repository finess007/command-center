<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"7e6b8fe0ef2794de803ab0aa99dce6d0e11d252f1ccaf637a2494a4981911ebd1ae9a81173930484f34c421569469ea91c82971c60d1bd5d19eff0fb45087fa65e85c56ffec22ae0ee844574804635a131d57fe75808b9e06a755fa8ab30a9aca7ce5ea8d736d5e6807ce791059647c61b334ae032c7903505426f945dec05ec9b7715849f2c4fdb0de8905dff94bb3a1f4e2a89d7b136ef545f057d74e07e7c879a9c3d214cc91e771dfb99107f5684b73462b07a143f9486e16ce43f771c48651a411ad5b86fd1e2c43c92d47040937545b2c2a22faf14ecb63ee8f789ed3cc8cccc53e50483729aa4869ece9693f696fa7f3b650519aa007ec34153de4ea6cb54db77b89bcc513476bba0885974366760df4f1b067a39885464d1a4352ebafd8e0b059b3c72a5022ddbffaead68e6bebcd7ceb24d32732d01222bda1f288797e263891bde7ae77afc0ac02ed8bafc63632269000aeaa3cb7532329c79bdd1c7e7fafea87308b93cf6c8a0a6e12cfb1b203d9f1f2d0e0e92aa28963c71165db6d3ecc402854ac4a04a8f44742a3358be7a607a2563c8fb9efa4f997f973a2b2b35883390342365e73c38684e8abc3a60a273c8e2ce28d9f5c67a85533b47646827cdf8ee69ba3a48dc1936d5394c11359a5c889dcc42d3a91c5f682ace28e52da16daa91bf1809c775cb07fb64040ca5f57e0906d75fdf2089bbda84ff4b8c8d2b59676c634245e9c7a92dc3e61e34ac002aed0c3b6a48bbf37d54d47f0125989b8e37e2cd1b756c2aaea6341528e1f4c3f01613badba3c679964ee0700dfb38632e3ed4b0131d8fdc24218c26f8ac7f8d576480400436743d36d44c93b47f19ca312b0ae24aec0f408e097834f4db57d5085ba6d643fbee829e4889ff97dfb2e5d00630f516413a000d21bf8add1d2037f3f6aac71338e66d88d16bf507ef31c8cd0e92ed403e184d838f29c9fc7b10aacb8ad2f7dd8d971bb7b226b083a7239807bbeb0f89be45711d0400ebeae1c95933622e05180e3ea4856ba97eec74ce850be52dc43c48121926ead6ec65e3a92c06fa1258cd18abfbe200cdda481d366d45f4f041b515b75cfc652efb03da3eb36a57a8b48f328493a1a650277c3fcea10a0c5d84831f468d0fe551611a1d357972e7bda29779df4fc50a72cb456af294b72e57b5ff0c96aa0bcc001abe222205d4c815119ddd7c7f2877187046a11a43737100cfc7477edbdbdd69af1fa10cfffd393f1526d672f01089e170a1b3a06d8ca2307707f216f3e7ebaa37c421af061f5ec39991dadce5b427cea9f72fed838055d3493c910d24498f9c56aa2aa0a60ef3a3d714f790a9988dbcb1636a28c3ce2545d3d58b85a59a647f1e286756d6d5cd53da055b3a8f7127536bbab7e7e3c912a68d4a318134fd13eedeba4710c258125f2af700a3854226d19c9dbc76b94a428e9368d738566168bdb152712565e1b94c201e45f64b9a5b65c9984f2426dc94f2f491461b9983f19320a17f4ac2e932236fd3d428fe870cd0ded1a705a25bd4572a114645624cfa21c32d357234de25fa317e05d615ed9546a9294f209900724f021aca3517df84bc6689b92fc5c9ee5e6c3d046e2b8175e3529d38ee25e0f64a503f14784fb523d7dc8e4b6c9cfa68d220b334e2d39f6d12b5fdaa94139918d46d7b8d919aac3f28d888a77b6b7d3d259cdf2e8fa435bc7936594f7cd7e2b5b6373aa48f03b8bb39f3451f3ad90a3f64b452ae91385462cb64f03e4dfd80459a34dda77852f860e0da9b8e3caae6f660e7c330ce13782c5e61f0bd3921104aa81ec002104f672c0b2d4db3c1d696c806a02920e848e61e5183981f3b404aeefba5700271d73a08824190cace968ac3c59cddc8fca4b38f0c1280677a706d3d83b297258830d67c80003b27114424f093e77638881b6b0c88e9e41235655eab9a1679e461de6f1be30691bd3abbb814d9c15a989ae592692db86171b3398139f9bb85628691d5d61b14c06b2dceb6f42109238fd5da0fc773aecfd39275fc7d5bed45b0f762d4ddd09d01224d4e30cd1283cbf2f7667a0e74546b9b68c2a8d3e35cd35367897813c19e8cffe942155f9f876e1485ba0ffb852d77dbf25cab6f738d5024d1cf6f234c24411fc8104238b816818a71a96d65f246768a4db11086c18040a18059aa12341f114419b3e332e34f4e556143f1d37d823586eda90600159257120aa63115ba1fd67703f02267bce9f8a28127efad5e90ed57fa9718fc34e8e864ceb79ef0fb3210882a4ac50545daaafb65c7b2207d2187eec4498e99acd06789448e560720766195e3876ead0a95f06f732586e84b6aba5608e750afd2eb5a23accf9563cfa78b532eb76a1d206be06e4786b36aa3c0db9ad7a75bc9835a38f084ad29e7e9051a4ac16b07e3a89c9b199215905f96300245e5294ca6b53e490e2c39d13e3ef245c8a7741cd75028372189d29d08ceb45027896b2a4dd1459d67c56222552b9d499739968d7c54fc0e0b927db3b88fce6c2b09ed3baa48f9a570019c5884383558654f6f3dc56396ad59e8c7459da80fe4c8e5e9b23f361d9a8f4c718f13f5dd5356c0824ddb07413ca34d45df221cefbbd8709c5c484b01f66b224ddab46163ebe24c0d2a2715b4f6d0b59aaa4ab94d2c3492ef2595aa65a3220613dcab9113798e0ff6c0b42189748f1f3efd2f2a91dd6da8dc3eda9ecccc4005c7bc73b8cdbddc81638bf858e7cbd2b9fdaba587e35eea0cf29f89cec21f279ebcbdf0e181f1eb8f3fc1de55704b349ced94a65f47be9480d16b4cc7f828e6cbe8f4a399ac64118410f6f8022d377d386ee54f0b792927d09fcf61cd9ac7631592e9bdbf69c6cd6768d2e47fe5c2b44cf7fcab653811c6fd6ecf503f8f8f3e5e4c663b93c16358ca5fbfa4e67035c7cfc2eb210f15a3dd84e730c2abbad9a661d2f71d56b9b813c571ae98bac4c92002d8623ec14035e38c3ad3ccc88e2aa3c07e84c57f3602fe495b0ce5ae1e1426a6b5867c8de2b2fe3653f2228ad16ed79d0bea676b9ed6336fb71a0a160cc982322337bbf2f84eac1fcee5b514470d7b4613672d2b69264f4ec6d05157fbad74bda6e9438e14367d9b7d974ea6bf1653980a27c167d005d3118644db93a93a8b724cf60889ba2da6aff716de963a45a49cf88d45480c34ff748608845b04647704afb82704c85bf259a1ac0358ed0e62651840c6ee533fb67bb5d3f251917e9528c0819b256351db2be235621290fdfacb7bc4998e00c68da0f8364f9e751a9b76c2da370ce76b53dcee4182f4bb583e387a6fee0c72c128f643fd4ac4899e8048afe5fea42b3a72b4bdd4d787907b96d926f7b79986193c1d9983a174f3bfa8b93ccd1f034fd7ffc63ad4a77826b9fd1d4117e3801836d2f7aa58ea90d69893e962d4245c0b8deb76a5ff1c15b7e1a556e5c6f3b29b44a0ed9b9a01603d2f973ed2c3657449ff6be30c43ef0c6853b3ecaef92afee99262b87785870e87d7c7503f6bccfca469700b46f1bd719865cd5bba19aa8a32813af24d96b30658c7d28d94eb88ae6e0df06d0a681d4c5b960375441e63230bf89676118789021e6e24aa049e835775e59865684ed56bd73f53d7b49771dec1a8ada5b70c9bfac61a5bb64ca2bee6e89cde90f13a756d94eecfff7d32f2418286ff5018ceb0d24caac80b13590a4a61194ee3189aac754cfda64e675578ddbd6ca966efb1e016db9602c8a3e3df07529ac8f32a11e9e1c535baca5b4283a3e77a522e4da32c531097b703a0b4d5abd0996855df9f07f6f276a7a8f34f7193da9fbf994eb69247ae928e0bad6ccb082f0f3ea71b2d5e833f652be827bd65b7edee99f56131fd2da5d8c54db093a0cf344036280e3c3c0e9e4937eef74e4d655100f8ecfd7bd95fe2e17d0119d7a445dc5e62cc4927d9a7909a95b380b2f64c827e0c851d094619e222c19e00d78b485faa9faaae56c03e2c358750b4bdc0a7f0e0f00bfecf9e7085c9653062bcf8b5a99897a8af152863f65961cd875ea93168fc799f46a94b16cb0d5ec3f0ac42577f5c56b9690f44aa293d6586208aa34d98e94d052fee039ca9fdc9b3a4202caed577938e16be6d760ea129ca821a837a766551aabceddd0ad260b96d2f33cb7b4dd718a534d52c5d19321cd2abe62f3fe7121172afd85230a500ab8ca5e25963ca761b1d45dd0436573d7b48c2b40f6aee4cabdd7c5e51167d987aff62821611340af8e07680fca301ddefa7125ea6e2c94028304a9025c48bf68f8d84b149337614bd58ad0dd602d000637571b90ecdd104d96ebaff144d48d123cc52c84f6f087bb17f5f53149bf799b648b6645603a973af622e1395cce7fc436f25ef5e0c175461bbb9671a724a41c64aeda5a7083f08ebbcec98465a66be7a82a716a872142b9a617e59e121e69cf98dd734ed675825f665c85c6f5d683329fa8709c0d668bace275dc585708cf4c43406d58d312010118dd3bb253df60b082b4460eef5e00b8c0631a001659d39e2f9721348a3b83c96472c408ada3b89cef5309f8de5217bad1a4edf20c8b2dbf7e916057abe309e94c84f2924a370801c224e534505b4c07ef33ecb37aca6e56920728a01bbf51314f2b1db983e029a8ed3ba471ecaebe0fcf4f929017ec7932aa256bb65a9de05cb68a6a08e31dba5d36cd0a8f73cdf04393fb560598c4e4b04265a1b9a781a3c56ee8781569763488ee7a2067deee0e381f65aa45235b66015a9398f45913184f8d045bb48723b1bc516ecf985f73b0798ebb12e852afd0dae49485d27ba6975803ec69674c753aed3bc42edcd8fe587d608e3a84518431fef915e1d524b4153a59c7af3824040f0a3654afe4dce86c06d40f9d3587d5178cddf073f99c98e70bc9a78df24bc93a9b2ec0a058eabf8876ea46271618e66e95a09bfc2806f75a585fabe4e60842f4942d7c683fdd0bc9994b7710db14c20da830fd4790c193e9ad1689a06366425c3394cb4b1ce4191c2585281be6ce24e7846dcf190520c643d9d8e81b87f57cde432500035455f661e954a42de9988c889c64da3f1c2397b28f0a7e06c4e17601011f1329ff525f5aa0c589291925fb8e5e14f22c24c41db3e83e98c533ff147726da955e208e69920dcc95db722f58b6139e8d031a2457c1a63a961b0b8dd8690adccf64976a345f9f608249846c4bceafea27862375b1b9c714e3e10771fd796e1f0ca097fc13531074198dbb37d460657ea8cf1d38754d48ef1408eda89637f53877b032178b5f1bb496c01dd7008490ed0214c0c09ab429c06c4886c8add10674e48363b015d02228b290f19f5bd6b726ba8b28244a6718f94e6c66870dbf4e837e48ce4f8ef28effe9e25600da1c01951031b4e4d19958f770d3e6031f4a6b4a41036340049e2c0e4d92a705239947fccaef429b29e9970ee6f1503e546d68b69e9c2637fe45bef357fcc24f3e4a0d72c72747d1009e718dba39b60539ccf876b444725a85c644d3e74e2997c73515cd9a132ddf809320809f9e149f09805b672b91397757ccbb904971ae4afada06c99f436c0b5de11d9d4e0c1f03d37b49c3b0d2303a73f9e24fd2049d7607648d7ccdfb75e86dd2653f242c705b9c306cb32983e0b48944461cf4e071f83ce6640a89e037954f0d09462ab7005240a7fd0b7307f0ccc81e74ad7b5b94d1b9dd747cfa7afcf6a149d8ef9a0b9d7c4cfc578f8909ecfe78e34d4e984289bdbc88313d8caa2e1ad4cdf0f414dc60a64ca2365b7198e617072e9268ff3dee92ba0549c94d06190638e1e671a3b883bea407f8ff3a0ae7be7e97b2c34db455d30af8b02540c05d969ef5deb364769d316c696fc7bc3166d9f6b8e74e9212d7ccc2d6e8ea89b7ebd69a8061e9079abfc98ecfaa43c2dd0bdcb1b6ad0ca960bea62fc5da9570a7175d0fbc6d74ba0246c461c1c27a7c1b640020af9e448b99a1873ff072c85c033d4ddce465665a335f62f81ae0be9b7e8cee7723bb67eb12025aa492154d763555807d3db12f36926561ac720668e95ca04bf370dac2fe1f3950ec9341e69ca1507f70d242f1b25fe31505263a3a96d9a652a39a639f9f580f5dd99ac78e2c2c3867c06f76f2dbab506ef9b89f24658f7a04a5d7e7f505b12b925a3241bc34d6d32636b8fa7f756b834d2a4d190c0b0b74bbcac86c798708496afed9d10a1b85a650229b892a024bc38503683222300f68c2ad162b6fe5140117e33f94fdb1db3804cf88301aea962258deb0c8aaef56c9f2998184d1b659a2fd2a24a037e2718e9812bc1a39da9f413e7a35deb2d72f2282e2183c1c0c78249a0660cba8d5b1ada9992fd350c247fb000cf0ad452c3af4c702cd09eb6f7d36f6bc5599c3717157732b9224859323a520f1d8ca3df9c6fd7140d8e052b42c84f0563d6996f7182ba3bf08315ab5cf479dd8cf4a83b239a7a2ef8e5f83985c631b03738c7ddcc0e9ffb514e49b480aa8096aebf0c7dbead744bbf335836ae2efe0dcc596502f62e3ed47cb0bf9231dc38f624ec2ec61f3c7d4695a3847c098d40b042e065f2d49f5ca92a3a22ccd744d6b1bcf49901787f39cdd4cb7d9724cb8156f4805a9f5255f6fc6058a47a065c60fa06168c87ef2f236a039ce5e6403bb27ba2e448701d65abfb07cd6ecbd5c5c82fdb8670be10a51695fe1ab5ab3e8909690f5f0994c463d26bef4b98724624088201d342ea4e8b2db42a01f976406aeebfdd00e3a53383f20da694275370009fa78f8e8bbe505e152f5019d884e65459920d0cd81960976222cee0db5e659b2a1ab5da1d24bc804b8120f6348859cdb9e18c615dd87dcf2d6adad1be86d03046e1652304b90097fd9d937c249e2c15a7f965ca51ceb7b7833cb1a0d5fb02465a552717901cc53bcabc049db435d4e6066473a4c1dc0b75e770130259df3eb24f5c017aa56436ed64c44f8daec2dc3dbea67e2d1aa98019089bd7cd8d9b5f5426cb4efb388bb34c37d7dba474b46ffaba961b121160148017e5ba91e65750d1e3b79cd772a9c0352a5a2b988e4a214294e847c693093cda3288f3e02ec52df71b470f8f363afa6c1a7e600e4d3351cad059ef56f5041129dd6a7ce7f9ed980b8929ba21e22c4ca1c5c56ffcc8e7b8c1fc0a32361ab4a151f570507c2246c6a678c61aa5f3e013a283889a2ac14624b3cbed54bba0a0d518c5257d0d8bcc0fcc7e566e7ac4bb86cf48f88f60db5024a26b5f898bfc74ccc6d763cd2b430277cc3efffde349f8d9e3441da9fc3237652cdbd0ab457d40816ff2753d0268570a60f1702012aa1a676524283db140bf43e5ce3aa2d2b0c4eda42babfa6f3dc1f3fe2e6a1aea7f46ff57c52bdb73b33504a5371c8d18777cab6bb67b925abaf50b6e631b6f446246269e9bfd7c90472210bf2a1da0dd7688636cec296b677bad73409acb4998520ab697a5291fea814bb0dbae748231a0b028e1831e86358f55263aa39c5ad412d49d815fbabc6957085c99c5e9aa851a0cfdd2842855957e98d5dcfdf846c3b23038d95d3dd14b5ee853a1f765a735d6cdb7203e844f92e3bd6ee10e6cdf2a7a89fb81974bd23741120dd0ec823714f2bb204b64d839b45e731c9049ba6d30bf0ff970f45bc6da315139b430159c0e3479566290453eaff510012afa04e9d7809fb79b135493963e128ff3e9bd497a160e00bda5b029e746b1891ae740149bf3a27f51f576a467520a3ea0558f05cb73f220860a49b45f385e946c05e43ca25ce20d3771a1b36b081b7c061739c20d73f70826134c0bc6d92e43fb45e19d0eee65f4c80ad42d075ec80fdff3b81b762cb18766dcfe913c544d4c747a981b43e2e9d04d174171a24ba4d0e89151163dba4017f38fa22be2d84d88d2d77d7838984f9293d351b3c373e7159d6f3015783cbe36f1f289248243dc15f3a313b93adff7cffe4076059478c2b5acc118d8b9aad845e9af913a9dfead3824c2eec54d38b24d4c939cd7d6beb0aa4fb66bb60e6c0b3ab49b58a0f47d8f4a8cda4f052a3397ddd87df024d83cae956ab3c3f6a98671b3831f914bc1c41896d9d3edce3aaee08f3f1f92bbb44be7174364e7ee4f5812fb89ce89c171522c0594890c1c0fe933875b3f3386ef35a57d38f04bc89a4ecbd8840d6cc0bf6b696c8df7469e893e2d9cd27659082ddfe211c4a5658c47167a8717051d1c83f6432dc7cd15aaa99e54c2ea4cef8203c5ae679890277f09488a1cba4f9a31e9c663d5588817d0e259e040648c957996b26c576f8b1f45815456edec1de57a75f9371824caa7a55b08ca5e90b30ea9bdc2519179140705a64f2ea00a8070c8ef1bc418b7361a3f381540e354da14cc6a451d219578315a8df0b2f0096f78a72e2defacef3184ce5c7c1379b7ae69c8a9f8ad008dd04aa63091e7639a862f5a91a4c7db6bcfd12393f496614b9b4061008b3cb5c7b915dd882a9f8aa5890f455f95a342545562b90786afa9c936e0fa19b775c3379a5e0e37a03a2f99e512bc37772d71ac3885d611cf7ea6937afef8012301b961100ce68c47fa8f23164dac4f33899efb88e44142e924b3bbf180e8a7f3ee0fce871984167a119e2fcfd6fbfc4bebfe9b41705ab3c50235f03e8e2c72bc1f21d1db99ac9ad5344a3144b0908d7fd3d5eb818b288be9a7495c524563b67e7cfab3cd6e2679310f8cdf4242b5099815ffe31acbfdc16887706da1f85b7a1509e10f44e531495d76f1cf61d0b84ead909920ca9c082d5e5849e61613c98f4c51389ce1901abd39dd7a240d6d5abdbf2b6f359dd4d581064590636563cdc786559eee8462463512ea6cc6a65bd7fda3647fe7cd704c3d616dbc3ad2c43ea9b4d498902da224e4e3c61b846a3d5bc2d58f2a039d09c7a682d6dade5a6df43085a89108a70727fc14218200b6930a9442234a26efe711b7b6a26217d3b5034b6064c765f73be3a11d853a4c936faf222e4871085fb503f518361ec31f021c1d814cd16b87755e1e71a318c8d6faf1e7cc4cae15d39fb7ad830a5f3c094c32b46e8cfe5f9b9c2bd3ee2dec3a12361477e5255e39a51f1d3e3a8db4731ac5ea60a4854c57fb81a4c15552a83d4564795279f365e51852b9759da516ec3b83dc71ce5703127b467421bbd4f1c7fce28c17575ff1316c8e5ecb6d2022222050a6c99db0ac08b984999ea5fed0d66f80c6d49add0859cf0a07ee5083b36e7b77835b7191a7494a9159d34cb805f4178fecd9184f3d9193278b1c42fc68fdaacdfbc5da70629a5f4843608320b2d0101458a0a079622f47a6dfe0856f0fd350a051f97d13b138c534939af86a1a1092ace6bd8ce575ea82c1679f1a53aace5a6979a9c475c0242f47e7eed6cb2d775c6d7827d9da1169677daa09290ce5e69b2778d48771cad11082db810cecfd913d777e7344ee38c6f49ce7dfaa061eb86748632966eb2f6ebf600c9478f3d1844c706a1036de01ef195110479d2e142f4a9587c975834fed7cf4c4bc7df0cfbd4bd67dc5f2fb3eb186f231858b90d3999e77ab29c2f43bdb18a30c330e461ddd596de4c8e73b3f8828ee0e693ff3761d850106a7ab1adc7e1f11027b20fa51f40dec777cf7011728c1c5709c7ba65e2a94fcc2478aadf1a48fda59c27f15270901360b127020ec626d3102fd14bee8c7981846e478b7cbef733c2090198f9f1fedd0770c1d3440c5346a7c26ff61883aea23dbdf963bea8a4bb8bdddb0d7fd0d65bbc66d181f14c340bca6b54053cf35fc5f8b24250e50fb246595a21c2a872437f14ff48741de4a8f69b3e68c8c65e5b01d2e1aed576c8abd966e94f69191b0a0691c8d17555ed639e341a1748df78aea404560728bb566bcbe66b803547bf60197a3d1a6cd91fbb9902aa70a3a4492e56c3e2020a160bec7a5c1590bc2a9a38475819b638c39c18ab8348a3b75b05b8030ff2b7591085f2ed51d463f54a42d2b604299bdb4187644eae69da46516af1ddbc035d729897eaf0fe8e621d7b098ca71dfb97f1855f9309057539291b1786d6b9a8b2be3f48fc4952113bdc41ac5d14156793798a9e302e5d17794984c335fe305a2abf49bdfe8b4713048289d82cc44881b8613f084c0cdebdeddea84163a3f50424337b2966e94aff56d43272dc8b53c5048414240aadefabee92eb8f96cd2416a379d666eabb0a06ffd94177b92655ab7cbedcc3ebd4a70935e234583642ff771fb396d22890cd3e5031b6a4977bc0c35dfbd45c29c496560d0d9a3407fc5ec03abbcca075c23db6655920e62ca89628c6e02fe6a7c3592a0785707b5620f7c41c5cf8bdcfdb65b2a008f8c22bc513d0b04b80a8c81d8c69882e00ce467dc9a554872ccaad0c43b51eeee24bd26c149e7e3f60665be11ef587c6f1c6f363be375ce871c31a7ea5717e9aaf2e445bee933ba2d6b4c214a19016ffcc2c106629f4fb6cab777e2a81c2e36e71f247f18616ab3430d3add82b5fcc5c652305e45a41d2e53e9896adc83fb0319d23ece5a3a91b9c3dff51102653fccd5e24831851a837a383a54b8c60b708ba560dd20730ed8e4c8f6e5c571a63d3ed661fdcacefc0bdc91a631a8118b619a16bf9ac0b9a3b5eeaf21ee08ee89ebf19af6b0aa2dcc02769e6fb7852b16101e4cc21aef14b3b5e508c93cf7195a17bfc4d9de72b584782279af86386985d199722815a382fe7a3ad96e99a1e7274cb223ed001e0252431b0dc9fda5c7f1515c036bca1d55e3a5ed7c211f439c5f6a91d2dcbd558523f570855aac40c7f30ff8512865e27761619259fcbdd7e27853e063ed5267c0d095466b43ad6ed97b6ebc4ed926d69ef9afa20cae9860db5d8a5e2dd0f2aeaeea0e6b5deecb49fb2c6f9641b6ad8c1680dd6f560a114f1fc9524806b8ba1c69addcd7b401cea57f89bd93aa1d6cb6314933cac2cbc257ae5f57572a522ab5cb4f45708d506300303667b4a3fc1c2e52f8d6981c1745ee50b665a41b124084c2df6fce9fdf51fe108bfc334e4379c2bedb2216c9e4024a3415e57fc88c4ece6851c621970ade216d1f45dcf1b8c6761aab67ad4d7ebd9ce37faf7bc9343e0131c5f137a070eba5c73e0fbe7560ac5c5d92adc0025e65864e552c58243cbe4a34cbc935deb8fbec2e5bb68f98d74361c6c3c91e8520c2189e20e0900d57c5f7b2d4110106e9b7c0bd502309d8a868483487e270f5d2fbf7de3c0c3f8b3ca98136978c11dd49d3358e0f07607cf198a4c6be7586f56601e1a550c2f53bd36a6a5786c69d8271de38de3cf0920b608400a94e43475219b196fda14f86f4f6e37bce6854295ac17f6f2b00df8bad8c540e857ab4d783e267d6f041dd50c5b6d4c704e5351db816b782daefbe0a953d7c84f4421685db9fc2ec050e214cf6b1cf085477fc65623ef5f7fc2e30440f3a76ae928464e79c5b9e948a060d7958905f4c5c5a15bc69ff4be77c5610d9a14a07c4c53b40170b33bbc76f574771e192ff24c04ccb36755dd07f62886dadcfcb3857465f63e4628581ab200c82bba80dd07cfbb51bf1a04583fbcd1828b65609b334e1bd28272854c466a5fb60cff330429855807caea9d16a00d7fb5a52b4f6561164a0ca6e208ea3b97ebb7e6653667ac057e3891bc987f2a830807b69758014c71fa141df3b46c40277ac51fc1d791a9c1a16e18a6a275df48c46752f6eb8d47f3bd14708d3e7ef7b5573951160739f6d9748de2af5d714e40db5bc3e62b4dd4d9a123dc68474ef054dc56255595ddd41edf144832cb0d097d4831451adbdbe796af1d23d3ec0aaa5f33b547bd398d29483f1102f93c3b64149671e9cf594ec9826d10fc625d529f965757ba6934f2f15caff7638480ca91647123ec17568710ab5009cf477eb0cdeafc06dfdbd710e857deecbe0524510501a0271c3630a6638689a3d8f6d90e427453baf51a129f72031aaa1a9b0cb9c8db47f8a8d656e5536ebe188d4d2e459dd99c355119f64f6ec0e6c4570b6f919884daa12a514fb253fa8e5ae8637ad03abd5f37e90d74bd722d1722c0aa6bcf464e11be92b821a38f81d105ce75deb6375420d4ced3338f75a2fad68eb2a885b2bc02f3cbbc5236cceb678dddfe8ed46f0cc7c4b8242f5b4c6deb9ccff6e9cbd8028fef80ed85e3b0473a2dbda72935d572780326493b4f12f68071f2c08efce97d14f3d650bcd6eea351c50ad09dca7c9528d7695cbbd0843f529af70b6069b527f33c4a6ec6346b9028a7893de2e83be89c69570654b0c3447b88d8cde172a215c0a74b5220937ff35d0fdea5b8cf0099dfc2aa6a20b0cbb083e525ddcb81f5952fcf85ee03e0be92e51f049606a4479cf273cfd1ac2283dd16d2eca80f777aad3d685c53f9ab89d36aeb9f0ac734384f324b4b183b312ce65995c263e30c9cfa0c97090569d3ec93292871696546ea59af27c0512fe138afc1ea61bb2ef2ab5decb348216c2a45f43a3baf1a3527492fa9782db328940cb23f1954fb772da092f804568609ead85532152a7ad887d250f07beb5388fb8896a114048d87cb183672a2e2c0e1c16bd8a091e46096c265c5ba5c8ec2d6d5fba6bfb47ab0c0bcbc091f0a17321cfc2622ca762c047c130460eaecf18af7ad10a9fcbc0cff36c2a5d880f0fcd2fe671c9bb92c4c184f6bb5709fd370352b3daeb3fb068c3e94de772574ce50a3f0130c1f54f6a6d5a24ea0c409da07b24dce9c5a37ea76ee36d016f9480c4d5f4df7e9fb7393f8116fd619841d1d85416ef48c81662726c822e12ec37edf619d99002f9288bb3e0821f8eb88ec3ac17404d520f47c2e6d33c406d0ae7da6a1f6a568bd0bd40d9f0632a3dab3dc0045eeac33ddbd16343312526694d6668cd527d2ec40215a2a9c81f9d171b1894e963d56c190f611dabd0dc4e4639204d702acab3be86f93ab5600543b142cfbe55dfc7d0fc2237181325150bfc58a31b9ab897ec9dffa78f58e1f74d06797fdb070973fb3ecb5b7b214a2b4d1fe26bdf8659b6e0f0aff98b75d7f14cbe5c4334557660b6950a339dc4a4718dfa6d6c48ba3db807716a7a58c1f360742c71735155a1387d7a224286d302b0ea64eee3921535d9503d0709a058538e92c2f5fcb899061a765384a6b89dde0913b51fccf819050b29c8b17e629af9d9dbeaba2b2e6d5b083f8ab0ae7a354017174b473fd436c16172dfc7a39bae7a2e8a6c12c6f6fbc4752c82ccb9e71ccd53ee70d53789e54d9e44468608580723b990094947d097fa2fdfe53a6a5e260807333691f04c9af677048d3ba000773357544ff5025e7407d6665ed0a7a87f860afbb0e6ad1aad2f69b727248db2f7618a8b94a5e76275382895548c808fbeada909aa7b809591813cc3b4eb7b1d46dcff7093223c3b4d6e44174b185a33342c72b1c1a94f8d92a7571deed9f1e7963d9d576991959a320208788428ba4b5665ba8423715755dc1a974fcde579721bbcb11f80d6735025a8fd00d97c6ac3b9df6369ce29fd528c0e1007082c8f3f6e812c62a6784fd4114e1f2f2655884c86d4663e605d29318ca6e24b206d2237d318a746cd1e00a31f840a7ec2fbf46b0348a5c67026897f2160c215ab9229376ea84920b4554e3873e1be997b4cc74240ba912f443994a2ed6f1d32e29d9375b4f2d7571ecb72d1fd48aa25c808d71edf417c28efb5a15bb7ef55e86ba1deee94ff092a2df6eea9402807368a2fe826036c13296152dcf1dfea973f850fdfbc3e0c89530009f8de93ee0c447cb8f28c7d8f146cd2b63913dbda912c390776013f9e2a538e2e8c655fa24ccd86dc932ebf7d861d59fd4f4f5c7c9b10fcd03a2409c1730fb35977f7ac0e9ba583d83cb6a3cb80ae0826bf2aa9ce9e71a4eaaabad48cf19e8c029e86ad6f9ae307fc314549e57974021368b7d3a0d1a4baf663443a11be8e0c9dc1b72e35368d3427645053e14d530cde6966ba2a55d8a4fd3020092bfc1c60160ac18e4dd8508805566357df48e7ea03f5ad1fa8a97c18480305032cdacc9eacd7240c7c96caf31e5e3785db853a21047ab59461d4a624865e00da8e04eaa81178bb82cded6cb6e917c31101195b54f32e310c408bf4b8e59482d0bc3d2c061978ed5e9e943fef21c33c61e89555f896f658e62bf9d45467c92fdca0202e04d10829bec0cc490fc22491e9233344958daf855fa98d7c64efd928284bf0f1b2a5b2864aaa3acfdaa464cd119011867028ebbdd71bbb981364fba691682bf49ea8321db940ccc9f9a682130251b62d164f07ab46e348522ade06628ded422c7afe1bdaee88d5cd89fb31e394f2d684eef5db4b982f8f0b95f0db8202d0d2aa758585a86e976595f19b7ca2a3f7ed5f365c2887f657face896e78e60131d53694dfca85298c5b6b238e7596d16c30598b39d63d429876ad61532ccd1ff744699bf904fb1425dd285665fc42c983e9de44dc792aee0aca3cc62fd385b1e91a366128c4d3129e8e1f2e2541a634a209f02238db1dd6b152aee2681434f7e461607c1772645dbd85639edb823753628162cce42afd867fcc8c2737196de9522017873c0e286874b984916c75ac571d68f5f29f9fd63c7ddf62bacbb48c505d2a26bc26a600782d3ddc6990fcd0500856dcfd0d331c2bf4b33c6aad83bac9dde97eb5e63e1033ddb4ced46e07d4fa8b8efeb5ed9b6194807732c389882863cf9469486a9f8381bb4dae5f3a7dba401b9e48294668fa949b2aff1d063f570544e95a608760f253d8a7ba3aa23f2320d0eaf2a37088df027107b8e655c2545d89fe270655d7fb32dc903d689e383653430e51b1336553cc1f81ee97f4bac2687f293996164e12d2741c2e7d4c1c40b78c7e68129b1514a19ba0251923546986edab6bf406685cf23c7c50bb93c9bbb5a8cf250f7c96c49f0e3355f7ec64d96517feaf352908a1798b6ca521eddfcc5df79bda34b72a143eafb7fb8730fc2b1271618f112473968d6d58a660d5ca03423783a8bdd7af03a02cdbcd93784b34f0d4c5b792c9cbb0537ecda4de6eab065d6de13bfda5fa77a46f5e1c760254b96d0e6c0785b78b1bb343256c522f3af29248174dbaae6795123639eea0198affe9dee46a30fec194ba086b33110dc788d08606dc262ed654fb7103b7063425c49dbea5cc6c07e933d0b3266216cbe8240f225d3ab75937112a70f4574512c3123bb87aae1ecfe2495cd49b3ad22490217fd2d3abeb1e14033198569e039a8fcdd8da5f3b54528de993fd4b43a3badb4755ed933879df362416f72ce9899cd7fa5b41d65fe2a6e03ae7c42e7c3e44284d44a48ab884021497009a442e42de392d576643eb6edd666f12d10ed20ca9af019fd67d65e349343f8ed8c897f04b11cb6f2725bae8fc80d2150b1fb9deddf59e167cd78ae456e9db8b9a76db99070e7561df739cc6644e910139aa2a541f36586d464f08d7d453db6822d90c0a2bfc3d4840417b4381cfab4351ee9417ff010cb2a26f778389715cc621ca931e8adc26cb0055a8bed60e857a2d5525a75dac52f359c7c9e54c587f7bc8a09b19077449612fafd0bcf1105eec58779b6f33b56c5a0853749842ac572148cae933c9a0dd2a4444d301ee8dd49cc0d436ce7b458b4ca54ca978ed3277f400aa1af5d922f49d05c635b1526b8f1aefe900b07e8c0925696ed58d71baa2228dfef6edcc4bebac84267cf66a80cb9fb198f2a0f4c88b410e45c73bf52a92cfcacd558815979adc9229922ccab9c717ca4fdc5b9f545de546fc57c4f4ff76885747981b08b9ea9c75f87829c95dafc13baca1cf270185a090c6348b3f2bcfad7023b513dd22e1fdd026d1306067a0d7cd2b240bb34eb7d6411255fba2a6f1090769e6252375753a8223c42fb1d597b85a3d1a798f7033a6a5a834944c567b6056c6e68053bfad88acf43bc57a9fa3717da1d0528aa1fd3636faf9fb279024a70ec70f529ccf67b96e179b698d07addd13c4497a0ca30f09e5caee706fbe23e7bc2423816c235447a01ec8cb6f9f23e46e36e6d7a4312769d58101e4727e2703bb6f9e6a158478140d1c894528b4bcd701e94902b490d77f0e163e190b48b00799e7a57c69472e293b6ed4b1c577254202e8949e8f63c10e02c38c0a0c6cc9d6835f7e26a06b3f08c0184be92f4f27ea7a853b536726566901c7ed719134e951c8a1fba00191f67f0beab7d9c2098bc2f2b8b77c7c1197dd0f10552cdda64e5b9f1d2fb313fe13989be5940f54ddcf85a1c5921328c610a805c4c07b9185f7e2c2c9407eae81964ed34c757a42ce0d97c26509b949ebf72c57c577662443feb4eedc0aa99b782ddaf2df9dca07c6e18fd6bbdc55b8cdfc4e7d5a72580181ad90735fd11e8e19b14ea3f67a61b3193c2bb2a9550c6ea1285e7c930dc9d486d5571e77e08dc6a974a61a9928cd2b678990903ad471cd6cfc4fb9f56eac86f96cc6810ab10ed2f559666843a76b7136e9301df763f2749e5044b3e089efe9bd8f8f844a6b6a58ef97f6eb3c3fa977f91902848c938222dea519391d21c5e82ac560819a50ab854a789a2fb0e1c44c3815190ba8ec3279d06985e486d7c049eb98f7a9a0506b1e58304c0d3ceccd6e9e24354e3d56a30aa2e931d659510ec87ff41b3a3cb855b35aa2a9aebd4013b84ee92244a1ca88a0d423954faf07e99cfe6b6f47c7c47d7116c214a6dd3701b1d73c0ccb9720eb44cbdd89168aefd4954eb4d148a74bcadaeba23bf3b1782259414b5c480bfb9a03db1049e1cc8f8547a589444a671c12f126fe386f8871f83fc60dad579b4cb6d8736e22b8b7699291fb37e17ab391383027e240cb0489229c2f78e0caec870d4ec7adceb7a3483ae5ce20dfec8b4e5a3080f6915117fbe3d7233f5d5964dc86d44a8a0e75e3c49c8f2de7b1b8645cb1955ead50e1717abb86f31cc1a933dbe507273e8c3b4be07d65eda312121d8cfcdf0061c065d47b6fc212c98a09b5efc831ed7dd3576dc0497878827c33a186c8ab8fbd9834a4d5e24b90cc45fc715a0c86f8d44e49586f5e9306b3b529db13db6e49d4ad4e8277ad3debd2886a2e95a633974bc7bb7dca0bc00b9c1501828c8ebf38e894092d90cff7b4e74ab31f82ec1c2f1139a7a004264bfff7d79599f3ed2a0759a7f343058c14b4411a72024035683c667bbb3cf610902b9ad6037dbc06cf6beb06807567e0676aaf936012e5770733ef35a773c60303a7a35c6f97c10ddf4208e76d4a962e576506154d1d431f63fdb0d0490ec84eab54e13653ed40c75a696228a4db7c6ddcd3b7e4b8d630020e2dc02ac7f890c8f9f448df53972dbc2fc5f06ddbcb9a3676c842bf7df1ccb16b06ac4ddfb493d023bb80ceaa44c7eec97429fe5166a5e49509a2334c4f2298d847e4d0c37c82495bcc4e0467d5f7882d94c1660550456b03fe67f503e00c88843faff6440046e8dafe98bb5051496ef5af41b76c","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"666125d2285f1dab0f009ee7052c866f"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
