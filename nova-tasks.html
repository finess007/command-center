<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }

            @media screen and (-webkit-min-device-pixel-ratio: 0) {
                .staticrypt-form input[type="password"],
                input[type="text"] {
                    font-size: 16px;
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="Show password"
                                title="Show password"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
            const templateError = "Bad password!",
                templateToggleAltShow = "Show password",
                templateToggleAltHide = "Hide password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"52526164953f0a130f3f0593252e3cca35b9d7a23d29b32646d01ab188587583280c18f4890738368adade2a914a1dc1471946d38dfcb27916f39e145304210cc804c5df543b12614abfc41ae9ce469a83943f14244d5964b6f1d92d6c6943b49cb0d50774a1811b1bcb60b53ff0d744c02d05ccaf280d4419c154250f6eb30963d81e6ae6bb0a4ffa5a0f80998003eb95c4a78e6d52b083ea1a775a5dec2763ef86f33d9243721b19ac3cb58a4ca4a61cdeff12802a6d390145e64980da7f27190756693cb7b74f47f2fba10f61a7842d5d98390272e34dcb36a5de856924cba49912da6b8fc2dfe0a3c2beaa79bc79829689a7ba4f42c04f840a6ea160e4ac82b86cb45084d9b3063dae89d8dd70b95388e95799511678982a2c8e4a3c3d95fb2d507ad0ff1bad7b3844431688a306029999edcdb76ef575a9bf5756fc845f8a107de78dc10704f338960616c20b3b6ce1935a723fb2a9b3bc34ba08ebf62c29e95f8647ed9ded33ab9cccf62cd8574ffaeced78b9363e208c3c45a35c19faf657a3cb094aa9a56f18781852e0347a5b4b3cdb32af293cd2667fb994e17d03505009643e761335eda8d56fb6240e55e877ced487c4f1901951fb8f6f7ff44241d8cee071994cf3a772f327e3a0879d8463fdf1922dca3fbccd804c6b24df64f8e34f19424836fa8bd180b951ab4f1ca1fd5987e032ceae8424ed7e218f1623562c47909bb679a0083815df8cc225dd28fe7d55ad93a0a3d9466105104e6c2d461f55b09beaf2b10541b4954757a7fc93430deacaf0ecf5aea56d5e7c7034cc60a0119f0a7a22cfa54d77dcdf19e1dd9e01fc39b5a4afcc1bc3349d22261310e00ad0907a635404af51a33dd18600f936353f1fbef7ef810a5c9d2d8dc517eaa858cb5991c0ab90ab85bf8b5b4fe1d1b11d8d66bdc0f52a2a34a90557efd45c21fbcab355d90b173c01b810d1b5dda51639f6fa62f5d4cb471cce2eebb374a1dacfbc277dbe6bf9e61d3ed68af21a496adcb3f4514232ad6a21fdca61dc9f728a2bcf228a65da29c419fdda8f381e34f70d7755402a987487248f1b3805f925018d974a2f258a8be401a80affe2f6ccf7e186ac7e3ac4b86c3f36af599990e6e47b06ad403e55a2ee882d1e672e9b20c568ce5be5b19d397a8ae27d4843938ddbf8b561b641434faf0d52d86a00832373daf53cc4d6c7a3a0abc4ef469b9eadd4a4a9fb0698b623213929bffae3db66d01ba347f1e983d5d123abe4cbe27e90c02245f0b1156b538b0c7f4f88101b6c2ef412ddd1de4c31f5846788aa240e8a2bbd45d512ee1c43e8879ac7646df2226b97afc03ed73e2a67912cbfa7e09f9389ccafac29fa67c893dd9a3e4ec3f4822b3a182d35f47cc96e6e6bd5d142bd35686f941cc98962540c5d2950ccda65f75f18c9ad7831b9e28ff94829dc098e819fcfd08d3ee3ef709af41145a64be5dcbe72f1f8e7d8e5ba4513ae0491b0841cbdecdc73f47ddf988f2f598e6528099df4d7aa89546fdd1ff16efc9ae3e6be90a3d268b8944f582957f17c1255877f7289a7c6849eda9dc33b779d21d00345242881ce6e18d0488f7943327ba952a2285d5ac92c763f86f74faf30c02ec13073f0d0b0a3186dd0693186f5d40e67fe0a34bf7d36307318e9ab3b35ccd99d35cce552d4d61509a1d9336707768d1f5ccfd14d6b5b9463ed3ae4cfa9d8c59c85ce31cccef7cd0faa2633e3b8d0f7c7fd1fbe63e2d5183e53778bb047f513563bfdf5b8bb8353938cf0cb893e67bfa72279f2a25bc05b9a3b722669dc51dca1c9bfd3b656c5edd31cf5aa30eb6a87fa2f79fca08f1f511403cd4a2af6007fae33c36d30798fe1c8963a6789d177c0efe02b9ac62072cda2713c4e8a8e33f3b8193da238ad10902f707731f30945917f114b18c73d5264af67b0b01b8f2eb12877ebd6cc989e409668c9e1729b1e7cde53da3187e38d0a1a3fdf3fddfe6575ceceec77de8c3a6f9ce18645f7a5cc87b851cd36041a89724c932e7ad3a5badd954ccaf8f6fe51c450b50792721e0eba0ad07480e3e32bf3610f45247fce3cf59faa15a74017eb018eed167fdc7792b7da59ea53893473193c6425baba18aea231c8d35227a3ba81127545637759c2496de7a6839cc76798857b2563b83f661d3f319b9f7e7edc3a6918885ee3864416ac7c119d80ef0aa3278049dc541c6675a4735c86fc59b725ba25aef40c2de57e8735858c993290ad362fdcb267669dd32a73380a462df9504c497453ea3d5d5fa39dccc869b72554a17cb136263e7b044439fc4f442a1bd7c20a94e580cb2ba4f3ce77fce68faad48643cabcbd5dd27d9daaa0b440c21d6c25abacc41978b6445ae8e517f95761e2e68c0fb5580de5a8933e77e2a5f9914acc8eef8ce540dc417a6c2a8f6775090772f6760180334422bf77e127b47f61bf2a7638159e47590a08c16c217ce3a2cb56f61147cef2391501ab05d256c90405683e55324d59dacd2504a9792a0609ca6da284ab7d380037d965084af644450630caaa3862a1ddd8f624196cd6e8e3b0b22cf7d726cfa0a5adb80a13b9eaf77cc5fc76b55635e5850587050f14c22d54a54e9ef8dc063b00e9957015f0794eb44a213c30271183da2480974984904b4a93b3ee33fdc8ca3277ff00c572e0f73409a1e12421b91f43526adf42d597f40de014b52483368b792e1e189339518f0787704167ad5d3f2e82ae9a087f52193da725608daa7124763cbd204b2acf122a5076f6efb2e4f013e009d3157696aa96e81282a53924b87498fdbb84a09bc8d88100e732d770e99dbce0c9b656a7f89976382f5b096d7ca97c4c8d5a180f167eb34a57c288a0202ff336619e06bf025621f00bd618732183b578a81d9975ba8ee7e281740cad4d6f1aeef8fb1099b2dac1ebdc2fa0b4b53b0634a7b477ea49dd02e38ccadfcdea0fe68fa173f75e4ea8dcab9566d924237541766bab9167f70134421b34518275d82daea17e4aabd521516ba96178a00a7292da210bd444449d52d297170ce431c9fa752e536279d8fa9a04e0e96319d8c235686a6a4e72f0c26d24dd71b2ceed3c4bb5d6a1604357eca608c2a54ffcfb2bd7a0e997770d21f96239cc59da18ff87eee6b7ab1e812d59f7840910b7d0baf93a98c2e76d84fd068db9b786d0078d3d7d06a53b758c9e9816df3030f0356a8740598e7623bc12720635a467e64ae09e109e23c3b7a07502be44a745f63f6a31785fdd7d2096da0383b6faf10d1a7821a452be8b37c23d75eacd69032d8219c32d87cd69e46873bb037e8811875b848ceae2a43efdeb02310751c4d9c371385f45272fe547e42075f5f878379b69926d8fb4144cdcac1fec071b2d8ec60cc8b4c71f77445345ce5e615b0013c051d2dc29ec36ba174e0bb0b405efea29ed1a20911f6f8a8c8eb83042d8b140592804819011c30a3c9a9b0be2c62aea6bece2865dadb1b0c81a49a8143ef4cf0114809b342cab960a5fe89846158cc02b3d162eaf2309d296c1fe536daaae076066fe91f0b85c532e1e1004977ed42a8e3bc31ed9b1e37d87b1ffa596e5f787fbfcc98fa2ae3e1be8fefa733f565d670e23faa701f54e0010bcbe20d520ea33d417e928e00c44415ef0b6b81d73c4880a02f1f8ef84b7030a126e9d534a793187cc2c812523ef97f8da167f311f4f2340e8fafe21d2a743c492bb2b6a40b3741dc245afb4594d6a99b2b611f694023ef2326d8c518304e71efa8ddd13918a66bd902a40d78d989806563296b022bb5ad919aecd51fdb7188ad215d0c843f83fb0be7503314956be547ef7df40a8945fb8e74b398f8ab28385f00d6180253ebbd28d95cbab9683d4938be914576f35fad7813a86e4b80656a39f3f62e0af19a639661b1a417fb1c0f965b7087edbd9bd0bb6379180501f3f77a06e11b30af30dfb7ca5a1aa7584ddc24dfc5f51d0545c504ecaafb95fd93b9d506141c3628bfa85319459193aa040049aeb21cc95a82fe319bf0887d2183f7a545673167dd1222a264ab8421533f36a974ada01cc813a138bd0b38d3449f4f9e7866b1502df683f8661044cf4142fee54c342371a3c735bc3b5272e2d5ba29c1fabc3b97ff60f1dd610a3cb97136bd4a49ad5d05bbbc556f36d40d23088a0c492183a43bc82a37de99a7e0dae87317146f30cfe723050547525c18abea23a8334cf5865506c838e2bdf6a6f4ecac04ff40706ba54911b03a2590babc9f0503b2108be7774d0497a0b8c5f2e1980d6eca04414e74aec6a4e25f9148bf2fb87d2c3d2e44d5b0c8fd0a2675f78e5af1d4ccc61c53b5d484c7a2530cb2938f516043eaf0787becedbf655f1ab72205605a2efa810c71fb73ef7340a85272b5359b943832445e0789b19d9b490344786abb142d1db5ac9173aef8daed4996c2c7a67bf76d4d3c5043b76c657477984b841b65630a35ac28ec58a621c587740935bf6a04c7bc44bb0c463907fc860370af9ec90e525ca136b5997fb4e6ec41253545e1d2f31f49c45eef63bab7f6295b2954ce7b77e1b922e526a536dfa7679c1e71d9d27bf33f273adcb5bb68155e31952793c404eafcebfa60da58ee795ccfbf88f4a106dcaafe5fdb4f1d52afc679dda78955ce4e896dda8eb32f040364c129aa686c7ed8f9c48fed6a2c8787dce7086ad53a6bd78eba5afb99c98e71f0a0c37dd4d651983817d89699d06820041b77c9a51c42f1215b2d049f7378d9f6f5c3d069044dc4add9f85961114650b0bda1471bdf02cf85928afe4871e59ce20b9b04e2c2cfb92b43f82fd865192d57b674f8aff070d37da6c3d3f575f60c08c3a0ca8115e68192b49746bd949487317c25ddc433deb73cf5b63c2dfcec1c9ff1053095013bf091db38dc2d88b5fbcb86e5a7da182f6c7fa645d88693fff01a38f18a4866360e588421155eebc20f46522759f3a3cd93e1316fba873534a4d4d2aee4d0e3493fb404d8ed3e631c80b298699234015770bf7c85091949c2ce9802ae73676f8521068412b2f2fde6aaa437d9f370318fe802eb5f13730583ac3af41c38fc488a6bef647c3174b5d7119cfff5b233735feade365d20d224ba8de8d577c626106dbe3723fb8967ba462c31b635b0cf733092bb276ced197e95d94758ac9ea3ed1da8c508dc78dc7fbf6ec205389d0704fd9e281a672e3dd4153d9bbce24e1dc43ae8c6d2012a600e445e22d1a30a90e6f8158d50f15a6cae4ccb120a3e66355e278b55548f93097a7889838624aff3dc7cbdc6ab7b5797a3740124f362b068f176f3fb11d4974267557e458804cc89159a656629234ef94ae9ef1eadac33886b42c36d6f20e1dd2b5fa8d1b3f12c01616e92bcff6a966d8510f2e21e3fd41db049e6d3cecebeb97521d64364a99e5a07e9f6ca24274e9ac3a33a8afd8b165721bf88aeb3c38e58eb232329473d59fec72d1662b4e9961ae1ed7a8165469f8add3a6bd81f8c6608ec71958a0a6e623382d5098d15e5bc37a5296420e3d26533c855e3a37b88335d8f460ac492798dc878d35f9e51d266635531d0c7f2f3072ae8050e3b2ec6c0f250ad8b03c1107257b0db7fdea44d80a3a86f5e51f05fe725bb5e4f779f08dd7ee955878a07406d162a28d671524d73286948c6c3dbaabba73fd02cb273386d3176531a45a680cc3a3831cd7f83c850ec813bd73b48db31c5c91ac6459a068976e60469122eeacf026345f9abba0aac2284e64bc3c9e05d93c68a97b9a057dd462728423bf4e85ac7e1d94ae9cb5db7d55a3d4ff7cd81d67a77c0c46d29e42a62f1e146f85430f633b1b2bc5d2c757e9f742d5e9819da6493d3eb4358ced895eaefcd4dcf5f6dba0f07f3bf19cd49fc797446dde3cfb1824c6c189b00236bdb6eb4f7d32c04e798977f3b6468a5e0566e8737c8f2e0fcea2eee85a7c2f5dd29ef3f8749bbb40132f6c5df32103f75fae633aee6c0ecf79a7c81080d6498b9b1e024af53226a3148beff105504ad739a7e09bf06b8db54cb72d6208640c90947878acff2d28aed451c117e3f242e1ba0dbc4d35aeb1dbfdd73e99f655993e265ee5ebfdfea74539e41bed4b261c154182d9353d99493c6179c91877b97b9336525c42a46447627a80260e741906dc7e0f378195a324ebc75706a5dff8c3f70460d59b493fe8a10e082326030a4ff5dfe5eec5406f8804daa74d6b8112b02bbfb6d2e411e9dcc3395bbac6bea2ebe322917eb4736678cb70af65de1b51299dec0b198245ae7288547b3b914a57001ee382dcdf3eae1a2a4f74b7c4a31b4231a5eb3de79211f090d54d42f1c61d759473b6749bbbab6e6e730dc864b3449cfa2769cf4789dcb13c00d662ca707a2927cb4eb53d11cba324bbe9871cafe58f7d1d8bf3d99bf49cfd30dc3822047ed7519bf14f522134eee975c7aa9411133914a4cbebdbcf4a986082a2ab50f2094396ae0dbf826eebd5bb22924fdda4517bff79f94c385a5de47d6b789c3c998bc6a57a8f57185d9e753ad02dbefbc5de80f830d6465a9ecfae3ec0eeb0a64fd5db21816199c02ad43ff3988227323e56cf6df18fa5e89aedb089093aaa1e518f75dfdcf69452e01e8478b1e8ad2ba927be4717c1c33d42135df12100089af6c10a0b4277e044345ca8b1775fe7913346be50e7fabbfca43dfde4af15d007530f281746cf68b4f727aff8464c082f4a1ed6ec6358edad0b2fc327e95e00be688499ec40aa350597a680a968bad62487e6d046de0133755a3f6da76d5dce77d8c26bed0f977f98f39b495fd1cfe78e30a18659d1a810ab1b13cbe2fe2357b5000f7b37fc16a0f3283244bb079a83ada8bbfc3bc1d1f65838441c3fc0a077d2a8506cc88358acf1071237912842ce44a14f6b4eb95b75584ccfa3ff12c35272550e179032321cff2e5959d16f0063bab1e93894f4704b9c5bf07f0cecf0d82104b3498cfd1b14a4cd1b00d8118e44928785650ea7ebd7843da534aaa0590d3c5cf49e9acd2be97fd837981571c0fe6b0c722a68be9f1e31742853a6b616dea74472e6362d96797dc2f0ff8ca404ee885c986fce573ef478c556972d4510bd7c94b880c8685200b3919713ed50dcb012a8475f23d60af021608e59deeb9de7d5ad94f194d16d2249af026d74f303efa33e6213264ddcbd7772e728398114788b982241e62eee2cc8a52948a853375b6e184403ed142b143c57e15c1c29ad73daffcad1994bff95fa5d723b38952a312d49044ddbbca093f000c5018edcefc6460556f334e8acdeea76b0f3f5f4d2d4252cff01f7d82aef21e6e311a0fe19670491e3b56db1cdee5b540cfc1592a0bde5bdfeda80ebb84838a8b045ad10026f1ee97fb9836172e031ba7d83fb62f27acd3a569717a28d086613417cffb465f275cada8f59712c0a911e4e9edfd502e21a78c0ad563cd9784c2228008b0bbc679489e36bd8f7c988d573e4d85e7e5983cbe912087f992a0ddc7bcaf662366348a9a02c797af87cd7a2892283ee447dc81f1e7f7a43ec8d030073d94e81a05c7290cace45ea611aeeb9611a460f4d1171bc34a1011576b078c20c5be2445bb1a866fe3104a33871294773e2f668634f81cad68cab32b7cbcfba94db688739a6f4ff853595b806632715ef12927aef5d45151837ed75c499fa06b91d3a851baee874074a0cc32336b55490d437f8983d90261ca8bc47ea657a2788e3f73c73b979c90bc68676bbe4db953396c2b965a868b9c5cbb1e88c7adea6dd6c6fa777de78a7c6cfa6532908c091f96ac91ca2732ce0edae1ca0ecd57a508a04b9cbef177dece64a568781fb6108625c413ed9f775d195ebd0eb5c0d87837538729004db63d75758cf57fd730bf069e683664adfa2815301c55612ccda702859e33b5a76683d336f9f3aa704469cf87dfa6bd841ddb6ead19afa2911a455e792f2643bf8f950816fa7a170a9dc12fd870b7dcfab7cadfe6368f65d620c2236c53f58f4deb011bec867595e4dcd258666caf0048d751e32fb345e71e9c7fc2b2877ede97873344977163d2958580017bf49dbe226d4c9a858ff5dc0f168210b68b05b18421a21d648a4f3484dbf94bba29437416417ce75da03ec9e770a22f8511cde88048988e2850f334e1d862edb125350bbe5bc984bd4b3e5a1bf25ea1d107ed6951ad241b99dfb3068389936aaf4319b316217edbe55d2f0037793b4bbc3be27e32c9e0153589564d54c7302c9d1a24dacacb25deabc26e6cbf9aa804c2675694394535f901b0c913f6508d188283d17197df59ab3bdf8b6540d3bdca0959274f757e2fb86c2877db3606af5515b6358a958ad8d4fcc855e0c6cf8f47109fa90085ea8ee85a06a8bf7fda1511052106830566ef5c4ebc191ed9c53e78b51630cdd75a167a745f5fdcc980e0e9b2d8c91ae6c8b51b0aa8c8714932c6a1d2729c436029d9692661caee3ad87c95466888737ef3e1b4d0cb58da6a9c32619595c9bb50041ca12d443b45a4d16e8419135e2d862303a8f7363ef210c6fd6e44b91ac8b16682cf580f399af5506b816757d404e4c0347620d7936c294c78a06830f0f1110b082f92bec60c217cf157881a9e6b94b55614df9a01b17d6ad39d19610f396e18bac86baf6c7b27b99ecf67c5708766c5968606b7740eab8bc0e96f4508f09b5cc79cb7e79c873d3de37666d12c0ba7d7df469b25c8243f834873e06131058863f3a789172abbe38af6ff4fc7b7c5007bb745f470b0af6e762353b8e2c6b623ac54ddcabc9b7eaca528787fdd4d4f0fd4ca32e3878d8d29732e007d1f8b832dff0a62222a1308e83c3732fa086266ba8694b846da5f6360f8930798227910088c1acd2b1d933ad36f75f8ea3e16f9bc3358fe7c8d1a099688d269593c6822bb64337839f49f08664bafca14bf279edfe51ebf2e26de6343e41f3b2b23fd511180525e1f33882178a41691601a53d19f43239d5b439d30fc0d74efafbbbd47101d716a5bbae00d9dae2fecb00a6fa864d3f92a1024c443898ac8cbea47754563529224fb3830c63a801eae61702db243ce390eb800f7d905a5a0a757222832bca08d2d0afec3295e0f35e79d5afe056ca91c564328591990bba3e0134daa578a23579f8eb5242ff8ef49221486bc9f386fd6a86357a03f3fa24c3c9f76b60eda650ec981d781d7eb44272f8798283b6e226723bbfd8e023988f45474dba108ff2b3abddcfaec0e00b61432bb27bb639bcbf70e3dd807bc0fed811a28d2c96a31498891814cdbe6c15458e7002f161df1b9e5b3a414fd1e243e786e1c68db2621942c18bcf952405338e1c120372bd16025c0f47b0764617ef0e9e8f9180cc33d12e5c095a81caa34d6999428906e1c3ea264461bebc72663a85e587293c48b3ec4f25b6d2b3349da24b48287d6c432be0d3e78b553b3f4878c4a526215ad34a18687391beca25d48fd176ebfead7e6f2f6a5403a46d01e6bb94fa8d96ca6545f0f60b61fd6e7a1365cc6d05d7678a1b6fbcb5072518c1c8b78e616afd5bc2a7da021a08f566e72b1662a9e72a7de1cff631b20281df0bf6d81d50d1e4f0cd7cfd8f0a84395c00a43a7df1c2a884fd3a5d4afa2c00beb69761cb0967a7ac27d2c579fc5f5bd1b53f3240aa1c2acc2ca837373295d3669f6b6bb30c28ae1e6bb144a14dbf3725788e6cd5f368c354439021942097f59fd74fa748b0d4b5eb2ccbd3e06bd1bbc7d33f76c3914c06e8ce2c04238b22bbd75b65527dc3f253995c0e785b3dbb07b7bdc08ada378832a57a14d9c06ee99f4d8614c671c4f789fb51a2ea47b6a42d6e4b6236c21f165fbf2b04b87b432dfdae98d976992ffce34532b06e735b99e5a1aeaa8a8ab23c62d6a6c5d6fcbdcb6e9e9b23ef1991bb37b0647fdce3b80f9e134d019d5282706fdda24ee8ffbce45e80ee61067728d313314f253076ff51061a471167e37c323c5449597bcc616ed111b0796194db7032a3b53960a13356695972bf032e72121ab12f6b26abcc83b98384731df6ed6d4cd4e8e5b91d30b003281ffb78ff026921220b16ce6c2b6b52776cfabceae24dd1b8f90d4f39454b3da518d61eeb32bdea837de5764459cb5d48f3222c1a29b8c8c9037fe8f2912196cbba752ef16fec45977a41b44c6e58f27073a32214a4256cbfc46cc2d05cc0a16b4cbedcdadb80fc8d44e0e1fa4b96a9f60ef43772ce78dfff0f830595cd22536add338635b314c096eb6c7d61ad140aa72c446487870f8dc9b414dd360f555dc0af49972bc225a315fb60c5250552d09b5fc5bef370eda45126997dbd7e3b7972e26f3e269dd11f98389b45e5400108c54f83ee33b6e32b44d061c3ea91b3205b11aee29bcedf05b688238ef787f2cb58c3a422b2ab7177c6c5ec4bf9c1aa2f1feae5f392bbbd1e7907460ccf6f3972c5a7c5f9b7bcca4c5e48bbf7ce1e6601a18853dcbcd2658028fec66f46a9314b6d97eef032db3213a98d34211fff3140c9feb7317a1b7135a102c72b251802590442019e6634ad45e78e2b7a76defbe708c3aa78613d98385cd4331a640474c1e5e41db57550300842504647321797ff5b2b16c68c0ae04595b5438fb7ad3a3a7364b28ad366e8ac73bd39deafe2c47caa0916fa31a2f4406f8659cd44deb1902f70ef8abe49dbce2864aee06c08802f881fa36a79976bcb4fcdabbda6f3919638cb3571b2e3c6dbed41408a3bf0f9510c91c362407bef268273ecf5a4e447159090aa525ee8b8db892f46aa5f64220d2c99b0fe09a59d0b17f7de6464341ac48baf3e5476b04f76fcf9601cfbb3eb38395b51ca89856c19dcf3dc04624bff1cbe6cbe1e0296c2da456f181db4b8b74b5f954c9e3fbf8cbe0fd752e7f6e918c72bfe8c9fbfab71360d9729c96b641545ca09c1b868af84e2e95a4ca2f6062d9b4e7775044adccb666980cb56a7056bdd9db545ac2b3539a02adf28e7eb6016416bbd6be9463e489e2062453b364152e7b2f109f786611b3b4d06a9649e4858884084908a1086125d42687b9cdac33d18f449a0fdccf85c6a34eb97b2a1ed3d234d784a2a94d95adaeb7678512e589bd031f57a664f416468e924363885bb60937fe287f206e61e5c437fa4ae58d9eff4231231070eb83a51ff5d9ab3ac9793fefde543a1bdebb8621c5fe1ff0c376f0cba4b7ce1466a42f34d44175f56cc0d813b3a632b39d646f39b8393c5760724529cf2ccdca8c14ff85ea6cb52e4414623d4bbf166b88e4fc165355a73ba2f17618b7ff012907ea891a14d20276379e9de2a7ce2d90845570934927db7d0cba918dafa6d5c38e09eece1b70fba7bf33875897ff827415699ee1eae5e9ff3dfe75b93268b68df27a38c7f885c0bf3a78836bd74e5febb09b0671f8b68b183584d460713653ab288abd102e9a06f71fee4beff66759520cc158489f8e35636f5c67b6437a54639a37d959ed07f5fdc5ec01aae7ccb0087e2ce44a61647136cf0744045fbba51f553d0ab6605a447ae51f9e4d24f94ac928ebbf1e20af34c0a129b9736f134cb241f2e90d7dd0ceb16f67b9c359023134df6d272eeec92524fb5095ec73130cbbb07551154e6ac9025fb2a866e5f257781c129d3f3638fff58a3a633729ae57b992755200fadde65dbe09f546e485ce1fe1522dfac8734be7809202ff7f7229bcfb4db0c63487df00fa187e1bf716fe6ccfd5a0e795af209937615a6e2f39a042cd02516b7555c9e258fd96e6b1a395bcf3b66a12be1bfb5591430a9c87d84580508186ec6531e0afb8bfcb947af595668cc4c306b78528bf1f2fcdec7a0ee46ac1bcc665d47e5ad75969a01f2b67031283e6b873315649c03bf16abc173867ae7fa7fbec101040e41b951e18981424b240e8d4af526e3fc2b8041fc1039c1097a2fd12c7a255aadfd16e5a7a9095994081747ac3e83aadab4172193f522c7b3e7691975cf848ac849610286ca52daae4f4cd07e4b65b6d0943c0d73f46c1069ddd391f6b0a925e253f60bfb9c255d79faa3fe4b7025bafbf79fd47ad907a936b0a66a3db4ece197ccfed170c1461647eeeac33931cd46bb955e0221a77eac965b3625645ee4f235d162e34a9592665691f1b5eb858a4b442dfaf014285e913b00eba943e8c1bde1766d433af99e2b6b0c32ff71d86cc9d5a0075e2d051b299d16be7a865c1e5734d85d36a197bf8109637d1977e9815570f9aa87bcf639a884b913415393527ee399dee5197f22907a7991a0621a56abcc8822befd083efd1e9560ae324063db529d25ed3cb90b4b1f4599f8634337acd06e684260edd10bfa31e9c8ed5d459e138dbdd84a100c848a5a616bc0ceca55700319b179bb28986b7ab93321077365cd16b2cdf2d668492f12c68ba378dacceaf82dba8e83f9f503caff2b112f13a0a292093aca3653d1a7711624269f1591039fc66117dd813e432b58e50885bc36fb9ede0f7768a72d7209af3e8d1b52998cfc5edff1b9df4cfa183219526ef4932369dd7a0d4e3473d1b6a62463501a83c9fd6fc1d7bc2b0621e4254b883595adb7d18ce106876431d1040db5031ab253334fec6acd601ee52b0e5a48494c6259e468e92470989679b9dbd7ece1f3f8b8da620a45ea33990b8150cd2ed13b5c7dd6c00ae3e535d0307ad23f230997a2521b12cd857b0638406f5b05b6291c6ba6b51bd38e2e0abf2fceab460b2e82659d1af222ed16cc5a05ed8a2df8bb6008c5afdb4c9f7e01bf4b0221ce60d83b8c4dcc3b88214c0e1a2164a7acf278703d3303db2f0c319376e430bca2cb6c4d0b9e78af996eb396bbc81af0dde1f6933bd467ff846b3de5d96ba55fc77ee82c8892460bc7ec57792f235a614b489e11b267a5d99ec1ac7495c2fbb774080f197a2b36ee335dec7d57e0a0c66416ed43e90c740ffbe71fb951fded7019406b3c774afb29800aedeeecea8d1a66e08d5c7e37678a279d4929f6de3180730b4bccb56848860362fa4b6b94102daff2a26e8a746d7f499f769dd5b525447e1824973926e1006bd63fe697c51c247c105f491ac06899ad1c77a606d2934803398caf7dd5c04905fe3d22388be9ef86ac212abf7449e45d57cb646ac1eaaa461bbb33e39dc8b08b274f5447b425eb2f36810ac2fbdfdbe1dd3c9149b429fb06a62f09f8f7b69cb04c61a3adc6fc16aa34d0357d860f6fdcfb6953b3c4c2ecd81c4c85e716891269afb72068af4fa81830240c46cae99ac2302d51b147c841fd6bd6575ffe1a2aeb8c35bd48facaeac17cd70f10304a2808d383bf22954b89182c846ab1386941074338f9d3a06476bcb949a1b8226c50c1593c74e5dd3b7ad63a1e9fdd92cd13448586cf7a4409bd77014145a8b58d4758b9aaf779f0f8596d7b5b903ab4b8e17204c9598f39ef8fa9c1ded08b26d3c032baa0d6e54acfbd24ee93c5475880b64aa9521fcc7b893308d2e500650a102d313aa0264b166c32aae1cd324ab92d34ba63e864913a03f1c9671e77f83da35d61218e1f0070ad94b109c56105361cefc0403f0e5e8cce8c51dade2c7cef8b1d35a74125cc2b0bfc0690d182d65a877749417ebefad82705f05f5e7b1fb5a5a538857bc63f0e5f71fad774e1f1e47bdf68777a4307b6bd626a9e7faba0f4e79b8bf817f983865602bcf3338e0d1297996fc446fb0b5c410e5a6dc04333b85efa2c21110e6faa41332cad9ac871c27795798b22b47b32006194a2ca8c0be8f12064baa01f88e7e586bc29c0abd9700a96f69eb2568a829ec5d6cf5ac77e4231ba23674f4d0e12b083e06f690e68ae128596f00b78630a3c8d8d00a0ba7ebaa340a05d364b95cc34462931a01113ade65d5b9e613b80431e469b0efbeaf6700e035270b34db59d76ccc28d01d55e9938a6aec5e9c11fb99979813ea7e363603ba85f445af3491adfba752c8f3bfc47c2572836db25bce187cf3f15e57623602e4647acb6874662f2638b9694de3de72a5bca7ce4e54f65f29756dfde1a19961ef5ad39574da32d29e65c70ffad9d0da6ad8ae4b09c472294fd09a6bbbd214decadf1d5cf44df29d6569ae8686ffd33d81be69cb79d89558e680a2655c41e8aeea570d1b8b2595629f355ec7af519657f4b0b526b26ef2c0a09bca16b92ccbac6aa3d56240691c4f25180443ed7e38654b41c4715ecffdd45af9cd60d69abec864c7609c652c48c0ead1c99c8c152f42a6ee40cc53ffdaf71903284d2c38889f39b713b47b2e94d9b25554100356b00ff0b8eef7819d768c2e307b5c205560c0e293c221436d9f90693e48b5297145f06219446d915a46d1e59285b99525184278c3f791faa9c3ffc94e615a2089f3c39cd78d8295890e18574b6000df76b8a4713e14834d18c5e6ff8ceaf0df644cbe948401d5e82b13f40fa58e57c4c3b1ca8a27c41bf1b46ca0784c5ae357153ac8701a886c778989d04d4daad67bd2f","isRememberEnabled":true,"rememberDurationInDays":30,"staticryptSaltUniqueVariableName":"e06b548b27a7e7d8dcac8c756dd3f2bc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
